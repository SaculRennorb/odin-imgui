package imgui

// dear imgui, v1.91.7 WIP
// (main code and documentation)

// Help:
// - See links below.
// - Call and read ImGui::ShowDemoWindow() in imgui_demo.cpp. All applications in examples/ are doing that.
// - Read top of imgui.cpp for more details, links and comments.

// Resources:
// - FAQ ........................ https://dearimgui.com/faq (in repository as docs/FAQ.md)
// - Homepage ................... https://github.com/ocornut/imgui
// - Releases & changelog ....... https://github.com/ocornut/imgui/releases
// - Gallery .................... https://github.com/ocornut/imgui/issues?q=label%3Agallery (please post your screenshots/video there!)
// - Wiki ....................... https://github.com/ocornut/imgui/wiki (lots of good stuff there)
//   - Getting Started            https://github.com/ocornut/imgui/wiki/Getting-Started (how to integrate in an existing app by adding ~25 lines of code)
//   - Third-party Extensions     https://github.com/ocornut/imgui/wiki/Useful-Extensions (ImPlot & many more)
//   - Bindings/Backends          https://github.com/ocornut/imgui/wiki/Bindings (language bindings, backends for various tech/engines)
//   - Glossary                   https://github.com/ocornut/imgui/wiki/Glossary
//   - Debug Tools                https://github.com/ocornut/imgui/wiki/Debug-Tools
//   - Software using Dear ImGui  https://github.com/ocornut/imgui/wiki/Software-using-dear-imgui
// - Issues & support ........... https://github.com/ocornut/imgui/issues
// - Test Engine & Automation ... https://github.com/ocornut/imgui_test_engine (test suite, test engine to automate your apps)

// For first-time users having issues compiling/linking/running/loading fonts:
// please post in https://github.com/ocornut/imgui/discussions if you cannot find a solution in resources above.
// Everything else should be asked in 'Issues'! We are building a database of cross-linked knowledge there.

// Copyright (c) 2014-2025 Omar Cornut
// Developed by Omar Cornut and every direct or indirect contributors to the GitHub.
// See LICENSE.txt for copyright and licensing details (standard MIT License).
// This library is free but needs your support to sustain development and maintenance.
// Businesses: you can support continued development via B2B invoiced technical support, maintenance and sponsoring contracts.
// PLEASE reach out at omar AT dearimgui DOT com. See https://github.com/ocornut/imgui/wiki/Funding
// Businesses: you can also purchase licenses for the Dear ImGui Automation/Test Engine.

// It is recommended that you don't modify imgui.cpp! It will become difficult for you to update the library.
// Note that 'ImGui::' being a namespace, you can add functions into the namespace from your own source files, without
// modifying imgui.h or imgui.cpp. You may include imgui_internal.h to access internal data structures, but it doesn't
// come with any guarantee of forward compatibility. Discussing your changes on the GitHub Issue Tracker may lead you
// to a better solution or official support for them.

/*

Index of this file:

DOCUMENTATION

- MISSION STATEMENT
- CONTROLS GUIDE
- PROGRAMMER GUIDE
  - READ FIRST
  - HOW TO UPDATE TO A NEWER VERSION OF DEAR IMGUI
  - GETTING STARTED WITH INTEGRATING DEAR IMGUI IN YOUR CODE/ENGINE
  - HOW A SIMPLE APPLICATION MAY LOOK LIKE
  - HOW A SIMPLE RENDERING FUNCTION MAY LOOK LIKE
- API BREAKING CHANGES (read me when you update!)
- FREQUENTLY ASKED QUESTIONS (FAQ)
  - Read all answers online: https://www.dearimgui.com/faq, or in docs/FAQ.md (with a Markdown viewer)

CODE
(search for "[SECTION]" in the code to find them)

// [SECTION] INCLUDES
// [SECTION] FORWARD DECLARATIONS
// [SECTION] CONTEXT AND MEMORY ALLOCATORS
// [SECTION] USER FACING STRUCTURES (ImGuiStyle, ImGuiIO, ImGuiPlatformIO)
// [SECTION] MISC HELPERS/UTILITIES (Geometry functions)
// [SECTION] MISC HELPERS/UTILITIES (String, Format, Hash functions)
// [SECTION] MISC HELPERS/UTILITIES (File functions)
// [SECTION] MISC HELPERS/UTILITIES (ImText* functions)
// [SECTION] MISC HELPERS/UTILITIES (Color functions)
// [SECTION] ImGuiStorage
// [SECTION] ImGuiTextFilter
// [SECTION] ImGuiTextBuffer, ImGuiTextIndex
// [SECTION] ImGuiListClipper
// [SECTION] STYLING
// [SECTION] RENDER HELPERS
// [SECTION] INITIALIZATION, SHUTDOWN
// [SECTION] MAIN CODE (most of the code! lots of stuff, needs tidying up!)
// [SECTION] ID STACK
// [SECTION] INPUTS
// [SECTION] ERROR CHECKING, STATE RECOVERY
// [SECTION] ITEM SUBMISSION
// [SECTION] LAYOUT
// [SECTION] SCROLLING
// [SECTION] TOOLTIPS
// [SECTION] POPUPS
// [SECTION] WINDOW FOCUS
// [SECTION] KEYBOARD/GAMEPAD NAVIGATION
// [SECTION] DRAG AND DROP
// [SECTION] LOGGING/CAPTURING
// [SECTION] SETTINGS
// [SECTION] LOCALIZATION
// [SECTION] VIEWPORTS, PLATFORM WINDOWS
// [SECTION] DOCKING
// [SECTION] PLATFORM DEPENDENT HELPERS
// [SECTION] METRICS/DEBUGGER WINDOW
// [SECTION] DEBUG LOG WINDOW
// [SECTION] OTHER DEBUG TOOLS (ITEM PICKER, ID STACK TOOL)

*/

//-----------------------------------------------------------------------------
// DOCUMENTATION
//-----------------------------------------------------------------------------

/*

 MISSION STATEMENT
 =================

 - Easy to use to create code-driven and data-driven tools.
 - Easy to use to create ad hoc short-lived tools and long-lived, more elaborate tools.
 - Easy to hack and improve.
 - Minimize setup and maintenance.
 - Minimize state storage on user side.
 - Minimize state synchronization.
 - Portable, minimize dependencies, run on target (consoles, phones, etc.).
 - Efficient runtime and memory consumption.

 Designed primarily for developers and content-creators, not the typical end-user!
 Some of the current weaknesses (which we aim to address in the future) includes:

 - Doesn't look fancy.
 - Limited layout features, intricate layouts are typically crafted in code.


 CONTROLS GUIDE
 ==============

 - MOUSE CONTROLS
   - Mouse wheel:                   Scroll vertically.
   - SHIFT+Mouse wheel:             Scroll horizontally.
   - Click [X]:                     Close a window, available when 'bool* p_open' is passed to Begin().
   - Click ^, Double-Click title:   Collapse window.
   - Drag on corner/border:         Resize window (double-click to auto fit window to its contents).
   - Drag on any empty space:       Move window (unless io.ConfigWindowsMoveFromTitleBarOnly = true).
   - Left-click outside popup:      Close popup stack (right-click over underlying popup: Partially close popup stack).

 - TEXT EDITOR
   - Hold SHIFT or Drag Mouse:      Select text.
   - CTRL+Left/Right:               Word jump.
   - CTRL+Shift+Left/Right:         Select words.
   - CTRL+A or Double-Click:        Select All.
   - CTRL+X, CTRL+C, CTRL+V:        Use OS clipboard.
   - CTRL+Z, CTRL+Y:                Undo, Redo.
   - ESCAPE:                        Revert text to its original value.
   - On OSX, controls are automatically adjusted to match standard OSX text editing 2ts and behaviors.

 - KEYBOARD CONTROLS
   - Basic:
     - Tab, SHIFT+Tab               Cycle through text editable fields.
     - CTRL+Tab, CTRL+Shift+Tab     Cycle through windows.
     - CTRL+Click                   Input text into a Slider or Drag widget.
   - Extended features with `io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard`:
     - Tab, SHIFT+Tab:              Cycle through every items.
     - Arrow keys                   Move through items using directional navigation. Tweak value.
     - Arrow keys + Alt, Shift      Tweak slower, tweak faster (when using arrow keys).
     - Enter                        Activate item (prefer text input when possible).
     - Space                        Activate item (prefer tweaking with arrows when possible).
     - Escape                       Deactivate item, leave child window, close popup.
     - Page Up, Page Down           Previous page, next page.
     - Home, End                    Scroll to top, scroll to bottom.
     - Alt                          Toggle between scrolling layer and menu layer.
     - CTRL+Tab then Ctrl+Arrows    Move window. Hold SHIFT to resize instead of moving.
   - Output when ImGuiConfigFlags_NavEnableKeyboard set,
     - io.WantCaptureKeyboard flag is set when keyboard is claimed.
     - io.NavActive: true when a window is focused and it doesn't have the ImGuiWindowFlags_NoNavInputs flag set.
     - io.NavVisible: true when the navigation cursor is visible (usually goes to back false when mouse is used).

 - GAMEPAD CONTROLS
   - Enable with 'io.ConfigFlags |= ImGuiConfigFlags_NavEnableGamepad'.
   - Particularly useful to use Dear ImGui on a console system (e.g. PlayStation, Switch, Xbox) without a mouse!
   - Download controller mapping PNG/PSD at http://dearimgui.com/controls_sheets
   - Backend support: backend needs to:
      - Set 'io.BackendFlags |= ImGuiBackendFlags_HasGamepad' + call io.AddKeyEvent/AddKeyAnalogEvent() with ImGuiKey.Gamepad_XXX keys.
      - For analog values (0.0 to 1.0), backend is responsible to handling a dead-zone and rescaling inputs accordingly.
        Backend code will probably need to transform your raw inputs (such as e.g. remapping your 0.2..0.9 raw input range to 0.0..1.0 imgui range, etc.).
   - If you need to share inputs between your game and the Dear ImGui interface, the easiest approach is to go all-or-nothing,
     with a buttons combo to toggle the target. Please reach out if you think the game vs navigation input sharing could be improved.

 - REMOTE INPUTS SHARING & MOUSE EMULATION
   - PS4/PS5 users: Consider emulating a mouse cursor with DualShock touch pad or a spare analog stick as a mouse-emulation fallback.
   - Consoles/Tablet/Phone users: Consider using a Synergy 1.x server (on your PC) + run examples/libs/synergy/uSynergy.c (on your console/tablet/phone app)
     in order to share your PC mouse/keyboard.
   - See https://github.com/ocornut/imgui/wiki/Useful-Extensions#remoting for other remoting solutions.
   - On a TV/console system where readability may be lower or mouse inputs may be awkward, you may want to set the io.ConfigNavMoveSetMousePos flag.
     Enabling io.ConfigNavMoveSetMousePos + ImGuiBackendFlags_HasSetMousePos instructs Dear ImGui to move your mouse cursor along with navigation movements.
     When enabled, the NewFrame() function may alter 'io.MousePos' and set 'io.WantSetMousePos' to notify you that it wants the mouse cursor to be moved.
     When that happens your backend NEEDS to move the OS or underlying mouse cursor on the next frame. Some of the backends in examples/ do that.
     (If you set the NavEnableSetMousePos flag but don't honor 'io.WantSetMousePos' properly, Dear ImGui will misbehave as it will see your mouse moving back & forth!)
     (In a setup when you may not have easy control over the mouse cursor, e.g. uSynergy.c doesn't expose moving remote mouse cursor, you may want
     to set a boolean to ignore your other external mouse positions until the external source is moved again.)


 PROGRAMMER GUIDE
 ================

 READ FIRST
 ----------
 - Remember to check the wonderful Wiki (https://github.com/ocornut/imgui/wiki)
 - Your code creates the UI every frame of your application loop, if your code doesn't run the UI is gone!
   The UI can be highly dynamic, there are no construction or destruction steps, less superfluous
   data retention on your side, less state duplication, less state synchronization, fewer bugs.
 - Call and read ShowDemoWindow() for demo code demonstrating most features.
   Or browse https://pthom.github.io/imgui_manual_online/manual/imgui_manual.html for interactive web version.
 - The library is designed to be built from sources. Avoid pre-compiled binaries and packaged versions. See imconfig.h to configure your build.
 - Dear ImGui is an implementation of the IMGUI paradigm (immediate-mode graphical user interface, a term coined by Casey Muratori).
   You can learn about IMGUI principles at http://www.johno.se/book/imgui.html, http://mollyrocket.com/861 & more links in Wiki.
 - Dear ImGui is a "single pass" rasterizing implementation of the IMGUI paradigm, aimed at ease of use and high-performances.
   For every application frame, your UI code will be called only once. This is in contrast to e.g. Unity's implementation of an IMGUI,
   where the UI code is called multiple times ("multiple passes") from a single entry point. There are pros and cons to both approaches.
 - Our origin is on the top-left. In axis aligned bounding boxes, Min = top-left, Max = bottom-right.
 - Please make sure you have asserts enabled (IM_ASSERT redirects to assert() by default, but can be redirected).
   If you get an assert, read the messages and comments around the assert.
 - This codebase aims to be highly optimized:
   - A typical idle frame should never call malloc/free.
   - We rely on a maximum of constant-time or O(N) algorithms. Limiting searches/scans as much as possible.
   - We put particular energy in making sure performances are decent with typical "Debug" build settings as well.
     Which mean we tend to avoid over-relying on "zero-cost abstraction" as they aren't zero-cost at all.
 - This codebase aims to be both highly opinionated and highly flexible:
   - This code works because of the things it choose to solve or not solve.
   - C++: this is a pragmatic C-ish codebase: we don't use fancy C++ features, we don't include C++ headers,
     and  is a namespace. We rarely use member functions (and when we did, I am mostly regretting it now).
     This is to increase compatibility, increase maintainability and facilitate use from other languages.
   - C++: ImVec2/ImVec4 do not expose math operators by default, because it is expected that you use your own math types.
     See FAQ "How can I use my own math types instead of ImVec2/ImVec4?" for details about setting up imconfig.h for that.
     We can can optionally export math operators for ImVec2/ImVec4 using IMGUI_DEFINE_MATH_OPERATORS, which we use internally.
   - C++: pay attention that ImVector<> manipulates plain-old-data and does not honor construction/destruction
     (so don't use ImVector in your code or at our own risk!).
   - Building: We don't use nor mandate a build system for the main library.
     This is in an effort to ensure that it works in the real world aka with any esoteric build setup.
     This is also because providing a build system for the main library would be of little-value.
     The build problems are almost never coming from the main library but from specific backends.


 HOW TO UPDATE TO A NEWER VERSION OF DEAR IMGUI
 ----------------------------------------------
 - Update submodule or copy/overwrite every file.
 - About imconfig.h:
   - You may modify your copy of imconfig.h, in this case don't overwrite it.
   - or you may locally branch to modify imconfig.h and merge/rebase latest.
   - or you may '#define IMGUI_USER_CONFIG "my_config_file.h"' globally from your build system to
     specify a custom path for your imconfig.h file and instead not have to modify the default one.

 - Overwrite all the sources files except for imconfig.h (if you have modified your copy of imconfig.h)
 - Or maintain your own branch where you have imconfig.h modified as a top-most commit which you can regularly rebase over "master".
 - You can also use '#define IMGUI_USER_CONFIG "my_config_file.h" to redirect configuration to your own file.
 - Read the "API BREAKING CHANGES" section (below). This is where we list occasional API breaking changes.
   If a function/type has been renamed / or marked obsolete, try to fix the name in your code before it is permanently removed
   from the public API. If you have a problem with a missing function/symbols, search for its name in the code, there will
   likely be a comment about it. Please report any issue to the GitHub page!
 - To find out usage of old API, you can add '#define IMGUI_DISABLE_OBSOLETE_FUNCTIONS' in your configuration file.
 - Try to keep your copy of Dear ImGui reasonably up to date!


 GETTING STARTED WITH INTEGRATING DEAR IMGUI IN YOUR CODE/ENGINE
 ---------------------------------------------------------------
 - See https://github.com/ocornut/imgui/wiki/Getting-Started.
 - Run and study the examples and demo in imgui_demo.cpp to get acquainted with the library.
 - In the majority of cases you should be able to use unmodified backends files available in the backends/ folder.
 - Add the Dear ImGui source files + selected backend source files to your projects or using your preferred build system.
   It is recommended you build and statically link the .cpp files as part of your project and NOT as a shared library (DLL).
 - You can later customize the imconfig.h file to tweak some compile-time behavior, such as integrating Dear ImGui types with your own maths types.
 - When using Dear ImGui, your programming IDE is your friend: follow the declaration of variables, functions and types to find comments about them.
 - Dear ImGui never touches or knows about your GPU state. The only function that knows about GPU is the draw function that you provide.
   Effectively it means you can create widgets at any time in your code, regardless of considerations of being in "update" vs "render"
   phases of your own application. All rendering information is stored into command-lists that you will retrieve after calling Render().
 - Refer to the backends and demo applications in the examples/ folder for instruction on how to setup your code.
 - If you are running over a standard OS with a common graphics API, you should be able to use unmodified imgui_impl_*** files from the examples/ folder.


 HOW A SIMPLE APPLICATION MAY LOOK LIKE
 --------------------------------------
 EXHIBIT 1: USING THE EXAMPLE BACKENDS (= imgui_impl_XXX.cpp files from the backends/ folder).
 The sub-folders in examples/ contain examples applications following this structure.

     // Application init: create a dear imgui context, setup some options, load fonts
     CreateContext();
     io := GetIO();
     // TODO: Set optional io.ConfigFlags values, e.g. 'io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard' to enable keyboard controls.
     // TODO: Fill optional fields of the io structure later.
     // TODO: Load TTF/OTF fonts if you don't want to use the default font.

     // Initialize helper Platform and Renderer backends (here we are using imgui_impl_win32.cpp and imgui_impl_dx11.cpp)
     ImGui_ImplWin32_Init(hwnd);
     ImGui_ImplDX11_Init(g_pd3dDevice, g_pd3dDeviceContext);

     // Application main loop
     for (true)
     {
         // Feed inputs to dear imgui, start new frame
         ImGui_ImplDX11_NewFrame();
         ImGui_ImplWin32_NewFrame();
         NewFrame();

         // Any application code here
         Text("Hello, world!");

         // Render dear imgui into screen
         Render();
         ImGui_ImplDX11_RenderDrawData(GetDrawData());
         g_pSwapChain.Present(1, 0);
     }

     // Shutdown
     ImGui_ImplDX11_Shutdown();
     ImGui_ImplWin32_Shutdown();
     DestroyContext();

 EXHIBIT 2: IMPLEMENTING CUSTOM BACKEND / CUSTOM ENGINE

     // Application init: create a dear imgui context, setup some options, load fonts
     CreateContext();
     io := GetIO();
     // TODO: Set optional io.ConfigFlags values, e.g. 'io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard' to enable keyboard controls.
     // TODO: Fill optional fields of the io structure later.
     // TODO: Load TTF/OTF fonts if you don't want to use the default font.

     // Build and load the texture atlas into a texture
     // (In the examples/ app this is usually done within the ImGui_ImplXXX_Init() function from one of the demo Renderer)
     width, height : i32
     pixels := nullptr;
     io.Fonts.GetTexDataAsRGBA32(&pixels, &width, &height);

     // At this point you've got the texture data and you need to upload that to your graphic system:
     // After we have created the texture, store its pointer/identifier (_in whichever format your engine uses_) in 'io.Fonts.TexID'.
     // This will be passed back to your via the renderer. Basically ImTextureID == void*. Read FAQ for details about ImTextureID.
     texture := MyEngine::CreateTextureFromMemoryPixels(pixels, width, height, TEXTURE_TYPE_RGBA32)
     io.Fonts.SetTexID((rawptr)texture);

     // Application main loop
     for (true)
     {
        // Setup low-level inputs, e.g. on Win32: calling GetKeyboardState(), or write to those fields from your Windows message handlers, etc.
        // (In the examples/ app this is usually done within the ImGui_ImplXXX_NewFrame() function from one of the demo Platform Backends)
        io.DeltaTime = 1.0/60.0;              // set the time elapsed since the previous frame (in seconds)
        io.DisplaySize.x = 1920.0;             // set the current display width
        io.DisplaySize.y = 1280.0;             // set the current display height here
        io.AddMousePosEvent(mouse_x, mouse_y);  // update mouse position
        io.AddMouseButtonEvent(0, mouse_b[0]);  // update mouse button states
        io.AddMouseButtonEvent(1, mouse_b[1]);  // update mouse button states

        // Call NewFrame(), after this point you can use ImGui::* functions anytime
        // (So you want to try calling NewFrame() as early as you can in your main loop to be able to use Dear ImGui everywhere)
        NewFrame();

        // Most of your application code here
        Text("Hello, world!");
        MyGameUpdate(); // may use any Dear ImGui functions, e.g. ImGui::Begin("My window"); ImGui::Text("Hello, world!"); ImGui::End();
        MyGameRender(); // may use any Dear ImGui functions as well!

        // Render dear imgui, swap buffers
        // (You want to try calling EndFrame/Render as late as you can, to be able to use Dear ImGui in your own game rendering code)
        EndFrame();
        Render();
        draw_data := GetDrawData();
        MyImGuiRenderFunction(draw_data);
        SwapBuffers();
     }

     // Shutdown
     DestroyContext();

 To decide whether to dispatch mouse/keyboard inputs to Dear ImGui to the rest of your application,
 you should read the 'io.WantCaptureMouse', 'io.WantCaptureKeyboard' and 'io.WantTextInput' flags!
 Please read the FAQ entry "How can I tell whether to dispatch mouse/keyboard to Dear ImGui or my application?" about this.


 HOW A SIMPLE RENDERING FUNCTION MAY LOOK LIKE
 ---------------------------------------------
 The backends in impl_impl_XXX.cpp files contain many working implementations of a rendering function.

    MyImGuiRenderFunction :: proc(draw_data : ^ImDrawData)
    {
       // TODO: Setup render state: alpha-blending enabled, no face culling, no depth testing, scissor enabled
       // TODO: Setup texture sampling state: sample with bilinear filtering (NOT point/nearest filtering). Use 'io.Fonts.Flags |= ImFontAtlasFlags_NoBakedLines;' to allow point/nearest filtering.
       // TODO: Setup viewport covering draw_data.DisplayPos to draw_data.DisplayPos + draw_data.DisplaySize
       // TODO: Setup orthographic projection matrix cover draw_data.DisplayPos to draw_data.DisplayPos + draw_data.DisplaySize
       // TODO: Setup shader: vertex { float2 pos, float2 uv, u32 color }, fragment shader sample color from 1 texture, multiply by vertex color.
       clip_off := draw_data.DisplayPos;
       for n := 0; n < draw_data.CmdListsCount; n += 1
       {
          const ImDrawList* cmd_list = draw_data.CmdLists[n];
          const ImDrawVert* vtx_buffer = cmd_list.VtxBuffer.Data;  // vertex buffer generated by Dear ImGui
          const ImDrawIdx* idx_buffer = cmd_list.IdxBuffer.Data;   // index buffer generated by Dear ImGui
          for cmd_i := 0; cmd_i < len(cmd_list.CmdBuffer); cmd_i += 1
          {
             const ImDrawCmd* pcmd = &cmd_list.CmdBuffer[cmd_i];
             if (pcmd.UserCallback)
             {
                 pcmd.UserCallback(cmd_list, pcmd);
             }
             else
             {
                 // Project scissor/clipping rectangles into framebuffer space
                 clip_min := ImVec2{pcmd.ClipRect.x - clip_off.x, pcmd.ClipRect.y - clip_off.y};
                 clip_max := ImVec2{pcmd.ClipRect.z - clip_off.x, pcmd.ClipRect.w - clip_off.y};
                 if (clip_max.x <= clip_min.x || clip_max.y <= clip_min.y)   do continue

                 // We are using scissoring to clip some objects. All low-level graphics API should support it.
                 // - If your engine doesn't support scissoring yet, you may ignore this at first. You will get some small glitches
                 //   (some elements visible outside their bounds) but you can fix that once everything else works!
                 // - Clipping coordinates are provided in imgui coordinates space:
                 //   - For a given viewport, draw_data.DisplayPos == viewport.Pos and draw_data.DisplaySize == viewport.Size
                 //   - In a single viewport application, draw_data.DisplayPos == (0,0) and draw_data.DisplaySize == io.DisplaySize, but always use GetMainViewport()->Pos/Size instead of hardcoding those values.
                 //   - In the interest of supporting multi-viewport applications (see 'docking' branch on github),
                 //     always subtract draw_data.DisplayPos from clipping bounds to convert them to your viewport space.
                 // - Note that pcmd.ClipRect contains Min+Max bounds. Some graphics API may use Min+Max, other may use Min+Size (size being Max-Min)
                 MyEngineSetScissor(clip_min.x, clip_min.y, clip_max.x, clip_max.y);

                 // The texture for the draw call is specified by pcmd.GetTexID().
                 // The vast majority of draw calls will use the Dear ImGui texture atlas, which value you have set yourself during initialization.
                 MyEngineBindTexture((MyTexture*)pcmd.GetTexID());

                 // Render 'pcmd.ElemCount/3' indexed triangles.
                 // By default the indices ImDrawIdx are 16-bit, you can change them to 32-bit in imconfig.h if your engine doesn't support 16-bit indices.
                 MyEngineDrawIndexedTriangles(pcmd.ElemCount, size_of(ImDrawIdx) == 2 ? GL_UNSIGNED_SHORT : GL_UNSIGNED_INT, idx_buffer + pcmd.IdxOffset, vtx_buffer, pcmd.VtxOffset);
             }
          }
       }
    }


 API BREAKING CHANGES
 ====================

 Occasionally introducing changes that are breaking the API. We try to make the breakage minor and easy to fix.
 Below is a change-log of API breaking changes only. If you are using one of the functions listed, expect to have to fix some code.
 When you are not sure about an old symbol or function name, try using the Search/Find function of your IDE to look for comments or references in all imgui files.
 You can read releases logs https://github.com/ocornut/imgui/releases for more details.

(Docking/Viewport Branch)
 - 2024/XX/XX (1.XXXX) - when multi-viewports are enabled, all positions will be in your natural OS coordinates space. It means that:
                          - reference to hard-coded positions such as in SetNextWindowPos(ImVec2{0,0}) are probably not what you want anymore.
                            you may use GetMainViewport()->Pos to offset hard-coded positions, e.g. SetNextWindowPos(GetMainViewport()->Pos)
                          - likewise io.MousePos and GetMousePos() will use OS coordinates.
                            If you query mouse positions to interact with non-imgui coordinates you will need to offset them, e.g. subtract GetWindowViewport()->Pos.

 - 2024/11/27 (1.91.6) - changed CRC32 table from CRC32-adler to CRC32c polynomial in order to be compatible with the result of SSE 4.2 instructions.
                         As a result, old .ini data may be partially lost (docking and tables information particularly).
                         Because some users have crafted and storing .ini data as a way to workaround limitations of the docking API, we are providing a '#define IMGUI_USE_LEGACY_CRC32_ADLER' compile-time option to keep using old CRC32 tables if you cannot afford invalidating old .ini data.
 - 2024/11/06 (1.91.5) - commented/obsoleted out pre-1.87 IO system (equivalent to using IMGUI_DISABLE_OBSOLETE_KEYIO or IMGUI_DISABLE_OBSOLETE_FUNCTIONS before)
                            - io.KeyMap[] and io.KeysDown[] are removed (obsoleted February 2022).
                            - io.NavInputs[] and ImGuiNavInput are removed (obsoleted July 2022).
                            - pre-1.87 backends are not supported:
                               - backends need to call io.AddKeyEvent(), io.AddMouseEvent() instead of writing to io.KeysDown[], io.MouseDown[] fields.
                               - backends need to call io.AddKeyAnalogEvent() for gamepad values instead of writing to io.NavInputs[] fields.
                            - for more reference:
                              - read 1.87 and 1.88 part of this section or read Changelog for 1.87 and 1.88.
                              - read https://github.com/ocornut/imgui/issues/4921
                            - if you have trouble updating a very old codebase using legacy backend-specific key codes: consider updating to 1.91.4 first, then #define IMGUI_DISABLE_OBSOLETE_KEYIO, then update to latest.
                       - obsoleted ImGuiKey.COUNT (it is unusually error-prone/misleading since valid keys don't start at 0). probably use ImGuiKey.NamedKey_BEGIN/ImGuiKey.NamedKey_END?
                       - fonts: removed const qualifiers from most font functions in prevision for upcoming font improvements.
 - 2024/10/18 (1.91.4) - renamed ImGuiCol.NavHighlight to ImGuiCol.NavCursor (for consistency with newly exposed and reworked features). Kept inline redirection enum (will obsolete).
 - 2024/10/14 (1.91.4) - moved ImGuiConfigFlags_NavEnableSetMousePos to standalone io.ConfigNavMoveSetMousePos bool.
                         moved ImGuiConfigFlags_NavNoCaptureKeyboard to standalone io.ConfigNavCaptureKeyboard bool (note the inverted value!).
                         kept legacy names (will obsolete) + code that copies settings once the first time. Dynamically changing the old value won't work. Switch to using the new value!
 - 2024/10/10 (1.91.4) - the typedef for ImTextureID now defaults to u64 instead of rawptr. (#1641)
                         this removes the requirement to redefine it for backends which are e.g. storing descriptor sets or other 64-bits structures when building on 32-bits archs. It therefore simplify various building scripts/helpers.
                         you may have compile-time issues if you were casting to 'rawptr' instead of 'ImTextureID' when passing your types to functions taking ImTextureID values, e.g. Image().
                         in doubt it is almost always better to do an intermediate rawptr cast, since it allows casting any pointer/integer type without warning:
                            - May warn:    Image((rawptr)MyTextureData, args : ..any);
                            - May warn:    Image(cast(rawptr)MyTextureData, args : ..any);
                            - Won't warn:  Image((ImTextureID)(rawptr)MyTextureData), args : ..any);
  -                      note that you can always define ImTextureID to be your own high-level structures (with dedicated constructors) if you like.
 - 2024/10/03 (1.91.3) - drags: treat v_min==v_max as a valid clamping range when != 0.0. Zero is a still special value due to legacy reasons, unless using ImGuiSliderFlags_ClampZeroRange. (#7968, #3361, #76)
                       - drags: extended behavior of ImGuiSliderFlags_AlwaysClamp to include _ClampZeroRange. It considers v_min==v_max==0.0 as a valid clamping range (aka edits not allowed).
                         although unlikely, it you wish to only clamp on text input but want v_min==v_max==0.0 to mean unclamped drags, you can use _ClampOnInput instead of _AlwaysClamp. (#7968, #3361, #76)
 - 2024/09/10 (1.91.2) - internals: using multiple overlayed ButtonBehavior() with same ID will now have io.ConfigDebugHighlightIdConflicts=true feature emit a warning. (#8030)
                         it was one of the rare case where using same ID is legal. workarounds: (1) use single ButtonBehavior() call with multiple _MouseButton flags, or (2) surround the calls with PushItemFlag(ImGuiItemFlags_AllowDuplicateId, true); ... PopItemFlag()
 - 2024/08/23 (1.91.1) - renamed ImGuiChildFlags_Border to ImGuiChildFlags_Borders for consistency. kept inline redirection flag.
 - 2024/08/22 (1.91.1) - moved some functions from ImGuiIO to ImGuiPlatformIO structure:
                            - io.GetClipboardTextFn         -> platform_io.Platform_GetClipboardTextFn + changed 'rawptr user_data' to 'ImGuiContext* ctx'. Pull your user data from platform_io.ClipboardUserData.
                            - io.SetClipboardTextFn         -> platform_io.Platform_SetClipboardTextFn + same as above line.
                            - io.PlatformOpenInShellFn      -> platform_io.Platform_OpenInShellFn (#7660)
                            - io.PlatformSetImeDataFn       -> platform_io.Platform_SetImeDataFn
                            - io.PlatformLocaleDecimalPoint -> platform_io.Platform_LocaleDecimalPoint (#7389, #6719, #2278)
                            - access those via GetPlatformIO() instead of GetIO().
                         some were introduced very recently and often automatically setup by core library and backends, so for those we are exceptionally not maintaining a legacy redirection symbol.
                       - commented the old ImageButton() signature obsoleted in 1.89 (~August 2022). As a reminder:
                            - old ImageButton() before 1.89 used ImTextureId as item id (created issue with e.g. multiple buttons in same scope, transient texture id values, opaque computation of ID)
                            - new ImageButton() since 1.89 requires an explicit 'const char* str_id'
                            - old ImageButton() before 1.89 had frame_padding' override argument.
                            - new ImageButton() since 1.89 always use style.FramePadding, which you can freely override with PushStyleVar()/PopStyleVar().
 - 2024/07/25 (1.91.0) - obsoleted GetContentRegionMax(), GetWindowContentRegionMin() and GetWindowContentRegionMax(). (see #7838 on GitHub for more info)
                         you should never need those functions. you can do everything with GetCursorScreenPos() and GetContentRegionAvail() in a more simple way.
                            - instead of:  GetWindowContentRegionMax().x - GetCursorPos().x
                            - you can use: GetContentRegionAvail().x
                            - instead of:  GetWindowContentRegionMax().x + GetWindowPos().x
                            - you can use: GetCursorScreenPos().x + GetContentRegionAvail().x // when called from left edge of window
                            - instead of:  GetContentRegionMax()
                            - you can use: GetContentRegionAvail() + GetCursorScreenPos() - GetWindowPos() // right edge in local coordinates
                            - instead of:  GetWindowContentRegionMax().x - GetWindowContentRegionMin().x
                            - you can use: GetContentRegionAvail() // when called from left edge of window
 - 2024/07/15 (1.91.0) - renamed ImGuiSelectableFlags_DontClosePopups to ImGuiSelectableFlags_NoAutoClosePopups. (#1379, #1468, #2200, #4936, #5216, #7302, #7573)
                         (internals: also renamed ImGuiItemFlags_SelectableDontClosePopup into ImGuiItemFlags_AutoClosePopups with inverted behaviors)
 - 2024/07/15 (1.91.0) - obsoleted PushButtonRepeat()/PopButtonRepeat() in favor of using new PushItemFlag(ImGuiItemFlags_ButtonRepeat, args : ..any)/PopItemFlag().
 - 2024/07/02 (1.91.0) - commented out obsolete ImGuiModFlags (renamed to ImGuiKeyChord in 1.89). (#4921, #456)
                       - commented out obsolete ImGuiModFlags_XXX values (renamed to ImGuiMod_XXX in 1.89). (#4921, #456)
                            - ImGuiModFlags_Ctrl -> ImGuiKey.Mod_Ctrl, ImGuiModFlags_Shift -> ImGuiKey.Mod_Shift etc.
 - 2024/07/02 (1.91.0) - IO, IME: renamed platform IME hook and added explicit context for consistency and future-proofness.
                            - old: io.SetPlatformImeDataFn(ImGuiViewport* viewport, ImGuiPlatformImeData* data);
                            - new: io.PlatformSetImeDataFn(ImGuiContext* ctx, ImGuiViewport* viewport, ImGuiPlatformImeData* data);
 - 2024/06/21 (1.90.9) - BeginChild: added ImGuiChildFlags_NavFlattened as a replacement for the window flag ImGuiWindowFlags_NavFlattened: the feature only ever made sense for BeginChild() anyhow.
                            - old: BeginChild("Name", size, 0, ImGuiWindowFlags_NavFlattened);
                            - new: BeginChild("Name", size, ImGuiChildFlags_NavFlattened, 0);
 - 2024/06/21 (1.90.9) - io: ClearInputKeys() (first exposed in 1.89.8) doesn't clear mouse data, newly added ClearInputMouse() does.
 - 2024/06/20 (1.90.9) - renamed ImGuiDragDropFlags_SourceAutoExpirePayload to ImGuiDragDropFlags_PayloadAutoExpire.
 - 2024/06/18 (1.90.9) - style: renamed ImGuiCol.TabActive -> ImGuiCol.TabSelected, ImGuiCol.TabUnfocused -> ImGuiCol.TabDimmed, ImGuiCol.TabUnfocusedActive -> ImGuiCol.TabDimmedSelected.
 - 2024/06/10 (1.90.9) - removed old nested structure: renaming ImGuiStorage::ImGuiStoragePair type to ImGuiStoragePair (simpler for many languages).
 - 2024/06/06 (1.90.8) - reordered ImGuiInputTextFlags values. This should not be breaking unless you are using generated headers that have values not matching the main library.
 - 2024/06/06 (1.90.8) - removed 'ImGuiButtonFlags_MouseButtonDefault_ = ImGuiButtonFlags_MouseButtonLeft', was mostly unused and misleading.
 - 2024/05/27 (1.90.7) - commented out obsolete symbols marked obsolete in 1.88 (May 2022):
                            - old: CaptureKeyboardFromApp(bool)
                            - new: SetNextFrameWantCaptureKeyboard(bool)
                            - old: CaptureMouseFromApp(bool)
                            - new: SetNextFrameWantCaptureMouse(bool)
 - 2024/05/22 (1.90.7) - inputs (internals): renamed ImGuiKeyOwner_None to ImGuiKeyOwner_NoOwner, to make use more explicit and reduce confusion with the default it is a non-zero value and cannot be the default value (never made public, but disclosing as I expect a few users caught on owner-aware inputs).
                       - inputs (internals): renamed ImGuiInputFlags_RouteGlobalLow -> ImGuiInputFlags_RouteGlobal, ImGuiInputFlags_RouteGlobal -> ImGuiInputFlags_RouteGlobalOverFocused, ImGuiInputFlags_RouteGlobalHigh -> ImGuiInputFlags_RouteGlobalHighest.
                       - inputs (internals): Shortcut(), SetShortcutRouting(): swapped last two parameters order in function signatures:
                            - old: Shortcut(ImGuiKeyChord key_chord, ImGuiID owner_id = 0, ImGuiInputFlags flags = 0);
                            - new: Shortcut(ImGuiKeyChord key_chord, ImGuiInputFlags flags = 0, ImGuiID owner_id = 0);
                       - inputs (internals): owner-aware versions of IsKeyPressed(), IsKeyChordPressed(), IsMouseClicked(): swapped last two parameters order in function signatures.
                            - old: IsKeyPressed(ImGuiKey key, ImGuiID owner_id, ImGuiInputFlags flags = 0);
                            - new: IsKeyPressed(ImGuiKey key, ImGuiInputFlags flags, ImGuiID owner_id = 0);
                            - old: IsMouseClicked(ImGuiMouseButton button, ImGuiID owner_id, ImGuiInputFlags flags = 0);
                            - new: IsMouseClicked(ImGuiMouseButton button, ImGuiInputFlags flags, ImGuiID owner_id = 0);
                         for various reasons those changes makes sense. They are being made because making some of those API public.
                         only past users of imgui_internal.h with the extra parameters will be affected. Added asserts for valid flags in various functions to detect _some_ misuses, BUT NOT ALL.
 - 2024/05/21 (1.90.7) - docking: changed signature of DockSpaceOverViewport() to add explicit dockspace id if desired. pass 0 to use old behavior. (#7611)
                           - old: DockSpaceOverViewport(const ImGuiViewport* viewport = nil, ImGuiDockNodeFlags flags = 0, args : ..any);
                           - new: DockSpaceOverViewport(ImGuiID dockspace_id = 0, const ImGuiViewport* viewport = nil, ImGuiDockNodeFlags flags = 0, args : ..any);
 - 2024/05/16 (1.90.7) - inputs: on macOS X, Cmd and Ctrl keys are now automatically swapped by io.AddKeyEvent() as this naturally align with how macOS X uses those keys.
                           - it shouldn't really affect you unless you had custom shortcut swapping in place for macOS X apps.
                           - removed ImGuiMod_Shortcut which was previously dynamically remapping to Ctrl or Cmd/Super. It is now unnecessary to specific cross-platform idiomatic shortcuts. (#2343, #4084, #5923, #456)
 - 2024/05/14 (1.90.7) - backends: SDL_Renderer2 and SDL_Renderer3 backend now take a SDL_Renderer* in their RenderDrawData() functions.
 - 2024/04/18 (1.90.6) - TreeNode: Fixed a layout inconsistency when using an empty/hidden label followed by a SameLine() call. (#7505, #282)
                           - old: TreeNode("##Hidden"); SameLine(); Text("Hello");     // <-- This was actually incorrect! BUT appeared to look ok with the default style where ItemSpacing.x == FramePadding.x * 2 (it didn't look aligned otherwise).
                           - new: TreeNode("##Hidden"); SameLine(0, 0); Text("Hello"); // <-- This is correct for all styles values.
                         with the fix, IF you were successfully using TreeNode("")+SameLine(); you will now have extra spacing between your TreeNode and the following item.
                         You'll need to change the SameLine() call to SameLine(0,0) to remove this extraneous spacing. This seemed like the more sensible fix that's not making things less consistent.
                         (Note: when using this idiom you are likely to also use ImGuiTreeNodeFlags_SpanAvailWidth).
 - 2024/03/18 (1.90.5) - merged the radius_x/radius_y parameters in ImDrawList::AddEllipse(), AddEllipseFilled() and PathEllipticalArcTo() into a single ImVec2 parameter. Exceptionally, because those functions were added in 1.90, we are not adding inline redirection functions. The transition is easy and should affect few users. (#2743, #7417)
 - 2024/03/08 (1.90.5) - inputs: more formally obsoleted GetKeyIndex() when IMGUI_DISABLE_OBSOLETE_FUNCTIONS is set. It has been unnecessary and a no-op since 1.87 (it returns the same value as passed when used with a 1.87+ backend using io.AddKeyEvent() function). (#4921)
                           - IsKeyPressed(GetKeyIndex(ImGuiKey.XXX)) -> use IsKeyPressed(ImGuiKey.XXX)
 - 2024/01/15 (1.90.2) - commented out obsolete ImGuiIO::ImeWindowHandle marked obsolete in 1.87, favor of writing to 'rawptr ImGuiViewport::PlatformHandleRaw'.
 - 2023/12/19 (1.90.1) - commented out obsolete ImGuiKey.KeyPadEnter redirection to ImGuiKey.KeypadEnter.
 - 2023/11/06 (1.90.1) - removed CalcListClipping() marked obsolete in 1.86. Prefer using ImGuiListClipper which can return non-contiguous ranges.
 - 2023/11/05 (1.90.1) - imgui_freetype: commented out ImGuiFreeType::BuildFontAtlas() obsoleted in 1.81. prefer using #define IMGUI_ENABLE_FREETYPE or see commented code for manual calls.
 - 2023/11/05 (1.90.1) - internals,columns: commented out legacy ImGuiColumnsFlags_XXX symbols redirecting to ImGuiOldColumnsFlags_XXX, obsoleted from imgui_internal.h in 1.80.
 - 2023/11/09 (1.90.0) - removed IM_OFFSETOF() macro in favor of using offset_of() available in C++11. Kept redirection define (will obsolete).
 - 2023/11/07 (1.90.0) - removed BeginChildFrame()/EndChildFrame() in favor of using BeginChild() with the ImGuiChildFlags_FrameStyle flag. kept inline redirection function (will obsolete).
                         those functions were merely PushStyle/PopStyle helpers, the removal isn't so much motivated by needing to add the feature in BeginChild(), but by the necessity to avoid BeginChildFrame() signature mismatching BeginChild() signature and features.
 - 2023/11/02 (1.90.0) - BeginChild: upgraded 'bool border = true' parameter to 'ImGuiChildFlags flags' type, added ImGuiChildFlags_Border equivalent. As with our prior "bool-to-flags" API updates, the ImGuiChildFlags_Border value is guaranteed to be == true forever to ensure a smoother transition, meaning all existing calls will still work.
                           - old: BeginChild("Name", size, true)
                           - new: BeginChild("Name", size, ImGuiChildFlags_Border)
                           - old: BeginChild("Name", size, false)
                           - new: BeginChild("Name", size) or BeginChild("Name", 0) or BeginChild("Name", size, ImGuiChildFlags_None)
                         **AMEND FROM THE FUTURE: from 1.91.1, 'ImGuiChildFlags_Border' is called 'ImGuiChildFlags_Borders'**
 - 2023/11/02 (1.90.0) - BeginChild: added child-flag ImGuiChildFlags_AlwaysUseWindowPadding as a replacement for the window-flag ImGuiWindowFlags_AlwaysUseWindowPadding: the feature only ever made sense for BeginChild() anyhow.
                           - old: BeginChild("Name", size, 0, ImGuiWindowFlags_AlwaysUseWindowPadding);
                           - new: BeginChild("Name", size, ImGuiChildFlags_AlwaysUseWindowPadding, 0);
 - 2023/09/27 (1.90.0) - io: removed io.MetricsActiveAllocations introduced in 1.63. Same as 'g.DebugMemAllocCount - g.DebugMemFreeCount' (still displayed in Metrics, unlikely to be accessed by end-user).
 - 2023/09/26 (1.90.0) - debug tools: Renamed ShowStackToolWindow() ("Stack Tool") to ShowIDStackToolWindow() ("ID Stack Tool"), as earlier name was misleading. Kept inline redirection function. (#4631)
 - 2023/09/15 (1.90.0) - ListBox, Combo: changed signature of "name getter" callback in old one-liner ListBox()/Combo() apis. kept inline redirection function (will obsolete).
                           - old: bool Combo(const char* label, int* current_item, bool (*getter)(rawptr user_data, int idx, const char** out_text), args : ..any)
                           - new: bool Combo(const char* label, int* current_item, const char* (*getter)(rawptr user_data, int idx), args : ..any);
                           - old: bool ListBox(const char* label, int* current_item, bool (*getting)(rawptr user_data, int idx, const char** out_text), args : ..any);
                           - new: bool ListBox(const char* label, int* current_item, const char* (*getter)(rawptr user_data, int idx), args : ..any);
 - 2023/09/08 (1.90.0) - commented out obsolete redirecting functions:
                           - GetWindowContentRegionWidth()  -> use GetWindowContentRegionMax().x - GetWindowContentRegionMin().x. Consider that generally 'GetContentRegionAvail().x' is more useful.
                           - ImDrawCornerFlags_XXX          -> use ImDrawFlags_RoundCornersXXX flags. Read 1.82 Changelog for details + grep commented names in sources.
                       - commented out runtime support for hardcoded ~0 or 0x01..0x0F rounding flags values for AddRect()/AddRectFilled()/PathRect()/AddImageRounded() -> use ImDrawFlags_RoundCornersXXX flags. Read 1.82 Changelog for details
 - 2023/08/25 (1.89.9) - clipper: Renamed IncludeRangeByIndices() (also called ForceDisplayRangeByIndices() before 1.89.6) to IncludeItemsByIndex(). Kept inline redirection function. Sorry!
 - 2023/07/12 (1.89.8) - ImDrawData: CmdLists now owned, changed from ImDrawList** to ImVector<ImDrawList*>. Majority of users shouldn't be affected, but you cannot compare to nil nor reassign manually anymore. Instead use AddDrawList(). (#6406, #4879, #1878)
 - 2023/06/28 (1.89.7) - overlapping items: obsoleted 'SetItemAllowOverlap()' (called after item) in favor of calling 'SetNextItemAllowOverlap()' (called before item). 'SetItemAllowOverlap()' didn't and couldn't work reliably since 1.89 (2022-11-15).
 - 2023/06/28 (1.89.7) - overlapping items: renamed 'ImGuiTreeNodeFlags_AllowItemOverlap' to 'ImGuiTreeNodeFlags_AllowOverlap', 'ImGuiSelectableFlags_AllowItemOverlap' to 'ImGuiSelectableFlags_AllowOverlap'. Kept redirecting enums (will obsolete).
 - 2023/06/28 (1.89.7) - overlapping items: IsItemHovered() now by default return false when querying an item using AllowOverlap mode which is being overlapped. Use ImGuiHoveredFlags_AllowWhenOverlappedByItem to revert to old behavior.
 - 2023/06/28 (1.89.7) - overlapping items: Selectable and TreeNode don't allow overlap when active so overlapping widgets won't appear as hovered. While this fixes a common small visual issue, it also means that calling IsItemHovered() after a non-reactive elements - e.g. Text() - overlapping an active one may fail if you don't use IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByActiveItem). (#6610)
 - 2023/06/20 (1.89.7) - moved io.HoverDelayShort/io.HoverDelayNormal to style.HoverDelayShort/style.HoverDelayNormal. As the fields were added in 1.89 and expected to be left unchanged by most users, or only tweaked once during app initialization, we are exceptionally accepting the breakage.
 - 2023/05/30 (1.89.6) - backends: renamed "imgui_impl_sdlrenderer.cpp" to "imgui_impl_sdlrenderer2.cpp" and "imgui_impl_sdlrenderer.h" to "imgui_impl_sdlrenderer2.h". This is in prevision for the future release of SDL3.
 - 2023/05/22 (1.89.6) - listbox: commented out obsolete/redirecting functions that were marked obsolete more than two years ago:
                           - ListBoxHeader()  -> use BeginListBox() (note how two variants of ListBoxHeader() existed. Check commented versions in imgui.h for reference)
                           - ListBoxFooter()  -> use EndListBox()
 - 2023/05/15 (1.89.6) - clipper: commented out obsolete redirection constructor 'ImGuiListClipper(int items_count, f32 items_height = -1.0)' that was marked obsolete in 1.79. Use default constructor + clipper.Begin().
 - 2023/05/15 (1.89.6) - clipper: renamed ImGuiListClipper::ForceDisplayRangeByIndices() to ImGuiListClipper::IncludeRangeByIndices().
 - 2023/03/14 (1.89.4) - commented out redirecting enums/functions names that were marked obsolete two years ago:
                           - ImGuiSliderFlags_ClampOnInput        -> use ImGuiSliderFlags_AlwaysClamp
                           - ImGuiInputTextFlags_AlwaysInsertMode -> use ImGuiInputTextFlags_AlwaysOverwrite
                           - ImDrawList::AddBezierCurve()         -> use ImDrawList::AddBezierCubic()
                           - ImDrawList::PathBezierCurveTo()      -> use ImDrawList::PathBezierCubicCurveTo()
 - 2023/03/09 (1.89.4) - renamed PushAllowKeyboardFocus()/PopAllowKeyboardFocus() to PushTabStop()/PopTabStop(). Kept inline redirection functions (will obsolete).
 - 2023/03/09 (1.89.4) - tooltips: Added 'bool' return value to BeginTooltip() for API consistency. Please only submit contents and call EndTooltip() if BeginTooltip() returns true. In reality the function will _currently_ always return true, but further changes down the line may change this, best to clarify API sooner.
 - 2023/02/15 (1.89.4) - moved the optional "courtesy maths operators" implementation from imgui_internal.h in imgui.h.
                         Even though we encourage using your own maths types and operators by setting up IM_VEC2_CLASS_EXTRA,
                         it has been frequently requested by people to use our own. We had an opt-in define which was
                         previously fulfilled in imgui_internal.h. It is now fulfilled in imgui.h. (#6164)
                           - OK:     #define IMGUI_DEFINE_MATH_OPERATORS / #include "imgui.h" / #include "imgui_internal.h"
                           - Error:  #include "imgui.h" / #define IMGUI_DEFINE_MATH_OPERATORS / #include "imgui_internal.h"
 - 2023/02/07 (1.89.3) - backends: renamed "imgui_impl_sdl.cpp" to "imgui_impl_sdl2.cpp" and "imgui_impl_sdl.h" to "imgui_impl_sdl2.h". (#6146) This is in prevision for the future release of SDL3.
 - 2022/10/26 (1.89)   - commented out redirecting OpenPopupContextItem() which was briefly the name of OpenPopupOnItemClick() from 1.77 to 1.79.
 - 2022/10/12 (1.89)   - removed runtime patching of invalid "%f"/"%0.f" format strings for DragInt()/SliderInt(). This was obsoleted in 1.61 (May 2018). See 1.61 changelog for details.
 - 2022/09/26 (1.89)   - renamed and merged keyboard modifiers key enums and flags into a same set. Kept inline redirection enums (will obsolete).
                           - ImGuiKey.ModCtrl  and ImGuiModFlags_Ctrl  -> ImGuiKey.Mod_Ctrl
                           - ImGuiKey.ModShift and ImGuiModFlags_Shift -> ImGuiKey.Mod_Shift
                           - ImGuiKey.ModAlt   and ImGuiModFlags_Alt   -> ImGuiKey.Mod_Alt
                           - ImGuiKey.ModSuper and ImGuiModFlags_Super -> ImGuiKey.Mod_Super
                         the ImGuiKey.ModXXX were introduced in 1.87 and mostly used by backends.
                         the ImGuiModFlags_XXX have been exposed in imgui.h but not really used by any public api only by third-party extensions.
                         exceptionally commenting out the older ImGuiKeyModFlags_XXX names ahead of obsolescence schedule to reduce confusion and because they were not meant to be used anyway.
 - 2022/09/20 (1.89)   - ImGuiKey is now a typed enum, allowing ImGuiKey.XXX symbols to be named in debuggers.
                         this will require uses of legacy backend-dependent indices to be casted, e.g.
                            - with imgui_impl_glfw:  IsKeyPressed(GLFW_KEY_A) -> IsKeyPressed((ImGuiKey)GLFW_KEY_A);
                            - with imgui_impl_win32: IsKeyPressed('A')        -> IsKeyPressed((ImGuiKey)'A')
                            - etc. However if you are upgrading code you might well use the better, backend-agnostic IsKeyPressed(ImGuiKey.A) now!
 - 2022/09/12 (1.89) - removed the bizarre legacy default argument for 'TreePush(const rawptr ptr = nil)', always pass a pointer value explicitly. nil/nullptr is ok but require cast, e.g. TreePush((rawptr)nullptr);
 - 2022/09/05 (1.89) - commented out redirecting functions/enums names that were marked obsolete in 1.77 and 1.78 (June 2020):
                         - DragScalar(), DragScalarN(), DragFloat(), DragFloat2(), DragFloat3(), DragFloat4(): For old signatures ending with (..., const char* format, f32 power = 1.0) -> use (..., format ImGuiSliderFlags_Logarithmic) if power != 1.0.
                         - SliderScalar(), SliderScalarN(), SliderFloat(), SliderFloat2(), SliderFloat3(), SliderFloat4(): For old signatures ending with (..., const char* format, f32 power = 1.0) -> use (..., format ImGuiSliderFlags_Logarithmic) if power != 1.0.
                         - BeginPopupContextWindow(const char*, ImGuiMouseButton, bool) -> use BeginPopupContextWindow(const char*, ImGuiPopupFlags)
 - 2022/09/02 (1.89) - obsoleted using SetCursorPos()/SetCursorScreenPos() to extend parent window/cell boundaries.
                       this relates to when moving the cursor position beyond current boundaries WITHOUT submitting an item.
                         - previously this would make the window content size ~200x200:
                              Begin(...) + SetCursorScreenPos(GetCursorScreenPos() + ImVec2{200,200}) + End();
                         - instead, please submit an item:
                              Begin(...) + SetCursorScreenPos(GetCursorScreenPos() + ImVec2{200,200}) + Dummy(ImVec2{0,0}) + End();
                         - alternative:
                              Begin(...) + Dummy(ImVec2{200,200}) + End();
                         - content size is now only extended when submitting an item!
                         - with '#define IMGUI_DISABLE_OBSOLETE_FUNCTIONS' this will now be detected and assert.
                         - without '#define IMGUI_DISABLE_OBSOLETE_FUNCTIONS' this will silently be fixed until we obsolete it.
 - 2022/08/03 (1.89) - changed signature of ImageButton() function. Kept redirection function (will obsolete).
                        - added 'const char* str_id' parameter + removed 'int frame_padding = -1' parameter.
                        - old signature: bool ImageButton(ImTextureID tex_id, ImVec2 size, ImVec2 uv0 = ImVec2{0,0}, ImVec2 uv1 = ImVec2{1,1}, int frame_padding = -1, ImVec4 bg_col = ImVec4{0,0,0,0}, ImVec4 tint_col = ImVec4{1,1,1,1});
                          - used the ImTextureID value to create an ID. This was inconsistent with other functions, led to ID conflicts, and caused problems with engines using transient ImTextureID values.
                          - had a FramePadding override which was inconsistent with other functions and made the already-long signature even longer.
                        - new signature: bool ImageButton(const char* str_id, ImTextureID tex_id, ImVec2 size, ImVec2 uv0 = ImVec2{0,0}, ImVec2 uv1 = ImVec2{1,1}, ImVec4 bg_col = ImVec4{0,0,0,0}, ImVec4 tint_col = ImVec4{1,1,1,1});
                          - requires an explicit identifier. You may still use e.g. PushID() calls and then pass an empty identifier.
                          - always uses style.FramePadding for padding, to be consistent with other buttons. You may use PushStyleVar() to alter this.
 - 2022/07/08 (1.89) - inputs: removed io.NavInputs[] and ImGuiNavInput enum (following 1.87 changes).
                        - Official backends from 1.87+                  -> no issue.
                        - Official backends from 1.60 to 1.86           -> will build and convert gamepad inputs, unless IMGUI_DISABLE_OBSOLETE_KEYIO is defined. Need updating!
                        - Custom backends not writing to io.NavInputs[] -> no issue.
                        - Custom backends writing to io.NavInputs[]     -> will build and convert gamepad inputs, unless IMGUI_DISABLE_OBSOLETE_KEYIO is defined. Need fixing!
                        - TL;DR: Backends should call io.AddKeyEvent()/io.AddKeyAnalogEvent() with ImGuiKey.GamepadXXX values instead of filling io.NavInput[].
 - 2022/06/15 (1.88) - renamed IMGUI_DISABLE_METRICS_WINDOW to IMGUI_DISABLE_DEBUG_TOOLS for correctness. kept support for old define (will obsolete).
 - 2022/05/03 (1.88) - backends: osx: removed ImGui_ImplOSX_HandleEvent() from backend API in favor of backend automatically handling event capture. All ImGui_ImplOSX_HandleEvent() calls should be removed as they are now unnecessary.
 - 2022/04/05 (1.88) - inputs: renamed ImGuiKeyModFlags to ImGuiModFlags. Kept inline redirection enums (will obsolete). This was never used in public API functions but technically present in imgui.h and ImGuiIO.
 - 2022/01/20 (1.87) - inputs: reworded gamepad IO.
                        - Backend writing to io.NavInputs[]            -> backend should call io.AddKeyEvent()/io.AddKeyAnalogEvent() with ImGuiKey.GamepadXXX values.
 - 2022/01/19 (1.87) - sliders, drags: removed support for legacy arithmetic operators (+,+-,*,/) when inputing text. This doesn't break any api/code but a feature that used to be accessible by end-users (which seemingly no one used).
 - 2022/01/17 (1.87) - inputs: reworked mouse IO.
                        - Backend writing to io.MousePos               -> backend should call io.AddMousePosEvent()
                        - Backend writing to io.MouseDown[]            -> backend should call io.AddMouseButtonEvent()
                        - Backend writing to io.MouseWheel             -> backend should call io.AddMouseWheelEvent()
                        - Backend writing to io.MouseHoveredViewport   -> backend should call io.AddMouseViewportEvent() [Docking branch w/ multi-viewports only]
                       note: for all calls to IO new functions, the Dear ImGui context should be bound/current.
                       read https://github.com/ocornut/imgui/issues/4921 for details.
 - 2022/01/10 (1.87) - inputs: reworked keyboard IO. Removed io.KeyMap[], io.KeysDown[] in favor of calling io.AddKeyEvent(). Removed GetKeyIndex(), now unnecessary. All IsKeyXXX() functions now take ImGuiKey values. All features are still functional until IMGUI_DISABLE_OBSOLETE_KEYIO is defined. Read Changelog and Release Notes for details.
                        - IsKeyPressed(MY_NATIVE_KEY_XXX)              -> use IsKeyPressed(ImGuiKey.XXX)
                        - IsKeyPressed(GetKeyIndex(ImGuiKey.XXX))      -> use IsKeyPressed(ImGuiKey.XXX)
                        - Backend writing to io.KeyMap[],io.KeysDown[] -> backend should call io.AddKeyEvent() (+ call io.SetKeyEventNativeData() if you want legacy user code to stil function with legacy key codes).
                        - Backend writing to io.KeyCtrl, io.KeyShift.. -> backend should call io.AddKeyEvent() with ImGuiMod_XXX values. *IF YOU PULLED CODE BETWEEN 2021/01/10 and 2021/01/27: We used to have a io.AddKeyModsEvent() function which was now replaced by io.AddKeyEvent() with ImGuiMod_XXX values.*
                     - one case won't work with backward compatibility: if your custom backend used ImGuiKey as mock native indices (e.g. "io.KeyMap[ImGuiKey.A] = ImGuiKey.A") because those values are now larger than the legacy KeyDown[] array. Will assert.
                     - inputs: added ImGuiKey.ModCtrl/ImGuiKey.ModShift/ImGuiKey.ModAlt/ImGuiKey.ModSuper values to submit keyboard modifiers using io.AddKeyEvent(), instead of writing directly to io.KeyCtrl, io.KeyShift, io.KeyAlt, io.KeySuper.
 - 2022/01/05 (1.87) - inputs: renamed ImGuiKey.KeyPadEnter to ImGuiKey.KeypadEnter to align with new symbols. Kept redirection enum.
 - 2022/01/05 (1.87) - removed io.ImeSetInputScreenPosFn() in favor of more flexible io.SetPlatformImeDataFn(). Removed 'rawptr io.ImeWindowHandle' in favor of writing to 'rawptr ImGuiViewport::PlatformHandleRaw'.
 - 2022/01/01 (1.87) - commented out redirecting functions/enums names that were marked obsolete in 1.69, 1.70, 1.71, 1.72 (March-July 2019)
                        - SetNextTreeNodeOpen()        -> use SetNextItemOpen()
                        - GetContentRegionAvailWidth() -> use GetContentRegionAvail().x
                        - TreeAdvanceToLabelPos()      -> use SetCursorPosX(GetCursorPosX() + GetTreeNodeToLabelSpacing());
                        - ImFontAtlas::CustomRect             -> use ImFontAtlasCustomRect
                        - ImGuiColorEditFlags_RGB/HSV/HEX     -> use ImGuiColorEditFlags_DisplayRGB/HSV/Hex
 - 2021/12/20 (1.86) - backends: removed obsolete Marmalade backend (imgui_impl_marmalade.cpp) + example. Find last supported version at https://github.com/ocornut/imgui/wiki/Bindings
 - 2021/11/04 (1.86) - removed CalcListClipping() function. Prefer using ImGuiListClipper which can return non-contiguous ranges. Please open an issue if you think you really need this function.
 - 2021/08/23 (1.85) - removed GetWindowContentRegionWidth() function. keep inline redirection helper. can use 'GetWindowContentRegionMax().x - GetWindowContentRegionMin().x' instead for generally 'GetContentRegionAvail().x' is more useful.
 - 2021/07/26 (1.84) - commented out redirecting functions/enums names that were marked obsolete in 1.67 and 1.69 (March 2019):
                        - GetOverlayDrawList() -> use GetForegroundDrawList()
                        - ImFont::GlyphRangesBuilder  -> use ImFontGlyphRangesBuilder
 - 2021/05/19 (1.83) - backends: obsoleted direct access to ImDrawCmd::TextureId in favor of calling ImDrawCmd::GetTexID().
                        - if you are using official backends from the source tree: you have nothing to do.
                        - if you have copied old backend code or using your own: change access to draw_cmd.TextureId to draw_cmd.GetTexID().
 - 2021/03/12 (1.82) - upgraded ImDrawList::AddRect(), AddRectFilled(), PathRect() to use ImDrawFlags instead of ImDrawCornersFlags.
                        - ImDrawCornerFlags_TopLeft  -> use ImDrawFlags_RoundCornersTopLeft
                        - ImDrawCornerFlags_BotRight -> use ImDrawFlags_RoundCornersBottomRight
                        - ImDrawCornerFlags_None     -> use ImDrawFlags_RoundCornersNone etc.
                       flags now sanely defaults to 0 instead of 0x0F, consistent with all other flags in the API.
                       breaking: the default with rounding > 0.0 is now "round all corners" vs old implicit "round no corners":
                        - rounding == 0.0 + flags == 0 --> meant no rounding  --> unchanged (common use)
                        - rounding  > 0.0 + flags != 0 --> meant rounding     --> unchanged (common use)
                        - rounding == 0.0 + flags != 0 --> meant no rounding  --> unchanged (unlikely use)
                        - rounding  > 0.0 + flags == 0 --> meant no rounding  --> BREAKING (unlikely use): will now round all corners --> use ImDrawFlags_RoundCornersNone or rounding == 0.0.
                       this ONLY matters for hard coded use of 0 + rounding > 0.0. Use of named ImDrawFlags_RoundCornersNone (new) or ImDrawCornerFlags_None (old) are ok.
                       the old ImDrawCornersFlags used awkward default values of ~0 or 0xF (4 lower bits set) to signify "round all corners" and we sometimes encouraged using them as shortcuts.
                       legacy path still support use of hard coded ~0 or any value from 0x1 or 0xF. They will behave the same with legacy paths enabled (will assert otherwise).
 - 2021/03/11 (1.82) - removed redirecting functions/enums names that were marked obsolete in 1.66 (September 2018):
                        - SetScrollHere()              -> use SetScrollHereY()
 - 2021/03/11 (1.82) - clarified that ImDrawList::PathArcTo(), ImDrawList::PathArcToFast() won't render with radius < 0.0. Previously it sorts of accidentally worked but would generally lead to counter-clockwise paths and have an effect on anti-aliasing.
 - 2021/03/10 (1.82) - upgraded ImDrawList::AddPolyline() and PathStroke() "bool closed" parameter to "ImDrawFlags flags". The matching ImDrawFlags_Closed value is guaranteed to always stay == 1 in the future.
 - 2021/02/22 (1.82) - (*undone in 1.84*) win32+mingw: Re-enabled IME functions by default even under MinGW. In July 2016, issue #738 had me incorrectly disable those default functions for MinGW. MinGW users should: either link with -limm32, either set their imconfig file  with '#define IMGUI_DISABLE_WIN32_DEFAULT_IME_FUNCTIONS'.
 - 2021/02/17 (1.82) - renamed rarely used style.CircleSegmentMaxError (old default = 1.60) to style.CircleTessellationMaxError (new default = 0.30) as the meaning of the value changed.
 - 2021/02/03 (1.81) - renamed ListBoxHeader(const char* label, ImVec2 size) to BeginListBox(). Kept inline redirection function (will obsolete).
                     - removed ListBoxHeader(const char* label, int items_count, int height_in_items = -1) in favor of specifying size. Kept inline redirection function (will obsolete).
                     - renamed ListBoxFooter() to EndListBox(). Kept inline redirection function (will obsolete).
 - 2021/01/26 (1.81) - removed ImGuiFreeType::BuildFontAtlas(). Kept inline redirection function. Prefer using '#define IMGUI_ENABLE_FREETYPE', but there's a runtime selection path available too. The shared extra flags parameters (very rarely used) are now stored in ImFontAtlas::FontBuilderFlags.
                     - renamed ImFontConfig::RasterizerFlags (used by FreeType) to ImFontConfig::FontBuilderFlags.
                     - renamed ImGuiFreeType::XXX flags to ImGuiFreeTypeBuilderFlags_XXX for consistency with other API.
 - 2020/10/12 (1.80) - removed redirecting functions/enums that were marked obsolete in 1.63 (August 2018):
                        - IsItemDeactivatedAfterChange() -> use IsItemDeactivatedAfterEdit().
                        - ImGuiCol.ModalWindowDarkening       -> use ImGuiCol.ModalWindowDimBg
                        - ImGuiInputTextCallback              -> use ImGuiTextEditCallback
                        - ImGuiInputTextCallbackData          -> use ImGuiTextEditCallbackData
 - 2020/12/21 (1.80) - renamed ImDrawList::AddBezierCurve() to AddBezierCubic(), and PathBezierCurveTo() to PathBezierCubicCurveTo(). Kept inline redirection function (will obsolete).
 - 2020/12/04 (1.80) - added imgui_tables.cpp file! Manually constructed project files will need the new file added!
 - 2020/11/18 (1.80) - renamed undocumented/internals ImGuiColumnsFlags_* to ImGuiOldColumnFlags_* in prevision of incoming Tables API.
 - 2020/11/03 (1.80) - renamed io.ConfigWindowsMemoryCompactTimer to io.ConfigMemoryCompactTimer as the feature will apply to other data structures
 - 2020/10/14 (1.80) - backends: moved all backends files (imgui_impl_XXXX.cpp, imgui_impl_XXXX.h) from examples/ to backends/.
 - 2020/10/12 (1.80) - removed redirecting functions/enums that were marked obsolete in 1.60 (April 2018):
                        - io.RenderDrawListsFn pointer        -> use GetDrawData() value and call the render function of your backend
                        - IsAnyWindowFocused()         -> use IsWindowFocused(ImGuiFocusedFlags_AnyWindow)
                        - IsAnyWindowHovered()         -> use IsWindowHovered(ImGuiHoveredFlags_AnyWindow)
                        - ImGuiStyleVar_Count_                -> use ImGuiStyleVar_COUNT
                        - ImGuiMouseCursor_Count_             -> use ImGuiMouseCursor_COUNT
                      - removed redirecting functions names that were marked obsolete in 1.61 (May 2018):
                        - InputFloat (... int decimal_precision ...) -> use InputFloat (... const char* format ...) with format = "%.Xf" where X is your value for decimal_precision.
                        - same for InputFloat2()/InputFloat3()/InputFloat4() variants taking a `int decimal_precision` parameter.
 - 2020/10/05 (1.79) - removed ImGuiListClipper: Renamed constructor parameters which created an ambiguous alternative to using the ImGuiListClipper::Begin() function, with misleading edge cases (note: imgui_memory_editor <0.40 from imgui_club/ used this old clipper API. Update your copy if needed).
 - 2020/09/25 (1.79) - renamed ImGuiSliderFlags_ClampOnInput to ImGuiSliderFlags_AlwaysClamp. Kept redirection enum (will obsolete sooner because previous name was added recently).
 - 2020/09/25 (1.79) - renamed style.TabMinWidthForUnselectedCloseButton to style.TabMinWidthForCloseButton.
 - 2020/09/21 (1.79) - renamed OpenPopupContextItem() back to OpenPopupOnItemClick(), reverting the change from 1.77. For varieties of reason this is more self-explanatory.
 - 2020/09/21 (1.79) - removed return value from OpenPopupOnItemClick() - returned true on mouse release on an item - because it is inconsistent with other popup APIs and makes others misleading. It's also and unnecessary: you can use IsWindowAppearing() after BeginPopup() for a similar result.
 - 2020/09/17 (1.79) - removed ImFont::DisplayOffset in favor of ImFontConfig::GlyphOffset. DisplayOffset was applied after scaling and not very meaningful/useful outside of being needed by the default ProggyClean font. If you scaled this value after calling AddFontDefault(), this is now done automatically. It was also getting in the way of better font scaling, so let's get rid of it now!
 - 2020/08/17 (1.78) - obsoleted use of the trailing 'f32 power=1.0' parameter for DragFloat(), DragFloat2(), DragFloat3(), DragFloat4(), DragFloatRange2(), DragScalar(), DragScalarN(), SliderFloat(), SliderFloat2(), SliderFloat3(), SliderFloat4(), SliderScalar(), SliderScalarN(), VSliderFloat() and VSliderScalar().
                       replaced the 'f32 power=1.0' argument with integer-based flags defaulting to 0 (as with all our flags).
                       worked out a backward-compatibility scheme so hopefully most C++ codebase should not be affected. in short, when calling those functions:
                       - if you omitted the 'power' parameter (likely!), you are not affected.
                       - if you set the 'power' parameter to 1.0 (same as previous default value): 1/ your compiler may warn on float>int conversion, 2/ everything else will work. 3/ you can replace the 1.0 value with 0 to fix the warning, and be technically correct.
                       - if you set the 'power' parameter to >1.0 (to enable non-linear editing): 1/ your compiler may warn on float>int conversion, 2/ code will assert at runtime, 3/ in case asserts are disabled, the code will not crash and enable the _Logarithmic flag. 4/ you can replace the >1.0 value with ImGuiSliderFlags_Logarithmic to fix the warning/assert and get a _similar_ effect as previous uses of power >1.0.
                       see https://github.com/ocornut/imgui/issues/3361 for all details.
                       kept inline redirection functions (will obsolete) apart for: DragFloatRange2(), VSliderFloat(), VSliderScalar(). For those three the 'f32 power=1.0' version was removed directly as they were most unlikely ever used.
                       for shared code, you can version check at compile-time with `#if IMGUI_VERSION_NUM >= 17704`.
                     - obsoleted use of v_min > v_max in DragInt, DragFloat, DragScalar to lock edits (introduced in 1.73, was not demoed nor documented very), will be replaced by a more generic ReadOnly feature. You may use the ImGuiSliderFlags_ReadOnly internal flag in the meantime.
 - 2020/06/23 (1.77) - removed BeginPopupContextWindow(const char*, int mouse_button, bool also_over_items) in favor of BeginPopupContextWindow(const char*, ImGuiPopupFlags flags) with ImGuiPopupFlags_NoOverItems.
 - 2020/06/15 (1.77) - renamed OpenPopupOnItemClick() to OpenPopupContextItem(). Kept inline redirection function (will obsolete). [NOTE: THIS WAS REVERTED IN 1.79]
 - 2020/06/15 (1.77) - removed CalcItemRectClosestPoint() entry point which was made obsolete and asserting in December 2017.
 - 2020/04/23 (1.77) - removed unnecessary ID (first arg) of ImFontAtlas::AddCustomRectRegular().
 - 2020/01/22 (1.75) - ImDrawList::AddCircle()/AddCircleFilled() functions don't accept negative radius any more.
 - 2019/12/17 (1.75) - [undid this change in 1.76] made Columns() limited to 64 columns by asserting above that limit. While the current code technically supports it, future code may not so we're putting the restriction ahead.
 - 2019/12/13 (1.75) - [imgui_internal.h] changed ImRect() default constructor initializes all fields to 0.0 instead of (math.F32_MAX,math.F32_MAX,-math.F32_MAX,-math.F32_MAX). If you used ImRect::Add() to create bounding boxes by adding multiple points into it, you may need to fix your initial value.
 - 2019/12/08 (1.75) - removed redirecting functions/enums that were marked obsolete in 1.53 (December 2017):
                       - ShowTestWindow()                    -> use ShowDemoWindow()
                       - IsRootWindowFocused()               -> use IsWindowFocused(ImGuiFocusedFlags_RootWindow)
                       - IsRootWindowOrAnyChildFocused()     -> use IsWindowFocused(ImGuiFocusedFlags_RootAndChildWindows)
                       - SetNextWindowContentWidth(w)        -> use SetNextWindowContentSize(ImVec2{w, 0.0}
                       - GetItemsLineHeightWithSpacing()     -> use GetFrameHeightWithSpacing()
                       - ImGuiCol.ChildWindowBg              -> use ImGuiCol.ChildBg
                       - ImGuiStyleVar_ChildWindowRounding   -> use ImGuiStyleVar_ChildRounding
                       - ImGuiTreeNodeFlags_AllowOverlapMode -> use ImGuiTreeNodeFlags_AllowItemOverlap
                       - IMGUI_DISABLE_TEST_WINDOWS          -> use IMGUI_DISABLE_DEMO_WINDOWS
 - 2019/12/08 (1.75) - obsoleted calling ImDrawList::PrimReserve() with a negative count (which was vaguely documented and rarely if ever used). Instead, we added an explicit PrimUnreserve() API.
 - 2019/12/06 (1.75) - removed implicit default parameter to IsMouseDragging(int button = 0) to be consistent with other mouse functions (none of the other functions have it).
 - 2019/11/21 (1.74) - ImFontAtlas::AddCustomRectRegular() now requires an ID larger than 0x110000 (instead of 0x10000) to conform with supporting Unicode planes 1-16 in a future update. ID below 0x110000 will now assert.
 - 2019/11/19 (1.74) - renamed IMGUI_DISABLE_FORMAT_STRING_FUNCTIONS to IMGUI_DISABLE_DEFAULT_FORMAT_FUNCTIONS for consistency.
 - 2019/11/19 (1.74) - renamed IMGUI_DISABLE_MATH_FUNCTIONS to IMGUI_DISABLE_DEFAULT_MATH_FUNCTIONS for consistency.
 - 2019/10/22 (1.74) - removed redirecting functions/enums that were marked obsolete in 1.52 (October 2017):
                       - Begin() [old 5 args version]        -> use Begin() [3 args], use SetNextWindowSize() SetNextWindowBgAlpha() if needed
                       - IsRootWindowOrAnyChildHovered()     -> use IsWindowHovered(ImGuiHoveredFlags_RootAndChildWindows)
                       - AlignFirstTextHeightToWidgets()     -> use AlignTextToFramePadding()
                       - SetNextWindowPosCenter()            -> use SetNextWindowPos() with a pivot of (0.5, 0.5)
                       - ImFont::Glyph                       -> use ImFontGlyph
 - 2019/10/14 (1.74) - inputs: Fixed a miscalculation in the keyboard/mouse "typematic" repeat delay/rate calculation, used by keys and e.g. repeating mouse buttons as well as the GetKeyPressedAmount() function.
                       if you were using a non-default value for io.KeyRepeatRate (previous default was 0.250), you can add +io.KeyRepeatDelay to it to compensate for the fix.
                       The function was triggering on: 0.0 and (delay+rate*N) where (N>=1). Fixed formula responds to (N>=0). Effectively it made io.KeyRepeatRate behave like it was set to (io.KeyRepeatRate + io.KeyRepeatDelay).
                       If you never altered io.KeyRepeatRate nor used GetKeyPressedAmount() this won't affect you.
 - 2019/07/15 (1.72) - removed TreeAdvanceToLabelPos() which is rarely used and only does SetCursorPosX(GetCursorPosX() + GetTreeNodeToLabelSpacing()). Kept redirection function (will obsolete).
 - 2019/07/12 (1.72) - renamed ImFontAtlas::CustomRect to ImFontAtlasCustomRect. Kept redirection typedef (will obsolete).
 - 2019/06/14 (1.72) - removed redirecting functions/enums names that were marked obsolete in 1.51 (June 2017): ImGuiCol.Column*, ImGuiSetCond_*, IsItemHoveredRect(), IsPosHoveringAnyWindow(), IsMouseHoveringAnyWindow(), IsMouseHoveringWindow(), IMGUI_ONCE_UPON_A_FRAME. Grep this log for details and new names, or see how they were implemented until 1.71.
 - 2019/06/07 (1.71) - rendering of child window outer decorations (bg color, border, scrollbars) is now performed as part of the parent window. If you have
                       overlapping child windows in a same parent, and relied on their relative z-order to be mapped to their submission order, this will affect your rendering.
                       This optimization is disabled if the parent window has no visual output, because it appears to be the most common situation leading to the creation of overlapping child windows.
                       Please reach out if you are affected.
 - 2019/05/13 (1.71) - renamed SetNextTreeNodeOpen() to SetNextItemOpen(). Kept inline redirection function (will obsolete).
 - 2019/05/11 (1.71) - changed io.AddInputCharacter(u16 c) signature to io.AddInputCharacter(u32 c).
 - 2019/04/29 (1.70) - improved ImDrawList thick strokes (>1.0) preserving correct thickness up to 90 degrees angles (e.g. rectangles). If you have custom rendering using thick lines, they will appear thicker now.
 - 2019/04/29 (1.70) - removed GetContentRegionAvailWidth(), use GetContentRegionAvail().x instead. Kept inline redirection function (will obsolete).
 - 2019/03/04 (1.69) - renamed GetOverlayDrawList() to GetForegroundDrawList(). Kept redirection function (will obsolete).
 - 2019/02/26 (1.69) - renamed ImGuiColorEditFlags_RGB/ImGuiColorEditFlags_HSV/ImGuiColorEditFlags_HEX to ImGuiColorEditFlags_DisplayRGB/ImGuiColorEditFlags_DisplayHSV/ImGuiColorEditFlags_DisplayHex. Kept redirection enums (will obsolete).
 - 2019/02/14 (1.68) - made it illegal/assert when io.DisplayTime == 0.0 (with an exception for the first frame). If for some reason your time step calculation gives you a zero value, replace it with an arbitrarily small value!
 - 2019/02/01 (1.68) - removed io.DisplayVisibleMin/DisplayVisibleMax (which were marked obsolete and removed from viewport/docking branch already).
 - 2019/01/06 (1.67) - renamed io.InputCharacters[], marked internal as was always intended. Please don't access directly, and use AddInputCharacter() instead!
 - 2019/01/06 (1.67) - renamed ImFontAtlas::GlyphRangesBuilder to ImFontGlyphRangesBuilder. Kept redirection typedef (will obsolete).
 - 2018/12/20 (1.67) - made it illegal to call Begin("") with an empty string. This somehow half-worked before but had various undesirable side-effects.
 - 2018/12/10 (1.67) - renamed io.ConfigResizeWindowsFromEdges to io.ConfigWindowsResizeFromEdges as we are doing a large pass on configuration flags.
 - 2018/10/12 (1.66) - renamed misc/stl/imgui_stl.* to misc/cpp/imgui_stdlib.* in prevision for other C++ helper files.
 - 2018/09/28 (1.66) - renamed SetScrollHere() to SetScrollHereY(). Kept redirection function (will obsolete).
 - 2018/09/06 (1.65) - renamed stb_truetype.h to imstb_truetype.h, stb_textedit.h to imstb_textedit.h, and stb_rect_pack.h to imstb_rectpack.h.
                       If you were conveniently using the imgui copy of those STB headers in your project you will have to update your include paths.
 - 2018/09/05 (1.65) - renamed io.OptCursorBlink/io.ConfigCursorBlink to io.ConfigInputTextCursorBlink. (#1427)
 - 2018/08/31 (1.64) - added imgui_widgets.cpp file, extracted and moved widgets code out of imgui.cpp into imgui_widgets.cpp. Re-ordered some of the code remaining in imgui.cpp.
                       NONE OF THE FUNCTIONS HAVE CHANGED. THE CODE IS SEMANTICALLY 100% IDENTICAL, BUT _EVERY_ FUNCTION HAS BEEN MOVED.
                       Because of this, any local modifications to imgui.cpp will likely conflict when you update. Read docs/CHANGELOG.txt for suggestions.
 - 2018/08/22 (1.63) - renamed IsItemDeactivatedAfterChange() to IsItemDeactivatedAfterEdit() for consistency with new IsItemEdited() API. Kept redirection function (will obsolete soonish as IsItemDeactivatedAfterChange() is very recent).
 - 2018/08/21 (1.63) - renamed ImGuiTextEditCallback to ImGuiInputTextCallback, ImGuiTextEditCallbackData to ImGuiInputTextCallbackData for consistency. Kept redirection types (will obsolete).
 - 2018/08/21 (1.63) - removed ImGuiInputTextCallbackData::ReadOnly since it is a duplication of (ImGuiInputTextCallbackData::Flags & ImGuiInputTextFlags_ReadOnly).
 - 2018/08/01 (1.63) - removed per-window ImGuiWindowFlags_ResizeFromAnySide beta flag in favor of a global io.ConfigResizeWindowsFromEdges [update 1.67 renamed to ConfigWindowsResizeFromEdges] to enable the feature.
 - 2018/08/01 (1.63) - renamed io.OptCursorBlink to io.ConfigCursorBlink [-> io.ConfigInputTextCursorBlink in 1.65], io.OptMacOSXBehaviors to ConfigMacOSXBehaviors for consistency.
 - 2018/07/22 (1.63) - changed GetTime() return value from f32 to f64 to avoid accumulating floating point imprecisions over time.
 - 2018/07/08 (1.63) - style: renamed ImGuiCol.ModalWindowDarkening to ImGuiCol.ModalWindowDimBg for consistency with other features. Kept redirection enum (will obsolete).
 - 2018/06/08 (1.62) - examples: the imgui_impl_XXX files have been split to separate platform (Win32, GLFW, SDL2, etc.) from renderer (DX11, OpenGL, Vulkan,  etc.).
                       old backends will still work as is, however prefer using the separated backends as they will be updated to support multi-viewports.
                       when adopting new backends follow the main.cpp code of your preferred examples/ folder to know which functions to call.
                       in particular, note that old backends called NewFrame() at the end of their ImGui_ImplXXXX_NewFrame() function.
 - 2018/06/06 (1.62) - renamed GetGlyphRangesChinese() to GetGlyphRangesChineseFull() to distinguish other variants and discourage using the full set.
 - 2018/06/06 (1.62) - TreeNodeEx()/TreeNodeBehavior(): the ImGuiTreeNodeFlags_CollapsingHeader helper now include the ImGuiTreeNodeFlags_NoTreePushOnOpen flag. See Changelog for details.
 - 2018/05/03 (1.61) - DragInt(): the default compile-time format string has been changed from "%.0" to "%d", as we are not using integers internally any more.
                       If you used DragInt() with custom format strings, make sure you change them to use %d or an integer-compatible format.
                       To honor backward-compatibility, the DragInt() code will currently parse and modify format strings to replace %*f with %d, giving time to users to upgrade their code.
                       If you have IMGUI_DISABLE_OBSOLETE_FUNCTIONS enabled, the code will instead assert! You may run a reg-exp search on your codebase for e.g. "DragInt.*%f" to help you find them.
 - 2018/04/28 (1.61) - obsoleted InputFloat() functions taking an optional "int decimal_precision" in favor of an equivalent and more flexible "const char* format",
                       consistent with other functions. Kept redirection functions (will obsolete).
 - 2018/04/09 (1.61) - IM_DELETE() helper function added in 1.60 doesn't clear the input _pointer_ reference, more consistent with expectation and allows passing r-value.
 - 2018/03/20 (1.60) - renamed io.WantMoveMouse to io.WantSetMousePos for consistency and ease of understanding (was added in 1.52, _not_ used by core and only honored by some backend ahead of merging the Nav branch).
 - 2018/03/12 (1.60) - removed ImGuiCol.CloseButton, ImGuiCol.CloseButtonActive, ImGuiCol.CloseButtonHovered as the closing cross uses regular button colors now.
 - 2018/03/08 (1.60) - changed ImFont::DisplayOffset.y to default to 0 instead of +1. Fixed rounding of Ascent/Descent to match TrueType renderer. If you were adding or subtracting to ImFont::DisplayOffset check if your fonts are correctly aligned vertically.
 - 2018/03/03 (1.60) - renamed ImGuiStyleVar_Count_ to ImGuiStyleVar_COUNT and ImGuiMouseCursor_Count_ to ImGuiMouseCursor_COUNT for consistency with other public enums.
 - 2018/02/18 (1.60) - BeginDragDropSource(): temporarily removed the optional mouse_button=0 parameter because it is not really usable in many situations at the moment.
 - 2018/02/16 (1.60) - obsoleted the io.RenderDrawListsFn callback, you can call your graphics engine render function after Render(). Use GetDrawData() to retrieve the ImDrawData* to display.
 - 2018/02/07 (1.60) - reorganized context handling to be more explicit,
                       - YOU NOW NEED TO CALL CreateContext() AT THE BEGINNING OF YOUR APP, AND CALL DestroyContext() AT THE END.
                       - removed Shutdown() function, as DestroyContext() serve this purpose.
                       - you may pass a ImFontAtlas* pointer to CreateContext() to share a font atlas between contexts. Otherwise CreateContext() will create its own font atlas instance.
                       - removed allocator parameters from CreateContext(), they are now setup with SetAllocatorFunctions(), and shared by all contexts.
                       - removed the default global context and font atlas instance, which were confusing for users of DLL reloading and users of multiple contexts.
 - 2018/01/31 (1.60) - moved sample TTF files from extra_fonts/ to misc/fonts/. If you loaded files directly from the imgui repo you may need to update your paths.
 - 2018/01/11 (1.60) - obsoleted IsAnyWindowHovered() in favor of IsWindowHovered(ImGuiHoveredFlags_AnyWindow). Kept redirection function (will obsolete).
 - 2018/01/11 (1.60) - obsoleted IsAnyWindowFocused() in favor of IsWindowFocused(ImGuiFocusedFlags_AnyWindow). Kept redirection function (will obsolete).
 - 2018/01/03 (1.60) - renamed ImGuiSizeConstraintCallback to ImGuiSizeCallback, ImGuiSizeConstraintCallbackData to ImGuiSizeCallbackData.
 - 2017/12/29 (1.60) - removed CalcItemRectClosestPoint() which was weird and not really used by anyone except demo code. If you need it it's easy to replicate on your side.
 - 2017/12/24 (1.53) - renamed the emblematic ShowTestWindow() function to ShowDemoWindow(). Kept redirection function (will obsolete).
 - 2017/12/21 (1.53) - ImDrawList: renamed style.AntiAliasedShapes to style.AntiAliasedFill for consistency and as a way to explicitly break code that manipulate those flag at runtime. You can now manipulate ImDrawList::Flags
 - 2017/12/21 (1.53) - ImDrawList: removed 'bool anti_aliased = true' final parameter of ImDrawList::AddPolyline() and ImDrawList::AddConvexPolyFilled(). Prefer manipulating ImDrawList::Flags if you need to toggle them during the frame.
 - 2017/12/14 (1.53) - using the ImGuiWindowFlags_NoScrollWithMouse flag on a child window forwards the mouse wheel event to the parent window, unless either ImGuiWindowFlags_NoInputs or ImGuiWindowFlags_NoScrollbar are also set.
 - 2017/12/13 (1.53) - renamed GetItemsLineHeightWithSpacing() to GetFrameHeightWithSpacing(). Kept redirection function (will obsolete).
 - 2017/12/13 (1.53) - obsoleted IsRootWindowFocused() in favor of using IsWindowFocused(ImGuiFocusedFlags_RootWindow). Kept redirection function (will obsolete).
                     - obsoleted IsRootWindowOrAnyChildFocused() in favor of using IsWindowFocused(ImGuiFocusedFlags_RootAndChildWindows). Kept redirection function (will obsolete).
 - 2017/12/12 (1.53) - renamed ImGuiTreeNodeFlags_AllowOverlapMode to ImGuiTreeNodeFlags_AllowItemOverlap. Kept redirection enum (will obsolete).
 - 2017/12/10 (1.53) - removed SetNextWindowContentWidth(), prefer using SetNextWindowContentSize(). Kept redirection function (will obsolete).
 - 2017/11/27 (1.53) - renamed ImGuiTextBuffer::append() helper to appendf(), appendv() to appendfv(). If you copied the 'Log' demo in your code, it uses appendv() so that needs to be renamed.
 - 2017/11/18 (1.53) - Style, Begin: removed ImGuiWindowFlags_ShowBorders window flag. Borders are now fully set up in the ImGuiStyle structure (see e.g. style.FrameBorderSize, style.WindowBorderSize). Use ShowStyleEditor() to look them up.
                       Please note that the style system will keep evolving (hopefully stabilizing in Q1 2018), and so custom styles will probably subtly break over time. It is recommended you use the StyleColorsClassic(), StyleColorsDark(), StyleColorsLight() functions.
 - 2017/11/18 (1.53) - Style: removed ImGuiCol.ComboBg in favor of combo boxes using ImGuiCol.PopupBg for consistency.
 - 2017/11/18 (1.53) - Style: renamed ImGuiCol.ChildWindowBg to ImGuiCol.ChildBg.
 - 2017/11/18 (1.53) - Style: renamed style.ChildWindowRounding to style.ChildRounding, ImGuiStyleVar_ChildWindowRounding to ImGuiStyleVar_ChildRounding.
 - 2017/11/02 (1.53) - obsoleted IsRootWindowOrAnyChildHovered() in favor of using IsWindowHovered(ImGuiHoveredFlags_RootAndChildWindows);
 - 2017/10/24 (1.52) - renamed IMGUI_DISABLE_WIN32_DEFAULT_CLIPBOARD_FUNCS/IMGUI_DISABLE_WIN32_DEFAULT_IME_FUNCS to IMGUI_DISABLE_WIN32_DEFAULT_CLIPBOARD_FUNCTIONS/IMGUI_DISABLE_WIN32_DEFAULT_IME_FUNCTIONS for consistency.
 - 2017/10/20 (1.52) - changed IsWindowHovered() default parameters behavior to return false if an item is active in another window (e.g. click-dragging item from another window to this window). You can use the newly introduced IsWindowHovered() flags to requests this specific behavior if you need it.
 - 2017/10/20 (1.52) - marked IsItemHoveredRect()/IsMouseHoveringWindow() as obsolete, in favor of using the newly introduced flags for IsItemHovered() and IsWindowHovered(). See https://github.com/ocornut/imgui/issues/1382 for details.
                       removed the IsItemRectHovered()/IsWindowRectHovered() names introduced in 1.51 since they were merely more consistent names for the two functions we are now obsoleting.
                         IsItemHoveredRect()        --> IsItemHovered(ImGuiHoveredFlags_RectOnly)
                         IsMouseHoveringAnyWindow() --> IsWindowHovered(ImGuiHoveredFlags_AnyWindow)
                         IsMouseHoveringWindow()    --> IsWindowHovered(ImGuiHoveredFlags_AllowWhenBlockedByPopup | ImGuiHoveredFlags_AllowWhenBlockedByActiveItem) [weird, old behavior]
 - 2017/10/17 (1.52) - marked the old 5-parameters version of Begin() as obsolete (still available). Use SetNextWindowSize()+Begin() instead!
 - 2017/10/11 (1.52) - renamed AlignFirstTextHeightToWidgets() to AlignTextToFramePadding(). Kept inline redirection function (will obsolete).
 - 2017/09/26 (1.52) - renamed ImFont::Glyph to ImFontGlyph. Kept redirection typedef (will obsolete).
 - 2017/09/25 (1.52) - removed SetNextWindowPosCenter() because SetNextWindowPos() now has the optional pivot information to do the same and more. Kept redirection function (will obsolete).
 - 2017/08/25 (1.52) - io.MousePos needs to be set to ImVec2{-math.F32_MAX,-math.F32_MAX} when mouse is unavailable/missing. Previously ImVec2{-1,-1} was enough but we now accept negative mouse coordinates. In your backend if you need to support unavailable mouse, make sure to replace "io.MousePos = ImVec2{-1,-1}" with "io.MousePos = ImVec2{-math.F32_MAX,-math.F32_MAX}".
 - 2017/08/22 (1.51) - renamed IsItemHoveredRect() to IsItemRectHovered(). Kept inline redirection function (will obsolete). -> (1.52) use IsItemHovered(ImGuiHoveredFlags_RectOnly)!
                     - renamed IsMouseHoveringAnyWindow() to IsAnyWindowHovered() for consistency. Kept inline redirection function (will obsolete).
                     - renamed IsMouseHoveringWindow() to IsWindowRectHovered() for consistency. Kept inline redirection function (will obsolete).
 - 2017/08/20 (1.51) - renamed GetStyleColName() to GetStyleColorName() for consistency.
 - 2017/08/20 (1.51) - added PushStyleColor(ImGuiCol idx, u32 col) overload, which _might_ cause an "ambiguous call" compilation error if you are using ImColor() with implicit cast. Cast to u32 or ImVec4 explicily to fix.
 - 2017/08/15 (1.51) - marked the weird IMGUI_ONCE_UPON_A_FRAME helper macro as obsolete. prefer using the more explicit ImGuiOnceUponAFrame type.
 - 2017/08/15 (1.51) - changed parameter order for BeginPopupContextWindow() from (const char*,int buttons,bool also_over_items) to (const char*,int buttons,bool also_over_items). Note that most calls relied on default parameters completely.
 - 2017/08/13 (1.51) - renamed ImGuiCol.Column to ImGuiCol.Separator, ImGuiCol.ColumnHovered to ImGuiCol.SeparatorHovered, ImGuiCol.ColumnActive to ImGuiCol.SeparatorActive. Kept redirection enums (will obsolete).
 - 2017/08/11 (1.51) - renamed ImGuiSetCond_Always to ImGuiCond_Always, ImGuiSetCond_Once to ImGuiCond_Once, ImGuiSetCond_FirstUseEver to ImGuiCond_FirstUseEver, ImGuiSetCond_Appearing to ImGuiCond_Appearing. Kept redirection enums (will obsolete).
 - 2017/08/09 (1.51) - removed ValueColor() helpers, they are equivalent to calling Text(label) + SameLine() + ColorButton().
 - 2017/08/08 (1.51) - removed ColorEditMode() and ImGuiColorEditMode in favor of ImGuiColorEditFlags and parameters to the various Color*() functions. The SetColorEditOptions() allows to initialize default but the user can still change them with right-click context menu.
                     - changed prototype of 'ColorEdit4(const char* label, f32 col[4], bool show_alpha = true)' to 'ColorEdit4(const char* label, f32 col[4], ImGuiColorEditFlags flags = 0)', where passing flags = 0x01 is a safe no-op (hello dodgy backward compatibility!). - check and run the demo window, under "Color/Picker Widgets", to understand the various new options.
                     - changed prototype of rarely used 'ColorButton(ImVec4 col, bool small_height = false, bool outline_border = true)' to 'ColorButton(const char* desc_id, ImVec4 col, ImGuiColorEditFlags flags = 0, ImVec2 size = ImVec2{0, 0})'
 - 2017/07/20 (1.51) - removed IsPosHoveringAnyWindow(ImVec2), which was partly broken and misleading. ASSERT + redirect user to io.WantCaptureMouse
 - 2017/05/26 (1.50) - removed ImFontConfig::MergeGlyphCenterV in favor of a more multipurpose ImFontConfig::GlyphOffset.
 - 2017/05/01 (1.50) - renamed ImDrawList::PathFill() (rarely used directly) to ImDrawList::PathFillConvex() for clarity.
 - 2016/11/06 (1.50) - BeginChild(const char*) now applies the stack id to the provided label, consistently with other functions as it should always have been. It shouldn't affect you unless (extremely unlikely) you were appending multiple times to a same child from different locations of the stack id. If that's the case, generate an id with GetID() and use it instead of passing string to BeginChild().
 - 2016/10/15 (1.50) - avoid 'rawptr user_data' parameter to io.SetClipboardTextFn/io.GetClipboardTextFn pointers. We pass io.ClipboardUserData to it.
 - 2016/09/25 (1.50) - style.WindowTitleAlign is now a ImVec2 (ImGuiAlign enum was removed). set to (0.5,0.5) for horizontal+vertical centering, (0.0,0.0) for upper-left, etc.
 - 2016/07/30 (1.50) - SameLine(x) with x>0.0 is now relative to left of column/group if any, and not always to left of window. This was sort of always the intent and hopefully, breakage should be minimal.
 - 2016/05/12 (1.49) - title bar (using ImGuiCol.TitleBg/ImGuiCol.TitleBgActive colors) isn't rendered over a window background (ImGuiCol.WindowBg color) anymore.
                       If your TitleBg/TitleBgActive alpha was 1.0 or you are using the default theme it will not affect you, otherwise if <1.0 you need to tweak your custom theme to readjust for the fact that we don't draw a WindowBg background behind the title bar.
                       This helper function will convert an old TitleBg/TitleBgActive color into a new one with the same visual output, given the OLD color and the OLD WindowBg color:
                       ImVec4 ConvertTitleBgCol(const ImVec4& win_bg_col, const ImVec4& title_bg_col) { f32 new_a = 1.0 - ((1.0 - win_bg_col.w) * (1.0 - title_bg_col.w)), k = title_bg_col.w / new_a; return ImVec4{(win_bg_col.x * win_bg_col.w + title_bg_col.x} * k, (win_bg_col.y * win_bg_col.w + title_bg_col.y) * k, (win_bg_col.z * win_bg_col.w + title_bg_col.z) * k, new_a); }
                       If this is confusing, pick the RGB value from title bar from an old screenshot and apply this as TitleBg/TitleBgActive. Or you may just create TitleBgActive from a tweaked TitleBg color.
 - 2016/05/07 (1.49) - removed confusing set of GetInternalState(), GetInternalStateSize(), SetInternalState() functions. Now using CreateContext(), DestroyContext(), GetCurrentContext(), SetCurrentContext().
 - 2016/05/02 (1.49) - renamed SetNextTreeNodeOpened() to SetNextTreeNodeOpen(), no redirection.
 - 2016/05/01 (1.49) - obsoleted old signature of CollapsingHeader(const char* label, const char* str_id = nil, bool display_frame = true, bool default_open = false) as extra parameters were badly designed and rarely used. You can replace the "default_open = true" flag in new API with CollapsingHeader(label, ImGuiTreeNodeFlags_DefaultOpen).
 - 2016/04/26 (1.49) - changed ImDrawList::PushClipRect(ImVec4 rect) to ImDrawList::PushClipRect(Imvec2 min,ImVec2 max,bool intersect_with_current_clip_rect=false). Note that higher-level PushClipRect() is preferable because it will clip at logic/widget level, whereas ImDrawList::PushClipRect() only affect your renderer.
 - 2016/04/03 (1.48) - removed style.WindowFillAlphaDefault setting which was redundant. Bake default BG alpha inside style.Colors[ImGuiCol.WindowBg] and all other Bg color values. (ref GitHub issue #337).
 - 2016/04/03 (1.48) - renamed ImGuiCol.TooltipBg to ImGuiCol.PopupBg, used by popups/menus and tooltips. popups/menus were previously using ImGuiCol.WindowBg. (ref github issue #337)
 - 2016/03/21 (1.48) - renamed GetWindowFont() to GetFont(), GetWindowFontSize() to GetFontSize(). Kept inline redirection function (will obsolete).
 - 2016/03/02 (1.48) - InputText() completion/history/always callbacks: if you modify the text buffer manually (without using DeleteChars()/InsertChars() helper) you need to maintain the BufTextLen field. added an assert.
 - 2016/01/23 (1.48) - fixed not honoring exact width passed to PushItemWidth(), previously it would add extra FramePadding.x*2 over that width. if you had manual pixel-perfect alignment in place it might affect you.
 - 2015/12/27 (1.48) - fixed ImDrawList::AddRect() which used to render a rectangle 1 px too large on each axis.
 - 2015/12/04 (1.47) - renamed Color() helpers to ValueColor() - dangerously named, rarely used and probably to be made obsolete.
 - 2015/08/29 (1.45) - with the addition of horizontal scrollbar we made various fixes to inconsistencies with dealing with cursor position.
                       GetCursorPos()/SetCursorPos() functions now include the scrolled amount. It shouldn't affect the majority of users, but take note that SetCursorPosX(100.0) puts you at +100 from the starting x position which may include scrolling, not at +100 from the window left side.
                       GetContentRegionMax()/GetWindowContentRegionMin()/GetWindowContentRegionMax() functions allow include the scrolled amount. Typically those were used in cases where no scrolling would happen so it may not be a problem, but watch out!
 - 2015/08/29 (1.45) - renamed style.ScrollbarWidth to style.ScrollbarSize
 - 2015/08/05 (1.44) - split imgui.cpp into extra files: imgui_demo.cpp imgui_draw.cpp imgui_internal.h that you need to add to your project.
 - 2015/07/18 (1.44) - fixed angles in ImDrawList::PathArcTo(), PathArcToFast() (introduced in 1.43) being off by an extra PI for no justifiable reason
 - 2015/07/14 (1.43) - add new ImFontAtlas::AddFont() API. For the old AddFont***, moved the 'font_no' parameter of ImFontAtlas::AddFont** functions to the ImFontConfig structure.
                       you need to render your textured triangles with bilinear filtering to benefit from sub-pixel positioning of text.
 - 2015/07/08 (1.43) - switched rendering data to use indexed rendering. this is saving a fair amount of CPU/GPU and enables us to get anti-aliasing for a marginal cost.
                       this necessary change will break your rendering function! the fix should be very easy. sorry for that :(
                     - if you are using a vanilla copy of one of the imgui_impl_XXX.cpp provided in the example, you just need to update your copy and you can ignore the rest.
                     - the signature of the io.RenderDrawListsFn handler has changed!
                       old: ImGui_XXXX_RenderDrawLists(ImDrawList** const cmd_lists, int cmd_lists_count)
                       new: ImGui_XXXX_RenderDrawLists(ImDrawData* draw_data).
                         parameters: 'cmd_lists' becomes 'draw_data.CmdLists', 'cmd_lists_count' becomes 'draw_data.CmdListsCount'
                         ImDrawList: 'commands' becomes 'CmdBuffer', 'vtx_buffer' becomes 'VtxBuffer', 'IdxBuffer' is new.
                         ImDrawCmd:  'vtx_count' becomes 'ElemCount', 'clip_rect' becomes 'ClipRect', 'user_callback' becomes 'UserCallback', 'texture_id' becomes 'TextureId'.
                     - each ImDrawList now contains both a vertex buffer and an index buffer. For each command, render ElemCount/3 triangles using indices from the index buffer.
                     - if you REALLY cannot render indexed primitives, you can call the draw_data.DeIndexAllBuffers() method to de-index the buffers. This is slow and a waste of CPU/GPU. Prefer using indexed rendering!
                     - refer to code in the examples/ folder or ask on the GitHub if you are unsure of how to upgrade. please upgrade!
 - 2015/07/10 (1.43) - changed SameLine() parameters from int to float.
 - 2015/07/02 (1.42) - renamed SetScrollPosHere() to SetScrollFromCursorPos(). Kept inline redirection function (will obsolete).
 - 2015/07/02 (1.42) - renamed GetScrollPosY() to GetScrollY(). Necessary to reduce confusion along with other scrolling functions, because positions (e.g. cursor position) are not equivalent to scrolling amount.
 - 2015/06/14 (1.41) - changed ImageButton() default bg_col parameter from (0,0,0,1) (black) to (0,0,0,0) (transparent) - makes a difference when texture have transparence
 - 2015/06/14 (1.41) - changed Selectable() API from (label, selected, size) to (label, selected, flags, size). Size override should have been rarely used. Sorry!
 - 2015/05/31 (1.40) - renamed GetWindowCollapsed() to IsWindowCollapsed() for consistency. Kept inline redirection function (will obsolete).
 - 2015/05/31 (1.40) - renamed IsRectClipped() to IsRectVisible() for consistency. Note that return value is opposite! Kept inline redirection function (will obsolete).
 - 2015/05/27 (1.40) - removed the third 'repeat_if_held' parameter from Button() - sorry! it was rarely used and inconsistent. Use PushButtonRepeat(true) / PopButtonRepeat() to enable repeat on desired buttons.
 - 2015/05/11 (1.40) - changed BeginPopup() API, takes a string identifier instead of a bool. ImGui needs to manage the open/closed state of popups. Call OpenPopup() to actually set the "open" state of a popup. BeginPopup() returns true if the popup is opened.
 - 2015/05/03 (1.40) - removed style.AutoFitPadding, using style.WindowPadding makes more sense (the default values were already the same).
 - 2015/04/13 (1.38) - renamed IsClipped() to IsRectClipped(). Kept inline redirection function until 1.50.
 - 2015/04/09 (1.38) - renamed ImDrawList::AddArc() to ImDrawList::AddArcFast() for compatibility with future API
 - 2015/04/03 (1.38) - removed ImGuiCol.CheckHovered, ImGuiCol.CheckActive, replaced with the more general ImGuiCol.FrameBgHovered, ImGuiCol.FrameBgActive.
 - 2014/04/03 (1.38) - removed support for passing -math.F32_MAX..+math.F32_MAX as the range for a SliderFloat(). Use DragFloat() or Inputfloat() instead.
 - 2015/03/17 (1.36) - renamed GetItemBoxMin()/GetItemBoxMax()/IsMouseHoveringBox() to GetItemRectMin()/GetItemRectMax()/IsMouseHoveringRect(). Kept inline redirection function until 1.50.
 - 2015/03/15 (1.36) - renamed style.TreeNodeSpacing to style.IndentSpacing, ImGuiStyleVar_TreeNodeSpacing to ImGuiStyleVar_IndentSpacing
 - 2015/03/13 (1.36) - renamed GetWindowIsFocused() to IsWindowFocused(). Kept inline redirection function until 1.50.
 - 2015/03/08 (1.35) - renamed style.ScrollBarWidth to style.ScrollbarWidth (casing)
 - 2015/02/27 (1.34) - renamed OpenNextNode(bool) to SetNextTreeNodeOpened(bool, ImGuiSetCond). Kept inline redirection function until 1.50.
 - 2015/02/27 (1.34) - renamed ImGuiSetCondition_*** to ImGuiSetCond_***, and _FirstUseThisSession becomes _Once.
 - 2015/02/11 (1.32) - changed text input callback ImGuiTextEditCallback return type from void-->int. reserved for future use, return 0 for now.
 - 2015/02/10 (1.32) - renamed GetItemWidth() to CalcItemWidth() to clarify its evolving behavior
 - 2015/02/08 (1.31) - renamed GetTextLineSpacing() to GetTextLineHeightWithSpacing()
 - 2015/02/01 (1.31) - removed IO.MemReallocFn (unused)
 - 2015/01/19 (1.30) - renamed ImGuiStorage::GetIntPtr()/GetFloatPtr() to GetIntRef()/GetIntRef() because Ptr was conflicting with actual pointer storage functions.
 - 2015/01/11 (1.30) - big font/image API change! now loads TTF file. allow for multiple fonts. no need for a PNG loader.
 - 2015/01/11 (1.30) - removed GetDefaultFontData(). uses io.Fonts.GetTextureData*() API to retrieve uncompressed pixels.
                       - old:  const rawptr png_data; u32 png_size; GetDefaultFontData(nil, nil, &png_data, &png_size); [..Upload texture to GPU..];
                       - new:  u8* pixels; int width, height; io.Fonts.GetTexDataAsRGBA32(&pixels, &width, &height); [..Upload texture to GPU..]; io.Fonts.SetTexID(YourTexIdentifier);
                       you now have more flexibility to load multiple TTF fonts and manage the texture buffer for internal needs. It is now recommended that you sample the font texture with bilinear interpolation.
 - 2015/01/11 (1.30) - added texture identifier in ImDrawCmd passed to your render function (we can now render images). make sure to call io.Fonts.SetTexID()
 - 2015/01/11 (1.30) - removed IO.PixelCenterOffset (unnecessary, can be handled in user projection matrix)
 - 2015/01/11 (1.30) - removed IsItemFocused() in favor of IsItemActive() which handles all widgets
 - 2014/12/10 (1.18) - removed SetNewWindowDefaultPos() in favor of new generic API SetNextWindowPos(pos, ImGuiSetCondition_FirstUseEver)
 - 2014/11/28 (1.17) - moved IO.Font*** options to inside the IO.Font-> structure (FontYOffset, FontTexUvForWhite, FontBaseScale, FontFallbackGlyph)
 - 2014/11/26 (1.17) - reworked syntax of IMGUI_ONCE_UPON_A_FRAME helper macro to increase compiler compatibility
 - 2014/11/07 (1.15) - renamed IsHovered() to IsItemHovered()
 - 2014/10/02 (1.14) - renamed IMGUI_INCLUDE_IMGUI_USER_CPP to IMGUI_INCLUDE_IMGUI_USER_INL and imgui_user.cpp to imgui_user.inl (more IDE friendly)
 - 2014/09/25 (1.13) - removed 'text_end' parameter from IO.SetClipboardTextFn (the string is now always zero-terminated for simplicity)
 - 2014/09/24 (1.12) - renamed SetFontScale() to SetWindowFontScale()
 - 2014/09/24 (1.12) - moved IM_MALLOC/IM_REALLOC/IM_FREE preprocessor defines to IO.MemAllocFn/IO.MemReallocFn/IO.MemFreeFn
 - 2014/08/30 (1.09) - removed IO.FontHeight (now computed automatically)
 - 2014/08/30 (1.09) - moved IMGUI_FONT_TEX_UV_FOR_WHITE preprocessor define to IO.FontTexUvForWhite
 - 2014/08/28 (1.09) - changed the behavior of IO.PixelCenterOffset following various rendering fixes


 FREQUENTLY ASKED QUESTIONS (FAQ)
 ================================

 Read all answers online:
   https://www.dearimgui.com/faq or https://github.com/ocornut/imgui/blob/master/docs/FAQ.md (same url)
 Read all answers locally (with a text editor or ideally a Markdown viewer):
   docs/FAQ.md
 Some answers are copied down here to facilitate searching in code.

 Q&A: Basics
 ===========

 Q: Where is the documentation?
 A: This library is poorly documented at the moment and expects the user to be acquainted with C/C++.
    - Run the examples/ applications and explore them.
    - Read Getting Started (https://github.com/ocornut/imgui/wiki/Getting-Started) guide.
    - See demo code in imgui_demo.cpp and particularly the ShowDemoWindow() function.
    - The demo covers most features of Dear ImGui, so you can read the code and see its output.
    - See documentation and comments at the top of imgui.cpp + effectively imgui.h.
    - 20+ standalone example applications using e.g. OpenGL/DirectX are provided in the
      examples/ folder to explain how to integrate Dear ImGui with your own engine/application.
    - The Wiki (https://github.com/ocornut/imgui/wiki) has many resources and links.
    - The Glossary (https://github.com/ocornut/imgui/wiki/Glossary) page also may be useful.
    - Your programming IDE is your friend, find the type or function declaration to find comments
      associated with it.

 Q: What is this library called?
 Q: Which version should I get?
 >> This library is called "Dear ImGui", please don't call it "ImGui" :)
 >> See https://www.dearimgui.com/faq for details.

 Q&A: Integration
 ================

 Q: How to get started?
 A: Read https://github.com/ocornut/imgui/wiki/Getting-Started. Read 'PROGRAMMER GUIDE' above. Read examples/README.txt.

 Q: How can I tell whether to dispatch mouse/keyboard to Dear ImGui or my application?
 A: You should read the 'io.WantCaptureMouse', 'io.WantCaptureKeyboard' and 'io.WantTextInput' flags!
 >> See https://www.dearimgui.com/faq for a fully detailed answer. You really want to read this.

 Q. How can I enable keyboard or gamepad controls?
 Q: How can I use this on a machine without mouse, keyboard or screen? (input share, remote display)
 Q: I integrated Dear ImGui in my engine and little squares are showing instead of text...
 Q: I integrated Dear ImGui in my engine and some elements are clipping or disappearing when I move windows around...
 Q: I integrated Dear ImGui in my engine and some elements are displaying outside their expected windows boundaries...
 >> See https://www.dearimgui.com/faq

 Q&A: Usage
 ----------

 Q: About the ID Stack system..
   - Why is my widget not reacting when I click on it?
   - How can I have widgets with an empty label?
   - How can I have multiple widgets with the same label?
   - How can I have multiple windows with the same label?
 Q: How can I display an image? What is ImTextureID, how does it work?
 Q: How can I use my own math types instead of ImVec2?
 Q: How can I interact with standard C++ types (such as std::string and std::vector)?
 Q: How can I display custom shapes? (using low-level ImDrawList API)
 >> See https://www.dearimgui.com/faq

 Q&A: Fonts, Text
 ================

 Q: How should I handle DPI in my application?
 Q: How can I load a different font than the default?
 Q: How can I easily use icons in my application?
 Q: How can I load multiple fonts?
 Q: How can I display and input non-Latin characters such as Chinese, Japanese, Korean, Cyrillic?
 >> See https://www.dearimgui.com/faq and https://github.com/ocornut/imgui/blob/master/docs/FONTS.md

 Q&A: Concerns
 =============

 Q: Who uses Dear ImGui?
 Q: Can you create elaborate/serious tools with Dear ImGui?
 Q: Can you reskin the look of Dear ImGui?
 Q: Why using C++ (as opposed to C)?
 >> See https://www.dearimgui.com/faq

 Q&A: Community
 ==============

 Q: How can I help?
 A: - Businesses: please reach out to "omar AT dearimgui DOT com" if you work in a place using Dear ImGui!
      We can discuss ways for your company to fund development via invoiced technical support, maintenance or sponsoring contacts.
      This is among the most useful thing you can do for Dear ImGui. With increased funding, we sustain and grow work on this project.
      >>> See https://github.com/ocornut/imgui/wiki/Funding
    - Businesses: you can also purchase licenses for the Dear ImGui Automation/Test Engine.
    - If you are experienced with Dear ImGui and C++, look at the GitHub issues, look at the Wiki, and see how you want to help and can help!
    - Disclose your usage of Dear ImGui via a dev blog post, a tweet, a screenshot, a mention somewhere etc.
      You may post screenshot or links in the gallery threads. Visuals are ideal as they inspire other programmers.
      But even without visuals, disclosing your use of dear imgui helps the library grow credibility, and help other teams and programmers with taking decisions.
    - If you have issues or if you need to hack into the library, even if you don't expect any support it is useful that you share your issues (on GitHub or privately).

*/

import "core:math"
import "core:strings"
import "core:bytes"
import "core:mem"
import "core:fmt"
import "core:io"
import "core:slice"
import "core:simd"
import "core:os"
import "base:runtime"

// Debug options
IMGUI_DEBUG_NAV_SCORING :: 0   // Display navigation scoring preview when hovering items. Hold CTRL to display for all candidates. CTRL+Arrow to change last direction.
IMGUI_DEBUG_NAV_RECTS :: 0   // Display the reference navigation rectangle for each window

// When using CTRL+TAB (or Gamepad Square+L/R) we delay the visual a little in order to reduce visual noise doing a fast switch.
NAV_WINDOWING_HIGHLIGHT_DELAY            : f32    :  0.20;    // Time before the highlight and screen dimming starts fading in
NAV_WINDOWING_LIST_APPEAR_DELAY          : f32    :  0.15;    // Time before the window list starts to appear

NAV_ACTIVATE_HIGHLIGHT_TIMER             : f32    :  0.10;    // Time to highlight an item activated by a shortcut.

// Window resizing from edges (when io.ConfigWindowsResizeFromEdges = true and ImGuiBackendFlags_HasMouseCursors is set in io.BackendFlags by backend)
WINDOWS_HOVER_PADDING                    : f32    :  4.0;     // Extend outside window for hovering/resizing (maxxed with TouchPadding) and inside windows for borders. Affect FindHoveredWindow().
WINDOWS_RESIZE_FROM_EDGES_FEEDBACK_TIMER : f32    :  0.04;    // Reduce visual noise by only highlighting the border after a certain time.
WINDOWS_MOUSE_WHEEL_SCROLL_LOCK_TIMER    : f32    :  0.70;    // Lock scrolled window (so it doesn't pick child windows that are scrolling through) for a certain time, unless mouse moved.

// Tooltip offset
TOOLTIP_DEFAULT_OFFSET_MOUSE             : ImVec2 :  ImVec2{16, 10};      // Multiplied by g.Style.MouseCursorScale
TOOLTIP_DEFAULT_OFFSET_TOUCH             : ImVec2 :  ImVec2{0, -20};      // Multiplied by g.Style.MouseCursorScale
TOOLTIP_DEFAULT_PIVOT_TOUCH              : ImVec2 :  ImVec2{0.5, 1.0};   // Multiplied by g.Style.MouseCursorScale

// Docking
DOCKING_TRANSPARENT_PAYLOAD_ALPHA        : f32    :  0.50;    // For use with io.ConfigDockingTransparentPayload. Apply to Viewport _or_ WindowBg in host viewport.

// Viewports
IMGUI_VIEWPORT_DEFAULT_ID :: ImGuiID(0x11111111); // Using an arbitrary constant instead of e.g. ImHashStr("ViewportDefault", 0); so it's easier to spot in the debugger. The exact value doesn't matter.

//-----------------------------------------------------------------------------
// [SECTION] CONTEXT AND MEMORY ALLOCATORS
//-----------------------------------------------------------------------------

// DLL users:
// - Heaps and globals are not shared across DLL boundaries!
// - You will need to call SetCurrentContext() + SetAllocatorFunctions() for each static/DLL boundary you are calling from.
// - Same applies for hot-reloading mechanisms that are reliant on reloading DLL (note that many hot-reloading mechanisms work without DLL).
// - Using Dear ImGui via a shared library is not recommended, because of function call overhead and because we don't guarantee backward nor forward ABI compatibility.
// - Confused? In a debugger: add GImGui to your watch window and notice how its value changes depending on your current location (which DLL boundary you are in).

// Current context pointer. Implicitly used by all Dear ImGui functions. Always assumed to be != NULL.
// - ImGui::CreateContext() will automatically set this pointer if it is NULL.
//   Change to a different context by calling ImGui::SetCurrentContext().
// - Important: Dear ImGui functions are not thread-safe because of this pointer.
//   If you want thread-safety to allow N threads to access N different contexts:
//   - Change this variable to use thread local storage so each thread can refer to a different context, in your imconfig.h:
//         struct ImGuiContext;
//         extern thread_local ImGuiContext* MyImGuiTLS;
//         #define GImGui MyImGuiTLS
//     And then define MyImGuiTLS in one of your cpp files. Note that thread_local is a C++11 keyword, earlier C++ uses compiler-specific keyword.
//   - Future development aims to make this context pointer explicit to all calls. Also read https://github.com/ocornut/imgui/issues/586
//   - If you need a finite number of contexts, you may compile and use multiple instances of the ImGui code from a different namespace.
// - DLL users: read comments above.
GImGui : ^ImGuiContext

// Memory Allocator functions. Use SetAllocatorFunctions() to change them.
// - You probably don't want to modify that mid-program, and if you use global/static e.g. ImVector<> instances you may need to keep them accessible during program destruction.
// - DLL users: read comments above.
MallocWrapper :: proc(size : int, user_data : rawptr) -> rawptr   { _ = user_data; return cast(rawptr) raw_data(make([]u8, size)); } //TODO(Rennorb)
FreeWrapper :: proc(ptr : rawptr, user_data : rawptr)             { _ = user_data; free(ptr); }
GImAllocatorAllocFunc : ImGuiMemAllocFunc = MallocWrapper;
GImAllocatorFreeFunc : ImGuiMemFreeFunc = FreeWrapper;
GImAllocatorUserData : rawptr = nil;

//-----------------------------------------------------------------------------
// [SECTION] USER FACING STRUCTURES (ImGuiStyle, ImGuiIO, ImGuiPlatformIO)
//-----------------------------------------------------------------------------

init_ImGuiStyle :: proc(this : ^ImGuiStyle)
{
    this.Alpha                       = 1.0;             // Global alpha applies to everything in Dear ImGui.
    this.DisabledAlpha               = 0.60;            // Additional alpha multiplier applied by BeginDisabled(). Multiply over current value of Alpha.
    this.WindowPadding               = ImVec2{8,8};      // Padding within a window
    this.WindowRounding              = 0.0;             // Radius of window corners rounding. Set to 0.0f to have rectangular windows. Large values tend to lead to variety of artifacts and are not recommended.
    this.WindowBorderSize            = 1.0;             // Thickness of border around windows. Generally set to 0.0f or 1.0f. Other values not well tested.
    this.WindowMinSize               = ImVec2{32,32};    // Minimum window size
    this.WindowTitleAlign            = ImVec2{0.0,0.5};// Alignment for title bar text
    this.WindowMenuButtonPosition    = .Left;    // Position of the collapsing/docking button in the title bar (left/right). Defaults to .Left.
    this.ChildRounding               = 0.0;             // Radius of child window corners rounding. Set to 0.0f to have rectangular child windows
    this.ChildBorderSize             = 1.0;             // Thickness of border around child windows. Generally set to 0.0f or 1.0f. Other values not well tested.
    this.PopupRounding               = 0.0;             // Radius of popup window corners rounding. Set to 0.0f to have rectangular child windows
    this.PopupBorderSize             = 1.0;             // Thickness of border around popup or tooltip windows. Generally set to 0.0f or 1.0f. Other values not well tested.
    this.FramePadding                = ImVec2{4,3};      // Padding within a framed rectangle (used by most widgets)
    this.FrameRounding               = 0.0;             // Radius of frame corners rounding. Set to 0.0f to have rectangular frames (used by most widgets).
    this.FrameBorderSize             = 0.0;             // Thickness of border around frames. Generally set to 0.0f or 1.0f. Other values not well tested.
    this.ItemSpacing                 = ImVec2{8,4};      // Horizontal and vertical spacing between widgets/lines
    this.ItemInnerSpacing            = ImVec2{4,4};      // Horizontal and vertical spacing between within elements of a composed widget (e.g. a slider and its label)
    this.CellPadding                 = ImVec2{4,2};      // Padding within a table cell. Cellpadding.x is locked for entire table. CellPadding.y may be altered between different rows.
    this.TouchExtraPadding           = ImVec2{0,0};      // Expand reactive bounding box for touch-based system where touch position is not accurate enough. Unfortunately we don't sort widgets so priority on overlap will always be given to the first widget. So don't grow this too much!
    this.IndentSpacing               = 21.0;            // Horizontal spacing when e.g. entering a tree node. Generally == (FontSize + FramePadding.x*2).
    this.ColumnsMinSpacing           = 6.0;             // Minimum horizontal spacing between two columns. Preferably > (FramePadding.x + 1).
    this.ScrollbarSize               = 14.0;            // Width of the vertical scrollbar, Height of the horizontal scrollbar
    this.ScrollbarRounding           = 9.0;             // Radius of grab corners rounding for scrollbar
    this.GrabMinSize                 = 12.0;            // Minimum width/height of a grab box for slider/scrollbar
    this.GrabRounding                = 0.0;             // Radius of grabs corners rounding. Set to 0.0f to have rectangular slider grabs.
    this.LogSliderDeadzone           = 4.0;             // The size in pixels of the dead-zone around zero on logarithmic sliders that cross zero.
    this.TabRounding                 = 4.0;             // Radius of upper corners of a tab. Set to 0.0f to have rectangular tabs.
    this.TabBorderSize               = 0.0;             // Thickness of border around tabs.
    this.TabMinWidthForCloseButton   = 0.0;             // Minimum width for close button to appear on an unselected tab when hovered. Set to 0.0f to always show when hovering, set to FLT_MAX to never show close button unless selected.
    this.TabBarBorderSize            = 1.0;             // Thickness of tab-bar separator, which takes on the tab active color to denote focus.
    this.TabBarOverlineSize          = 2.0;             // Thickness of tab-bar overline, which highlights the selected tab-bar.
    this.TableAngledHeadersAngle     = 35.0 * (IM_PI / 180.0); // Angle of angled headers (supported values range from -50 degrees to +50 degrees).
    this.TableAngledHeadersTextAlign = ImVec2{0.5,0.0};// Alignment of angled headers within the cell
    this.ColorButtonPosition         = .Right;   // Side of the color button in the ColorEdit4 widget (left/right). Defaults to .Right.
    this.ButtonTextAlign             = ImVec2{0.5,0.5};// Alignment of button text when button is larger than text.
    this.SelectableTextAlign         = ImVec2{0.0,0.0};// Alignment of selectable text. Defaults to (0.0f, 0.0f) (top-left aligned). It's generally important to keep this left-aligned if you want to lay multiple items on a same line.
    this.SeparatorTextBorderSize     = 3.0;             // Thickness of border in SeparatorText()
    this.SeparatorTextAlign          = ImVec2{0.0,0.5};// Alignment of text within the separator. Defaults to (0.0f, 0.5f) (left aligned, center).
    this.SeparatorTextPadding        = ImVec2{20.0,3.0};// Horizontal offset of text from each edge of the separator + spacing on other axis. Generally small values. .y is recommended to be == FramePadding.y.
    this.DisplayWindowPadding        = ImVec2{19,19};    // Window position are clamped to be visible within the display area or monitors by at least this amount. Only applies to regular windows.
    this.DisplaySafeAreaPadding      = ImVec2{3,3};      // If you cannot see the edge of your screen (e.g. on a TV) increase the safe area padding. Covers popups/tooltips as well regular windows.
    this.DockingSeparatorSize        = 2.0;             // Thickness of resizing border between docked windows
    this.MouseCursorScale            = 1.0;             // Scale software rendered mouse cursor (when io.MouseDrawCursor is enabled). May be removed later.
    this.AntiAliasedLines            = true;             // Enable anti-aliased lines/borders. Disable if you are really tight on CPU/GPU.
    this.AntiAliasedLinesUseTex      = true;             // Enable anti-aliased lines/borders using textures where possible. Require backend to render with bilinear filtering (NOT point/nearest filtering).
    this.AntiAliasedFill             = true;             // Enable anti-aliased filled shapes (rounded rectangles, circles, etc.).
    this.CurveTessellationTol        = 1.25;            // Tessellation tolerance when using PathBezierCurveTo() without a specific number of segments. Decrease for highly tessellated curves (higher quality, more polygons), increase to reduce quality.
    this.CircleTessellationMaxError  = 0.30;            // Maximum error (in pixels) allowed when using AddCircle()/AddCircleFilled() or drawing rounded corner rectangles with no explicit segment count specified. Decrease for higher quality but more geometry.

    // Behaviors
    this.HoverStationaryDelay        = 0.15;            // Delay for IsItemHovered(ImGuiHoveredFlags_Stationary). Time required to consider mouse stationary.
    this.HoverDelayShort             = 0.15;            // Delay for IsItemHovered(ImGuiHoveredFlags_DelayShort). Usually used along with HoverStationaryDelay.
    this.HoverDelayNormal            = 0.40;            // Delay for IsItemHovered(ImGuiHoveredFlags_DelayNormal). "
    this.HoverFlagsForTooltipMouse   = { .Stationary, .DelayShort, .AllowWhenDisabled }    // Default flags when using IsItemHovered(ImGuiHoveredFlags_ForTooltip) or BeginItemTooltip()/SetItemTooltip() while using mouse.
    this.HoverFlagsForTooltipNav     = { .NoSharedDelay, .DelayNormal, .AllowWhenDisabled }  // Default flags when using IsItemHovered(ImGuiHoveredFlags_ForTooltip) or BeginItemTooltip()/SetItemTooltip() while using keyboard/gamepad.

    // Default theme
    StyleColorsDark(this);
}

// To scale your entire UI (e.g. if you want your app to use High DPI or generally be DPI aware) you may use this helper function. Scaling the fonts is done separately and is up to you.
// Important: This operation is lossy because we round all sizes to integer. If you need to change your scale multiples, call this over a freshly initialized ImGuiStyle structure rather than scaling multiple times.
ScaleAllSizes :: proc(this : ^ImGuiStyle, scale_factor : f32)
{
    this.WindowPadding             = ImTrunc(this.WindowPadding * scale_factor);
    this.WindowRounding            = ImTrunc(this.WindowRounding * scale_factor);
    this.WindowMinSize             = ImTrunc(this.WindowMinSize * scale_factor);
    this.ChildRounding             = ImTrunc(this.ChildRounding * scale_factor);
    this.PopupRounding             = ImTrunc(this.PopupRounding * scale_factor);
    this.FramePadding              = ImTrunc(this.FramePadding * scale_factor);
    this.FrameRounding             = ImTrunc(this.FrameRounding * scale_factor);
    this.ItemSpacing               = ImTrunc(this.ItemSpacing * scale_factor);
    this.ItemInnerSpacing          = ImTrunc(this.ItemInnerSpacing * scale_factor);
    this.CellPadding               = ImTrunc(this.CellPadding * scale_factor);
    this.TouchExtraPadding         = ImTrunc(this.TouchExtraPadding * scale_factor);
    this.IndentSpacing             = ImTrunc(this.IndentSpacing * scale_factor);
    this.ColumnsMinSpacing         = ImTrunc(this.ColumnsMinSpacing * scale_factor);
    this.ScrollbarSize             = ImTrunc(this.ScrollbarSize * scale_factor);
    this.ScrollbarRounding         = ImTrunc(this.ScrollbarRounding * scale_factor);
    this.GrabMinSize               = ImTrunc(this.GrabMinSize * scale_factor);
    this.GrabRounding              = ImTrunc(this.GrabRounding * scale_factor);
    this.LogSliderDeadzone         = ImTrunc(this.LogSliderDeadzone * scale_factor);
    this.TabRounding               = ImTrunc(this.TabRounding * scale_factor);
    this.TabMinWidthForCloseButton = (this.TabMinWidthForCloseButton != math.F32_MAX) ? ImTrunc(this.TabMinWidthForCloseButton * scale_factor) : math.F32_MAX;
    this.TabBarOverlineSize        = ImTrunc(this.TabBarOverlineSize * scale_factor);
    this.SeparatorTextPadding      = ImTrunc(this.SeparatorTextPadding * scale_factor);
    this.DockingSeparatorSize      = ImTrunc(this.DockingSeparatorSize * scale_factor);
    this.DisplayWindowPadding      = ImTrunc(this.DisplayWindowPadding * scale_factor);
    this.DisplaySafeAreaPadding    = ImTrunc(this.DisplaySafeAreaPadding * scale_factor);
    this.MouseCursorScale          = ImTrunc(this.MouseCursorScale * scale_factor);
}

init_ImGuiIO :: proc(this : ^ImGuiIO)
{
    // Most fields are initialized with zero
    this^ = {};

    // Settings
    this.ConfigFlags = nil;
    this.BackendFlags = nil;
    this.DisplaySize = ImVec2{-1.0, -1.0};
    this.DeltaTime = 1.0 / 60.0;
    this.IniSavingRate = 5.0;
    this.IniFilename = "imgui.ini"; // Important: "imgui.ini" is relative to current working dir, most apps will want to lock this to an absolute path (e.g. same path as executables).
    this.LogFilename = "imgui_log.txt";
    this.UserData = nil;

    this.Fonts = nil;
    this.FontGlobalScale = 1.0;
    this.FontDefault = nil;
    this.FontAllowUserScaling = false;
    this.DisplayFramebufferScale = ImVec2{1.0, 1.0};

    // Keyboard/Gamepad Navigation options
    this.ConfigNavSwapGamepadButtons = false;
    this.ConfigNavMoveSetMousePos = false;
    this.ConfigNavCaptureKeyboard = true;
    this.ConfigNavEscapeClearFocusItem = true;
    this.ConfigNavEscapeClearFocusWindow = false;
    this.ConfigNavCursorVisibleAuto = true;
    this.ConfigNavCursorVisibleAlways = false;

    // Docking options (when ImGuiConfigFlags_DockingEnable is set)
    this.ConfigDockingNoSplit = false;
    this.ConfigDockingWithShift = false;
    this.ConfigDockingAlwaysTabBar = false;
    this.ConfigDockingTransparentPayload = false;

    // Viewport options (when ImGuiConfigFlags_ViewportsEnable is set)
    this.ConfigViewportsNoAutoMerge = false;
    this.ConfigViewportsNoTaskBarIcon = false;
    this.ConfigViewportsNoDecoration = true;
    this.ConfigViewportsNoDefaultParent = false;

    // Miscellaneous options
    this.MouseDrawCursor = false;
    this.ConfigMacOSXBehaviors = true when ODIN_OS == .Darwin else false;  // Set Mac OS X style defaults based on __APPLE__ compile time flag
    this.ConfigInputTrickleEventQueue = true;
    this.ConfigInputTextCursorBlink = true;
    this.ConfigInputTextEnterKeepActive = false;
    this.ConfigDragClickToInputText = false;
    this.ConfigWindowsResizeFromEdges = true;
    this.ConfigWindowsMoveFromTitleBarOnly = false;
    this.ConfigWindowsCopyContentsWithCtrlC = false;
    this.ConfigScrollbarScrollByPage = true;
    this.ConfigMemoryCompactTimer = 60.0;
    this.ConfigDebugIsDebuggerPresent = false;
    this.ConfigDebugHighlightIdConflicts = true;
    this.ConfigDebugBeginReturnValueOnce = false;
    this.ConfigDebugBeginReturnValueLoop = false;

    this.ConfigErrorRecovery = true;
    this.ConfigErrorRecoveryEnableAssert = true;
    this.ConfigErrorRecoveryEnableDebugLog = true;
    this.ConfigErrorRecoveryEnableTooltip = true;

    // Inputs Behaviors
    this.MouseDoubleClickTime = 0.30;
    this.MouseDoubleClickMaxDist = 6.0;
    this.MouseDragThreshold = 6.0;
    this.KeyRepeatDelay = 0.275;
    this.KeyRepeatRate = 0.050;

    // Platform Functions
    // Note: Initialize() will setup default clipboard/ime handlers.
    this.BackendPlatformName = ""
    this.BackendRendererName = "";
    this.BackendPlatformUserData = nil
    this.BackendRendererUserData = nil
    this.BackendLanguageUserData = nil;

    // Input (NB: we already have memset zero the entire structure!)
    this.MousePos = ImVec2{-math.F32_MAX, -math.F32_MAX};
    this.MousePosPrev = ImVec2{-math.F32_MAX, -math.F32_MAX};
    this.MouseSource = .Mouse;
    for i := 0; i < len(this.MouseDownDuration); i += 1 { this.MouseDownDuration[i] = -1; this.MouseDownDurationPrev[i] = -1.0;}
    for i := 0; i < len(this.KeysData); i += 1 { this.KeysData[i].DownDuration = -1; this.KeysData[i].DownDurationPrev = -1.0; }
    this.AppAcceptingEvents = true;
}

// Pass in translated ASCII characters for text input.
// - with glfw you can get those from the callback set in glfwSetCharCallback()
// - on Windows you can get those using ToAscii+keyboard state, or via the WM_CHAR message
// FIXME: Should in theory be called "AddCharacterEvent()" to be consistent with new API
// [forward declared comment]:
// Queue a new character input
AddInputCharacter :: proc(this : ^ImGuiIO, c : u32)
{
    assert(this.Ctx != nil);
    g := this.Ctx;
    if (c == 0 || !this.AppAcceptingEvents)   do return

    e : ImGuiInputEvent
    e.Type = .Text;
    e.Source = .Keyboard;
    g.InputEventsNextEventId += 1;
    e.EventId = g.InputEventsNextEventId
    e.Text.Char = c;
    append(&g.InputEventsQueue, e);
}

// UTF16 strings use surrogate pairs to encode codepoints >= 0x10000, so
// we should save the high surrogate.
// [forward declared comment]:
// Queue a new character input from a UTF-16 character, it can be a surrogate
AddInputCharacterUTF16 :: proc(this : ^ImGuiIO, c : ImWchar16)
{
    if ((c == 0 && this.InputQueueSurrogate == 0) || !this.AppAcceptingEvents)   do return

    if ((c & 0xFC00) == 0xD800) // High surrogate, must save
    {
        if (this.InputQueueSurrogate != 0) do AddInputCharacter(this, IM_UNICODE_CODEPOINT_INVALID);
        this.InputQueueSurrogate = c;
        return;
    }

    cp := c;
    if (this.InputQueueSurrogate != 0)
    {
        if ((c & 0xFC00) != 0xDC00) // Invalid low surrogate
        {
            AddInputCharacter(this, IM_UNICODE_CODEPOINT_INVALID);
        }
        else
        {
when IM_UNICODE_CODEPOINT_MAX == 0xFFFF {
            cp = IM_UNICODE_CODEPOINT_INVALID; // Codepoint will not fit in ImWchar
} else {
            cp = (ImWchar)(((this.InputQueueSurrogate - 0xD800) << 10) + (c - 0xDC00) + 0x10000);
}
        }

        this.InputQueueSurrogate = 0;
    }
    AddInputCharacter(this, u32(cp));
}

// [forward declared comment]:
// Queue a new characters input from a UTF-8 string
AddInputCharactersUTF8 :: proc(this : ^ImGuiIO, utf8_chars : [^]u8)
{
    utf8_chars := utf8_chars

    if (!this.AppAcceptingEvents)   do return
    for (utf8_chars[0] != 0)
    {
        c : u32;
        new_chars := ImTextCharFromUtf8(&c, utf8_chars, nil)
        utf8_chars = utf8_chars[new_chars:];
        AddInputCharacter(this, c);
    }
}

// Clear all incoming events.
// [forward declared comment]:
// Clear all incoming events.
ClearEventsQueue :: proc(this : ^ImGuiIO)
{
    assert(this.Ctx != nil);
    g := this.Ctx;
    clear(&g.InputEventsQueue)
}

// Clear current keyboard/gamepad state + current frame text input buffer. Equivalent to releasing all keys/buttons.
// [forward declared comment]:
// Clear current keyboard/gamepad state + current frame text input buffer. Equivalent to releasing all keys/buttons.
ClearInputKeys :: proc(this : ^ImGuiIO)
{
    g := this.Ctx;
    for key := ImGuiKey.NamedKey_BEGIN; key < ImGuiKey.NamedKey_END; key += ImGuiKey(1)
    {
        if (IsMouseKey(ImGuiKey(key)))   do continue
        key_data := &g.IO.KeysData[key - ImGuiKey.NamedKey_BEGIN];
        key_data.Down = false;
        key_data.DownDuration = -1.0;
        key_data.DownDurationPrev = -1.0;
    }
    this.KeyCtrl = false;
    this.KeyShift = false
    this.KeyAlt = false
    this.KeySuper = false;
    this.KeyMods = {};
    clear(&this.InputQueueCharacters); // Behavior of old ClearInputCharacters().
}

// [forward declared comment]:
// Clear current mouse state.
ClearInputMouse :: proc(this : ^ImGuiIO)
{
    for key : ImGuiKey = ImGuiKey_Mouse_BEGIN; key < ImGuiKey_Mouse_END; key += ImGuiKey(1)
    {
        key_data := &this.KeysData[key - ImGuiKey.NamedKey_BEGIN];
        key_data.Down = false;
        key_data.DownDuration = -1.0;
        key_data.DownDurationPrev = -1.0;
    }
    this.MousePos = ImVec2{-math.F32_MAX, -math.F32_MAX};
    for n := 0; n < len(this.MouseDown); n += 1
    {
        this.MouseDown[n] = false;
        this.MouseDownDurationPrev[n] = -1.0;
        this.MouseDownDuration[n] = -1
    }
    this.MouseWheel = 0
    this.MouseWheelH = 0.0;
}

// Removed this as it is ambiguous/misleading and generally incorrect to use with the existence of a higher-level input queue.
// Current frame character buffer is now also cleared by ClearInputKeys().

FindLatestInputEvent :: proc(ctx : ^ImGuiContext, type : ImGuiInputEventType, arg : i32 = -1) -> ^ImGuiInputEvent
{
    g := ctx;
    #reverse for &e in g.InputEventsQueue {
        if (e.Type != type)   do continue
        if (type == .Key && i32(e.Key.Key) != arg)   do continue
        if (type == .MouseButton && i32(e.MouseButton.Button) != arg)   do continue
        return &e; // TODO(Rennorb) @correctness
    }
    return nil;
}

// Queue a new key down/up event.
// - ImGuiKey key:       Translated key (as in, generally ImGuiKey.A matches the key end-user would use to emit an 'A' character)
// - bool down:          Is the key down? use false to signify a key release.
// - float analog_value: 0.0f..1.0f
// IMPORTANT: THIS FUNCTION AND OTHER "ADD" GRABS THE CONTEXT FROM OUR INSTANCE.
// WE NEED TO ENSURE THAT ALL FUNCTION CALLS ARE FULFILLING THIS, WHICH IS WHY GetKeyData() HAS AN EXPLICIT CONTEXT.
// [forward declared comment]:
// Queue a new key down/up event for analog values (e.g. ImGuiKey.Gamepad_ values). Dead-zones should be handled by the backend.
AddKeyAnalogEvent :: proc(this : ^ImGuiIO, key : ImGuiKey, down : bool, analog_value : f32)
{
    //if (e.Down) { IMGUI_DEBUG_LOG_IO("AddKeyEvent() Key='%s' %d, NativeKeycode = %d, NativeScancode = %d\n", ImGui::GetKeyName(e.Key), e.Down, e.NativeKeycode, e.NativeScancode); }
    assert(this.Ctx != nil);
    if (key == nil || !this.AppAcceptingEvents)   do return
    g := this.Ctx;
    assert(IsNamedKeyOrMod(key)); // Backend needs to pass a valid ImGuiKey. constant. 0..511 values are legacy native key codes which are not accepted by this API.
    assert(IsAliasKey(key) == false); // Backend cannot submit ImGuiKey.MouseXXX values they are automatically inferred from AddMouseXXX() events.

    key := key
    // MacOS: swap Cmd(Super) and Ctrl
    if (g.IO.ConfigMacOSXBehaviors)
    {
        if (key == .Mod_Super)          { key = .Mod_Ctrl; }
        else if (key == .Mod_Ctrl)      { key = .Mod_Super; }
        else if (key == .LeftSuper) { key = .LeftCtrl; }
        else if (key == .RightSuper){ key = .RightCtrl; }
        else if (key == .LeftCtrl)  { key = .LeftSuper; }
        else if (key == .RightCtrl) { key = .RightSuper; }
    }

    // Filter duplicate (in particular: key mods and gamepad analog values are commonly spammed)
    latest_event := FindLatestInputEvent(g, .Key, cast(i32) key);
    key_data := GetKeyData(g, key);
    latest_key_down := latest_event != nil ? latest_event.Key.Down : key_data.Down;
    latest_key_analog := latest_event != nil ? latest_event.Key.AnalogValue : key_data.AnalogValue;
    if (latest_key_down == down && latest_key_analog == analog_value)   do return

    // Add event
    e : ImGuiInputEvent
    e.Type = .Key;
    e.Source = IsGamepadKey(key) ? .Gamepad : .Keyboard;
    g.InputEventsNextEventId += 1;
    e.EventId = g.InputEventsNextEventId
    e.Key.Key = key;
    e.Key.Down = down;
    e.Key.AnalogValue = analog_value;
    append(&g.InputEventsQueue, e);
}

// [forward declared comment]:
// Queue a new key down/up event. Key should be "translated" (as in, generally ImGuiKey.A matches the key end-user would use to emit an 'A' character)
AddKeyEvent :: proc(this : ^ImGuiIO, key : ImGuiKey, down : bool)
{
    if (!this.AppAcceptingEvents)   do return
    AddKeyAnalogEvent(this, key, down, down ? 1.0 : 0.0);
}

// [Optional] Call after AddKeyEvent().
// Specify native keycode, scancode + Specify index for legacy <1.87 IsKeyXXX() functions with native indices.
// If you are writing a backend in 2022 or don't use IsKeyXXX() with native values that are not ImGuiKey values, you can avoid calling this.
// [forward declared comment]:
// [Optional] Specify index for legacy <1.87 IsKeyXXX() functions with native indices + specify native keycode, scancode.
SetKeyEventNativeData :: proc(this : ^ImGuiIO, key : ImGuiKey, native_keycode : i32, native_scancode : i32, native_legacy_index : i32 = -1)
{
    if (key == nil)   do return
    assert(IsNamedKey(key)); // >= 512
    assert(native_legacy_index == -1 || IsLegacyKey(ImGuiKey(native_legacy_index))); // >= 0 && <= 511
    _ = key;                 // Yet unused
    _ = native_keycode;      // Yet unused
    _ = native_scancode;     // Yet unused
    _ = native_legacy_index; // Yet unused
}

// Set master flag for accepting key/mouse/text events (default to true). Useful if you have native dialog boxes that are interrupting your application loop/refresh, and you want to disable events being queued while your app is frozen.
// [forward declared comment]:
// Set master flag for accepting key/mouse/text events (default to true). Useful if you have native dialog boxes that are interrupting your application loop/refresh, and you want to disable events being queued while your app is frozen.
SetAppAcceptingEvents :: proc(this : ^ImGuiIO, accepting_events : bool)
{
    this.AppAcceptingEvents = accepting_events;
}

// Queue a mouse move event
// [forward declared comment]:
// Queue a mouse position update. Use -FLT_MAX,-FLT_MAX to signify no mouse (e.g. app not focused and not hovered)
AddMousePosEvent :: proc(this : ^ImGuiIO, x : f32, y : f32)
{
    assert(this.Ctx != nil);
    g := this.Ctx;
    if (!this.AppAcceptingEvents)   do return

    // Apply same flooring as UpdateMouseInputs()
    pos := ImVec2{(x > -math.F32_MAX) ? ImFloor(x) : x, (y > -math.F32_MAX) ? ImFloor(y) : y};

    // Filter duplicate
    latest_event := FindLatestInputEvent(g, .MousePos);
    latest_pos := latest_event != nil ? ImVec2{latest_event.MousePos.PosX, latest_event.MousePos.PosY} : g.IO.MousePos;
    if (latest_pos.x == pos.x && latest_pos.y == pos.y)   do return

    e : ImGuiInputEvent
    e.Type = .MousePos;
    e.Source = .Mouse;
    g.InputEventsNextEventId += 1;
    e.EventId = g.InputEventsNextEventId
    e.MousePos.PosX = pos.x;
    e.MousePos.PosY = pos.y;
    e.MousePos.MouseSource = g.InputEventsNextMouseSource;
    append(&g.InputEventsQueue, e)
}

// [forward declared comment]:
// Queue a mouse button change
AddMouseButtonEvent :: proc(this : ^ImGuiIO, mouse_button : ImGuiMouseButton, down : bool)
{
    assert(this.Ctx != nil);
    assert(mouse_button >= ImGuiMouseButton(0) && mouse_button < ImGuiMouseButton.COUNT);
    mouse_button := mouse_button
    g := this.Ctx;
    if (!this.AppAcceptingEvents)   do return

    // On MacOS X: Convert Ctrl(Super)+Left click into Right-click: handle held button.
    if (this.ConfigMacOSXBehaviors && mouse_button == .Left && this.MouseCtrlLeftAsRightClick)
    {
        // Order of both statements matterns: this event will still release mouse button 1
        mouse_button = .Right;
        if (!down) do this.MouseCtrlLeftAsRightClick = false;
    }

    // Filter duplicate
    latest_event := FindLatestInputEvent(g, .MouseButton, cast(i32) mouse_button);
    latest_button_down := latest_event != nil ? latest_event.MouseButton.Down : g.IO.MouseDown[mouse_button];
    if (latest_button_down == down)   do return

    // On MacOS X: Convert Ctrl(Super)+Left click into Right-click.
    // - Note that this is actual physical Ctrl which is ImGuiKey.Mod_Super for us.
    // - At this point we want from !down to down, so this is handling the initial press.
    if (this.ConfigMacOSXBehaviors && mouse_button == .Left && down)
    {
        latest_super_event := FindLatestInputEvent(g, .Key, cast(i32) ImGuiKey.Mod_Super);
        if (latest_super_event != nil ? latest_super_event.Key.Down : g.IO.KeySuper)
        {
            IMGUI_DEBUG_LOG_IO(g, "[io] Super+Left Click aliased into Right Click\n");
            this.MouseCtrlLeftAsRightClick = true;
            AddMouseButtonEvent(this, .Right, true); // This is just quicker to write that passing through, as we need to filter duplicate again.
            return;
        }
    }

    e : ImGuiInputEvent
    e.Type = .MouseButton;
    e.Source = .Mouse;
    g.InputEventsNextEventId += 1;
    e.EventId = g.InputEventsNextEventId
    e.MouseButton.Button = mouse_button;
    e.MouseButton.Down = down;
    e.MouseButton.MouseSource = g.InputEventsNextMouseSource;
    append(&g.InputEventsQueue, e);
}

// Queue a mouse wheel event (some mouse/API may only have a Y component)
// [forward declared comment]:
// Queue a mouse wheel update. wheel_y<0: scroll down, wheel_y>0: scroll up, wheel_x<0: scroll right, wheel_x>0: scroll left.
AddMouseWheelEvent :: proc(this : ^ImGuiIO, wheel_x : f32, wheel_y : f32)
{
    assert(this.Ctx != nil);
    g := this.Ctx;

    // Filter duplicate (unlike most events, wheel values are relative and easy to filter)
    if (!this.AppAcceptingEvents || (wheel_x == 0.0 && wheel_y == 0.0))   do return

    e : ImGuiInputEvent
    e.Type = .MouseWheel;
    e.Source = .Mouse;
    g.InputEventsNextEventId += 1;
    e.EventId = g.InputEventsNextEventId
    e.MouseWheel.WheelX = wheel_x;
    e.MouseWheel.WheelY = wheel_y;
    e.MouseWheel.MouseSource = g.InputEventsNextMouseSource;
    append(&g.InputEventsQueue, e);
}

// This is not a real event, the data is latched in order to be stored in actual Mouse events.
// This is so that duplicate events (e.g. Windows sending extraneous WM_MOUSEMOVE) gets filtered and are not leading to actual source changes.
// [forward declared comment]:
// Queue a mouse source change (Mouse/TouchScreen/Pen)
AddMouseSourceEvent :: proc(this : ^ImGuiIO, source : ImGuiMouseSource)
{
    assert(this.Ctx != nil);
    g := this.Ctx;
    g.InputEventsNextMouseSource = source;
}

// [forward declared comment]:
// Queue a mouse hovered viewport. Requires backend to set ImGuiBackendFlags_HasMouseHoveredViewport to call this (for multi-viewport support).
AddMouseViewportEvent :: proc(this : ^ImGuiIO, viewport_id : ImGuiID)
{
    assert(this.Ctx != nil);
    g := this.Ctx;
    //assert(.HasMouseHoveredViewport in g.IO.BackendFlags);
    if (!this.AppAcceptingEvents)   do return

    // Filter duplicate
    latest_event := FindLatestInputEvent(g, .MouseViewport);
    latest_viewport_id := latest_event != nil ? latest_event.MouseViewport.HoveredViewportID : g.IO.MouseHoveredViewport;
    if (latest_viewport_id == viewport_id)   do return

    e : ImGuiInputEvent
    e.Type = .MouseViewport;
    e.Source = .Mouse;
    e.MouseViewport.HoveredViewportID = viewport_id;
    append(&g.InputEventsQueue, e);
}

// [forward declared comment]:
// Queue a gain/loss of focus for the application (generally based on OS/platform focus of your window)
AddFocusEvent :: proc(this : ^ImGuiIO, focused : bool)
{
    assert(this.Ctx != nil);
    g := this.Ctx;

    // Filter duplicate
    latest_event := FindLatestInputEvent(g, .Focus);
    latest_focused := latest_event != nil ? latest_event.AppFocused.Focused : !g.IO.AppFocusLost;
    if (latest_focused == focused || (this.ConfigDebugIgnoreFocusLoss && !focused))   do return

    e : ImGuiInputEvent
    e.Type = .Focus;
    g.InputEventsNextEventId += 1;
    e.EventId = g.InputEventsNextEventId
    e.AppFocused.Focused = focused;
    append(&g.InputEventsQueue, e);
}

init_ImGuiPlatformIO :: proc(this : ^ImGuiPlatformIO)
{
    // Most fields are initialized with zero
    this^ = {};
    this.Platform_LocaleDecimalPoint = '.';
}

//-----------------------------------------------------------------------------
// [SECTION] MISC HELPERS/UTILITIES (Geometry functions)
//-----------------------------------------------------------------------------

// [forward declared comment]:
// For curves with explicit number of segments
ImBezierCubicClosestPoint :: proc(p1 : ImVec2, p2 : ImVec2, p3 : ImVec2, p4 : ImVec2, p : ImVec2, num_segments : i32) -> ImVec2
{
    assert(num_segments > 0); // Use ImBezierCubicClosestPointCasteljau()
    p_last := p1;
    p_closest : ImVec2
    p_closest_dist2 : f32 = math.F32_MAX;
    t_step := 1.0 / f32(num_segments);
    for i_step : i32 = 1; i_step <= num_segments; i_step += 1
    {
        p_current := ImBezierCubicCalc(p1, p2, p3, p4, t_step * f32(i_step));
        p_line := ImLineClosestPoint(p_last, p_current, p);
        dist2 := ImLengthSqr(p - p_line);
        if (dist2 < p_closest_dist2)
        {
            p_closest = p_line;
            p_closest_dist2 = dist2;
        }
        p_last = p_current;
    }
    return p_closest;
}

// Closely mimics PathBezierToCasteljau() in imgui_draw.cpp
ImBezierCubicClosestPointCasteljauStep :: proc(p : ImVec2, p_closest : ^ImVec2, p_last : ^ImVec2, p_closest_dist2 : ^f32, x1 : f32, y1 : f32, x2 : f32, y2 : f32, x3 : f32, y3 : f32, x4 : f32, y4 : f32, tess_tol : f32, level : i32)
{
    dx := x4 - x1;
    dy := y4 - y1;
    d2 := ((x2 - x4) * dy - (y2 - y4) * dx);
    d3 := ((x3 - x4) * dy - (y3 - y4) * dx);
    d2 = (d2 >= 0) ? d2 : -d2;
    d3 = (d3 >= 0) ? d3 : -d3;
    if ((d2 + d3) * (d2 + d3) < tess_tol * (dx * dx + dy * dy))
    {
        p_current := ImVec2{x4, y4};
        p_line := ImLineClosestPoint(p_last^, p_current, p);
        dist2 := ImLengthSqr(p - p_line);
        if (dist2 < p_closest_dist2^)
        {
            p_closest^ = p_line;
            p_closest_dist2^ = dist2;
        }
        p_last^ = p_current;
    }
    else if (level < 10)
    {
        x12 := (x1 + x2)*0.5;       y12 := (y1 + y2)*0.5;
        x23 := (x2 + x3)*0.5;       y23 := (y2 + y3)*0.5;
        x34 := (x3 + x4)*0.5;       y34 := (y3 + y4)*0.5;
        x123 := (x12 + x23)*0.5;    y123 := (y12 + y23)*0.5;
        x234 := (x23 + x34)*0.5;    y234 := (y23 + y34)*0.5;
        x1234 := (x123 + x234)*0.5; y1234 := (y123 + y234)*0.5;
        ImBezierCubicClosestPointCasteljauStep(p, p_closest, p_last, p_closest_dist2, x1, y1, x12, y12, x123, y123, x1234, y1234, tess_tol, level + 1);
        ImBezierCubicClosestPointCasteljauStep(p, p_closest, p_last, p_closest_dist2, x1234, y1234, x234, y234, x34, y34, x4, y4, tess_tol, level + 1);
    }
}

// tess_tol is generally the same value you would find in ImGui::GetStyle().CurveTessellationTol
// Because those ImXXX functions are lower-level than ImGui:: we cannot access this value automatically.
// [forward declared comment]:
// For auto-tessellated curves you can use tess_tol = style.CurveTessellationTol
ImBezierCubicClosestPointCasteljau :: proc(p1 : ImVec2, p2 : ImVec2, p3 : ImVec2, p4 : ImVec2, p : ImVec2, tess_tol : f32) -> ImVec2
{
    assert(tess_tol > 0.0);
    p_last := p1;
    p_closest : ImVec2
    p_closest_dist2 : f32 = math.F32_MAX;
    ImBezierCubicClosestPointCasteljauStep(p, &p_closest, &p_last, &p_closest_dist2, p1.x, p1.y, p2.x, p2.y, p3.x, p3.y, p4.x, p4.y, tess_tol, 0);
    return p_closest;
}

ImLineClosestPoint :: proc(a : ImVec2, b : ImVec2, p : ImVec2) -> ImVec2
{
    ap := p - a;
    ab_dir := b - a;
    dot := ap.x * ab_dir.x + ap.y * ab_dir.y;
    if (dot < 0.0)   do return a
    ab_len_sqr := ab_dir.x * ab_dir.x + ab_dir.y * ab_dir.y;
    if (dot > ab_len_sqr)   do return b
    return a + ab_dir * dot / ab_len_sqr;
}

ImTriangleContainsPoint :: proc(a : ImVec2, b : ImVec2, c : ImVec2, p : ImVec2) -> bool
{
    b1 := ((p.x - b.x) * (a.y - b.y) - (p.y - b.y) * (a.x - b.x)) < 0.0;
    b2 := ((p.x - c.x) * (b.y - c.y) - (p.y - c.y) * (b.x - c.x)) < 0.0;
    b3 := ((p.x - a.x) * (c.y - a.y) - (p.y - a.y) * (c.x - a.x)) < 0.0;
    return ((b1 == b2) && (b2 == b3));
}

ImTriangleBarycentricCoords :: proc(a : ImVec2, b : ImVec2, c : ImVec2, p : ImVec2, out_u : ^f32, out_v : ^f32, out_w : ^f32)
{
    v0 := b - a;
    v1 := c - a;
    v2 := p - a;
    denom := v0.x * v1.y - v1.x * v0.y;
    out_v^ = (v2.x * v1.y - v1.x * v2.y) / denom;
    out_w^ = (v0.x * v2.y - v2.x * v0.y) / denom;
    out_u^ = 1.0 - out_v^ - out_w^;
}

ImTriangleClosestPoint :: proc(a : ImVec2, b : ImVec2, c : ImVec2, p : ImVec2) -> ImVec2
{
    proj_ab := ImLineClosestPoint(a, b, p);
    proj_bc := ImLineClosestPoint(b, c, p);
    proj_ca := ImLineClosestPoint(c, a, p);
    dist2_ab := ImLengthSqr(p - proj_ab);
    dist2_bc := ImLengthSqr(p - proj_bc);
    dist2_ca := ImLengthSqr(p - proj_ca);
    m := ImMin(dist2_ab, ImMin(dist2_bc, dist2_ca));
    if (m == dist2_ab)   do return proj_ab
    if (m == dist2_bc)   do return proj_bc
    return proj_ca;
}

//-----------------------------------------------------------------------------
// [SECTION] MISC HELPERS/UTILITIES (String, Format, Hash functions)
//-----------------------------------------------------------------------------

// Consider using _stricmp/_strnicmp under Windows or strcasecmp/strncasecmp. We don't actually use either ImStricmp/ImStrnicmp in the codebase any more.
// [forward declared comment]:
// Case insensitive compare.
ImStricmp :: proc(str1 : [^]u8, str2 : [^]u8) -> i32
{
    str1 := str1;
    str2 := str2;

    d := ImToUpper(str2[0]) - ImToUpper(str1[0])
    for (d == 0 && str1[0] != 0) {
        str1 = mem.ptr_offset(str1, 1);
        str2 = mem.ptr_offset(str2, 1);
        d = ImToUpper(str2[0]) - ImToUpper(str1[0])
    }
    return i32(d);
}

// [forward declared comment]:
// Case insensitive compare to a certain count.
ImStrnicmp :: proc(str1 : [^]u8, str2 : [^]u8, count : int) -> i32
{
    str1 := str1;
    str2 := str2;
    count := count

    d := count > 0 ? ImToUpper(str2[0]) - ImToUpper(str1[0]) : 0
    for (count > 0 && d == 0 && str1[0] != 0) {
        str1 = mem.ptr_offset(str1, 1);
        str2 = mem.ptr_offset(str2, 1);
        count -= 1;
        d = count > 0 ? ImToUpper(str2[0]) - ImToUpper(str1[0]) : 0
    }
    return i32(d);
}

// [forward declared comment]:
// Copy to a certain count and always zero terminate (strncpy doesn't).
ImStrncpy :: proc(dst : [^]u8, src : [^]u8, count : int)
{
    if (count < 1)   do return
    if (count > 1)   do mem.copy_non_overlapping(dst, src, count - 1);
    dst[count - 1] = 0;
}

// [forward declared comment]:
// Duplicate a string.
ImStrdup :: proc(str : [^]u8) -> [^]u8
{
    len := cast(int) strlen(str);
    buf := IM_ALLOC(len + 1);
    return cast(^u8)memcpy(buf, cast(rawptr)str, len + 1);
}

ImStrdup_str :: proc(str : string) -> string
{
    buf := IM_ALLOC(len(str));
    cpy := strings.string_from_ptr(buf, len(str))
    copy(transmute([]u8) cpy, transmute([]u8) str)
    return cpy
}

// [forward declared comment]:
// Copy in provided buffer, recreate buffer if needed.
ImStrdupcpy :: proc(dst : [^]u8, p_dst_size : ^int, src : [^]u8) -> [^]u8
{
    dst := dst
    dst_buf_size := p_dst_size != nil ? p_dst_size^ : strlen(dst) + 1;
    src_size := strlen(src) + 1;
    if (dst_buf_size < src_size)
    {
        IM_FREE(dst);
        dst = IM_ALLOC(src_size);
        if (p_dst_size != nil)   do p_dst_size^ = src_size
    }
    return cast(^u8)memcpy(dst, cast(rawptr)src, src_size);
}

// [forward declared comment]:
// Find first occurrence of 'c' in string range.
ImStrchrRange :: proc(str : ^u8, str_end : ^u8, c : u8) -> ^u8
{
    p := memchr_end(str, c, str_end);
    return p;
}

strlen :: proc(str : [^]u8) -> int
{
    curr := str
    for curr[0] != 0 {
        curr = curr[1:]
    }
    return mem.ptr_sub(curr, str);
}

// [forward declared comment]:
// Computer string length (ImWchar string)
ImStrlenW :: proc(str : [^]ImWchar) -> int
{
    //return cast(int) wcslen((const wchar_t*)str);  // FIXME-OPT: Could use this when wchar_t are 16-bit
    curr := str
    for curr[0] != 0 {
        curr = curr[1:]
    }
    return mem.ptr_sub(curr, str);
}

// Find end-of-line. Return pointer will point to either first \n, either str_end.
// [forward declared comment]:
// End end-of-line
ImStreolRange :: proc(str : [^]u8, str_end : ^u8) -> ^u8
{
    p := memchr_end(str, '\n', str_end);
    return p != nil ? p : str_end;
}

// [forward declared comment]:
// Find beginning-of-line
ImStrbol :: proc(buf_mid_line : [^]u8, buf_begin : [^]u8) -> [^]u8 // find beginning-of-line
{
    buf_mid_line := buf_mid_line
    for (buf_mid_line > buf_begin && buf_mid_line[-1] != '\n') {
        buf_mid_line = buf_mid_line[-1:]
    }
    return buf_mid_line;
}

// [forward declared comment]:
// Find a substring in a string range.
ImStristr :: proc(haystack_ : string, needle_ : string) -> [^]u8
{
    haystack := raw_data(haystack_)
    haystack_end := end(haystack_)
    needle := raw_data(needle_)
    needle_end := end(needle_)

    un0 := cast(u8) ImToUpper(needle[0]);
    for ((haystack_end == nil && haystack[0] != 0) || (haystack_end != nil && cast(^u8) haystack < haystack_end))
    {
        if (ImToUpper(haystack[0]) == un0)
        {
            b := needle[1:]
            for a := haystack[1:]; b < needle_end; a, b = a[1:], b[1:]  {
                if (ImToUpper(a[0]) != ImToUpper(b[0]))   do break
            }
            if (b == needle_end)   do return haystack
        }
        haystack = haystack[1:];
    }
    return nil;
}

// Trim str by offsetting contents when there's leading data. We use this in situation where the cost is negligible.
// [forward declared comment]:
// Remove leading and trailing blanks from a buffer.
ImStrTrimBlanks :: proc(buf : ^string)
{
    buf^ = strings.trim_space(buf^)
}

// [forward declared comment]:
// Find first non-blank character.
ImStrSkipBlank :: proc(str : [^]u8) -> [^]u8
{
    str := str
    for (str[0] == ' ' || str[0] == '\t') {
        str = str[1:];
    }
    return str;
}

memmove :: mem.copy
memcmp :: mem.compare_ptrs
memcpy :: mem.copy_non_overlapping
memset :: proc(ptr : rawptr, v : u8, #any_int size : int)
{
    s := slice.bytes_from_ptr(ptr, size)
    slice.fill(s, v) // TODO(Rennorb) @perf
}

memchr :: #force_inline proc (str : [^]u8, c : u8, len : i32) -> ^u8
{
    index := bytes.index_byte(str[:len], c)
    return index == -1 ? nil : mem.ptr_offset(str, index)
}
memchr_end :: #force_inline proc (str : [^]u8, c : u8, end : ^u8) -> ^u8
{
    index := bytes.index_byte(str[:mem.ptr_sub(end, cast(^u8)str)], c)
    return index == -1 ? nil : mem.ptr_offset(str, index)
}

strchr :: #force_inline proc(str : [^]u8, c : u8) -> ^u8
{
    return memchr(str, c, cast(i32) strlen(str))
}

strncmp :: #force_inline proc(str1, str2 : [^]u8, #any_int len : int) -> int
{
    return mem.compare_byte_ptrs(cast(^byte) str1, cast(^byte) str2, len)
}

//R temporary
string_from_start_end :: #force_inline proc(start : [^]u8, end : ^u8) -> string
{
    return strings.string_from_ptr(cast(^byte) start, mem.ptr_sub(end, cast(^u8) start))
}

ImFormatString :: proc(buf : [^]u8, buf_size : int, format : string, args : .. any) -> i32
{
    slice_stram_proc :: proc(stream_data: rawptr, mode: io.Stream_Mode, p: []byte, offset: i64, whence: io.Seek_From) -> (n: i64, err: io.Error) {
        d := (^[]u8)(stream_data)
        #partial switch mode {
        case .Write:
            n = i64(copy(d^, p))
            if n < i64(len(p)) {
                err = .EOF
            }
            d^ = d[n:]
            return
        case .Size:
            n = i64(len(d))
            return
        case .Query:
            return io.query_utility({.Write, .Size, .Query})
        }
        return 0, .Empty
    }

    slice := buf[:buf_size]

    stream := io.Stream{ procedure = slice_stram_proc, data = &slice }
    return  cast(i32) fmt.wprintf(io.to_writer(stream), format, args)
}

// FIXME: Should rework API toward allowing multiple in-flight temp buffers (easier and safer for caller)
// by making the caller acquire a temp buffer token, with either explicit or destructor release, e.g.
//  ImGuiTempBufferToken token;
//  ImFormatStringToTempBuffer(token, ...);
ImFormatStringToTempBuffer :: #force_inline proc(format : string, args : .. any) -> string
{

    g := GImGui;
    if (format == "%s")
    {
        buf := (cast(^string) args[0].data)^; // Skip formatting when using "%s"
        if (buf == {}) {
            buf = "(null)"
        }
        return buf
    }
    else if (format == "%.*s")
    {
        buf_len := (cast(^i32) args[0].data)^; // Skip formatting when using "%.*s"
        buf := (cast(^string) args[1].data)^;
        if (buf == {})
        {
            return "(null)";
        }
        return buf[:buf_len]
    }
    else
    {
        return fmt.bprintf(g.TempBuffer[:], format, args)
    }
}

when !IMGUI_ENABLE_SSE4_2_CRC {
// CRC32 needs a 1KB lookup table (not cache friendly)
// Although the code to generate the table is simple and shorter than the table itself, using a const table allows us to easily:
// - avoid an unnecessary branch/memory tap, - keep the ImHashXXX functions usable by static constructors, - make it thread-safe.
when IMGUI_USE_LEGACY_CRC32_ADLER {
    GCrc32LookupTable := [256]u32 {
    // Legacy CRC32-adler table used pre 1.91.6 (before 2024/11/27). Only use if you cannot afford invalidating old .ini data.
    0x00000000,0x77073096,0xEE0E612C,0x990951BA,0x076DC419,0x706AF48F,0xE963A535,0x9E6495A3,0x0EDB8832,0x79DCB8A4,0xE0D5E91E,0x97D2D988,0x09B64C2B,0x7EB17CBD,0xE7B82D07,0x90BF1D91,
    0x1DB71064,0x6AB020F2,0xF3B97148,0x84BE41DE,0x1ADAD47D,0x6DDDE4EB,0xF4D4B551,0x83D385C7,0x136C9856,0x646BA8C0,0xFD62F97A,0x8A65C9EC,0x14015C4F,0x63066CD9,0xFA0F3D63,0x8D080DF5,
    0x3B6E20C8,0x4C69105E,0xD56041E4,0xA2677172,0x3C03E4D1,0x4B04D447,0xD20D85FD,0xA50AB56B,0x35B5A8FA,0x42B2986C,0xDBBBC9D6,0xACBCF940,0x32D86CE3,0x45DF5C75,0xDCD60DCF,0xABD13D59,
    0x26D930AC,0x51DE003A,0xC8D75180,0xBFD06116,0x21B4F4B5,0x56B3C423,0xCFBA9599,0xB8BDA50F,0x2802B89E,0x5F058808,0xC60CD9B2,0xB10BE924,0x2F6F7C87,0x58684C11,0xC1611DAB,0xB6662D3D,
    0x76DC4190,0x01DB7106,0x98D220BC,0xEFD5102A,0x71B18589,0x06B6B51F,0x9FBFE4A5,0xE8B8D433,0x7807C9A2,0x0F00F934,0x9609A88E,0xE10E9818,0x7F6A0DBB,0x086D3D2D,0x91646C97,0xE6635C01,
    0x6B6B51F4,0x1C6C6162,0x856530D8,0xF262004E,0x6C0695ED,0x1B01A57B,0x8208F4C1,0xF50FC457,0x65B0D9C6,0x12B7E950,0x8BBEB8EA,0xFCB9887C,0x62DD1DDF,0x15DA2D49,0x8CD37CF3,0xFBD44C65,
    0x4DB26158,0x3AB551CE,0xA3BC0074,0xD4BB30E2,0x4ADFA541,0x3DD895D7,0xA4D1C46D,0xD3D6F4FB,0x4369E96A,0x346ED9FC,0xAD678846,0xDA60B8D0,0x44042D73,0x33031DE5,0xAA0A4C5F,0xDD0D7CC9,
    0x5005713C,0x270241AA,0xBE0B1010,0xC90C2086,0x5768B525,0x206F85B3,0xB966D409,0xCE61E49F,0x5EDEF90E,0x29D9C998,0xB0D09822,0xC7D7A8B4,0x59B33D17,0x2EB40D81,0xB7BD5C3B,0xC0BA6CAD,
    0xEDB88320,0x9ABFB3B6,0x03B6E20C,0x74B1D29A,0xEAD54739,0x9DD277AF,0x04DB2615,0x73DC1683,0xE3630B12,0x94643B84,0x0D6D6A3E,0x7A6A5AA8,0xE40ECF0B,0x9309FF9D,0x0A00AE27,0x7D079EB1,
    0xF00F9344,0x8708A3D2,0x1E01F268,0x6906C2FE,0xF762575D,0x806567CB,0x196C3671,0x6E6B06E7,0xFED41B76,0x89D32BE0,0x10DA7A5A,0x67DD4ACC,0xF9B9DF6F,0x8EBEEFF9,0x17B7BE43,0x60B08ED5,
    0xD6D6A3E8,0xA1D1937E,0x38D8C2C4,0x4FDFF252,0xD1BB67F1,0xA6BC5767,0x3FB506DD,0x48B2364B,0xD80D2BDA,0xAF0A1B4C,0x36034AF6,0x41047A60,0xDF60EFC3,0xA867DF55,0x316E8EEF,0x4669BE79,
    0xCB61B38C,0xBC66831A,0x256FD2A0,0x5268E236,0xCC0C7795,0xBB0B4703,0x220216B9,0x5505262F,0xC5BA3BBE,0xB2BD0B28,0x2BB45A92,0x5CB36A04,0xC2D7FFA7,0xB5D0CF31,0x2CD99E8B,0x5BDEAE1D,
    0x9B64C2B0,0xEC63F226,0x756AA39C,0x026D930A,0x9C0906A9,0xEB0E363F,0x72076785,0x05005713,0x95BF4A82,0xE2B87A14,0x7BB12BAE,0x0CB61B38,0x92D28E9B,0xE5D5BE0D,0x7CDCEFB7,0x0BDBDF21,
    0x86D3D2D4,0xF1D4E242,0x68DDB3F8,0x1FDA836E,0x81BE16CD,0xF6B9265B,0x6FB077E1,0x18B74777,0x88085AE6,0xFF0F6A70,0x66063BCA,0x11010B5C,0x8F659EFF,0xF862AE69,0x616BFFD3,0x166CCF45,
    0xA00AE278,0xD70DD2EE,0x4E048354,0x3903B3C2,0xA7672661,0xD06016F7,0x4969474D,0x3E6E77DB,0xAED16A4A,0xD9D65ADC,0x40DF0B66,0x37D83BF0,0xA9BCAE53,0xDEBB9EC5,0x47B2CF7F,0x30B5FFE9,
    0xBDBDF21C,0xCABAC28A,0x53B39330,0x24B4A3A6,0xBAD03605,0xCDD70693,0x54DE5729,0x23D967BF,0xB3667A2E,0xC4614AB8,0x5D681B02,0x2A6F2B94,0xB40BBE37,0xC30C8EA1,0x5A05DF1B,0x2D02EF8D,
    }
} else {
    GCrc32LookupTable := [256]u32 {
    // CRC32c table compatible with SSE 4.2 instructions
    0x00000000,0xF26B8303,0xE13B70F7,0x1350F3F4,0xC79A971F,0x35F1141C,0x26A1E7E8,0xD4CA64EB,0x8AD958CF,0x78B2DBCC,0x6BE22838,0x9989AB3B,0x4D43CFD0,0xBF284CD3,0xAC78BF27,0x5E133C24,
    0x105EC76F,0xE235446C,0xF165B798,0x030E349B,0xD7C45070,0x25AFD373,0x36FF2087,0xC494A384,0x9A879FA0,0x68EC1CA3,0x7BBCEF57,0x89D76C54,0x5D1D08BF,0xAF768BBC,0xBC267848,0x4E4DFB4B,
    0x20BD8EDE,0xD2D60DDD,0xC186FE29,0x33ED7D2A,0xE72719C1,0x154C9AC2,0x061C6936,0xF477EA35,0xAA64D611,0x580F5512,0x4B5FA6E6,0xB93425E5,0x6DFE410E,0x9F95C20D,0x8CC531F9,0x7EAEB2FA,
    0x30E349B1,0xC288CAB2,0xD1D83946,0x23B3BA45,0xF779DEAE,0x05125DAD,0x1642AE59,0xE4292D5A,0xBA3A117E,0x4851927D,0x5B016189,0xA96AE28A,0x7DA08661,0x8FCB0562,0x9C9BF696,0x6EF07595,
    0x417B1DBC,0xB3109EBF,0xA0406D4B,0x522BEE48,0x86E18AA3,0x748A09A0,0x67DAFA54,0x95B17957,0xCBA24573,0x39C9C670,0x2A993584,0xD8F2B687,0x0C38D26C,0xFE53516F,0xED03A29B,0x1F682198,
    0x5125DAD3,0xA34E59D0,0xB01EAA24,0x42752927,0x96BF4DCC,0x64D4CECF,0x77843D3B,0x85EFBE38,0xDBFC821C,0x2997011F,0x3AC7F2EB,0xC8AC71E8,0x1C661503,0xEE0D9600,0xFD5D65F4,0x0F36E6F7,
    0x61C69362,0x93AD1061,0x80FDE395,0x72966096,0xA65C047D,0x5437877E,0x4767748A,0xB50CF789,0xEB1FCBAD,0x197448AE,0x0A24BB5A,0xF84F3859,0x2C855CB2,0xDEEEDFB1,0xCDBE2C45,0x3FD5AF46,
    0x7198540D,0x83F3D70E,0x90A324FA,0x62C8A7F9,0xB602C312,0x44694011,0x5739B3E5,0xA55230E6,0xFB410CC2,0x092A8FC1,0x1A7A7C35,0xE811FF36,0x3CDB9BDD,0xCEB018DE,0xDDE0EB2A,0x2F8B6829,
    0x82F63B78,0x709DB87B,0x63CD4B8F,0x91A6C88C,0x456CAC67,0xB7072F64,0xA457DC90,0x563C5F93,0x082F63B7,0xFA44E0B4,0xE9141340,0x1B7F9043,0xCFB5F4A8,0x3DDE77AB,0x2E8E845F,0xDCE5075C,
    0x92A8FC17,0x60C37F14,0x73938CE0,0x81F80FE3,0x55326B08,0xA759E80B,0xB4091BFF,0x466298FC,0x1871A4D8,0xEA1A27DB,0xF94AD42F,0x0B21572C,0xDFEB33C7,0x2D80B0C4,0x3ED04330,0xCCBBC033,
    0xA24BB5A6,0x502036A5,0x4370C551,0xB11B4652,0x65D122B9,0x97BAA1BA,0x84EA524E,0x7681D14D,0x2892ED69,0xDAF96E6A,0xC9A99D9E,0x3BC21E9D,0xEF087A76,0x1D63F975,0x0E330A81,0xFC588982,
    0xB21572C9,0x407EF1CA,0x532E023E,0xA145813D,0x758FE5D6,0x87E466D5,0x94B49521,0x66DF1622,0x38CC2A06,0xCAA7A905,0xD9F75AF1,0x2B9CD9F2,0xFF56BD19,0x0D3D3E1A,0x1E6DCDEE,0xEC064EED,
    0xC38D26C4,0x31E6A5C7,0x22B65633,0xD0DDD530,0x0417B1DB,0xF67C32D8,0xE52CC12C,0x1747422F,0x49547E0B,0xBB3FFD08,0xA86F0EFC,0x5A048DFF,0x8ECEE914,0x7CA56A17,0x6FF599E3,0x9D9E1AE0,
    0xD3D3E1AB,0x21B862A8,0x32E8915C,0xC083125F,0x144976B4,0xE622F5B7,0xF5720643,0x07198540,0x590AB964,0xAB613A67,0xB831C993,0x4A5A4A90,0x9E902E7B,0x6CFBAD78,0x7FAB5E8C,0x8DC0DD8F,
    0xE330A81A,0x115B2B19,0x020BD8ED,0xF0605BEE,0x24AA3F05,0xD6C1BC06,0xC5914FF2,0x37FACCF1,0x69E9F0D5,0x9B8273D6,0x88D28022,0x7AB90321,0xAE7367CA,0x5C18E4C9,0x4F48173D,0xBD23943E,
    0xF36E6F75,0x0105EC76,0x12551F82,0xE03E9C81,0x34F4F86A,0xC69F7B69,0xD5CF889D,0x27A40B9E,0x79B737BA,0x8BDCB4B9,0x988C474D,0x6AE7C44E,0xBE2DA0A5,0x4C4623A6,0x5F16D052,0xAD7D5351
    }
}
}


//TODO(Rennorb): hash.crc32 ? 

// Known size hash
// It is ok to call ImHashData on a string with known length but the ### operator won't be supported.
// FIXME-OPT: Replace with e.g. FNV1a hash? CRC32 pretty much randomly access 1KB. Need to do proper measurements.
ImHashData :: proc(data_p : rawptr, data_size : int, seed : ImGuiID = {}) -> ImGuiID
{
    crc := ~seed;
    data := cast([^]u8) data_p;
    data_end := cast(^u8) data[data_size:]
when !(IMGUI_ENABLE_SSE4_2_CRC) {
    crc32_lut := GCrc32LookupTable;
    for (data < data_end) {
        crc = (crc >> 8) ~ crc32_lut[u8(crc & 0xFF) ~ data[0]];
        data = data[1:]
    }
} else {
    for (mem.ptr_offset(data, 4) <= data_end)
    {
        crc = _mm_crc32_u32(crc, (cast(^u32)data)^);
        data = data[4:];
    }
    for (data < data_end) {
        crc = _mm_crc32_u8(crc, data[0]);
        data = data[1:]
    }
}
    return ~crc;
}

//  string hash, with support for ### to reset back to seed value
// We support a syntax of "label###id" where only "###id" is included in the hash, and only "label" gets displayed.
// Because this syntax is rarely used we are optimizing for the common case.
// - If we reach ### in the string we discard the hash so far and reset to the seed.
// - We don't do 'current += 2; continue;' after handling ### to keep the code smaller/faster (measured ~10% diff in Debug build)
// FIXME-OPT: Replace with e.g. FNV1a hash? CRC32 pretty much randomly access 1KB. Need to do proper measurements.
ImHashStr :: proc(str : string, seed : ImGuiID = {}) -> ImGuiID
{
    data := raw_data(str);
    data_size := len(str)

    seed := ~seed;
    crc := seed;
when !(IMGUI_ENABLE_SSE4_2_CRC) {
    crc32_lut := GCrc32LookupTable;
}
    #no_bounds_check for (data_size != 0)
    {
        c := data[0]
        data = data[1:];
        if (c == '#' && data_size >= 2 && data[0] == '#' && data[1] == '#')   do crc = seed
when !(IMGUI_ENABLE_SSE4_2_CRC) {
        crc = (crc >> 8) ~ crc32_lut[(crc & 0xFF) ~ u32(c)];
} else {
        crc = _mm_crc32_u8(crc, c);
}
        data_size -= 1
    }
    return ~crc;
}

//-----------------------------------------------------------------------------
// [SECTION] MISC HELPERS/UTILITIES (File functions)
//-----------------------------------------------------------------------------

// Default file functions
when !IMGUI_DISABLE_DEFAULT_FILE_FUNCTIONS {

ImFileOpen :: proc(filename : string, mode : string) -> ImFileHandle
{
    _mode : int;
    for c in mode {
        switch c {
            case 'a': _mode = os.O_APPEND
            case 'r': _mode = _mode == os.O_WRONLY ? os.O_RDWR : os.O_RDONLY
            case 'w': _mode = _mode == os.O_RDONLY ? os.O_RDWR : os.O_TRUNC
            case '+': switch _mode {
                case os.O_RDONLY: _mode = os.O_RDWR
                case os.O_TRUNC:  _mode |= os.O_RDONLY
                case os.O_APPEND: _mode |= os.O_RDONLY
            }
            case: assert(false, fmt.tprint("unknown flagg passed into fopen:", c))
        }
    }

    handle, err := os.open(filename, _mode)
    if handle == os.INVALID_HANDLE do handle = os.Handle(0)
    return handle
}

// We should in theory be using fseeko()/ftello() with off_t and _fseeki64()/_ftelli64() with __int64, waiting for the PR that does that in a very portable pre-C++11 zero-warnings way.
ImFileClose :: proc(f : ImFileHandle) -> bool    { return os.close(f) == nil; }
ImFileGetSize :: proc(f : ImFileHandle) -> u64   {
    size, err := os.file_size(f)
    return u64(size)
}
ImFileRead :: proc(data : rawptr, sz : u64, count : u64, f : ImFileHandle) -> u64
{
    read, err := os.read(f, slice.bytes_from_ptr(data, int(sz * count)))
    return u64(read)
}
ImFileWrite :: proc(data : rawptr, sz : u64, count : u64, f : ImFileHandle) -> u64
{
    ln := os.write(f, slice.bytes_from_ptr(data, int(sz * count))); 
    return u64(ln)
}
} // #ifndef IMGUI_DISABLE_DEFAULT_FILE_FUNCTIONS

// Helper: Load file content into memory
// Memory allocated with IM_ALLOC(), must be freed by user using IM_FREE() == ImGui::MemFree()
// This can't really be used with "rt" because fseek size won't match read size.
ImFileLoadToMemory :: proc(filename : string, mode : string, out_file_size : ^u64 = nil, padding_bytes : u64 = 0) -> rawptr
{
    assert(filename != {} && mode != {});
    if (out_file_size != nil)   do out_file_size^ = 0

    f := ImFileOpen(filename, mode)
    if (f == {})   do return nil
    defer ImFileClose(f)

    file_size := ImFileGetSize(f);
    if (cast(int) file_size == -1)
    {
        return nil;
    }

    file_data := IM_ALLOC(int(file_size + padding_bytes));
    if (file_data == nil)
    {
        return nil;
    }
    if (ImFileRead(file_data, 1, file_size, f) != file_size)
    {
        IM_FREE(file_data);
        return nil;
    }
    if (padding_bytes > 0) {
        slice.fill(file_data[file_size:file_size + padding_bytes], 0)
    }

    if (out_file_size != nil)  do out_file_size^ = file_size;

    return file_data;
}

//-----------------------------------------------------------------------------
// [SECTION] MISC HELPERS/UTILITIES (ImText* functions)
//-----------------------------------------------------------------------------


// Convert UTF-8 to 32-bit character, process single character input.
// A nearly-branchless UTF-8 decoder, based on work of Christopher Wellons (https://github.com/skeeto/branchless-utf8).
// We handle UTF-8 decoding error by skipping forward.
// [forward declared comment]:
// read one character. return input UTF-8 bytes count
ImTextCharFromUtf8 :: proc(out_char : ^u32, in_text : [^]u8, in_text_end : ^u8) -> i32
{
    in_text_end := in_text_end

    @(static) lengths := [32]u8 { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 3, 3, 4, 0 };
    @(static) masks  := [?]u8  { 0x00, 0x7f, 0x1f, 0x0f, 0x07 };
    @(static) mins   := [?]u32 { 0x400000, 0, 0x80, 0x800, 0x10000 };
    @(static) shiftc := [?]u32 { 0, 18, 12, 6, 0 };
    @(static) shifte := [?]u32 { 0, 6, 4, 2, 0 };
    len := lengths[in_text[0] >> 3];
    wanted := len + (len != 0 ? 0 : 1);

    if (in_text_end == nil) {
        in_text_end = mem.ptr_offset(in_text, wanted); // Max length, nulls will be taken into account.
    }

    // Copy at most 'len' bytes, stop copying at 0 or past in_text_end. Branch predictor does a good job here,
    // so it is fast even with excessive branching.
    s : [4]u8;
    s[0] = mem.ptr_offset(in_text, 0) < in_text_end ? in_text[0] : 0;
    s[1] = mem.ptr_offset(in_text, 1) < in_text_end ? in_text[1] : 0;
    s[2] = mem.ptr_offset(in_text, 2) < in_text_end ? in_text[2] : 0;
    s[3] = mem.ptr_offset(in_text, 3) < in_text_end ? in_text[3] : 0;

    // Assume a four-byte character and load four bytes. Unused bits are shifted out.
    out_char^ = (u32)(s[0] & masks[len]) << 18;
    out_char^ |= (u32)(s[1] & 0x3f) << 12;
    out_char^ |= (u32)(s[2] & 0x3f) <<  6;
    out_char^ |= (u32)(s[3] & 0x3f) <<  0;
    out_char^ >>= shiftc[len];

    // Accumulate the various error conditions.
    e : u8
    e  = (out_char^ < mins[len] ? 1 : 0) << 6; // non-canonical encoding
    e |= ((out_char^ >> 11) == 0x1b  ? 1 : 0) << 7;  // surrogate half?
    e |= (out_char^ > IM_UNICODE_CODEPOINT_MAX  ? 1 : 0) << 8;  // out of range?
    e |= (s[1] & 0xc0) >> 2;
    e |= (s[2] & 0xc0) >> 4;
    e |= (s[3]       ) >> 6;
    e = e ~ 0x2a; // top two bits of each tail byte correct?
    e >>= shifte[len];

    if (e != 0)
    {
        // No bytes are consumed when *in_text == 0 || in_text == in_text_end.
        // One byte is consumed in case of invalid first byte of in_text.
        // All available bytes (at most `len` bytes) are consumed on incomplete/invalid second to last bytes.
        // Invalid or incomplete input may consume less bytes than wanted, therefore every byte has to be inspected in s.
        wanted = ImMin(wanted,
            s[0] == 0 ? 0 : 1 + 
            s[1] == 0 ? 0 : 1 + 
            s[2] == 0 ? 0 : 1 + 
            s[3] == 0 ? 0 : 1
        );
        out_char^ = IM_UNICODE_CODEPOINT_INVALID;
    }

    return i32(wanted);
}

// [forward declared comment]:
// return input UTF-8 bytes count
ImTextStrFromUtf8 :: proc(buf : [^]ImWchar, buf_size : i32, in_text : [^]u8, in_text_end : ^u8, in_text_remaining : ^[^]u8 = nil) -> i32
{
    in_text := in_text

    buf_out := buf;
    buf_end := mem.ptr_offset(buf, buf_size);
    for (buf_out < mem.ptr_offset(buf_end, -1) && (in_text_end == nil || cast(^u8) in_text < in_text_end) && in_text[0] != 0)
    {
        c : u32
        in_text = in_text[ImTextCharFromUtf8(&c, in_text, in_text_end):]
        buf_out[0] = ImWchar(c);
        buf_out = buf_out[1:]
    }
    buf_out[0] = 0;
    if (in_text_remaining != nil) {
        in_text_remaining^ = in_text;
    }
    return i32(mem.ptr_sub(buf_out, buf));
}

// [forward declared comment]:
// return number of UTF-8 code-points (NOT bytes count)
ImTextCountCharsFromUtf8 :: proc(in_text : [^]u8, in_text_end : ^u8) -> i32
{
    in_text := in_text

    char_count : i32 = 0;
    for ((in_text_end == nil || cast(^u8) in_text < in_text_end) && in_text[0] != 0)
    {
        c : u32
        in_text = in_text[ImTextCharFromUtf8(&c, in_text, in_text_end):]
        char_count += 1;
    }
    return char_count;
}

// Based on stb_to_utf8() from github.com/nothings/stb/
ImTextCharToUtf8_inline :: #force_inline proc(buf : [^]u8, buf_size : i32, c : u32) -> i32
{
    if (c < 0x80)
    {
        buf[0] = cast(u8) c;
        return 1;
    }
    if (c < 0x800)
    {
        if (buf_size < 2) do return 0;
        buf[0] = (u8)(0xc0 + (c >> 6));
        buf[1] = (u8)(0x80 + (c & 0x3f));
        return 2;
    }
    if (c < 0x10000)
    {
        if (buf_size < 3) do return 0;
        buf[0] = (u8)(0xe0 + (c >> 12));
        buf[1] = (u8)(0x80 + ((c >> 6) & 0x3f));
        buf[2] = (u8)(0x80 + ((c ) & 0x3f));
        return 3;
    }
    if (c <= 0x10FFFF)
    {
        if (buf_size < 4) do return 0;
        buf[0] = (u8)(0xf0 + (c >> 18));
        buf[1] = (u8)(0x80 + ((c >> 12) & 0x3f));
        buf[2] = (u8)(0x80 + ((c >> 6) & 0x3f));
        buf[3] = (u8)(0x80 + ((c ) & 0x3f));
        return 4;
    }
    // Invalid code point, the max unicode is 0x10FFFF
    return 0;
}

// [forward declared comment]:
// return out_buf
ImTextCharToUtf8 :: proc(out_buf : ^[5]u8, c : u32) -> ^u8
{
    count := ImTextCharToUtf8_inline(raw_data(out_buf), 5, c);
    out_buf[count] = 0;
    return raw_data(out_buf);
}

// Not optimal but we very rarely use this function.
// [forward declared comment]:
// return number of bytes to express one char in UTF-8
ImTextCountUtf8BytesFromChar_str :: proc(in_text : ^u8, in_text_end : ^u8) -> i32
{
    unused : u32 = 0;
    return ImTextCharFromUtf8(&unused, in_text, in_text_end);
}

ImTextCountUtf8BytesFromChar_u32 :: #force_inline proc(c :u32) -> i32
{
    if (c < 0x80) do return 1;
    if (c < 0x800) do return 2;
    if (c < 0x10000) do return 3;
    if (c <= 0x10FFFF) do return 4;
    return 3;
}

ImTextCountUtf8BytesFromChar :: proc { ImTextCountUtf8BytesFromChar_str, ImTextCountUtf8BytesFromChar_u32 }

// [forward declared comment]:
// return output UTF-8 bytes count
ImTextStrToUtf8 :: proc(out_buf : [^]u8, out_buf_size : i32, in_text : [^]ImWchar, in_text_end : ^ImWchar) -> i32
{
    in_text := in_text

    buf_p := out_buf;
    buf_end := out_buf[out_buf_size:];
    for (cast(^u8) buf_p < mem.ptr_offset(buf_end, -1) && (in_text_end == nil || in_text < in_text_end) && in_text[0] != 0)
    {
        c := cast(u32)in_text[0];
        in_text = in_text[1:]
        if (c < 0x80) {
            buf_p[0] = cast(u8) c
            buf_p = buf_p[1:]
        }
        else {
            buf_p = buf_p[ImTextCharToUtf8_inline(buf_p, (i32)(mem.ptr_sub(buf_end, buf_p) - 1), c):]
        }
    }
    buf_p[0] = 0;
    return (i32)(mem.ptr_sub(buf_p, out_buf));
}

// [forward declared comment]:
// return number of bytes to express string in UTF-8
ImTextCountUtf8BytesFromStr :: proc(in_text : [^]ImWchar, in_text_end : ^ImWchar) -> i32
{
    in_text := in_text
    bytes_count : i32 = 0;
    for ((in_text_end == nil || in_text < in_text_end) && in_text[0] != 0)
    {
        c := cast(u32)in_text[0]
        in_text = in_text[1:]
        if (c < 0x80)   do bytes_count += 1
        else do bytes_count += ImTextCountUtf8BytesFromChar(c);
    }
    return bytes_count;
}

// [forward declared comment]:
// return previous UTF-8 code-point.
ImTextFindPreviousUtf8Codepoint :: proc(in_text_start : [^]u8, in_text_curr : [^]u8) -> ^u8
{
    in_text_curr := in_text_curr
    for (in_text_curr > in_text_start)
    {
        in_text_curr = in_text_curr[-1:]
        if ((in_text_curr[0] & 0xC0) != 0x80)   do return in_text_curr
    }
    return in_text_start;
}

// [forward declared comment]:
// return number of lines taken by text. trailing carriage return doesn't count as an extra line.
ImTextCountLines :: proc(in_text : [^]u8, in_text_end : ^u8) -> i32
{
    in_text := in_text
    in_text_end := in_text_end

    if (in_text_end == nil) {
        in_text_end = mem.ptr_offset(in_text, strlen(in_text)); // FIXME-OPT: Not optimal approach, discourage use for now.
    }
    count : i32 = 0;
    for (in_text < in_text_end)
    {
        line_end := memchr_end(in_text, '\n', in_text_end);
        in_text = line_end == nil ? mem.ptr_offset(line_end, 1) : in_text_end;
        count += 1;
    }
    return count;
}


//-----------------------------------------------------------------------------
// [SECTION] MISC HELPERS/UTILITIES (Color functions)
// Note: The Convert functions are early design which are not consistent with other API.
//-----------------------------------------------------------------------------

ImAlphaBlendColors :: proc(col_a : u32, col_b : u32) -> u32
{
    t := ((col_b >> IM_COL32_A_SHIFT) & 0xFF) / 255.0
    r := ImLerp((i32)(col_a >> IM_COL32_R_SHIFT) & 0xFF, (i32)(col_b >> IM_COL32_R_SHIFT) & 0xFF, t);
    g := ImLerp((i32)(col_a >> IM_COL32_G_SHIFT) & 0xFF, (i32)(col_b >> IM_COL32_G_SHIFT) & 0xFF, t);
    b := ImLerp((i32)(col_a >> IM_COL32_B_SHIFT) & 0xFF, (i32)(col_b >> IM_COL32_B_SHIFT) & 0xFF, t);
    return IM_COL32(r, g, b, 0xFF);
}

ColorConvertU32ToFloat4 :: proc(v : u32) -> ImVec4
{
    s : f32 = 1.0 / 255.0;
    return ImVec4{
        f32((v >> IM_COL32_R_SHIFT) & 0xFF) * s,
        f32((v >> IM_COL32_G_SHIFT) & 0xFF) * s,
        f32((v >> IM_COL32_B_SHIFT) & 0xFF) * s,
        f32((v >> IM_COL32_A_SHIFT) & 0xFF) * s};
}

ColorConvertFloat4ToU32 :: proc(v : ImVec4) -> u32
{
    out : u32
    out  = (cast(u32) IM_F32_TO_INT8_SAT(v.x)) << IM_COL32_R_SHIFT;
    out |= (cast(u32) IM_F32_TO_INT8_SAT(v.y)) << IM_COL32_G_SHIFT;
    out |= (cast(u32) IM_F32_TO_INT8_SAT(v.z)) << IM_COL32_B_SHIFT;
    out |= (cast(u32) IM_F32_TO_INT8_SAT(v.w)) << IM_COL32_A_SHIFT;
    return out;
}

// Convert rgb floats ([0-1],[0-1],[0-1]) to hsv floats ([0-1],[0-1],[0-1]), from Foley & van Dam p592
// Optimized http://lolengine.net/blog/2013/01/13/fast-rgb-to-hsv
ColorConvertRGBtoHSV :: proc(r : f32, g : f32, b : f32, out_h : ^f32, out_s : ^f32, out_v : ^f32)
{
    g := g
    b := b
    r := r

    K : f32 = 0.0
    if (g < b)
    {
        ImSwap(&g, &b);
        K = -1.0
    }
    if (r < g)
    {
        ImSwap(&r, &g);
        K = -2.0 / 6.0 - K;
    }

    chroma := r - (g < b ? g : b);
    out_h^ = ImAbs(K + (g - b) / (6.0 * chroma + 1e-20));
    out_s^ = chroma / (r + 1e-20);
    out_v^ = r;
}

// Convert hsv floats ([0-1],[0-1],[0-1]) to rgb floats ([0-1],[0-1],[0-1]), from Foley & van Dam p593
// also http://en.wikipedia.org/wiki/HSL_and_HSV
ColorConvertHSVtoRGB :: proc(h : f32, s : f32, v : f32, out_r : ^f32, out_g : ^f32, out_b : ^f32)
{
    if (s == 0.0)
    {
        // gray
        out_r^ = v
        out_g^ = v
        out_b^ = v;
        return;
    }

    h := ImFmod(h, 1.0) / (60.0 / 360.0);
    i := cast(i32) h;
    f := h - cast(f32) i;
    p := v * (1.0 - s);
    q := v * (1.0 - s * f);
    t := v * (1.0 - s * (1.0 - f));

    switch (i)
    {
    case 0: out_r^ = v; out_g^ = t; out_b^ = p; break;
    case 1: out_r^ = q; out_g^ = v; out_b^ = p; break;
    case 2: out_r^ = p; out_g^ = v; out_b^ = t; break;
    case 3: out_r^ = p; out_g^ = q; out_b^ = v; break;
    case 4: out_r^ = t; out_g^ = p; out_b^ = v; break;
    case 5: case: out_r^ = v; out_g^ = p; out_b^ = q; break;
    }
}

//-----------------------------------------------------------------------------
// [SECTION] ImGuiStorage
// Helper: Key.value storage
//-----------------------------------------------------------------------------

// std::lower_bound but without the bullshit
ImLowerBound :: proc(in_begin : ^ImGuiStoragePair, in_end : ^ImGuiStoragePair, key : ImGuiID) -> ^ImGuiStoragePair
{
    in_p := in_begin;
    for count := mem.ptr_sub(in_end, in_p); count > 0; 
    {
        count2 := count >> 1;
        mid := mem.ptr_offset(in_p, count2);
        if (mid.key < key)
        {
            mid = mem.ptr_offset(mid, 1);
            in_p = mid;
            count -= count2 + 1;
        }
        else
        {
            count = count2;
        }
    }
    return in_p;
}

PairComparerByID :: proc(lhs, rhs : ^ImGuiStoragePair) -> i32
{
    // We can't just do a subtraction because qsort uses signed integers and subtracting our ID doesn't play well with that.
    lhs_v := lhs.key;
    rhs_v := rhs.key;
    return (lhs_v > rhs_v ? +1 : lhs_v < rhs_v ? -1 : 0);
}

// For quicker full rebuild of a storage (instead of an incremental one), you may add all your contents and then sort once.
BuildSortByKey :: proc(this : ^ImGuiStorage)
{
    ImQsort(raw_data(this.Data), len(this.Data), size_of(ImGuiStoragePair), PairComparerByID);
}

GetInt :: proc(this : ^ImGuiStorage, key : ImGuiID, default_val : i32 = 0) -> i32
{
    it := ImLowerBound(raw_data(this.Data), end(this.Data), key);
    if (it == end(this.Data) || it.key != key)   do return default_val
    return it.val_i;
}

GetBool :: proc(this : ^ImGuiStorage, key : ImGuiID, default_val : bool = false) -> bool
{
    return GetInt(this, key, default_val ? 1 : 0) != 0;
}

GetFloat :: proc(this : ^ImGuiStorage, key : ImGuiID, default_val : f32 = 0.0) -> f32
{
    it := ImLowerBound(raw_data(this.Data), end(this.Data), key);
    if (it == end(this.Data) || it.key != key)   do return default_val
    return it.val_f;
}

// [forward declared comment]:
// default_val is NULL
GetVoidPtr :: proc(this : ^ImGuiStorage, key : ImGuiID) -> rawptr
{
    it := ImLowerBound(raw_data(this.Data), end(this.Data), key);
    if (it == end(this.Data) || it.key != key)   do return nil
    return it.val_p;
}

// References are only valid until a new value is added to the storage. Calling a Set***() function or a Get***Ref() function invalidates the pointer.
GetIntRef :: proc(this : ^ImGuiStorage, key : ImGuiID, default_val : i32 = 0) -> ^i32
{
    it := ImLowerBound(raw_data(this.Data), end(this.Data), key);
    if (it == end(this.Data) || it.key != key) {
        it = insert(&this.Data, it, make_ImGuiStoragePair(key, default_val));
    }
    return &it.val_i;
}

GetBoolRef :: proc(this : ^ImGuiStorage, key : ImGuiID, default_val : bool = false) -> ^bool
{
    return cast(^bool)GetIntRef(this, key, default_val ? 1 : 0);
}

GetFloatRef :: proc(this : ^ImGuiStorage, key : ImGuiID, default_val : f32 = 0.0) -> ^f32
{
    it := ImLowerBound(raw_data(this.Data), end(this.Data), key);
    if (it == end(this.Data) || it.key != key) {
        it = insert(&this.Data, it, make_ImGuiStoragePair(key, default_val));
    }
    return &it.val_f;
}

GetVoidPtrRef :: proc(this : ^ImGuiStorage, key : ImGuiID, default_val : rawptr = nil) -> ^rawptr
{
    it := ImLowerBound(raw_data(this.Data), end(this.Data), key);
    if (it == end(this.Data) || it.key != key) {
        it = insert(&this.Data, it, make_ImGuiStoragePair(key, default_val));
    }
    return &it.val_p;
}

// FIXME-OPT: Need a way to reuse the result of lower_bound when doing GetInt()/SetInt() - not too bad because it only happens on explicit interaction (maximum one a frame)
SetInt :: proc(this : ^ImGuiStorage, key : ImGuiID, val : i32)
{
    it := ImLowerBound(raw_data(this.Data), end(this.Data), key);
    if (it == end(this.Data) || it.key != key) {
        insert(&this.Data, it, make_ImGuiStoragePair(key, val));
    }
    else {
        it.val_i = val;
    }
}

SetBool :: proc(this : ^ImGuiStorage, key : ImGuiID, val : bool)
{
    SetInt(this, key, val ? 1 : 0);
}

SetFloat :: proc(this : ^ImGuiStorage, key : ImGuiID, val : f32)
{
    it := ImLowerBound(raw_data(this.Data), end(this.Data), key);
    if (it == end(this.Data) || it.key != key) {
        insert(&this.Data, it, make_ImGuiStoragePair(key, val));
    }
    else {
        it.val_f = val;
    }
}

SetVoidPtr :: proc(this : ^ImGuiStorage, key : ImGuiID, val : rawptr)
{
    it := ImLowerBound(raw_data(this.Data), end(this.Data), key);
    if (it == end(this.Data) || it.key != key) {
        insert(&this.Data, it, make_ImGuiStoragePair(key, val));
    }
    else {
        it.val_p = val;
    }
}

SetAllInt :: proc(this : ^ImGuiStorage, v : i32)
{
    for &e in this.Data {
        e.val_i = v;
    }
}

//-----------------------------------------------------------------------------
// [SECTION] ImGuiTextFilter
//-----------------------------------------------------------------------------

// Helper: Parse and apply text filters. In format "aaaaa[,bbbb][,ccccc]"
init_ImGuiTextFilter :: proc(this : ^ImGuiTextFilter, default_filter : [^]u8) //-V1077
{
    this.InputBuf[0] = 0;
    this.CountGrep = 0;
    if (default_filter != nil)
    {
        ImStrncpy(raw_data(this.InputBuf[:]), default_filter, len(this.InputBuf));
        Build(this);
    }
}

// [forward declared comment]:
// Helper calling InputText+Build
Draw :: proc(this : ^ImGuiTextFilter, label : string = "Filter (inc,-exc)", width : f32 = 0.0) -> bool
{
    if (width != 0.0)   do SetNextItemWidth(width)
    value_changed := InputText(label, this.InputBuf[:]);
    if (value_changed)   do Build(this)
    return value_changed;
}

split :: proc(this : ^ImGuiTextRange, separator : u8, out : ^[dynamic]ImGuiTextRange)
{
    clear(out);
    wb := this.b;
    we := wb;
    for (we < this.e)
    {
        if (we[0] == separator)
        {
            append(out, ImGuiTextRange{wb, we});
            wb = we[1:]
        }
        we = we[1:]
    }
    if (wb != we) {
        append(out, ImGuiTextRange{wb, we});
    }
}

// [forward declared comment]:
// Build pixels data. This is called automatically for you by the GetTexData*** functions.
ImGuiTextFilter_Build :: proc(this : ^ImGuiTextFilter)
{
    clear(&this.Filters)
    input_range := ImGuiTextRange{&this.InputBuf[0], mem.ptr_offset(&this.InputBuf[0], strlen(raw_data(this.InputBuf[:])))};
    split(&input_range, ',', &this.Filters);

    this.CountGrep = 0;
    for &f in this.Filters
    {
        for (f.b < f.e && ImCharIsBlankA(f.b[0])) {
            f.b = mem.ptr_offset(f.b, 1);
        }
        for (f.e > f.b && ImCharIsBlankA(mem.ptr_offset(f.e, -1)^)) {
            f.e = mem.ptr_offset(f.e, -1);
        }
        if (empty(f))   do continue
        if (f.b[0] != '-')   do this.CountGrep += 1
    }
}

PassFilter :: proc(this : ^ImGuiTextFilter, text : string) -> bool
{
    if (len(this.Filters) == 0)   do return true

    text := text;

    for &f in this.Filters
    {
        if (f.b == f.e)   do continue
        if (f.b[0] == '-')
        {
            // Subtract
            if (ImStristr(text, string_from_start_end(f.b[1:], f.e)) != nil)   do return false
        }
        else
        {
            // Grep
            if (ImStristr(text, string_from_start_end(f.b, f.e)) != nil)   do return true
        }
    }

    // Implicit * grep
    if (this.CountGrep == 0)   do return true

    return false;
}

//-----------------------------------------------------------------------------
// [SECTION] ImGuiTextBuffer, ImGuiTextIndex
//-----------------------------------------------------------------------------

ImGuiTextBuffer__EmptyString : [1]u8 = { 0 };

ImGuiTextBuffer_append :: #force_inline proc(this : ^ImGuiTextBuffer, str : [^]u8, str_end : ^u8) { strings.write_bytes(this, str[:mem.ptr_sub(str_end, cast(^u8) str)]) }

// Helper: Text buffer for logging/accumulating text
appendf :: #force_inline proc(this : ^ImGuiTextBuffer, format : string, args : .. any) { fmt.sbprintf(this, format, args) }

ImGuiTextIndex_append :: proc(this : ^ImGuiTextIndex, base : string, old_size : i32, new_size : i32)
{
    assert(old_size >= 0 && new_size >= old_size && new_size >= this.EndOffset);
    if (old_size == new_size)   do return
    if (this.EndOffset == 0 || base[this.EndOffset - 1] == '\n') {
        append(&this.LineOffsets, this.EndOffset);
    }
    new_slice := base[old_size:new_size];
    #no_bounds_check for p := strings.index_byte(new_slice, '\n'); p != -1; p = strings.index_byte(new_slice, '\n') {
        new_slice = new_slice[1:]
        offset := cast(i32) mem.ptr_sub(raw_data(new_slice), raw_data(base))
        if (offset < new_size)  { // Don't push a trailing offset on last \n
            append(&this.LineOffsets, (i32(offset)));
        }
    }
    this.EndOffset = ImMax(this.EndOffset, new_size);
}


//-----------------------------------------------------------------------------
// [SECTION] ImGuiListClipper
//-----------------------------------------------------------------------------

// FIXME-TABLE: This prevents us from using ImGuiListClipper _inside_ a table cell.
// The problem we have is that without a Begin/End scheme for rows using the clipper is ambiguous.
GetSkipItemForListClipping :: proc() -> bool
{
    g := GImGui;
    return (g.CurrentTable != nil ? g.CurrentTable.HostSkipItems : g.CurrentWindow.SkipItems);
}

ImGuiListClipper_SortAndFuseRanges :: proc(ranges : ^[dynamic]ImGuiListClipperRange, offset : i32 = 0)
{
    if (cast(i32) len(ranges) - offset <= 1)   do return

    // Helper to order ranges and fuse them together if possible (bubble sort is fine as we are only sorting 2-3 entries)
    for sort_end := cast(i32) len(ranges) - offset - 1; sort_end > 0; sort_end -= 1 {
        for i := offset; i < sort_end + offset; i += 1 {
            if (ranges[i].Min > ranges[i + 1].Min) {
                ImSwap(&ranges[i], &ranges[i + 1]);
            }
        }
    }

    // Now fuse ranges together as much as possible.
    for i := 1 + offset; i < cast(i32) len(ranges); i += 1
    {
        assert(!ranges[i].PosToIndexConvert && !ranges[i - 1].PosToIndexConvert);
        if (ranges[i - 1].Max < ranges[i].Min)   do continue
        ranges[i - 1].Min = ImMin(ranges[i - 1].Min, ranges[i].Min);
        ranges[i - 1].Max = ImMax(ranges[i - 1].Max, ranges[i].Max);
        erase(ranges, &ranges[i]);
        i -= 1;
    }
}

ImGuiListClipper_SeekCursorAndSetupPrevLine :: proc(pos_y : f32, line_height : f32)
{
    // Set cursor position and a few other things so that SetScrollHereY() and Columns() can work when seeking cursor.
    // FIXME: It is problematic that we have to do that here, because custom/equivalent end-user code would stumble on the same issue.
    // The clipper should probably have a final step to display the last item in a regular manner, maybe with an opt-out flag for data sets which may have costly seek?
    g := GImGui;
    window := g.CurrentWindow;
    off_y := pos_y - window.DC.CursorPos.y;
    window.DC.CursorPos.y = pos_y;
    window.DC.CursorMaxPos.y = ImMax(window.DC.CursorMaxPos.y, pos_y - g.Style.ItemSpacing.y);
    window.DC.CursorPosPrevLine.y = window.DC.CursorPos.y - line_height;  // Setting those fields so that SetScrollHereY() can properly function after the end of our clipper usage.
    window.DC.PrevLineSize.y = (line_height - g.Style.ItemSpacing.y);      // If we end up needing more accurate data (to e.g. use SameLine) we may as well make the clipper have a fourth step to let user process and display the last item in their list.
    if columns := window.DC.CurrentColumns; columns != nil {
        columns.LineMinY = window.DC.CursorPos.y;                         // Setting this so that cell Y position are set properly
    }
    if table := g.CurrentTable; table != nil
    {
        if (table.IsInsideRow)   do TableEndRow(table)
        table.RowPosY2 = window.DC.CursorPos.y;
        row_increase := cast(i32)((off_y / line_height) + 0.5);
        //table.CurrentRow += row_increase; // Can't do without fixing TableEndRow()
        table.RowBgColorCounter += row_increase;
    }
}

deinit_ImGuiListClipper :: proc(this : ^ImGuiListClipper)
{
    End();
}

ListClipper_Begin :: proc(this : ^ImGuiListClipper, items_count : i32, items_height : f32 = 1.0)
{
    if (this.Ctx == nil)   do this.Ctx = GetCurrentContext()

    g := this.Ctx;
    window := g.CurrentWindow;
    IMGUI_DEBUG_LOG_CLIPPER(g, "Clipper: Begin(%d,%.2) in '%s'\n", items_count, items_height, window.Name);

    if table := g.CurrentTable; table != nil {
        if (table.IsInsideRow)   do TableEndRow(table)
    }

    this.StartPosY = window.DC.CursorPos.y;
    this.ItemsHeight = items_height;
    this.ItemsCount = items_count;
    this.DisplayStart = -1;
    this.DisplayEnd = 0;

    // Acquire temporary buffer
    g.ClipperTempDataStacked += 1
    if (g.ClipperTempDataStacked > cast(i32) len(g.ClipperTempData)) {
        resize(&g.ClipperTempData, g.ClipperTempDataStacked, { });
    }
    data := &g.ClipperTempData[g.ClipperTempDataStacked - 1];
    Reset(data, this);
    data.LossynessOffset = window.DC.CursorStartPosLossyness.y;
    this.TempData = data;
    this.StartSeekOffsetY = cast(f64) data.LossynessOffset;
}

// [forward declared comment]:
// Automatically called on the last call of Step() that returns false.
ImGuiListClipper_End :: proc(this : ^ImGuiListClipper)
{
    if data := cast(^ImGuiListClipperData)this.TempData; data != nil
    {
        // In theory here we should assert that we are already at the right position, but it seems saner to just seek at the end and not assert/crash the user.
        g := this.Ctx;
        IMGUI_DEBUG_LOG_CLIPPER(g, "Clipper: End() in '%s'\n", g.CurrentWindow.Name);
        if (this.ItemsCount >= 0 && this.ItemsCount < max(i32) && this.DisplayStart >= 0) {
            SeekCursorForItem(this, this.ItemsCount);
        }

        // Restore temporary buffer and fix back pointers which may be invalidated when nesting
        assert(data.ListClipper == this);
        data.StepNo = cast(i32) len(data.Ranges)
        g.ClipperTempDataStacked -= 1
        if (g.ClipperTempDataStacked > 0)
        {
            data = &g.ClipperTempData[g.ClipperTempDataStacked - 1];
            data.ListClipper.TempData = data;
        }
        this.TempData = nil;
    }
    this.ItemsCount = -1;
}

// [forward declared comment]:
// item_end is exclusive e.g. use (42, 42+1) to make item 42 never clipped.
IncludeItemsByIndex :: proc(this : ^ImGuiListClipper, item_begin : i32, item_end : i32)
{
    data := cast(^ImGuiListClipperData)this.TempData;
    assert(this.DisplayStart < 0); // Only allowed after Begin() and if there has not been a specified range yet.
    assert(item_begin <= item_end);
    if (item_begin < item_end) {
        append(&data.Ranges, ImGuiListClipperRange_FromIndices(item_begin, item_end));
    }
}

// This is already called while stepping.
// The ONLY reason you may want to call this is if you passed INT_MAX to ImGuiListClipper::Begin() because you couldn't step item count beforehand.
SeekCursorForItem :: proc(this : ^ImGuiListClipper, item_n : i32)
{
    // - Perform the add and multiply with double to allow seeking through larger ranges.
    // - StartPosY starts from ItemsFrozen, by adding SeekOffsetY we generally cancel that out (SeekOffsetY == LossynessOffset - ItemsFrozen * ItemsHeight).
    // - The reason we store SeekOffsetY instead of inferring it, is because we want to allow user to perform Seek after the last step, where ImGuiListClipperData is already done.
    pos_y := cast(f32)(cast(f64) this.StartPosY + this.StartSeekOffsetY + cast(f64) item_n * cast(f64) this.ItemsHeight);
    ImGuiListClipper_SeekCursorAndSetupPrevLine(pos_y, this.ItemsHeight);
}

ImGuiListClipper_StepInternal :: proc(clipper : ^ImGuiListClipper) -> bool
{
    g := clipper.Ctx;
    window := g.CurrentWindow;
    data := cast(^ImGuiListClipperData)clipper.TempData;
    assert(data != nil, "Called ImGuiListClipper::Step() too many times, or before ImGuiListClipper::Begin() ?");

    table := g.CurrentTable;
    if (table != nil && table.IsInsideRow)   do TableEndRow(table)

    // No items
    if (clipper.ItemsCount == 0 || GetSkipItemForListClipping())   do return false

    // While we are in frozen row state, keep displaying items one by one, unclipped
    // FIXME: Could be stored as a table-agnostic state.
    if (data.StepNo == 0 && table != nil && !table.IsUnfrozenRows)
    {
        clipper.DisplayStart = data.ItemsFrozen;
        clipper.DisplayEnd = ImMin(data.ItemsFrozen + 1, clipper.ItemsCount);
        if (clipper.DisplayStart < clipper.DisplayEnd)   do data.ItemsFrozen += 1
        return true;
    }

    // Step 0: Let you process the first element (regardless of it being visible or not, so we can measure the element height)
    calc_clipping := false;
    if (data.StepNo == 0)
    {
        clipper.StartPosY = window.DC.CursorPos.y;
        if (clipper.ItemsHeight <= 0.0)
        {
            // Submit the first item (or range) so we can measure its height (generally the first range is 0..1)
            append(&data.Ranges, ImGuiListClipperRange_FromIndices(data.ItemsFrozen, data.ItemsFrozen + 1));
            clipper.DisplayStart = ImMax(data.Ranges[0].Min, data.ItemsFrozen);
            clipper.DisplayEnd = ImMin(data.Ranges[0].Max, clipper.ItemsCount);
            data.StepNo = 1;
            return true;
        }
        calc_clipping = true;   // If on the first step with known item height, calculate clipping.
    }

    // Step 1: Let the clipper infer height from first range
    if (clipper.ItemsHeight <= 0.0)
    {
        assert(data.StepNo == 1);
        if (table != nil) {
            assert(table.RowPosY1 == clipper.StartPosY && table.RowPosY2 == window.DC.CursorPos.y);
        }

        clipper.ItemsHeight = (window.DC.CursorPos.y - clipper.StartPosY) / (f32)(clipper.DisplayEnd - clipper.DisplayStart);
        affected_by_floating_point_precision := ImIsFloatAboveGuaranteedIntegerPrecision(clipper.StartPosY) || ImIsFloatAboveGuaranteedIntegerPrecision(window.DC.CursorPos.y);
        if (affected_by_floating_point_precision) {
            clipper.ItemsHeight = window.DC.PrevLineSize.y + g.Style.ItemSpacing.y; // FIXME: Technically wouldn't allow multi-line entries.
        }
        if (clipper.ItemsHeight == 0.0 && clipper.ItemsCount == max(i32)) { // Accept that no item have been submitted if in indeterminate mode.
            return false;
        }
        assert(clipper.ItemsHeight > 0.0, "Unable to calculate item height! First item hasn't moved the cursor vertically!");
        calc_clipping = true;   // If item height had to be calculated, calculate clipping afterwards.
    }

    // Step 0 or 1: Calculate the actual ranges of visible elements.
    already_submitted := clipper.DisplayEnd;
    if (calc_clipping)
    {
        // Record seek offset, this is so ImGuiListClipper::Seek() can be called after ImGuiListClipperData is done
        clipper.StartSeekOffsetY = cast(f64) data.LossynessOffset -  cast(f64) data.ItemsFrozen * cast(f64) clipper.ItemsHeight;

        if (g.LogEnabled)
        {
            // If logging is active, do not perform any clipping
            append(&data.Ranges, ImGuiListClipperRange_FromIndices(0, clipper.ItemsCount));
        }
        else
        {
            // Add range selected to be included for navigation
            is_nav_request := (g.NavMoveScoringItems && g.NavWindow != nil && g.NavWindow.RootWindowForNav == window.RootWindowForNav);
            if (is_nav_request) {
                append(&data.Ranges, ImGuiListClipperRange_FromPositions(g.NavScoringNoClipRect.Min.y, g.NavScoringNoClipRect.Max.y, 0, 0));
            }
            if (is_nav_request && (.IsTabbing in g.NavMoveFlags) && g.NavTabbingDir == -1) {
                append(&data.Ranges, ImGuiListClipperRange_FromIndices(clipper.ItemsCount - 1, clipper.ItemsCount));
            }

            // Add focused/active item
            nav_rect_abs := WindowRectRelToAbs(window, window.NavRectRel[.Main]);
            if (g.NavId != 0 && window.NavLastIds[.Main] == g.NavId) {
                append(&data.Ranges, ImGuiListClipperRange_FromPositions(nav_rect_abs.Min.y, nav_rect_abs.Max.y, 0, 0));
            }

            // Add visible range
            min_y := window.ClipRect.Min.y;
            max_y := window.ClipRect.Max.y;

            // Add box selection range
            bs := &g.BoxSelectState;
            if (bs.IsActive && bs.Window == window)
            {
                // FIXME: Selectable() use of half-ItemSpacing isn't consistent in matter of layout, as ItemAdd(bb) stray above ItemSize()'s CursorPos.
                // RangeSelect's BoxSelect relies on comparing overlap of previous and current rectangle and is sensitive to that.
                // As a workaround we currently half ItemSpacing worth on each side.
                min_y -= g.Style.ItemSpacing.y;
                max_y += g.Style.ItemSpacing.y;

                // Box-select on 2D area requires different clipping.
                if (bs.UnclipMode) {
                    append(&data.Ranges, ImGuiListClipperRange_FromPositions(bs.UnclipRect.Min.y, bs.UnclipRect.Max.y, 0, 0));
                }
            }

            off_min : i32 = (is_nav_request && g.NavMoveClipDir == ImGuiDir.Up) ? -1 : 0;
            off_max : i32 = (is_nav_request && g.NavMoveClipDir == ImGuiDir.Down) ? 1 : 0;
            append(&data.Ranges, ImGuiListClipperRange_FromPositions(min_y, max_y, off_min, off_max));
        }

        // Convert position ranges to item index ranges
        // - Very important: when a starting position is after our maximum item, we set Min to (ItemsCount - 1). This allows us to handle most forms of wrapping.
        // - Due to how Selectable extra padding they tend to be "unaligned" with exact unit in the item list,
        //   which with the flooring/ceiling tend to lead to 2 items instead of one being submitted.
        for &range in data.Ranges {
            if (range.PosToIndexConvert)
            {
                m1 := (i32)((cast(f32) range.Min - window.DC.CursorPos.y - data.LossynessOffset) / clipper.ItemsHeight);
                m2 := (i32)(((cast(f32) range.Max - window.DC.CursorPos.y - data.LossynessOffset) / clipper.ItemsHeight) + 0.999999);
                range.Min = ImClamp(already_submitted + m1 + cast(i32) range.PosToIndexOffsetMin, already_submitted, clipper.ItemsCount - 1);
                range.Max = ImClamp(already_submitted + m2 + cast(i32) range.PosToIndexOffsetMax, range.Min + 1, clipper.ItemsCount);
                range.PosToIndexConvert = false;
            }
        }
        ImGuiListClipper_SortAndFuseRanges(&data.Ranges, data.StepNo);
    }

    // Step 0+ (if item height is given in advance) or 1+: Display the next range in line.
    for (data.StepNo < cast(i32) len(data.Ranges))
    {
        clipper.DisplayStart = ImMax(data.Ranges[data.StepNo].Min, already_submitted);
        clipper.DisplayEnd = ImMin(data.Ranges[data.StepNo].Max, clipper.ItemsCount);
        if (clipper.DisplayStart > already_submitted) {//-V1051
            SeekCursorForItem(clipper, clipper.DisplayStart);
        }
        data.StepNo += 1;
        if (clipper.DisplayStart == clipper.DisplayEnd && data.StepNo < cast(i32) len(data.Ranges))   do continue
        return true;
    }

    // After the last step: Let the clipper validate that we have reached the expected Y position (corresponding to element DisplayEnd),
    // Advance the cursor to the end of the list and then returns 'false' to end the loop.
    if (clipper.ItemsCount < max(i32)) {
        SeekCursorForItem(clipper, clipper.ItemsCount);
    }

    return false;
}

// [forward declared comment]:
// Call until it returns false. The DisplayStart/DisplayEnd fields will be set and you can process/draw those items.
Step :: proc(this : ^ImGuiListClipper) -> bool
{
    g := this.Ctx;
    need_items_height := (this.ItemsHeight <= 0.0);
    ret := ImGuiListClipper_StepInternal(this);
    if (ret && (this.DisplayStart == this.DisplayEnd))   do ret = false
    if (g.CurrentTable != nil && g.CurrentTable.IsUnfrozenRows == false) {
        IMGUI_DEBUG_LOG_CLIPPER(g, "Clipper: Step(): inside frozen table row.\n");
    }
    if (need_items_height && this.ItemsHeight > 0.0) {
        IMGUI_DEBUG_LOG_CLIPPER(g, "Clipper: Step(): computed ItemsHeight: %.2.\n", this.ItemsHeight);
    }
    if (ret)
    {
        IMGUI_DEBUG_LOG_CLIPPER(g, "Clipper: Step(): display %d to %d.\n", this.DisplayStart, this.DisplayEnd);
    }
    else
    {
        IMGUI_DEBUG_LOG_CLIPPER(g, "Clipper: Step(): End.\n");
        End();
    }
    return ret;
}

//-----------------------------------------------------------------------------
// [SECTION] STYLING
//-----------------------------------------------------------------------------

GetStyle :: proc() -> ^ImGuiStyle
{
    assert(GImGui != nil, "No current context. Did you call CreateContext() and SetCurrentContext() ?");
    return &GImGui.Style;
}

// [forward declared comment]:
// retrieve given color with style alpha applied, packed as a 32-bit value suitable for ImDrawList
GetColorU32_ia :: proc(idx : ImGuiCol, alpha_mul : f32 = 1.0) -> u32
{
    style := &GImGui.Style;
    c := style.Colors[idx];
    c.w *= style.Alpha * alpha_mul;
    return ColorConvertFloat4ToU32(c);
}

// [forward declared comment]:
// retrieve given color with style alpha applied, packed as a 32-bit value suitable for ImDrawList
GetColorU32_c :: proc(col : ImVec4) -> u32
{
    style := &GImGui.Style;
    c := col;
    c.w *= style.Alpha;
    return ColorConvertFloat4ToU32(c);
}

GetStyleColorVec4 :: proc(idx : ImGuiCol) -> ^ImVec4
{
    style := &GImGui.Style;
    return &style.Colors[idx];
}

// [forward declared comment]:
// retrieve given color with style alpha applied, packed as a 32-bit value suitable for ImDrawList
GetColorU32_ca :: proc(col : u32, alpha_mul : f32 = 1.0) -> u32
{
    style := &GImGui.Style;
    alpha_mul := alpha_mul * style.Alpha;
    if (alpha_mul >= 1.0)   do return col
    a := (col & IM_COL32_A_MASK) >> IM_COL32_A_SHIFT;
    a = (u32)(f32(a) * alpha_mul); // We don't need to clamp 0..255 because alpha is in 0..1 range.
    return (col & ~IM_COL32_A_MASK) | (a << IM_COL32_A_SHIFT);
}

GetColorU32 :: proc { GetColorU32_ca, GetColorU32_ia, GetColorU32_c }

// FIXME: This may incur a round-trip (if the end user got their data from a float4) but eventually we aim to store the in-flight colors as ImU32
PushStyleColor_u :: proc(idx : ImGuiCol, col : u32)
{
    g := GImGui;
    backup : ImGuiColorMod
    backup.Col = idx;
    backup.BackupValue = g.Style.Colors[idx];
    append(&g.ColorStack, backup);
    if (g.DebugFlashStyleColorIdx != idx) {
        g.Style.Colors[idx] = ColorConvertU32ToFloat4(col);
    }
}

PushStyleColor_v :: proc(idx : ImGuiCol, col : ImVec4)
{
    g := GImGui;
    backup : ImGuiColorMod
    backup.Col = idx;
    backup.BackupValue = g.Style.Colors[idx];
    append(&g.ColorStack, backup);
    if (g.DebugFlashStyleColorIdx != idx)   do g.Style.Colors[idx] = col
}

PushStyleColor :: proc { PushStyleColor_u, PushStyleColor_v }

PopStyleColor :: proc(count : int = 1)
{
    count := count

    g := GImGui;
    if (len(g.ColorStack) < count)
    {
        IM_ASSERT_USER_ERROR(false, "Calling PopStyleColor() too many times!");
        count = len(g.ColorStack);
    }
    for (count > 0)
    {
        backup := back(g.ColorStack);
        g.Style.Colors[backup.Col] = backup.BackupValue;
        pop(&g.ColorStack)
        count -= 1;
    }
}

GWindowDockStyleColors := [ImGuiWindowDockStyleCol]ImGuiCol {
    .Text                      = .Text,
    .TabHovered                = .TabHovered,
    .TabFocused                = .Tab,
    .TabSelected               = .TabSelected,
    .TabSelectedOverline       = .TabSelectedOverline,
    .TabDimmed                 = .TabDimmed,
    .TabDimmedSelected         = .TabDimmedSelected,
    .TabDimmedSelectedOverline = .TabDimmedSelectedOverline,
};

GStyleVarInfo := [ImGuiStyleVar]ImGuiDataVarInfo {
    .Alpha                       = { .Float, 1, cast(u32) offset_of(ImGuiStyle, Alpha) },                     // ImGuiStyleVar_Alpha
    .DisabledAlpha               = { .Float, 1, cast(u32) offset_of(ImGuiStyle, DisabledAlpha) },             // ImGuiStyleVar_DisabledAlpha
    .WindowPadding               = { .Float, 2, cast(u32) offset_of(ImGuiStyle, WindowPadding) },             // ImGuiStyleVar_WindowPadding
    .WindowRounding              = { .Float, 1, cast(u32) offset_of(ImGuiStyle, WindowRounding) },            // ImGuiStyleVar_WindowRounding
    .WindowBorderSize            = { .Float, 1, cast(u32) offset_of(ImGuiStyle, WindowBorderSize) },          // ImGuiStyleVar_WindowBorderSize
    .WindowMinSize               = { .Float, 2, cast(u32) offset_of(ImGuiStyle, WindowMinSize) },             // ImGuiStyleVar_WindowMinSize
    .WindowTitleAlign            = { .Float, 2, cast(u32) offset_of(ImGuiStyle, WindowTitleAlign) },          // ImGuiStyleVar_WindowTitleAlign
    .ChildRounding               = { .Float, 1, cast(u32) offset_of(ImGuiStyle, ChildRounding) },             // ImGuiStyleVar_ChildRounding
    .ChildBorderSize             = { .Float, 1, cast(u32) offset_of(ImGuiStyle, ChildBorderSize) },           // ImGuiStyleVar_ChildBorderSize
    .PopupRounding               = { .Float, 1, cast(u32) offset_of(ImGuiStyle, PopupRounding) },             // ImGuiStyleVar_PopupRounding
    .PopupBorderSize             = { .Float, 1, cast(u32) offset_of(ImGuiStyle, PopupBorderSize) },           // ImGuiStyleVar_PopupBorderSize
    .FramePadding                = { .Float, 2, cast(u32) offset_of(ImGuiStyle, FramePadding) },              // ImGuiStyleVar_FramePadding
    .FrameRounding               = { .Float, 1, cast(u32) offset_of(ImGuiStyle, FrameRounding) },             // ImGuiStyleVar_FrameRounding
    .FrameBorderSize             = { .Float, 1, cast(u32) offset_of(ImGuiStyle, FrameBorderSize) },           // ImGuiStyleVar_FrameBorderSize
    .ItemSpacing                 = { .Float, 2, cast(u32) offset_of(ImGuiStyle, ItemSpacing) },               // ImGuiStyleVar_ItemSpacing
    .ItemInnerSpacing            = { .Float, 2, cast(u32) offset_of(ImGuiStyle, ItemInnerSpacing) },          // ImGuiStyleVar_ItemInnerSpacing
    .IndentSpacing               = { .Float, 1, cast(u32) offset_of(ImGuiStyle, IndentSpacing) },             // ImGuiStyleVar_IndentSpacing
    .CellPadding                 = { .Float, 2, cast(u32) offset_of(ImGuiStyle, CellPadding) },               // ImGuiStyleVar_CellPadding
    .ScrollbarSize               = { .Float, 1, cast(u32) offset_of(ImGuiStyle, ScrollbarSize) },             // ImGuiStyleVar_ScrollbarSize
    .ScrollbarRounding           = { .Float, 1, cast(u32) offset_of(ImGuiStyle, ScrollbarRounding) },         // ImGuiStyleVar_ScrollbarRounding
    .GrabMinSize                 = { .Float, 1, cast(u32) offset_of(ImGuiStyle, GrabMinSize) },               // ImGuiStyleVar_GrabMinSize
    .GrabRounding                = { .Float, 1, cast(u32) offset_of(ImGuiStyle, GrabRounding) },              // ImGuiStyleVar_GrabRounding
    .TabRounding                 = { .Float, 1, cast(u32) offset_of(ImGuiStyle, TabRounding) },               // ImGuiStyleVar_TabRounding
    .TabBorderSize               = { .Float, 1, cast(u32) offset_of(ImGuiStyle, TabBorderSize) },             // ImGuiStyleVar_TabBorderSize
    .TabBarBorderSize            = { .Float, 1, cast(u32) offset_of(ImGuiStyle, TabBarBorderSize) },          // ImGuiStyleVar_TabBarBorderSize
    .TabBarOverlineSize          = { .Float, 1, cast(u32) offset_of(ImGuiStyle, TabBarOverlineSize) },        // ImGuiStyleVar_TabBarOverlineSize
    .TableAngledHeadersAngle     = { .Float, 1, cast(u32) offset_of(ImGuiStyle, TableAngledHeadersAngle)},    // ImGuiStyleVar_TableAngledHeadersAngle
    .TableAngledHeadersTextAlign = { .Float, 2, cast(u32) offset_of(ImGuiStyle, TableAngledHeadersTextAlign)},// ImGuiStyleVar_TableAngledHeadersTextAlign
    .ButtonTextAlign             = { .Float, 2, cast(u32) offset_of(ImGuiStyle, ButtonTextAlign) },           // ImGuiStyleVar_ButtonTextAlign
    .SelectableTextAlign         = { .Float, 2, cast(u32) offset_of(ImGuiStyle, SelectableTextAlign) },       // ImGuiStyleVar_SelectableTextAlign
    .SeparatorTextBorderSize     = { .Float, 1, cast(u32) offset_of(ImGuiStyle, SeparatorTextBorderSize)},    // ImGuiStyleVar_SeparatorTextBorderSize
    .SeparatorTextAlign          = { .Float, 2, cast(u32) offset_of(ImGuiStyle, SeparatorTextAlign) },        // ImGuiStyleVar_SeparatorTextAlign
    .SeparatorTextPadding        = { .Float, 2, cast(u32) offset_of(ImGuiStyle, SeparatorTextPadding) },      // ImGuiStyleVar_SeparatorTextPadding
    .DockingSeparatorSize        = { .Float, 1, cast(u32) offset_of(ImGuiStyle, DockingSeparatorSize) },      // ImGuiStyleVar_DockingSeparatorSize
};

GetStyleVarInfo :: proc(idx : ImGuiStyleVar) -> ^ImGuiDataVarInfo
{
    assert(transmute(i32) idx >= 0 && transmute(i32) idx < len(ImGuiStyleVar));
    return &GStyleVarInfo[idx];
}

// [forward declared comment]:
// modify a style ImVec2 variable. "
PushStyleVar_f :: proc(idx : ImGuiStyleVar, val : f32)
{
    g := GImGui;
    var_info := GetStyleVarInfo(idx);
    if (var_info.Type != ImGuiDataType.Float || var_info.Count != 1)
    {
        IM_ASSERT_USER_ERROR(false, "Calling PushStyleVar() variant with wrong type!");
        return;
    }
    pvar := cast(^f32) GetVarPtr(var_info, &g.Style);
    append(&g.StyleVarStack, make_ImGuiStyleMod(idx, pvar^));
    pvar^ = val;
}

// [forward declared comment]:
// modify X component of a style ImVec2 variable. "
PushStyleVarX :: proc(idx : ImGuiStyleVar, val_x : f32)
{
    g := GImGui;
    var_info := GetStyleVarInfo(idx);
    if (var_info.Type != ImGuiDataType.Float || var_info.Count != 2)
    {
        IM_ASSERT_USER_ERROR(false, "Calling PushStyleVar() variant with wrong type!");
        return;
    }
    pvar := cast(^ImVec2)GetVarPtr(var_info, &g.Style);
    append(&g.StyleVarStack, make_ImGuiStyleMod(idx, pvar^));
    pvar.x = val_x;
}

// [forward declared comment]:
// modify Y component of a style ImVec2 variable. "
PushStyleVarY :: proc(idx : ImGuiStyleVar, val_y : f32)
{
    g := GImGui;
    var_info := GetStyleVarInfo(idx);
    if (var_info.Type != ImGuiDataType.Float || var_info.Count != 2)
    {
        IM_ASSERT_USER_ERROR(false, "Calling PushStyleVar() variant with wrong type!");
        return;
    }
    pvar := cast(^ImVec2)GetVarPtr(var_info, &g.Style);
    append(&g.StyleVarStack, make_ImGuiStyleMod(idx, pvar^));
    pvar.y = val_y;
}

// [forward declared comment]:
// modify a style ImVec2 variable. "
PushStyleVar_v :: proc(idx : ImGuiStyleVar, val : ImVec2)
{
    g := GImGui;
    var_info := GetStyleVarInfo(idx);
    if (var_info.Type != ImGuiDataType.Float || var_info.Count != 2)
    {
        IM_ASSERT_USER_ERROR(false, "Calling PushStyleVar() variant with wrong type!");
        return;
    }
    pvar := cast(^ImVec2)GetVarPtr(var_info, &g.Style);
    append(&g.StyleVarStack, make_ImGuiStyleMod(idx, pvar^));
    pvar^ = val;
}

PushStyleVar :: proc { PushStyleVar_v, PushStyleVar_f }

PopStyleVar :: proc(count : int = 1)
{
    count := count
    g := GImGui;
    
    if (len(g.StyleVarStack) < count)
    {
        IM_ASSERT_USER_ERROR(false, "Calling PopStyleVar() too many times!");
        count = len(g.StyleVarStack);
    }

    for (count > 0)
    {
        // We avoid a generic memcpy(data, &backup.Backup.., GDataTypeSize[info.Type] * info.Count), the overhead in Debug is not worth it.
        backup := back(g.StyleVarStack);
        info := GetStyleVarInfo(backup.VarIdx);
        data := GetVarPtr(info, &g.Style);
        if (info.Type == ImGuiDataType.Float && info.Count == 1)      { (cast([^]f32) data)[0] = backup.BackupFloat[0]; }
        else if (info.Type == ImGuiDataType.Float && info.Count == 2) { (cast([^]f32) data)[0] = backup.BackupFloat[0]; (cast([^]f32) data)[1] = backup.BackupFloat[1]; }
        pop(&g.StyleVarStack);
        count -= 1;
    }
}

// [forward declared comment]:
// get a string corresponding to the enum value (for display, saving, etc.).
GetStyleColorName :: proc(idx : ImGuiCol) -> string
{
    // Create switch-case from enum with regexp: ImGuiCol.{.*}, --> case ImGuiCol.\1: return "\1";
    switch (idx)
    {
        case .Text:                      return "Text";
        case .TextDisabled:              return "TextDisabled";
        case .WindowBg:                  return "WindowBg";
        case .ChildBg:                   return "ChildBg";
        case .PopupBg:                   return "PopupBg";
        case .Border:                    return "Border";
        case .BorderShadow:              return "BorderShadow";
        case .FrameBg:                   return "FrameBg";
        case .FrameBgHovered:            return "FrameBgHovered";
        case .FrameBgActive:             return "FrameBgActive";
        case .TitleBg:                   return "TitleBg";
        case .TitleBgActive:             return "TitleBgActive";
        case .TitleBgCollapsed:          return "TitleBgCollapsed";
        case .MenuBarBg:                 return "MenuBarBg";
        case .ScrollbarBg:               return "ScrollbarBg";
        case .ScrollbarGrab:             return "ScrollbarGrab";
        case .ScrollbarGrabHovered:      return "ScrollbarGrabHovered";
        case .ScrollbarGrabActive:       return "ScrollbarGrabActive";
        case .CheckMark:                 return "CheckMark";
        case .SliderGrab:                return "SliderGrab";
        case .SliderGrabActive:          return "SliderGrabActive";
        case .Button:                    return "Button";
        case .ButtonHovered:             return "ButtonHovered";
        case .ButtonActive:              return "ButtonActive";
        case .Header:                    return "Header";
        case .HeaderHovered:             return "HeaderHovered";
        case .HeaderActive:              return "HeaderActive";
        case .Separator:                 return "Separator";
        case .SeparatorHovered:          return "SeparatorHovered";
        case .SeparatorActive:           return "SeparatorActive";
        case .ResizeGrip:                return "ResizeGrip";
        case .ResizeGripHovered:         return "ResizeGripHovered";
        case .ResizeGripActive:          return "ResizeGripActive";
        case .TabHovered:                return "TabHovered";
        case .Tab:                       return "Tab";
        case .TabSelected:               return "TabSelected";
        case .TabSelectedOverline:       return "TabSelectedOverline";
        case .TabDimmed:                 return "TabDimmed";
        case .TabDimmedSelected:         return "TabDimmedSelected";
        case .TabDimmedSelectedOverline: return "TabDimmedSelectedOverline";
        case .DockingPreview:            return "DockingPreview";
        case .DockingEmptyBg:            return "DockingEmptyBg";
        case .PlotLines:                 return "PlotLines";
        case .PlotLinesHovered:          return "PlotLinesHovered";
        case .PlotHistogram:             return "PlotHistogram";
        case .PlotHistogramHovered:      return "PlotHistogramHovered";
        case .TableHeaderBg:             return "TableHeaderBg";
        case .TableBorderStrong:         return "TableBorderStrong";
        case .TableBorderLight:          return "TableBorderLight";
        case .TableRowBg:                return "TableRowBg";
        case .TableRowBgAlt:             return "TableRowBgAlt";
        case .TextLink:                  return "TextLink";
        case .TextSelectedBg:            return "TextSelectedBg";
        case .DragDropTarget:            return "DragDropTarget";
        case .NavCursor:                 return "NavCursor";
        case .NavWindowingHighlight:     return "NavWindowingHighlight";
        case .NavWindowingDimBg:         return "NavWindowingDimBg";
        case .ModalWindowDimBg:          return "ModalWindowDimBg";
    }
    assert(false)
    return "Unknown";
}

//-----------------------------------------------------------------------------
// [SECTION] RENDER HELPERS
// Some of those (internal) functions are currently quite a legacy mess - their signature and behavior will change,
// we need a nicer separation between low-level functions and high-level functions relying on the ImGui context.
// Also see imgui_draw.cpp for some more which have been reworked to not rely on ImGui:: context.
//-----------------------------------------------------------------------------

// [forward declared comment]:
// Find the optional ## from which we stop displaying text.
FindRenderedText :: proc(text_ : string) -> (rendered : string, tag : string)
{
    text := raw_data(text_)
    text_end := end(text_)
    text_display_end := text;

    for (text_display_end < text_end && (text_display_end[0] != '#' || text_display_end[1] != '#')) {
        text_display_end = text_display_end[1:]
    }

    return string_from_start_end(text, text_display_end), string_from_start_end(text_display_end, text_end);
}

// Internal ImGui functions to render text
// RenderText***() functions calls ImDrawList::AddText() calls ImBitmapFont::RenderText()
RenderText_basic :: proc(pos : ImVec2, text : string, hide_text_after_hash : bool = true)
{
    g := GImGui;
    window := g.CurrentWindow;
    text := text

    // Hide anything after a '##' string
    if (hide_text_after_hash)
    {
        text, _ = FindRenderedText(text);
    }

    if (len(text) > 0)
    {
        AddText(window.DrawList, g.Font, g.FontSize, pos, GetColorU32(ImGuiCol.Text), text);
        if (g.LogEnabled) {
            pos := pos
            LogRenderedText(&pos, text);
        }
    }
}

RenderTextWrapped :: proc(pos : ImVec2, text : string, wrap_width : f32)
{
    g := GImGui;
    window := g.CurrentWindow;

    if (text != "")
    {
        AddText(window.DrawList, g.Font, g.FontSize, pos, GetColorU32(ImGuiCol.Text), text, wrap_width);
        if (g.LogEnabled) {
            LogRenderedText(&pos, text);
        }
    }
}

// Default clip_rect uses (pos_min,pos_max)
// Handle clipping on CPU immediately (vs typically let the GPU clip the triangles that are overlapping the clipping rectangle edges)
// FIXME-OPT: Since we have or calculate text_size we could coarse clip whole block immediately, especally for text above draw_list.DrawList.
// Effectively as this is called from widget doing their own coarse clipping it's not very valuable presently. Next time function will take
// better advantage of the render function taking size into account for coarse clipping.
RenderTextClippedEx :: proc(draw_list : ^ImDrawList, pos_min : ImVec2, pos_max : ImVec2, text : string, text_size_if_known : ^ImVec2, align : ImVec2 = {}, clip_rect : ^ImRect = nil)
{
    // Perform CPU side clipping for single clipped element to avoid using scissor state
    pos := pos_min;
    text_size := text_size_if_known != nil ? text_size_if_known^ : CalcTextSize(text, false, 0.0);

    clip_min := clip_rect != nil ? clip_rect.Min : pos_min;
    clip_max := clip_rect != nil ? clip_rect.Max : pos_max;
    need_clipping := (pos.x + text_size.x >= clip_max.x) || (pos.y + text_size.y >= clip_max.y);
    if (clip_rect != nil)  { // If we had no explicit clipping rectangle then pos==clip_min
        need_clipping |= (pos.x < clip_min.x) || (pos.y < clip_min.y);
    }

    // Align whole block. We should defer that to the better rendering function when we'll have support for individual line alignment.
    if (align.x > 0.0) do pos.x = ImMax(pos.x, pos.x + (pos_max.x - pos.x - text_size.x) * align.x);
    if (align.y > 0.0) do pos.y = ImMax(pos.y, pos.y + (pos_max.y - pos.y - text_size.y) * align.y);

    // Render
    if (need_clipping)
    {
        fine_clip_rect := ImVec4{clip_min.x, clip_min.y, clip_max.x, clip_max.y};
        AddText(draw_list, nil, 0.0, pos, GetColorU32(ImGuiCol.Text), text, 0.0, &fine_clip_rect);
    }
    else
    {
        AddText(draw_list, nil, 0.0, pos, GetColorU32(ImGuiCol.Text), text, 0.0, nil);
    }
}

RenderTextClipped :: proc(pos_min : ImVec2, pos_max : ImVec2, text : string, text_size_if_known : ^ImVec2, align : ImVec2 = {}, clip_rect : ^ImRect = nil)
{
    // Hide anything after a '##' string
    text, _ := FindRenderedText(text);
    if (len(text) == 0)   do return

    g := GImGui;
    window := g.CurrentWindow;
    RenderTextClippedEx(window.DrawList, pos_min, pos_max, text, text_size_if_known, align, clip_rect);
    if (g.LogEnabled) {
        pos_min := pos_min
        LogRenderedText(&pos_min, text);
    }
}

// Another overly complex function until we reorganize everything into a nice all-in-one helper.
// This is made more complex because we have dissociated the layout rectangle (pos_min..pos_max) which define _where_ the ellipsis is, from actual clipping of text and limit of the ellipsis display.
// This is because in the context of tabs we selectively hide part of the text when the Close Button appears, but we don't want the ellipsis to move.
RenderTextEllipsis :: proc(draw_list : ^ImDrawList, pos_min : ImVec2, pos_max : ImVec2, clip_max_x : f32, ellipsis_max_x : f32, text : string, text_size_if_known : ^ImVec2)
{
    text_begin := raw_data(text)
    text_end_full := end(text)

    g := GImGui;
    text, tag := FindRenderedText(text);
    text_size := text_size_if_known != nil ? text_size_if_known^ : CalcTextSize(text, false, 0.0);

    //draw_list.AddLine(ImVec2{pos_max.x, pos_min.y - 4}, ImVec2{pos_max.x, pos_max.y + 4}, IM_COL32(0, 0, 255, 255));
    //draw_list.AddLine(ImVec2{ellipsis_max_x, pos_min.y-2}, ImVec2{ellipsis_max_x, pos_max.y+2}, IM_COL32(0, 255, 0, 255));
    //draw_list.AddLine(ImVec2{clip_max_x, pos_min.y}, ImVec2{clip_max_x, pos_max.y}, IM_COL32(255, 0, 0, 255));
    // FIXME: We could technically remove (last_glyph.AdvanceX - last_glyph.X1) from text_size.x here and save a few pixels.
    if (text_size.x > pos_max.x - pos_min.x)
    {
        // Hello wo...
        // |       |   |
        // min   max   ellipsis_max
        //          <-> this is generally some padding value

        font := draw_list._Data.Font;
        font_size := draw_list._Data.FontSize;
        font_scale := draw_list._Data.FontScale;
        text_end_ellipsis : [^]u8 
        ellipsis_width := font.EllipsisWidth * font_scale;

        // We can now claim the space between pos_max.x and ellipsis_max.x
        text_avail_width := ImMax((ImMax(pos_max.x, ellipsis_max_x) - ellipsis_width) - pos_min.x, 1.0);
        text_size_clipped_x := CalcTextSizeA(font, font_size, text_avail_width, 0.0, text, &text_end_ellipsis).x;
        if (text_begin == text_end_ellipsis && text_end_ellipsis < text_end_full)
        {
            // Always display at least 1 character if there's no room for character + ellipsis
            text_end_ellipsis = text_begin[ImTextCountUtf8BytesFromChar(text_begin, text_end_full):];
            text_size_clipped_x = CalcTextSizeA(font, font_size, math.F32_MAX, 0.0, text, text_end_ellipsis).x;
        }
        for (text_end_ellipsis > text && ImCharIsBlankA(text_end_ellipsis[-1]))
        {
            // Trim trailing space before ellipsis (FIXME: Supporting non-ascii blanks would be nice, for this we need a function to backtrack in UTF-8 text)
            text_end_ellipsis -= 1;
            text_size_clipped_x -= CalcTextSizeA(font, font_size, math.F32_MAX, 0.0, string_from_start_end(text_end_ellipsis, text_end_ellipsis[1:])).x; // Ascii blanks are always 1 byte
        }

        // Render text, render ellipsis
        RenderTextClippedEx(draw_list, pos_min, ImVec2{clip_max_x, pos_max.y}, string_from_start_end(text_begin, text_end_ellipsis), &text_size, ImVec2{0.0, 0.0});
        ellipsis_pos := ImTrunc(ImVec2{pos_min.x + text_size_clipped_x, pos_min.y});
        if (ellipsis_pos.x + ellipsis_width <= ellipsis_max_x) {
            for i : i16 = 0; i < font.EllipsisCharCount; i, ellipsis_pos.x = i + 1, ellipsis_pos.x + font.EllipsisCharStep * font_scale {
                RenderChar(font, font, draw_list, font_size, ellipsis_pos, GetColorU32(ImGuiCol.Text), font.EllipsisChar);
            }
        }
    }
    else
    {
        RenderTextClippedEx(draw_list, pos_min, ImVec2{clip_max_x, pos_max.y}, text, &text_size, ImVec2{0.0, 0.0});
    }

    if (g.LogEnabled) {
        LogRenderedText(&pos_min, text, text_end_full);
    }
}

// Render a rectangle shaped with optional rounding and borders
RenderFrame :: proc(p_min : ImVec2, p_max : ImVec2, fill_col : u32, borders : bool = true, rounding : f32 = 0.0)
{
    g := GImGui;
    window := g.CurrentWindow;
    AddRectFilled(window.DrawList, p_min, p_max, fill_col, rounding);
    border_size := g.Style.FrameBorderSize;
    if (borders && border_size > 0.0)
    {
        AddRect(window.DrawList, p_min + ImVec2{1, 1}, p_max + ImVec2{1, 1}, GetColorU32(ImGuiCol.BorderShadow), rounding, {}, border_size);
        AddRect(window.DrawList, p_min, p_max, GetColorU32(ImGuiCol.Border), rounding, {}, border_size);
    }
}

RenderFrameBorder :: proc(p_min : ImVec2, p_max : ImVec2, rounding : f32 = 0.0)
{
    g := GImGui;
    window := g.CurrentWindow;
    border_size := g.Style.FrameBorderSize;
    if (border_size > 0.0)
    {
        AddRect(window.DrawList, p_min + ImVec2{1, 1}, p_max + ImVec2{1, 1}, GetColorU32(ImGuiCol.BorderShadow), rounding, 0, border_size);
        AddRect(window.DrawList, p_min, p_max, GetColorU32(ImGuiCol.Border), rounding, 0, border_size);
    }
}

// [forward declared comment]:
// Navigation highlight
RenderNavCursor :: proc(bb : ImRect, id : ImGuiID, flags : ImGuiNavRenderCursorFlags = nil)
{
    g := GImGui;
    if (id != g.NavId)   do return
    if (!g.NavCursorVisible && !(.AlwaysDraw in flags))   do return
    if (id == g.LastItemData.ID && (.NoNav in g.LastItemData.ItemFlags))   do return
    window := g.CurrentWindow;
    if (window.DC.NavHideHighlightOneFrame)   do return

    rounding := (.NoRounding in flags) ? 0.0 : g.Style.FrameRounding;
    display_rect := bb;
    ClipWith(&display_rect, window.ClipRect);
    thickness : f32 = 2.0;
    if (.Compact in flags)
    {
        AddRect(window.DrawList, display_rect.Min, display_rect.Max, GetColorU32(ImGuiCol.NavCursor), rounding, nil, thickness);
    }
    else
    {
        distance := 3.0 + thickness * 0.5;
        Expand(&display_rect, ImVec2{distance, distance});
        fully_visible := Contains(window.ClipRect, display_rect);
        if (!fully_visible) {
            PushClipRect(window.DrawList, display_rect.Min, display_rect.Max);
        }
        AddRect(window.DrawList, display_rect.Min, display_rect.Max, GetColorU32(ImGuiCol.NavCursor), rounding, nil, thickness);
        if (!fully_visible) {
            PopClipRect(window.DrawList, );
        }
    }
}

RenderMouseCursor :: proc(base_pos : ImVec2, base_scale : f32, mouse_cursor : ImGuiMouseCursor, col_fill : u32, col_border : u32, col_shadow : u32)
{
    g := GImGui;
    if (mouse_cursor <= ImGuiMouseCursor_None || mouse_cursor >= ImGuiMouseCursor_COUNT) {// We intentionally accept out of bound values.
        mouse_cursor = ImGuiMouseCursor_Arrow;
    }
    font_atlas := g.DrawListSharedData.Font.ContainerAtlas;
    for viewport in g.Viewports
    {
        // We scale cursor with current viewport/monitor, however Windows 10 for its own hardware cursor seems to be using a different scale factor.
        offset : ImVec2
        size : ImVec2
        uv : [4]ImVec2;
        if (!font_atlas.GetMouseCursorTexData(mouse_cursor, &offset, &size, &uv[0], &uv[2]))   do continue
        pos := base_pos - offset;
        scale := base_scale * viewport.DpiScale;
        if (!viewport.GetMainRect().Overlaps(ImRect(pos, pos + ImVec2{size.x + 2, size.y + 2} * scale)))   do continue
        draw_list := GetForegroundDrawList(viewport);
        tex_id := font_atlas.TexID;
        draw_list.PushTextureID(tex_id);
        draw_list.AddImage(tex_id, pos + ImVec2{1, 0} * scale, pos + (ImVec2{1, 0} + size) * scale, uv[2], uv[3], col_shadow);
        draw_list.AddImage(tex_id, pos + ImVec2{2, 0} * scale, pos + (ImVec2{2, 0} + size) * scale, uv[2], uv[3], col_shadow);
        draw_list.AddImage(tex_id, pos,                        pos + size * scale,                  uv[2], uv[3], col_border);
        draw_list.AddImage(tex_id, pos,                        pos + size * scale,                  uv[0], uv[1], col_fill);
        draw_list.PopTextureID();
    }
}

//-----------------------------------------------------------------------------
// [SECTION] INITIALIZATION, SHUTDOWN
//-----------------------------------------------------------------------------

// Internal state access - if you want to share Dear ImGui state between modules (e.g. DLL) or allocate it yourself
// Note that we still point to some static data and members (such as GFontAtlas), so the state instance you end up using will point to the static data within its module
GetCurrentContext :: proc() -> ^ImGuiContext
{
    return GImGui;
}

SetCurrentContext :: proc(ctx : ^ImGuiContext)
{
    GImGui = ctx;
}

SetAllocatorFunctions :: proc(alloc_func : ImGuiMemAllocFunc, free_func : ImGuiMemFreeFunc, user_data : rawptr = nil)
{
    GImAllocatorAllocFunc = alloc_func;
    GImAllocatorFreeFunc = free_func;
    GImAllocatorUserData = user_data;
}

// This is provided to facilitate copying allocators from one static/DLL boundary to another (e.g. retrieve default allocator of your executable address space)
GetAllocatorFunctions :: proc(p_alloc_func : ^ImGuiMemAllocFunc, p_free_func : ^ImGuiMemFreeFunc, p_user_data : ^rawptr)
{
    p_alloc_func^ = GImAllocatorAllocFunc;
    p_free_func^ = GImAllocatorFreeFunc;
    p_user_data^ = GImAllocatorUserData;
}

CreateContext :: proc(shared_font_atlas : ^ImFontAtlas = nil) -> ^ImGuiContext
{
    prev_ctx := GetCurrentContext();
    ctx := IM_NEW(ImGuiContext)
    init_ImGuiContext(ctx, shared_font_atlas)
    SetCurrentContext(ctx);
    Initialize();
    if (prev_ctx != nil) {
        SetCurrentContext(prev_ctx); // Restore previous context if any, else keep new one.
    }
    return ctx;
}

// [forward declared comment]:
// NULL = destroy current context
DestroyContext :: proc(ctx : ^ImGuiContext = nil)
{
    ctx := ctx
    prev_ctx := GetCurrentContext();
    if (ctx == nil) {//-V1051
        ctx = prev_ctx;
    }
    SetCurrentContext(ctx);
    Shutdown();
    SetCurrentContext((prev_ctx != ctx) ? prev_ctx : nil);
    IM_DELETE(ctx);
}

// IMPORTANT: interactive elements requires a fixed ###xxx suffix, it must be same in ALL languages to allow for automation.
GLocalizationEntriesEnUS := [?]ImGuiLocEntry {
    { .VersionStr                   , "Dear ImGui "+ IMGUI_VERSION +" (" /*+IMGUI_VERSION_NUM*/+ ")" }, // TODO
    { .TableSizeOne                 , "Size column to fit###SizeOne"          },
    { .TableSizeAllFit              , "Size all columns to fit###SizeAll"     },
    { .TableSizeAllDefault          , "Size all columns to default###SizeAll" },
    { .TableResetOrder              , "Reset order###ResetOrder"              },
    { .WindowingMainMenuBar         , "(Main menu bar)"                       },
    { .WindowingPopup               , "(Popup)"                               },
    { .WindowingUntitled            , "(Untitled)"                            },
    { .OpenLink_s                   , "Open '%s'"                             },
    { .CopyLink                     , "Copy Link###CopyLink"                  },
    { .DockingHideTabBar            , "Hide tab bar###HideTabBar"             },
    { .DockingHoldShiftToDock       , "Hold SHIFT to enable Docking window."  },
    { .DockingDragToUndockOrMoveNode, "Click and drag to move or undock whole node."    },
};

init_ImGuiContext :: proc(this : ^ImGuiContext, shared_font_atlas : ^ImFontAtlas)
{
    this.IO.Ctx = this;
    this.InputTextState.Ctx = this;

    this.Initialized = false;
    this.ConfigFlagsCurrFrame = nil
    this.ConfigFlagsLastFrame = nil;
    this.FontAtlasOwnedByContext = shared_font_atlas != nil ? false : true;
    this.Font = nil;
    this.FontSize = 0
    this.FontBaseSize = 0
    this.FontScale = 0
    this.CurrentDpiScale = 0.0;
    this.IO.Fonts = shared_font_atlas != nil ? shared_font_atlas : IM_NEW(ImFontAtlas);
    this.Time = 0.0;
    this.FrameCount = 0;
    this.FrameCountEnded = -1
    this.FrameCountPlatformEnded = -1
    this.FrameCountRendered = -1;
    this.WithinEndChildID = 0;
    this.WithinFrameScope = false
    this.WithinFrameScopeWithImplicitWindow = false;
    this.GcCompactAll = false;
    this.TestEngineHookItems = false;
    this.TestEngine = nil;
    this.ContextName = {}

    this.InputEventsNextMouseSource = .Mouse;
    this.InputEventsNextEventId = 1;

    this.WindowsActiveCount = 0;
    this.CurrentWindow = nil;
    this.HoveredWindow = nil;
    this.HoveredWindowUnderMovingWindow = nil;
    this.HoveredWindowBeforeClear = nil;
    this.MovingWindow = nil;
    this.WheelingWindow = nil;
    this.WheelingWindowStartFrame = -1
    this.WheelingWindowScrolledFrame = -1;
    this.WheelingWindowReleaseTimer = 0.0;

    this.DebugDrawIdConflicts = 0;
    this.DebugHookIdInfo = 0;
    this.HoveredId = 0
    this.HoveredIdPreviousFrame = 0;
    this.HoveredIdPreviousFrameItemCount = 0;
    this.HoveredIdAllowOverlap = false;
    this.HoveredIdIsDisabled = false;
    this.HoveredIdTimer = 0
    this.HoveredIdNotActiveTimer = 0.0;
    this.ItemUnclipByLog = false;
    this.ActiveId = 0;
    this.ActiveIdIsAlive = 0;
    this.ActiveIdTimer = 0.0;
    this.ActiveIdIsJustActivated = false;
    this.ActiveIdAllowOverlap = false;
    this.ActiveIdNoClearOnFocusLoss = false;
    this.ActiveIdHasBeenPressedBefore = false;
    this.ActiveIdHasBeenEditedBefore = false;
    this.ActiveIdHasBeenEditedThisFrame = false;
    this.ActiveIdFromShortcut = false;
    this.ActiveIdClickOffset = ImVec2{-1, -1};
    this.ActiveIdWindow = nil;
    this.ActiveIdSource = nil;
    this.ActiveIdMouseButton = -1;
    this.ActiveIdPreviousFrame = 0;
    this.ActiveIdPreviousFrameIsAlive = false;
    this.ActiveIdPreviousFrameHasBeenEditedBefore = false;
    this.ActiveIdPreviousFrameWindow = nil;
    this.ActiveIdValueOnActivation = {}
    this.LastActiveId = 0;
    this.LastActiveIdTimer = 0.0;

    this.LastKeyboardKeyPressTime = -1
    this.LastKeyModsChangeTime = -1
    this.LastKeyModsChangeFromNoneTime = -1.0;

    this.ActiveIdUsingNavDirMask = 0x00;
    this.ActiveIdUsingAllKeyboardKeys = false;

    this.CurrentFocusScopeId = 0;
    this.CurrentItemFlags = nil;
    this.DebugShowGroupRects = false;

    this.CurrentViewport = nil;
    this.MouseViewport = nil
    this.MouseLastHoveredViewport = nil;
    this.PlatformLastFocusedViewportId = 0;
    this.ViewportCreatedCount = 0
    this.PlatformWindowsCreatedCount = 0;
    this.ViewportFocusedStampCount = 0;

    this.NavCursorVisible = false;
    this.NavHighlightItemUnderNav = false;
    this.NavMousePosDirty = false;
    this.NavIdIsAlive = false;
    this.NavId = 0;
    this.NavWindow = nil;
    this.NavFocusScopeId = 0
    this.NavActivateId = 0
    this.NavActivateDownId = 0
    this.NavActivatePressedId = 0;
    this.NavLayer = .Main;
    this.NavNextActivateId = 0;
    this.NavActivateFlags = nil
    this.NavNextActivateFlags = nil;
    this.NavHighlightActivatedId = 0;
    this.NavHighlightActivatedTimer = 0.0;
    this.NavInputSource = .Keyboard;
    this.NavLastValidSelectionUserData = ImGuiSelectionUserData_Invalid;
    this.NavCursorHideFrames = 0;

    this.NavAnyRequest = false;
    this.NavInitRequest = false;
    this.NavInitRequestFromMove = false;
    this.NavMoveSubmitted = false;
    this.NavMoveScoringItems = false;
    this.NavMoveForwardToNextFrame = false;
    this.NavMoveFlags = nil;
    this.NavMoveScrollFlags = nil;
    this.NavMoveKeyMods = {};
    this.NavMoveDir = nil
    this.NavMoveDirForDebug = nil
    this.NavMoveClipDir = nil;
    this.NavScoringDebugCount = 0;
    this.NavTabbingDir = 0;
    this.NavTabbingCounter = 0;

    this.NavJustMovedFromFocusScopeId = 0
    this.NavJustMovedToId = 0
    this.NavJustMovedToFocusScopeId = 0;
    this.NavJustMovedToKeyMods = {};
    this.NavJustMovedToIsTabbing = false;
    this.NavJustMovedToHasSelectionData = false;

    // All platforms use Ctrl+Tab but Ctrl<>Super are swapped on Mac...
    // FIXME: Because this value is stored, it annoyingly interfere with toggling io.ConfigMacOSXBehaviors updating this..
    this.ConfigNavWindowingKeyNext = this.IO.ConfigMacOSXBehaviors ? (ImGuiKey.Mod_Super | ImGuiKey.Tab) : (ImGuiKey.Mod_Ctrl | ImGuiKey.Tab);
    this.ConfigNavWindowingKeyPrev = this.IO.ConfigMacOSXBehaviors ? (ImGuiKey.Mod_Super | ImGuiKey.Mod_Shift | ImGuiKey.Tab) : (ImGuiKey.Mod_Ctrl | ImGuiKey.Mod_Shift | ImGuiKey.Tab);
    this.NavWindowingTarget = nil
    this.NavWindowingTargetAnim = nil
    this.NavWindowingListWindow = nil;
    this.NavWindowingTimer = 0
    this.NavWindowingHighlightAlpha = 0.0;
    this.NavWindowingToggleLayer = false;
    this.NavWindowingToggleKey = nil;

    this.DimBgRatio = 0.0;

    this.DragDropActive = false
    this.DragDropWithinSource = false
    this.DragDropWithinTarget = false;
    this.DragDropSourceFlags = nil;
    this.DragDropSourceFrameCount = -1;
    this.DragDropMouseButton = -1;
    this.DragDropTargetId = 0;
    this.DragDropAcceptFlags = nil;
    this.DragDropAcceptIdCurrRectSurface = 0.0;
    this.DragDropAcceptIdPrev = 0
    this.DragDropAcceptIdCurr = 0;
    this.DragDropAcceptFrameCount = -1;
    this.DragDropHoldJustPressedId = 0;
    this.DragDropPayloadBufLocal = {}

    this.ClipperTempDataStacked = 0;

    this.CurrentTable = nil;
    this.TablesTempDataStacked = 0;
    this.CurrentTabBar = nil;
    this.CurrentMultiSelect = nil;
    this.MultiSelectTempDataStacked = 0;

    this.HoverItemDelayId = 0
    this.HoverItemDelayIdPreviousFrame = 0
    this.HoverItemUnlockedStationaryId = 0
    this.HoverWindowUnlockedStationaryId = 0;
    this.HoverItemDelayTimer = 0
    this.HoverItemDelayClearTimer = 0.0;

    this.MouseCursor = .Arrow;
    this.MouseStationaryTimer = 0.0;

    this.TempInputId = 0;
    this.DataTypeZeroValue = {}
    this.BeginMenuDepth = 0
    this.BeginComboDepth = 0;
    this.ColorEditOptions = ImGuiColorEditFlags_DefaultOptions_;
    this.ColorEditCurrentID = 0
    this.ColorEditSavedID = 0;
    this.ColorEditSavedHue = 0
    this.ColorEditSavedSat = 0.0;
    this.ColorEditSavedColor = 0;
    this.WindowResizeRelativeMode = false;
    this.ScrollbarSeekMode = 0;
    this.ScrollbarClickDeltaToGrabCenter = 0.0;
    this.SliderGrabClickOffset = 0.0;
    this.SliderCurrentAccum = 0.0;
    this.SliderCurrentAccumDirty = false;
    this.DragCurrentAccumDirty = false;
    this.DragCurrentAccum = 0.0;
    this.DragSpeedDefaultRatio = 1.0 / 100.0;
    this.DisabledAlphaBackup = 0.0;
    this.DisabledStackSize = 0;
    this.TooltipOverrideCount = 0;
    this.TooltipPreviousWindow = nil;

    this.PlatformImeData.InputPos = ImVec2{0.0, 0.0};
    this.PlatformImeDataPrev.InputPos = ImVec2{-1.0, -1.0}; // Different to ensure initial submission
    this.PlatformImeViewport = 0;

    this.DockNodeWindowMenuHandler = nil;

    this.SettingsLoaded = false;
    this.SettingsDirtyTimer = 0.0;
    this.HookIdNext = 0;

    this.LocalizationTable = {}

    this.LogEnabled = false;
    this.LogFlags = nil;
    this.LogWindow = nil;
    this.LogNextPrefix = nil
    this.LogNextSuffix = nil;
    this.LogFile = {};
    this.LogLinePosY = math.F32_MAX;
    this.LogLineFirstItem = false;
    this.LogDepthRef = 0;
    this.LogDepthToExpand = 2
    this.LogDepthToExpandDefault = 2;

    this.ErrorCallback = nil;
    this.ErrorCallbackUserData = nil;
    this.ErrorFirst = true;
    this.ErrorCountCurrentFrame = 0;
    this.StackSizesInBeginForCurrentWindow = nil;

    this.DebugDrawIdConflictsCount = 0;
    this.DebugLogFlags = {.EventError, .OutputToTTY};
    this.DebugLocateId = 0;
    this.DebugLogSkippedErrors = 0;
    this.DebugLogAutoDisableFlags = nil;
    this.DebugLogAutoDisableFrames = 0;
    this.DebugLocateFrames = 0;
    this.DebugBeginReturnValueCullDepth = -1;
    this.DebugItemPickerActive = false;
    this.DebugItemPickerMouseButton = cast(u8) ImGuiMouseButton.Left;
    this.DebugItemPickerBreakId = 0;
    this.DebugFlashStyleColorTime = 0.0;
    this.DebugFlashStyleColorIdx = ImGuiCol(len(ImGuiCol))
    this.DebugHoveredDockNode = nil;

    // Same as DebugBreakClearData(). Those fields are scattered in their respective subsystem to stay in hot-data locations
    this.DebugBreakInWindow = {};
    this.DebugBreakInTable = 0;
    this.DebugBreakInLocateId = false;
    this.DebugBreakKeyChord =  ImGuiKey.Pause;
    this.DebugBreakInShortcutRouting = nil;

    this.FramerateSecPerFrame = {}
    this.FramerateSecPerFrameIdx = 0
    this.FramerateSecPerFrameCount = 0;
    this.FramerateSecPerFrameAccum = 0.0;
    this.WantCaptureMouseNextFrame = -1
    this.WantCaptureKeyboardNextFrame = -1
    this.WantTextInputNextFrame = -1;
    this.TempKeychordName = {}
}

Initialize :: proc()
{
    g := GImGui;
    assert(!g.Initialized && !g.SettingsLoaded);

    // Add .ini handle for ImGuiWindow and ImGuiTable types
    {
        ini_handler : ImGuiSettingsHandler
        ini_handler.TypeName = "Window";
        ini_handler.TypeHash = ImHashStr("Window");
        ini_handler.ClearAllFn = WindowSettingsHandler_ClearAll;
        ini_handler.ReadOpenFn = WindowSettingsHandler_ReadOpen;
        ini_handler.ReadLineFn = WindowSettingsHandler_ReadLine;
        ini_handler.ApplyAllFn = WindowSettingsHandler_ApplyAll;
        ini_handler.WriteAllFn = WindowSettingsHandler_WriteAll;
        AddSettingsHandler(&ini_handler);
    }
    TableSettingsAddSettingsHandler();

    // Setup default localization table
    LocalizeRegisterEntries(GLocalizationEntriesEnUS, len(GLocalizationEntriesEnUS));

    // Setup default ImGuiPlatformIO clipboard/IME handlers.
    g.PlatformIO.Platform_GetClipboardTextFn = Platform_GetClipboardTextFn_DefaultImpl;    // Platform dependent default implementations
    g.PlatformIO.Platform_SetClipboardTextFn = Platform_SetClipboardTextFn_DefaultImpl;
    g.PlatformIO.Platform_OpenInShellFn = Platform_OpenInShellFn_DefaultImpl;
    g.PlatformIO.Platform_SetImeDataFn = Platform_SetImeDataFn_DefaultImpl;

    // Create default viewport
    viewport := IM_NEW(ImGuiViewportP)
    init_ImGuiViewportP(viewport)
    viewport.ID = IMGUI_VIEWPORT_DEFAULT_ID;
    viewport.Idx = 0;
    viewport.PlatformWindowCreated = true;
    viewport.Flags = {.OwnedByApp};
    append(&g.Viewports, viewport);
    resize(&g.TempBuffer, 1024 * 3 + 1, 0);
    g.ViewportCreatedCount += 1;
    append(&g.PlatformIO.Viewports, g.Viewports[0]);

    // Build KeysMayBeCharInput[] lookup table (1 bool per named key)
    for key := ImGuiKey.NamedKey_BEGIN; key < ImGuiKey.NamedKey_END; key = (ImGuiKey)(key + 1) {
        if ((key >= ImGuiKey._0 && key <= ImGuiKey._9) || (key >= ImGuiKey.A && key <= ImGuiKey.Z) || (key >= ImGuiKey.Keypad0 && key <= ImGuiKey.Keypad9) \
            || key == ImGuiKey.Tab || key == ImGuiKey.Space || key == ImGuiKey.Apostrophe || key == ImGuiKey.Comma || key == ImGuiKey.Minus || key == ImGuiKey.Period \
            || key == ImGuiKey.Slash || key == ImGuiKey.Semicolon || key == ImGuiKey.Equal || key == ImGuiKey.LeftBracket || key == ImGuiKey.RightBracket || key == ImGuiKey.GraveAccent \
            || key == ImGuiKey.KeypadDecimal || key == ImGuiKey.KeypadDivide || key == ImGuiKey.KeypadMultiply || key == ImGuiKey.KeypadSubtract || key == ImGuiKey.KeypadAdd || key == ImGuiKey.KeypadEqual) {
            SetBit(&g.KeysMayBeCharInput, key);
        }
    }

when IMGUI_HAS_DOCK {
    // Initialize Docking
    DockContextInitialize(g);
}

    g.Initialized = true;
}

// This function is merely here to free heap allocations.
// [forward declared comment]:
// Since 1.60 this is a _private_ function. You can call DestroyContext() to destroy the context created by CreateContext().
Shutdown :: proc()
{
    g := GImGui;
    IM_ASSERT_USER_ERROR(g.IO.BackendPlatformUserData == nil, "Forgot to shutdown Platform backend?");
    IM_ASSERT_USER_ERROR(g.IO.BackendRendererUserData == nil, "Forgot to shutdown Renderer backend?");

    // The fonts atlas can be used prior to calling NewFrame(), so we clear it even if g.Initialized is FALSE (which would happen if we never called NewFrame)
    if (g.IO.Fonts != nil && g.FontAtlasOwnedByContext)
    {
        g.IO.Fonts.Locked = false;
        IM_DELETE(g.IO.Fonts);
    }
    g.IO.Fonts = nil;
    clear(&g.DrawListSharedData.TempBuffer)

    // Cleanup of other data are conditional on actually having initialized Dear ImGui.
    if (!g.Initialized)   do return

    // Save settings (unless we haven't attempted to load them: CreateContext/DestroyContext without a call to NewFrame shouldn't save an empty file)
    if (g.SettingsLoaded && g.IO.IniFilename != "") {
        SaveIniSettingsToDisk(g.IO.IniFilename);
    }

    // Destroy platform windows
    DestroyPlatformWindows();

    // Shutdown extensions
    DockContextShutdown(g);

    CallContextHooks(g, .Shutdown);

    // Clear everything else
    clear_delete(&g.Windows);
    clear(&g.WindowsFocusOrder);
    clear(&g.WindowsTempSortBuffer);
    g.CurrentWindow = nil;
    clear(&g.CurrentWindowStack);
    clear(&g.WindowsById);
    g.NavWindow = nil;
    g.HoveredWindow = nil
    g.HoveredWindowUnderMovingWindow = nil;
    g.ActiveIdWindow = nil
    g.ActiveIdPreviousFrameWindow = nil;
    g.MovingWindow = nil;

    clear(&g.KeysRoutingTable);

    clear(&g.ColorStack);
    clear(&g.StyleVarStack);
    clear(&g.FontStack);
    clear(&g.OpenPopupStack);
    clear(&g.BeginPopupStack);
    clear(&g.TreeNodeStack);

    g.CurrentViewport = nil
    g.MouseViewport = nil
    g.MouseLastHoveredViewport = nil;
    clear_delete(&g.Viewports);

    clear(&g.TabBars);
    clear(&g.CurrentTabBarStack);
    clear(&g.ShrinkWidthBuffer);

    clear_destruct(&g.ClipperTempData);

    clear(&g.Tables);
    clear_destruct(&g.TablesTempData);
    clear(&g.DrawChannelsTempMergeBuffer);

    clear(&g.MultiSelectStorage);
    clear_destruct(&g.MultiSelectTempData);

    clear(&g.ClipboardHandlerData);
    clear(&g.MenusIdSubmittedThisFrame);
    _ClearFreeMemory(&g.InputTextState);
    _ClearFreeMemory(&g.InputTextDeactivatedState);

    clear(&g.SettingsWindows);
    clear(&g.SettingsHandlers);

    if (g.LogFile != {})
    {
when !(IMGUI_DISABLE_TTY_FUNCTIONS) {
        if (g.LogFile != stdout)  {
            ImFileClose(g.LogFile);
        }
}
else {
        ImFileClose(g.LogFile);
}
        g.LogFile = {};
    }
    clear(&g.LogBuffer);
    clear(&g.DebugLogBuf);
    clear(&g.DebugLogIndex);

    g.Initialized = false;
}

// No specific ordering/dependency support, will see as needed
AddContextHook :: proc(ctx : ^ImGuiContext, hook : ^ImGuiContextHook) -> ImGuiID
{
    g := ctx;
    assert(hook.Callback != nil && hook.HookId == 0 && hook.Type != ImGuiContextHookType.PendingRemoval_);
    append(&g.Hooks, hook^);
    g.HookIdNext += 1;
    back(g.Hooks).HookId = g.HookIdNext;
    return g.HookIdNext;
}

// Deferred removal, avoiding issue with changing vector while iterating it
RemoveContextHook :: proc(ctx : ^ImGuiContext, hook_id : ImGuiID)
{
    g := ctx;
    assert(hook_id != 0);
    for &hook in g.Hooks {
        if (hook.HookId == hook_id) {
            hook.Type = ImGuiContextHookType.PendingRemoval_;
        }
    }
}

// Call context hooks (used by e.g. test engine)
// We assume a small number of hooks so all stored in same array
CallContextHooks :: proc(ctx : ^ImGuiContext, hook_type : ImGuiContextHookType)
{
    g := ctx;
    for &hook in g.Hooks {
        if (hook.Type == hook_type)   do hook.Callback(g, &hook)
    }
}

//-----------------------------------------------------------------------------
// [SECTION] MAIN CODE (most of the code! lots of stuff, needs tidying up!)
//-----------------------------------------------------------------------------

// ImGuiWindow is mostly a dumb struct. It merely has a constructor and a few helper methods
init_ImGuiWindow :: proc(this : ^ImGuiWindow, ctx : ^ImGuiContext, name : string)
{
    this^ = {};
    init_ImDrawList(&this.DrawListInst, nil)
    this.Ctx = ctx;
    this.Name = ImStrdup_str(name);
    this.ID = ImHashStr(name);
    append(&this.IDStack, this.ID);
    this.ViewportAllowPlatformMonitorExtend = -1;
    this.ViewportPos = ImVec2{math.F32_MAX, math.F32_MAX};
    this.MoveId = GetID("#MOVE");
    this.TabId = GetID("#TAB");
    this.ScrollTarget = ImVec2{math.F32_MAX, math.F32_MAX};
    this.ScrollTargetCenterRatio = ImVec2{0.5, 0.5};
    this.AutoFitFramesX = -1
    this.AutoFitFramesY = -1;
    this.AutoPosLastDirection = nil;
    this.SetWindowPosAllowFlags = nil
    this.SetWindowSizeAllowFlags = nil
    this.SetWindowCollapsedAllowFlags = nil
    this.SetWindowDockAllowFlags = nil;
    this.SetWindowPosPivot = ImVec2{math.F32_MAX, math.F32_MAX};
    this.SetWindowPosVal =  this.SetWindowPosPivot
    this.LastFrameActive = -1;
    this.LastFrameJustFocused = -1;
    this.LastTimeActive = -1.0;
    this.FontWindowScale = 1
    this.FontDpiScale = 1.0;
    this.SettingsOffset = -1;
    this.DockOrder = -1;
    this.DrawList = &this.DrawListInst;
    this.DrawList._OwnerName = this.Name;
    this.DrawList._Data = &this.Ctx.DrawListSharedData;
    this.NavPreferredScoringPosRel[.Menu] = ImVec2{math.F32_MAX, math.F32_MAX};
    this.NavPreferredScoringPosRel[.Main] = this.NavPreferredScoringPosRel[.Menu]
    __inplace_constructors(&this.WindowClass);
}

deinit_ImGuiWindow :: proc(this : ^ImGuiWindow)
{
    assert(this.DrawList == &this.DrawListInst);
    IM_DELETE(raw_data(this.Name));
    clear_destruct(&this.ColumnsStorage);
}

SetCurrentWindow :: proc(window : ^ImGuiWindow)
{
    g := GImGui;
    g.CurrentWindow = window;
    g.StackSizesInBeginForCurrentWindow = g.CurrentWindow != nil ? &back(g.CurrentWindowStack).StackSizesInBegin : nil;
    g.CurrentTable = window != nil && window.DC.CurrentTableIdx != -1 ? GetByIndex(&g.Tables, window.DC.CurrentTableIdx) : nil;
    if (window != nil)
    {
        g.DrawListSharedData.FontSize = CalcFontSize(window);
        g.FontSize = g.DrawListSharedData.FontSize 
        g.DrawListSharedData.FontScale = g.FontSize / g.Font.FontSize;
        g.FontScale = g.DrawListSharedData.FontScale 
        NavUpdateCurrentWindowIsScrollPushableX();
    }
}

GcCompactTransientMiscBuffers :: proc()
{
    g := GImGui;
    clear(&g.ItemFlagsStack);
    clear(&g.GroupStack);
    g.MultiSelectTempDataStacked = 0;
    g.MultiSelectTempData.clear_destruct();
    TableGcCompactSettings();
}

// Free up/compact internal window buffers, we can use this when a window becomes unused.
// Not freed:
// - ImGuiWindow, ImGuiWindowSettings, Name, StateStorage, ColumnsStorage (may hold useful data)
// This should have no noticeable visual effect. When the window reappear however, expect new allocation/buffer growth/copy cost.
GcCompactTransientWindowBuffers :: proc(window : ^ImGuiWindow)
{
    window.MemoryCompacted = true;
    window.MemoryDrawListIdxCapacity = cast(i32) cap(window.DrawList.IdxBuffer);
    window.MemoryDrawListVtxCapacity = cast(i32) cap(window.DrawList.VtxBuffer);
    clear(&window.IDStack)
    _ClearFreeMemory(window.DrawList);
    clear(&window.DC.ChildWindows);
    clear(&window.DC.ItemWidthStack);
    clear(&window.DC.TextWrapPosStack);
}

GcAwakeTransientWindowBuffers :: proc(window : ^ImGuiWindow)
{
    // We stored capacity of the ImDrawList buffer to reduce growth-caused allocation/copy when awakening.
    // The other buffers tends to amortize much faster.
    window.MemoryCompacted = false;
    reserve(&window.DrawList.IdxBuffer, window.MemoryDrawListIdxCapacity);
    reserve(&window.DrawList.VtxBuffer, window.MemoryDrawListVtxCapacity);
    window.MemoryDrawListVtxCapacity = 0;
    window.MemoryDrawListIdxCapacity = 0
}

SetActiveID :: proc(id : ImGuiID, window : ^ImGuiWindow)
{
    g := GImGui;

    // Clear previous active id
    if (g.ActiveId != 0)
    {
        // While most behaved code would make an effort to not steal active id during window move/drag operations,
        // we at least need to be resilient to it. Canceling the move is rather aggressive and users of 'master' branch
        // may prefer the weird ill-defined half working situation ('docking' did assert), so may need to rework that.
        if (g.MovingWindow != nil && g.ActiveId == g.MovingWindow.MoveId)
        {
            IMGUI_DEBUG_LOG_ACTIVEID(g, "SetActiveID() cancel MovingWindow\n");
            g.MovingWindow = nil;
        }

        // This could be written in a more general way (e.g associate a hook to ActiveId),
        // but since this is currently quite an exception we'll leave it as is.
        // One common scenario leading to this is: pressing Key ->NavMoveRequestApplyResult() -> ClearActiveID()
        if (g.InputTextState.ID == g.ActiveId) {
            InputTextDeactivateHook(g.ActiveId);
        }
    }

    // Set active id
    g.ActiveIdIsJustActivated = (g.ActiveId != id);
    if (g.ActiveIdIsJustActivated)
    {
        IMGUI_DEBUG_LOG_ACTIVEID(g, "SetActiveID() old:0x%08X (window \"%s\") -> new:0x%08X (window \"%s\")\n", g.ActiveId, g.ActiveIdWindow != nil ? g.ActiveIdWindow.Name : "", id, window != nil ? window.Name : "");
        g.ActiveIdTimer = 0.0;
        g.ActiveIdHasBeenPressedBefore = false;
        g.ActiveIdHasBeenEditedBefore = false;
        g.ActiveIdMouseButton = -1;
        if (id != 0)
        {
            g.LastActiveId = id;
            g.LastActiveIdTimer = 0.0;
        }
    }
    g.ActiveId = id;
    g.ActiveIdAllowOverlap = false;
    g.ActiveIdNoClearOnFocusLoss = false;
    g.ActiveIdWindow = window;
    g.ActiveIdHasBeenEditedThisFrame = false;
    g.ActiveIdFromShortcut = false;
    if (id != 0)
    {
        g.ActiveIdIsAlive = id;
        g.ActiveIdSource = (g.NavActivateId == id || g.NavJustMovedToId == id) ? g.NavInputSource : .Mouse;
        assert(g.ActiveIdSource != nil);
    }

    // Clear declaration of inputs claimed by the widget
    // (Please note that this is WIP and not all keys/inputs are thoroughly declared by all widgets yet)
    g.ActiveIdUsingNavDirMask = 0x00;
    g.ActiveIdUsingAllKeyboardKeys = false;
}

ClearActiveID :: proc()
{
    SetActiveID(0, nil); // g.ActiveId = 0;
}

SetHoveredID :: proc(id : ImGuiID)
{
    g := GImGui;
    g.HoveredId = id;
    g.HoveredIdAllowOverlap = false;
    if (id != 0 && g.HoveredIdPreviousFrame != id) {
        g.HoveredIdTimer = 0
        g.HoveredIdNotActiveTimer = 0.0;
    }
}

GetHoveredID :: proc() -> ImGuiID
{
    g := GImGui;
    return g.HoveredId != {} ? g.HoveredId : g.HoveredIdPreviousFrame;
}

// [forward declared comment]:
// Mark data associated to given item as "edited", used by IsItemDeactivatedAfterEdit() function.
MarkItemEdited :: proc(id : ImGuiID)
{
    // This marking is to be able to provide info for IsItemDeactivatedAfterEdit().
    // ActiveId might have been released by the time we call this (as in the typical press/release button behavior) but still need to fill the data.
    g := GImGui;
    if (g.LastItemData.ItemFlags & transmute(ImGuiItemFlags) ImGuiItemFlagsPrivate.NoMarkEdited != nil)   do return
    if (g.ActiveId == id || g.ActiveId == 0)
    {
        g.ActiveIdHasBeenEditedThisFrame = true;
        g.ActiveIdHasBeenEditedBefore = true;
    }

    // We accept a MarkItemEdited() on drag and drop targets (see https://github.com/ocornut/imgui/issues/1875#issuecomment-978243343)
    // We accept 'ActiveIdPreviousFrame == id' for InputText() returning an edit after it has been taken ActiveId away (#4714)
    assert(g.DragDropActive || g.ActiveId == id || g.ActiveId == 0 || g.ActiveIdPreviousFrame == id || (g.CurrentMultiSelect != nil && g.BoxSelectState.IsActive));

    //assert(g.CurrentWindow.DC.LastItemId == id);
    g.LastItemData.StatusFlags |= ImGuiItemStatusFlags{.Edited};
}

IsWindowContentHoverable :: proc(window : ^ImGuiWindow, flags : ImGuiHoveredFlags = {}) -> bool
{
    // An active popup disable hovering on other windows (apart from its own children)
    // FIXME-OPT: This could be cached/stored within the window.
    g := GImGui;
    if (g.NavWindow != nil) {
        if focused_root_window := g.NavWindow.RootWindowDockTree; focused_root_window != nil {
            if (focused_root_window.WasActive && focused_root_window != window.RootWindowDockTree)
            {
                // For the purpose of those flags we differentiate "standard popup" from "modal popup"
                // NB: The 'else' is important because Modal windows are also Popups.
                want_inhibit := false;
                if (.Modal in focused_root_window.Flags)   do want_inhibit = true
                else if ((.Popup in focused_root_window.Flags) && !(.AllowWhenBlockedByPopup in flags))   do want_inhibit = true

                // Inhibit hover unless the window is within the stack of our modal/popup
                if (want_inhibit) {
                    if (!IsWindowWithinBeginStackOf(window.RootWindow, focused_root_window))   do return false
                }
            }
        }
    }

    // Filter by viewport
    if (window.Viewport != g.MouseViewport) {
        if (g.MovingWindow == nil || window.RootWindowDockTree != g.MovingWindow.RootWindowDockTree)   do return false
    }

    return true;
}

CalcDelayFromHoveredFlags :: #force_inline proc(flags :ImGuiHoveredFlags) -> f32
{
    g := GImGui;
    if (.DelayNormal in flags)   do return g.Style.HoverDelayNormal
    if (.DelayShort in flags)   do return g.Style.HoverDelayShort
    return 0.0;
}

ApplyHoverFlagsForTooltip :: proc(user_flags : ImGuiHoveredFlags, shared_flags : ImGuiHoveredFlags) -> ImGuiHoveredFlags
{
    shared_flags := shared_flags
    // Allow instance flags to override shared flags
    if (user_flags & ImGuiHoveredFlags{ .DelayNone, .DelayShort, .DelayNormal} != nil) {
        shared_flags &= ~{.DelayNone, .DelayShort, .DelayNormal};
    }
    return user_flags | shared_flags;
}

// This is roughly matching the behavior of internal-facing ItemHoverable()
// - we allow hovering to be true when ActiveId==window.MoveID, so that clicking on non-interactive items such as a Text() item still returns true with IsItemHovered()
// - this should work even for non-interactive items that have no ID, so we cannot use LastItemId
// [forward declared comment]:
// is the last item hovered? (and usable, aka not blocked by a popup, etc.). See ImGuiHoveredFlags for more options.
IsItemHovered :: proc(flags : ImGuiHoveredFlags = {}) -> bool
{
    flags := flags
    g := GImGui;
    window := g.CurrentWindow;
    IM_ASSERT_USER_ERROR((flags & ~transmute(ImGuiHoveredFlags)ImGuiHoveredFlagsPrivate.AllowedMaskForIsItemHovered) == nil, "Invalid flags for IsItemHovered()!");

    if (g.NavHighlightItemUnderNav && g.NavCursorVisible && !(.NoNavOverride in flags))
    {
        if (!IsItemFocused())   do return false
        if ((g.LastItemData.ItemFlags & transmute(ImGuiItemFlags) ImGuiItemFlagsPrivate.Disabled != nil) && !(.AllowWhenDisabled in flags))   do return false

        if (.ForTooltip in flags) {
            flags = ApplyHoverFlagsForTooltip(flags, g.Style.HoverFlagsForTooltipNav);
        }
    }
    else
    {
        // Test for bounding box overlap, as updated as ItemAdd()
        status_flags := g.LastItemData.StatusFlags;
        if (!(.HoveredRect in status_flags))   do return false

        if (.ForTooltip in flags) {
            flags = ApplyHoverFlagsForTooltip(flags, g.Style.HoverFlagsForTooltipMouse);
        }

        // Done with rectangle culling so we can perform heavier checks now
        // Test if we are hovering the right window (our window could be behind another window)
        // [2021/03/02] Reworked / reverted the revert, finally. Note we want e.g. BeginGroup/ItemAdd/EndGroup to work as well. (#3851)
        // [2017/10/16] Reverted commit 344d48be3 and testing RootWindow instead. I believe it is correct to NOT test for RootWindow but this leaves us unable
        // to use IsItemHovered() after EndChild() itself. Until a solution is found I believe reverting to the test from 2017/09/27 is safe since this was
        // the test that has been running for a long while.
        if (g.HoveredWindow != window && (.HoveredWindow not_in status_flags)) {
            if ((.AllowWhenOverlappedByWindow not_in flags))   do return false
        }

        // Test if another item is active (e.g. being dragged)
        id := g.LastItemData.ID;
        if ((.AllowWhenBlockedByActiveItem not_in flags)) {
            if (g.ActiveId != 0 && g.ActiveId != id && !g.ActiveIdAllowOverlap) {
                if (g.ActiveId != window.MoveId && g.ActiveId != window.TabId)   do return false
            }
        }

        // Test if interactions on this window are blocked by an active popup or modal.
        // The ImGuiHoveredFlags_AllowWhenBlockedByPopup flag will be tested here.
        if (!IsWindowContentHoverable(window, flags) && !(g.LastItemData.ItemFlags & transmute(ImGuiItemFlags) ImGuiItemFlagsPrivate.NoWindowHoverableCheck != nil))   do return false

        // Test if the item is disabled
        if ((g.LastItemData.ItemFlags & transmute(ImGuiItemFlags) ImGuiItemFlagsPrivate.Disabled != nil) && !(.AllowWhenDisabled in flags))   do return false

        // Special handling for calling after Begin() which represent the title bar or tab.
        // When the window is skipped/collapsed (SkipItems==true) that last item (always ->MoveId submitted by Begin)
        // will never be overwritten so we need to detect the case.
        if (id == window.MoveId && window.WriteAccessed)   do return false

        // Test if using AllowOverlap and overlapped
        if ((g.LastItemData.ItemFlags & transmute(ImGuiItemFlags) ImGuiItemFlagsPrivate.AllowOverlap != nil) && id != 0) {
            if ((.AllowWhenOverlappedByItem not_in flags)) {
                if (g.HoveredIdPreviousFrame != g.LastItemData.ID)   do return false
            }
        }
    }

    // Handle hover delay
    // (some ideas: https://www.nngroup.com/articles/timing-exposing-content)
    delay := CalcDelayFromHoveredFlags(flags);
    if (delay > 0.0 || (.Stationary in flags))
    {
        hover_delay_id := (g.LastItemData.ID != 0) ? g.LastItemData.ID : GetIDFromPos(window, g.LastItemData.Rect.Min);
        if ((.NoSharedDelay in flags) && (g.HoverItemDelayIdPreviousFrame != hover_delay_id)) {
            g.HoverItemDelayTimer = 0.0;
        }
        g.HoverItemDelayId = hover_delay_id;

        // When changing hovered item we requires a bit of stationary delay before activating hover timer,
        // but once unlocked on a given item we also moving.
        //if (g.HoverDelayTimer >= delay && (g.HoverDelayTimer - g.IO.DeltaTime < delay || g.MouseStationaryTimer - g.IO.DeltaTime < g.Style.HoverStationaryDelay)) { IMGUI_DEBUG_LOG("HoverDelayTimer = %f/%f, MouseStationaryTimer = %f\n", g.HoverDelayTimer, delay, g.MouseStationaryTimer); }
        if ((.Stationary in flags) && g.HoverItemUnlockedStationaryId != hover_delay_id)   do return false

        if (g.HoverItemDelayTimer < delay)   do return false
    }

    return true;
}

// Internal facing ItemHoverable() used when submitting widgets. Differs slightly from IsItemHovered().
// (this does not rely on LastItemData it can be called from a ButtonBehavior() call not following an ItemAdd() call)
// FIXME-LEGACY: the 'ImGuiItemFlags item_flags' parameter was added on 2023-06-28.
// If you used this in your legacy/custom widgets code:
// - Commonly: if your ItemHoverable() call comes after an ItemAdd() call: pass 'item_flags = g.LastItemData.ItemFlags'.
// - Rare: otherwise you may pass 'item_flags = 0' (ImGuiItemFlags_None) unless you want to benefit from special behavior handled by ItemHoverable.
ItemHoverable :: proc(bb : ImRect, id : ImGuiID, item_flags : ImGuiItemFlags) -> bool
{
    g := GImGui;
    window := g.CurrentWindow;

    // Detect ID conflicts
when !(IMGUI_DISABLE_DEBUG_TOOLS) {
    if (id != 0 && g.HoveredIdPreviousFrame == id && (.AllowDuplicateId not_in item_flags))
    {
        g.HoveredIdPreviousFrameItemCount += 1;
        if (g.DebugDrawIdConflicts == id) {
            AddRect(window.DrawList, bb.Min - ImVec2{1,1}, bb.Max + ImVec2{1,1}, IM_COL32(255, 0, 0, 255), 0.0, nil, 2.0);
        }
    }
}

    if (g.HoveredWindow != window)   do return false
    if (!IsMouseHoveringRect(bb.Min, bb.Max))   do return false

    if (g.HoveredId != 0 && g.HoveredId != id && !g.HoveredIdAllowOverlap)   do return false
    if (g.ActiveId != 0 && g.ActiveId != id && !g.ActiveIdAllowOverlap) {
        if (!g.ActiveIdFromShortcut)   do return false
    }

    // Done with rectangle culling so we can perform heavier checks now.
    if (!(item_flags & transmute(ImGuiItemFlags) ImGuiItemFlagsPrivate.NoWindowHoverableCheck != nil) && !IsWindowContentHoverable(window, nil))
    {
        g.HoveredIdIsDisabled = true;
        return false;
    }

    // We exceptionally allow this function to be called with id==0 to allow using it for easy high-level
    // hover test in widgets code. We could also decide to split this function is two.
    if (id != 0)
    {
        // Drag source doesn't report as hovered
        if (g.DragDropActive && g.DragDropPayload.SourceId == id && !(.SourceNoDisableHover in g.DragDropSourceFlags))   do return false

        SetHoveredID(id);

        // AllowOverlap mode (rarely used) requires previous frame HoveredId to be null or to match.
        // This allows using patterns where a later submitted widget overlaps a previous one. Generally perceived as a front-to-back hit-test.
        if (item_flags & transmute(ImGuiItemFlags) ImGuiItemFlagsPrivate.AllowOverlap != nil)
        {
            g.HoveredIdAllowOverlap = true;
            if (g.HoveredIdPreviousFrame != id)   do return false
        }

        // Display shortcut (only works with mouse)
        // (ImGuiItemStatusFlags_HasShortcut in LastItemData denotes we want a tooltip)
        if (id == g.LastItemData.ID && (.HasShortcut in g.LastItemData.StatusFlags) && g.ActiveId != id) {
            if (IsItemHovered({.ForTooltip, .DelayNormal})) {
                SetTooltip("%s", GetKeyChordName(g.LastItemData.Shortcut));
            }
        }
    }

    // When disabled we'll return false but still set HoveredId
    if (item_flags & transmute(ImGuiItemFlags) ImGuiItemFlagsPrivate.Disabled != nil)
    {
        // Release active id if turning disabled
        if (g.ActiveId == id && id != 0)   do ClearActiveID()
        g.HoveredIdIsDisabled = true;
        return false;
    }

when !(IMGUI_DISABLE_DEBUG_TOOLS) {
    if (id != 0)
    {
        // [DEBUG] Item Picker tool!
        // We perform the check here because reaching is path is rare (1~ time a frame),
        // making the cost of this tool near-zero! We could get better call-stack and support picking non-hovered
        // items if we performed the test in ItemAdd(), but that would incur a bigger runtime cost.
        if (g.DebugItemPickerActive && g.HoveredIdPreviousFrame == id) {
            AddRect(GetForegroundDrawList(), bb.Min, bb.Max, IM_COL32(255, 255, 0, 255));
        }
        if (g.DebugItemPickerBreakId == id)   do runtime.debug_trap()
    }
}

    if (g.NavHighlightItemUnderNav && (item_flags & transmute(ImGuiItemFlags) ImGuiItemFlagsPrivate.NoNavDisableMouseHover == nil))   do return false

    return true;
}

// FIXME: This is inlined/duplicated in ItemAdd()
// FIXME: The id != 0 path is not used by our codebase, may get rid of it?
IsClippedEx :: proc(bb : ImRect, id : ImGuiID) -> bool
{
    g := GImGui;
    window := g.CurrentWindow;
    if (!Overlaps(bb, window.ClipRect)) {
        if (id == 0 || (id != g.ActiveId && id != g.ActiveIdPreviousFrame && id != g.NavId && id != g.NavActivateId)) {
            if (!g.ItemUnclipByLog)   do return true
        }
    }
    return false;
}

// This is also inlined in ItemAdd()
// Note: if ImGuiItemStatusFlags_HasDisplayRect is set, user needs to set g.LastItemData.DisplayRect.
SetLastItemData :: proc(item_id : ImGuiID, in_flags : ImGuiItemFlags, item_flags : ImGuiItemStatusFlags, item_rect : ImRect)
{
    g := GImGui;
    g.LastItemData.ID = item_id;
    g.LastItemData.ItemFlags = in_flags;
    g.LastItemData.StatusFlags = item_flags;
    g.LastItemData.NavRect = item_rect;
    g.LastItemData.Rect = item_rect;
}

CalcWrapWidthForPos :: proc(pos : ImVec2, wrap_pos_x : f32) -> f32
{
    if (wrap_pos_x < 0.0)   do return 0.0

    wrap_pos_x := wrap_pos_x

    g := GImGui;
    window := g.CurrentWindow;
    if (wrap_pos_x == 0.0)
    {
        // We could decide to setup a default wrapping max point for auto-resizing windows,
        // or have auto-wrap (with unspecified wrapping pos) behave as a ContentSize extending function?
        //if (window.Hidden && (window.Flags & ImGuiWindowFlags_AlwaysAutoResize))
        //    wrap_pos_x = ImMax(window.WorkRect.Min.x + g.FontSize * 10.0f, window.WorkRect.Max.x);
        //else
        wrap_pos_x = window.WorkRect.Max.x;
    }
else if (wrap_pos_x > 0.0)    
    {
        wrap_pos_x += window.Pos.x - window.Scroll.x; // wrap_pos_x is provided is window local space
    }

    return ImMax(wrap_pos_x - pos.x, 1.0);
}

// IM_ALLOC() == ImGui::MemAlloc()
MemAlloc :: proc(size : int) -> rawptr
{
    ptr := GImAllocatorAllocFunc(size, GImAllocatorUserData);
when !(IMGUI_DISABLE_DEBUG_TOOLS) {
    if ctx := GImGui; ctx != nil {
        DebugAllocHook(&ctx.DebugAllocInfo, ctx.FrameCount, ptr, size);
    }
}
    return ptr;
}

// IM_FREE() == ImGui::MemFree()
MemFree :: proc(ptr : rawptr)
{
when !(IMGUI_DISABLE_DEBUG_TOOLS) {
    if (ptr != nil) {
        if ctx := GImGui; ctx != nil {
            DebugAllocHook(&ctx.DebugAllocInfo, ctx.FrameCount, ptr, -1);
        }
    }
}
    GImAllocatorFreeFunc(ptr, GImAllocatorUserData);
}

// We record the number of allocation in recent frames, as a way to audit/sanitize our guiding principles of "no allocations on idle/repeating frames"
// [forward declared comment]:
// size >= 0 : alloc, size = -1 : free
DebugAllocHook :: proc(info : ^ImGuiDebugAllocInfo, frame_count : i32, ptr : rawptr, size : int)
{
    entry := &info.LastEntriesBuf[info.LastEntriesIdx];
    _ = ptr
    if (entry.FrameCount != frame_count)
    {
        info.LastEntriesIdx = (info.LastEntriesIdx + 1) % len(info.LastEntriesBuf);
        entry = &info.LastEntriesBuf[info.LastEntriesIdx];
        entry.FrameCount = frame_count;
        entry.FreeCount = 0;
        entry.AllocCount = 0
    }
    if (size != -1)
    {
        //printf("[%05d] MemAlloc(%d) -> 0x%p\n", frame_count, cast(int) size, ptr);
        entry.AllocCount += 1;
        info.TotalAllocCount += 1;
    }
    else
    {
        //printf("[%05d] MemFree(0x%p)\n", frame_count, ptr);
        entry.FreeCount += 1;
        info.TotalFreeCount += 1;
    }
}

GetClipboardText :: proc() -> [^]u8
{
    g := GImGui;
    return g.PlatformIO.Platform_GetClipboardTextFn ? g.PlatformIO.Platform_GetClipboardTextFn(g) : "";
}

SetClipboardText :: proc(text : ^u8)
{
    g := GImGui;
    if (g.PlatformIO.Platform_SetClipboardTextFn != nil) {
        g.PlatformIO.Platform_SetClipboardTextFn(g, text);
    }
}

// [forward declared comment]:
// get the compiled version string e.g. "1.80 WIP" (essentially the value for IMGUI_VERSION from the compiled version of imgui.cpp)
GetVersion :: proc() -> string
{
    return IMGUI_VERSION;
}

GetIO :: proc() -> ^ImGuiIO
{
    assert(GImGui != nil, "No current context. Did you call CreateContext() and SetCurrentContext() ?");
    return &GImGui.IO;
}

// This variant exists to facilitate backends experimenting with multi-threaded parallel context. (#8069, #6293, #5856)
GetIOEx :: proc(ctx : ^ImGuiContext) -> ^ImGuiIO
{
    assert(ctx != nil);
    return &ctx.IO;
}

GetPlatformIO :: proc() -> ^ImGuiPlatformIO
{
    assert(GImGui != nil, "No current context. Did you call CreateContext() and SetCurrentContext()?");
    return &GImGui.PlatformIO;
}

// This variant exists to facilitate backends experimenting with multi-threaded parallel context. (#8069, #6293, #5856)
GetPlatformIOEx :: proc(ctx : ^ImGuiContext) -> ^ImGuiPlatformIO
{
    assert(ctx != nil);
    return &ctx.PlatformIO;
}

// Pass this to your backend rendering function! Valid after Render() and until the next call to NewFrame()
// [forward declared comment]:
// valid after Render() and until the next call to NewFrame(). this is what you have to render.
GetDrawData :: proc() -> ^ImDrawData
{
    g := GImGui;
    viewport := g.Viewports[0];
    return viewport.DrawDataP.Valid ? &viewport.DrawDataP : nil;
}

// [forward declared comment]:
// get global imgui time. incremented by io.DeltaTime every frame.
GetTime :: proc() -> f64
{
    return GImGui.Time;
}

// [forward declared comment]:
// get global imgui frame count. incremented by 1 every frame.
GetFrameCount :: proc() -> i32
{
    return GImGui.FrameCount;
}

GetViewportBgFgDrawList :: proc(viewport : ^ImGuiViewportP, drawlist_no : int, drawlist_name : string) -> ^ImDrawList
{
    // Create the draw list on demand, because they are not frequently used for all viewports
    g := GImGui;
    assert(drawlist_no < len(viewport.BgFgDrawLists));
    draw_list := viewport.BgFgDrawLists[drawlist_no];
    if (draw_list == nil)
    {
        draw_list = IM_NEW(ImDrawList)
        init_ImDrawList(draw_list, &g.DrawListSharedData)
        draw_list._OwnerName = drawlist_name;
        viewport.BgFgDrawLists[drawlist_no] = draw_list;
    }

    // Our ImDrawList system requires that there is always a command
    if (viewport.BgFgDrawListsLastFrame[drawlist_no] != g.FrameCount)
    {
        _ResetForNewFrame(draw_list);
        PushTextureID(draw_list, g.IO.Fonts.TexID);
        PushClipRect(draw_list, viewport.Pos, viewport.Pos + viewport.Size, false);
        viewport.BgFgDrawListsLastFrame[drawlist_no] = g.FrameCount;
    }
    return draw_list;
}

// [forward declared comment]:
// get background draw list for the given viewport or viewport associated to the current window. this draw list will be the first rendering one. Useful to quickly draw shapes/text behind dear imgui contents.
GetBackgroundDrawList :: proc(viewport : ^ImGuiViewport = nil) -> ^ImDrawList
{
    viewport := viewport
    if (viewport == nil) {
        viewport = GImGui.CurrentWindow.Viewport;
    }
    return GetViewportBgFgDrawList(cast(^ImGuiViewportP)viewport, 0, "##Background");
}

// [forward declared comment]:
// get foreground draw list for the given viewport or viewport associated to the current window. this draw list will be the top-most rendered one. Useful to quickly draw shapes/text over dear imgui contents.
ImGuiViewport_GetForegroundDrawList :: proc(viewport : ^ImGuiViewport = nil) -> ^ImDrawList
{
    viewport := viewport
    if (viewport == nil) {
        viewport = GImGui.CurrentWindow.Viewport;
    }
    return GetViewportBgFgDrawList(cast(^ImGuiViewportP)viewport, 1, "##Foreground");
}

GetForegroundDrawList :: proc{ ImGuiViewport_GetForegroundDrawList, ImGuiWindow_GetForegroundDrawList }

// [forward declared comment]:
// you may use this when creating your own ImDrawList instances.
GetDrawListSharedData :: proc() -> ^ImDrawListSharedData
{
    return &GImGui.DrawListSharedData;
}

StartMouseMovingWindow :: proc(window : ^ImGuiWindow)
{
    // Set ActiveId even if the _NoMove flag is set. Without it, dragging away from a window with _NoMove would activate hover on other windows.
    // We _also_ call this when clicking in a window empty space when io.ConfigWindowsMoveFromTitleBarOnly is set, but clear g.MovingWindow afterward.
    // This is because we want ActiveId to be set even when the window is not permitted to move.
    g := GImGui;
    FocusWindow(window);
    SetActiveID(window.MoveId, window);
    if (g.IO.ConfigNavCursorVisibleAuto) {
        g.NavCursorVisible = false;
    }
    g.ActiveIdClickOffset = g.IO.MouseClickedPos[0] - window.RootWindowDockTree.Pos;
    g.ActiveIdNoClearOnFocusLoss = true;
    SetActiveIdUsingAllKeyboardKeys();

    can_move_window := true;
    if ((.NoMove in window.Flags) || (.NoMove in window.RootWindowDockTree.Flags))   do can_move_window = false
    if node := window.DockNodeAsHost; node != nil {
        if (node.VisibleWindow != nil && (.NoMove in node.VisibleWindow.Flags))   do can_move_window = false
    }
    if (can_move_window)   do g.MovingWindow = window
}

// We use 'undock == false' when dragging from title bar to allow moving groups of floating nodes without undocking them.
StartMouseMovingWindowOrNode :: proc(window : ^ImGuiWindow, node : ^ImGuiDockNode, undock : bool)
{
    g := GImGui;
    can_undock_node := false;
    if (undock && node != nil && node.VisibleWindow != nil && (.NoMove not_in node.VisibleWindow.Flags) && (.NoUndocking not_in node.MergedFlags))
    {
        // Can undock if:
        // - part of a hierarchy with more than one visible node (if only one is visible, we'll just move the root window)
        // - part of a dockspace node hierarchy: so we can undock the last single visible node too. Undocking from a fixed/central node will create a new node and copy windows.
        root_node := DockNodeGetRootNode(node);
        if (root_node.OnlyNodeWithWindows != node || root_node.CentralNode != nil) {  // -V1051 PVS-Studio thinks node should be root_node and is wrong about that.
            can_undock_node = true;
        }
    }

    clicked := IsMouseClicked(0);
    dragging := IsMouseDragging(0);
    if (can_undock_node && dragging) {
        DockContextQueueUndockNode(g, node); // Will lead to DockNodeStartMouseMovingWindow() -> StartMouseMovingWindow() being called next frame
    }
    else if (!can_undock_node && (clicked || dragging) && g.MovingWindow != window) {
        StartMouseMovingWindow(window);
    }
}

// Handle mouse moving window
// Note: moving window with the navigation keys (Square + d-pad / CTRL+TAB + Arrows) are processed in NavUpdateWindowing()
// FIXME: We don't have strong guarantee that g.MovingWindow stay synched with g.ActiveId == g.MovingWindow.MoveId.
// This is currently enforced by the fact that BeginDragDropSource() is setting all g.ActiveIdUsingXXXX flags to inhibit navigation inputs,
// but if we should more thoroughly test cases where g.ActiveId or g.MovingWindow gets changed and not the other.
UpdateMouseMovingWindowNewFrame :: proc()
{
    g := GImGui;
    if (g.MovingWindow != nil)
    {
        // We actually want to move the root window. g.MovingWindow == window we clicked on (could be a child window).
        // We track it to preserve Focus and so that generally ActiveIdWindow == MovingWindow and ActiveId == MovingWindow.MoveId for consistency.
        KeepAliveID(g.ActiveId);
        assert(g.MovingWindow != nil && g.MovingWindow.RootWindowDockTree != nil);
        moving_window := g.MovingWindow.RootWindowDockTree;

        // When a window stop being submitted while being dragged, it may will its viewport until next Begin()
        window_disappared := (!moving_window.WasActive && !moving_window.Active);
        if (g.IO.MouseDown[0] && IsMousePosValid(&g.IO.MousePos) && !window_disappared)
        {
            pos := g.IO.MousePos - g.ActiveIdClickOffset;
            if (moving_window.Pos.x != pos.x || moving_window.Pos.y != pos.y)
            {
                SetWindowPos(moving_window, pos, { .Always });
                if (moving_window.Viewport != nil && moving_window.ViewportOwned) // Synchronize viewport immediately because some overlays may relies on clipping rectangle before we Begin() into the window.
                {
                    moving_window.Viewport.Pos = pos;
                    UpdateWorkRect(moving_window.Viewport);
                }
            }
            FocusWindow(g.MovingWindow);
        }
        else
        {
            if (!window_disappared)
            {
                // Try to merge the window back into the main viewport.
                // This works because MouseViewport should be != MovingWindow.Viewport on release (as per code in UpdateViewports)
                if (.ViewportsEnable in g.ConfigFlagsCurrFrame) {
                    UpdateTryMergeWindowIntoHostViewport(moving_window, g.MouseViewport);
                }

                // Restore the mouse viewport so that we don't hover the viewport _under_ the moved window during the frame we released the mouse button.
                if (moving_window.Viewport && !IsDragDropPayloadBeingAccepted()) {
                    g.MouseViewport = moving_window.Viewport;
                }

                // Clear the NoInput window flag set by the Viewport system
                if (moving_window.Viewport != nil) {
                    moving_window.Viewport.Flags &= ~ {.NoInputs};
                }
            }

            g.MovingWindow = nil;
            ClearActiveID();
        }
    }
    else
    {
        // When clicking/dragging from a window that has the _NoMove flag, we still set the ActiveId in order to prevent hovering others.
        if (g.ActiveIdWindow && g.ActiveIdWindow.MoveId == g.ActiveId)
        {
            KeepAliveID(g.ActiveId);
            if (!g.IO.MouseDown[0])   do ClearActiveID()
        }
    }
}

// Initiate focusing and moving window when clicking on empty space or title bar.
// Initiate focusing window when clicking on a disabled item.
// Handle left-click and right-click focus.
UpdateMouseMovingWindowEndFrame :: proc()
{
    g := GImGui;
    if (g.ActiveId != 0 || (g.HoveredId != 0 && !g.HoveredIdIsDisabled))   do return

    // Unless we just made a window/popup appear
    if (g.NavWindow && g.NavWindow.Appearing)   do return

    // Click on empty space to focus window and start moving
    // (after we're done with all our widgets, so e.g. clicking on docking tab-bar which have set HoveredId already and not get us here!)
    if (g.IO.MouseClicked[0])
    {
        // Handle the edge case of a popup being closed while clicking in its empty space.
        // If we try to focus it, FocusWindow() > ClosePopupsOverWindow() will accidentally close any parent popups because they are not linked together any more.
        root_window := g.HoveredWindow != nil ? g.HoveredWindow.RootWindow : nil;
        is_closed_popup := root_window != nil && (.Popup in root_window.Flags) && !IsPopupOpen(root_window.PopupId, {.AnyPopupLevel});

        if (root_window != nil && !is_closed_popup)
        {
            StartMouseMovingWindow(g.HoveredWindow); //-V595

            // Cancel moving if clicked outside of title bar
            if (g.IO.ConfigWindowsMoveFromTitleBarOnly) {
                if (!(.NoTitleBar in root_window.Flags) || root_window.DockIsActive) {
                    if (!Contains(TitleBarRect(root_window), g.IO.MouseClickedPos[0]))   do g.MovingWindow = nil
                }
            }

            // Cancel moving if clicked over an item which was disabled or inhibited by popups
            // (when g.HoveredIdIsDisabled == true && g.HoveredId == 0 we are inhibited by popups, when g.HoveredIdIsDisabled == true && g.HoveredId != 0 we are over a disabled item)0 already)
            if (g.HoveredIdIsDisabled)   do g.MovingWindow = nil
        }
else if (root_window == nil && g.NavWindow != nil)        
        {
            // Clicking on void disable focus
            FocusWindow(nil, {.UnlessBelowModal});
        }
    }

    // With right mouse button we close popups without changing focus based on where the mouse is aimed
    // Instead, focus will be restored to the window under the bottom-most closed popup.
    // (The left mouse button path calls FocusWindow on the hovered window, which will lead NewFrame.ClosePopupsOverWindow to trigger)
    if (g.IO.MouseClicked[1] && g.HoveredId == 0)
    {
        // Find the top-most window between HoveredWindow and the top-most Modal Window.
        // This is where we can trim the popup stack.
        modal := GetTopMostPopupModal();
        hovered_window_above_modal := g.HoveredWindow && (modal == nil || IsWindowAbove(g.HoveredWindow, modal));
        ClosePopupsOverWindow(hovered_window_above_modal ? g.HoveredWindow : modal, true);
    }
}

// This is called during NewFrame()->UpdateViewportsNewFrame() only.
// Need to keep in sync with SetWindowPos()
TranslateWindow :: proc(window : ^ImGuiWindow, delta : ImVec2)
{
    window.Pos += delta;
    Translate(&window.ClipRect, delta);
    Translate(&window.OuterRectClipped, delta);
    Translate(&window.InnerRect, delta);
    window.DC.CursorPos += delta;
    window.DC.CursorStartPos += delta;
    window.DC.CursorMaxPos += delta;
    window.DC.IdealMaxPos += delta;
}

ScaleWindow :: proc(window : ^ImGuiWindow, scale : f32)
{
    origin := window.Viewport.Pos;
    window.Pos = ImFloor((window.Pos - origin) * scale + origin);
    window.Size = ImTrunc(window.Size * scale);
    window.SizeFull = ImTrunc(window.SizeFull * scale);
    window.ContentSize = ImTrunc(window.ContentSize * scale);
}

IsWindowActiveAndVisible :: proc(window : ^ImGuiWindow) -> bool
{
    return (window.Active) && (!window.Hidden);
}

// The reason this is exposed in imgui_internal.h is: on touch-based system that don't have hovering, we want to dispatch inputs to the right target (imgui vs imgui+app)
UpdateHoveredWindowAndCaptureFlags :: proc()
{
    g := GImGui;
    io := &g.IO;

    // FIXME-DPI: This storage was added on 2021/03/31 for test engine, but if we want to multiply WINDOWS_HOVER_PADDING
    // by DpiScale, we need to make this window-agnostic anyhow, maybe need storing inside ImGuiWindow.
    g.WindowsHoverPadding = ImMax(g.Style.TouchExtraPadding, ImVec2{WINDOWS_HOVER_PADDING, WINDOWS_HOVER_PADDING});

    // Find the window hovered by mouse:
    // - Child windows can extend beyond the limit of their parent so we need to derive HoveredRootWindow from HoveredWindow.
    // - When moving a window we can skip the search, which also conveniently bypasses the fact that window.WindowRectClipped is lagging as this point of the frame.
    // - We also support the moved window toggling the NoInputs flag after moving has started in order to be able to detect windows below it, which is useful for e.g. docking mechanisms.
    clear_hovered_windows := false;
    FindHoveredWindowEx(g.IO.MousePos, false, &g.HoveredWindow, &g.HoveredWindowUnderMovingWindow);
    assert(g.HoveredWindow == nil || g.HoveredWindow == g.MovingWindow || g.HoveredWindow.Viewport == g.MouseViewport);
    g.HoveredWindowBeforeClear = g.HoveredWindow;

    // Modal windows prevents mouse from hovering behind them.
    modal_window := GetTopMostPopupModal();
    if (modal_window && g.HoveredWindow && !IsWindowWithinBeginStackOf(g.HoveredWindow.RootWindow, modal_window)) {// FIXME-MERGE: RootWindowDockTree ? 
        clear_hovered_windows = true;
    }

    // Disabled mouse hovering (we don't currently clear MousePos, we could)
    if (.NoMouse in io.ConfigFlags) {
        clear_hovered_windows = true;
    }

    // We track click ownership. When clicked outside of a window the click is owned by the application and
    // won't report hovering nor request capture even while dragging over our windows afterward.
    has_open_popup := (len(g.OpenPopupStack) > 0);
    has_open_modal := (modal_window != nil);
    mouse_earliest_down := -1;
    mouse_any_down := false;
    for i := 0; i < len(io.MouseDown); i += 1
    {
        if (io.MouseClicked[i])
        {
            io.MouseDownOwned[i] = (g.HoveredWindow != nil) || has_open_popup;
            io.MouseDownOwnedUnlessPopupClose[i] = (g.HoveredWindow != nil) || has_open_modal;
        }
        mouse_any_down |= io.MouseDown[i];
        if (io.MouseDown[i] || io.MouseReleased[i]) { // Increase release frame for our evaluation of earliest button (#1392)
            if (mouse_earliest_down == -1 || io.MouseClickedTime[i] < io.MouseClickedTime[mouse_earliest_down])   do mouse_earliest_down = i
        }
    }
    mouse_avail := (mouse_earliest_down == -1) || io.MouseDownOwned[mouse_earliest_down];
    mouse_avail_unless_popup_close := (mouse_earliest_down == -1) || io.MouseDownOwnedUnlessPopupClose[mouse_earliest_down];

    // If mouse was first clicked outside of ImGui bounds we also cancel out hovering.
    // FIXME: For patterns of drag and drop across OS windows, we may need to rework/remove this test (first committed 311c0ca9 on 2015/02)
    mouse_dragging_extern_payload := g.DragDropActive && (.SourceExtern in g.DragDropSourceFlags);
    if (!mouse_avail && !mouse_dragging_extern_payload) {
        clear_hovered_windows = true;
    }

    if (clear_hovered_windows) {
        g.HoveredWindowUnderMovingWindow = nil;
        g.HoveredWindow = nil
    }

    // Update io.WantCaptureMouse for the user application (true = dispatch mouse info to Dear ImGui only, false = dispatch mouse to Dear ImGui + underlying app)
    // Update io.WantCaptureMouseAllowPopupClose (experimental) to give a chance for app to react to popup closure with a drag
    if (g.WantCaptureMouseNextFrame != -1)
    {
        io.WantCaptureMouseUnlessPopupClose = (g.WantCaptureMouseNextFrame != 0);
        io.WantCaptureMouse = io.WantCaptureMouseUnlessPopupClose
    }
    else
    {
        io.WantCaptureMouse = (mouse_avail && (g.HoveredWindow != nil || mouse_any_down)) || has_open_popup;
        io.WantCaptureMouseUnlessPopupClose = (mouse_avail_unless_popup_close && (g.HoveredWindow != nil || mouse_any_down)) || has_open_modal;
    }

    // Update io.WantCaptureKeyboard for the user application (true = dispatch keyboard info to Dear ImGui only, false = dispatch keyboard info to Dear ImGui + underlying app)
    io.WantCaptureKeyboard = false;
    if ((.NoKeyboard not_in io.ConfigFlags))
    {
        if ((g.ActiveId != 0) || (modal_window != nil)) {
            io.WantCaptureKeyboard = true;
        }
        else if (io.NavActive && (.NavEnableKeyboard in io.ConfigFlags) && io.ConfigNavCaptureKeyboard) {
            io.WantCaptureKeyboard = true;
        }
    }
    if (g.WantCaptureKeyboardNextFrame != -1) { // Manual override
        io.WantCaptureKeyboard = (g.WantCaptureKeyboardNextFrame != 0);
    }

    // Update io.WantTextInput flag, this is to allow systems without a keyboard (e.g. mobile, hand-held) to show a software keyboard if possible
    io.WantTextInput = (g.WantTextInputNextFrame != -1) ? (g.WantTextInputNextFrame != 0) : false;
}

// Called once a frame. Followed by SetCurrentFont() which sets up the remaining data.
SetupDrawListSharedData :: proc()
{
    g := GImGui;
    virtual_space := ImRect{ _r = {math.F32_MAX, math.F32_MAX, -math.F32_MAX, -math.F32_MAX}};
    for viewport in g.Viewports {
        Add(&virtual_space, viewport.GetMainRect());
    }
    g.DrawListSharedData.ClipRectFullscreen = ToVec4(virtual_space);
    g.DrawListSharedData.CurveTessellationTol = g.Style.CurveTessellationTol;
    g.DrawListSharedData.SetCircleTessellationMaxError(g.Style.CircleTessellationMaxError);
    g.DrawListSharedData.InitialFlags = nil;
    if (g.Style.AntiAliasedLines) {
        g.DrawListSharedData.InitialFlags |= {.AntiAliasedLines};
    }
    if (g.Style.AntiAliasedLinesUseTex && !(.NoBakedLines in g.IO.Fonts.Flags)) {
        g.DrawListSharedData.InitialFlags |= {.AntiAliasedLinesUseTex};
    }
    if (g.Style.AntiAliasedFill) {
        g.DrawListSharedData.InitialFlags |= {.AntiAliasedFill};
    }
    if (.RendererHasVtxOffset in g.IO.BackendFlags) {
        g.DrawListSharedData.InitialFlags |= {.AllowVtxOffset};
    }
}

// [forward declared comment]:
// start a new Dear ImGui frame, you can submit any command from this point until Render()/EndFrame().
NewFrame :: proc()
{
    assert(GImGui != nil, "No current context. Did you call CreateContext() and SetCurrentContext() ?");
    g := GImGui;

    // Remove pending delete hooks before frame start.
    // This deferred removal avoid issues of removal while iterating the hook vector
    for n := len(g.Hooks) - 1; n >= 0; n -= 1 {
        if (g.Hooks[n].Type == ImGuiContextHookType.PendingRemoval_) {
            erase(g.Hooks, &g.Hooks[n]);
        }
    }

    CallContextHooks(g, ImGuiContextHookType_NewFramePre);

    // Check and assert for various common IO and Configuration mistakes
    g.ConfigFlagsLastFrame = g.ConfigFlagsCurrFrame;
    ErrorCheckNewFrameSanityChecks();
    g.ConfigFlagsCurrFrame = g.IO.ConfigFlags;

    // Load settings on first frame, save settings when modified (after a delay)
    UpdateSettings();

    g.Time += f64(g.IO.DeltaTime);
    g.WithinFrameScope = true;
    g.FrameCount += 1;
    g.TooltipOverrideCount = 0;
    g.WindowsActiveCount = 0;
    clear(&g.MenusIdSubmittedThisFrame)

    // Calculate frame-rate for the user, as a purely luxurious feature
    g.FramerateSecPerFrameAccum += g.IO.DeltaTime - g.FramerateSecPerFrame[g.FramerateSecPerFrameIdx];
    g.FramerateSecPerFrame[g.FramerateSecPerFrameIdx] = g.IO.DeltaTime;
    g.FramerateSecPerFrameIdx = (g.FramerateSecPerFrameIdx + 1) % len(g.FramerateSecPerFrame);
    g.FramerateSecPerFrameCount = ImMin(g.FramerateSecPerFrameCount + 1, len(g.FramerateSecPerFrame));
    g.IO.Framerate = (g.FramerateSecPerFrameAccum > 0.0) ? (1.0 / (g.FramerateSecPerFrameAccum / cast(f32) g.FramerateSecPerFrameCount)) : math.F32_MAX;

    // Process input queue (trickle as many events as possible), turn events into writes to IO structure
    clear(&g.InputEventsTrail)
    UpdateInputEvents(g.IO.ConfigInputTrickleEventQueue);

    // Update viewports (after processing input queue, so io.MouseHoveredViewport is set)
    UpdateViewportsNewFrame();

    // Setup current font and draw list shared data
    // FIXME-VIEWPORT: the concept of a single ClipRectFullscreen is not ideal!
    g.IO.Fonts.Locked = true;
    SetupDrawListSharedData();
    SetCurrentFont(GetDefaultFont());
    assert(IsLoaded(g.Font));

    // Mark rendering data as invalid to prevent user who may have a handle on it to use it.
    for viewport in g.Viewports
    {
        viewport.DrawData = nil;
        viewport.DrawDataP.Valid = false;
    }

    // Drag and drop keep the source ID alive so even if the source disappear our state is consistent
    if (g.DragDropActive && g.DragDropPayload.SourceId == g.ActiveId) {
        KeepAliveID(g.DragDropPayload.SourceId);
    }

    // [DEBUG]
    if (!g.IO.ConfigDebugHighlightIdConflicts || !g.IO.KeyCtrl) { // Count is locked while holding CTRL
        g.DebugDrawIdConflicts = 0;
    }
    if (g.IO.ConfigDebugHighlightIdConflicts && g.HoveredIdPreviousFrameItemCount > 1) {
        g.DebugDrawIdConflicts = g.HoveredIdPreviousFrame;
    }

    // Update HoveredId data
    if (g.HoveredIdPreviousFrame == {})   do g.HoveredIdTimer = 0.0
    if (g.HoveredIdPreviousFrame == {} || (g.HoveredId == {} && g.ActiveId == g.HoveredId)) {
        g.HoveredIdNotActiveTimer = 0.0;
    }
    if (g.HoveredId != {}) {
        g.HoveredIdTimer += g.IO.DeltaTime;
    }
    if (g.HoveredId != {} && g.ActiveId != g.HoveredId) {
        g.HoveredIdNotActiveTimer += g.IO.DeltaTime;
    }
    g.HoveredIdPreviousFrame = g.HoveredId;
    g.HoveredIdPreviousFrameItemCount = 0;
    g.HoveredId = 0;
    g.HoveredIdAllowOverlap = false;
    g.HoveredIdIsDisabled = false;

    // Clear ActiveID if the item is not alive anymore.
    // In 1.87, the common most call to KeepAliveID() was moved from GetID() to ItemAdd().
    // As a result, custom widget using ButtonBehavior() _without_ ItemAdd() need to call KeepAliveID() themselves.
    if (g.ActiveId != 0 && g.ActiveIdIsAlive != g.ActiveId && g.ActiveIdPreviousFrame == g.ActiveId)
    {
        IMGUI_DEBUG_LOG_ACTIVEID(g, "NewFrame(): ClearActiveID() because it isn't marked alive anymore!\n");
        ClearActiveID();
    }

    // Update ActiveId data (clear reference to active widget if the widget isn't alive anymore)
    if (g.ActiveId) {
        g.ActiveIdTimer += g.IO.DeltaTime;
    }
    g.LastActiveIdTimer += g.IO.DeltaTime;
    g.ActiveIdPreviousFrame = g.ActiveId;
    g.ActiveIdPreviousFrameWindow = g.ActiveIdWindow;
    g.ActiveIdPreviousFrameHasBeenEditedBefore = g.ActiveIdHasBeenEditedBefore;
    g.ActiveIdIsAlive = 0;
    g.ActiveIdHasBeenEditedThisFrame = false;
    g.ActiveIdPreviousFrameIsAlive = false;
    g.ActiveIdIsJustActivated = false;
    if (g.TempInputId != 0 && g.ActiveId != g.TempInputId)   do g.TempInputId = 0
    if (g.ActiveId == 0)
    {
        g.ActiveIdUsingNavDirMask = 0x00;
        g.ActiveIdUsingAllKeyboardKeys = false;
    }

    // Record when we have been stationary as this state is preserved while over same item.
    // FIXME: The way this is expressed means user cannot alter HoverStationaryDelay during the frame to use varying values.
    // To allow this we should store HoverItemMaxStationaryTime+ID and perform the >= check in IsItemHovered() function.
    if (g.HoverItemDelayId != 0 && g.MouseStationaryTimer >= g.Style.HoverStationaryDelay) {
        g.HoverItemUnlockedStationaryId = g.HoverItemDelayId;
    }
    else if (g.HoverItemDelayId == 0) {
        g.HoverItemUnlockedStationaryId = 0;
    }
    if (g.HoveredWindow != nil && g.MouseStationaryTimer >= g.Style.HoverStationaryDelay) {
        g.HoverWindowUnlockedStationaryId = g.HoveredWindow.ID;
    }
    else if (g.HoveredWindow == nil) {
        g.HoverWindowUnlockedStationaryId = 0;
    }

    // Update hover delay for IsItemHovered() with delays and tooltips
    g.HoverItemDelayIdPreviousFrame = g.HoverItemDelayId;
    if (g.HoverItemDelayId != 0)
    {
        g.HoverItemDelayTimer += g.IO.DeltaTime;
        g.HoverItemDelayClearTimer = 0.0;
        g.HoverItemDelayId = 0;
    }
    else if (g.HoverItemDelayTimer > 0.0)    
    {
        // This gives a little bit of leeway before clearing the hover timer, allowing mouse to cross gaps
        // We could expose 0.25f as style.HoverClearDelay but I am not sure of the logic yet, this is particularly subtle.
        g.HoverItemDelayClearTimer += g.IO.DeltaTime;
        if (g.HoverItemDelayClearTimer >= ImMax(f32(0.25), g.IO.DeltaTime * 2.0)) { // ~7 frames at 30 Hz + allow for low framerate
            g.HoverItemDelayClearTimer = 0.0; // May want a decaying timer, in which case need to clamp at max first, based on max of caller last requested timer.
            g.HoverItemDelayTimer = 0
        }
    }

    // Drag and drop
    g.DragDropAcceptIdPrev = g.DragDropAcceptIdCurr;
    g.DragDropAcceptIdCurr = 0;
    g.DragDropAcceptIdCurrRectSurface = math.F32_MAX;
    g.DragDropWithinSource = false;
    g.DragDropWithinTarget = false;
    g.DragDropHoldJustPressedId = 0;
    g.TooltipPreviousWindow = nil;

    // Close popups on focus lost (currently wip/opt-in)
    //if (g.IO.AppFocusLost)
    //    ClosePopupsExceptModals();

    // Update keyboard input state
    UpdateKeyboardInputs();

    //assert(g.IO.KeyCtrl == IsKeyDown(ImGuiKey.LeftCtrl) || IsKeyDown(ImGuiKey.RightCtrl));
    //assert(g.IO.KeyShift == IsKeyDown(ImGuiKey.LeftShift) || IsKeyDown(ImGuiKey.RightShift));
    //assert(g.IO.KeyAlt == IsKeyDown(ImGuiKey.LeftAlt) || IsKeyDown(ImGuiKey.RightAlt));
    //assert(g.IO.KeySuper == IsKeyDown(ImGuiKey.LeftSuper) || IsKeyDown(ImGuiKey.RightSuper));

    // Update keyboard/gamepad navigation
    NavUpdate();

    // Update mouse input state
    UpdateMouseInputs();

    // Undocking
    // (needs to be before UpdateMouseMovingWindowNewFrame so the window is already offset and following the mouse on the detaching frame)
    DockContextNewFrameUpdateUndocking(g);

    // Mark all windows as not visible and compact unused memory.
    assert(len(g.WindowsFocusOrder) <= len(g.Windows));
    memory_compact_start_time := (g.GcCompactAll || g.IO.ConfigMemoryCompactTimer < 0.0) ? math.F32_MAX : cast(f32) g.Time - g.IO.ConfigMemoryCompactTimer;
    for window in g.Windows
    {
        window.WasActive = window.Active;
        window.Active = false;
        window.WriteAccessed = false;
        window.BeginCountPreviousFrame = window.BeginCount;
        window.BeginCount = 0;

        // Garbage collect transient buffers of recently unused windows
        if (!window.WasActive && !window.MemoryCompacted && window.LastTimeActive < memory_compact_start_time) {
            GcCompactTransientWindowBuffers(window);
        }
    }

    // Find hovered window
    // (needs to be before UpdateMouseMovingWindowNewFrame so we fill g.HoveredWindowUnderMovingWindow on the mouse release frame)
    // (currently needs to be done after the WasActive=Active loop and FindHoveredWindowEx uses ->Active)
    UpdateHoveredWindowAndCaptureFlags();

    // Handle user moving window with mouse (at the beginning of the frame to avoid input lag or sheering)
    UpdateMouseMovingWindowNewFrame();

    // Background darkening/whitening
    if (GetTopMostPopupModal() != nil || (g.NavWindowingTarget != nil && g.NavWindowingHighlightAlpha > 0.0)) {
        g.DimBgRatio = ImMin(g.DimBgRatio + g.IO.DeltaTime * 6.0, 1.0);
    }
    else {
        g.DimBgRatio = ImMax(g.DimBgRatio - g.IO.DeltaTime * 10.0, 0.0);
    }

    g.MouseCursor = .Arrow;
    g.WantCaptureMouseNextFrame = -1
    g.WantCaptureKeyboardNextFrame = -1
    g.WantTextInputNextFrame = -1;

    // Platform IME data: reset for the frame
    g.PlatformImeDataPrev = g.PlatformImeData;
    g.PlatformImeData.WantVisible = false;

    // Mouse wheel scrolling, scale
    UpdateMouseWheel();

    // Garbage collect transient buffers of recently unused tables
    for i := 0; i < len(g.TablesLastTimeActive); i += 1 {
        if (g.TablesLastTimeActive[i] >= 0.0 && g.TablesLastTimeActive[i] < memory_compact_start_time) {
            TableGcCompactTransientBuffers(GetByIndex(&g.Tables, i));
        }
    }
    for &table_temp_data in g.TablesTempData {
        if (table_temp_data.LastTimeActive >= 0.0 && table_temp_data.LastTimeActive < memory_compact_start_time) {
            TableGcCompactTransientBuffers(&table_temp_data);
        }
    }
    if (g.GcCompactAll) {
        GcCompactTransientMiscBuffers();
    }
    g.GcCompactAll = false;

    // Closing the focused window restore focus to the first active root window in descending z-order
    if (g.NavWindow != nil && !g.NavWindow.WasActive) {
        FocusTopMostWindowUnderOne(nil, nil, nil, {.RestoreFocusedChild});
    }

    // No window should be open at the beginning of the frame.
    // But in order to allow the user to call NewFrame() multiple times without calling Render(), we are doing an explicit clear.
    clear(&g.CurrentWindowStack)
    clear(&g.BeginPopupStack)
    clear(&g.ItemFlagsStack)
    append(&g.ItemFlagsStack, {.AutoClosePopups}); // Default flags
    g.CurrentItemFlags = back(g.ItemFlagsStack)
    clear(&g.GroupStack);

    // Docking
    DockContextNewFrameUpdateDocking(g);

    // [DEBUG] Update debug features
when !(IMGUI_DISABLE_DEBUG_TOOLS) {
    UpdateDebugToolItemPicker();
    UpdateDebugToolStackQueries();
    UpdateDebugToolFlashStyleColor();
    if (g.DebugLocateFrames > 0)
    {
        g.DebugLocateFrames -= 1
        if g.DebugLocateFrames == 0 {
            g.DebugLocateId = 0;
            g.DebugBreakInLocateId = false;
        }
    }
    if (g.DebugLogAutoDisableFrames > 0)
    {
        g.DebugLogAutoDisableFrames -= 1
        if g.DebugLogAutoDisableFrames == 0 {
            DebugLog("(Debug Log: Auto-disabled some ImGuiDebugLogFlags after 2 frames)\n");
            g.DebugLogFlags &= ~g.DebugLogAutoDisableFlags;
            g.DebugLogAutoDisableFlags = nil;
        }
    }
}

    // Create implicit/fallback window - which we will only render it if the user has added something to it.
    // We don't use "Debug" to avoid colliding with user trying to create a "Debug" window with custom flags.
    // This fallback is particularly important as it prevents ImGui:: calls from crashing.
    g.WithinFrameScopeWithImplicitWindow = true;
    SetNextWindowSize(ImVec2{400, 400}, { .FirstUseEver });
    Begin("Debug##Default");
    assert(g.CurrentWindow.IsFallbackWindow == true);

    // Store stack sizes
    g.ErrorCountCurrentFrame = 0;
    ErrorRecoveryStoreState(&g.StackSizesInNewFrame);

    // [DEBUG] When io.ConfigDebugBeginReturnValue is set, we make Begin()/BeginChild() return false at different level of the window-stack,
    // allowing to validate correct Begin/End behavior in user code.
when !(IMGUI_DISABLE_DEBUG_TOOLS) {
    if (g.IO.ConfigDebugBeginReturnValueLoop) {
        g.DebugBeginReturnValueCullDepth = (g.DebugBeginReturnValueCullDepth == -1) ? 0 : ((g.DebugBeginReturnValueCullDepth + ((g.FrameCount % 4) == 0 ? 1 : 0)) % 10);
    }
    else {
        g.DebugBeginReturnValueCullDepth = -1;
    }
}

    CallContextHooks(g, .NewFramePost);
}

// FIXME: Add a more explicit sort order in the window structure.
ChildWindowComparer :: proc(lhs, rhs : ^^ImGuiWindow) -> i32
{
    a := lhs^;
    b := rhs^;
    if d := i32(.Popup in a.Flags) - i32(.Popup in b.Flags); d != 0   do return d
    if d := i32(.Tooltip in a.Flags) - i32(.Tooltip in b.Flags); d != 0   do return d
    return i32(a.BeginOrderWithinParent - b.BeginOrderWithinParent);
}

AddWindowToSortBuffer :: proc(out_sorted_windows : ^[]^ImGuiWindow, window : ^ImGuiWindow)
{
    append(out_sorted_windows, window);
    if (window.Active)
    {
        count := len(window.DC.ChildWindows);
        ImQsort(window.DC.ChildWindows[:], cast(int) count, size_of(^ImGuiWindow), ChildWindowComparer);
        for i := 0; i < count; i += 1
        {
            child := window.DC.ChildWindows[i];
            if (child.Active)  do AddWindowToSortBuffer(out_sorted_windows, child);
        }
    }
}

AddWindowToDrawData :: proc(window : ^ImGuiWindow, layer : i32)
{
    g := GImGui;
    viewport := window.Viewport;
    assert(viewport != nil);
    g.IO.MetricsRenderWindows += 1;
    if (window.DrawList._Splitter._Count > 1) {
        ChannelsMerge(window.DrawList); // Merge if user forgot to merge back. Also required in Docking branch for ImGuiWindowFlags_DockNodeHost windows.
    }
    AddDrawListToDrawDataEx(&viewport.DrawDataP, viewport.DrawDataBuilder.Layers[layer], window.DrawList);
    for child in window.DC.ChildWindows {
        if (IsWindowActiveAndVisible(child)) { // Clipped children may have been marked not active
            AddWindowToDrawData(child, layer);
        }
    }
}

GetWindowDisplayLayer :: #force_inline proc(window : ^ImGuiWindow) -> i32
{
    return (.Tooltip in window.Flags) ? 1 : 0;
}

// Layer is locked for the root window, however child windows may use a different viewport (e.g. extruding menu)
AddRootWindowToDrawData :: #force_inline proc(window : ^ImGuiWindow)
{
    AddWindowToDrawData(window, GetWindowDisplayLayer(window));
}

FlattenDrawDataIntoSingleLayer :: proc(builder : ^ImDrawDataBuilder)
{
    n := len(builder.Layers[0])
    full_size := n;
    for i := 1; i < len(builder.Layers); i += 1 {
        full_size += len(builder.Layers[i])
    }
    resize(&builder.Layers[0], full_size);
    for layer_n := 1; layer_n < len(builder.Layers); layer_n += 1
    {
        layer := builder.Layers[layer_n];
        if (empty(layer))   do continue
        memcpy(raw_data(builder.Layers[0])[n:], raw_data(layer^), len(layer) * size_of(^ImDrawList));
        n += len(layer);
        clear(layer)
    }
}

InitViewportDrawData :: proc(viewport : ^ImGuiViewportP)
{
    io := GetIO();
    draw_data := &viewport.DrawDataP;

    viewport.DrawData = draw_data; // Make publicly accessible
    viewport.DrawDataBuilder.Layers[0] = &draw_data.CmdLists;
    viewport.DrawDataBuilder.Layers[1] = &viewport.DrawDataBuilder.LayerData1;
    viewport.DrawDataBuilder.Layers[0]->resize(0);
    viewport.DrawDataBuilder.Layers[1]->resize(0);

    // When minimized, we report draw_data.DisplaySize as zero to be consistent with non-viewport mode,
    // and to allow applications/backends to easily skip rendering.
    // FIXME: Note that we however do NOT attempt to report "zero drawlist / vertices" into the ImDrawData structure.
    // This is because the work has been done already, and its wasted! We should fix that and add optimizations for
    // it earlier in the pipeline, rather than pretend to hide the data at the end of the pipeline.
    is_minimized := (.IsMinimized in viewport.Flags) != 0;

    draw_data.Valid = true;
    draw_data.CmdListsCount = 0;
    draw_data.TotalVtxCount = 0
    draw_data.TotalIdxCount = 0;
    draw_data.DisplayPos = viewport.Pos;
    draw_data.DisplaySize = is_minimized ? ImVec2{0.0, 0.0} : len(viewport);
    draw_data.FramebufferScale = io.DisplayFramebufferScale; // FIXME-VIEWPORT: This may vary on a per-monitor/viewport basis?
    draw_data.OwnerViewport = viewport;
}

// Push a clipping rectangle for both ImGui logic (hit-testing etc.) and low-level ImDrawList rendering.
// - When using this function it is sane to ensure that float are perfectly rounded to integer values,
//   so that e.g. (int)(max.x-min.x) in user's render produce correct result.
// - If the code here changes, may need to update code of functions like NextColumn() and PushColumnClipRect():
//   some frequently called functions which to modify both channels and clipping simultaneously tend to use the
//   more specialized SetWindowClipRectBeforeSetChannel() to avoid extraneous updates of underlying ImDrawCmds.
// - This is analoguous to PushFont()/PopFont() in the sense that are a mixing a global stack and a window stack,
//   which in the case of ClipRect is not so problematic but tends to be more restrictive for fonts.
// [forward declared comment]:
// Render-level scissoring. This is passed down to your render function but not used for CPU-side coarse clipping. Prefer using higher-level ImGui::PushClipRect() to affect logic (hit-testing and widget culling)
PushClipRect_g :: proc(clip_rect_min : ImVec2, clip_rect_max : ImVec2, intersect_with_current_clip_rect : bool = false)
{
    window := GetCurrentWindow();
    PushClipRect(window.DrawList, clip_rect_min, clip_rect_max, intersect_with_current_clip_rect);
    window.ClipRect._r = back(window.DrawList._ClipRectStack)^
}

PushClipRect :: proc { PushClipRect_g, ImDrawList_PushClipRect }

PopClipRect_g :: proc()
{
    window := GetCurrentWindow();
    PopClipRect(window.DrawList);
    window.ClipRect._r = back(window.DrawList._ClipRectStack)^;
}

PopClipRect :: proc { PopClipRect_g, ImDrawList_PopClipRect }

FindFrontMostVisibleChildWindow :: proc(window : ^ImGuiWindow) -> ^ImGuiWindow
{
    for n := len(window.DC.ChildWindows) - 1; n >= 0; n -= 1 {
        if (IsWindowActiveAndVisible(window.DC.ChildWindows[n])) {
            return FindFrontMostVisibleChildWindow(window.DC.ChildWindows[n]);
        }
    }
    return window;
}

RenderDimmedBackgroundBehindWindow :: proc(window : ^ImGuiWindow, col : u32)
{
    if ((col & IM_COL32_A_MASK) == 0)   do return

    viewport := window.Viewport;
    viewport_rect := viewport.GetMainRect();

    // Draw behind window by moving the draw command at the FRONT of the draw list
    {
        // Draw list have been trimmed already, hence the explicit recreation of a draw command if missing.
        // FIXME: This is creating complication, might be simpler if we could inject a drawlist in drawdata at a given position and not attempt to manipulate ImDrawCmd order.
        draw_list := window.RootWindowDockTree.DrawList;
        draw_list.ChannelsMerge();
        if (len(draw_list.CmdBuffer) == 0)   do AddDrawCmd(draw_list)
        draw_list.PushClipRect(viewport_rect.Min - ImVec2{1, 1}, viewport_rect.Max + ImVec2{1, 1}, false); // FIXME: Need to stricty ensure ImDrawCmd are not merged (ElemCount==6 checks below will verify that)
        AddRectFilled(draw_list, viewport_rect.Min, viewport_rect.Max, col);
        cmd := draw_list.CmdBuffer.back();
        assert(cmd.ElemCount == 6);
        draw_list.CmdBuffer.pop_back();
        draw_list.CmdBuffer.push_front(cmd);
        AddDrawCmd(draw_list); // We need to create a command as CmdBuffer.back().IdxOffset won't be correct if we append to same command.
        draw_list.PopClipRect();
    }

    // Draw over sibling docking nodes in a same docking tree
    if (window.RootWindow.DockIsActive)
    {
        draw_list := FindFrontMostVisibleChildWindow(window.RootWindowDockTree)->DrawList;
        draw_list.ChannelsMerge();
        if (len(draw_list.CmdBuffer) == 0)   do AddDrawCmd(draw_list)
        draw_list.PushClipRect(viewport_rect.Min, viewport_rect.Max, false);
        RenderRectFilledWithHole(draw_list, window.RootWindowDockTree.Rect(), window.RootWindow.Rect(), col, 0.0);// window.RootWindowDockTree.WindowRounding);
        draw_list.PopClipRect();
    }
}

FindBottomMostVisibleWindowWithinBeginStack :: proc(parent_window : ^ImGuiWindow) -> ^ImGuiWindow
{
    g := GImGui;
    bottom_most_visible_window := parent_window;
    for i := FindWindowDisplayIndex(parent_window); i >= 0; i -= 1
    {
        window := g.Windows[i];
        if (.ChildWindow in window.Flags)   do continue
        if (!IsWindowWithinBeginStackOf(window, parent_window))   do break
        if (IsWindowActiveAndVisible(window) && GetWindowDisplayLayer(window) <= GetWindowDisplayLayer(parent_window)) {
            bottom_most_visible_window = window;
        }

    }
    return bottom_most_visible_window;
}

// Important: AddWindowToDrawData() has not been called yet, meaning DockNodeHost windows needs a DrawList.ChannelsMerge() before usage.
// We call ChannelsMerge() lazily here at it is faster that doing a full iteration of g.Windows[] prior to calling RenderDimmedBackgrounds().
RenderDimmedBackgrounds :: proc()
{
    g := GImGui;
    modal_window := GetTopMostAndVisiblePopupModal();
    if (g.DimBgRatio <= 0.0 && g.NavWindowingHighlightAlpha <= 0.0)   do return
    dim_bg_for_modal := (modal_window != nil);
    dim_bg_for_window_list := (g.NavWindowingTargetAnim != nil && g.NavWindowingTargetAnim.Active);
    if (!dim_bg_for_modal && !dim_bg_for_window_list)   do return

    ImGuiViewport* viewports_already_dimmed[2] = { nil, nil };
    if (dim_bg_for_modal)
    {
        // Draw dimming behind modal or a begin stack child, whichever comes first in draw order.
        dim_behind_window := FindBottomMostVisibleWindowWithinBeginStack(modal_window);
        RenderDimmedBackgroundBehindWindow(dim_behind_window, GetColorU32(modal_window.DC.ModalDimBgColor, g.DimBgRatio));
        viewports_already_dimmed[0] = modal_window.Viewport;
    }
    else if (dim_bg_for_window_list)
    {
        // Draw dimming behind CTRL+Tab target window and behind CTRL+Tab UI window
        RenderDimmedBackgroundBehindWindow(g.NavWindowingTargetAnim, GetColorU32(ImGuiCol.NavWindowingDimBg, g.DimBgRatio));
        if (g.NavWindowingListWindow != nil && g.NavWindowingListWindow.Viewport && g.NavWindowingListWindow.Viewport != g.NavWindowingTargetAnim.Viewport) {
            RenderDimmedBackgroundBehindWindow(g.NavWindowingListWindow, GetColorU32(ImGuiCol.NavWindowingDimBg, g.DimBgRatio));
        }
        viewports_already_dimmed[0] = g.NavWindowingTargetAnim.Viewport;
        viewports_already_dimmed[1] = g.NavWindowingListWindow ? g.NavWindowingListWindow.Viewport : nil;

        // Draw border around CTRL+Tab target window
        window := g.NavWindowingTargetAnim;
        viewport := window.Viewport;
        distance := g.FontSize;
        bb := Rect(window);
        bb.Expand(distance);
        if (bb.GetWidth() >= viewport.Size.x && bb.GetHeight() >= viewport.Size.y) {
            bb.Expand(-distance - 1.0); // If a window fits the entire viewport, adjust its highlight inward
        }
        window.DrawList.ChannelsMerge();
        if (len(window.DrawList.CmdBuffer) == 0) {
            window.DrawList.AddDrawCmd();
        }
        window.DrawList.PushClipRect(viewport.Pos, viewport.Pos + viewport.Size);
        window.DrawList.AddRect(bb.Min, bb.Max, GetColorU32(ImGuiCol.NavWindowingHighlight, g.NavWindowingHighlightAlpha), window.WindowRounding, 0, 3.0);
        window.DrawList.PopClipRect();
    }

    // Draw dimming background on _other_ viewports than the ones our windows are in
    for viewport in g.Viewports
    {
        if (viewport == viewports_already_dimmed[0] || viewport == viewports_already_dimmed[1])   do continue
        if (modal_window && viewport.Window && IsWindowAbove(viewport.Window, modal_window))   do continue
        draw_list := GetForegroundDrawList(viewport);
        dim_bg_col := GetColorU32(dim_bg_for_modal ? ImGuiCol.ModalWindowDimBg : ImGuiCol.NavWindowingDimBg, g.DimBgRatio);
        AddRectFilled(draw_list, viewport.Pos, viewport.Pos + viewport.Size, dim_bg_col);
    }
}

// This is normally called by Render(). You may want to call it directly if you want to avoid calling Render() but the gain will be very minimal.
// [forward declared comment]:
// ends the Dear ImGui frame. automatically called by Render(). If you don't need to render data (skipping rendering) you may call EndFrame() without Render()... but you'll have wasted CPU already! If you don't need to render, better to not create any windows and not call NewFrame() at all!
EndFrame :: proc()
{
    g := GImGui;
    assert(g.Initialized);

    // Don't process EndFrame() multiple times.
    if (g.FrameCountEnded == g.FrameCount)   do return
    assert(g.WithinFrameScope, "Forgot to call NewFrame()?");

    CallContextHooks(g, ImGuiContextHookType_EndFramePre);

    // [EXPERIMENTAL] Recover from errors
    if (g.IO.ConfigErrorRecovery) {
        ErrorRecoveryTryToRecoverState(&g.StackSizesInNewFrame);
    }
    ErrorCheckEndFrameSanityChecks();
    ErrorCheckEndFrameFinalizeErrorTooltip();

    // Notify Platform/OS when our Input Method Editor cursor has moved (e.g. CJK inputs using Microsoft IME)
    ime_data := &g.PlatformImeData;
    if (g.PlatformIO.Platform_SetImeDataFn != nil && memcmp(ime_data, &g.PlatformImeDataPrev, size_of(ImGuiPlatformImeData)) != 0)
    {
        viewport := FindViewportByID(g.PlatformImeViewport);
        IMGUI_DEBUG_LOG_IO("[io] Calling Platform_SetImeDataFn(): WantVisible: %d, InputPos (%.2,%.2)\n", ime_data.WantVisible, ime_data.InputPos.x, ime_data.InputPos.y);
        if (viewport == nil) do viewport = GetMainViewport();
        g.PlatformIO.Platform_SetImeDataFn(g, viewport, ime_data);
    }

    // Hide implicit/fallback "Debug" window if it hasn't been used
    g.WithinFrameScopeWithImplicitWindow = false;
    if (g.CurrentWindow && !g.CurrentWindow.WriteAccessed) {
        g.CurrentWindow.Active = false;
    }
    End();

    // Update navigation: CTRL+Tab, wrap-around requests
    NavEndFrame();

    // Update docking
    DockContextEndFrame(&g);

    SetCurrentViewport(nil, nil);

    // Drag and Drop: Elapse payload (if delivered, or if source stops being submitted)
    if (g.DragDropActive)
    {
        is_delivered := g.DragDropPayload.Delivery;
        is_elapsed := (g.DragDropSourceFrameCount + 1 < g.FrameCount) && ((.PayloadAutoExpire in g.DragDropSourceFlags) || g.DragDropMouseButton == -1 || !IsMouseDown(g.DragDropMouseButton));
        if (is_delivered || is_elapsed)   do ClearDragDrop()
    }

    // Drag and Drop: Fallback for missing source tooltip. This is not ideal but better than nothing.
    // If you want to handle source item disappearing: instead of submitting your description tooltip
    // in the BeginDragDropSource() block of the dragged item, you can submit them from a safe single spot
    // (e.g. end of your item loop, or before EndFrame) by reading payload data.
    // In the typical case, the contents of drag tooltip should be possible to infer solely from payload data.
    if (g.DragDropActive && g.DragDropSourceFrameCount + 1 < g.FrameCount && !(.SourceNoPreviewTooltip in g.DragDropSourceFlags))
    {
        g.DragDropWithinSource = true;
        SetTooltip("...");
        g.DragDropWithinSource = false;
    }

    // End frame
    g.WithinFrameScope = false;
    g.FrameCountEnded = g.FrameCount;

    // Initiate moving window + handle left-click and right-click focus
    UpdateMouseMovingWindowEndFrame();

    // Update user-facing viewport list (g.Viewports -> g.PlatformIO.Viewports after filtering out some)
    UpdateViewportsEndFrame();

    // Sort the window list so that all child windows are after their parent
    // We cannot do that on FocusWindow() because children may not exist yet
    g.WindowsTempSortBuffer.resize(0);
    g.WindowsTempSortBuffer.reserve(g.Windows.Size);
    for window in g.Windows
    {
        if (window.Active && (.ChildWindow in window.Flags)) do continue       // if a child is active its parent will add it
        AddWindowToSortBuffer(&g.WindowsTempSortBuffer, window);
    }

    // This usually assert if there is a mismatch between the ImGuiWindowFlags_ChildWindow / ParentWindow values and DC.ChildWindows[] in parents, aka we've done something wrong.
    assert(len(g.Windows) == g.WindowsTempSortBuffer.Size);
    g.Windows.swap(g.WindowsTempSortBuffer);
    g.IO.MetricsActiveWindows = g.WindowsActiveCount;

    // Unlock font atlas
    g.IO.Fonts.Locked = false;

    // Clear Input data for next frame
    g.IO.MousePosPrev = g.IO.MousePos;
    g.IO.AppFocusLost = false;
    g.IO.MouseWheel = 0
    g.IO.MouseWheelH = 0.0;
    g.IO.InputQueueCharacters.resize(0);

    CallContextHooks(g, ImGuiContextHookType_EndFramePost);
}

// Prepare the data for rendering so you can call GetDrawData()
// (As with anything within the ImGui:: namspace this doesn't touch your GPU or graphics API at all:
// it is the role of the ImGui_ImplXXXX_RenderDrawData() function provided by the renderer backend)
// [forward declared comment]:
// ends the Dear ImGui frame, finalize the draw data. You can then get call GetDrawData().
Render :: proc()
{
    g := GImGui;
    assert(g.Initialized);

    if (g.FrameCountEnded != g.FrameCount)   do EndFrame()
    if (g.FrameCountRendered == g.FrameCount)   do return
    g.FrameCountRendered = g.FrameCount;

    g.IO.MetricsRenderWindows = 0;
    CallContextHooks(g, ImGuiContextHookType_RenderPre);

    // Add background ImDrawList (for each active viewport)
    for viewport in g.Viewports
    {
        InitViewportDrawData(viewport);
        if (viewport.BgFgDrawLists[0] != nil) {
            AddDrawListToDrawDataEx(&viewport.DrawDataP, viewport.DrawDataBuilder.Layers[0], GetBackgroundDrawList(viewport));
        }
    }

    // Draw modal/window whitening backgrounds
    RenderDimmedBackgrounds();

    // Add ImDrawList to render
    windows_to_render_top_most : [2]^ImGuiWindow;
    windows_to_render_top_most[0] = (g.NavWindowingTarget && !(.NoBringToFrontOnFocus in g.NavWindowingTarget.Flags)) ? g.NavWindowingTarget.RootWindowDockTree : nil;
    windows_to_render_top_most[1] = (g.NavWindowingTarget ? g.NavWindowingListWindow : nil);
    for window in g.Windows
    {
        if (IsWindowActiveAndVisible(window) && (.ChildWindow not_in window.Flags) && window != windows_to_render_top_most[0] && window != windows_to_render_top_most[1]) {
            AddRootWindowToDrawData(window);
        }
    }
    for n := 0; n < len(windows_to_render_top_most); n += 1 {
        if (windows_to_render_top_most[n] && IsWindowActiveAndVisible(windows_to_render_top_most[n])) { // NavWindowingTarget is always temporarily displayed as the top-most window
            AddRootWindowToDrawData(windows_to_render_top_most[n]);
        }
    }

    // Draw software mouse cursor if requested by io.MouseDrawCursor flag
    if (g.IO.MouseDrawCursor && g.MouseCursor != ImGuiMouseCursor_None) {
        RenderMouseCursor(g.IO.MousePos, g.Style.MouseCursorScale, g.MouseCursor, IM_COL32_WHITE, IM_COL32_BLACK, IM_COL32(0, 0, 0, 48));
    }

    // Setup ImDrawData structures for end-user
    g.IO.MetricsRenderVertices = 0
    g.IO.MetricsRenderIndices = 0;
    for viewport in g.Viewports
    {
        FlattenDrawDataIntoSingleLayer(&viewport.DrawDataBuilder);

        // Add foreground ImDrawList (for each active viewport)
        if (viewport.BgFgDrawLists[1] != nil) {
            AddDrawListToDrawDataEx(&viewport.DrawDataP, viewport.DrawDataBuilder.Layers[0], GetForegroundDrawList(viewport));
        }

        // We call _PopUnusedDrawCmd() last thing, as RenderDimmedBackgrounds() rely on a valid command being there (especially in docking branch).
        draw_data := &viewport.DrawDataP;
        assert(len(draw_data.CmdLists) == draw_data.CmdListsCount);
        for draw_list in draw_data.CmdLists {
            draw_list._PopUnusedDrawCmd();
        }

        g.IO.MetricsRenderVertices += draw_data.TotalVtxCount;
        g.IO.MetricsRenderIndices += draw_data.TotalIdxCount;
    }

    CallContextHooks(g, ImGuiContextHookType_RenderPost);
}

// Calculate text size. Text can be multi-line. Optionally ignore text after a ## marker.
// CalcTextSize("") should return ImVec2{0.0f, g.FontSize}
CalcTextSize :: proc(text : string, hide_text_after_double_hash : bool = false, wrap_width : f32 = 1.0) -> ImVec2
{
    text := text
    g := GImGui;

    if (hide_text_after_double_hash) {
        text, _ = FindRenderedText(text);      // Hide anything after a '##' string
    }

    font := g.Font;
    font_size := g.FontSize;
    if (text == "")   do return ImVec2{0.0, font_size}
    text_size := CalcTextSizeA(font, font_size, math.F32_MAX, wrap_width, text, nil);

    // Round
    // FIXME: This has been here since Dec 2015 (7b0bf230) but down the line we want this out.
    // FIXME: Investigate using ceilf or e.g.
    // - https://git.musl-libc.org/cgit/musl/tree/src/math/ceilf.c
    // - https://embarkstudios.github.io/rust-gpu/api/src/libm/math/ceilf.rs.html
    text_size.x = ImTrunc(text_size.x + 0.99999);

    return text_size;
}

// Find window given position, search front-to-back
// - Typically write output back to g.HoveredWindow and g.HoveredWindowUnderMovingWindow.
// - FIXME: Note that we have an inconsequential lag here: OuterRectClipped is updated in Begin(), so windows moved programmatically
//   with SetWindowPos() and not SetNextWindowPos() will have that rectangle lagging by a frame at the time FindHoveredWindow() is
//   called, aka before the next Begin(). Moving window isn't affected.
// - The 'find_first_and_in_any_viewport = true' mode is only used by TestEngine. It is simpler to maintain here.
FindHoveredWindowEx :: proc(pos : ImVec2, find_first_and_in_any_viewport : bool, out_hovered_window : ^^ImGuiWindow, out_hovered_window_under_moving_window : ^^ImGuiWindow)
{
    g := GImGui;
    hovered_window : ^ImGuiWindow
    hovered_window_under_moving_window : ^ImGuiWindow

    // Special handling for the window being moved: Ignore the mouse viewport check (because it may reset/lose its viewport during the undocking frame)
    backup_moving_window_viewport : ^ImGuiViewportP
    if (find_first_and_in_any_viewport == false && g.MovingWindow != nil)
    {
        backup_moving_window_viewport = g.MovingWindow.Viewport;
        g.MovingWindow.Viewport = g.MouseViewport;
        if (!(.NoMouseInputs in g.MovingWindow.Flags)) {
            hovered_window = g.MovingWindow;
        }
    }

    padding_regular := g.Style.TouchExtraPadding;
    padding_for_resize := g.IO.ConfigWindowsResizeFromEdges ? g.WindowsHoverPadding : padding_regular;
    for i := len(g.Windows) - 1; i >= 0; i -= 1
    {
        window := g.Windows[i];
        if (!window.WasActive || window.Hidden)   do continue
        if (.NoMouseInputs in window.Flags)   do continue
        assert(window.Viewport);
        if (window.Viewport != g.MouseViewport)   do continue

        // Using the clipped AABB, a child window will typically be clipped by its parent (not always)
        hit_padding := (window.Flags & (ImGuiWindowFlags_NoResize | ImGuiWindowFlags_AlwaysAutoResize)) ? padding_regular : padding_for_resize;
        if (!window.OuterRectClipped.ContainsWithPad(pos, hit_padding))   do continue

        // Support for one rectangular hole in any given window
        // FIXME: Consider generalizing hit-testing override (with more generic data, callback, etc.) (#1512)
        if (window.HitTestHoleSize.x != 0)
        {
            hole_pos := ImVec2(window.Pos.x + cast(f32) window.HitTestHoleOffset.x, window.Pos.y + cast(f32) window.HitTestHoleOffset.y);
            hole_size := ImVec2(cast(f32) window.HitTestHoleSize.x, cast(f32) window.HitTestHoleSize.y);
            if (ImRect{ _v = {hole_pos, hole_pos + hole_size}}.Contains(pos))   do continue
        }

        if (find_first_and_in_any_viewport)
        {
            hovered_window = window;
            break;
        }
        else
        {
            if (hovered_window == nil)   do hovered_window = window
            if (hovered_window_under_moving_window == nil && (!g.MovingWindow || window.RootWindowDockTree != g.MovingWindow.RootWindowDockTree)) {
                hovered_window_under_moving_window = window;
            }
            if (hovered_window && hovered_window_under_moving_window)   do break
        }
    }

    out_hovered_window^ = hovered_window;
    if (out_hovered_window_under_moving_window != nil) {
        out_hovered_window_under_moving_window^ = hovered_window_under_moving_window;
    }
    if (find_first_and_in_any_viewport == false && g.MovingWindow) {
        g.MovingWindow.Viewport = backup_moving_window_viewport;
    }
}

// [forward declared comment]:
// is the last item active? (e.g. button being held, text field being edited. This will continuously return true while holding mouse button on an item. Items that don't interact will always return false)
IsItemActive :: proc() -> bool
{
    g := GImGui;
    if (g.ActiveId) do return g.ActiveId == g.LastItemData.ID;
    return false;
}

// [forward declared comment]:
// was the last item just made active (item was previously inactive).
IsItemActivated :: proc() -> bool
{
    g := GImGui;
    if (g.ActiveId) {
        if (g.ActiveId == g.LastItemData.ID && g.ActiveIdPreviousFrame != g.LastItemData.ID)   do return true
    }
    return false;
}

// [forward declared comment]:
// was the last item just made inactive (item was previously active). Useful for Undo/Redo patterns with widgets that require continuous editing.
IsItemDeactivated :: proc() -> bool
{
    g := GImGui;
    if (.HasDeactivated in g.LastItemData.StatusFlags) {
        return (.Deactivated in g.LastItemData.StatusFlags) != 0;
    }
    return (g.ActiveIdPreviousFrame == g.LastItemData.ID && g.ActiveIdPreviousFrame != 0 && g.ActiveId != g.LastItemData.ID);
}

// [forward declared comment]:
// was the last item just made inactive and made a value change when it was active? (e.g. Slider/Drag moved). Useful for Undo/Redo patterns with widgets that require continuous editing. Note that you may get false positives (some widgets such as Combo()/ListBox()/Selectable() will return true even when clicking an already selected item).
IsItemDeactivatedAfterEdit :: proc() -> bool
{
    g := GImGui;
    return IsItemDeactivated() && (g.ActiveIdPreviousFrameHasBeenEditedBefore || (g.ActiveId == 0 && g.ActiveIdHasBeenEditedBefore));
}

// == (GetItemID() == GetFocusID() && GetFocusID() != 0)
// [forward declared comment]:
// is the last item focused for keyboard/gamepad navigation?
IsItemFocused :: proc() -> bool
{
    g := GImGui;
    if (g.NavId != g.LastItemData.ID || g.NavId == 0)   do return false

    // Special handling for the dummy item after Begin() which represent the title bar or tab.
    // When the window is collapsed (SkipItems==true) that last item will never be overwritten so we need to detect the case.
    window := g.CurrentWindow;
    if (g.LastItemData.ID == window.ID && window.WriteAccessed)   do return false

    return true;
}

// Important: this can be useful but it is NOT equivalent to the behavior of e.g.Button()!
// Most widgets have specific reactions based on mouse-up/down state, mouse position etc.
// [forward declared comment]:
// is the last item hovered and mouse clicked on? (**)  == IsMouseClicked(mouse_button) && IsItemHovered()Important. (**) this is NOT equivalent to the behavior of e.g. Button(). Read comments in function definition.
IsItemClicked :: proc(mouse_button : ImGuiMouseButton = {}) -> bool
{
    return IsMouseClicked(mouse_button) && IsItemHovered(ImGuiHoveredFlags_None);
}

// [forward declared comment]:
// was the last item open state toggled? set by TreeNode().
IsItemToggledOpen :: proc() -> bool
{
    g := GImGui;
    return (.ToggledOpen in g.LastItemData.StatusFlags) ? true : false;
}

// Call after a Selectable() or TreeNode() involved in multi-selection.
// Useful if you need the per-item information before reaching EndMultiSelect(), e.g. for rendering purpose.
// This is only meant to be called inside a BeginMultiSelect()/EndMultiSelect() block.
// (Outside of multi-select, it would be misleading/ambiguous to report this signal, as widgets
// return e.g. a pressed event and user code is in charge of altering selection in ways we cannot predict.)
// [forward declared comment]:
// Was the last item selection state toggled? Useful if you need the per-item information _before_ reaching EndMultiSelect(). We only returns toggle _event_ in order to handle clipping correctly.
IsItemToggledSelection :: proc() -> bool
{
    g := GImGui;
    assert(g.CurrentMultiSelect != nil); // Can only be used inside a BeginMultiSelect()/EndMultiSelect()
    return (.ToggledSelection in g.LastItemData.StatusFlags) ? true : false;
}

// IMPORTANT: If you are trying to check whether your mouse should be dispatched to Dear ImGui or to your underlying app,
// you should not use this function! Use the 'io.WantCaptureMouse' boolean for that!
// Refer to FAQ entry "How can I tell whether to dispatch mouse/keyboard to Dear ImGui or my application?" for details.
// [forward declared comment]:
// is any item hovered?
IsAnyItemHovered :: proc() -> bool
{
    g := GImGui;
    return g.HoveredId != 0 || g.HoveredIdPreviousFrame != 0;
}

// [forward declared comment]:
// is any item active?
IsAnyItemActive :: proc() -> bool
{
    g := GImGui;
    return g.ActiveId != 0;
}

// [forward declared comment]:
// is any item focused?
IsAnyItemFocused :: proc() -> bool
{
    g := GImGui;
    return g.NavId != 0 && g.NavCursorVisible;
}

// [forward declared comment]:
// is the last item visible? (items may be out of sight because of clipping/scrolling)
IsItemVisible :: proc() -> bool
{
    g := GImGui;
    return (.Visible in g.LastItemData.StatusFlags);
}

// [forward declared comment]:
// did the last item modify its underlying value this frame? or was pressed? This is generally the same as the "bool" return value of many widgets.
IsItemEdited :: proc() -> bool
{
    g := GImGui;
    return (.Edited in g.LastItemData.StatusFlags) != 0;
}

// Allow next item to be overlapped by subsequent items.
// This works by requiring HoveredId to match for two subsequent frames,
// so if a following items overwrite it our interactions will naturally be disabled.
// [forward declared comment]:
// allow next item to be overlapped by a subsequent item. Useful with invisible buttons, selectable, treenode covering an area where subsequent items may need to be added. Note that both Selectable() and TreeNode() have dedicated flags doing this.
SetNextItemAllowOverlap :: proc()
{
    g := GImGui;
    g.NextItemData.ItemFlags |= ImGuiItemFlags_AllowOverlap;
}


// This is a shortcut for not taking ownership of 100+ keys, frequently used by drag operations.
// FIXME: It might be undesirable that this will likely disable KeyOwner-aware shortcuts systems. Consider a more fine-tuned version if needed?
SetActiveIdUsingAllKeyboardKeys :: proc()
{
    g := GImGui;
    assert(g.ActiveId != 0);
    g.ActiveIdUsingNavDirMask = (1 << ImGuiDir.COUNT) - 1;
    g.ActiveIdUsingAllKeyboardKeys = true;
    NavMoveRequestCancel();
}

// [forward declared comment]:
// get ID of last item (~~ often same ImGui::GetID(label) beforehand)
GetItemID :: proc() -> ImGuiID
{
    g := GImGui;
    return g.LastItemData.ID;
}

// [forward declared comment]:
// get upper-left bounding rectangle of the last item (screen space)
GetItemRectMin :: proc() -> ImVec2
{
    g := GImGui;
    return g.LastItemData.Rect.Min;
}

// [forward declared comment]:
// get lower-right bounding rectangle of the last item (screen space)
GetItemRectMax :: proc() -> ImVec2
{
    g := GImGui;
    return g.LastItemData.Rect.Max;
}

// [forward declared comment]:
// get size of last item
GetItemRectSize :: proc() -> ImVec2
{
    g := GImGui;
    return g.LastItemData.Rect.GetSize();
}

// Prior to v1.90 2023/10/16, the BeginChild() function took a 'bool border = false' parameter instead of 'ImGuiChildFlags child_flags = 0'.
// ImGuiChildFlags_Borders is defined as always == 1 in order to allow old code passing 'true'. Read comments in imgui.h for details!
BeginChild_str :: proc(str_id : ^u8, size_arg : ImVec2 = {}, child_flags : ImGuiChildFlags = {}, window_flags : ImGuiWindowFlags = {}) -> bool
{
    id := GetCurrentWindow()->GetID(str_id);
    return BeginChildEx(str_id, id, size_arg, child_flags, window_flags);
}

BeginChild_id :: proc(id : ImGuiID, size_arg : ImVec2 = {}, child_flags : ImGuiChildFlags = {}, window_flags : ImGuiWindowFlags = {}) -> bool
{
    return BeginChildEx(nil, id, size_arg, child_flags, window_flags);
}

BeginChild :: proc { BeginChild_id, BeginChild_str }

BeginChildEx :: proc(name : string, id : ImGuiID, size_arg : ImVec2, child_flags : ImGuiChildFlags, window_flags : ImGuiWindowFlags) -> bool
{
    g := GImGui;
    parent_window := g.CurrentWindow;
    assert(id != 0);

    // Sanity check as it is likely that some user will accidentally pass ImGuiWindowFlags into the ImGuiChildFlags argument.
    ImGuiChildFlags_SupportedMask_ := ImGuiChildFlags{.Borders, .AlwaysUseWindowPadding, .ResizeX, .ResizeY, .AutoResizeX, .AutoResizeY, .AlwaysAutoResize, .FrameStyle, .NavFlattened };
    _ = ImGuiChildFlags_SupportedMask_
    assert((child_flags & ~ImGuiChildFlags_SupportedMask_) == nil, "Illegal ImGuiChildFlags value. Did you pass ImGuiWindowFlags values instead of ImGuiChildFlags?");
    assert((.AlwaysAutoResize not_in window_flags), "Cannot specify ImGuiWindowFlags_AlwaysAutoResize for BeginChild(). Use ImGuiChildFlags_AlwaysAutoResize!");
    if (.AlwaysAutoResize in child_flags)
    {
        assert((child_flags & {.ResizeX, .ResizeY}) == nil, "Cannot use ImGuiChildFlags_ResizeX or ImGuiChildFlags_ResizeY with ImGuiChildFlags_AlwaysAutoResize!");
        assert((child_flags & {.AutoResizeX, .AutoResizeY}) != nil, "Must use ImGuiChildFlags_AutoResizeX or ImGuiChildFlags_AutoResizeY with ImGuiChildFlags_AlwaysAutoResize!");
    }
    child_flags := child_flags
    if (.AutoResizeX in child_flags) {
        child_flags &= ~{.ResizeX};
    }
    if (.AutoResizeY in child_flags) {
        child_flags &= ~{.ResizeY};
    }

    window_flags := window_flags
    // Set window flags
    window_flags |= {.ChildWindow, .NoTitleBar, .NoDocking};
    window_flags |= (parent_window.Flags & {.NoMove}); // Inherit the NoMove flag
    if (child_flags & {.AutoResizeX, .AutoResizeY, .AlwaysAutoResize} != nil) {
        window_flags |= {.AlwaysAutoResize};
    }
    if ((child_flags & {.ResizeX, .ResizeY}) == nil) {
        window_flags |= {.NoResize, .NoSavedSettings};
    }

    // Special framed style
    if (.FrameStyle in child_flags)
    {
        PushStyleColor(ImGuiCol.ChildBg, g.Style.Colors[ImGuiCol.FrameBg]);
        PushStyleVar(.ChildRounding, g.Style.FrameRounding);
        PushStyleVar(.ChildBorderSize, g.Style.FrameBorderSize);
        PushStyleVar(.WindowPadding, g.Style.FramePadding);
        child_flags |= {.Borders, .AlwaysUseWindowPadding};
        window_flags |= {.NoMove};
    }

    // Forward size
    // Important: Begin() has special processing to switch condition to ImGuiCond_FirstUseEver for a given axis when ImGuiChildFlags_ResizeXXX is set.
    // (the alternative would to store conditional flags per axis, which is possible but more code)
    size_avail := GetContentRegionAvail();
    size_default := ImVec2{(.AutoResizeX in child_flags) ? 0.0 : size_avail.x, (.AutoResizeY in child_flags) ? 0.0 : size_avail.y};
    size := CalcItemSize(size_arg, size_default.x, size_default.y);

    // A SetNextWindowSize() call always has priority (#8020)
    // (since the code in Begin() never supported SizeVal==0.0f aka auto-resize via SetNextWindowSize() call, we don't support it here for now)
    // FIXME: We only support ImGuiCond_Always in this path. Supporting other paths would requires to obtain window pointer.
    if ((.HasSize in g.NextWindowData.Flags) && (.Always in g.NextWindowData.SizeCond))
    {
        if (g.NextWindowData.SizeVal.x > 0.0)
        {
            size.x = g.NextWindowData.SizeVal.x;
            child_flags &= ~ImGuiChildFlags{.ResizeX};
        }
        if (g.NextWindowData.SizeVal.y > 0.0)
        {
            size.y = g.NextWindowData.SizeVal.y;
            child_flags &= ~ImGuiChildFlags{.ResizeY};
        }
    }
    SetNextWindowSize(size);

    // Forward child flags (we allow prior settings to merge but it'll only work for adding flags)
    if (.HasChildFlags in g.NextWindowData.Flags) {
        g.NextWindowData.ChildFlags |= child_flags;
    }
    else {
        g.NextWindowData.ChildFlags = child_flags;
    }
    g.NextWindowData.Flags |= {.HasChildFlags};

    // Build up name. If you need to append to a same child from multiple location in the ID stack, use BeginChild(ImGuiID id) with a stable value.
    // FIXME: 2023/11/14: commented out shorted version. We had an issue with multiple ### in child window path names, which the trailing hash helped workaround.
    // e.g. "ParentName###ParentIdentifier/ChildName###ChildIdentifier" would get hashed incorrectly by ImHashStr(), trailing _%08X somehow fixes it.
    temp_window_name : string;
    /*if (name && parent_window.IDStack.back() == parent_window.ID)
        ImFormatStringToTempBuffer(&temp_window_name, nil, "%s/%s", parent_window.Name, name); // May omit ID if in root of ID stack
    else*/
    if (name != "") {
        temp_window_name = ImFormatStringToTempBuffer("%s/%s_%08X", parent_window.Name, name, id);
    }
    else {
        temp_window_name = ImFormatStringToTempBuffer("%s/%08X", parent_window.Name, id);
    }

    // Set style
    backup_border_size := g.Style.ChildBorderSize;
    if ((.Borders not_in child_flags)) {
        g.Style.ChildBorderSize = 0.0;
    }

    // Begin into window
    ret := Begin(temp_window_name, nil, window_flags);

    // Restore style
    g.Style.ChildBorderSize = backup_border_size;
    if (.FrameStyle in child_flags)
    {
        PopStyleVar(3);
        PopStyleColor();
    }

    child_window := g.CurrentWindow;
    child_window.ChildId = id;

    // Set the cursor to handle case where the user called SetNextWindowPos()+BeginChild() manually.
    // While this is not really documented/defined, it seems that the expected thing to do.
    if (child_window.BeginCount == 1) {
        parent_window.DC.CursorPos = child_window.Pos;
    }

    // Process navigation-in immediately so NavInit can run on first frame
    // Can enter a child if (A) it has navigable items or (B) it can be scrolled.
    temp_id_for_activation := ImHashStr("##Child", id);
    if (g.ActiveId == temp_id_for_activation)   do ClearActiveID()
    if (g.NavActivateId == id && !(.NavFlattened in child_flags) && (child_window.DC.NavLayersActiveMask != 0 || child_window.DC.NavWindowHasScrollY))
    {
        FocusWindow(child_window);
        NavInitWindow(child_window, false);
        SetActiveID(temp_id_for_activation, child_window); // Steal ActiveId with another arbitrary id so that key-press won't activate child item
        g.ActiveIdSource = g.NavInputSource;
    }
    return ret;
}

EndChild :: proc()
{
    g := GImGui;
    child_window := g.CurrentWindow;

    backup_within_end_child_id := g.WithinEndChildID;
    assert(.ChildWindow in child_window.Flags);   // Mismatched BeginChild()/EndChild() calls

    g.WithinEndChildID = child_window.ID;
    child_size := child_window.Size;
    End();
    if (child_window.BeginCount == 1)
    {
        parent_window := g.CurrentWindow;
        bb := ImRect{ _v = {parent_window.DC.CursorPos, parent_window.DC.CursorPos + child_size}};
        ItemSize(child_size);
        nav_flattened := (.NavFlattened in child_window.ChildFlags);
        if ((child_window.DC.NavLayersActiveMask != 0 || child_window.DC.NavWindowHasScrollY) && !nav_flattened)
        {
            ItemAdd(bb, child_window.ChildId);
            RenderNavCursor(bb, child_window.ChildId);

            // When browsing a window that has no activable items (scroll only) we keep a highlight on the child (pass g.NavId to trick into always displaying)
            if (child_window.DC.NavLayersActiveMask == 0 && child_window == g.NavWindow) {
                RenderNavCursor(ImRect{_v = { bb.Min - ImVec2{2, 2}, bb.Max + ImVec2{2, 2}}}, g.NavId, {.Compact});
            }
        }
        else
        {
            // Not navigable into
            // - This is a bit of a fringe use case, mostly useful for undecorated, non-scrolling contents childs, or empty childs.
            // - We could later decide to not apply this path if ImGuiChildFlags_FrameStyle or ImGuiChildFlags_Borders is set.
            ItemAdd(bb, child_window.ChildId, nil, {.NoNav});

            // But when flattened we directly reach items, adjust active layer mask accordingly
            if (nav_flattened) {
                parent_window.DC.NavLayersActiveMaskNext |= child_window.DC.NavLayersActiveMaskNext;
            }
        }
        if (g.HoveredWindow == child_window) {
            g.LastItemData.StatusFlags |= {.HoveredWindow};
        }
    }
    g.WithinEndChildID = backup_within_end_child_id;
    g.LogLinePosY = -math.F32_MAX; // To enforce a carriage return
}

SetWindowConditionAllowFlags :: proc(window : ^ImGuiWindow, flags : ImGuiCond, enabled : bool)
{
    window.SetWindowPosAllowFlags       = enabled ? (window.SetWindowPosAllowFlags       | flags) : (window.SetWindowPosAllowFlags       & ~flags);
    window.SetWindowSizeAllowFlags      = enabled ? (window.SetWindowSizeAllowFlags      | flags) : (window.SetWindowSizeAllowFlags      & ~flags);
    window.SetWindowCollapsedAllowFlags = enabled ? (window.SetWindowCollapsedAllowFlags | flags) : (window.SetWindowCollapsedAllowFlags & ~flags);
    window.SetWindowDockAllowFlags      = enabled ? (window.SetWindowDockAllowFlags      | flags) : (window.SetWindowDockAllowFlags      & ~flags);
}

FindWindowByID :: proc(id : ImGuiID) -> ^ImGuiWindow
{
    g := GImGui;
    return cast(^ImGuiWindow)GetVoidPtr(&g.WindowsById, id);
}

FindWindowByName :: proc(name : string) -> ^ImGuiWindow
{
    id := ImHashStr(name);
    return FindWindowByID(id);
}

ApplyWindowSettings :: proc(window : ^ImGuiWindow, settings : ^ImGuiWindowSettings)
{
    main_viewport := GetMainViewport();
    window.ViewportPos = main_viewport.Pos;
    if (settings.ViewportId != {})
    {
        window.ViewportId = settings.ViewportId;
        window.ViewportPos = ImVec2{cast(f32) settings.ViewportPos.x, cast(f32) settings.ViewportPos.y};
    }
    window.Pos = ImTrunc(ImVec2{cast(f32) settings.Pos.x + window.ViewportPos.x, cast(f32) settings.Pos.y + window.ViewportPos.y});
    if (settings.Size.x > 0 && settings.Size.y > 0) {
        window.SizeFull = ImTrunc(ImVec2{cast(f32) settings.Size.x, cast(f32) settings.Size.y});
        window.Size = window.SizeFull
    }
    window.Collapsed = settings.Collapsed;
    window.DockId = settings.DockId;
    window.DockOrder = settings.DockOrder;
}

InitOrLoadWindowSettings :: proc(window : ^ImGuiWindow, settings : ^ImGuiWindowSettings)
{
    // Initial window state with e.g. default/arbitrary window position
    // Use SetNextWindowPos() with the appropriate condition flag to change the initial position of a window.
    main_viewport := GetMainViewport();
    window.Pos = main_viewport.Pos + ImVec2{60, 60};
    window.SizeFull = ImVec2{0, 0};
    window.Size = {}
    window.ViewportPos = main_viewport.Pos;
    window.SetWindowDockAllowFlags = {.Always, .Once, .FirstUseEver, .Appearing};
    window.SetWindowCollapsedAllowFlags = window.SetWindowDockAllowFlags
    window.SetWindowSizeAllowFlags = window.SetWindowCollapsedAllowFlags
    window.SetWindowPosAllowFlags = window.SetWindowSizeAllowFlags

    if (settings != nil)
    {
        SetWindowConditionAllowFlags(window, {.FirstUseEver}, false);
        ApplyWindowSettings(window, settings);
    }
    window.DC.CursorStartPos =  window.Pos
    window.DC.CursorMaxPos = window.Pos 
    window.DC.IdealMaxPos = window.Pos; // So first call to CalcWindowContentSizes() doesn't return crazy values

    if ((.AlwaysAutoResize in window.Flags))
    {
        window.AutoFitFramesX = 2
        window.AutoFitFramesY = 2;
        window.AutoFitOnlyGrows = false;
    }
    else
    {
        if (window.Size.x <= 0.0)   do window.AutoFitFramesX = 2
        if (window.Size.y <= 0.0)   do window.AutoFitFramesY = 2
        window.AutoFitOnlyGrows = (window.AutoFitFramesX > 0) || (window.AutoFitFramesY > 0);
    }
}

CreateNewWindow :: proc(name : string, flags : ImGuiWindowFlags) -> ^ImGuiWindow
{
    // Create window the first time
    //IMGUI_DEBUG_LOG("CreateNewWindow '%s', flags = 0x%08X\n", name, flags);
    g := GImGui;
    window := IM_NEW(ImGuiWindow)
    init_ImGuiWindow(window, g, name);
    window.Flags = flags;
    SetVoidPtr(&g.WindowsById, window.ID, window);

    settings : ^ImGuiWindowSettings
    if (!(.NoSavedSettings in flags)) {
        settings = FindWindowSettingsByWindow(window)
        if settings != nil {
            window.SettingsOffset = offset_from_ptr(&g.SettingsWindows, settings);
        }
    }

    InitOrLoadWindowSettings(window, settings);

    if (.NoBringToFrontOnFocus in flags) {
        inject_at(&g.Windows, 0, window); // Quite slow but rare and only once
    }
    else {
        append(&g.Windows, window);
    }

    return window;
}

GetWindowForTitleDisplay :: proc(window : ^ImGuiWindow) -> ^ImGuiWindow
{
    return window.DockNodeAsHost ? window.DockNodeAsHost.VisibleWindow : window;
}

GetWindowForTitleAndMenuHeight :: proc(window : ^ImGuiWindow) -> ^ImGuiWindow
{
    return (window.DockNodeAsHost != nil && window.DockNodeAsHost.VisibleWindow != nil) ? window.DockNodeAsHost.VisibleWindow : window;
}

CalcWindowMinSize :: #force_inline proc(window : ^ImGuiWindow) -> ImVec2
{
    // We give windows non-zero minimum size to facilitate understanding problematic cases (e.g. empty popups)
    // FIXME: Essentially we want to restrict manual resizing to WindowMinSize+Decoration, and allow api resizing to be smaller.
    // Perhaps should tend further a neater test for this.
    g := GImGui;
    size_min : ImVec2
    if ((.ChildWindow in window.Flags) && !(.Popup in window.Flags))
    {
        size_min.x = (.ResizeX in window.ChildFlags) ? g.Style.WindowMinSize.x : 4.0;
        size_min.y = (.ResizeY in window.ChildFlags) ? g.Style.WindowMinSize.y : 4.0;
    }
    else
    {
        size_min.x = ((.AlwaysAutoResize not_in window.Flags)) ? g.Style.WindowMinSize.x : 4.0;
        size_min.y = ((.AlwaysAutoResize not_in window.Flags)) ? g.Style.WindowMinSize.y : 4.0;
    }

    // Reduce artifacts with very small windows
    window_for_height := GetWindowForTitleAndMenuHeight(window);
    size_min.y = ImMax(size_min.y, window_for_height.TitleBarHeight + window_for_height.MenuBarHeight + ImMax(f32(0), g.Style.WindowRounding - 1.0));
    return size_min;
}

CalcWindowSizeAfterConstraint :: proc(window : ^ImGuiWindow, size_desired : ImVec2) -> ImVec2
{
    g := GImGui;
    new_size := size_desired;
    if (.HasSizeConstraint in g.NextWindowData.Flags)
    {
        // See comments in SetNextWindowSizeConstraints() for details about setting size_min an size_max.
        cr := g.NextWindowData.SizeConstraintRect;
        new_size.x = (cr.Min.x >= 0 && cr.Max.x >= 0) ? ImClamp(new_size.x, cr.Min.x, cr.Max.x) : window.SizeFull.x;
        new_size.y = (cr.Min.y >= 0 && cr.Max.y >= 0) ? ImClamp(new_size.y, cr.Min.y, cr.Max.y) : window.SizeFull.y;
        if (g.NextWindowData.SizeCallback != nil)
        {
            data : ImGuiSizeCallbackData
            data.UserData = g.NextWindowData.SizeCallbackUserData;
            data.Pos = window.Pos;
            data.CurrentSize = window.SizeFull;
            data.DesiredSize = new_size;
            g.NextWindowData.SizeCallback(&data);
            new_size = data.DesiredSize;
        }
        new_size.x = math.trunc(new_size.x);
        new_size.y = math.trunc(new_size.y);
    }

    // Minimum size
    size_min := CalcWindowMinSize(window);
    return ImMax(new_size, size_min);
}

CalcWindowContentSizes :: proc(window : ^ImGuiWindow, content_size_current : ^ImVec2, content_size_ideal : ^ImVec2)
{
    preserve_old_content_sizes := false;
    if (window.Collapsed && window.AutoFitFramesX <= 0 && window.AutoFitFramesY <= 0) {
        preserve_old_content_sizes = true;
    }
    else if (window.Hidden && window.HiddenFramesCannotSkipItems == 0 && window.HiddenFramesCanSkipItems > 0) {
        preserve_old_content_sizes = true;
    }
    if (preserve_old_content_sizes)
    {
        content_size_current^ = window.ContentSize;
        content_size_ideal^ = window.ContentSizeIdeal;
        return;
    }

    content_size_current.x = (window.ContentSizeExplicit.x != 0.0) ? window.ContentSizeExplicit.x : math.trunc(window.DC.CursorMaxPos.x - window.DC.CursorStartPos.x);
    content_size_current.y = (window.ContentSizeExplicit.y != 0.0) ? window.ContentSizeExplicit.y : math.trunc(window.DC.CursorMaxPos.y - window.DC.CursorStartPos.y);
    content_size_ideal.x = (window.ContentSizeExplicit.x != 0.0) ? window.ContentSizeExplicit.x : math.trunc(ImMax(window.DC.CursorMaxPos.x, window.DC.IdealMaxPos.x) - window.DC.CursorStartPos.x);
    content_size_ideal.y = (window.ContentSizeExplicit.y != 0.0) ? window.ContentSizeExplicit.y : math.trunc(ImMax(window.DC.CursorMaxPos.y, window.DC.IdealMaxPos.y) - window.DC.CursorStartPos.y);
}

CalcWindowAutoFitSize :: proc(window : ^ImGuiWindow, size_contents : ImVec2) -> ImVec2
{
    g := GImGui;
    style := &g.Style;
    decoration_w_without_scrollbars := window.DecoOuterSizeX1 + window.DecoOuterSizeX2 - window.ScrollbarSizes.x;
    decoration_h_without_scrollbars := window.DecoOuterSizeY1 + window.DecoOuterSizeY2 - window.ScrollbarSizes.y;
    size_pad := window.WindowPadding * 2.0;
    size_desired := size_contents + size_pad + ImVec2{decoration_w_without_scrollbars, decoration_h_without_scrollbars};
    if (.Tooltip in window.Flags)
    {
        // Tooltip always resize
        return size_desired;
    }
    else
    {
        // Maximum window size is determined by the viewport size or monitor size
        size_min := CalcWindowMinSize(window);
        size_max := ImVec2{math.F32_MAX, math.F32_MAX};

        // Child windows are layed within their parent (unless they are also popups/menus) and thus have no restriction
        if ((.ChildWindow not_in window.Flags) || (.Popup in window.Flags))
        {
            if (!window.ViewportOwned) {
                size_max = GetMainViewport().WorkSize - style.DisplaySafeAreaPadding * 2.0;
            }
            monitor_idx := window.ViewportAllowPlatformMonitorExtend;
            if (monitor_idx >= 0 && monitor_idx < cast(i32) len(g.PlatformIO.Monitors)) {
                size_max = g.PlatformIO.Monitors[monitor_idx].WorkSize - style.DisplaySafeAreaPadding * 2.0;
            }
        }

        size_auto_fit := ImClamp(size_desired, size_min, ImMax(size_min, size_max));

        // FIXME: CalcWindowAutoFitSize() doesn't take into account that only one axis may be auto-fit when calculating scrollbars,
        // we may need to compute/store three variants of size_auto_fit, for x/y/xy.
        // Here we implement a workaround for child windows only, but a full solution would apply to normal windows as well:
        if ((.ResizeX in window.ChildFlags) && !(.ResizeY in window.ChildFlags)) {
            size_auto_fit.y = window.SizeFull.y;
        }
        else if (!(.ResizeX in window.ChildFlags) && (.ResizeY in window.ChildFlags)) {
            size_auto_fit.x = window.SizeFull.x;
        }

        // When the window cannot fit all contents (either because of constraints, either because screen is too small),
        // we are growing the size on the other axis to compensate for expected scrollbar. FIXME: Might turn bigger than ViewportSize-WindowPadding.
        size_auto_fit_after_constraint := CalcWindowSizeAfterConstraint(window, size_auto_fit);
        will_have_scrollbar_x := (size_auto_fit_after_constraint.x - size_pad.x - decoration_w_without_scrollbars < size_contents.x && !(.NoScrollbar in window.Flags) && (.HorizontalScrollbar in window.Flags)) || (.AlwaysHorizontalScrollbar in window.Flags);
        will_have_scrollbar_y := (size_auto_fit_after_constraint.y - size_pad.y - decoration_h_without_scrollbars < size_contents.y && !(.NoScrollbar in window.Flags)) || (.AlwaysVerticalScrollbar in window.Flags);
        if (will_have_scrollbar_x) {
            size_auto_fit.y += style.ScrollbarSize;
        }
        if (will_have_scrollbar_y) {
            size_auto_fit.x += style.ScrollbarSize;
        }
        return size_auto_fit;
    }
}

CalcWindowNextAutoFitSize :: proc(window : ^ImGuiWindow) -> ImVec2
{
    size_contents_current : ImVec2
    size_contents_ideal : ImVec2
    CalcWindowContentSizes(window, &size_contents_current, &size_contents_ideal);
    size_auto_fit := CalcWindowAutoFitSize(window, size_contents_ideal);
    size_final := CalcWindowSizeAfterConstraint(window, size_auto_fit);
    return size_final;
}

GetWindowBgColorIdx :: proc(window : ^ImGuiWindow) -> ImGuiCol
{
    if (window.Flags & (ImGuiWindowFlags_Tooltip | ImGuiWindowFlags_Popup))   do return ImGuiCol.PopupBg
    if ((.ChildWindow in window.Flags) && !window.DockIsActive)   do return ImGuiCol.ChildBg
    return ImGuiCol.WindowBg;
}

CalcResizePosSizeFromAnyCorner :: proc(window : ^ImGuiWindow, corner_target : ImVec2, corner_norm : ImVec2, out_pos : ^ImVec2, out_size : ^ImVec2)
{
    pos_min := ImLerp(corner_target, window.Pos, corner_norm);                // Expected window upper-left
    pos_max := ImLerp(window.Pos + window.Size, corner_target, corner_norm); // Expected window lower-right
    size_expected := pos_max - pos_min;
    size_constrained := CalcWindowSizeAfterConstraint(window, size_expected);
    out_pos^ = pos_min;
    if (corner_norm.x == 0.0) {
        out_pos.x -= (size_constrained.x - size_expected.x);
    }
    if (corner_norm.y == 0.0) {
        out_pos.y -= (size_constrained.y - size_expected.y);
    }
    out_size^ = size_constrained;
}

// Data for resizing from resize grip / corner
ImGuiResizeGripDef :: struct
{
    CornerPosN : ImVec2,
    InnerDir : ImVec2,
    AngleMin12, AngleMax12 : i32,
};
resize_grip_def := [4]ImGuiResizeGripDef {
    { ImVec2{1, 1}, ImVec2{-1, -1}, 0, 3 },  // Lower-right
    { ImVec2{0, 1}, ImVec2{+1, -1}, 3, 6 },  // Lower-left
    { ImVec2{0, 0}, ImVec2{+1, +1}, 6, 9 },  // Upper-left (Unused)
    { ImVec2{1, 0}, ImVec2{-1, +1}, 9, 12 }  // Upper-right (Unused)
};

// Data for resizing from borders
ImGuiResizeBorderDef :: struct
{
    InnerDir : ImVec2,               // Normal toward inside
    SegmentN1, SegmentN2 : ImVec2,   // End positions, normalized (0,0: upper left)
    OuterAngle : f32,             // Angle toward outside
};
resize_border_def := [4]ImGuiResizeBorderDef {
    { ImVec2{+1, 0}, ImVec2{0, 1}, ImVec2{0, 0}, IM_PI * 1.00 }, // Left
    { ImVec2{-1, 0}, ImVec2{1, 0}, ImVec2{1, 1}, IM_PI * 0.00 }, // Right
    { ImVec2{0, +1}, ImVec2{0, 0}, ImVec2{1, 0}, IM_PI * 1.50 }, // Up
    { ImVec2{0, -1}, ImVec2{1, 1}, ImVec2{0, 1}, IM_PI * 0.50 }  // Down
};

GetResizeBorderRect :: proc(window : ^ImGuiWindow, border_n : i32, perp_padding : f32, thickness : f32) -> ImRect
{
    rect := Rect(window);
    if (thickness == 0.0)   do rect.Max -= ImVec2{1, 1}
    if (border_n == .Left)  { return ImRect{ _r = {rect.Min.x - thickness,    rect.Min.y + perp_padding, rect.Min.x + thickness,    rect.Max.y - perp_padding}}; }
    if (border_n == .Right) { return ImRect{ _r = {rect.Max.x - thickness,    rect.Min.y + perp_padding, rect.Max.x + thickness,    rect.Max.y - perp_padding}}; }
    if (border_n == ImGuiDir.Up)    { return ImRect{ _r = {rect.Min.x + perp_padding, rect.Min.y - thickness,    rect.Max.x - perp_padding, rect.Min.y + thickness}};    }
    if (border_n == ImGuiDir.Down)  { return ImRect{ _r = {rect.Min.x + perp_padding, rect.Max.y - thickness,    rect.Max.x - perp_padding, rect.Max.y + thickness}};    }
    assert(false)
    return ImRect();
}

// 0..3: corners (Lower-right, Lower-left, Unused, Unused)
// [forward declared comment]:
// 0..3: corners
GetWindowResizeCornerID :: proc(window : ^ImGuiWindow, n : i32) -> ImGuiID
{
    assert(n >= 0 && n < 4);
    id := window.DockIsActive ? window.DockNode.HostWindow.ID : window.ID;
    id = ImHashStr("#RESIZE", 0, id);
    id = ImHashData(&n, size_of(i32), id);
    return id;
}

// Borders (Left, Right, Up, Down)
GetWindowResizeBorderID :: proc(window : ^ImGuiWindow, dir : ImGuiDir) -> ImGuiID
{
    assert(dir >= 0 && dir < 4);
    n := cast(i32) dir + 4;
    id := window.DockIsActive ? window.DockNode.HostWindow.ID : window.ID;
    id = ImHashStr("#RESIZE", 0, id);
    id = ImHashData(&n, size_of(i32), id);
    return id;
}

// Handle resize for: Resize Grips, Borders, Gamepad
// Return true when using auto-fit (double-click on resize grip)
UpdateWindowManualResize :: proc(window : ^ImGuiWindow, size_auto_fit : ImVec2, border_hovered : ^i32, border_held : ^i32, resize_grip_count : i32, resize_grip_col : ^[4]u32, visibility_rect : ImRect) -> i32
{
    g := GImGui;
    flags := window.Flags;

    if ((.NoResize in flags) || (.AlwaysAutoResize in flags) || window.AutoFitFramesX > 0 || window.AutoFitFramesY > 0)   do return 0
    if (window.WasActive == false) { // Early out to avoid running this code for e.g. a hidden implicit/fallback Debug window.
        return 0;
    }

    ret_auto_fit_mask := 0x00;
    grip_draw_size := math.trunc(ImMax(g.FontSize * 1.35, window.WindowRounding + 1.0 + g.FontSize * 0.2));
    grip_hover_inner_size := (resize_grip_count > 0) ? math.trunc(grip_draw_size * 0.75) : 0.0;
    grip_hover_outer_size := g.IO.ConfigWindowsResizeFromEdges ? WINDOWS_HOVER_PADDING : 0.0;

    clamp_rect := visibility_rect;
    window_move_from_title_bar := g.IO.ConfigWindowsMoveFromTitleBarOnly && !(.NoTitleBar in window.Flags);
    if (window_move_from_title_bar) {
        clamp_rect.Min.y -= window.TitleBarHeight;
    }

    pos_target := ImVec2{math.F32_MAX, math.F32_MAX};
    size_target := ImVec2{math.F32_MAX, math.F32_MAX};

    // Clip mouse interaction rectangles within the viewport rectangle (in practice the narrowing is going to happen most of the time).
    // - Not narrowing would mostly benefit the situation where OS windows _without_ decoration have a threshold for hovering when outside their limits.
    //   This is however not the case with current backends under Win32, but a custom borderless window implementation would benefit from it.
    // - When decoration are enabled we typically benefit from that distance, but then our resize elements would be conflicting with OS resize elements, so we also narrow.
    // - Note that we are unable to tell if the platform setup allows hovering with a distance threshold (on Win32, decorated window have such threshold).
    // We only clip interaction so we overwrite window.ClipRect, cannot call PushClipRect() yet as DrawList is not yet setup.
    clip_with_viewport_rect := !(.HasMouseHoveredViewport in g.IO.BackendFlags) || (g.IO.MouseHoveredViewport != window.ViewportId) || !(window.Viewport.Flags & ImGuiViewportFlags_NoDecoration);
    if (clip_with_viewport_rect) {
        window.ClipRect = GetMainRect(window.Viewport);
    }

    // Resize grips and borders are on layer 1
    window.DC.NavLayerCurrent = ImGuiNavLayer_Menu;

    // Manual resize grips
    PushID("#RESIZE");
    for resize_grip_n := 0; resize_grip_n < resize_grip_count; resize_grip_n += 1
    {
        def := &resize_grip_def[resize_grip_n];
        corner := ImLerp(window.Pos, window.Pos + window.Size, def.CornerPosN);

        // Using the FlattenChilds button flag we make the resize button accessible even if we are hovering over a child window
        hovered, held : bool
        resize_rect := ImRect{ _v = {corner - def.InnerDir * grip_hover_outer_size, corner + def.InnerDir * grip_hover_inner_size}};
        if (resize_rect.Min.x > resize_rect.Max.x) do ImSwap(resize_rect.Min.x, resize_rect.Max.x);
        if (resize_rect.Min.y > resize_rect.Max.y) do ImSwap(resize_rect.Min.y, resize_rect.Max.y);
        resize_grip_id := GetID(window, resize_grip_n); // == GetWindowResizeCornerID()
        ItemAdd(resize_rect, resize_grip_id, nil, ImGuiItemFlags_NoNav);
        ButtonBehavior(resize_rect, resize_grip_id, &hovered, &held, ImGuiButtonFlags_FlattenChildren | ImGuiButtonFlags_NoNavFocus);
        //GetForegroundDrawList(window)->AddRect(resize_rect.Min, resize_rect.Max, IM_COL32(255, 255, 0, 255));
        if (hovered || held) {
            SetMouseCursor((resize_grip_n & 1) ? ImGuiMouseCursor_ResizeNESW : ImGuiMouseCursor_ResizeNWSE);
        }

        if (held && g.IO.MouseDoubleClicked[0])
        {
            // Auto-fit when double-clicking
            size_target = CalcWindowSizeAfterConstraint(window, size_auto_fit);
            ret_auto_fit_mask = 0x03; // Both axises
            ClearActiveID();
        }
        else if (held)
        {
            // Resize from any of the four corners
            // We don't use an incremental MouseDelta but rather compute an absolute target size based on mouse position
            clamp_min := ImVec2{def.CornerPosN.x == 1.0 ? clamp_rect.Min.x : -math.F32_MAX, (def.CornerPosN.y == 1.0 || (def.CornerPosN.y == 0.0 && window_move_from_title_bar)) ? clamp_rect.Min.y : -math.F32_MAX};
            clamp_max := ImVec2{def.CornerPosN.x == 0.0 ? clamp_rect.Max.x : +math.F32_MAX, def.CornerPosN.y == 0.0 ? clamp_rect.Max.y : +math.F32_MAX};
            corner_target := g.IO.MousePos - g.ActiveIdClickOffset + ImLerp(def.InnerDir * grip_hover_outer_size, def.InnerDir * -grip_hover_inner_size, def.CornerPosN); // Corner of the window corresponding to our corner grip
            corner_target = ImClamp(corner_target, clamp_min, clamp_max);
            CalcResizePosSizeFromAnyCorner(window, corner_target, def.CornerPosN, &pos_target, &size_target);
        }

        // Only lower-left grip is visible before hovering/activating
        if (resize_grip_n == 0 || held || hovered) {
            resize_grip_col[resize_grip_n] = GetColorU32(held ? ImGuiCol.ResizeGripActive : hovered ? ImGuiCol.ResizeGripHovered : ImGuiCol.ResizeGrip);
        }
    }

    resize_border_mask := 0x00;
    if (.ChildWindow in window.Flags) {
        resize_border_mask |= ((.ResizeX in window.ChildFlags) ? 0x02 : 0) | ((.ResizeY in window.ChildFlags) ? 0x08 : 0);
    }
    else {
        resize_border_mask = g.IO.ConfigWindowsResizeFromEdges ? 0x0F : 0x00;
    }
    for border_n := 0; border_n < 4; border_n += 1
    {
        if ((resize_border_mask & (1 << border_n)) == 0)   do continue
        def := &resize_border_def[border_n];
        axis := (border_n == .Left || border_n == .Right) ? ImGuiAxis.X : ImGuiAxis.Y;

        hovered, held : bool
        border_rect := GetResizeBorderRect(window, border_n, grip_hover_inner_size, WINDOWS_HOVER_PADDING);
        border_id := GetID(window, border_n + 4); // == GetWindowResizeBorderID()
        ItemAdd(border_rect, border_id, nil, ImGuiItemFlags_NoNav);
        ButtonBehavior(border_rect, border_id, &hovered, &held, ImGuiButtonFlags_FlattenChildren | ImGuiButtonFlags_NoNavFocus);
        //GetForegroundDrawList(window)->AddRect(border_rect.Min, border_rect.Max, IM_COL32(255, 255, 0, 255));
        if (hovered && g.HoveredIdTimer <= WINDOWS_RESIZE_FROM_EDGES_FEEDBACK_TIMER)   do hovered = false
        if (hovered || held) {
            SetMouseCursor((axis == ImGuiAxis.X) ? ImGuiMouseCursor_ResizeEW : ImGuiMouseCursor_ResizeNS);
        }
        if (held && g.IO.MouseDoubleClicked[0])
        {
            // Double-clicking bottom or right border auto-fit on this axis
            // FIXME: CalcWindowAutoFitSize() doesn't take into account that only one side may be auto-fit when calculating scrollbars.
            // FIXME: Support top and right borders: rework CalcResizePosSizeFromAnyCorner() to be reusable in both cases.
            if (border_n == 1 || border_n == 3) // Right and bottom border
            {
                size_target[axis] = CalcWindowSizeAfterConstraint(window, size_auto_fit)[axis];
                ret_auto_fit_mask |= (1 << axis);
                hovered = false
                held = false; // So border doesn't show highlighted at new position
            }
            ClearActiveID();
        }
        else if (held)
        {
            // Switch to relative resizing mode when border geometry moved (e.g. resizing a child altering parent scroll), in order to avoid resizing feedback loop.
            // Currently only using relative mode on resizable child windows, as the problem to solve is more likely noticeable for them, but could apply for all windows eventually.
            // FIXME: May want to generalize this idiom at lower-level, so more widgets can use it!
            just_scrolled_manually_while_resizing := (g.WheelingWindow != nil && g.WheelingWindowScrolledFrame == g.FrameCount && IsWindowChildOf(window, g.WheelingWindow, false, true));
            if (g.ActiveIdIsJustActivated || just_scrolled_manually_while_resizing)
            {
                g.WindowResizeBorderExpectedRect = border_rect;
                g.WindowResizeRelativeMode = false;
            }
            if ((.ChildWindow in window.Flags) && memcmp(&g.WindowResizeBorderExpectedRect, &border_rect, size_of(ImRect)) != 0) {
                g.WindowResizeRelativeMode = true;
            }

            border_curr := (window.Pos + ImMin(def.SegmentN1, def.SegmentN2) * window.Size);
            border_target_rel_mode_for_axis := border_curr[axis] + g.IO.MouseDelta[axis];
            border_target_abs_mode_for_axis := g.IO.MousePos[axis] - g.ActiveIdClickOffset[axis] + WINDOWS_HOVER_PADDING; // Match ButtonBehavior() padding above.

            // Use absolute mode position
            border_target := window.Pos;
            border_target[axis] = border_target_abs_mode_for_axis;

            // Use relative mode target for child window, ignore resize when moving back toward the ideal absolute position.
            ignore_resize := false;
            if (g.WindowResizeRelativeMode)
            {
                //GetForegroundDrawList()->AddText(GetMainViewport()->WorkPos, IM_COL32_WHITE, "Relative Mode");
                border_target[axis] = border_target_rel_mode_for_axis;
                if (g.IO.MouseDelta[axis] == 0.0 || (g.IO.MouseDelta[axis] > 0.0) == (border_target_rel_mode_for_axis > border_target_abs_mode_for_axis))   do ignore_resize = true
            }

            // Clamp, apply
            clamp_min := ImVec2(border_n == .Right ? clamp_rect.Min.x : -math.F32_MAX, border_n == ImGuiDir.Down || (border_n == ImGuiDir.Up && window_move_from_title_bar) ? clamp_rect.Min.y : -math.F32_MAX);
            clamp_max := ImVec2{border_n == .Left ? clamp_rect.Max.x : +math.F32_MAX, border_n == ImGuiDir.Up ? clamp_rect.Max.y : +math.F32_MAX};
            border_target = ImClamp(border_target, clamp_min, clamp_max);
            if (.ChildWindow in flags) // Clamp resizing of childs within parent
            {
                parent_window := window.ParentWindow;
                parent_flags := parent_window.Flags;
                border_limit_rect := parent_window.InnerRect;
                border_limit_rect.Expand(ImVec2{-ImMax(parent_window.WindowPadding.x, parent_window.WindowBorderSize), -ImMax(parent_window.WindowPadding.y, parent_window.WindowBorderSize)});
                if ((axis == ImGuiAxis.X) && ((parent_flags & (ImGuiWindowFlags_HorizontalScrollbar | ImGuiWindowFlags_AlwaysHorizontalScrollbar)) == 0 || (.NoScrollbar in parent_flags))) {
                    border_target.x = ImClamp(border_target.x, border_limit_rect.Min.x, border_limit_rect.Max.x);
                }
                if ((axis == ImGuiAxis.Y) && (.NoScrollbar in parent_flags)) {
                    border_target.y = ImClamp(border_target.y, border_limit_rect.Min.y, border_limit_rect.Max.y);
                }
            }
            if (!ignore_resize) {
                CalcResizePosSizeFromAnyCorner(window, border_target, ImMin(def.SegmentN1, def.SegmentN2), &pos_target, &size_target);
            }
        }
        if (hovered)   do border_hovered^ = border_n;
        if (held)   do border_held^ = border_n
    }
    PopID();

    // Restore nav layer
    window.DC.NavLayerCurrent = ImGuiNavLayer_Main;

    // Navigation resize (keyboard/gamepad)
    // FIXME: This cannot be moved to NavUpdateWindowing() because CalcWindowSizeAfterConstraint() need to callback into user.
    // Not even sure the callback works here.
    if (g.NavWindowingTarget && g.NavWindowingTarget.RootWindowDockTree == window)
    {
        nav_resize_dir : ImVec2
        if (g.NavInputSource == .Keyboard && g.IO.KeyShift) {
            nav_resize_dir = GetKeyMagnitude2d(ImGuiKey.LeftArrow, ImGuiKey.RightArrow, ImGuiKey.UpArrow, ImGuiKey.DownArrow);
        }
        if (g.NavInputSource == .Gamepad) {
            nav_resize_dir = GetKeyMagnitude2d(ImGuiKey.GamepadDpadLeft, ImGuiKey.GamepadDpadRight, ImGuiKey.GamepadDpadUp, ImGuiKey.GamepadDpadDown);
        }
        if (nav_resize_dir.x != 0.0 || nav_resize_dir.y != 0.0)
        {
            NAV_RESIZE_SPEED := 600.0;
            resize_step := NAV_RESIZE_SPEED * g.IO.DeltaTime * ImMin(g.IO.DisplayFramebufferScale.x, g.IO.DisplayFramebufferScale.y);
            g.NavWindowingAccumDeltaSize += nav_resize_dir * resize_step;
            g.NavWindowingAccumDeltaSize = ImMax(g.NavWindowingAccumDeltaSize, clamp_rect.Min - window.Pos - window.Size); // We need Pos+Size >= clmap_rect.Min, so Size >= clmap_rect.Min - Pos, so size_delta >= clmap_rect.Min - window.Pos - window.Size
            g.NavWindowingToggleLayer = false;
            g.NavHighlightItemUnderNav = true;
            resize_grip_col[0] = GetColorU32(ImGuiCol.ResizeGripActive);
            accum_floored := ImTrunc(g.NavWindowingAccumDeltaSize);
            if (accum_floored.x != 0.0 || accum_floored.y != 0.0)
            {
                // FIXME-NAV: Should store and accumulate into a separate size buffer to handle sizing constraints properly, right now a constraint will make us stuck.
                size_target = CalcWindowSizeAfterConstraint(window, window.SizeFull + accum_floored);
                g.NavWindowingAccumDeltaSize -= accum_floored;
            }
        }
    }

    // Apply back modified position/size to window
    curr_pos := window.Pos;
    curr_size := window.SizeFull;
    if (size_target.x != math.F32_MAX && (window.Size.x != size_target.x || window.SizeFull.x != size_target.x)) {
        window.SizeFull.x = size_target.x;
        window.Size.x = size_target.x;
    }
    if (size_target.y != math.F32_MAX && (window.Size.y != size_target.y || window.SizeFull.y != size_target.y)) {
        window.SizeFull.y = size_target.y;
        window.Size.y = size_target.y;
    }
    if (pos_target.x != math.F32_MAX && window.Pos.x != ImTrunc(pos_target.x)) {
        window.Pos.x = ImTrunc(pos_target.x);
    }
    if (pos_target.y != math.F32_MAX && window.Pos.y != ImTrunc(pos_target.y)) {
        window.Pos.y = ImTrunc(pos_target.y);
    }
    if (curr_pos.x != window.Pos.x || curr_pos.y != window.Pos.y || curr_size.x != window.SizeFull.x || curr_size.y != window.SizeFull.y) {
        MarkIniSettingsDirty(window);
    }

    // Recalculate next expected border expected coordinates
    if (border_held^ != -1) {
        g.WindowResizeBorderExpectedRect = GetResizeBorderRect(window, border_held^, grip_hover_inner_size, WINDOWS_HOVER_PADDING);
    }

    return ret_auto_fit_mask;
}

ClampWindowPos :: #force_inline proc(window : ^ImGuiWindow, visibility_rect : ImRect)
{
    g := GImGui;
    size_for_clamping := window.Size;
    if (g.IO.ConfigWindowsMoveFromTitleBarOnly && window.DockNodeAsHost) {
        size_for_clamping.y = GetFrameHeight(); // Not using window.TitleBarHeight() as DockNodeAsHost will report 0.0f here.
    }
    else if (g.IO.ConfigWindowsMoveFromTitleBarOnly && !(.NoTitleBar in window.Flags)) {
        size_for_clamping.y = window.TitleBarHeight;
    }
    window.Pos = ImClamp(window.Pos, visibility_rect.Min - size_for_clamping, visibility_rect.Max);
}

RenderWindowOuterSingleBorder :: proc(window : ^ImGuiWindow, border_n : i32, border_col : u32, border_size : f32)
{
    def := &resize_border_def[border_n];
    rounding := window.WindowRounding;
    border_r := GetResizeBorderRect(window, border_n, rounding, 0.0);
    window.DrawList.PathArcTo(ImLerp(border_r.Min, border_r.Max, def.SegmentN1) + ImVec2{0.5, 0.5} + def.InnerDir * rounding, rounding, def.OuterAngle - IM_PI * 0.25, def.OuterAngle);
    window.DrawList.PathArcTo(ImLerp(border_r.Min, border_r.Max, def.SegmentN2) + ImVec2{0.5, 0.5} + def.InnerDir * rounding, rounding, def.OuterAngle, def.OuterAngle + IM_PI * 0.25);
    window.DrawList.PathStroke(border_col, ImDrawFlags_None, border_size);
}

RenderWindowOuterBorders :: proc(window : ^ImGuiWindow)
{
    g := GImGui;
    border_size := window.WindowBorderSize;
    border_col := GetColorU32(ImGuiCol.Border);
    if (border_size > 0.0 && (.NoBackground not_in window.Flags)) {
        window.DrawList.AddRect(window.Pos, window.Pos + window.Size, border_col, window.WindowRounding, 0, window.WindowBorderSize);
    }
    else if (border_size > 0.0)    
    {
        if (.ResizeX in window.ChildFlags) {// Similar code as 'resize_border_mask' computation in UpdateWindowManualResize() but we specifically only always draw explicit child resize border.
            RenderWindowOuterSingleBorder(window, 1, border_col, border_size);
        }
        if (.ResizeY in window.ChildFlags) {
            RenderWindowOuterSingleBorder(window, 3, border_col, border_size);
        }
    }
    if (window.ResizeBorderHovered != -1 || window.ResizeBorderHeld != -1)
    {
        border_n := (window.ResizeBorderHeld != -1) ? window.ResizeBorderHeld : window.ResizeBorderHovered;
        border_col_resizing := GetColorU32((window.ResizeBorderHeld != -1) ? ImGuiCol.SeparatorActive : ImGuiCol.SeparatorHovered);
        RenderWindowOuterSingleBorder(window, border_n, border_col_resizing, ImMax(2.0, window.WindowBorderSize)); // Thicker than usual
    }
    if (g.Style.FrameBorderSize > 0 && !(.NoTitleBar in window.Flags) && !window.DockIsActive)
    {
        y := window.Pos.y + window.TitleBarHeight - 1;
        AddLine(window.DrawList, ImVec2{window.Pos.x + border_size, y}, ImVec2{window.Pos.x + window.Size.x - border_size, y}, border_col, g.Style.FrameBorderSize);
    }
}

// Draw background and borders
// Draw and handle scrollbars
RenderWindowDecorations :: proc(window : ^ImGuiWindow, title_bar_rect : ImRect, title_bar_is_highlight : bool, handle_borders_and_resize_grips : bool, resize_grip_count : i32, resize_grip_col : [4]u32, resize_grip_draw_size : f32)
{
    g := GImGui;
    style := &g.Style;
    flags := window.Flags;

    // Ensure that Scrollbar() doesn't read last frame's SkipItems
    assert(window.BeginCount == 0);
    window.SkipItems = false;
    window.DC.NavLayerCurrent = ImGuiNavLayer_Menu;

    // Draw window + handle manual resize
    // As we highlight the title bar when want_focus is set, multiple reappearing windows will have their title bar highlighted on their reappearing frame.
    window_rounding := window.WindowRounding;
    window_border_size := window.WindowBorderSize;
    if (window.Collapsed)
    {
        // Title bar only
        backup_border_size := style.FrameBorderSize;
        g.Style.FrameBorderSize = window.WindowBorderSize;
        title_bar_col := GetColorU32((title_bar_is_highlight && g.NavCursorVisible) ? ImGuiCol.TitleBgActive : ImGuiCol.TitleBgCollapsed);
        if (window.ViewportOwned)  do title_bar_col |= IM_COL32_A_MASK; // No alpha (we don't support is_docking_transparent_payload here because simpler and less meaningful, but could with a bit of code shuffle/reuse)
        RenderFrame(title_bar_rect.Min, title_bar_rect.Max, title_bar_col, true, window_rounding);
        g.Style.FrameBorderSize = backup_border_size;
    }
    else
    {
        // Window background
        if (!(.NoBackground in flags))
        {
            is_docking_transparent_payload := false;
            if (g.DragDropActive && (g.FrameCount - g.DragDropAcceptFrameCount) <= 1 && g.IO.ConfigDockingTransparentPayload) {
                if (g.DragDropPayload.IsDataType(IMGUI_PAYLOAD_TYPE_WINDOW) && (cast(^^ImGuiWindow)g.DragDropPayload.Data)^ == window) {
                    is_docking_transparent_payload = true;
                }
            }

            bg_col := GetColorU32(GetWindowBgColorIdx(window));
            if (window.ViewportOwned)
            {
                bg_col |= IM_COL32_A_MASK; // No alpha
                if (is_docking_transparent_payload) {
                    window.Viewport.Alpha *= DOCKING_TRANSPARENT_PAYLOAD_ALPHA;
                }
            }
            else
            {
                // Adjust alpha. For docking
                override_alpha := false;
                alpha := 1.0;
                if (.HasBgAlpha in g.NextWindowData.Flags)
                {
                    alpha = g.NextWindowData.BgAlphaVal;
                    override_alpha = true;
                }
                if (is_docking_transparent_payload)
                {
                    alpha *= DOCKING_TRANSPARENT_PAYLOAD_ALPHA; // FIXME-DOCK: Should that be an override?
                    override_alpha = true;
                }
                if (override_alpha) {
                    bg_col = (bg_col & ~IM_COL32_A_MASK) | (IM_F32_TO_INT8_SAT(alpha) << IM_COL32_A_SHIFT);
                }
            }

            // Render, for docked windows and host windows we ensure bg goes before decorations
            if (window.DockIsActive) {
                window.DockNode.LastBgColor = bg_col;
            }
            bg_draw_list := window.DockIsActive ? window.DockNode.HostWindow.DrawList : window.DrawList;
            if (window.DockIsActive || (.DockNodeHost in flags)) {
                bg_draw_list.ChannelsSetCurrent(DOCKING_HOST_DRAW_CHANNEL_BG);
            }
            bg_AddRectFilled(draw_list, window.Pos + ImVec2{0, window.TitleBarHeight}, window.Pos + window.Size, bg_col, window_rounding, (.NoTitleBar in flags) ? 0 : ImDrawFlags_RoundCornersBottom);
            if (window.DockIsActive || (.DockNodeHost in flags)) {
                bg_draw_list.ChannelsSetCurrent(DOCKING_HOST_DRAW_CHANNEL_FG);
            }
        }
        if (window.DockIsActive) {
            window.DockNode.IsBgDrawnThisFrame = true;
        }

        // Title bar
        // (when docked, DockNode are drawing their own title bar. Individual windows however do NOT set the _NoTitleBar flag,
        // in order for their pos/size to be matching their undocking state.)
        if (!(.NoTitleBar in flags) && !window.DockIsActive)
        {
            title_bar_col := GetColorU32(title_bar_is_highlight ? ImGuiCol.TitleBgActive : ImGuiCol.TitleBg);
            if (window.ViewportOwned) {
                title_bar_col |= IM_COL32_A_MASK; // No alpha
            }
            AddRectFilled(window.DrawList, title_bar_rect.Min, title_bar_rect.Max, title_bar_col, window_rounding, ImDrawFlags_RoundCornersTop);
        }

        // Menu bar
        if (.MenuBar in flags)
        {
            menu_bar_rect := window.MenuBarRect();
            menu_bar_rect.ClipWith(Rect(window));  // Soft clipping, in particular child window don't have minimum size covering the menu bar so this is useful for them.
            AddRectFilled(window.DrawList, menu_bar_rect.Min + ImVec2{window_border_size, 0}, menu_bar_rect.Max - ImVec2{window_border_size, 0}, GetColorU32(ImGuiCol.MenuBarBg), (.NoTitleBar in flags) ? window_rounding : 0.0, ImDrawFlags_RoundCornersTop);
            if (style.FrameBorderSize > 0.0 && menu_bar_rect.Max.y < window.Pos.y + window.Size.y) {
                AddLine(window.DrawList, menu_bar_rect.GetBL(), menu_bar_rect.GetBR(), GetColorU32(ImGuiCol.Border), style.FrameBorderSize);
            }
        }

        // Docking: Unhide tab bar (small triangle in the corner), drag from small triangle to quickly undock
        node := window.DockNode;
        if (window.DockIsActive && node.IsHiddenTabBar() && !node.IsNoTabBar())
        {
            unhide_sz_draw := ImTrunc(g.FontSize * 0.70);
            unhide_sz_hit := ImTrunc(g.FontSize * 0.55);
            p := node.Pos;
            r := ImRect(p, p + ImVec2{unhide_sz_hit, unhide_sz_hit});
            unhide_id := GetID(window, "#UNHIDE");
            KeepAliveID(unhide_id);
            hovered, held : bool
            if (ButtonBehavior(r, unhide_id, &hovered, &held, ImGuiButtonFlags_FlattenChildren)) {
                node.WantHiddenTabBarToggle = true;
            }
            else if (held && IsMouseDragging(0)) {
                StartMouseMovingWindowOrNode(window, node, true); // Undock from tab-bar triangle = same as window/collapse menu button
            }

            // FIXME-DOCK: Ideally we'd use ImGuiCol.TitleBgActive/ImGuiCol.TitleBg here, but neither is guaranteed to be visible enough at this sort of size..
            col := GetColorU32(((held && hovered) || (node.IsFocused && !hovered)) ? ImGuiCol.ButtonActive : hovered ? ImGuiCol.ButtonHovered : ImGuiCol.Button);
            window.DrawList.AddTriangleFilled(p, p + ImVec2{unhide_sz_draw, 0.0}, p + ImVec2{0.0, unhide_sz_draw}, col);
        }

        // Scrollbars
        if (window.ScrollbarX)   do Scrollbar(ImGuiAxis.X)
        if (window.ScrollbarY)   do Scrollbar(ImGuiAxis.Y)

        // Render resize grips (after their input handling so we don't have a frame of latency)
        if (handle_borders_and_resize_grips && !(.NoResize in flags))
        {
            for resize_grip_n := 0; resize_grip_n < resize_grip_count; resize_grip_n += 1
            {
                col := resize_grip_col[resize_grip_n];
                if ((col & IM_COL32_A_MASK) == 0)   do continue
                grip := &resize_grip_def[resize_grip_n];
                corner := ImLerp(window.Pos, window.Pos + window.Size, grip.CornerPosN);
                window.DrawList.PathLineTo(corner + grip.InnerDir * ((resize_grip_n & 1) ? ImVec2{window_border_size, resize_grip_draw_size} : ImVec2{resize_grip_draw_size, window_border_size}));
                window.DrawList.PathLineTo(corner + grip.InnerDir * ((resize_grip_n & 1) ? ImVec2{resize_grip_draw_size, window_border_size} : ImVec2{window_border_size, resize_grip_draw_size}));
                window.DrawList.PathArcToFast(ImVec2{corner.x + grip.InnerDir.x * (window_rounding + window_border_size), corner.y + grip.InnerDir.y * (window_rounding + window_border_size)}, window_rounding, grip.AngleMin12, grip.AngleMax12);
                window.DrawList.PathFillConvex(col);
            }
        }

        // Borders (for dock node host they will be rendered over after the tab bar)
        if (handle_borders_and_resize_grips && !window.DockNodeAsHost) {
            RenderWindowOuterBorders(window);
        }
    }
    window.DC.NavLayerCurrent = ImGuiNavLayer_Main;
}

// When inside a dock node, this is handled in DockNodeCalcTabBarLayout() instead.
// Render title text, collapse button, close button
RenderWindowTitleBarContents :: proc(window : ^ImGuiWindow, title_bar_rect : ImRect, name : string, p_open : ^bool)
{
    g := GImGui;
    style := &g.Style;
    flags := window.Flags;

    has_close_button := (p_open != nil);
    has_collapse_button := !(.NoCollapse in flags) && (style.WindowMenuButtonPosition != nil);

    // Close & Collapse button are on the Menu NavLayer and don't default focus (unless there's nothing else on that layer)
    // FIXME-NAV: Might want (or not?) to set the equivalent of ImGuiButtonFlags_NoNavFocus so that mouse clicks on standard title bar items don't necessarily set nav/keyboard ref?
    item_flags_backup := g.CurrentItemFlags;
    g.CurrentItemFlags |= ImGuiItemFlags_NoNavDefaultFocus;
    window.DC.NavLayerCurrent = ImGuiNavLayer_Menu;

    // Layout buttons
    // FIXME: Would be nice to generalize the subtleties expressed here into reusable code.
    pad_l := style.FramePadding.x;
    pad_r := style.FramePadding.x;
    button_sz := g.FontSize;
    close_button_pos : ImVec2
    collapse_button_pos : ImVec2
    if (has_close_button)
    {
        close_button_pos = ImVec2{title_bar_rect.Max.x - pad_r - button_sz, title_bar_rect.Min.y + style.FramePadding.y};
        pad_r += button_sz + style.ItemInnerSpacing.x;
    }
    if (has_collapse_button && style.WindowMenuButtonPosition == .Right)
    {
        collapse_button_pos = ImVec2{title_bar_rect.Max.x - pad_r - button_sz, title_bar_rect.Min.y + style.FramePadding.y};
        pad_r += button_sz + style.ItemInnerSpacing.x;
    }
    if (has_collapse_button && style.WindowMenuButtonPosition == .Left)
    {
        collapse_button_pos = ImVec2{title_bar_rect.Min.x + pad_l, title_bar_rect.Min.y + style.FramePadding.y};
        pad_l += button_sz + style.ItemInnerSpacing.x;
    }

    // Collapse button (submitting first so it gets priority when choosing a navigation init fallback)
    if (has_collapse_button) {
        if (CollapseButton(GetID(window, "#COLLAPSE"), collapse_button_pos, nil)) {
            window.WantCollapseToggle = true; // Defer actual collapsing to next frame as we are too far in the Begin() function
        }
    }

    // Close button
    if (has_close_button) {
        if (CloseButton(GetID(window, "#CLOSE"), close_button_pos))   do p_open^ = false
    }

    window.DC.NavLayerCurrent = ImGuiNavLayer_Main;
    g.CurrentItemFlags = item_flags_backup;

    // Title bar text (with: horizontal alignment, avoiding collapse/close button, optional "unsaved document" marker)
    // FIXME: Refactor text alignment facilities along with RenderText helpers, this is WAY too much messy code..
    marker_size_x := (.UnsavedDocument in flags) ? button_sz * 0.80 : 0.0;
    text_size := CalcTextSize(name, nil, true) + ImVec2{marker_size_x, 0.0};

    // As a nice touch we try to ensure that centered title text doesn't get affected by visibility of Close/Collapse button,
    // while uncentered title text will still reach edges correctly.
    if (pad_l > style.FramePadding.x) {
        pad_l += g.Style.ItemInnerSpacing.x;
    }
    if (pad_r > style.FramePadding.x) {
        pad_r += g.Style.ItemInnerSpacing.x;
    }
    if (style.WindowTitleAlign.x > 0.0 && style.WindowTitleAlign.x < 1.0)
    {
        centerness := ImSaturate(1.0 - ImAbs(style.WindowTitleAlign.x - 0.5) * 2.0); // 0.0f on either edges, 1.0f on center
        pad_extend := ImMin(ImMax(pad_l, pad_r), title_bar_rect.GetWidth() - pad_l - pad_r - text_size.x);
        pad_l = ImMax(pad_l, pad_extend * centerness);
        pad_r = ImMax(pad_r, pad_extend * centerness);
    }

    layout_r := ImRect{ _r = {title_bar_rect.Min.x + pad_l, title_bar_rect.Min.y, title_bar_rect.Max.x - pad_r, title_bar_rect.Max.y}};
    clip_r := ImRect(layout_r.Min.x, layout_r.Min.y, ImMin(layout_r.Max.x + g.Style.ItemInnerSpacing.x, title_bar_rect.Max.x), layout_r.Max.y);
    if (.UnsavedDocument in flags)
    {
        marker_pos : ImVec2
        marker_pos.x = ImClamp(layout_r.Min.x + (layout_r.GetWidth() - text_size.x) * style.WindowTitleAlign.x + text_size.x, layout_r.Min.x, layout_r.Max.x);
        marker_pos.y = (layout_r.Min.y + layout_r.Max.y) * 0.5;
        if (marker_pos.x > layout_r.Min.x)
        {
            RenderBullet(window.DrawList, marker_pos, GetColorU32(ImGuiCol.Text));
            clip_r.Max.x = ImMin(clip_r.Max.x, marker_pos.x - (i32)(marker_size_x * 0.5));
        }
    }
    //if (g.IO.KeyShift) window.DrawList.AddRect(layout_r.Min, layout_r.Max, IM_COL32(255, 128, 0, 255)); // [DEBUG]
    //if (g.IO.KeyCtrl) window.DrawList.AddRect(clip_r.Min, clip_r.Max, IM_COL32(255, 128, 0, 255)); // [DEBUG]
    RenderTextClipped(layout_r.Min, layout_r.Max, name, nil, &text_size, style.WindowTitleAlign, &clip_r);
}

UpdateWindowParentAndRootLinks :: proc(window : ^ImGuiWindow, flags : ImGuiWindowFlags, parent_window : ^ImGuiWindow)
{
    window.ParentWindow = parent_window;
    window.RootWindow = window
    window.RootWindowPopupTree = window
    window.RootWindowDockTree = window
    window.RootWindowForTitleBarHighlight = window
    window.RootWindowForNav = window;
    if (parent_window && (.ChildWindow in flags) && !(.Tooltip in flags))
    {
        window.RootWindowDockTree = parent_window.RootWindowDockTree;
        if (!window.DockIsActive && !(.DockNodeHost in parent_window.Flags)) {
            window.RootWindow = parent_window.RootWindow;
        }
    }
    if (parent_window && (.Popup in flags)) {
        window.RootWindowPopupTree = parent_window.RootWindowPopupTree;
    }
    if (parent_window && !(.Modal in flags) && (flags & (ImGuiWindowFlags_ChildWindow | ImGuiWindowFlags_Popup))) {// FIXME: simply use _NoTitleBar ?
        window.RootWindowForTitleBarHighlight = parent_window.RootWindowForTitleBarHighlight;
    }
    for (window.RootWindowForNav.ChildFlags & ImGuiChildFlags_NavFlattened)
    {
        assert(window.RootWindowForNav.ParentWindow != nil);
        window.RootWindowForNav = window.RootWindowForNav.ParentWindow;
    }
}

// [EXPERIMENTAL] Called by Begin(). NextWindowData is valid at this point.
// This is designed as a toy/test-bed for
UpdateWindowSkipRefresh :: proc(window : ^ImGuiWindow)
{
    g := GImGui;
    window.SkipRefresh = false;
    if ((.HasRefreshPolicy not_in g.NextWindowData.Flags))   do return
    if (g.NextWindowData.RefreshFlagsVal & ImGuiWindowRefreshFlags_TryToAvoidRefresh)
    {
        // FIXME-IDLE: Tests for e.g. mouse clicks or keyboard while focused.
        if (window.Appearing) do return// If currently appearing
        if (window.Hidden) do return // If was hidden (previous frame) 
        if ((g.NextWindowData.RefreshFlagsVal & ImGuiWindowRefreshFlags_RefreshOnHover) && g.HoveredWindow) {
            if (window.RootWindow == g.HoveredWindow.RootWindow || IsWindowWithinBeginStackOf(g.HoveredWindow.RootWindow, window))   do return
        }
        if ((g.NextWindowData.RefreshFlagsVal & ImGuiWindowRefreshFlags_RefreshOnFocus) && g.NavWindow) {
            if (window.RootWindow == g.NavWindow.RootWindow || IsWindowWithinBeginStackOf(g.NavWindow.RootWindow, window))   do return
        }
        window.DrawList = nil;
        window.SkipRefresh = true;
    }
}

SetWindowActiveForSkipRefresh :: proc(window : ^ImGuiWindow)
{
    window.Active = true;
    for child in window.DC.ChildWindows {
        if (!child.Hidden)
        {
            child.Active = true
            child.SkipRefresh = true;
            SetWindowActiveForSkipRefresh(child);
        }
    }
}

// Push a new Dear ImGui window to add widgets to.
// - A default window called "Debug" is automatically stacked at the beginning of every frame so you can use widgets without explicitly calling a Begin/End pair.
// - Begin/End can be called multiple times during the frame with the same window name to append content.
// - The window name is used as a unique identifier to preserve window information across frames (and save rudimentary information to the .ini file).
//   You can use the "##" or "###" markers to use the same label with different id, or same id with different label. See documentation at the top of this file.
// - Return false when window is collapsed, so you can early out in your code. You always need to call ImGui::End() even if false is returned.
// - Passing 'bool* p_open' displays a Close button on the upper-right corner of the window, the pointed value will be set to false when the button is pressed.
Begin :: proc(name : string, p_open : ^bool = nil, flags : ImGuiWindowFlags = nil) -> bool
{
    flags := flags
    g := GImGui;
    style := &g.Style;
    assert(name != "");     // Window name required
    assert(g.WithinFrameScope);                  // Forgot to call ImGui::NewFrame()
    assert(g.FrameCountEnded != g.FrameCount);   // Called ImGui::Render() or ImGui::EndFrame() and haven't called ImGui::NewFrame() again yet

    // Find or create
    window := FindWindowByName(name);
    window_just_created := (window == nil);
    if (window_just_created) {
        window = CreateNewWindow(name, flags);
    }

    // [DEBUG] Debug break requested by user
    if (g.DebugBreakInWindow == window.ID)   do runtime.debug_trap()

    // Automatically disable manual moving/resizing when NoInputs is set
    if ((flags & ImGuiWindowFlags_NoInputs) == ImGuiWindowFlags_NoInputs) {
        flags |= {.NoMove, .NoResize};
    }

    current_frame := g.FrameCount;
    first_begin_of_the_frame := (window.LastFrameActive != current_frame);
    window.IsFallbackWindow = (len(g.CurrentWindowStack) == 0 && g.WithinFrameScopeWithImplicitWindow);

    // Update the Appearing flag (note: the BeginDocked() path may also set this to true later)
    window_just_activated_by_user := (window.LastFrameActive < current_frame - 1); // Not using !WasActive because the implicit "Debug" window would always toggle off.on
    if (.Popup in flags)
    {
        popup_ref := end(g.OpenPopupStack)
        window_just_activated_by_user |= (window.PopupId != popup_ref.PopupId); // We recycle popups so treat window as activated if popup id changed
        window_just_activated_by_user |= (window != popup_ref.Window);
    }

    // Update Flags, LastFrameActive, BeginOrderXXX fields
    window_was_appearing := window.Appearing;
    if (first_begin_of_the_frame)
    {
        UpdateWindowInFocusOrderList(window, window_just_created, flags);
        window.Appearing = window_just_activated_by_user;
        if (window.Appearing) {
            SetWindowConditionAllowFlags(window, {.Appearing}, true);
        }
        window.FlagsPreviousFrame = window.Flags;
        window.Flags = cast(ImGuiWindowFlags)flags;
        window.ChildFlags = (.HasChildFlags in g.NextWindowData.Flags) ? g.NextWindowData.ChildFlags : nil;
        window.LastFrameActive = current_frame;
        window.LastTimeActive = cast(f32) g.Time;
        window.BeginOrderWithinParent = 0;
        window.BeginOrderWithinContext = cast(i16)(g.WindowsActiveCount);
        g.WindowsActiveCount += 1
    }
    else
    {
        flags = window.Flags;
    }

    // Docking
    // (NB: during the frame dock nodes are created, it is possible that (window.DockIsActive == false) even though (len(window.DockNode.Windows) > 1)
    assert(window.DockNode == nil || window.DockNodeAsHost == nil); // Cannot be both
    if (.HasDock in g.NextWindowData.Flags) {
        SetWindowDock(window, g.NextWindowData.DockId, g.NextWindowData.DockCond);
    }
    if (first_begin_of_the_frame)
    {
        has_dock_node := (window.DockId != 0 || window.DockNode != nil);
        new_auto_dock_node := !has_dock_node && GetWindowAlwaysWantOwnTabBar(window);
        dock_node_was_visible := window.DockNodeIsVisible;
        dock_tab_was_visible := window.DockTabIsVisible;
        if (has_dock_node || new_auto_dock_node)
        {
            BeginDocked(window, p_open);
            flags = window.Flags;
            if (window.DockIsActive)
            {
                assert(window.DockNode != nil);
                g.NextWindowData.Flags &= ~{.HasSizeConstraint}; // Docking currently override constraints
            }

            // Amend the Appearing flag
            if (window.DockTabIsVisible && !dock_tab_was_visible && dock_node_was_visible && !window.Appearing && !window_was_appearing)
            {
                window.Appearing = true;
                SetWindowConditionAllowFlags(window, {.Appearing}, true);
            }
        }
        else
        {
            window.DockIsActive = false
            window.DockNodeIsVisible = false
            window.DockTabIsVisible = false;
        }
    }

    // Parent window is latched only on the first call to Begin() of the frame, so further append-calls can be done from a different window stack
    parent_window_in_stack := (window.DockIsActive && window.DockNode.HostWindow != nil) ? window.DockNode.HostWindow : empty(g.CurrentWindowStack) ? nil : back(g.CurrentWindowStack).Window;
    parent_window := first_begin_of_the_frame ? ((flags & {.ChildWindow, .Popup} != nil) ? parent_window_in_stack : nil) : window.ParentWindow;
    assert(parent_window != nil || !(.ChildWindow in flags));

    // We allow window memory to be compacted so recreate the base stack when needed.
    if (len(window.IDStack) == 0) {
        append(&window.IDStack, window.ID);
    }

    // Add to stack
    g.CurrentWindow = window;
    resize(&g.CurrentWindowStack, len(g.CurrentWindowStack) + 1);
    window_stack_data := back(g.CurrentWindowStack)
    window_stack_data.Window = window;
    window_stack_data.ParentLastItemDataBackup = g.LastItemData;
    window_stack_data.DisabledOverrideReenable = (.Tooltip in flags) && (g.CurrentItemFlags & ImGuiItemFlagsPrivate.Disabled) != nil;
    ErrorRecoveryStoreState(&window_stack_data.StackSizesInBegin);
    g.StackSizesInBeginForCurrentWindow = &window_stack_data.StackSizesInBegin;
    if (.ChildMenu in flags)   do g.BeginMenuDepth += 1

    // Update ->RootWindow and others pointers (before any possible call to FocusWindow)
    if (first_begin_of_the_frame)
    {
        UpdateWindowParentAndRootLinks(window, flags, parent_window);
        window.ParentWindowInBeginStack = parent_window_in_stack;

        // Focus route
        // There's little point to expose a flag to set this: because the interesting cases won't be using parent_window_in_stack,
        // Use for e.g. linking a tool window in a standalone viewport to a document window, regardless of their Begin() stack parenting. (#6798)
        window.ParentWindowForFocusRoute = (window.RootWindow != window) ? parent_window_in_stack : nil;
        if (window.ParentWindowForFocusRoute == nil && window.DockNode != nil) {
            if (window.DockNode.MergedFlags & ImGuiDockNodeFlagsPrivate.DockedWindowsInFocusRoute) != nil {
                window.ParentWindowForFocusRoute = window.DockNode.HostWindow;
            }
        }

        // Override with SetNextWindowClass() field or direct call to SetWindowParentWindowForFocusRoute()
        if (window.WindowClass.FocusRouteParentWindowId != 0)
        {
            window.ParentWindowForFocusRoute = FindWindowByID(window.WindowClass.FocusRouteParentWindowId);
            assert(window.ParentWindowForFocusRoute != nil); // Invalid value for FocusRouteParentWindowId.
        }
    }

    // Add to focus scope stack
    PushFocusScope((.NavFlattened in window.ChildFlags) ? g.CurrentFocusScopeId : window.ID);
    window.NavRootFocusScopeId = g.CurrentFocusScopeId;

    // Add to popup stacks: update OpenPopupStack[] data, push to BeginPopupStack[]
    if (.Popup in flags)
    {
        popup_ref := &g.OpenPopupStack[len(g.BeginPopupStack)];
        popup_ref.Window = window;
        popup_ref.ParentNavLayer = parent_window_in_stack.DC.NavLayerCurrent;
        append(&g.BeginPopupStack, popup_ref^);
        window.PopupId = popup_ref.PopupId;
    }

    // Process SetNextWindow***() calls
    // (FIXME: Consider splitting the HasXXX flags into X/Y components
    window_pos_set_by_api := false;
    window_size_x_set_by_api := false
    window_size_y_set_by_api := false;
    if (.HasPos in g.NextWindowData.Flags)
    {
        window_pos_set_by_api = (window.SetWindowPosAllowFlags & g.NextWindowData.PosCond) != 0;
        if (window_pos_set_by_api && ImLengthSqr(g.NextWindowData.PosPivotVal) > 0.00001)
        {
            // May be processed on the next frame if this is our first frame and we are measuring size
            // FIXME: Look into removing the branch so everything can go through this same code path for consistency.
            window.SetWindowPosVal = g.NextWindowData.PosVal;
            window.SetWindowPosPivot = g.NextWindowData.PosPivotVal;
            window.SetWindowPosAllowFlags &= ~{.Once, .FirstUseEver, .Appearing};
        }
        else
        {
            SetWindowPos(window, g.NextWindowData.PosVal, g.NextWindowData.PosCond);
        }
    }
    if (.HasSize in g.NextWindowData.Flags)
    {
        window_size_x_set_by_api = (window.SetWindowSizeAllowFlags & g.NextWindowData.SizeCond) != nil && (g.NextWindowData.SizeVal.x > 0.0);
        window_size_y_set_by_api = (window.SetWindowSizeAllowFlags & g.NextWindowData.SizeCond) != nil && (g.NextWindowData.SizeVal.y > 0.0);
        if ((.ResizeX in window.ChildFlags) && (.FirstUseEver not_in window.SetWindowSizeAllowFlags)) {// Axis-specific conditions for BeginChild()
            g.NextWindowData.SizeVal.x = window.SizeFull.x;
        }
        if ((.ResizeY in window.ChildFlags) && (.FirstUseEver not_in window.SetWindowSizeAllowFlags)) {
            g.NextWindowData.SizeVal.y = window.SizeFull.y;
        }
        SetWindowSize(window, g.NextWindowData.SizeVal, g.NextWindowData.SizeCond);
    }
    if (.HasScroll in g.NextWindowData.Flags)
    {
        if (g.NextWindowData.ScrollVal.x >= 0.0)
        {
            window.ScrollTarget.x = g.NextWindowData.ScrollVal.x;
            window.ScrollTargetCenterRatio.x = 0.0;
        }
        if (g.NextWindowData.ScrollVal.y >= 0.0)
        {
            window.ScrollTarget.y = g.NextWindowData.ScrollVal.y;
            window.ScrollTargetCenterRatio.y = 0.0;
        }
    }
    if (.HasContentSize in g.NextWindowData.Flags) {
        window.ContentSizeExplicit = g.NextWindowData.ContentSizeVal;
    }
    else if (first_begin_of_the_frame) {
        window.ContentSizeExplicit = ImVec2{0.0, 0.0};
    }
    if (.HasWindowClass in g.NextWindowData.Flags) {
        window.WindowClass = g.NextWindowData.WindowClass;
    }
    if (.HasCollapsed in g.NextWindowData.Flags) {
        SetWindowCollapsed(window, g.NextWindowData.CollapsedVal, g.NextWindowData.CollapsedCond);
    }
    if (.HasFocus in g.NextWindowData.Flags)   do FocusWindow(window)
    if (window.Appearing) {
        SetWindowConditionAllowFlags(window, {.Appearing}, false);
    }

    // [EXPERIMENTAL] Skip Refresh mode
    UpdateWindowSkipRefresh(window);

    // Nested root windows (typically tooltips) override disabled state
    if (window_stack_data.DisabledOverrideReenable && window.RootWindow == window) {
        BeginDisabledOverrideReenable();
    }

    // We intentionally set g.CurrentWindow to NULL to prevent usage until when the viewport is set, then will call SetCurrentWindow()
    g.CurrentWindow = nil;

    // When reusing window again multiple times a frame, just append content (don't need to setup again)
    if (first_begin_of_the_frame && !window.SkipRefresh)
    {
        // Initialize
        window_is_child_tooltip := (.ChildWindow in flags) && (.Tooltip in flags); // FIXME-WIP: Undocumented behavior of Child+Tooltip for pinned tooltip (#1345)
        window_just_appearing_after_hidden_for_resize := (window.HiddenFramesCannotSkipItems > 0);
        window.Active = true;
        window.HasCloseButton = (p_open != nil);
        window.ClipRect._r = ImVec4{-math.F32_MAX, -math.F32_MAX, +math.F32_MAX, +math.F32_MAX};
        resize(&window.IDStack, 1);
        _ResetForNewFrame(window.DrawList);
        window.DC.CurrentTableIdx = -1;
        if (.DockNodeHost in flags)
        {
            ChannelsSplit(window.DrawList, 2);
            ChannelsSetCurrent(window.DrawList, DOCKING_HOST_DRAW_CHANNEL_FG); // Render decorations on channel 1 as we will render the backgrounds manually later
        }

        // Restore buffer capacity when woken from a compacted state, to avoid
        if (window.MemoryCompacted) {
            GcAwakeTransientWindowBuffers(window);
        }

        // Update stored window name when it changes (which can _only_ happen with the "###" operator, so the ID would stay unchanged).
        // The title bar always display the 'name' parameter, so we only update the string storage if it needs to be visible to the end-user elsewhere.
        window_title_visible_elsewhere := false;
        if ((window.Viewport != nil && window.Viewport.Window == window) || (window.DockIsActive)) {
            window_title_visible_elsewhere = true;
        }
        else if (g.NavWindowingListWindow != nil && (.NoNavFocus not_in window.Flags))  {             // Window titles visible when using CTRL+TAB
            window_title_visible_elsewhere = true;
        }
        if (window_title_visible_elsewhere && !window_just_created && name != window.Name)
        {
            raw := transmute(^runtime.Raw_String) &window.Name
            ImStrdupcpy(cast([^]u8) raw.data, &raw.len, raw_data(name));
        }

        // UPDATE CONTENTS SIZE, UPDATE HIDDEN STATUS

        // Update contents size from last frame for auto-fitting (or use explicit size)
        CalcWindowContentSizes(window, &window.ContentSize, &window.ContentSizeIdeal);

        // FIXME: These flags are decremented before they are used. This means that in order to have these fields produce their intended behaviors
        // for one frame we must set them to at least 2, which is counter-intuitive. HiddenFramesCannotSkipItems is a more complicated case because
        // it has a single usage before this code block and may be set below before it is finally checked.
        if (window.HiddenFramesCanSkipItems > 0) {
            window.HiddenFramesCanSkipItems -= 1;
        }
        if (window.HiddenFramesCannotSkipItems > 0) {
            window.HiddenFramesCannotSkipItems -= 1;
        }
        if (window.HiddenFramesForRenderOnly > 0) {
            window.HiddenFramesForRenderOnly -= 1;
        }

        // Hide new windows for one frame until they calculate their size
        if (window_just_created && (!window_size_x_set_by_api || !window_size_y_set_by_api)) {
            window.HiddenFramesCannotSkipItems = 1;
        }

        // Hide popup/tooltip window when re-opening while we measure size (because we recycle the windows)
        // We reset Size/ContentSize for reappearing popups/tooltips early in this function, so further code won't be tempted to use the old size.
        if (window_just_activated_by_user && (flags & {.Popup, .Tooltip}) != nil)
        {
            window.HiddenFramesCannotSkipItems = 1;
            if (.AlwaysAutoResize in flags)
            {
                if (!window_size_x_set_by_api)  { window.Size.x = 0; window.SizeFull.x = 0.0 }
                if (!window_size_y_set_by_api)  { window.Size.y = 0; window.SizeFull.y = 0.0 }
                window.ContentSize = {}
                window.ContentSizeIdeal = {}
            }
        }

        // SELECT VIEWPORT
        // We need to do this before using any style/font sizes, as viewport with a different DPI may affect font sizes.

        WindowSelectViewport(window);
        SetCurrentViewport(window, window.Viewport);
        window.FontDpiScale = (.DpiEnableScaleFonts in g.IO.ConfigFlags) ? window.Viewport.DpiScale : 1.0;
        SetCurrentWindow(window);
        flags = window.Flags;

        // LOCK BORDER SIZE AND PADDING FOR THE FRAME (so that altering them doesn't cause inconsistencies)
        // We read Style data after the call to UpdateSelectWindowViewport() which might be swapping the style.

        if (!window.DockIsActive && (.ChildWindow in flags)) {
            window.WindowBorderSize = style.ChildBorderSize;
        }
        else {
            window.WindowBorderSize = ((flags & {.Popup, .Tooltip} != nil) && !(.Modal in flags)) ? style.PopupBorderSize : style.WindowBorderSize;
        }
        window.WindowPadding = style.WindowPadding;
        if (!window.DockIsActive && (.ChildWindow in flags) && !(.Popup in flags) && !(.AlwaysUseWindowPadding in window.ChildFlags) && window.WindowBorderSize == 0.0) {
            window.WindowPadding = ImVec2{0.0, (.MenuBar in flags) ? style.WindowPadding.y : 0.0};
        }

        // Lock menu offset so size calculation can use it as menu-bar windows need a minimum size.
        window.DC.MenuBarOffset.x = ImMax(ImMax(window.WindowPadding.x, style.ItemSpacing.x), g.NextWindowData.MenuBarOffsetMinVal.x);
        window.DC.MenuBarOffset.y = g.NextWindowData.MenuBarOffsetMinVal.y;
        window.TitleBarHeight = (.NoTitleBar in flags) ? 0.0 : g.FontSize + g.Style.FramePadding.y * 2.0;
        window.MenuBarHeight = (.MenuBar in flags) ? window.DC.MenuBarOffset.y + g.FontSize + g.Style.FramePadding.y * 2.0 : 0.0;

        // Depending on condition we use previous or current window size to compare against contents size to decide if a scrollbar should be visible.
        // Those flags will be altered further down in the function depending on more conditions.
        use_current_size_for_scrollbar_x := window_just_created;
        use_current_size_for_scrollbar_y := window_just_created;
        if (window_size_x_set_by_api && window.ContentSizeExplicit.x != 0.0) {
            use_current_size_for_scrollbar_x = true;
        }
        if (window_size_y_set_by_api && window.ContentSizeExplicit.y != 0.0) {// #7252
            use_current_size_for_scrollbar_y = true;
        }

        // Collapse window by double-clicking on title bar
        // At this point we don't have a clipping rectangle setup yet, so we can use the title bar area for hit detection and drawing
        if (!(.NoTitleBar in flags) && !(.NoCollapse in flags) && !window.DockIsActive)
        {
            // We don't use a regular button+id to test for double-click on title bar (mostly due to legacy reason, could be fixed),
            // so verify that we don't have items over the title bar.
            title_bar_rect := TitleBarRect(window);
            if (g.HoveredWindow == window && g.HoveredId == 0 && g.HoveredIdPreviousFrame == 0 && g.ActiveId == 0 && IsMouseHoveringRect(title_bar_rect.Min, title_bar_rect.Max)) {
                if (g.IO.MouseClickedCount[0] == 2 && GetKeyOwner(ImGuiKey.MouseLeft) == ImGuiKeyOwner_NoOwner) {
                    window.WantCollapseToggle = true;
                }
            }
            if (window.WantCollapseToggle)
            {
                window.Collapsed = !window.Collapsed;
                if (!window.Collapsed) do use_current_size_for_scrollbar_y = true;
                MarkIniSettingsDirty(window);
            }
        }
        else
        {
            window.Collapsed = false;
        }
        window.WantCollapseToggle = false;

        // SIZE

        // Outer Decoration Sizes
        // (we need to clear ScrollbarSize immediately as CalcWindowAutoFitSize() needs it and can be called from other locations).
        scrollbar_sizes_from_last_frame := window.ScrollbarSizes;
        window.DecoOuterSizeX1 = 0.0;
        window.DecoOuterSizeX2 = 0.0;
        window.DecoOuterSizeY1 = window.TitleBarHeight + window.MenuBarHeight;
        window.DecoOuterSizeY2 = 0.0;
        window.ScrollbarSizes = ImVec2{0.0, 0.0};

        // Calculate auto-fit size, handle automatic resize
        size_auto_fit := CalcWindowAutoFitSize(window, window.ContentSizeIdeal);
        if ((.AlwaysAutoResize in flags) && !window.Collapsed)
        {
            // Using SetNextWindowSize() overrides ImGuiWindowFlags_AlwaysAutoResize, so it can be used on tooltips/popups, etc.
            if (!window_size_x_set_by_api)
            {
                window.SizeFull.x = size_auto_fit.x;
                use_current_size_for_scrollbar_x = true;
            }
            if (!window_size_y_set_by_api)
            {
                window.SizeFull.y = size_auto_fit.y;
                use_current_size_for_scrollbar_y = true;
            }
        }
        else if (window.AutoFitFramesX > 0 || window.AutoFitFramesY > 0)
        {
            // Auto-fit may only grow window during the first few frames
            // We still process initial auto-fit on collapsed windows to get a window width, but otherwise don't honor ImGuiWindowFlags_AlwaysAutoResize when collapsed.
            if (!window_size_x_set_by_api && window.AutoFitFramesX > 0)
            {
                window.SizeFull.x = window.AutoFitOnlyGrows ? ImMax(window.SizeFull.x, size_auto_fit.x) : size_auto_fit.x;
                use_current_size_for_scrollbar_x = true;
            }
            if (!window_size_y_set_by_api && window.AutoFitFramesY > 0)
            {
                window.SizeFull.y = window.AutoFitOnlyGrows ? ImMax(window.SizeFull.y, size_auto_fit.y) : size_auto_fit.y;
                use_current_size_for_scrollbar_y = true;
            }
            if (!window.Collapsed) {
                MarkIniSettingsDirty(window);
            }

        }

        // Apply minimum/maximum window size constraints and final size
        window.SizeFull = CalcWindowSizeAfterConstraint(window, window.SizeFull);
        window.Size = window.Collapsed && !(.ChildWindow in flags) ? TitleBarRect(window).GetSize() : window.SizeFull;

        // POSITION

        // Popup latch its initial position, will position itself when it appears next frame
        if (window_just_activated_by_user)
        {
            window.AutoPosLastDirection = nil;
            if ((.Popup in flags) != 0 && !(.Modal in flags) && !window_pos_set_by_api) {// FIXME: BeginPopup() could use SetNextWindowPos()
                window.Pos = back(g.BeginPopupStack).OpenPopupPos;
            }
        }

        // Position child window
        if (.ChildWindow in flags)
        {
            assert(parent_window != nil && parent_window.Active);
            window.BeginOrderWithinParent = cast(i16)len(parent_window.DC.ChildWindows);
            append(&parent_window.DC.ChildWindows, window);
            if (!(.Popup in flags) && !window_pos_set_by_api && !window_is_child_tooltip) {
                window.Pos = parent_window.DC.CursorPos;
            }
        }

        window_pos_with_pivot := (window.SetWindowPosVal.x != math.F32_MAX && window.HiddenFramesCannotSkipItems == 0);
        if (window_pos_with_pivot) {
            SetWindowPos(window, window.SetWindowPosVal - window.Size * window.SetWindowPosPivot, 0); // Position given a pivot (e.g. for centering)
        }
        else if ((.ChildMenu in flags)) {
            window.Pos = FindBestWindowPosForPopup(window);
        }
        else if ((.Popup in flags) && !window_pos_set_by_api && window_just_appearing_after_hidden_for_resize) {
            window.Pos = FindBestWindowPosForPopup(window);
        }
        else if ((.Tooltip in flags) && !window_pos_set_by_api && !window_is_child_tooltip) {
            window.Pos = FindBestWindowPosForPopup(window);
        }

        // Late create viewport if we don't fit within our current host viewport.
        if (window.ViewportAllowPlatformMonitorExtend >= 0 && !window.ViewportOwned && !(.IsMinimized in window.Viewport.Flags)) {
            if (!Contains(GetMainRect(window.Viewport), Rect(window)))
            {
                // This is based on the assumption that the DPI will be known ahead (same as the DPI of the selection done in UpdateSelectWindowViewport)
                //ImGuiViewport* old_viewport = window.Viewport;
                window.Viewport = AddUpdateViewport(window, window.ID, window.Pos, window.Size, {.NoFocusOnAppearing});

                // FIXME-DPI
                //assert(old_viewport.DpiScale == window.Viewport.DpiScale); // FIXME-DPI: Something went wrong
                SetCurrentViewport(window, window.Viewport);
                window.FontDpiScale = (.DpiEnableScaleFonts in g.IO.ConfigFlags) ? window.Viewport.DpiScale : 1.0;
                SetCurrentWindow(window);
            }
        }

        if (window.ViewportOwned) {
            WindowSyncOwnedViewport(window, parent_window_in_stack);
        }

        // Calculate the range of allowed position for that window (to be movable and visible past safe area padding)
        // When clamping to stay visible, we will enforce that window.Pos stays inside of visibility_rect.
        viewport_rect := ImRect(GetMainRect(window.Viewport));
        viewport_work_rect := ImRect(GetWorkRect(window.Viewport));
        visibility_padding := ImMax(style.DisplayWindowPadding, style.DisplaySafeAreaPadding);
        visibility_rect := ImRect{ _v = {viewport_work_rect.Min + visibility_padding, viewport_work_rect.Max - visibility_padding}};

        // Clamp position/size so window stays visible within its viewport or monitor
        // Ignore zero-sized display explicitly to avoid losing positions if a window manager reports zero-sized window when initializing or minimizing.
        // FIXME: Similar to code in GetWindowAllowedExtentRect()
        if (!window_pos_set_by_api && !(.ChildWindow in flags))
        {
            if (!window.ViewportOwned && GetWidth(viewport_rect) > 0 && GetHeight(viewport_rect) > 0.0)
            {
                ClampWindowPos(window, visibility_rect);
            }
            else if (window.ViewportOwned && len(g.PlatformIO.Monitors) > 0)
            {
                if (g.MovingWindow != nil && window.RootWindowDockTree == g.MovingWindow.RootWindowDockTree)
                {
                    // While moving windows we allow them to straddle monitors (#7299, #3071)
                    visibility_rect = g.PlatformMonitorsFullWorkRect;
                }
                else
                {
                    // When not moving ensure visible in its monitor
                    // Lost windows (e.g. a monitor disconnected) will naturally moved to the fallback/dummy monitor aka the main viewport.
                    monitor := GetViewportPlatformMonitor(window.Viewport);
                    visibility_rect = ImRect{ _v = {monitor.WorkPos, monitor.WorkPos + monitor.WorkSize}};
                }
                Expand(&visibility_rect, -visibility_padding);
                ClampWindowPos(window, visibility_rect);
            }
        }
        window.Pos = ImTrunc(window.Pos);

        // Lock window rounding for the frame (so that altering them doesn't cause inconsistencies)
        // Large values tend to lead to variety of artifacts and are not recommended.
        if (window.ViewportOwned || window.DockIsActive) {
            window.WindowRounding = 0.0;
        }
        else {
            window.WindowRounding = (.ChildWindow in flags) ? style.ChildRounding : ((.Popup in flags) && !(.Modal in flags)) ? style.PopupRounding : style.WindowRounding;
        }

        // For windows with title bar or menu bar, we clamp to FrameHeight(FontSize + FramePadding.y * 2.0f) to completely hide artifacts.
        //if ((window.Flags & ImGuiWindowFlags_MenuBar) || !(window.Flags & ImGuiWindowFlags_NoTitleBar))
        //    window.WindowRounding = ImMin(window.WindowRounding, g.FontSize + style.FramePadding.y * 2.0f);

        // Apply window focus (new and reactivated windows are moved to front)
        want_focus := false;
        if (window_just_activated_by_user && !(.NoFocusOnAppearing in flags))
        {
            if (.Popup in flags)   do want_focus = true
            else if ((window.DockIsActive || (.ChildWindow not_in flags)) && !(.Tooltip in flags))   do want_focus = true
        }

        // [Test Engine] Register whole window in the item system (before submitting further decorations)
when IMGUI_ENABLE_TEST_ENGINE {
        if (g.TestEngineHookItems)
        {
            assert(len(window.IDStack) == 1);
            len(window.IDStack) = 0; // As window.IDStack[0] == window.ID here, make sure TestEngine doesn't erroneously see window as parent of itself.
            window.DC.NavLayerCurrent = ImGuiNavLayer_Menu;
            IMGUI_TEST_ENGINE_ITEM_ADD(window.ID, Rect(window), nil);
            IMGUI_TEST_ENGINE_ITEM_INFO(window.ID, window.Name, (g.HoveredWindow == window) ? ImGuiItemStatusFlags_HoveredRect : 0);
            len(window.IDStack) = 1;
            window.DC.NavLayerCurrent = ImGuiNavLayer_Main;

        }
}

        // Decide if we are going to handle borders and resize grips
        handle_borders_and_resize_grips := (window.DockNodeAsHost != nil || !window.DockIsActive);

        // Handle manual resize: Resize Grips, Borders, Gamepad
        border_hovered : i32 = -1; border_held : i32 = -1;
        resize_grip_col : [4]u32 = {};
        resize_grip_count : i32 = ((.ChildWindow in flags) && !(.Popup in flags)) ? 0 : g.IO.ConfigWindowsResizeFromEdges ? 2 : 1; // Allow resize from lower-left if we have the mouse cursor feedback for it.
        resize_grip_draw_size := math.trunc(ImMax(g.FontSize * 1.10, window.WindowRounding + 1.0 + g.FontSize * 0.2));
        if (handle_borders_and_resize_grips && !window.Collapsed) {
            if auto_fit_mask := UpdateWindowManualResize(window, size_auto_fit, &border_hovered, &border_held, resize_grip_count, &resize_grip_col[0], visibility_rect); auto_fit_mask != 0
            {
                if (auto_fit_mask & (1 << u32(ImGuiAxis.X)))  do use_current_size_for_scrollbar_x = true;
                if (auto_fit_mask & (1 << u32(ImGuiAxis.Y)))  do use_current_size_for_scrollbar_y = true;
            }
        }
        window.ResizeBorderHovered = cast(i8) border_hovered;
        window.ResizeBorderHeld = cast(i8) border_held;

        // Synchronize window --> viewport again and one last time (clamping and manual resize may have affected either)
        if (window.ViewportOwned)
        {
            if (!window.Viewport.PlatformRequestMove)  do window.Viewport.Pos = window.Pos;
            if (!window.Viewport.PlatformRequestResize) do window.Viewport.Size = window.Size;
            UpdateWorkRect(window.Viewport);
            viewport_rect = GetMainRect(window.Viewport);
        }

        // Save last known viewport position within the window itself (so it can be saved in .ini file and restored)
        window.ViewportPos = window.Viewport.Pos;

        // SCROLLBAR VISIBILITY

        // Update scrollbar visibility (based on the Size that was effective during last frame or the auto-resized Size).
        if (!window.Collapsed)
        {
            // When reading the current size we need to read it after size constraints have been applied.
            // Intentionally use previous frame values for InnerRect and ScrollbarSizes.
            // And when we use window.DecorationUp here it doesn't have ScrollbarSizes.y applied yet.
            avail_size_from_current_frame := ImVec2{window.SizeFull.x, window.SizeFull.y - (window.DecoOuterSizeY1 + window.DecoOuterSizeY2)};
            avail_size_from_last_frame := GetSize(window.InnerRect) + scrollbar_sizes_from_last_frame;
            needed_size_from_last_frame := window_just_created ? ImVec2{0, 0} : window.ContentSize + window.WindowPadding * 2.0;
            size_x_for_scrollbars := use_current_size_for_scrollbar_x ? avail_size_from_current_frame.x : avail_size_from_last_frame.x;
            size_y_for_scrollbars := use_current_size_for_scrollbar_y ? avail_size_from_current_frame.y : avail_size_from_last_frame.y;
            //bool scrollbar_y_from_last_frame = window.ScrollbarY; // FIXME: May want to use that in the ScrollbarX expression? How many pros vs cons?
            window.ScrollbarY = (.AlwaysVerticalScrollbar in flags) || ((needed_size_from_last_frame.y > size_y_for_scrollbars) && !(.NoScrollbar in flags));
            window.ScrollbarX = (.AlwaysHorizontalScrollbar in flags) || ((needed_size_from_last_frame.x > size_x_for_scrollbars - (window.ScrollbarY ? style.ScrollbarSize : 0.0)) && !(.NoScrollbar in flags) && (.HorizontalScrollbar in flags));
            if (window.ScrollbarX && !window.ScrollbarY) {
                window.ScrollbarY = (needed_size_from_last_frame.y > size_y_for_scrollbars - style.ScrollbarSize) && !(.NoScrollbar in flags);
            }
            window.ScrollbarSizes = ImVec2{window.ScrollbarY ? style.ScrollbarSize : 0.0, window.ScrollbarX ? style.ScrollbarSize : 0.0};

            // Amend the partially filled window.DecorationXXX values.
            window.DecoOuterSizeX2 += window.ScrollbarSizes.x;
            window.DecoOuterSizeY2 += window.ScrollbarSizes.y;
        }

        // UPDATE RECTANGLES (1- THOSE NOT AFFECTED BY SCROLLING)
        // Update various regions. Variables they depend on should be set above in this function.
        // We set this up after processing the resize grip so that our rectangles doesn't lag by a frame.

        // Outer rectangle
        // Not affected by window border size. Used by:
        // - FindHoveredWindow() (w/ extra padding when border resize is enabled)
        // - Begin() initial clipping rect for drawing window background and borders.
        // - Begin() clipping whole child
        host_rect := ((.ChildWindow in flags) && !(.Popup in flags) && !window_is_child_tooltip) ? parent_window.ClipRect : viewport_rect;
        outer_rect := Rect(window);
        title_bar_rect := TitleBarRect(window);
        window.OuterRectClipped = outer_rect;
        if (window.DockIsActive) {
            window.OuterRectClipped.Min.y += window.TitleBarHeight;
        }
        ClipWith(&window.OuterRectClipped, host_rect);

        // Inner rectangle
        // Not affected by window border size. Used by:
        // - InnerClipRect
        // - ScrollToRectEx()
        // - NavUpdatePageUpPageDown()
        // - Scrollbar()
        window.InnerRect.Min.x = window.Pos.x + window.DecoOuterSizeX1;
        window.InnerRect.Min.y = window.Pos.y + window.DecoOuterSizeY1;
        window.InnerRect.Max.x = window.Pos.x + window.Size.x - window.DecoOuterSizeX2;
        window.InnerRect.Max.y = window.Pos.y + window.Size.y - window.DecoOuterSizeY2;

        // Inner clipping rectangle.
        // - Extend a outside of normal work region up to borders.
        // - This is to allow e.g. Selectable or CollapsingHeader or some separators to cover that space.
        // - It also makes clipped items be more noticeable.
        // - And is consistent on both axis (prior to 2024/05/03 ClipRect used WindowPadding.x * 0.5f on left and right edge), see #3312
        // - Force round operator last to ensure that e.g. (int)(max.x-min.x) in user's render code produce correct result.
        // Note that if our window is collapsed we will end up with an inverted (~null) clipping rectangle which is the correct behavior.
        // Affected by window/frame border size. Used by:
        // - Begin() initial clip rect
        top_border_size := (((.MenuBar in flags) || !(.NoTitleBar in flags)) ? style.FrameBorderSize : window.WindowBorderSize);

        // Try to match the fact that our border is drawn centered over the window rectangle, rather than inner.
        // This is why we do a *0.5f here. We don't currently even technically support large values for WindowBorderSize,
        // see e.g #7887 #7888, but may do after we move the window border to become an inner border (and then we can remove the 0.5f here).
        window.InnerClipRect.Min.x = ImFloor(0.5 + window.InnerRect.Min.x + window.WindowBorderSize * 0.5);
        window.InnerClipRect.Min.y = ImFloor(0.5 + window.InnerRect.Min.y + top_border_size * 0.5);
        window.InnerClipRect.Max.x = ImFloor(window.InnerRect.Max.x - window.WindowBorderSize * 0.5);
        window.InnerClipRect.Max.y = ImFloor(window.InnerRect.Max.y - window.WindowBorderSize * 0.5);
        ClipWithFull(&window.InnerClipRect, host_rect);

        // Default item width. Make it proportional to window size if window manually resizes
        if (window.Size.x > 0.0 && !(.Tooltip in flags) && !(.AlwaysAutoResize in flags)) {
            window.ItemWidthDefault = ImTrunc(window.Size.x * 0.65);
        }
        else {
            window.ItemWidthDefault = ImTrunc(g.FontSize * 16.0);
        }

        // SCROLLING

        // Lock down maximum scrolling
        // The value of ScrollMax are ahead from ScrollbarX/ScrollbarY which is intentionally using InnerRect from previous rect in order to accommodate
        // for right/bottom aligned items without creating a scrollbar.
        window.ScrollMax.x = ImMax(f32(0), window.ContentSize.x + window.WindowPadding.x * 2.0 - GetWidth(window.InnerRect));
        window.ScrollMax.y = ImMax(f32(0), window.ContentSize.y + window.WindowPadding.y * 2.0 - GetHeight(window.InnerRect));

        // Apply scrolling
        window.Scroll = CalcNextScrollFromScrollTargetAndClamp(window);
        window.ScrollTarget = ImVec2{math.F32_MAX, math.F32_MAX};
        window.DecoInnerSizeY1 = 0.0;
        window.DecoInnerSizeX1 = 0

        // DRAWING

        // Setup draw list and outer clipping rectangle
        assert(len(window.DrawList.CmdBuffer) == 1 && window.DrawList.CmdBuffer[0].ElemCount == 0);
        PushTextureID(window.DrawList, g.Font.ContainerAtlas.TexID);
        PushClipRect(host_rect.Min, host_rect.Max, false);

        // Child windows can render their decoration (bg color, border, scrollbars, etc.) within their parent to save a draw call (since 1.71)
        // When using overlapping child windows, this will break the assumption that child z-order is mapped to submission order.
        // FIXME: User code may rely on explicit sorting of overlapping child window and would need to disable this somehow. Please get in contact if you are affected (github #4493)
        is_undocked_or_docked_visible := !window.DockIsActive || window.DockTabIsVisible;
        if (is_undocked_or_docked_visible)
        {
            render_decorations_in_parent := false;
            if ((.ChildWindow in flags) && !(.Popup in flags) && !window_is_child_tooltip)
            {
                // - We test overlap with the previous child window only (testing all would end up being O(log N) not a good investment here)
                // - We disable this when the parent window has zero vertices, which is a common pattern leading to laying out multiple overlapping childs
                previous_child := len(parent_window.DC.ChildWindows) >= 2 ? parent_window.DC.ChildWindows[len(parent_window.DC.ChildWindows) - 2] : nil;
                previous_child_overlapping := previous_child != nil ? Overlaps(Rect(previous_child), Rect(window)) : false;
                parent_is_empty := (len(parent_window.DrawList.VtxBuffer) == 0);
                if (back(window.DrawList.CmdBuffer).ElemCount == 0 && !parent_is_empty && !previous_child_overlapping) {
                    render_decorations_in_parent = true;
                }
            }
            if (render_decorations_in_parent) {
                window.DrawList = parent_window.DrawList;
            }

            // Handle title bar, scrollbar, resize grips and resize borders
            window_to_highlight := g.NavWindowingTarget != nil ? g.NavWindowingTarget : g.NavWindow;
            title_bar_is_highlight := want_focus || (window_to_highlight != nil && (window.RootWindowForTitleBarHighlight == window_to_highlight.RootWindowForTitleBarHighlight || (window.DockNode != nil && window.DockNode == window_to_highlight.DockNode)));
            RenderWindowDecorations(window, title_bar_rect, title_bar_is_highlight, handle_borders_and_resize_grips, resize_grip_count, resize_grip_col, resize_grip_draw_size);

            if (render_decorations_in_parent) {
                window.DrawList = &window.DrawListInst;
            }
        }

        // UPDATE RECTANGLES (2- THOSE AFFECTED BY SCROLLING)

        // Work rectangle.
        // Affected by window padding and border size. Used by:
        // - Columns() for right-most edge
        // - TreeNode(), CollapsingHeader() for right-most edge
        // - BeginTabBar() for right-most edge
        allow_scrollbar_x := !(.NoScrollbar in flags) && (.HorizontalScrollbar in flags);
        allow_scrollbar_y := !(.NoScrollbar in flags);
        work_rect_size_x := (window.ContentSizeExplicit.x != 0.0 ? window.ContentSizeExplicit.x : ImMax(allow_scrollbar_x ? window.ContentSize.x : 0.0, window.Size.x - window.WindowPadding.x * 2.0 - (window.DecoOuterSizeX1 + window.DecoOuterSizeX2)));
        work_rect_size_y := (window.ContentSizeExplicit.y != 0.0 ? window.ContentSizeExplicit.y : ImMax(allow_scrollbar_y ? window.ContentSize.y : 0.0, window.Size.y - window.WindowPadding.y * 2.0 - (window.DecoOuterSizeY1 + window.DecoOuterSizeY2)));
        window.WorkRect.Min.x = ImTrunc(window.InnerRect.Min.x - window.Scroll.x + ImMax(window.WindowPadding.x, window.WindowBorderSize));
        window.WorkRect.Min.y = ImTrunc(window.InnerRect.Min.y - window.Scroll.y + ImMax(window.WindowPadding.y, window.WindowBorderSize));
        window.WorkRect.Max.x = window.WorkRect.Min.x + work_rect_size_x;
        window.WorkRect.Max.y = window.WorkRect.Min.y + work_rect_size_y;
        window.ParentWorkRect = window.WorkRect;

        // [LEGACY] Content Region
        // FIXME-OBSOLETE: window.ContentRegionRect.Max is currently very misleading / partly faulty, but some BeginChild() patterns relies on it.
        // Unless explicit content size is specified by user, this currently represent the region leading to no scrolling.
        // Used by:
        // - Mouse wheel scrolling + many other things
        window.ContentRegionRect.Min.x = window.Pos.x - window.Scroll.x + window.WindowPadding.x + window.DecoOuterSizeX1;
        window.ContentRegionRect.Min.y = window.Pos.y - window.Scroll.y + window.WindowPadding.y + window.DecoOuterSizeY1;
        window.ContentRegionRect.Max.x = window.ContentRegionRect.Min.x + (window.ContentSizeExplicit.x != 0.0 ? window.ContentSizeExplicit.x : (window.Size.x - window.WindowPadding.x * 2.0 - (window.DecoOuterSizeX1 + window.DecoOuterSizeX2)));
        window.ContentRegionRect.Max.y = window.ContentRegionRect.Min.y + (window.ContentSizeExplicit.y != 0.0 ? window.ContentSizeExplicit.y : (window.Size.y - window.WindowPadding.y * 2.0 - (window.DecoOuterSizeY1 + window.DecoOuterSizeY2)));

        // Setup drawing context
        // (NB: That term "drawing context / DC" lost its meaning a long time ago. Initially was meant to hold transient data only. Nowadays difference between window-> and window.DC-> is dubious.)
        window.DC.Indent.x = window.DecoOuterSizeX1 + window.WindowPadding.x - window.Scroll.x;
        window.DC.GroupOffset.x = 0.0;
        window.DC.ColumnsOffset.x = 0.0;

        // Record the loss of precision of CursorStartPos which can happen due to really large scrolling amount.
        // This is used by clipper to compensate and fix the most common use case of large scroll area. Easy and cheap, next best thing compared to switching everything to double or ImU64.
        start_pos_highp_x := cast(f64) window.Pos.x + cast(f64) window.WindowPadding.x - cast(f64) window.Scroll.x + cast(f64) window.DecoOuterSizeX1 + cast(f64) window.DC.ColumnsOffset.x;
        start_pos_highp_y := cast(f64) window.Pos.y + cast(f64) window.WindowPadding.y - cast(f64) window.Scroll.y + cast(f64) window.DecoOuterSizeY1;
        window.DC.CursorStartPos  = ImVec2{cast(f32)start_pos_highp_x, cast(f32) start_pos_highp_y};
        window.DC.CursorStartPosLossyness = ImVec2{cast(f32)(start_pos_highp_x - f64(window.DC.CursorStartPos.x)), (f32)(start_pos_highp_y - f64(window.DC.CursorStartPos.y))};
        window.DC.CursorPos = window.DC.CursorStartPos;
        window.DC.CursorPosPrevLine = window.DC.CursorPos;
        window.DC.CursorMaxPos = window.DC.CursorStartPos;
        window.DC.IdealMaxPos = window.DC.CursorStartPos;
        window.DC.PrevLineSize = {};
        window.DC.CurrLineSize = {}
        window.DC.PrevLineTextBaseOffset = 0.0;
        window.DC.CurrLineTextBaseOffset = 0
        window.DC.IsSetPos = false;
        window.DC.IsSameLine = false

        window.DC.NavLayerCurrent = .Main;
        window.DC.NavLayersActiveMask = window.DC.NavLayersActiveMaskNext;
        window.DC.NavLayersActiveMaskNext = 0x00;
        window.DC.NavIsScrollPushableX = true;
        window.DC.NavHideHighlightOneFrame = false;
        window.DC.NavWindowHasScrollY = (window.ScrollMax.y > 0.0);

        window.DC.MenuBarAppending = false;
        Update(&window.DC.MenuColumns, style.ItemSpacing.x, window_just_activated_by_user);
        window.DC.TreeDepth = 0;
        window.DC.TreeHasStackDataDepthMask = 0x00;
        clear(&window.DC.ChildWindows)
        window.DC.StateStorage = &window.StateStorage;
        window.DC.CurrentColumns = nil;
        window.DC.LayoutType = .Vertical;
        window.DC.ParentLayoutType = parent_window != nil ? parent_window.DC.LayoutType : .Vertical;

        window.DC.ItemWidth = window.ItemWidthDefault;
        window.DC.TextWrapPos = -1.0; // disabled
        clear(&window.DC.ItemWidthStack);
        clear(&window.DC.TextWrapPosStack);
        if (.Modal in flags) {
            window.DC.ModalDimBgColor = ColorConvertFloat4ToU32(GetStyleColorVec4(ImGuiCol.ModalWindowDimBg)^);
        }

        if (window.AutoFitFramesX > 0) do window.AutoFitFramesX -= 1;
        if (window.AutoFitFramesY > 0) do window.AutoFitFramesY -= 1;

        // Clear SetNextWindowXXX data (can aim to move this higher in the function)
        ClearFlags(&g.NextWindowData);

        // Apply focus (we need to call FocusWindow() AFTER setting DC.CursorStartPos so our initial navigation reference rectangle can start around there)
        // We ImGuiFocusRequestFlags_UnlessBelowModal to:
        // - Avoid focusing a window that is created outside of a modal. This will prevent active modal from being closed.
        // - Position window behind the modal that is not a begin-parent of this window.
        if (want_focus) {
            FocusWindow(window, {.UnlessBelowModal});
        }
        if (want_focus && window == g.NavWindow) {
            NavInitWindow(window, false); // <-- this is in the way for us to be able to defer and sort reappearing FocusWindow() calls
        }

        // Close requested by platform window (apply to all windows in this viewport)
        if (p_open != nil && window.Viewport.PlatformRequestClose && window.Viewport != GetMainViewport())
        {
            IMGUI_DEBUG_LOG_VIEWPORT("[viewport] Window '%s' closed by PlatformRequestClose\n", window.Name);
            p_open^ = false;
            g.NavWindowingToggleLayer = false; // Assume user mapped PlatformRequestClose on ALT-F4 so we disable ALT for menu toggle. False positive not an issue. // FIXME-NAV: Try removing.
        }

        // Pressing CTRL+C copy window content into the clipboard
        // [EXPERIMENTAL] Breaks on nested Begin/End pairs. We need to work that out and add better logging scope.
        // [EXPERIMENTAL] Text outputs has many issues.
        if (g.IO.ConfigWindowsCopyContentsWithCtrlC) {
            if (g.NavWindow != nil && g.NavWindow.RootWindow == window && g.ActiveId == 0 && Shortcut(ImGuiKey.Mod_Ctrl | ImGuiKey.C))   do LogToClipboard(0)
        }

        // Title bar
        if (!(.NoTitleBar in flags) && !window.DockIsActive) {
            RenderWindowTitleBarContents(window, ImRect{ _r = {title_bar_rect.Min.x + window.WindowBorderSize, title_bar_rect.Min.y, title_bar_rect.Max.x - window.WindowBorderSize, title_bar_rect.Max.y}}, name, p_open);
        }
        else if (!(.NoTitleBar in flags) && window.DockIsActive) {
            LogText("%s\n", FindRenderedText(window.Name));
        }

        // Clear hit test shape every frame
        window.HitTestHoleSize.y = 0;
        window.HitTestHoleSize.x = 0

        if (.Tooltip in flags) {
            g.TooltipPreviousWindow = window;
        }

        if (.DockingEnable in g.IO.ConfigFlags)
        {
            // Docking: Dragging a dockable window (or any of its child) turns it into a drag and drop source.
            // We need to do this _before_ we overwrite window.DC.LastItemId below because BeginDockableDragDropSource() also overwrites it.
            if (g.MovingWindow == window && (.NoDocking not_in window.RootWindowDockTree.Flags)) {
                BeginDockableDragDropSource(window);
            }

            // Docking: Any dockable window can act as a target. For dock node hosts we call BeginDockableDragDropTarget() in DockNodeUpdate() instead.
            if (g.DragDropActive && !(.NoDocking in flags)) {
                if (g.MovingWindow == nil || g.MovingWindow.RootWindowDockTree != window) {
                    if ((window == window.RootWindowDockTree) && !(.DockNodeHost in window.Flags)) {
                        BeginDockableDragDropTarget(window);
                    }
                }
            }
        }

        // We fill last item data based on Title Bar/Tab, in order for IsItemHovered() and IsItemActive() to be usable after Begin().
        // This is useful to allow creating context menus on title bar only, etc.
        SetLastItemDataForWindow(window, title_bar_rect);

        // [DEBUG]
when !(IMGUI_DISABLE_DEBUG_TOOLS) {
        if (g.DebugLocateId != 0 && (window.ID == g.DebugLocateId || window.MoveId == g.DebugLocateId)) {
            DebugLocateItemResolveWithLastItem();
        }
}

        // [Test Engine] Register title bar / tab with MoveId.
when IMGUI_ENABLE_TEST_ENGINE {
        if (!(.NoTitleBar in window.Flags))
        {
            window.DC.NavLayerCurrent = ImGuiNavLayer_Menu;
            IMGUI_TEST_ENGINE_ITEM_ADD(g.LastItemData.ID, g.LastItemData.Rect, &g.LastItemData);
            window.DC.NavLayerCurrent = ImGuiNavLayer_Main;
        }
}
    }
    else
    {
        // Skip refresh always mark active
        if (window.SkipRefresh)  do SetWindowActiveForSkipRefresh(window);

        // Append
        SetCurrentViewport(window, window.Viewport);
        SetCurrentWindow(window);
        g.NextWindowData.ClearFlags();
        SetLastItemDataForWindow(window, TitleBarRect(window));
    }

    if (!(.DockNodeHost in flags) && !window.SkipRefresh) {
        PushClipRect(window.InnerClipRect.Min, window.InnerClipRect.Max, true);
    }

    // Clear 'accessed' flag last thing (After PushClipRect which will set the flag. We want the flag to stay false when the default "Debug" window is unused)
    window.WriteAccessed = false;
    window.BeginCount += 1;

    // Update visibility
    if (first_begin_of_the_frame && !window.SkipRefresh)
    {
        // When we are about to select this tab (which will only be visible on the _next frame_), flag it with a non-zero HiddenFramesCannotSkipItems.
        // This will have the important effect of actually returning true in Begin() and not setting SkipItems, allowing an earlier submission of the window contents.
        // This is analogous to regular windows being hidden from one frame.
        // It is especially important as e.g. nested TabBars would otherwise generate flicker in the form of one empty frame, or focus requests won't be processed.
        if (window.DockIsActive && !window.DockTabIsVisible)
        {
            if (window.LastFrameJustFocused == g.FrameCount) {
                window.HiddenFramesCannotSkipItems = 1;
            }
            else {
                window.HiddenFramesCanSkipItems = 1;
            }
        }

        if ((.ChildWindow in flags) && !(.ChildMenu in flags))
        {
            // Child window can be out of sight and have "negative" clip windows.
            // Mark them as collapsed so commands are skipped earlier (we can't manually collapse them because they have no title bar).
            assert((.NoTitleBar in flags) || window.DockIsActive);
            nav_request := (.NavFlattened in window.ChildFlags) && (g.NavAnyRequest && g.NavWindow != nil && g.NavWindow.RootWindowForNav == window.RootWindowForNav);
            if (!g.LogEnabled && !nav_request) {
                if (window.OuterRectClipped.Min.x >= window.OuterRectClipped.Max.x || window.OuterRectClipped.Min.y >= window.OuterRectClipped.Max.y)
                {
                    if (window.AutoFitFramesX > 0 || window.AutoFitFramesY > 0) {
                        window.HiddenFramesCannotSkipItems = 1;
                    }
                    else {
                        window.HiddenFramesCanSkipItems = 1;
                    }
                }
            }

            // Hide along with parent or if parent is collapsed
            if (parent_window != nil && (parent_window.Collapsed || parent_window.HiddenFramesCanSkipItems > 0)) {
                window.HiddenFramesCanSkipItems = 1;
            }
            if (parent_window != nil && (parent_window.Collapsed || parent_window.HiddenFramesCannotSkipItems > 0)) {
                window.HiddenFramesCannotSkipItems = 1;
            }
        }

        // Don't render if style alpha is 0.0 at the time of Begin(). This is arbitrary and inconsistent but has been there for a long while (may remove at some point)
        if (style.Alpha <= 0.0)  do window.HiddenFramesCanSkipItems = 1;

        // Update the Hidden flag
        hidden_regular := (window.HiddenFramesCanSkipItems > 0) || (window.HiddenFramesCannotSkipItems > 0);
        window.Hidden = hidden_regular || (window.HiddenFramesForRenderOnly > 0);

        // Disable inputs for requested number of frames
        if (window.DisableInputsFrames > 0)
        {
            window.DisableInputsFrames -= 1;
            window.Flags |= ImGuiWindowFlags_NoInputs;
        }

        // Update the SkipItems flag, used to early out of all items functions (no layout required)
        skip_items := false;
        if (window.Collapsed || !window.Active || hidden_regular) {
            if (window.AutoFitFramesX <= 0 && window.AutoFitFramesY <= 0 && window.HiddenFramesCannotSkipItems <= 0)   do skip_items = true
        }
        window.SkipItems = skip_items;

        // Restore NavLayersActiveMaskNext to previous value when not visible, so a CTRL+Tab back can use a safe value.
        if (window.SkipItems) {
            window.DC.NavLayersActiveMaskNext = window.DC.NavLayersActiveMask;
        }

        // Sanity check: there are two spots which can set Appearing = true
        // - when 'window_just_activated_by_user' is set -> HiddenFramesCannotSkipItems is set -> SkipItems always false
        // - in BeginDocked() path when DockNodeIsVisible == DockTabIsVisible == true -> hidden _should_ be all zero // FIXME: Not formally proven, hence the assert.
        if (window.SkipItems && !window.Appearing) {
            assert(window.Appearing == false); // Please report on GitHub if this triggers: https://github.com/ocornut/imgui/issues/4177
        }
    }
    else if (first_begin_of_the_frame)
    {
        // Skip refresh mode
        window.SkipItems = true;
    }

    // [DEBUG] io.ConfigDebugBeginReturnValue override return value to test Begin/End and BeginChild/EndChild behaviors.
    // (The implicit fallback window is NOT automatically ended allowing it to always be able to receive commands without crashing)
when !(IMGUI_DISABLE_DEBUG_TOOLS) {
    if (!window.IsFallbackWindow) {
        if ((g.IO.ConfigDebugBeginReturnValueOnce && window_just_created) || (g.IO.ConfigDebugBeginReturnValueLoop && g.DebugBeginReturnValueCullDepth == cast(i8) len(g.CurrentWindowStack)))
        {
            if (window.AutoFitFramesX > 0) { window.AutoFitFramesX += 1; }
            if (window.AutoFitFramesY > 0) { window.AutoFitFramesY += 1; }
            return false;
        }
    }
}

    return !window.SkipItems;
}

SetLastItemDataForWindow :: proc(window : ^ImGuiWindow, rect : ImRect)
{
    g := GImGui;
    if (window.DockIsActive) {
        SetLastItemData(window.MoveId, g.CurrentItemFlags, window.DockTabItemStatusFlags, window.DockTabItemRect);
    }
    else {
        SetLastItemData(window.MoveId, g.CurrentItemFlags, IsMouseHoveringRect(rect.Min, rect.Max, false) ? {.HoveredRect} : nil, rect);
    }
}

// [forward declared comment]:
// Automatically called on the last call of Step() that returns false.
End :: proc()
{
    g := GImGui;
    window := g.CurrentWindow;

    // Error checking: verify that user hasn't called End() too many times!
    if (len(g.CurrentWindowStack) <= 1 && g.WithinFrameScopeWithImplicitWindow)
    {
        IM_ASSERT_USER_ERROR(len(g.CurrentWindowStack) > 1, "Calling End() too many times!");
        return;
    }
    window_stack_data := back(g.CurrentWindowStack);

    // Error checking: verify that user doesn't directly call End() on a child window.
    if ((.ChildWindow in window.Flags) && !(.DockNodeHost in window.Flags) && !window.DockIsActive) {
        IM_ASSERT_USER_ERROR(g.WithinEndChildID == window.ID, "Must call EndChild() and not End()!");
    }

    // Close anything that is open
    if (window.DC.CurrentColumns != nil)   do EndColumns()
    if (!(.DockNodeHost in window.Flags) && !window.SkipRefresh) {  // Pop inner window clip rectangle
        PopClipRect();
    }
    PopFocusScope();
    if (window_stack_data.DisabledOverrideReenable && window.RootWindow == window) {
        EndDisabledOverrideReenable();
    }

    if (window.SkipRefresh)
    {
        assert(window.DrawList == nil);
        window.DrawList = &window.DrawListInst;
    }

    // Stop logging
    if (g.LogWindow == window) { // FIXME: add more options for scope of logging
        LogFinish();
    }

    if (window.DC.IsSetPos) {
        ErrorCheckUsingSetCursorPosToExtendParentBoundaries();
    }

    // Docking: report contents sizes to parent to allow for auto-resize
    if (window.DockNode != nil && window.DockTabIsVisible) {
        if host_window := window.DockNode.HostWindow; host_window != nil {        // FIXME-DOCK
            host_window.DC.CursorMaxPos = window.DC.CursorMaxPos + window.WindowPadding - host_window.WindowPadding;
        }
    }

    // Pop from window stack
    g.LastItemData = window_stack_data.ParentLastItemDataBackup;
    if (.ChildMenu in window.Flags)   do g.BeginMenuDepth -= 1
    if (.Popup in window.Flags)  do pop(&g.BeginPopupStack);

    // Error handling, state recovery
    if (g.IO.ConfigErrorRecovery) {
        ErrorRecoveryTryToRecoverWindowState(&window_stack_data.StackSizesInBegin);
    }

    pop(&g.CurrentWindowStack);
    SetCurrentWindow(len(g.CurrentWindowStack) == 0 ? nil : back(g.CurrentWindowStack).Window);
    if (g.CurrentWindow != nil) {
        SetCurrentViewport(g.CurrentWindow, g.CurrentWindow.Viewport);
    }
}

// Important: this alone doesn't alter current ImDrawList state. This is called by PushFont/PopFont only.
SetCurrentFont :: proc(font : ^ImFont)
{
    g := GImGui;
    assert(font && IsLoaded(font));    // Font Atlas not created. Did you call io.Fonts.GetTexDataAsRGBA32 / GetTexDataAsAlpha8 ?
    assert(font.Scale > 0.0);
    g.Font = font;
    g.FontBaseSize = ImMax(f32(1), g.IO.FontGlobalScale * g.Font.FontSize * g.Font.Scale);
    g.FontSize = g.CurrentWindow != nil ? CalcFontSize(g.CurrentWindow) : 0.0;
    g.FontScale = g.FontSize / g.Font.FontSize;

    atlas := g.Font.ContainerAtlas;
    g.DrawListSharedData.TexUvWhitePixel = atlas.TexUvWhitePixel;
    g.DrawListSharedData.TexUvLines = raw_data(&atlas.TexUvLines);
    g.DrawListSharedData.Font = g.Font;
    g.DrawListSharedData.FontSize = g.FontSize;
    g.DrawListSharedData.FontScale = g.FontScale;
}

// Use ImDrawList::_SetTextureID(), making our shared g.FontStack[] authorative against window-local ImDrawList.
// - Whereas ImDrawList::PushTextureID()/PopTextureID() is not to be used across Begin() calls.
// - Note that we don't propagate current texture id when e.g. Begin()-ing into a new window, we never really did...
//   - Some code paths never really fully worked with multiple atlas textures.
//   - The right-ish solution may be to remove _SetTextureID() and make AddText/RenderText lazily call PushTextureID()/PopTextureID()
//     the same way AddImage() does, but then all other primitives would also need to? I don't think we should tackle this problem
//     because we have a concrete need and a test bed for multiple atlas textures.
// [forward declared comment]:
// use NULL as a shortcut to push default font
PushFont :: proc(font : ^ImFont)
{
    font := font
    g := GImGui;
    if (font == nil)   do font = GetDefaultFont()
    append(&g.FontStack, font);
    SetCurrentFont(font);
    _SetTextureID(g.CurrentWindow.DrawList, font.ContainerAtlas.TexID);
}

PopFont :: proc()
{
    g := GImGui;
    if (len(g.FontStack) <= 0)
    {
        IM_ASSERT_USER_ERROR(false, "Calling PopFont() too many times!");
        return;
    }
    pop(&g.FontStack)
    font := len(g.FontStack) == 0 ? GetDefaultFont() : back(g.FontStack)^;
    SetCurrentFont(font);
    _SetTextureID(g.CurrentWindow.DrawList, font.ContainerAtlas.TexID);
}

// [forward declared comment]:
// modify specified shared item flag, e.g. PushItemFlag(ImGuiItemFlags_NoTabStop, true)
PushItemFlag :: proc(option : ImGuiItemFlags, enabled : bool)
{
    g := GImGui;
    item_flags := g.CurrentItemFlags;
    assert(item_flags == back(g.ItemFlagsStack)^);
    if (enabled)   do item_flags |= option
    else  do item_flags &= ~option;
    g.CurrentItemFlags = item_flags;
    append(&g.ItemFlagsStack, item_flags);
}

PopItemFlag :: proc()
{
    g := GImGui;
    if (len(g.ItemFlagsStack) <= 1)
    {
        IM_ASSERT_USER_ERROR(false, "Calling PopItemFlag() too many times!");
        return;
    }
    pop(&g.ItemFlagsStack);
    g.CurrentItemFlags = back(g.ItemFlagsStack)^;
}

// BeginDisabled()/EndDisabled()
// - Those can be nested but it cannot be used to enable an already disabled section (a single BeginDisabled(true) in the stack is enough to keep everything disabled)
// - Visually this is currently altering alpha, but it is expected that in a future styling system this would work differently.
// - Feedback welcome at https://github.com/ocornut/imgui/issues/211
// - BeginDisabled(false)/EndDisabled() essentially does nothing but is provided to facilitate use of boolean expressions.
//   (as a micro-optimization: if you have tens of thousands of BeginDisabled(false)/EndDisabled() pairs, you might want to reformulate your code to avoid making those calls)
// - Note: mixing up BeginDisabled() and PushItemFlag(ImGuiItemFlags_Disabled) is currently NOT SUPPORTED.
BeginDisabled :: proc(disabled : bool = true)
{
    g := GImGui;
    was_disabled := (g.CurrentItemFlags & ImGuiItemFlagsPrivate.Disabled) != nil;
    if (!was_disabled && disabled)
    {
        g.DisabledAlphaBackup = g.Style.Alpha;
        g.Style.Alpha *= g.Style.DisabledAlpha; // PushStyleVar(ImGuiStyleVar_Alpha, g.Style.Alpha * g.Style.DisabledAlpha);
    }
    if (was_disabled || disabled) {
        g.CurrentItemFlags |= transmute(ImGuiItemFlags) ImGuiItemFlagsPrivate.Disabled;
    }
    append(&g.ItemFlagsStack, g.CurrentItemFlags); // FIXME-OPT: can we simply skip this and use DisabledStackSize?
    g.DisabledStackSize += 1;
}

EndDisabled :: proc()
{
    g := GImGui;
    if (g.DisabledStackSize <= 0)
    {
        IM_ASSERT_USER_ERROR(false, "Calling EndDisabled() too many times!");
        return;
    }
    g.DisabledStackSize -= 1;
    was_disabled := (.Disabled in g.CurrentItemFlags) != 0;
    //PopItemFlag();
    pop(&g.ItemFlagsStack);
    g.CurrentItemFlags = back(g.ItemFlagsStack)^;
    if (was_disabled && (.Disabled not_in g.CurrentItemFlags)) {
        g.Style.Alpha = g.DisabledAlphaBackup; //PopStyleVar();
    }
}

// Could have been called BeginDisabledDisable() but it didn't want to be award nominated for most awkward function name.
// Ideally we would use a shared e.g. BeginDisabled()->BeginDisabledEx() but earlier needs to be optimal.
// The whole code for this is awkward, will reevaluate if we find a way to implement SetNextItemDisabled().
BeginDisabledOverrideReenable :: proc()
{
    g := GImGui;
    assert(.Disabled in g.CurrentItemFlags);
    g.Style.Alpha = g.DisabledAlphaBackup;
    g.CurrentItemFlags &= ~{.Disabled};
    append(&g.ItemFlagsStack, g.CurrentItemFlags);
    g.DisabledStackSize += 1;
}

EndDisabledOverrideReenable :: proc()
{
    g := GImGui;
    g.DisabledStackSize -= 1;
    assert(g.DisabledStackSize > 0);
    pop(&g.ItemFlagsStack)
    g.CurrentItemFlags = back(g.ItemFlagsStack)^;
    g.Style.Alpha = g.DisabledAlphaBackup * g.Style.DisabledAlpha;
}

// [forward declared comment]:
// push word-wrapping position for Text*() commands. < 0.0f: no wrapping; 0.0f: wrap to end of window (or column); > 0.0f: wrap at 'wrap_pos_x' position in window local space
PushTextWrapPos :: proc(wrap_pos_x : f32 = 0.0)
{
    g := GImGui;
    window := g.CurrentWindow;
    append(&window.DC.TextWrapPosStack, window.DC.TextWrapPos);
    window.DC.TextWrapPos = wrap_pos_x;
}

PopTextWrapPos :: proc()
{
    g := GImGui;
    window := g.CurrentWindow;
    if (len(window.DC.TextWrapPosStack) <= 0)
    {
        IM_ASSERT_USER_ERROR(false, "Calling PopTextWrapPos() too many times!");
        return;
    }
    window.DC.TextWrapPos = back(window.DC.TextWrapPosStack)^;
    pop(&window.DC.TextWrapPosStack);
}

GetCombinedRootWindow :: proc(window : ^ImGuiWindow, popup_hierarchy : bool, dock_hierarchy : bool) -> ^ImGuiWindow
{
    window := window
    last_window : ^ImGuiWindow
    for (last_window != window)
    {
        last_window = window;
        window = window.RootWindow;
        if (popup_hierarchy) {
            window = window.RootWindowPopupTree;
        }
		if (dock_hierarchy) {
			window = window.RootWindowDockTree;
        }
	}
    return window;
}

IsWindowChildOf :: proc(window : ^ImGuiWindow, potential_parent : ^ImGuiWindow, popup_hierarchy : bool, dock_hierarchy : bool) -> bool
{
    window := window
    window_root := GetCombinedRootWindow(window, popup_hierarchy, dock_hierarchy);
    if (window_root == potential_parent)   do return true
    for (window != nil)
    {
        if (window == potential_parent)   do return true
        if (window == window_root) do return false // end of chain
        window = window.ParentWindow;
    }
    return false;
}

IsWindowWithinBeginStackOf :: proc(window : ^ImGuiWindow, potential_parent : ^ImGuiWindow) -> bool
{
    window := window
    if (window.RootWindow == potential_parent)   do return true
    for (window != nil)
    {
        if (window == potential_parent)   do return true
        window = window.ParentWindowInBeginStack;
    }
    return false;
}

IsWindowAbove :: proc(potential_above : ^ImGuiWindow, potential_below : ^ImGuiWindow) -> bool
{
    g := GImGui;

    // It would be saner to ensure that display layer is always reflected in the g.Windows[] order, which would likely requires altering all manipulations of that array
    display_layer_delta := GetWindowDisplayLayer(potential_above) - GetWindowDisplayLayer(potential_below);
    if (display_layer_delta != 0)   do return display_layer_delta > 0

    for i := len(g.Windows) - 1; i >= 0; i -= 1
    {
        candidate_window := g.Windows[i];
        if (candidate_window == potential_above)   do return true
        if (candidate_window == potential_below)   do return false
    }
    return false;
}

// Is current window hovered and hoverable (e.g. not blocked by a popup/modal)? See ImGuiHoveredFlags_ for options.
// IMPORTANT: If you are trying to check whether your mouse should be dispatched to Dear ImGui or to your underlying app,
// you should not use this function! Use the 'io.WantCaptureMouse' boolean for that!
// Refer to FAQ entry "How can I tell whether to dispatch mouse/keyboard to Dear ImGui or my application?" for details.
// [forward declared comment]:
// is current window hovered and hoverable (e.g. not blocked by a popup/modal)? See ImGuiHoveredFlags_ for options. IMPORTANT: If you are trying to check whether your mouse should be dispatched to Dear ImGui or to your underlying app, you should not use this function! Use the 'io.WantCaptureMouse' boolean for that! Refer to FAQ entry "How can I tell whether to dispatch mouse/keyboard to Dear ImGui or my application?" for details.
IsWindowHovered :: proc(flags : ImGuiHoveredFlags) -> bool
{
    g := GImGui;
    IM_ASSERT_USER_ERROR((flags & ~ImGuiHoveredFlags_AllowedMaskForIsWindowHovered) == 0, "Invalid flags for IsWindowHovered()!");

    ref_window := g.HoveredWindow;
    cur_window := g.CurrentWindow;
    if (ref_window == nil)   do return false

    if ((.AnyWindow not_in flags))
    {
        assert(cur_window); // Not inside a Begin()/End()
        popup_hierarchy := (.NoPopupHierarchy not_in flags);
        dock_hierarchy := (.DockHierarchy in flags)
        if (.RootWindow in flags) {
            cur_window = GetCombinedRootWindow(cur_window, popup_hierarchy, dock_hierarchy);

        result : bool
        if (.ChildWindows in flags) {
            result = IsWindowChildOf(ref_window, cur_window, popup_hierarchy, dock_hierarchy);
        }
        else {
            result = (ref_window == cur_window);
        }
        if (!result)   do return false
    }

    if (!IsWindowContentHoverable(ref_window, flags))   do return false
    if (!(.AllowWhenBlockedByActiveItem in flags)) {
        if (g.ActiveId != 0 && !g.ActiveIdAllowOverlap && g.ActiveId != ref_window.MoveId)   do return false
    }

    // When changing hovered window we requires a bit of stationary delay before activating hover timer.
    // FIXME: We don't support delay other than stationary one for now, other delay would need a way
    // to fulfill the possibility that multiple IsWindowHovered() with varying flag could return true
    // for different windows of the hierarchy. Possibly need a Hash(Current+Flags) ==> (Timer) cache.
    // We can implement this for _Stationary because the data is linked to HoveredWindow rather than CurrentWindow.
    if (.ForTooltip in flags) {
        flags = ApplyHoverFlagsForTooltip(flags, g.Style.HoverFlagsForTooltipMouse);
    }
    if ((.Stationary in flags) != 0 && g.HoverWindowUnlockedStationaryId != ref_window.ID)   do return false

    return true;
}

GetWindowDockID :: proc() -> ImGuiID
{
    g := GImGui;
    return g.CurrentWindow.DockId;
}

// [forward declared comment]:
// is current window docked into another window?
IsWindowDocked :: proc() -> bool
{
    g := GImGui;
    return g.CurrentWindow.DockIsActive;
}

// [forward declared comment]:
// get current window width (IT IS UNLIKELY YOU EVER NEED TO USE THIS). Shortcut for GetWindowSize().x.
GetWindowWidth :: proc() -> f32
{
    window := GImGui.CurrentWindow;
    return window.Size.x;
}

// [forward declared comment]:
// get current window height (IT IS UNLIKELY YOU EVER NEED TO USE THIS). Shortcut for GetWindowSize().y.
GetWindowHeight :: proc() -> f32
{
    window := GImGui.CurrentWindow;
    return window.Size.y;
}

// [forward declared comment]:
// get current window position in screen space (IT IS UNLIKELY YOU EVER NEED TO USE THIS. Consider always using GetCursorScreenPos() and GetContentRegionAvail() instead)
GetWindowPos :: proc() -> ImVec2
{
    g := GImGui;
    window := g.CurrentWindow;
    return window.Pos;
}

SetWindowPos :: proc(window : ^ImGuiWindow, pos : ImVec2, cond : ImGuiCond = {})
{
    // Test condition (NB: bit 0 is always true) and clear flags for next time
    if (cond && (window.SetWindowPosAllowFlags & cond) == 0)   do return

    assert(cond == 0 || math.is_power_of_two(cond)); // Make sure the user doesn't attempt to combine multiple condition flags.
    window.SetWindowPosAllowFlags &= ~(ImGuiCond_Once | ImGuiCond_FirstUseEver | ImGuiCond_Appearing);
    window.SetWindowPosVal = ImVec2{math.F32_MAX, math.F32_MAX};

    // Set
    old_pos := window.Pos;
    window.Pos = ImTrunc(pos);
    offset := window.Pos - old_pos;
    if (offset.x == 0.0 && offset.y == 0.0)   do return
    MarkIniSettingsDirty(window);
    // FIXME: share code with TranslateWindow(), need to confirm whether the 3 rect modified by TranslateWindow() are desirable here.
    window.DC.CursorPos += offset;         // As we happen to move the window while it is being appended to (which is a bad idea - will smear) let's at least offset the cursor
    window.DC.CursorMaxPos += offset;      // And more importantly we need to offset CursorMaxPos/CursorStartPos this so ContentSize calculation doesn't get affected.
    window.DC.IdealMaxPos += offset;
    window.DC.CursorStartPos += offset;
}

SetWindowPos :: proc(pos : ImVec2, cond : ImGuiCond)
{
    window := GetCurrentWindowRead();
    SetWindowPos(window, pos, cond);
}

SetWindowPos :: proc(name : ^u8, pos : ImVec2, cond : ImGuiCond = {})
{
    if window := FindWindowByName(name); window != nil {
        SetWindowPos(window, pos, cond);
    }
}

// [forward declared comment]:
// get current window size (IT IS UNLIKELY YOU EVER NEED TO USE THIS. Consider always using GetCursorScreenPos() and GetContentRegionAvail() instead)
GetWindowSize :: proc() -> ImVec2
{
    window := GetCurrentWindowRead();
    return window.Size;
}

SetWindowSize :: proc(window : ^ImGuiWindow, size : ImVec2, cond : ImGuiCond = {})
{
    // Test condition (NB: bit 0 is always true) and clear flags for next time
    if (cond && (window.SetWindowSizeAllowFlags & cond) == 0)   do return

    assert(cond == 0 || math.is_power_of_two(cond)); // Make sure the user doesn't attempt to combine multiple condition flags.
    window.SetWindowSizeAllowFlags &= ~(ImGuiCond_Once | ImGuiCond_FirstUseEver | ImGuiCond_Appearing);

    // Enable auto-fit (not done in BeginChild() path unless appearing or combined with ImGuiChildFlags_AlwaysAutoResize)
    if ((.ChildWindow not_in window.Flags) || window.Appearing || (.AlwaysAutoResize in window.ChildFlags) != 0) {
        window.AutoFitFramesX = (size.x <= 0.0) ? 2 : 0;
    }
    if ((.ChildWindow not_in window.Flags) || window.Appearing || (.AlwaysAutoResize in window.ChildFlags) != 0) {
        window.AutoFitFramesY = (size.y <= 0.0) ? 2 : 0;
    }

    // Set
    old_size := window.SizeFull;
    if (size.x <= 0.0) {
        window.AutoFitOnlyGrows = false;
    }
    else {
        window.SizeFull.x = math.trunc(size.x);
    }
    if (size.y <= 0.0) {
        window.AutoFitOnlyGrows = false;
    }
    else {
        window.SizeFull.y = math.trunc(size.y);
    }
    if (old_size.x != window.SizeFull.x || old_size.y != window.SizeFull.y) {
        MarkIniSettingsDirty(window);
    }
}

SetWindowSize :: proc(size : ImVec2, cond : ImGuiCond)
{
    SetWindowSize(GImGui.CurrentWindow, size, cond);
}

SetWindowSize :: proc(name : ^u8, size : ImVec2, cond : ImGuiCond = {})
{
    if window := FindWindowByName(name); window != nil {
        SetWindowSize(window, size, cond);
    }
}

SetWindowCollapsed :: proc(window : ^ImGuiWindow, collapsed : bool, cond : ImGuiCond = {})
{
    // Test condition (NB: bit 0 is always true) and clear flags for next time
    if (cond && (window.SetWindowCollapsedAllowFlags & cond) == 0)   do return
    window.SetWindowCollapsedAllowFlags &= ~(ImGuiCond_Once | ImGuiCond_FirstUseEver | ImGuiCond_Appearing);

    // Set
    window.Collapsed = collapsed;
}

SetWindowHitTestHole :: proc(window : ^ImGuiWindow, pos : ImVec2, size : ImVec2)
{
    assert(window.HitTestHoleSize.x == 0);     // We don't support multiple holes/hit test filters
    window.HitTestHoleSize = ImVec2ih(size);
    window.HitTestHoleOffset = ImVec2ih(pos - window.Pos);
}

SetWindowHiddenAndSkipItemsForCurrentFrame :: proc(window : ^ImGuiWindow)
{
    window.SkipItems = true;
    window.Hidden = true
    window.HiddenFramesCanSkipItems = 1;
}

SetWindowCollapsed :: proc(collapsed : bool, cond : ImGuiCond)
{
    SetWindowCollapsed(GImGui.CurrentWindow, collapsed, cond);
}

IsWindowCollapsed :: proc() -> bool
{
    window := GetCurrentWindowRead();
    return window.Collapsed;
}

IsWindowAppearing :: proc() -> bool
{
    window := GetCurrentWindowRead();
    return window.Appearing;
}

SetWindowCollapsed :: proc(name : ^u8, collapsed : bool, cond : ImGuiCond = {})
{
    if window := FindWindowByName(name); window != nil {
        SetWindowCollapsed(window, collapsed, cond);
    }
}

// [forward declared comment]:
// set next window position. call before Begin(). use pivot=(0.5f,0.5f) to center on given point, etc.
SetNextWindowPos :: proc(pos : ImVec2, cond : ImGuiCond = {}, pivot : ImVec2 = {})
{
    g := GImGui;
    assert(cond == 0 || math.is_power_of_two(cond)); // Make sure the user doesn't attempt to combine multiple condition flags.
    g.NextWindowData.Flags |= ImGuiNextWindowDataFlags_HasPos;
    g.NextWindowData.PosVal = pos;
    g.NextWindowData.PosPivotVal = pivot;
    g.NextWindowData.PosCond = cond ? cond : ImGuiCond_Always;
    g.NextWindowData.PosUndock = true;
}

// [forward declared comment]:
// set next window size. set axis to 0.0f to force an auto-fit on this axis. call before Begin()
SetNextWindowSize :: proc(size : ImVec2, cond : ImGuiCond = {})
{
    g := GImGui;
    assert(cond == 0 || math.is_power_of_two(cond)); // Make sure the user doesn't attempt to combine multiple condition flags.
    g.NextWindowData.Flags |= ImGuiNextWindowDataFlags_HasSize;
    g.NextWindowData.SizeVal = size;
    g.NextWindowData.SizeCond = cond ? cond : ImGuiCond_Always;
}

// For each axis:
// - Use 0.0f as min or FLT_MAX as max if you don't want limits, e.g. size_min = (500.0f, 0.0f), size_max = (FLT_MAX, FLT_MAX) sets a minimum width.
// - Use -1 for both min and max of same axis to preserve current size which itself is a constraint.
// - See "Demo->Examples->Constrained-resizing window" for examples.
// [forward declared comment]:
// set next window size limits. use 0.0f or FLT_MAX if you don't want limits. Use -1 for both min and max of same axis to preserve current size (which itself is a constraint). Use callback to apply non-trivial programmatic constraints.
SetNextWindowSizeConstraints :: proc(size_min : ImVec2, size_max : ImVec2, custom_callback : ImGuiSizeCallback = nil, custom_callback_user_data : rawptr = nil)
{
    g := GImGui;
    g.NextWindowData.Flags |= ImGuiNextWindowDataFlags_HasSizeConstraint;
    g.NextWindowData.SizeConstraintRect = ImRect{ _v = {size_min, size_max}};
    g.NextWindowData.SizeCallback = custom_callback;
    g.NextWindowData.SizeCallbackUserData = custom_callback_user_data;
}

// Content size = inner scrollable rectangle, padded with WindowPadding.
// SetNextWindowContentSize(ImVec2(100,100) + ImGuiWindowFlags_AlwaysAutoResize will always allow submitting a 100x100 item.
// [forward declared comment]:
// set next window content size (~ scrollable client area, which enforce the range of scrollbars). Not including window decorations (title bar, menu bar, etc.) nor WindowPadding. set an axis to 0.0f to leave it automatic. call before Begin()
SetNextWindowContentSize :: proc(size : ImVec2)
{
    g := GImGui;
    g.NextWindowData.Flags |= ImGuiNextWindowDataFlags_HasContentSize;
    g.NextWindowData.ContentSizeVal = ImTrunc(size);
}

// [forward declared comment]:
// set next window scrolling value (use < 0.0f to not affect a given axis).
SetNextWindowScroll :: proc(scroll : ImVec2)
{
    g := GImGui;
    g.NextWindowData.Flags |= ImGuiNextWindowDataFlags_HasScroll;
    g.NextWindowData.ScrollVal = scroll;
}

// [forward declared comment]:
// set next window collapsed state. call before Begin()
SetNextWindowCollapsed :: proc(collapsed : bool, cond : ImGuiCond = {})
{
    g := GImGui;
    assert(cond == 0 || math.is_power_of_two(cond)); // Make sure the user doesn't attempt to combine multiple condition flags.
    g.NextWindowData.Flags |= ImGuiNextWindowDataFlags_HasCollapsed;
    g.NextWindowData.CollapsedVal = collapsed;
    g.NextWindowData.CollapsedCond = cond ? cond : ImGuiCond_Always;
}

// [forward declared comment]:
// set next window background color alpha. helper to easily override the Alpha component of ImGuiCol.WindowBg/ChildBg/PopupBg. you may also use ImGuiWindowFlags_NoBackground.
SetNextWindowBgAlpha :: proc(alpha : f32)
{
    g := GImGui;
    g.NextWindowData.Flags |= ImGuiNextWindowDataFlags_HasBgAlpha;
    g.NextWindowData.BgAlphaVal = alpha;
}

// [forward declared comment]:
// set next window viewport
SetNextWindowViewport :: proc(id : ImGuiID)
{
    g := GImGui;
    g.NextWindowData.Flags |= ImGuiNextWindowDataFlags_HasViewport;
    g.NextWindowData.ViewportId = id;
}

// [forward declared comment]:
// set next window dock id
SetNextWindowDockID :: proc(id : ImGuiID, cond : ImGuiCond = {})
{
    g := GImGui;
    g.NextWindowData.Flags |= ImGuiNextWindowDataFlags_HasDock;
    g.NextWindowData.DockCond = cond ? cond : ImGuiCond_Always;
    g.NextWindowData.DockId = id;
}

// [forward declared comment]:
// set next window class (control docking compatibility + provide hints to platform backend via custom viewport flags and platform parent/child relationship)
SetNextWindowClass :: proc(window_class : ^ImGuiWindowClass)
{
    g := GImGui;
    assert((window_class.ViewportFlagsOverrideSet & window_class.ViewportFlagsOverrideClear) == 0); // Cannot set both set and clear for the same bit
    g.NextWindowData.Flags |= ImGuiNextWindowDataFlags_HasWindowClass;
    g.NextWindowData.WindowClass = window_class^;
}

// This is experimental and meant to be a toy for exploring a future/wider range of features.
SetNextWindowRefreshPolicy :: proc(flags : ImGuiWindowRefreshFlags)
{
    g := GImGui;
    g.NextWindowData.Flags |= ImGuiNextWindowDataFlags_HasRefreshPolicy;
    g.NextWindowData.RefreshFlagsVal = flags;
}

// [forward declared comment]:
// get draw list associated to the current window, to append your own drawing primitives
GetWindowDrawList :: proc() -> ^ImDrawList
{
    window := GetCurrentWindow();
    return window.DrawList;
}

// [forward declared comment]:
// get DPI scale currently associated to the current window's viewport.
GetWindowDpiScale :: proc() -> f32
{
    g := GImGui;
    return g.CurrentDpiScale;
}

GetWindowViewport :: proc() -> ^ImGuiViewport
{
    g := GImGui;
    assert(g.CurrentViewport != nil && g.CurrentViewport == g.CurrentWindow.Viewport);
    return g.CurrentViewport;
}

// [forward declared comment]:
// get current font
GetFont :: proc() -> ^ImFont
{
    return GImGui.Font;
}

// [forward declared comment]:
// get current font size (= height in pixels) of current font with current scale applied
GetFontSize :: proc() -> f32
{
    return GImGui.FontSize;
}

// [forward declared comment]:
// get UV coordinate for a white pixel, useful to draw custom shapes via the ImDrawList API
GetFontTexUvWhitePixel :: proc() -> ImVec2
{
    return GImGui.DrawListSharedData.TexUvWhitePixel;
}

// [forward declared comment]:
// [OBSOLETE] set font scale. Adjust IO.FontGlobalScale if you want to scale all windows. This is an old API! For correct scaling, prefer to reload font + rebuild ImFontAtlas + call style.ScaleAllSizes().
SetWindowFontScale :: proc(scale : f32)
{
    assert(scale > 0.0);
    g := GImGui;
    window := GetCurrentWindow();
    window.FontWindowScale = scale;
    g.DrawListSharedData.FontSize = window.CalcFontSize();
    g.FontSize = g.DrawListSharedData.FontSize
    g.DrawListSharedData.FontScale = g.FontSize / g.Font.FontSize;
    g.FontScale = g.DrawListSharedData.FontScale
}

PushFocusScope :: proc(id : ImGuiID)
{
    g := GImGui;
    data : ImGuiFocusScopeData
    data.ID = id;
    data.WindowID = g.CurrentWindow.ID;
    g.FocusScopeStack.append(data);
    g.CurrentFocusScopeId = id;
}

PopFocusScope :: proc()
{
    g := GImGui;
    if (len(g.FocusScopeStack) <= g.StackSizesInBeginForCurrentWindow.SizeOfFocusScopeStack)
    {
        IM_ASSERT_USER_ERROR(false, "Calling PopFocusScope() too many times!");
        return;
    }
    g.FocusScopeStack.pop_back();
    g.CurrentFocusScopeId = len(g.FocusScopeStack) ? g.FocusScopeStack.back().ID : 0;
}

SetNavFocusScope :: proc(focus_scope_id : ImGuiID)
{
    g := GImGui;
    g.NavFocusScopeId = focus_scope_id;
    g.NavFocusRoute.resize(0); // Invalidate
    if (focus_scope_id == 0)   do return
    assert(g.NavWindow != nil);

    // Store current path (in reverse order)
    if (focus_scope_id == g.CurrentFocusScopeId)
    {
        // Top of focus stack contains local focus scopes inside current window
        for n := len(g.FocusScopeStack) - 1; n >= 0 && g.FocusScopeStack.Data[n].WindowID == g.CurrentWindow.ID; n -= 1 {
            g.NavFocusRoute.append(g.FocusScopeStack.Data[n]);
        }
    }
    else if (focus_scope_id == g.NavWindow.NavRootFocusScopeId) {
        g.NavFocusRoute.append({ focus_scope_id, g.NavWindow.ID });
    }
    else {
        return;
    }

    // Then follow on manually set ParentWindowForFocusRoute field (#6798)
    for ImGuiWindow* window = g.NavWindow.ParentWindowForFocusRoute; window != nil; window = window.ParentWindowForFocusRoute {
        g.NavFocusRoute.append({ window.NavRootFocusScopeId, window.ID });
    }
    assert(len(g.NavFocusRoute) < 100); // Maximum depth is technically 251 as per CalcRoutingScore(): 254 - 3
}

// Focus = move navigation cursor, set scrolling, set focus window.
// [forward declared comment]:
// Focus last item (no selection/activation).
FocusItem :: proc()
{
    g := GImGui;
    window := g.CurrentWindow;
    IMGUI_DEBUG_LOG_FOCUS("FocusItem(0x%08x) in window \"%s\"\n", g.LastItemData.ID, window.Name);
    if (g.DragDropActive || g.MovingWindow != nil) // FIXME: Opt-in flags for this?
    {
        IMGUI_DEBUG_LOG_FOCUS("FocusItem() ignored while DragDropActive!\n");
        return;
    }

    move_flags := ImGuiNavMoveFlags_IsTabbing | ImGuiNavMoveFlags_FocusApi | ImGuiNavMoveFlags_NoSetNavCursorVisible | ImGuiNavMoveFlags_NoSelect;
    scroll_flags := window.Appearing ? ImGuiScrollFlags_KeepVisibleEdgeX | ImGuiScrollFlags_AlwaysCenterY : ImGuiScrollFlags_KeepVisibleEdgeX | ImGuiScrollFlags_KeepVisibleEdgeY;
    SetNavWindow(window);
    NavMoveRequestSubmit(nil, ImGuiDir.Up, move_flags, scroll_flags);
    NavMoveRequestResolveWithLastItem(&g.NavMoveResultLocal);
}

// [forward declared comment]:
// Activate an item by ID (button, checkbox, tree node etc.). Activation is queued and processed on the next frame when the item is encountered again.
ActivateItemByID :: proc(id : ImGuiID)
{
    g := GImGui;
    g.NavNextActivateId = id;
    g.NavNextActivateFlags = ImGuiActivateFlags_None;
}

// Note: this will likely be called ActivateItem() once we rework our Focus/Activation system!
// But ActivateItem() should function without altering scroll/focus?
// [forward declared comment]:
// focus keyboard on the next widget. Use positive 'offset' to access sub components of a multiple component widget. Use -1 to access previous widget.
SetKeyboardFocusHere :: proc(offset : i32 = 0)
{
    g := GImGui;
    window := g.CurrentWindow;
    assert(offset >= -1);    // -1 is allowed but not below
    IMGUI_DEBUG_LOG_FOCUS("SetKeyboardFocusHere(%d) in window \"%s\"\n", offset, window.Name);

    // It makes sense in the vast majority of cases to never interrupt a drag and drop.
    // When we refactor this function into ActivateItem() we may want to make this an option.
    // MovingWindow is protected from most user inputs using SetActiveIdUsingNavAndKeys(), but
    // is also automatically dropped in the event g.ActiveId is stolen.
    if (g.DragDropActive || g.MovingWindow != nil)
    {
        IMGUI_DEBUG_LOG_FOCUS("SetKeyboardFocusHere() ignored while DragDropActive!\n");
        return;
    }

    SetNavWindow(window);

    move_flags := ImGuiNavMoveFlags_IsTabbing | ImGuiNavMoveFlags_Activate | ImGuiNavMoveFlags_FocusApi | ImGuiNavMoveFlags_NoSetNavCursorVisible;
    scroll_flags := window.Appearing ? ImGuiScrollFlags_KeepVisibleEdgeX | ImGuiScrollFlags_AlwaysCenterY : ImGuiScrollFlags_KeepVisibleEdgeX | ImGuiScrollFlags_KeepVisibleEdgeY;
    NavMoveRequestSubmit(nil, offset < 0 ? ImGuiDir.Up : ImGuiDir.Down, move_flags, scroll_flags); // FIXME-NAV: Once we refactor tabbing, add LegacyApi flag to not activate non-inputable.
    if (offset == -1)
    {
        NavMoveRequestResolveWithLastItem(&g.NavMoveResultLocal);
    }
    else
    {
        g.NavTabbingDir = 1;
        g.NavTabbingCounter = offset + 1;
    }
}

// [forward declared comment]:
// make last item the default focused item of of a newly appearing window.
SetItemDefaultFocus :: proc()
{
    g := GImGui;
    window := g.CurrentWindow;
    if (!window.Appearing)   do return
    if (g.NavWindow != window.RootWindowForNav || (!g.NavInitRequest && g.NavInitResult.ID == 0) || g.NavLayer != window.DC.NavLayerCurrent)   do return

    g.NavInitRequest = false;
    NavApplyItemToResult(&g.NavInitResult);
    NavUpdateAnyRequestFlag();

    // Scroll could be done in NavInitRequestApplyResult() via an opt-in flag (we however don't want regular init requests to scroll)
    if (!window.ClipRect.Contains(g.LastItemData.Rect)) {
        ScrollToRectEx(window, g.LastItemData.Rect, ImGuiScrollFlags_None);
    }
}

// [forward declared comment]:
// replace current window storage with our own (if you want to manipulate it yourself, typically clear subsection of it)
SetStateStorage :: proc(tree : ^ImGuiStorage)
{
    window := GImGui.CurrentWindow;
    window.DC.StateStorage = tree ? tree : &window.StateStorage;
}

GetStateStorage :: proc() -> ^ImGuiStorage
{
    window := GImGui.CurrentWindow;
    return window.DC.StateStorage;
}

// [forward declared comment]:
// test if rectangle (in screen space) is visible / not clipped. to perform coarse clipping on user's side.
IsRectVisible :: proc(size : ImVec2) -> bool
{
    window := GImGui.CurrentWindow;
    return window.ClipRect.Overlaps(ImRect{ _v = {window.DC.CursorPos, window.DC.CursorPos + size}});
}

// [forward declared comment]:
// test if rectangle (in screen space) is visible / not clipped. to perform coarse clipping on user's side.
IsRectVisible :: proc(rect_min : ImVec2, rect_max : ImVec2) -> bool
{
    window := GImGui.CurrentWindow;
    return window.ClipRect.Overlaps(ImRect{ _v = {rect_min, rect_max}});
}

//-----------------------------------------------------------------------------
// [SECTION] ID STACK
//-----------------------------------------------------------------------------

// This is one of the very rare legacy case where we use ImGuiWindow methods,
// it should ideally be flattened at some point but it's been used a lots by widgets.
GetID_s_e :: proc(this : ^ImGuiWindow, str : ^u8, str_end : ^u8) -> ImGuiID
{
    seed := IDStack.back();
    id := ImHashStr(str, str_end ? (str_end - str) : 0, seed);
when !(IMGUI_DISABLE_DEBUG_TOOLS) {
    g := Ctx;
    if (g.DebugHookIdInfo == id) {
        DebugHookIdInfo(id, ImGuiDataType.String, str, str_end);
    }
}
    return id;
}

GetID_raw :: proc(this : ^ImGuiWindow, ptr : rawptr) -> ImGuiID
{
    seed := IDStack.back();
    id := ImHashData(&ptr, size_of(rawptr), seed);
when !(IMGUI_DISABLE_DEBUG_TOOLS) {
    g := Ctx;
    if (g.DebugHookIdInfo == id) {
        DebugHookIdInfo(id, ImGuiDataType.Pointer, ptr, nil);
    }
}
    return id;
}

GetID_i :: proc(this : ^ImGuiWindow, n : i32) -> ImGuiID
{
    seed := IDStack.back();
    id := ImHashData(&n, size_of(n), seed);
when !(IMGUI_DISABLE_DEBUG_TOOLS) {
    g := Ctx;
    if (g.DebugHookIdInfo == id) {
        DebugHookIdInfo(id, ImGuiDataType.S32, cast(rawptr) cast(rawptr)n, nil);
    }
}
    return id;
}

// This is only used in rare/specific situations to manufacture an ID out of nowhere.
// FIXME: Consider instead storing last non-zero ID + count of successive zero-ID, and combine those?
GetIDFromPos :: proc(this : ^ImGuiWindow, p_abs : ImVec2) -> ImGuiID
{
    seed := IDStack.back();
    p_rel := WindowPosAbsToRel(this, p_abs);
    id := ImHashData(&p_rel, size_of(p_rel), seed);
    return id;
}

// "
GetIDFromRectangle :: proc(this : ^ImGuiWindow, r_abs : ^ImRect) -> ImGuiID
{
    seed := IDStack.back();
    r_rel := WindowRectAbsToRel(this, r_abs);
    id := ImHashData(&r_rel, size_of(r_rel), seed);
    return id;
}

// [forward declared comment]:
// push integer into the ID stack (will hash integer).
PushID :: proc(str_id : ^u8)
{
    g := GImGui;
    window := g.CurrentWindow;
    id := GetID(window, str_id);
    window.IDStack.append(id);
}

// [forward declared comment]:
// push integer into the ID stack (will hash integer).
PushID :: proc(str_id_begin : ^u8, str_id_end : ^u8)
{
    g := GImGui;
    window := g.CurrentWindow;
    id := GetID(window, str_id_begin, str_id_end);
    window.IDStack.append(id);
}

// [forward declared comment]:
// push integer into the ID stack (will hash integer).
PushID :: proc(ptr_id : rawptr)
{
    g := GImGui;
    window := g.CurrentWindow;
    id := GetID(window, ptr_id);
    window.IDStack.append(id);
}

// [forward declared comment]:
// push integer into the ID stack (will hash integer).
PushID :: proc(int_id : i32)
{
    g := GImGui;
    window := g.CurrentWindow;
    id := GetID(window, int_id);
    window.IDStack.append(id);
}

// Push a given id value ignoring the ID stack as a seed.
// [forward declared comment]:
// Push given value as-is at the top of the ID stack (whereas PushID combines old and new hashes)
PushOverrideID :: proc(id : ImGuiID)
{
    g := GImGui;
    window := g.CurrentWindow;
when !(IMGUI_DISABLE_DEBUG_TOOLS) {
    if (g.DebugHookIdInfo == id) {
        DebugHookIdInfo(id, ImGuiDataType.ID, nil, nil);
    }
}
    window.IDStack.append(id);
}

// Helper to avoid a common series of PushOverrideID -> GetID() -> PopID() call
// (note that when using this pattern, ID Stack Tool will tend to not display the intermediate stack level.
//  for that to work we would need to do PushOverrideID() -> ItemAdd() -> PopID() which would alter widget code a little more)
GetIDWithSeed :: proc(str : ^u8, str_end : ^u8, seed : ImGuiID) -> ImGuiID
{
    id := ImHashStr(str, str_end ? (str_end - str) : 0, seed);
when !(IMGUI_DISABLE_DEBUG_TOOLS) {
    g := GImGui;
    if (g.DebugHookIdInfo == id) {
        DebugHookIdInfo(id, ImGuiDataType.String, str, str_end);
    }
}
    return id;
}

GetIDWithSeed :: proc(n : i32, seed : ImGuiID) -> ImGuiID
{
    id := ImHashData(&n, size_of(n), seed);
when !(IMGUI_DISABLE_DEBUG_TOOLS) {
    g := GImGui;
    if (g.DebugHookIdInfo == id) {
        DebugHookIdInfo(id, ImGuiDataType.S32, cast(rawptr) cast(rawptr)n, nil);
    }
}
    return id;
}

// [forward declared comment]:
// pop from the ID stack.
PopID :: proc()
{
    window := GImGui.CurrentWindow;
    if (len(window.IDStack) <= 1)
    {
        IM_ASSERT_USER_ERROR(false, "Calling PopID() too many times!");
        return;
    }
    window.IDStack.pop_back();
}

GetID_g_s :: proc(str_id : ^u8) -> ImGuiID
{
    window := GImGui.CurrentWindow;
    return GetID(window, str_id);
}

GetID_g_s_e :: proc(str_id_begin : ^u8, str_id_end : ^u8) -> ImGuiID
{
    window := GImGui.CurrentWindow;
    return GetID(window, str_id_begin, str_id_end);
}

GetID_g_raw :: proc(ptr_id : rawptr) -> ImGuiID
{
    window := GImGui.CurrentWindow;
    return GetID(window, ptr_id);
}

GetID_g_i :: proc(int_id : i32) -> ImGuiID
{
    window := GImGui.CurrentWindow;
    return GetID(window, int_id);
}

//-----------------------------------------------------------------------------
// [SECTION] INPUTS
//-----------------------------------------------------------------------------
// - GetModForLRModKey() [Internal]
// - FixupKeyChord() [Internal]
// - GetKeyData() [Internal]
// - GetKeyIndex() [Internal]
// - GetKeyName()
// - GetKeyChordName() [Internal]
// - CalcTypematicRepeatAmount() [Internal]
// - GetTypematicRepeatRate() [Internal]
// - GetKeyPressedAmount() [Internal]
// - GetKeyMagnitude2d() [Internal]
//-----------------------------------------------------------------------------
// - UpdateKeyRoutingTable() [Internal]
// - GetRoutingIdFromOwnerId() [Internal]
// - GetShortcutRoutingData() [Internal]
// - CalcRoutingScore() [Internal]
// - SetShortcutRouting() [Internal]
// - TestShortcutRouting() [Internal]
//-----------------------------------------------------------------------------
// - IsKeyDown()
// - IsKeyPressed()
// - IsKeyReleased()
//-----------------------------------------------------------------------------
// - IsMouseDown()
// - IsMouseClicked()
// - IsMouseReleased()
// - IsMouseDoubleClicked()
// - GetMouseClickedCount()
// - IsMouseHoveringRect() [Internal]
// - IsMouseDragPastThreshold() [Internal]
// - IsMouseDragging()
// - GetMousePos()
// - SetMousePos() [Internal]
// - GetMousePosOnOpeningCurrentPopup()
// - IsMousePosValid()
// - IsAnyMouseDown()
// - GetMouseDragDelta()
// - ResetMouseDragDelta()
// - GetMouseCursor()
// - SetMouseCursor()
//-----------------------------------------------------------------------------
// - UpdateAliasKey()
// - GetMergedModsFromKeys()
// - UpdateKeyboardInputs()
// - UpdateMouseInputs()
//-----------------------------------------------------------------------------
// - LockWheelingWindow [Internal]
// - FindBestWheelingWindow [Internal]
// - UpdateMouseWheel() [Internal]
//-----------------------------------------------------------------------------
// - SetNextFrameWantCaptureKeyboard()
// - SetNextFrameWantCaptureMouse()
//-----------------------------------------------------------------------------
// - GetInputSourceName() [Internal]
// - DebugPrintInputEvent() [Internal]
// - UpdateInputEvents() [Internal]
//-----------------------------------------------------------------------------
// - GetKeyOwner() [Internal]
// - TestKeyOwner() [Internal]
// - SetKeyOwner() [Internal]
// - SetItemKeyOwner() [Internal]
// - Shortcut() [Internal]
//-----------------------------------------------------------------------------

GetModForLRModKey :: proc(key : ImGuiKey) -> ImGuiKeyChord
{
    if (key == ImGuiKey.LeftCtrl || key == ImGuiKey.RightCtrl)   do return ImGuiKey.Mod_Ctrl
    if (key == ImGuiKey.LeftShift || key == ImGuiKey.RightShift)   do return ImGuiKey.Mod_Shift
    if (key == ImGuiKey.LeftAlt || key == ImGuiKey.RightAlt)   do return ImGuiKey.Mod_Alt
    if (key == ImGuiKey.LeftSuper || key == ImGuiKey.RightSuper)   do return ImGuiKey.Mod_Super
    return ImGuiKey.Mod_None;
}

FixupKeyChord :: proc(key_chord : ImGuiKeyChord) -> ImGuiKeyChord
{
    // Add ImGuiMod_XXXX when a corresponding ImGuiKey.LeftXXX/ImGuiKey.RightXXX is specified.
    key := (ImGuiKey)(key_chord & ~ImGuiKey.Mod_Mask_);
    if (IsLRModKey(key))  do key_chord |= GetModForLRModKey(key);
    return key_chord;
}

GetKeyData_ctx :: proc(ctx : ^ImGuiContext, key : ImGuiKey) -> ^ImGuiKeyData
{
    g := ctx;

    // Special storage location for mods
    if (key & ImGuiKey.Mod_Mask_)  do key = ConvertSingleModFlagToKey(key);

    assert(IsNamedKey(key), "Support for user key indices was dropped in favor of ImGuiKey. Please update backend & user code.");
    return &g.IO.KeysData[key - ImGuiKey.NamedKey_BEGIN];
}

// Those names a provided for debugging purpose and are not meant to be saved persistently not compared.
GKeyNames := [?]string {
    "Tab", "LeftArrow", "RightArrow", "UpArrow", "DownArrow", "PageUp", "PageDown",
    "Home", "End", "Insert", "Delete", "Backspace", "Space", "Enter", "Escape",
    "LeftCtrl", "LeftShift", "LeftAlt", "LeftSuper", "RightCtrl", "RightShift", "RightAlt", "RightSuper", "Menu",
    "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "A", "B", "C", "D", "E", "F", "G", "H",
    "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z",
    "F1", "F2", "F3", "F4", "F5", "F6", "F7", "F8", "F9", "F10", "F11", "F12",
    "F13", "F14", "F15", "F16", "F17", "F18", "F19", "F20", "F21", "F22", "F23", "F24",
    "Apostrophe", "Comma", "Minus", "Period", "Slash", "Semicolon", "Equal", "LeftBracket",
    "Backslash", "RightBracket", "GraveAccent", "CapsLock", "ScrollLock", "NumLock", "PrintScreen",
    "Pause", "Keypad0", "Keypad1", "Keypad2", "Keypad3", "Keypad4", "Keypad5", "Keypad6",
    "Keypad7", "Keypad8", "Keypad9", "KeypadDecimal", "KeypadDivide", "KeypadMultiply",
    "KeypadSubtract", "KeypadAdd", "KeypadEnter", "KeypadEqual",
    "AppBack", "AppForward",
    "GamepadStart", "GamepadBack",
    "GamepadFaceLeft", "GamepadFaceRight", "GamepadFaceUp", "GamepadFaceDown",
    "GamepadDpadLeft", "GamepadDpadRight", "GamepadDpadUp", "GamepadDpadDown",
    "GamepadL1", "GamepadR1", "GamepadL2", "GamepadR2", "GamepadL3", "GamepadR3",
    "GamepadLStickLeft", "GamepadLStickRight", "GamepadLStickUp", "GamepadLStickDown",
    "GamepadRStickLeft", "GamepadRStickRight", "GamepadRStickUp", "GamepadRStickDown",
    "MouseLeft", "MouseRight", "MouseMiddle", "MouseX1", "MouseX2", "MouseWheelX", "MouseWheelY",
    "ModCtrl", "ModShift", "ModAlt", "ModSuper", // ReservedForModXXX are showing the ModXXX names.
};
#assert(ImGuiKey.NamedKey_COUNT == len(GKeyNames));

// [forward declared comment]:
// [DEBUG] returns English name of the key. Those names a provided for debugging purpose and are not meant to be saved persistently not compared.
GetKeyName :: proc(key : ImGuiKey) -> ^u8
{
    if (key == ImGuiKey.None)   do return "None"
    assert(IsNamedKeyOrMod(key), "Support for user key indices was dropped in favor of ImGuiKey. Please update backend and user code.");
    if (key & ImGuiKey.Mod_Mask_)  do key = ConvertSingleModFlagToKey(key);
    if (!IsNamedKey(key))   do return "Unknown"

    return GKeyNames[key - ImGuiKey.NamedKey_BEGIN];
}

// Return untranslated names: on macOS, Cmd key will show as Ctrl, Ctrl key will show as super.
// Lifetime of return value: valid until next call to same function.
GetKeyChordName :: proc(key_chord : ImGuiKeyChord) -> ^u8
{
    g := GImGui;

    key := (ImGuiKey)(key_chord & ~ImGuiKey.Mod_Mask_);
    if (IsLRModKey(key))  do key_chord &= ~GetModForLRModKey(key); // Return "Ctrl+LeftShift" instead of "Ctrl+Shift+LeftShift"
    ImFormatString(g.TempKeychordName, len(g.TempKeychordName), "%s%s%s%s%s",
        (key_chord & ImGuiKey.Mod_Ctrl) ? "Ctrl+" : "",
        (key_chord & ImGuiKey.Mod_Shift) ? "Shift+" : "",
        (key_chord & ImGuiKey.Mod_Alt) ? "Alt+" : "",
        (key_chord & ImGuiKey.Mod_Super) ? "Super+" : "",
        (key != ImGuiKey.None || key_chord == ImGuiKey.None) ? GetKeyName(key) : "");
    len : int
    if (key == ImGuiKey.None && key_chord != 0) {
        len = strlen(g.TempKeychordName)
        if (len != 0) { // Remove trailing '+'
            g.TempKeychordName[len - 1] = 0;
        }
    }
    return g.TempKeychordName;
}

// t0 = previous time (e.g.: g.Time - g.IO.DeltaTime)
// t1 = current time (e.g.: g.Time)
// An event is triggered at:
//  t = 0.0f     t = repeat_delay,    t = repeat_delay + repeat_rate*N
CalcTypematicRepeatAmount :: proc(t0 : f32, t1 : f32, repeat_delay : f32, repeat_rate : f32) -> i32
{
    if (t1 == 0.0)   do return 1
    if (t0 >= t1)   do return 0
    if (repeat_rate <= 0.0) {
        return (t0 < repeat_delay) && (t1 >= repeat_delay);
    }
    count_t0 := (t0 < repeat_delay) ? -1 : (i32)((t0 - repeat_delay) / repeat_rate);
    count_t1 := (t1 < repeat_delay) ? -1 : (i32)((t1 - repeat_delay) / repeat_rate);
    count := count_t1 - count_t0;
    return count;
}

GetTypematicRepeatRate :: proc(flags : ImGuiInputFlags, repeat_delay : ^f32, repeat_rate : ^f32)
{
    g := GImGui;
    switch (flags & ImGuiInputFlags_RepeatRateMask_)
    {
    case ImGuiInputFlags_RepeatRateNavMove:             repeat_delay^ = g.IO.KeyRepeatDelay * 0.72; repeat_rate^ = g.IO.KeyRepeatRate * 0.80; return;
    case ImGuiInputFlags_RepeatRateNavTweak:            repeat_delay^ = g.IO.KeyRepeatDelay * 0.72; repeat_rate^ = g.IO.KeyRepeatRate * 0.30; return;
    case ImGuiInputFlags_RepeatRatecase: case:    repeat_delay^ = g.IO.KeyRepeatDelay * 1.00; repeat_rate^ = g.IO.KeyRepeatRate * 1.00; return;
    }
}

// Return value representing the number of presses in the last time period, for the given repeat rate
// (most often returns 0 or 1. The result is generally only >1 when RepeatRate is smaller than DeltaTime, aka large DeltaTime or fast RepeatRate)
// [forward declared comment]:
// uses provided repeat rate/delay. return a count, most often 0 or 1 but might be >1 if RepeatRate is small enough that DeltaTime > RepeatRate
GetKeyPressedAmount :: proc(key : ImGuiKey, repeat_delay : f32, repeat_rate : f32) -> i32
{
    g := GImGui;
    key_data := GetKeyData(key);
    if (!key_data.Down) do return 0; // In theory this should already be encoded as (DownDuration < 0.0f), but testing this facilitates eating mechanism (until we finish work on key ownership) 
    t := key_data.DownDuration;
    return CalcTypematicRepeatAmount(t - g.IO.DeltaTime, t, repeat_delay, repeat_rate);
}

// Return 2D vector representing the combination of four cardinal direction, with analog value support (for e.g. ImGuiKey.GamepadLStick* values).
GetKeyMagnitude2d :: proc(key_left : ImGuiKey, key_right : ImGuiKey, key_up : ImGuiKey, key_down : ImGuiKey) -> ImVec2
{
    return ImVec2(
        GetKeyData(key_right)->AnalogValue - GetKeyData(key_left)->AnalogValue,
        GetKeyData(key_down)->AnalogValue - GetKeyData(key_up)->AnalogValue);
}

// Rewrite routing data buffers to strip old entries + sort by key to make queries not touch scattered data.
//   Entries   D,A,B,B,A,C,B     --> A,A,B,B,B,C,D
//   Index     A:1 B:2 C:5 D:0   --> A:0 B:2 C:5 D:6
// See 'Metrics->Key Owners & Shortcut Routing' to visualize the result of that operation.
UpdateKeyRoutingTable :: proc(rt : ^ImGuiKeyRoutingTable)
{
    g := GImGui;
    rt.EntriesNext.resize(0);
    for key := ImGuiKey.NamedKey_BEGIN; key < ImGuiKey.NamedKey_END; key = (ImGuiKey)(key + 1)
    {
        new_routing_start_idx := len(rt.EntriesNext);
        routing_entry : ^ImGuiKeyRoutingData
        for old_routing_idx := rt.Index[key - ImGuiKey.NamedKey_BEGIN]; old_routing_idx != -1; old_routing_idx = routing_entry.NextEntryIndex
        {
            routing_entry = &rt.Entries[old_routing_idx];
            routing_entry.RoutingCurrScore = routing_entry.RoutingNextScore;
            routing_entry.RoutingCurr = routing_entry.RoutingNext; // Update entry
            routing_entry.RoutingNext = ImGuiKeyOwner_NoOwner;
            routing_entry.RoutingNextScore = 255;
            if (routing_entry.RoutingCurr == ImGuiKeyOwner_NoOwner)   do continue
            append(&rt.EntriesNext, routing_entry^); // Write alive ones into new buffer

            // Apply routing to owner if there's no owner already (RoutingCurr == None at this point)
            // This is the result of previous frame's SetShortcutRouting() call.
            if (routing_entry.Mods == g.IO.KeyMods)
            {
                owner_data := GetKeyOwnerData(g, key);
                if (owner_data.OwnerCurr == ImGuiKeyOwner_NoOwner)
                {
                    owner_data.OwnerCurr = routing_entry.RoutingCurr;
                    //IMGUI_DEBUG_LOG("SetKeyOwner(%s, owner_id=0x%08X) via Routing\n", GetKeyName(key), routing_entry.RoutingCurr);
                }
            }
        }

        // Rewrite linked-list
        rt.Index[key - ImGuiKey.NamedKey_BEGIN] = (ImGuiKeyRoutingIndex)(new_routing_start_idx < len(rt.EntriesNext) ? new_routing_start_idx : -1);
        for n := new_routing_start_idx; n < len(rt.EntriesNext); n += 1 {
            rt.EntriesNext[n].NextEntryIndex = (ImGuiKeyRoutingIndex)((n + 1 < rt.EntriesNext.Size) ? n + 1 : -1);
        }
    }
    rt.Entries.swap(rt.EntriesNext); // Swap new and old indexes
}

// owner_id may be None/Any, but routing_id needs to be always be set, so we default to GetCurrentFocusScope().
GetRoutingIdFromOwnerId :: #force_inline proc(owner_id : ImGuiID) -> ImGuiID
{
    g := GImGui;
    return (owner_id != ImGuiKeyOwner_NoOwner && owner_id != ImGuiKeyOwner_Any) ? owner_id : g.CurrentFocusScopeId;
}

GetShortcutRoutingData :: proc(key_chord : ImGuiKeyChord) -> ^ImGuiKeyRoutingData
{
    // Majority of shortcuts will be Key + any number of Mods
    // We accept _Single_ mod with ImGuiKey.None.
    //  - Shortcut(ImGuiKey.S | ImGuiKey.Mod_Ctrl);                    // Legal
    //  - Shortcut(ImGuiKey.S | ImGuiKey.Mod_Ctrl | ImGuiKey.Mod_Shift);   // Legal
    //  - Shortcut(ImGuiKey.Mod_Ctrl);                                 // Legal
    //  - Shortcut(ImGuiKey.Mod_Ctrl | ImGuiKey.Mod_Shift);                // Not legal
    g := GImGui;
    rt := &g.KeysRoutingTable;
    routing_data : ^ImGuiKeyRoutingData
    key := (ImGuiKey)(key_chord & ~ImGuiKey.Mod_Mask_);
    mods := (ImGuiKey)(key_chord & ImGuiKey.Mod_Mask_);
    if (key == ImGuiKey.None) {
        key = ConvertSingleModFlagToKey(mods);
    }
    assert(IsNamedKey(key));

    // Get (in the majority of case, the linked list will have one element so this should be 2 reads.
    // Subsequent elements will be contiguous in memory as list is sorted/rebuilt in NewFrame).
    for idx := rt.Index[key - ImGuiKey.NamedKey_BEGIN]; idx != -1; idx = routing_data.NextEntryIndex
    {
        routing_data = &rt.Entries[idx];
        if (routing_data.Mods == mods)   do return routing_data
    }

    // Add to linked-list
    routing_data_idx := cast(ImGuiKeyRoutingIndex)len(rt.Entries);
    rt.Entries.append(ImGuiKeyRoutingData());
    routing_data = &rt.Entries[routing_data_idx];
    routing_data.Mods = cast(u16) mods;
    routing_data.NextEntryIndex = rt.Index[key - ImGuiKey.NamedKey_BEGIN]; // Setup linked list
    rt.Index[key - ImGuiKey.NamedKey_BEGIN] = routing_data_idx;
    return routing_data;
}

// Current score encoding (lower is highest priority):
//  -   0: ImGuiInputFlags_RouteGlobal | ImGuiInputFlags_RouteOverActive
//  -   1: ImGuiInputFlags_ActiveItem or ImGuiInputFlags_RouteFocused (if item active)
//  -   2: ImGuiInputFlags_RouteGlobal | ImGuiInputFlags_RouteOverFocused
//  -  3+: ImGuiInputFlags_RouteFocused (if window in focus-stack)
//  - 254: ImGuiInputFlags_RouteGlobal
//  - 255: never route
// 'flags' should include an explicit routing policy
CalcRoutingScore :: proc(focus_scope_id : ImGuiID, owner_id : ImGuiID, flags : ImGuiInputFlags) -> i32
{
    g := GImGui;
    if (.RouteFocused in flags)
    {
        // ActiveID gets top priority
        // (we don't check g.ActiveIdUsingAllKeys here. Routing is applied but if input ownership is tested later it may discard it)
        if (owner_id != 0 && g.ActiveId == owner_id)   do return 1

        // Score based on distance to focused window (lower is better)
        // Assuming both windows are submitting a routing request,
        // - When Window....... is focused -> Window scores 3 (best), Window/ChildB scores 255 (no match)
        // - When Window/ChildB is focused -> Window scores 4,        Window/ChildB scores 3 (best)
        // Assuming only WindowA is submitting a routing request,
        // - When Window/ChildB is focused -> Window scores 4 (best), Window/ChildB doesn't have a score.
        // This essentially follow the window.ParentWindowForFocusRoute chain.
        if (focus_scope_id == 0)   do return 255
        for index_in_focus_path := 0; index_in_focus_path < len(g.NavFocusRoute); index_in_focus_path += 1 {
            if (g.NavFocusRoute.Data[index_in_focus_path].ID == focus_scope_id)   do return 3 + index_in_focus_path
        }
        return 255;
    }
    else if (.RouteActive in flags)
    {
        if (owner_id != 0 && g.ActiveId == owner_id)   do return 1
        return 255;
    }
    else if (.RouteGlobal in flags)
    {
        if (.RouteOverActive in flags)   do return 0
        if (.RouteOverFocused in flags)   do return 2
        return 254;
    }
    assert(false)
    return 0;
}

// - We need this to filter some Shortcut() routes when an item e.g. an InputText() is active
//   e.g. ImGuiKey.G won't be considered a shortcut when item is active, but ImGuiMod|ImGuiKey.G can be.
// - This is also used by UpdateInputEvents() to avoid trickling in the most common case of e.g. pressing ImGuiKey.G also emitting a G character.
IsKeyChordPotentiallyCharInput :: proc(key_chord : ImGuiKeyChord) -> bool
{
    // Mimic 'ignore_char_inputs' logic in InputText()
    g := GImGui;

    // When the right mods are pressed it cannot be a char input so we won't filter the shortcut out.
    mods := (ImGuiKey)(key_chord & ImGuiKey.Mod_Mask_);
    ignore_char_inputs := ((mods & ImGuiKey.Mod_Ctrl) && !(mods & ImGuiKey.Mod_Alt)) || (g.IO.ConfigMacOSXBehaviors && (mods & ImGuiKey.Mod_Ctrl));
    if (ignore_char_inputs)   do return false

    // Return true for A-Z, 0-9 and other keys associated to char inputs. Other keys such as F1-F12 won't be filtered.
    key := (ImGuiKey)(key_chord & ~ImGuiKey.Mod_Mask_);
    if (key == ImGuiKey.None)   do return false
    return g.KeysMayBeCharInput.TestBit(key);
}

// Request a desired route for an input chord (key + mods).
// Return true if the route is available this frame.
// - Routes and key ownership are attributed at the beginning of next frame based on best score and mod state.
//   (Conceptually this does a "Submit for next frame" + "Test for current frame".
//   As such, it could be called TrySetXXX or SubmitXXX, or the Submit and Test operations should be separate.)
// [forward declared comment]:
// owner_id needs to be explicit and cannot be 0
SetShortcutRouting :: proc(key_chord : ImGuiKeyChord, flags : ImGuiInputFlags, owner_id : ImGuiID) -> bool
{
    g := GImGui;
    if ((flags & ImGuiInputFlags_RouteTypeMask_) == 0) {
        flags |= ImGuiInputFlags_RouteGlobal | ImGuiInputFlags_RouteOverFocused | ImGuiInputFlags_RouteOverActive; // IMPORTANT: This is the default for SetShortcutRouting() but NOT Shortcut()
    }
    else {
        assert(math.is_power_of_two(flags & ImGuiInputFlags_RouteTypeMask_)); // Check that only 1 routing flag is used
    }
    assert(owner_id != ImGuiKeyOwner_Any && owner_id != ImGuiKeyOwner_NoOwner);
    if (flags & (ImGuiInputFlags_RouteOverFocused | ImGuiInputFlags_RouteOverActive | ImGuiInputFlags_RouteUnlessBgFocused)) {
        assert(.RouteGlobal in flags);
    }

    // Add ImGuiMod_XXXX when a corresponding ImGuiKey.LeftXXX/ImGuiKey.RightXXX is specified.
    key_chord = FixupKeyChord(key_chord);

    // [DEBUG] Debug break requested by user
    if (g.DebugBreakInShortcutRouting == key_chord)   do runtime.debug_trap()

    if (.RouteUnlessBgFocused in flags) {
        if (g.NavWindow == nil)   do return false
    }

    // Note how ImGuiInputFlags_RouteAlways won't set routing and thus won't set owner. May want to rework this?
    if (.RouteAlways in flags)
    {
        IMGUI_DEBUG_LOG_INPUTROUTING("SetShortcutRouting(%s, flags=%04X, owner_id=0x%08X) -> always, no register\n", GetKeyChordName(key_chord), flags, owner_id);
        return true;
    }

    // Specific culling when there's an active item.
    if (g.ActiveId != 0 && g.ActiveId != owner_id)
    {
        if (.RouteActive in flags)   do return false

        // Cull shortcuts with no modifiers when it could generate a character.
        // e.g. Shortcut(ImGuiKey.G) also generates 'g' character, should not trigger when InputText() is active.
        // but  Shortcut(Ctrl+G) should generally trigger when InputText() is active.
        // TL;DR: lettered shortcut with no mods or with only Alt mod will not trigger while an item reading text input is active.
        // (We cannot filter based on io.InputQueueCharacters[] contents because of trickling and key<>chars submission order are undefined)
        if (g.IO.WantTextInput && IsKeyChordPotentiallyCharInput(key_chord))
        {
            IMGUI_DEBUG_LOG_INPUTROUTING("SetShortcutRouting(%s, flags=%04X, owner_id=0x%08X) -> filtered as potential u8 input\n", GetKeyChordName(key_chord), flags, owner_id);
            return false;
        }

        // ActiveIdUsingAllKeyboardKeys trumps all for ActiveId
        if ((.RouteOverActive not_in flags) && g.ActiveIdUsingAllKeyboardKeys)
        {
            key := (ImGuiKey)(key_chord & ~ImGuiKey.Mod_Mask_);
            if (key == ImGuiKey.None) {
                key = ConvertSingleModFlagToKey((ImGuiKey)(key_chord & ImGuiKey.Mod_Mask_));
            }
            if (key >= ImGuiKey.Keyboard_BEGIN && key < ImGuiKey.Keyboard_END)   do return false
        }
    }

    // Where do we evaluate route for?
    focus_scope_id := g.CurrentFocusScopeId;
    if (.RouteFromRootWindow in flags) {
        focus_scope_id = g.CurrentWindow.RootWindow.ID; // See PushFocusScope() call in Begin()
    }

    score := CalcRoutingScore(focus_scope_id, owner_id, flags);
    IMGUI_DEBUG_LOG_INPUTROUTING("SetShortcutRouting(%s, flags=%04X, owner_id=0x%08X) -> score %d\n", GetKeyChordName(key_chord), flags, owner_id, score);
    if (score == 255)   do return false

    // Submit routing for NEXT frame (assuming score is sufficient)
    // FIXME: Could expose a way to use a "serve last" policy for same score resolution (using <= instead of <).
    routing_data := GetShortcutRoutingData(key_chord);
    //const bool set_route = (.ServeLast in flags) ? (score <= routing_data.RoutingNextScore) : (score < routing_data.RoutingNextScore);
    if (score < routing_data.RoutingNextScore)
    {
        routing_data.RoutingNext = owner_id;
        routing_data.RoutingNextScore = cast(u8) score;
    }

    // Return routing state for CURRENT frame
    if (routing_data.RoutingCurr == owner_id) {
        IMGUI_DEBUG_LOG_INPUTROUTING("--> granting current route\n");
    }
    return routing_data.RoutingCurr == owner_id;
}

// Currently unused by core (but used by tests)
// Note: this cannot be turned into GetShortcutRouting() because we do the owner_id.routing_id translation, name would be more misleading.
TestShortcutRouting :: proc(key_chord : ImGuiKeyChord, owner_id : ImGuiID) -> bool
{
    routing_id := GetRoutingIdFromOwnerId(owner_id);
    key_chord = FixupKeyChord(key_chord);
    routing_data := GetShortcutRoutingData(key_chord); // FIXME: Could avoid creating entry.
    return routing_data.RoutingCurr == routing_id;
}

// Note that Dear ImGui doesn't know the meaning/semantic of ImGuiKey from 0..511: they are legacy native keycodes.
// Consider transitioning from 'IsKeyDown(MY_ENGINE_KEY_A)' (<1.87) to IsKeyDown(ImGuiKey.A) (>= 1.87)
IsKeyDown :: proc(key : ImGuiKey) -> bool
{
    return IsKeyDown(key, ImGuiKeyOwner_Any);
}

IsKeyDown :: proc(key : ImGuiKey, owner_id : ImGuiID) -> bool
{
    key_data := GetKeyData(key);
    if (!key_data.Down)   do return false
    if (!TestKeyOwner(key, owner_id))   do return false
    return true;
}

// [forward declared comment]:
// Important: when transitioning from old to new IsKeyPressed(): old API has "bool repeat = true", so would default to repeat. New API requiress explicit ImGuiInputFlags_Repeat.
IsKeyPressed :: proc(key : ImGuiKey, repeat : bool) -> bool
{
    return IsKeyPressed(key, repeat ? ImGuiInputFlags_Repeat : ImGuiInputFlags_None, ImGuiKeyOwner_Any);
}

// Important: unlike legacy IsKeyPressed(ImGuiKey, bool repeat=true) which DEFAULT to repeat, this requires EXPLICIT repeat.
// [forward declared comment]:
// Important: when transitioning from old to new IsKeyPressed(): old API has "bool repeat = true", so would default to repeat. New API requiress explicit ImGuiInputFlags_Repeat.
IsKeyPressed :: proc(key : ImGuiKey, flags : ImGuiInputFlags, owner_id : ImGuiID = {}) -> bool
{
    key_data := GetKeyData(key);
    if (!key_data.Down) do return false // In theory this should already be encoded as (DownDuration < 0.0f), but testing this facilitates eating mechanism (until we finish work on key ownership)
    t := key_data.DownDuration;
    if (t < 0.0)   do return false
    assert((flags & ~ImGuiInputFlags_SupportedByIsKeyPressed) == 0); // Passing flags not supported by this function!
    if (flags & (ImGuiInputFlags_RepeatRateMask_ | ImGuiInputFlags_RepeatUntilMask_)) {// Setting any _RepeatXXX option enables _Repeat
        flags |= ImGuiInputFlags_Repeat;
    }

    pressed := (t == 0.0);
    if (!pressed && (.Repeat in flags) != 0)
    {
        repeat_delay, repeat_rate : f32
        GetTypematicRepeatRate(flags, &repeat_delay, &repeat_rate);
        pressed = (t > repeat_delay) && GetKeyPressedAmount(key, repeat_delay, repeat_rate) > 0;
        if (pressed && (flags & ImGuiInputFlags_RepeatUntilMask_))
        {
            // Slightly bias 'key_pressed_time' as DownDuration is an accumulation of DeltaTime which we compare to an absolute time value.
            // Ideally we'd replace DownDuration with KeyPressedTime but it would break user's code.
            g := GImGui;
            key_pressed_time := g.Time - t + 0.00001;
            if ((.RepeatUntilKeyModsChange in flags) && (g.LastKeyModsChangeTime > key_pressed_time))   do pressed = false
            if ((.RepeatUntilKeyModsChangeFromNone in flags) && (g.LastKeyModsChangeFromNoneTime > key_pressed_time))   do pressed = false
            if ((.RepeatUntilOtherKeyPress in flags) && (g.LastKeyboardKeyPressTime > key_pressed_time))   do pressed = false
        }
    }
    if (!pressed)   do return false
    if (!TestKeyOwner(key, owner_id))   do return false
    return true;
}

IsKeyReleased :: proc(key : ImGuiKey) -> bool
{
    return IsKeyReleased(key, ImGuiKeyOwner_Any);
}

IsKeyReleased :: proc(key : ImGuiKey, owner_id : ImGuiID) -> bool
{
    key_data := GetKeyData(key);
    if (key_data.DownDurationPrev < 0.0 || key_data.Down)   do return false
    if (!TestKeyOwner(key, owner_id))   do return false
    return true;
}

IsMouseDown :: proc(button : ImGuiMouseButton) -> bool
{
    g := GImGui;
    assert(button >= 0 && button < len(g.IO.MouseDown));
    return g.IO.MouseDown[button] && TestKeyOwner(MouseButtonToKey(button), ImGuiKeyOwner_Any); // should be same as IsKeyDown(MouseButtonToKey(button), ImGuiKeyOwner_Any), but this allows legacy code hijacking the io.Mousedown[] array.
}

IsMouseDown :: proc(button : ImGuiMouseButton, owner_id : ImGuiID) -> bool
{
    g := GImGui;
    assert(button >= 0 && button < len(g.IO.MouseDown));
    return g.IO.MouseDown[button] && TestKeyOwner(MouseButtonToKey(button), owner_id); // Should be same as IsKeyDown(MouseButtonToKey(button), owner_id), but this allows legacy code hijacking the io.Mousedown[] array.
}

IsMouseClicked :: proc(button : ImGuiMouseButton, repeat : bool) -> bool
{
    return IsMouseClicked(button, repeat ? ImGuiInputFlags_Repeat : ImGuiInputFlags_None, ImGuiKeyOwner_Any);
}

IsMouseClicked :: proc(button : ImGuiMouseButton, flags : ImGuiInputFlags, owner_id : ImGuiID = {}) -> bool
{
    g := GImGui;
    assert(button >= 0 && button < len(g.IO.MouseDown));
    if (!g.IO.MouseDown[button]) do return false // In theory this should already be encoded as (DownDuration < 0.0f), but testing this facilitates eating mechanism (until we finish work on key ownership)
    t := g.IO.MouseDownDuration[button];
    if (t < 0.0)   do return false
    assert((flags & ~ImGuiInputFlags_SupportedByIsMouseClicked) == 0); // Passing flags not supported by this function! // FIXME: Could support RepeatRate and RepeatUntil flags here.

    repeat := (.Repeat in flags)
    pressed := (t == 0.0) || (repeat && t > g.IO.KeyRepeatDelay && CalcTypematicRepeatAmount(t - g.IO.DeltaTime, t, g.IO.KeyRepeatDelay, g.IO.KeyRepeatRate) > 0);
    if (!pressed)   do return false

    if (!TestKeyOwner(MouseButtonToKey(button), owner_id))   do return false

    return true;
}

IsMouseReleased :: proc(button : ImGuiMouseButton) -> bool
{
    g := GImGui;
    assert(button >= 0 && button < len(g.IO.MouseDown));
    return g.IO.MouseReleased[button] && TestKeyOwner(MouseButtonToKey(button), ImGuiKeyOwner_Any); // Should be same as IsKeyReleased(MouseButtonToKey(button), ImGuiKeyOwner_Any)
}

IsMouseReleased :: proc(button : ImGuiMouseButton, owner_id : ImGuiID) -> bool
{
    g := GImGui;
    assert(button >= 0 && button < len(g.IO.MouseDown));
    return g.IO.MouseReleased[button] && TestKeyOwner(MouseButtonToKey(button), owner_id); // Should be same as IsKeyReleased(MouseButtonToKey(button), owner_id)
}

IsMouseDoubleClicked :: proc(button : ImGuiMouseButton) -> bool
{
    g := GImGui;
    assert(button >= 0 && button < len(g.IO.MouseDown));
    return g.IO.MouseClickedCount[button] == 2 && TestKeyOwner(MouseButtonToKey(button), ImGuiKeyOwner_Any);
}

IsMouseDoubleClicked :: proc(button : ImGuiMouseButton, owner_id : ImGuiID) -> bool
{
    g := GImGui;
    assert(button >= 0 && button < len(g.IO.MouseDown));
    return g.IO.MouseClickedCount[button] == 2 && TestKeyOwner(MouseButtonToKey(button), owner_id);
}

// [forward declared comment]:
// return the number of successive mouse-clicks at the time where a click happen (otherwise 0).
GetMouseClickedCount :: proc(button : ImGuiMouseButton) -> i32
{
    g := GImGui;
    assert(button >= 0 && button < len(g.IO.MouseDown));
    return g.IO.MouseClickedCount[button];
}

// Test if mouse cursor is hovering given rectangle
// NB- Rectangle is clipped by our current clip setting
// NB- Expand the rectangle to be generous on imprecise inputs systems (g.Style.TouchExtraPadding)
// [forward declared comment]:
// is mouse hovering given bounding rect (in screen space). clipped by current clipping settings, but disregarding of other consideration of focus/window ordering/popup-block.
IsMouseHoveringRect :: proc(r_min : ImVec2, r_max : ImVec2, clip : bool = true) -> bool
{
    g := GImGui;

    // Clip
    rect_clipped := ImRect{ _v = {r_min, r_max}};
    if (clip)  do rect_clipped.ClipWith(g.CurrentWindow.ClipRect);

    // Hit testing, expanded for touch input
    if (!rect_clipped.ContainsWithPad(g.IO.MousePos, g.Style.TouchExtraPadding))   do return false
    if (!g.MouseViewport.GetMainRect().Overlaps(rect_clipped))   do return false
    return true;
}

// Return if a mouse click/drag went past the given threshold. Valid to call during the MouseReleased frame.
// [Internal] This doesn't test if the button is pressed
IsMouseDragPastThreshold :: proc(button : ImGuiMouseButton, lock_threshold : f32 = 1.0) -> bool
{
    g := GImGui;
    assert(button >= 0 && button < len(g.IO.MouseDown));
    if (lock_threshold < 0.0) {
        lock_threshold = g.IO.MouseDragThreshold;
    }
    return g.IO.MouseDragMaxDistanceSqr[button] >= lock_threshold * lock_threshold;
}

// [forward declared comment]:
// is mouse dragging? (uses io.MouseDraggingThreshold if lock_threshold < 0.0f)
IsMouseDragging :: proc(button : ImGuiMouseButton, lock_threshold : f32 = 1.0) -> bool
{
    g := GImGui;
    assert(button >= 0 && button < len(g.IO.MouseDown));
    if (!g.IO.MouseDown[button])   do return false
    return IsMouseDragPastThreshold(button, lock_threshold);
}

// [forward declared comment]:
// shortcut to ImGui::GetIO().MousePos provided by user, to be consistent with other calls
GetMousePos :: proc() -> ImVec2
{
    g := GImGui;
    return g.IO.MousePos;
}

// This is called TeleportMousePos() and not SetMousePos() to emphasis that setting MousePosPrev will effectively clear mouse delta as well.
// It is expected you only call this if (.HasSetMousePos in io.BackendFlags) is set and supported by backend.
TeleportMousePos :: proc(pos : ImVec2)
{
    g := GImGui;
    g.IO.MousePosPrev = pos;
    g.IO.MousePos = pos
    g.IO.MouseDelta = ImVec2{0.0, 0.0};
    g.IO.WantSetMousePos = true;
    //IMGUI_DEBUG_LOG_IO("TeleportMousePos: (%.1f,%.1f)\n", io.MousePos.x, io.MousePos.y);
}

// NB: prefer to call right after BeginPopup(). At the time Selectable/MenuItem is activated, the popup is already closed!
// [forward declared comment]:
// retrieve mouse position at the time of opening popup we have BeginPopup() into (helper to avoid user backing that value themselves)
GetMousePosOnOpeningCurrentPopup :: proc() -> ImVec2
{
    g := GImGui;
    if (len(g.BeginPopupStack) > 0) {
        return g.OpenPopupStack[len(g.BeginPopupStack) - 1].OpenMousePos;
    }
    return g.IO.MousePos;
}

// We typically use ImVec2(-FLT_MAX,-FLT_MAX) to denote an invalid mouse position.
// [forward declared comment]:
// by convention we use (-FLT_MAX,-FLT_MAX) to denote that there is no mouse available
IsMousePosValid :: proc(mouse_pos : ^ImVec2 = nil) -> bool
{
    // The assert is only to silence a false-positive in XCode Static Analysis.
    // Because GImGui is not dereferenced in every code path, the static analyzer assume that it may be NULL (which it doesn't for other functions).
    assert(GImGui != nil);
    MOUSE_INVALID := -256000.0;
    p := mouse_pos != nil ? mouse_pos^ : GImGui.IO.MousePos;
    return p.x >= MOUSE_INVALID && p.y >= MOUSE_INVALID;
}

// [WILL OBSOLETE] This was designed for backends, but prefer having backend maintain a mask of held mouse buttons, because upcoming input queue system will make this invalid.
// [forward declared comment]:
// [WILL OBSOLETE] is any mouse button held? This was designed for backends, but prefer having backend maintain a mask of held mouse buttons, because upcoming input queue system will make this invalid.
IsAnyMouseDown :: proc() -> bool
{
    g := GImGui;
    for n := 0; n < len(g.IO.MouseDown); n += 1 {
        if (g.IO.MouseDown[n])   do return true
    }
    return false;
}

// Return the delta from the initial clicking position while the mouse button is clicked or was just released.
// This is locked and return 0.0f until the mouse moves past a distance threshold at least once.
// NB: This is only valid if IsMousePosValid(). backends in theory should always keep mouse position valid when dragging even outside the client window.
// [forward declared comment]:
// return the delta from the initial clicking position while the mouse button is pressed or was just released. This is locked and return 0.0f until the mouse moves past a distance threshold at least once (uses io.MouseDraggingThreshold if lock_threshold < 0.0f)
GetMouseDragDelta :: proc(button : ImGuiMouseButton = {}, lock_threshold : f32 = 1.0) -> ImVec2
{
    g := GImGui;
    assert(button >= 0 && button < len(g.IO.MouseDown));
    if (lock_threshold < 0.0) {
        lock_threshold = g.IO.MouseDragThreshold;
    }
    if (g.IO.MouseDown[button] || g.IO.MouseReleased[button]) {
        if (g.IO.MouseDragMaxDistanceSqr[button] >= lock_threshold * lock_threshold) {
            if (IsMousePosValid(&g.IO.MousePos) && IsMousePosValid(&g.IO.MouseClickedPos[button])) {
                return g.IO.MousePos - g.IO.MouseClickedPos[button];
            }
        }
    }
    return ImVec2{0.0, 0.0};
}

// [forward declared comment]:
//
ResetMouseDragDelta :: proc(button : ImGuiMouseButton = {})
{
    g := GImGui;
    assert(button >= 0 && button < len(g.IO.MouseDown));
    // NB: We don't need to reset g.IO.MouseDragMaxDistanceSqr
    g.IO.MouseClickedPos[button] = g.IO.MousePos;
}

// Get desired mouse cursor shape.
// Important: this is meant to be used by a platform backend, it is reset in ImGui::NewFrame(),
// updated during the frame, and locked in EndFrame()/Render().
// If you use software rendering by setting io.MouseDrawCursor then Dear ImGui will render those for you
// [forward declared comment]:
// get desired mouse cursor shape. Important: reset in ImGui::NewFrame(), this is updated during the frame. valid before Render(). If you use software rendering by setting io.MouseDrawCursor ImGui will render those for you
GetMouseCursor :: proc() -> ImGuiMouseCursor
{
    g := GImGui;
    return g.MouseCursor;
}

// We intentionally accept values of ImGuiMouseCursor that are outside our bounds, in case users needs to hack-in a custom cursor value.
// Custom cursors may be handled by custom backends. If you are using a standard backend and want to hack in a custom cursor, you may
// handle it before the backend _NewFrame() call and temporarily set ImGuiConfigFlags_NoMouseCursorChange during the backend _NewFrame() call.
// [forward declared comment]:
// set desired mouse cursor shape
SetMouseCursor :: proc(cursor_type : ImGuiMouseCursor)
{
    g := GImGui;
    g.MouseCursor = cursor_type;
}

UpdateAliasKey :: proc(key : ImGuiKey, v : bool, analog_value : f32)
{
    assert(IsAliasKey(key));
    key_data := GetKeyData(key);
    key_data.Down = v;
    key_data.AnalogValue = analog_value;
}

// [Internal] Do not use directly
GetMergedModsFromKeys :: proc() -> ImGuiKeyChord
{
    mods := 0;
    if (IsKeyDown(ImGuiKey.Mod_Ctrl))     { mods |= ImGuiKey.Mod_Ctrl; }
    if (IsKeyDown(ImGuiKey.Mod_Shift))    { mods |= ImGuiKey.Mod_Shift; }
    if (IsKeyDown(ImGuiKey.Mod_Alt))      { mods |= ImGuiKey.Mod_Alt; }
    if (IsKeyDown(ImGuiKey.Mod_Super))    { mods |= ImGuiKey.Mod_Super; }
    return mods;
}

UpdateKeyboardInputs :: proc()
{
    g := GImGui;
    io := &g.IO;

    if (.NoKeyboard in io.ConfigFlags)   do io.ClearInputKeys()

    // Update aliases
    for n := 0; n < ImGuiMouseButton_COUNT; n += 1 {
        UpdateAliasKey(MouseButtonToKey(n), io.MouseDown[n], io.MouseDown[n] ? 1.0 : 0.0);
    }
    UpdateAliasKey(ImGuiKey.MouseWheelX, io.MouseWheelH != 0.0, io.MouseWheelH);
    UpdateAliasKey(ImGuiKey.MouseWheelY, io.MouseWheel != 0.0, io.MouseWheel);

    // Synchronize io.KeyMods and io.KeyCtrl/io.KeyShift/etc. values.
    // - New backends (1.87+): send io.AddKeyEvent(ImGuiMod_XXX) ->                                      -> (here) deriving io.KeyMods + io.KeyXXX from key array.
    // - Legacy backends:      set io.KeyXXX bools               -> (above) set key array from io.KeyXXX -> (here) deriving io.KeyMods + io.KeyXXX from key array.
    // So with legacy backends the 4 values will do a unnecessary back-and-forth but it makes the code simpler and future facing.
    prev_key_mods := io.KeyMods;
    io.KeyMods = GetMergedModsFromKeys();
    io.KeyCtrl = (io.KeyMods & ImGuiKey.Mod_Ctrl) != 0;
    io.KeyShift = (io.KeyMods & ImGuiKey.Mod_Shift) != 0;
    io.KeyAlt = (io.KeyMods & ImGuiKey.Mod_Alt) != 0;
    io.KeySuper = (io.KeyMods & ImGuiKey.Mod_Super) != 0;
    if (prev_key_mods != io.KeyMods) {
        g.LastKeyModsChangeTime = g.Time;
    }
    if (prev_key_mods != io.KeyMods && prev_key_mods == 0) {
        g.LastKeyModsChangeFromNoneTime = g.Time;
    }

    // Clear gamepad data if disabled
    if ((.HasGamepad not_in io.BackendFlags)) {
        for key := ImGuiKey.Gamepad_BEGIN; key < ImGuiKey.Gamepad_END; key += 1
        {
            io.KeysData[key - ImGuiKey.NamedKey_BEGIN].Down = false;
            io.KeysData[key - ImGuiKey.NamedKey_BEGIN].AnalogValue = 0.0;
        }
    }

    // Update keys
    for key := ImGuiKey.NamedKey_BEGIN; key < ImGuiKey.NamedKey_END; key += 1
    {
        key_data := &io.KeysData[key - ImGuiKey.NamedKey_BEGIN];
        key_data.DownDurationPrev = key_data.DownDuration;
        key_data.DownDuration = key_data.Down ? (key_data.DownDuration < 0.0 ? 0.0 : key_data.DownDuration + io.DeltaTime) : -1.0;
        if (key_data.DownDuration == 0.0)
        {
            if (IsKeyboardKey(cast(ImGuiKey)key)) {
                g.LastKeyboardKeyPressTime = g.Time;
            }
            else if (key == ImGuiKey.ReservedForModCtrl || key == ImGuiKey.ReservedForModShift || key == ImGuiKey.ReservedForModAlt || key == ImGuiKey.ReservedForModSuper) {
                g.LastKeyboardKeyPressTime = g.Time;
            }
        }
    }

    // Update keys/input owner (named keys only): one entry per key
    for key := ImGuiKey.NamedKey_BEGIN; key < ImGuiKey.NamedKey_END; key = (ImGuiKey)(key + 1)
    {
        key_data := &io.KeysData[key - ImGuiKey.NamedKey_BEGIN];
        owner_data := &g.KeysOwnerData[key - ImGuiKey.NamedKey_BEGIN];
        owner_data.OwnerCurr = owner_data.OwnerNext;
        if (!key_data.Down) { // Important: ownership is released on the frame after a release. Ensure a 'MouseDown -> CloseWindow -> MouseUp' chain doesn't lead to someone else seeing the MouseUp.
            owner_data.OwnerNext = ImGuiKeyOwner_NoOwner;
        }
        owner_data.LockUntilRelease = owner_data.LockUntilRelease && key_data.Down
        owner_data.LockThisFrame = owner_data.LockUntilRelease;  // Clear LockUntilRelease when key is not Down anymore
    }

    // Update key routing (for e.g. shortcuts)
    UpdateKeyRoutingTable(&g.KeysRoutingTable);
}

UpdateMouseInputs :: proc()
{
    g := GImGui;
    io := &g.IO;

    // Mouse Wheel swapping flag
    // As a standard behavior holding SHIFT while using Vertical Mouse Wheel triggers Horizontal scroll instead
    // - We avoid doing it on OSX as it the OS input layer handles this already.
    // - FIXME: However this means when running on OSX over Emscripten, Shift+WheelY will incur two swapping (1 in OS, 1 here), canceling the feature.
    // - FIXME: When we can distinguish e.g. touchpad scroll events from mouse ones, we'll set this accordingly based on input source.
    io.MouseWheelRequestAxisSwap = io.KeyShift && !io.ConfigMacOSXBehaviors;

    // Round mouse position to avoid spreading non-rounded position (e.g. UpdateManualResize doesn't support them well)
    if (IsMousePosValid(&io.MousePos)) {
        g.MouseLastValidPos = ImFloor(io.MousePos);
        io.MousePos = g.MouseLastValidPos
    }

    // If mouse just appeared or disappeared (usually denoted by -FLT_MAX components) we cancel out movement in MouseDelta
    if (IsMousePosValid(&io.MousePos) && IsMousePosValid(&io.MousePosPrev)) {
        io.MouseDelta = io.MousePos - io.MousePosPrev;
    }
    else {
        io.MouseDelta = ImVec2{0.0, 0.0};
    }

    // Update stationary timer.
    // FIXME: May need to rework again to have some tolerance for occasional small movement, while being functional on high-framerates.
    mouse_stationary_threshold := (io.MouseSource == ImGuiMouseSource_Mouse) ? 2.0 : 3.0; // Slightly higher threshold for ImGuiMouseSource_TouchScreen/ImGuiMouseSource_Pen, may need rework.
    mouse_stationary := (ImLengthSqr(io.MouseDelta) <= mouse_stationary_threshold * mouse_stationary_threshold);
    g.MouseStationaryTimer = mouse_stationary ? (g.MouseStationaryTimer + io.DeltaTime) : 0.0;
    //IMGUI_DEBUG_LOG("%.4f\n", g.MouseStationaryTimer);

    // If mouse moved we re-enable mouse hovering in case it was disabled by keyboard/gamepad. In theory should use a >0.0f threshold but would need to reset in everywhere we set this to true.
    if (io.MouseDelta.x != 0.0 || io.MouseDelta.y != 0.0) {
        g.NavHighlightItemUnderNav = false;
    }

    for i := 0; i < len(io.MouseDown); i += 1
    {
        io.MouseClicked[i] = io.MouseDown[i] && io.MouseDownDuration[i] < 0.0;
        io.MouseClickedCount[i] = 0; // Will be filled below
        io.MouseReleased[i] = !io.MouseDown[i] && io.MouseDownDuration[i] >= 0.0;
        io.MouseDownDurationPrev[i] = io.MouseDownDuration[i];
        io.MouseDownDuration[i] = io.MouseDown[i] ? (io.MouseDownDuration[i] < 0.0 ? 0.0 : io.MouseDownDuration[i] + io.DeltaTime) : -1.0;
        if (io.MouseClicked[i])
        {
            is_repeated_click := false;
            if ((f32)(g.Time - io.MouseClickedTime[i]) < io.MouseDoubleClickTime)
            {
                delta_from_click_pos := IsMousePosValid(&io.MousePos) ? (io.MousePos - io.MouseClickedPos[i]) : ImVec2{0.0, 0.0};
                if (ImLengthSqr(delta_from_click_pos) < io.MouseDoubleClickMaxDist * io.MouseDoubleClickMaxDist)   do is_repeated_click = true
            }
            if (is_repeated_click) {
                io.MouseClickedLastCount[i] += 1;
            }
            else {
                io.MouseClickedLastCount[i] = 1;
            }
            io.MouseClickedTime[i] = g.Time;
            io.MouseClickedPos[i] = io.MousePos;
            io.MouseClickedCount[i] = io.MouseClickedLastCount[i];
            io.MouseDragMaxDistanceAbs[i] = ImVec2{0.0, 0.0};
            io.MouseDragMaxDistanceSqr[i] = 0.0;
        }
        else if (io.MouseDown[i])
        {
            // Maintain the maximum distance we reaching from the initial click position, which is used with dragging threshold
            delta_from_click_pos := IsMousePosValid(&io.MousePos) ? (io.MousePos - io.MouseClickedPos[i]) : ImVec2{0.0, 0.0};
            io.MouseDragMaxDistanceSqr[i] = ImMax(io.MouseDragMaxDistanceSqr[i], ImLengthSqr(delta_from_click_pos));
            io.MouseDragMaxDistanceAbs[i].x = ImMax(io.MouseDragMaxDistanceAbs[i].x, delta_from_click_pos.x < 0.0 ? -delta_from_click_pos.x : delta_from_click_pos.x);
            io.MouseDragMaxDistanceAbs[i].y = ImMax(io.MouseDragMaxDistanceAbs[i].y, delta_from_click_pos.y < 0.0 ? -delta_from_click_pos.y : delta_from_click_pos.y);
        }

        // We provide io.MouseDoubleClicked[] as a legacy service
        io.MouseDoubleClicked[i] = (io.MouseClickedCount[i] == 2);

        // Clicking any mouse button reactivate mouse hovering which may have been deactivated by keyboard/gamepad navigation
        if (io.MouseClicked[i]) {
            g.NavHighlightItemUnderNav = false;
        }
    }
}

LockWheelingWindow :: proc(window : ^ImGuiWindow, wheel_amount : f32)
{
    g := GImGui;
    if (window != nil) {
        g.WheelingWindowReleaseTimer = ImMin(g.WheelingWindowReleaseTimer + ImAbs(wheel_amount) * WINDOWS_MOUSE_WHEEL_SCROLL_LOCK_TIMER, WINDOWS_MOUSE_WHEEL_SCROLL_LOCK_TIMER);
    }
    else {
        g.WheelingWindowReleaseTimer = 0.0;
    }
    if (g.WheelingWindow == window)   do return
    IMGUI_DEBUG_LOG_IO("[io] LockWheelingWindow() \"%s\"\n", window ? window.Name : "nil");
    g.WheelingWindow = window;
    g.WheelingWindowRefMousePos = g.IO.MousePos;
    if (window == nil)
    {
        g.WheelingWindowStartFrame = -1;
        g.WheelingAxisAvg = ImVec2{0.0, 0.0};
    }
}

FindBestWheelingWindow :: proc(wheel : ImVec2) -> ^ImGuiWindow
{
    // For each axis, find window in the hierarchy that may want to use scrolling
    g := GImGui;
    windows : [2]^ImGuiWindow = { nil, nil };
    for axis := 0; axis < 2; axis += 1 {
        if (wheel[axis] != 0.0) {
            windows[axis] = g.HoveredWindow
            for window := g.HoveredWindow; window.Flags & ImGuiWindowFlags_ChildWindow; window = window.ParentWindow
            {
                // Bubble up into parent window if:
                // - a child window doesn't allow any scrolling.
                // - a child window has the ImGuiWindowFlags_NoScrollWithMouse flag.
                //// - a child window doesn't need scrolling because it is already at the edge for the direction we are going in (FIXME-WIP)
                has_scrolling := (window.ScrollMax[axis] != 0.0);
                inputs_disabled := (.NoScrollWithMouse in window.Flags) && !(.NoMouseInputs in window.Flags);
                //const bool scrolling_past_limits = (wheel_v < 0.0f) ? (window.Scroll[axis] <= 0.0f) : (window.Scroll[axis] >= window.ScrollMax[axis]);
                if (has_scrolling && !inputs_disabled) {// && !scrolling_past_limits)
                    break; // select this window
                }

                windows[axis] = window.ParentWindow
            }
        }
    }
    if (windows[0] == nil && windows[1] == nil)   do return nil

    // If there's only one window or only one axis then there's no ambiguity
    if (windows[0] == windows[1] || windows[0] == nil || windows[1] == nil) {
        return windows[1] ? windows[1] : windows[0];
    }

    // If candidate are different windows we need to decide which one to prioritize
    // - First frame: only find a winner if one axis is zero.
    // - Subsequent frames: only find a winner when one is more than the other.
    if (g.WheelingWindowStartFrame == -1) {
        g.WheelingWindowStartFrame = g.FrameCount;
    }
    if ((g.WheelingWindowStartFrame == g.FrameCount && wheel.x != 0.0 && wheel.y != 0.0) || (g.WheelingAxisAvg.x == g.WheelingAxisAvg.y))
    {
        g.WheelingWindowWheelRemainder = wheel;
        return nil;
    }
    return (g.WheelingAxisAvg.x > g.WheelingAxisAvg.y) ? windows[0] : windows[1];
}

// Called by NewFrame()
UpdateMouseWheel :: proc()
{
    // Reset the locked window if we move the mouse or after the timer elapses.
    // FIXME: Ideally we could refactor to have one timer for "changing window w/ same axis" and a shorter timer for "changing window or axis w/ other axis" (#3795)
    g := GImGui;
    if (g.WheelingWindow != nil)
    {
        g.WheelingWindowReleaseTimer -= g.IO.DeltaTime;
        if (IsMousePosValid() && ImLengthSqr(g.IO.MousePos - g.WheelingWindowRefMousePos) > g.IO.MouseDragThreshold * g.IO.MouseDragThreshold) {
            g.WheelingWindowReleaseTimer = 0.0;
        }
        if (g.WheelingWindowReleaseTimer <= 0.0) {
            LockWheelingWindow(nil, 0.0);
        }
    }

    wheel : ImVec2
    wheel.x = TestKeyOwner(ImGuiKey.MouseWheelX, ImGuiKeyOwner_NoOwner) ? g.IO.MouseWheelH : 0.0;
    wheel.y = TestKeyOwner(ImGuiKey.MouseWheelY, ImGuiKeyOwner_NoOwner) ? g.IO.MouseWheel : 0.0;

    //IMGUI_DEBUG_LOG("MouseWheel X:%.3f Y:%.3f\n", wheel_x, wheel_y);
    mouse_window := g.WheelingWindow ? g.WheelingWindow : g.HoveredWindow;
    if (!mouse_window || mouse_window.Collapsed)   do return

    // Zoom / Scale window
    // FIXME-OBSOLETE: This is an old feature, it still works but pretty much nobody is using it and may be best redesigned.
    if (wheel.y != 0.0 && g.IO.KeyCtrl && g.IO.FontAllowUserScaling)
    {
        LockWheelingWindow(mouse_window, wheel.y);
        window := mouse_window;
        new_font_scale := ImClamp(window.FontWindowScale + g.IO.MouseWheel * 0.10, 0.50, 2.50);
        scale := new_font_scale / window.FontWindowScale;
        window.FontWindowScale = new_font_scale;
        if (window == window.RootWindow)
        {
            offset := window.Size * (1.0 - scale) * (g.IO.MousePos - window.Pos) / window.Size;
            SetWindowPos(window, window.Pos + offset, 0);
            window.Size = ImTrunc(window.Size * scale);
            window.SizeFull = ImTrunc(window.SizeFull * scale);
        }
        return;
    }
    if (g.IO.KeyCtrl)   do return

    // Mouse wheel scrolling
    // Read about io.MouseWheelRequestAxisSwap and its issue on Mac+Emscripten in UpdateMouseInputs()
    if (g.IO.MouseWheelRequestAxisSwap) {
        wheel = ImVec2{wheel.y, 0.0};
    }

    // Maintain a rough average of moving magnitude on both axises
    // FIXME: should by based on wall clock time rather than frame-counter
    g.WheelingAxisAvg.x = ImExponentialMovingAverage(g.WheelingAxisAvg.x, ImAbs(wheel.x), 30);
    g.WheelingAxisAvg.y = ImExponentialMovingAverage(g.WheelingAxisAvg.y, ImAbs(wheel.y), 30);

    // In the rare situation where FindBestWheelingWindow() had to defer first frame of wheeling due to ambiguous main axis, reinject it now.
    wheel += g.WheelingWindowWheelRemainder;
    g.WheelingWindowWheelRemainder = ImVec2{0.0, 0.0};
    if (wheel.x == 0.0 && wheel.y == 0.0)   do return

    // Mouse wheel scrolling: find target and apply
    // - don't renew lock if axis doesn't apply on the window.
    // - select a main axis when both axises are being moved.
    if window := (g.WheelingWindow ? g.WheelingWindow : FindBestWheelingWindow(wheel)); window != nil {
        if (!(.NoScrollWithMouse in window.Flags) && !(.NoMouseInputs in window.Flags))
        {
            do_scroll : [2]bool = { wheel.x != 0.0 && window.ScrollMax.x != 0.0, wheel.y != 0.0 && window.ScrollMax.y != 0.0 };
            if (do_scroll[ImGuiAxis.X] && do_scroll[ImGuiAxis.Y]) {
                do_scroll[(g.WheelingAxisAvg.x > g.WheelingAxisAvg.y) ? ImGuiAxis.Y : ImGuiAxis.X] = false;
            }
            if (do_scroll[ImGuiAxis.X])
            {
                LockWheelingWindow(window, wheel.x);
                max_step := GetWidth(window.InnerRect) * 0.67;
                scroll_step := ImTrunc(ImMin(2 * window.CalcFontSize(), max_step));
                SetScrollX(window, window.Scroll.x - wheel.x * scroll_step);
                g.WheelingWindowScrolledFrame = g.FrameCount;
            }
            if (do_scroll[ImGuiAxis.Y])
            {
                LockWheelingWindow(window, wheel.y);
                max_step := GetHeight(window.InnerRect) * 0.67;
                scroll_step := ImTrunc(ImMin(5 * window.CalcFontSize(), max_step));
                SetScrollY(window, window.Scroll.y - wheel.y * scroll_step);
                g.WheelingWindowScrolledFrame = g.FrameCount;
            }
        }
    }
}

// [forward declared comment]:
// Override io.WantCaptureKeyboard flag next frame (said flag is left for your application to handle, typically when true it instructs your app to ignore inputs). e.g. force capture keyboard when your widget is being hovered. This is equivalent to setting "io.WantCaptureKeyboard = want_capture_keyboard"; after the next NewFrame() call.
SetNextFrameWantCaptureKeyboard :: proc(want_capture_keyboard : bool)
{
    g := GImGui;
    g.WantCaptureKeyboardNextFrame = want_capture_keyboard ? 1 : 0;
}

// [forward declared comment]:
// Override io.WantCaptureMouse flag next frame (said flag is left for your application to handle, typical when true it instucts your app to ignore inputs). This is equivalent to setting "io.WantCaptureMouse = want_capture_mouse;" after the next NewFrame() call.
SetNextFrameWantCaptureMouse :: proc(want_capture_mouse : bool)
{
    g := GImGui;
    g.WantCaptureMouseNextFrame = want_capture_mouse ? 1 : 0;
}

when !(IMGUI_DISABLE_DEBUG_TOOLS) {
GetInputSourceName :: proc(source : ImGuiInputSource) -> ^u8
{
    input_source_names := [?]string { "None", "Mouse", "Keyboard", "Gamepad" };
    assert(len(input_source_names) == ImGuiInputSource_COUNT && source >= 0 && source < ImGuiInputSource_COUNT);
    return input_source_names[source];
}
GetMouseSourceName :: proc(source : ImGuiMouseSource) -> ^u8
{
    mouse_source_names := [?]string { "Mouse", "TouchScreen", "Pen" };
    assert(len(mouse_source_names) == ImGuiMouseSource_COUNT && source >= 0 && source < ImGuiMouseSource_COUNT);
    return mouse_source_names[source];
}
DebugPrintInputEvent :: proc(prefix : ^u8, e : ^ImGuiInputEvent)
{
    g := GImGui;
    if (e.Type == ImGuiInputEventType_MousePos)    { if (e.MousePos.PosX == -math.F32_MAX && e.MousePos.PosY == -math.F32_MAX) do IMGUI_DEBUG_LOG_IO("[io] %s: MousePos (-math.F32_MAX, -math.F32_MAX)\n", prefix); else do IMGUI_DEBUG_LOG_IO("[io] %s: MousePos (%.1, %.1) (%s)\n", prefix, e.MousePos.PosX, e.MousePos.PosY, GetMouseSourceName(e.MousePos.MouseSource)); return; }
    if (e.Type == .MouseButton) { IMGUI_DEBUG_LOG_IO("[io] %s: MouseButton %d %s (%s)\n", prefix, e.MouseButton.Button, e.MouseButton.Down ? "Down" : "Up", GetMouseSourceName(e.MouseButton.MouseSource)); return; }
    if (e.Type == .MouseWheel)  { IMGUI_DEBUG_LOG_IO("[io] %s: MouseWheel (%.3, %.3) (%s)\n", prefix, e.MouseWheel.WheelX, e.MouseWheel.WheelY, GetMouseSourceName(e.MouseWheel.MouseSource)); return; }
    if (e.Type == .MouseViewport){IMGUI_DEBUG_LOG_IO("[io] %s: MouseViewport (0x%08X)\n", prefix, e.MouseViewport.HoveredViewportID); return; }
    if (e.Type == .Key)         { IMGUI_DEBUG_LOG_IO("[io] %s: Key \"%s\" %s\n", prefix, GetKeyName(e.Key.Key), e.Key.Down ? "Down" : "Up"); return; }
    if (e.Type == ImGuiInputEventType_Text)        { IMGUI_DEBUG_LOG_IO("[io] %s: Text: %c (U+%08X)\n", prefix, e.Text.Char, e.Text.Char); return; }
    if (e.Type == .Focus)       { IMGUI_DEBUG_LOG_IO("[io] %s: AppFocused %d\n", prefix, e.AppFocused.Focused); return; }
}
}

// Process input queue
// We always call this with the value of 'bool g.IO.ConfigInputTrickleEventQueue'.
// - trickle_fast_inputs = false : process all events, turn into flattened input state (e.g. successive down/up/down/up will be lost)
// - trickle_fast_inputs = true  : process as many events as possible (successive down/up/down/up will be trickled over several frames so nothing is lost) (new feature in 1.87)
UpdateInputEvents :: proc(trickle_fast_inputs : bool)
{
    g := GImGui;
    io := &g.IO;

    // Only trickle chars<>key when working with InputText()
    // FIXME: InputText() could parse event trail?
    // FIXME: Could specialize chars<>keys trickling rules for control keys (those not typically associated to characters)
    trickle_interleaved_nonchar_keys_and_text := (trickle_fast_inputs && g.WantTextInputNextFrame == 1);

    mouse_moved := false; mouse_wheeled := false; key_changed := false; key_changed_nonchar := false; text_inputted := false;
    mouse_button_changed := 0x00;
    ImBitArray<ImGuiKey.NamedKey_COUNT> key_changed_mask;

    event_n := 0;
    for ; event_n < len(g.InputEventsQueue); event_n += 1
    {
        e := &g.InputEventsQueue[event_n];
        if (e.Type == ImGuiInputEventType_MousePos)
        {
            if (g.IO.WantSetMousePos)   do continue
            // Trickling Rule: Stop processing queued events if we already handled a mouse button change
            event_pos := ImVec2{e.MousePos.PosX, e.MousePos.PosY};
            if (trickle_fast_inputs && (mouse_button_changed != 0 || mouse_wheeled || key_changed || text_inputted))   do break
            io.MousePos = event_pos;
            io.MouseSource = e.MousePos.MouseSource;
            mouse_moved = true;
        }
        else if (e.Type == .MouseButton)
        {
            // Trickling Rule: Stop processing queued events if we got multiple action on the same button
            button := e.MouseButton.Button;
            assert(button >= 0 && button < ImGuiMouseButton_COUNT);
            if (trickle_fast_inputs && ((mouse_button_changed & (1 << button)) || mouse_wheeled))   do break
            if (trickle_fast_inputs && e.MouseButton.MouseSource == ImGuiMouseSource_TouchScreen && mouse_moved) { // #2702: TouchScreen have no initial hover.
                break;
            }
            io.MouseDown[button] = e.MouseButton.Down;
            io.MouseSource = e.MouseButton.MouseSource;
            mouse_button_changed |= (1 << button);
        }
        else if (e.Type == .MouseWheel)
        {
            // Trickling Rule: Stop processing queued events if we got multiple action on the event
            if (trickle_fast_inputs && (mouse_moved || mouse_button_changed != 0))   do break
            io.MouseWheelH += e.MouseWheel.WheelX;
            io.MouseWheel += e.MouseWheel.WheelY;
            io.MouseSource = e.MouseWheel.MouseSource;
            mouse_wheeled = true;
        }
        else if (e.Type == .MouseViewport)
        {
            io.MouseHoveredViewport = e.MouseViewport.HoveredViewportID;
        }
        else if (e.Type == .Key)
        {
            // Trickling Rule: Stop processing queued events if we got multiple action on the same button
            if (.NoKeyboard in io.ConfigFlags)   do continue
            key := e.Key.Key;
            assert(key != ImGuiKey.None);
            key_data := GetKeyData(key);
            key_data_index := (i32)(key_data - g.IO.KeysData);
            if (trickle_fast_inputs && key_data.Down != e.Key.Down && (key_changed_mask.TestBit(key_data_index) || mouse_button_changed != 0))   do break

            key_is_potentially_for_char_input := IsKeyChordPotentiallyCharInput(GetMergedModsFromKeys() | key);
            if (trickle_interleaved_nonchar_keys_and_text && (text_inputted && !key_is_potentially_for_char_input))   do break

            key_data.Down = e.Key.Down;
            key_data.AnalogValue = e.Key.AnalogValue;
            key_changed = true;
            key_changed_mask.SetBit(key_data_index);
            if (trickle_interleaved_nonchar_keys_and_text && !key_is_potentially_for_char_input) {
                key_changed_nonchar = true;
            }
        }
        else if (e.Type == ImGuiInputEventType_Text)
        {
            if (.NoKeyboard in io.ConfigFlags)   do continue
            // Trickling Rule: Stop processing queued events if keys/mouse have been interacted with
            if (trickle_fast_inputs && (mouse_button_changed != 0 || mouse_moved || mouse_wheeled))   do break
            if (trickle_interleaved_nonchar_keys_and_text && key_changed_nonchar)   do break
            c := e.Text.Char;
            io.InputQueueCharacters.append(c <= IM_UNICODE_CODEPOINT_MAX ? cast(ImWchar)c : IM_UNICODE_CODEPOINT_INVALID);
            if (trickle_interleaved_nonchar_keys_and_text)   do text_inputted = true
        }
        else if (e.Type == .Focus)
        {
            // We intentionally overwrite this and process in NewFrame(), in order to give a chance
            // to multi-viewports backends to queue AddFocusEvent(false) + AddFocusEvent(true) in same frame.
            focus_lost := !e.AppFocused.Focused;
            io.AppFocusLost = focus_lost;
        }
        else
        {
            assert(false, "Unknown event!");
        }
    }

    // Record trail (for domain-specific applications wanting to access a precise trail)
    //if (event_n != 0) IMGUI_DEBUG_LOG_IO("Processed: %d / Remaining: %d\n", event_n, len(g.InputEventsQueue) - event_n);
    for n := 0; n < event_n; n += 1 {
        g.InputEventsTrail.append(g.InputEventsQueue[n]);
    }

    // [DEBUG]
when !(IMGUI_DISABLE_DEBUG_TOOLS) {
    if (event_n != 0 && (.EventIO in g.DebugLogFlags)) {
        for n := 0; n < len(g.InputEventsQueue); n += 1 {
            DebugPrintInputEvent(n < event_n ? "Processed" : "Remaining", &g.InputEventsQueue[n]);
        }
    }
}

    // Remaining events will be processed on the next frame
    if (event_n == g.InputEventsQueue.Size) {
        g.InputEventsQueue.resize(0);
    }
    else {
        g.InputEventsQueue.erase(g.InputEventsQueue.Data, g.InputEventsQueue.Data + event_n);
    }

    // Clear buttons state when focus is lost
    // - this is useful so e.g. releasing Alt after focus loss on Alt-Tab doesn't trigger the Alt menu toggle.
    // - we clear in EndFrame() and not now in order allow application/user code polling this flag
    //   (e.g. custom backend may want to clear additional data, custom widgets may want to react with a "canceling" event).
    if (g.IO.AppFocusLost)
    {
        g.IO.ClearInputKeys();
        g.IO.ClearInputMouse();
    }
}

GetKeyOwner :: proc(key : ImGuiKey) -> ImGuiID
{
    if (!IsNamedKeyOrMod(key))   do return ImGuiKeyOwner_NoOwner

    g := GImGui;
    owner_data := GetKeyOwnerData(g, key);
    owner_id := owner_data.OwnerCurr;

    if (g.ActiveIdUsingAllKeyboardKeys && owner_id != g.ActiveId && owner_id != ImGuiKeyOwner_Any) {
        if (key >= ImGuiKey.Keyboard_BEGIN && key < ImGuiKey.Keyboard_END)   do return ImGuiKeyOwner_NoOwner
    }

    return owner_id;
}

// TestKeyOwner(..., ID)   : (owner == None || owner == ID)
// TestKeyOwner(..., None) : (owner == None)
// TestKeyOwner(..., Any)  : no owner test
// All paths are also testing for key not being locked, for the rare cases that key have been locked with using ImGuiInputFlags_LockXXX flags.
// [forward declared comment]:
// Test that key is either not owned, either owned by 'owner_id'
TestKeyOwner :: proc(key : ImGuiKey, owner_id : ImGuiID) -> bool
{
    if (!IsNamedKeyOrMod(key))   do return true

    g := GImGui;
    if (g.ActiveIdUsingAllKeyboardKeys && owner_id != g.ActiveId && owner_id != ImGuiKeyOwner_Any) {
        if (key >= ImGuiKey.Keyboard_BEGIN && key < ImGuiKey.Keyboard_END)   do return false
    }

    owner_data := GetKeyOwnerData(g, key);
    if (owner_id == ImGuiKeyOwner_Any) {
        return (owner_data.LockThisFrame == false);
    }

    // Note: SetKeyOwner() sets OwnerCurr. It is not strictly required for most mouse routing overlap (because of ActiveId/HoveredId
    // are acting as filter before this has a chance to filter), but sane as soon as user tries to look into things.
    // Setting OwnerCurr in SetKeyOwner() is more consistent than testing OwnerNext here: would be inconsistent with getter and other functions.
    if (owner_data.OwnerCurr != owner_id)
    {
        if (owner_data.LockThisFrame)   do return false
        if (owner_data.OwnerCurr != ImGuiKeyOwner_NoOwner)   do return false
    }

    return true;
}

// _LockXXX flags are useful to lock keys away from code which is not input-owner aware.
// When using _LockXXX flags, you can use ImGuiKeyOwner_Any to lock keys from everyone.
// - SetKeyOwner(..., None)              : clears owner
// - SetKeyOwner(..., Any, !Lock)        : illegal (assert)
// - SetKeyOwner(..., Any or None, Lock) : set lock
SetKeyOwner :: proc(key : ImGuiKey, owner_id : ImGuiID, flags : ImGuiInputFlags = {})
{
    g := GImGui;
    assert(IsNamedKeyOrMod(key) && (owner_id != ImGuiKeyOwner_Any || (flags & (ImGuiInputFlags_LockThisFrame | ImGuiInputFlags_LockUntilRelease)))); // Can only use _Any with _LockXXX flags (to eat a key away without an ID to retrieve it)
    assert((flags & ~ImGuiInputFlags_SupportedBySetKeyOwner) == 0); // Passing flags not supported by this function!
    //IMGUI_DEBUG_LOG("SetKeyOwner(%s, owner_id=0x%08X, flags=%08X)\n", GetKeyName(key), owner_id, flags);

    owner_data := GetKeyOwnerData(g, key);
    owner_data.OwnerNext = owner_id;
    owner_data.OwnerCurr = owner_id;

    // We cannot lock by default as it would likely break lots of legacy code.
    // In the case of using LockUntilRelease while key is not down we still lock during the frame (no key_data.Down test)
    owner_data.LockUntilRelease = (.LockUntilRelease in flags)
    owner_data.LockThisFrame = (.LockThisFrame in flags) != 0 || (owner_data.LockUntilRelease);
}

// Rarely used helper
SetKeyOwnersForKeyChord :: proc(key_chord : ImGuiKeyChord, owner_id : ImGuiID, flags : ImGuiInputFlags = {})
{
    if (key_chord & ImGuiKey.Mod_Ctrl)      { SetKeyOwner(ImGuiKey.Mod_Ctrl, owner_id, flags); }
    if (key_chord & ImGuiKey.Mod_Shift)     { SetKeyOwner(ImGuiKey.Mod_Shift, owner_id, flags); }
    if (key_chord & ImGuiKey.Mod_Alt)       { SetKeyOwner(ImGuiKey.Mod_Alt, owner_id, flags); }
    if (key_chord & ImGuiKey.Mod_Super)     { SetKeyOwner(ImGuiKey.Mod_Super, owner_id, flags); }
    if (key_chord & ~ImGuiKey.Mod_Mask_)    { SetKeyOwner((ImGuiKey)(key_chord & ~ImGuiKey.Mod_Mask_), owner_id, flags); }
}

// This is more or less equivalent to:
//   if (IsItemHovered() || IsItemActive())
//       SetKeyOwner(key, GetItemID());
// Extensive uses of that (e.g. many calls for a single item) may want to manually perform the tests once and then call SetKeyOwner() multiple times.
// More advanced usage scenarios may want to call SetKeyOwner() manually based on different condition.
// Worth noting is that only one item can be hovered and only one item can be active, therefore this usage pattern doesn't need to bother with routing and priority.
// [forward declared comment]:
// Set key owner to last item if it is hovered or active. Equivalent to 'if (IsItemHovered() || IsItemActive()) { SetKeyOwner(key, GetItemID());'.
SetItemKeyOwner :: proc(key : ImGuiKey, flags : ImGuiInputFlags)
{
    g := GImGui;
    id := g.LastItemData.ID;
    if (id == 0 || (g.HoveredId != id && g.ActiveId != id))   do return
    if ((flags & ImGuiInputFlags_CondMask_) == 0) {
        flags |= ImGuiInputFlags_CondDefault_;
    }
    if ((g.HoveredId == id && (.CondHovered in flags)) || (g.ActiveId == id && (.CondActive in flags)))
    {
        assert((flags & ~ImGuiInputFlags_SupportedBySetItemKeyOwner) == 0); // Passing flags not supported by this function!
        SetKeyOwner(key, id, flags & ~ImGuiInputFlags_CondMask_);
    }
}

// [forward declared comment]:
// Set key owner to last item if it is hovered or active. Equivalent to 'if (IsItemHovered() || IsItemActive()) { SetKeyOwner(key, GetItemID());'.
SetItemKeyOwner :: proc(key : ImGuiKey)
{
    SetItemKeyOwner(key, ImGuiInputFlags_None);
}

// This is the only public API until we expose owner_id versions of the API as replacements.
IsKeyChordPressed :: proc(key_chord : ImGuiKeyChord) -> bool
{
    return IsKeyChordPressed(key_chord, ImGuiInputFlags_None, ImGuiKeyOwner_Any);
}

// This is equivalent to comparing KeyMods + doing a IsKeyPressed()
IsKeyChordPressed :: proc(key_chord : ImGuiKeyChord, flags : ImGuiInputFlags, owner_id : ImGuiID = {}) -> bool
{
    g := GImGui;
    key_chord = FixupKeyChord(key_chord);
    mods := (ImGuiKey)(key_chord & ImGuiKey.Mod_Mask_);
    if (g.IO.KeyMods != mods)   do return false

    // Special storage location for mods
    key := (ImGuiKey)(key_chord & ~ImGuiKey.Mod_Mask_);
    if (key == ImGuiKey.None) {
        key = ConvertSingleModFlagToKey(mods);
    }
    if (!IsKeyPressed(key, (flags & ImGuiInputFlags_RepeatMask_), owner_id))   do return false
    return true;
}

SetNextItemShortcut :: proc(key_chord : ImGuiKeyChord, flags : ImGuiInputFlags = {})
{
    g := GImGui;
    g.NextItemData.HasFlags |= ImGuiNextItemDataFlags_HasShortcut;
    g.NextItemData.Shortcut = key_chord;
    g.NextItemData.ShortcutFlags = flags;
}

// Called from within ItemAdd: at this point we can read from NextItemData and write to LastItemData
ItemHandleShortcut :: proc(id : ImGuiID)
{
    g := GImGui;
    flags := g.NextItemData.ShortcutFlags;
    assert((flags & ~ImGuiInputFlags_SupportedBySetNextItemShortcut) == 0); // Passing flags not supported by SetNextItemShortcut()!

    if (.Disabled in g.LastItemData.ItemFlags)   do return
    if (.Tooltip in flags)
    {
        g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_HasShortcut;
        g.LastItemData.Shortcut = g.NextItemData.Shortcut;
    }
    if (!Shortcut(g.NextItemData.Shortcut, flags & ImGuiInputFlags_SupportedByShortcut, id) || g.NavActivateId != 0)   do return

    // FIXME: Generalize Activation queue?
    g.NavActivateId = id; // Will effectively disable clipping.
    g.NavActivateFlags = ImGuiActivateFlags_PreferInput | ImGuiActivateFlags_FromShortcut;
    //if (g.ActiveId == 0 || g.ActiveId == id) {
    g.NavActivatePressedId = id;
    g.NavActivateDownId = id
    //}
    NavHighlightActivated(id);
}

Shortcut :: proc(key_chord : ImGuiKeyChord, flags : ImGuiInputFlags) -> bool
{
    return Shortcut(key_chord, flags, ImGuiKeyOwner_Any);
}

Shortcut :: proc(key_chord : ImGuiKeyChord, flags : ImGuiInputFlags, owner_id : ImGuiID) -> bool
{
    g := GImGui;
    //IMGUI_DEBUG_LOG("Shortcut(%s, flags=%X, owner_id=0x%08X)\n", GetKeyChordName(key_chord, g.TempBuffer.Data, g.TempBuffer.Size), flags, owner_id);

    // When using (owner_id == 0/Any): SetShortcutRouting() will use CurrentFocusScopeId and filter with this, so IsKeyPressed() is fine with he 0/Any.
    if ((flags & ImGuiInputFlags_RouteTypeMask_) == 0) {
        flags |= ImGuiInputFlags_RouteFocused;
    }

    // Using 'owner_id == ImGuiKeyOwner_Any/0': auto-assign an owner based on current focus scope (each window has its focus scope by default)
    // Effectively makes Shortcut() always input-owner aware.
    if (owner_id == ImGuiKeyOwner_Any || owner_id == ImGuiKeyOwner_NoOwner) {
        owner_id = GetRoutingIdFromOwnerId(owner_id);
    }

    if (.Disabled in g.CurrentItemFlags)   do return false

    // Submit route
    if (!SetShortcutRouting(key_chord, flags, owner_id))   do return false

    // Default repeat behavior for Shortcut()
    // So e.g. pressing Ctrl+W and releasing Ctrl while holding W will not trigger the W shortcut.
    if ((.Repeat in flags) != 0 && (flags & ImGuiInputFlags_RepeatUntilMask_) == 0) {
        flags |= ImGuiInputFlags_RepeatUntilKeyModsChange;
    }

    if (!IsKeyChordPressed(key_chord, flags, owner_id))   do return false

    // Claim mods during the press
    SetKeyOwnersForKeyChord(key_chord & ImGuiKey.Mod_Mask_, owner_id);

    assert((flags & ~ImGuiInputFlags_SupportedByShortcut) == 0); // Passing flags not supported by this function!
    return true;
}

//-----------------------------------------------------------------------------
// [SECTION] ERROR CHECKING, STATE RECOVERY
//-----------------------------------------------------------------------------
// - DebugCheckVersionAndDataLayout() (called via IMGUI_CHECKVERSION() macros)
// - ErrorCheckUsingSetCursorPosToExtendParentBoundaries()
// - ErrorCheckNewFrameSanityChecks()
// - ErrorCheckEndFrameSanityChecks()
// - ErrorRecoveryStoreState()
// - ErrorRecoveryTryToRecoverState()
// - ErrorRecoveryTryToRecoverWindowState()
// - ErrorLog()
//-----------------------------------------------------------------------------

// Verify ABI compatibility between caller code and compiled version of Dear ImGui. This helps detects some build issues.
// Called by IMGUI_CHECKVERSION().
// Verify that the type sizes are matching between the calling file's compilation unit and imgui.cpp's compilation unit
// If this triggers you have mismatched headers and compiled code versions.
// - It could be because of a build issue (using new headers with old compiled code)
// - It could be because of mismatched configuration #define, compilation settings, packing pragma etc.
//   THE CONFIGURATION SETTINGS MENTIONED IN imconfig.h MUST BE SET FOR ALL COMPILATION UNITS INVOLVED WITH DEAR IMGUI.
//   Which is why it is required you put them in your imconfig file (and NOT only before including imgui.h).
//   Otherwise it is possible that different compilation units would see different structure layout.
//   If you don't want to modify imconfig.h you can use the IMGUI_USER_CONFIG define to change filename.
// [forward declared comment]:
// This is called by IMGUI_CHECKVERSION() macro.
DebugCheckVersionAndDataLayout :: proc(version : ^u8, sz_io : int, sz_style : int, sz_vec2 : int, sz_vec4 : int, sz_vert : int, sz_idx : int) -> bool
{
    error := false;
    if (strcmp(version, IMGUI_VERSION) != 0) { error = true; assert(strcmp(version, IMGUI_VERSION) == 0, "Mismatched version string!"); }
    if (sz_io    != size_of(ImGuiIO))    { error = true; assert(sz_io == size_of(ImGuiIO), "Mismatched struct layout!"); }
    if (sz_style != size_of(ImGuiStyle)) { error = true; assert(sz_style == size_of(ImGuiStyle), "Mismatched struct layout!"); }
    if (sz_vec2  != size_of(ImVec2))     { error = true; assert(sz_vec2 == size_of(ImVec2), "Mismatched struct layout!"); }
    if (sz_vec4  != size_of(ImVec4))     { error = true; assert(sz_vec4 == size_of(ImVec4), "Mismatched struct layout!"); }
    if (sz_vert  != size_of(ImDrawVert)) { error = true; assert(sz_vert == size_of(ImDrawVert), "Mismatched struct layout!"); }
    if (sz_idx   != size_of(ImDrawIdx))  { error = true; assert(sz_idx == size_of(ImDrawIdx), "Mismatched struct layout!"); }
    return !error;
}

// Until 1.89 (IMGUI_VERSION_NUM < 18814) it was legal to use SetCursorPos() to extend the boundary of a parent (e.g. window or table cell)
// This is causing issues and ambiguity and we need to retire that.
// See https://github.com/ocornut/imgui/issues/5548 for more details.
// [Scenario 1]
//  Previously this would make the window content size ~200x200:
//    Begin(...) + SetCursorScreenPos(GetCursorScreenPos() + ImVec2(200,200)) + End();  // NOT OK
//  Instead, please submit an item:
//    Begin(...) + SetCursorScreenPos(GetCursorScreenPos() + ImVec2(200,200)) + Dummy(ImVec2(0,0)) + End(); // OK
//  Alternative:
//    Begin(...) + Dummy(ImVec2(200,200)) + End(); // OK
// [Scenario 2]
//  For reference this is one of the issue what we aim to fix with this change:
//    BeginGroup() + SomeItem("foobar") + SetCursorScreenPos(GetCursorScreenPos()) + EndGroup()
//  The previous logic made SetCursorScreenPos(GetCursorScreenPos()) have a side-effect! It would erroneously incorporate ItemSpacing.y after the item into content size, making the group taller!
//  While this code is a little twisted, no-one would expect SetXXX(GetXXX()) to have a side-effect. Using vertical alignment patterns could trigger this issue.
ErrorCheckUsingSetCursorPosToExtendParentBoundaries :: proc()
{
    g := GImGui;
    window := g.CurrentWindow;
    assert(window.DC.IsSetPos);
    window.DC.IsSetPos = false;
    if (window.DC.CursorPos.x <= window.DC.CursorMaxPos.x && window.DC.CursorPos.y <= window.DC.CursorMaxPos.y)   do return
    if (window.SkipItems)   do return
    assert(false, "Code uses SetCursorPos()/SetCursorScreenPos() to extend window/parent boundaries. Please submit an item e.g. Dummy() to validate extent.");
}

ErrorCheckNewFrameSanityChecks :: proc()
{
    g := GImGui;

    // Check user IM_ASSERT macro
    // (IF YOU GET A WARNING OR COMPILE ERROR HERE: it means your assert macro is incorrectly defined!
    //  If your macro uses multiple statements, it NEEDS to be surrounded by a 'do { ... } while (0)' block.
    //  This is a common C/C++ idiom to allow multiple statements macros to be used in control flow blocks.)
    // #define assert(EXPR)   if (SomeCode(EXPR)) SomeMoreCode();                    // Wrong!
    // #define assert(EXPR)   do { if (SomeCode(EXPR)) SomeMoreCode(); } while (0)   // Correct!
    if (true) do assert(1); else do assert(false)

    // Emscripten backends are often imprecise in their submission of DeltaTime. (#6114, #3644)
    // Ideally the Emscripten app/backend should aim to fix or smooth this value and avoid feeding zero, but we tolerate it.
when __EMSCRIPTEN__ {
    if (g.IO.DeltaTime <= 0.0 && g.FrameCount > 0)   do g.IO.DeltaTime = 0.00001
}

    // Check user data
    // (We pass an error message in the assert expression to make it visible to programmers who are not using a debugger, as most assert handlers display their argument)
    assert(g.Initialized);
    assert((g.IO.DeltaTime > 0.0 || g.FrameCount == 0), "Need a positive DeltaTime!");
    assert((g.FrameCount == 0 || g.FrameCountEnded == g.FrameCount), "Forgot to call Render() or EndFrame() at the end of the previous frame?");
    assert(g.IO.DisplaySize.x >= 0.0 && g.IO.DisplaySize.y >= 0.0, "Invalid DisplaySize value!");
    assert(g.IO.Fonts.IsBuilt(), "Font Atlas not built! Make sure you called ImGui_ImplXXXX_NewFrame() function for renderer backend, which should call io.Fonts.GetTexDataAsRGBA32() / GetTexDataAsAlpha8()");
    assert(g.Style.CurveTessellationTol > 0.0, "Invalid style setting!");
    assert(g.Style.CircleTessellationMaxError > 0.0, "Invalid style setting!");
    assert(g.Style.Alpha >= 0.0 && g.Style.Alpha <= 1.0, "Invalid style setting!"); // Allows us to avoid a few clamps in color computations
    assert(g.Style.WindowMinSize.x >= 1.0 && g.Style.WindowMinSize.y >= 1.0, "Invalid style setting.");
    assert(g.Style.WindowMenuButtonPosition == nil || g.Style.WindowMenuButtonPosition == .Left || g.Style.WindowMenuButtonPosition == .Right);
    assert(g.Style.ColorButtonPosition == .Left || g.Style.ColorButtonPosition == .Right);

    // Error handling: we do not accept 100% silent recovery! Please contact me if you feel this is getting in your way.
    if (g.IO.ConfigErrorRecovery) {
        assert(g.IO.ConfigErrorRecoveryEnableAssert || g.IO.ConfigErrorRecoveryEnableDebugLog || g.IO.ConfigErrorRecoveryEnableTooltip || g.ErrorCallback != nil);
    }


    // Perform simple check: error if Docking or Viewport are enabled _exactly_ on frame 1 (instead of frame 0 or later), which is a common error leading to loss of .ini data.
    if (g.FrameCount == 1 && (.DockingEnable in g.IO.ConfigFlags) && (g.ConfigFlagsLastFrame & ImGuiConfigFlags_DockingEnable) == 0) {
        assert(false, "Please set DockingEnable before the first call to NewFrame()! Otherwise you will lose your .ini settings!");
    }
    if (g.FrameCount == 1 && (.ViewportsEnable in g.IO.ConfigFlags) && (g.ConfigFlagsLastFrame & ImGuiConfigFlags_ViewportsEnable) == 0) {
        assert(false, "Please set ViewportsEnable before the first call to NewFrame()! Otherwise you will lose your .ini settings!");
    }

    // Perform simple checks: multi-viewport and platform windows support
    if (.ViewportsEnable in g.IO.ConfigFlags)
    {
        if ((.PlatformHasViewports in g.IO.BackendFlags) && (.RendererHasViewports in g.IO.BackendFlags))
        {
            assert((g.FrameCount == 0 || g.FrameCount == g.FrameCountPlatformEnded), "Forgot to call UpdatePlatformWindows() in main loop after EndFrame()? Check examples/ applications for reference.");
            assert(g.PlatformIO.Platform_CreateWindow  != nil, "Platform init didn't install handlers?");
            assert(g.PlatformIO.Platform_DestroyWindow != nil, "Platform init didn't install handlers?");
            assert(g.PlatformIO.Platform_GetWindowPos  != nil, "Platform init didn't install handlers?");
            assert(g.PlatformIO.Platform_SetWindowPos  != nil, "Platform init didn't install handlers?");
            assert(g.PlatformIO.Platform_GetWindowSize != nil, "Platform init didn't install handlers?");
            assert(g.PlatformIO.Platform_SetWindowSize != nil, "Platform init didn't install handlers?");
            assert(len(g.PlatformIO.Monitors) > 0, "Platform init didn't setup Monitors list?");
            assert((g.Viewports[0]->PlatformUserData != nil || g.Viewports[0]->PlatformHandle != nil), "Platform init didn't setup main viewport.");
            if (g.IO.ConfigDockingTransparentPayload && (.DockingEnable in g.IO.ConfigFlags)) {
                assert(g.PlatformIO.Platform_SetWindowAlpha != nil, "Platform_SetWindowAlpha handler is required to use io.ConfigDockingTransparent!");
            }
        }
        else
        {
            // Disable feature, our backends do not support it
            g.IO.ConfigFlags &= ~ImGuiConfigFlags_ViewportsEnable;
        }

        // Perform simple checks on platform monitor data + compute a total bounding box for quick early outs
        for &mon in g.PlatformIO.Monitors
        {
            _ = mon;
            assert(mon.MainSize.x > 0.0 && mon.MainSize.y > 0.0, "Monitor main bounds not setup properly.");
            assert(ImRect{ _v = {mon.MainPos, mon.MainPos + mon.MainSize}}.Contains(ImRect{ _v = {mon.WorkPos, mon.WorkPos + mon.WorkSize}}), "Monitor work bounds not setup properly. If you don't have work area information, just copy MainPos/MainSize into them.");
            assert(mon.DpiScale > 0.0 && mon.DpiScale < 99.0, "Monitor DpiScale is invalid."); // Typical correct values would be between 1.0f and 4.0f
        }
    }
}

ErrorCheckEndFrameSanityChecks :: proc()
{
    // Verify that io.KeyXXX fields haven't been tampered with. Key mods should not be modified between NewFrame() and EndFrame()
    // One possible reason leading to this assert is that your backends update inputs _AFTER_ NewFrame().
    // It is known that when some modal native windows called mid-frame takes focus away, some backends such as GLFW will
    // send key release events mid-frame. This would normally trigger this assertion and lead to sheared inputs.
    // We silently accommodate for this case by ignoring the case where all io.KeyXXX modifiers were released (aka key_mod_flags == 0),
    // while still correctly asserting on mid-frame key press events.
    g := GImGui;
    key_mods := GetMergedModsFromKeys();
    _ = g;
    _ = key_mods;
    assert((key_mods == 0 || g.IO.KeyMods == key_mods), "Mismatching io.KeyCtrl/io.KeyShift/io.KeyAlt/io.KeySuper vs io.KeyMods");
    _ = key_mods;

    assert(len(g.CurrentWindowStack) == 1);
    assert(g.CurrentWindowStack[0].Window.IsFallbackWindow);
}

// Save current stack sizes. Called e.g. by NewFrame() and by Begin() but may be called for manual recovery.
ErrorRecoveryStoreState :: proc(state_out : ^ImGuiErrorRecoveryState)
{
    g := GImGui;
    state_out.SizeOfWindowStack = cast(i16)len(g.CurrentWindowStack);
    state_out.SizeOfIDStack = cast(i16)len(g.CurrentWindow.IDStack);
    state_out.SizeOfTreeStack = cast(i16)g.CurrentWindow.DC.TreeDepth; // NOT len(g.TreeNodeStack) which is a partial stack!
    state_out.SizeOfColorStack = cast(i16)len(g.ColorStack);
    state_out.SizeOfStyleVarStack = cast(i16)len(g.StyleVarStack);
    state_out.SizeOfFontStack = cast(i16)len(g.FontStack);
    state_out.SizeOfFocusScopeStack = cast(i16)len(g.FocusScopeStack);
    state_out.SizeOfGroupStack = cast(i16)len(g.GroupStack);
    state_out.SizeOfItemFlagsStack = cast(i16)len(g.ItemFlagsStack);
    state_out.SizeOfBeginPopupStack = cast(i16)len(g.BeginPopupStack);
    state_out.SizeOfDisabledStack = cast(i16)g.DisabledStackSize;
}

// Chosen name "Try to recover" over e.g. "Restore" to suggest this is not a 100% guaranteed recovery.
// Called by e.g. EndFrame() but may be called for manual recovery.
// Attempt to recover full window stack.
ErrorRecoveryTryToRecoverState :: proc(state_in : ^ImGuiErrorRecoveryState)
{
    // PVS-Studio V1044 is "Loop break conditions do not depend on the number of iterations"
    g := GImGui;
    for (len(g.CurrentWindowStack) > state_in.SizeOfWindowStack) //-V1044
    {
        // Recap:
        // - Begin()/BeginChild() return false to indicate the window is collapsed or fully clipped.
        // - Always call a matching End() for each Begin() call, regardless of its return value!
        // - Begin/End and BeginChild/EndChild logic is KNOWN TO BE INCONSISTENT WITH ALL OTHER BEGIN/END FUNCTIONS.
        // - We will fix that in a future major update.
        window := g.CurrentWindow;
        if (.ChildWindow in window.Flags)
        {
            if (g.CurrentTable != nil && g.CurrentTable.InnerWindow == g.CurrentWindow)
            {
                IM_ASSERT_USER_ERROR(false, "Missing EndTable()");
                EndTable();
            }
            else
            {
                IM_ASSERT_USER_ERROR(false, "Missing EndChild()");
                EndChild();
            }
        }
        else
        {
            IM_ASSERT_USER_ERROR(false, "Missing End()");
            End();
        }
    }
    if (len(g.CurrentWindowStack) == state_in.SizeOfWindowStack) {
        ErrorRecoveryTryToRecoverWindowState(state_in);
    }
}

// Called by e.g. End() but may be called for manual recovery.
// Read '// Error Handling [BETA]' block in imgui_internal.h for details.
// Attempt to recover from incorrect usage of BeginXXX/EndXXX/PushXXX/PopXXX calls.
ErrorRecoveryTryToRecoverWindowState :: proc(state_in : ^ImGuiErrorRecoveryState)
{
    g := GImGui;

    for (g.CurrentTable != nil && g.CurrentTable.InnerWindow == g.CurrentWindow) //-V1044
    {
        IM_ASSERT_USER_ERROR(false, "Missing EndTable()");
        EndTable();
    }

    window := g.CurrentWindow;

    // FIXME: Can't recover from inside BeginTabItem/EndTabItem yet.
    for (g.CurrentTabBar != nil && g.CurrentTabBar.Window == window) //-V1044
    {
        IM_ASSERT_USER_ERROR(false, "Missing EndTabBar()");
        EndTabBar();
    }
    for (g.CurrentMultiSelect != nil && g.CurrentMultiSelect.Storage.Window == window) //-V1044
    {
        IM_ASSERT_USER_ERROR(false, "Missing EndMultiSelect()");
        EndMultiSelect();
    }
    for (window.DC.TreeDepth > state_in.SizeOfTreeStack) //-V1044
    {
        IM_ASSERT_USER_ERROR(false, "Missing TreePop()");
        TreePop();
    }
    for (len(g.GroupStack) > state_in.SizeOfGroupStack) //-V1044
    {
        IM_ASSERT_USER_ERROR(false, "Missing EndGroup()");
        EndGroup();
    }
    assert(len(g.GroupStack) == state_in.SizeOfGroupStack);
    for (len(window.IDStack) > state_in.SizeOfIDStack) //-V1044
    {
        IM_ASSERT_USER_ERROR(false, "Missing PopID()");
        PopID();
    }
    for (g.DisabledStackSize > state_in.SizeOfDisabledStack) //-V1044
    {
        IM_ASSERT_USER_ERROR(false, "Missing EndDisabled()");
        if (.Disabled in g.CurrentItemFlags)   do EndDisabled()
        else
        {
            EndDisabledOverrideReenable();
            g.CurrentWindowStack.back().DisabledOverrideReenable = false;
        }
    }
    assert(g.DisabledStackSize == state_in.SizeOfDisabledStack);
    for (len(g.ColorStack) > state_in.SizeOfColorStack) //-V1044
    {
        IM_ASSERT_USER_ERROR(false, "Missing PopStyleColor()");
        PopStyleColor();
    }
    for (len(g.ItemFlagsStack) > state_in.SizeOfItemFlagsStack) //-V1044
    {
        IM_ASSERT_USER_ERROR(false, "Missing PopItemFlag()");
        PopItemFlag();
    }
    for (len(g.StyleVarStack) > state_in.SizeOfStyleVarStack) //-V1044
    {
        IM_ASSERT_USER_ERROR(false, "Missing PopStyleVar()");
        PopStyleVar();
    }
    for (len(g.FontStack) > state_in.SizeOfFontStack) //-V1044
    {
        IM_ASSERT_USER_ERROR(false, "Missing PopFont()");
        PopFont();
    }
    for (len(g.FocusScopeStack) > state_in.SizeOfFocusScopeStack) //-V1044
    {
        IM_ASSERT_USER_ERROR(false, "Missing PopFocusScope()");
        PopFocusScope();
    }
    //assert(len(g.FocusScopeStack) == state_in.SizeOfFocusScopeStack);
}

ErrorLog :: proc(msg : ^u8) -> bool
{
    g := GImGui;

    // Output to debug log
when !(IMGUI_DISABLE_DEBUG_TOOLS) {
    window := g.CurrentWindow;

    if (g.IO.ConfigErrorRecoveryEnableDebugLog)
    {
        if (g.ErrorFirst) {
            IMGUI_DEBUG_LOG_ERROR("[imgui-error] (current settings: Assert=%d, Log=%d, Tooltip=%d)\n",
                g.IO.ConfigErrorRecoveryEnableAssert, g.IO.ConfigErrorRecoveryEnableDebugLog, g.IO.ConfigErrorRecoveryEnableTooltip);
        }
        IMGUI_DEBUG_LOG_ERROR("[imgui-error] In window '%s': %s\n", window ? window.Name : "nil", msg);
    }
    g.ErrorFirst = false;

    // Output to tooltip
    if (g.IO.ConfigErrorRecoveryEnableTooltip)
    {
        if (g.WithinFrameScope && BeginErrorTooltip())
        {
            if (g.ErrorCountCurrentFrame < 20)
            {
                Text("In window '%s': %s", window ? window.Name : "nil", msg);
                if (window && (!window.IsFallbackWindow || window.WasActive)) {
                    GetForegroundDrawList(window)->AddRect(window.Pos, window.Pos + window.Size, IM_COL32(255, 0, 0, 255));
                }
            }
            if (g.ErrorCountCurrentFrame == 20)   do Text("(and more errors)")
            // EndFrame() will amend debug buttons to this window, after all errors have been submitted.
            EndErrorTooltip();
        }
        g.ErrorCountCurrentFrame += 1;
    }
}

    // Output to callback
    if (g.ErrorCallback != nil) {
        g.ErrorCallback(g, g.ErrorCallbackUserData, msg);
    }

    // Return whether we should assert
    return g.IO.ConfigErrorRecoveryEnableAssert;
}

ErrorCheckEndFrameFinalizeErrorTooltip :: proc()
{
when !(IMGUI_DISABLE_DEBUG_TOOLS) {
    g := GImGui;
    if (g.DebugDrawIdConflicts != 0 && g.IO.KeyCtrl == false) {
        g.DebugDrawIdConflictsCount = g.HoveredIdPreviousFrameItemCount;
    }
    if (g.DebugDrawIdConflicts != 0 && g.DebugItemPickerActive == false && BeginErrorTooltip())
    {
        Text("Programmer error: %d visible items with conflicting ID!", g.DebugDrawIdConflictsCount);
        BulletText("Code should use PushID()/PopID() in loops, or append \"##xx\" to same-label identifiers!");
        BulletText("Empty label e.g. Button(\"\") == same ID as parent widget/node. Use Button(\"##xx\") instead!");
        //BulletText("Code intending to use duplicate ID may use e.g. PushItemFlag(ImGuiItemFlags_AllowDuplicateId, true); ... PopItemFlag()"); // Not making this too visible for fear of it being abused.
        BulletText("Set io.ConfigDebugHighlightIdConflicts=false to disable this warning in non-programmers builds.");
        Separator();
        Text("(Hold CTRL to: use");
        SameLine();
        if (SmallButton("Item Picker"))   do DebugStartItemPicker()
        SameLine();
        Text("to break in item call-stack, or");
        SameLine();
        if (SmallButton("Open FAQ.About ID Stack System") && g.PlatformIO.Platform_OpenInShellFn != nil) {
            g.PlatformIO.Platform_OpenInShellFn(g, "https://github.com/ocornut/imgui/blob/master/docs/FAQ.md#qa-usage");
        }
        EndErrorTooltip();
    }

    if (g.ErrorCountCurrentFrame > 0 && BeginErrorTooltip()) // Amend at end of frame
    {
        Separator();
        Text("(Hold CTRL to:");
        SameLine();
        if (SmallButton("Enable Asserts")) {
            g.IO.ConfigErrorRecoveryEnableAssert = true;
        }
        //SameLine();
        //if (SmallButton("Hide Error Tooltips"))
        //    g.IO.ConfigErrorRecoveryEnableTooltip = false; // Too dangerous
        SameLine(0, 0);
        Text(")");
        EndErrorTooltip();
    }
}
}

// Pseudo-tooltip. Follow mouse until CTRL is held. When CTRL is held we lock position, allowing to click it.
BeginErrorTooltip :: proc() -> bool
{
    g := GImGui;
    window := FindWindowByName("##Tooltip_Error");
    use_locked_pos := (g.IO.KeyCtrl && window && window.WasActive);
    PushStyleColor(ImGuiCol.PopupBg, ImLerp(g.Style.Colors[ImGuiCol.PopupBg], ImVec4{1.0, 0.0, 0.0, 1.0}, 0.15));
    if (use_locked_pos) {
        SetNextWindowPos(g.ErrorTooltipLockedPos);
    }
    is_visible := Begin("##Tooltip_Error", nil, ImGuiWindowFlags_Tooltip | ImGuiWindowFlags_NoDecoration | ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoSavedSettings | ImGuiWindowFlags_AlwaysAutoResize);
    PopStyleColor();
    if (is_visible && g.CurrentWindow.BeginCount == 1)
    {
        SeparatorText("MESSAGE FROM DEAR IMGUI");
        BringWindowToDisplayFront(g.CurrentWindow);
        BringWindowToFocusFront(g.CurrentWindow);
        g.ErrorTooltipLockedPos = GetWindowPos();
    }
    else if (!is_visible)
    {
        End();
    }
    return is_visible;
}

EndErrorTooltip :: proc()
{
    End();
}

//-----------------------------------------------------------------------------
// [SECTION] ITEM SUBMISSION
//-----------------------------------------------------------------------------
// - KeepAliveID()
// - ItemAdd()
//-----------------------------------------------------------------------------

// Code not using ItemAdd() may need to call this manually otherwise ActiveId will be cleared. In IMGUI_VERSION_NUM < 18717 this was called by GetID().
KeepAliveID :: proc(id : ImGuiID)
{
    g := GImGui;
    if (g.ActiveId == id)   do g.ActiveIdIsAlive = id
    if (g.ActiveIdPreviousFrame == id) {
        g.ActiveIdPreviousFrameIsAlive = true;
    }
}

// Declare item bounding box for clipping and interaction.
// Note that the size can be different than the one provided to ItemSize(). Typically, widgets that spread over available surface
// declare their minimum size requirement to ItemSize() and provide a larger region to ItemAdd() which is used drawing/interaction.
// THIS IS IN THE PERFORMANCE CRITICAL PATH (UNTIL THE CLIPPING TEST AND EARLY-RETURN)
ItemAdd :: proc(bb : ^ImRect, id : ImGuiID, nav_bb_arg : ^ImRect = nil, extra_flags : ImGuiItemFlags = {}) -> bool
{
    g := GImGui;
    window := g.CurrentWindow;

    // Set item data
    // (DisplayRect is left untouched, made valid when ImGuiItemStatusFlags_HasDisplayRect is set)
    g.LastItemData.ID = id;
    g.LastItemData.Rect = bb;
    g.LastItemData.NavRect = nav_bb_arg != nil ? nav_bb_arg^ : bb;
    g.LastItemData.ItemFlags = g.CurrentItemFlags | g.NextItemData.ItemFlags | extra_flags;
    g.LastItemData.StatusFlags = ImGuiItemStatusFlags_None;
    // Note: we don't copy 'g.NextItemData.SelectionUserData' to an hypothetical g.LastItemData.SelectionUserData: since the former is not cleared.

    if (id != 0)
    {
        KeepAliveID(id);

        // Directional navigation processing
        // Runs prior to clipping early-out
        //  (a) So that NavInitRequest can be honored, for newly opened windows to select a default widget
        //  (b) So that we can scroll up/down past clipped items. This adds a small O(N) cost to regular navigation requests
        //      unfortunately, but it is still limited to one window. It may not scale very well for windows with ten of
        //      thousands of item, but at least NavMoveRequest is only set on user interaction, aka maximum once a frame.
        //      We could early out with "if (is_clipped && !g.NavInitRequest) return false;" but when we wouldn't be able
        //      to reach unclipped widgets. This would work if user had explicit scrolling control (e.g. mapped on a stick).
        // We intentionally don't check if g.NavWindow != NULL because g.NavAnyRequest should only be set when it is non null.
        // If we crash on a NULL g.NavWindow we need to fix the bug elsewhere.
        if (!(.NoNav in g.LastItemData.ItemFlags))
        {
            // FIMXE-NAV: investigate changing the window tests into a simple 'if (g.NavFocusScopeId == g.CurrentFocusScopeId)' test.
            window.DC.NavLayersActiveMaskNext |= (1 << window.DC.NavLayerCurrent);
            if (g.NavId == id || g.NavAnyRequest) {
                if (g.NavWindow.RootWindowForNav == window.RootWindowForNav) {
                    if (window == g.NavWindow || ((window.ChildFlags | g.NavWindow.ChildFlags) & ImGuiChildFlags_NavFlattened))   do NavProcessItem()
                }
            }
        }

        if (.HasShortcut in g.NextItemData.HasFlags)   do ItemHandleShortcut(id)
    }

    // Lightweight clear of SetNextItemXXX data.
    g.NextItemData.HasFlags = ImGuiNextItemDataFlags_None;
    g.NextItemData.ItemFlags = ImGuiItemFlags_None;

when IMGUI_ENABLE_TEST_ENGINE {
    if (id != 0) {
        IMGUI_TEST_ENGINE_ITEM_ADD(id, g.LastItemData.NavRect, &g.LastItemData);
    }
}

    // Clipping test
    // (this is an inline copy of IsClippedEx() so we can reuse the is_rect_visible value, otherwise we'd do 'if (IsClippedEx(bb, id)) return false')
    // g.NavActivateId is not necessarily == g.NavId, in the case of remote activation (e.g. shortcuts)
    is_rect_visible := bb.Overlaps(window.ClipRect);
    if (!is_rect_visible) {
        if (id == 0 || (id != g.ActiveId && id != g.ActiveIdPreviousFrame && id != g.NavId && id != g.NavActivateId)) {
            if (!g.ItemUnclipByLog)   do return false
        }
    }

    // [DEBUG]
when !(IMGUI_DISABLE_DEBUG_TOOLS) {
    if (id != 0)
    {
        if (id == g.DebugLocateId) {
            DebugLocateItemResolveWithLastItem();
        }

        // [DEBUG] People keep stumbling on this problem and using "" as identifier in the root of a window instead of "##something".
        // Empty identifier are valid and useful in a small amount of cases, but 99.9% of the time you want to use "##something".
        // READ THE FAQ: https://dearimgui.com/faq
        assert(id != window.ID, "Cannot have an empty ID at the root of a window. If you need an empty label, use ## and read the FAQ about how the ID Stack works!");
    }
    //if (g.IO.KeyAlt) window.DrawList.AddRect(bb.Min, bb.Max, IM_COL32(255,255,0,120)); // [DEBUG]
    //if ((.NoNav not_in g.LastItemData.ItemFlags))
    //    window.DrawList.AddRect(g.LastItemData.NavRect.Min, g.LastItemData.NavRect.Max, IM_COL32(255,255,0,255)); // [DEBUG]
}

    // We need to calculate this now to take account of the current clipping rectangle (as items like Selectable may change them)
    if (is_rect_visible) {
        g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_Visible;
    }
    if (IsMouseHoveringRect(bb.Min, bb.Max)) {
        g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_HoveredRect;
    }
    return true;
}

//-----------------------------------------------------------------------------
// [SECTION] LAYOUT
//-----------------------------------------------------------------------------
// - ItemSize()
// - SameLine()
// - GetCursorScreenPos()
// - SetCursorScreenPos()
// - GetCursorPos(), GetCursorPosX(), GetCursorPosY()
// - SetCursorPos(), SetCursorPosX(), SetCursorPosY()
// - GetCursorStartPos()
// - Indent()
// - Unindent()
// - SetNextItemWidth()
// - PushItemWidth()
// - PushMultiItemsWidths()
// - PopItemWidth()
// - CalcItemWidth()
// - CalcItemSize()
// - GetTextLineHeight()
// - GetTextLineHeightWithSpacing()
// - GetFrameHeight()
// - GetFrameHeightWithSpacing()
// - GetContentRegionMax()
// - GetContentRegionAvail(),
// - BeginGroup()
// - EndGroup()
// Also see in imgui_widgets: tab bars, and in imgui_tables: tables, columns.
//-----------------------------------------------------------------------------

// Advance cursor given item size for layout.
// Register minimum needed size so it can extend the bounding box used for auto-fit calculation.
// See comments in ItemAdd() about how/why the size provided to ItemSize() vs ItemAdd() may often different.
// THIS IS IN THE PERFORMANCE CRITICAL PATH.
ImVec2_ItemSize :: proc(size : ImVec2, text_baseline_y : f32 = 1.0)
{
    g := GImGui;
    window := g.CurrentWindow;
    if (window.SkipItems)   do return

    // We increase the height in this function to accommodate for baseline offset.
    // In theory we should be offsetting the starting position (window.DC.CursorPos), that will be the topic of a larger refactor,
    // but since ItemSize() is not yet an API that moves the cursor (to handle e.g. wrapping) enlarging the height has the same effect.
    offset_to_match_baseline_y := (text_baseline_y >= 0) ? ImMax(0.0, window.DC.CurrLineTextBaseOffset - text_baseline_y) : 0.0;

    line_y1 := window.DC.IsSameLine ? window.DC.CursorPosPrevLine.y : window.DC.CursorPos.y;
    line_height := ImMax(window.DC.CurrLineSize.y, /*ImMax(*/window.DC.CursorPos.y - line_y1/*, 0.0)*/ + size.y + offset_to_match_baseline_y);

    // Always align ourselves on pixel boundaries
    //if (g.IO.KeyAlt) window.DrawList.AddRect(window.DC.CursorPos, window.DC.CursorPos + ImVec2{size.x, line_height}, IM_COL32(255,0,0,200)); // [DEBUG]
    window.DC.CursorPosPrevLine.x = window.DC.CursorPos.x + size.x;
    window.DC.CursorPosPrevLine.y = line_y1;
    window.DC.CursorPos.x = math.trunc(window.Pos.x + window.DC.Indent.x + window.DC.ColumnsOffset.x);    // Next line
    window.DC.CursorPos.y = math.trunc(line_y1 + line_height + g.Style.ItemSpacing.y);                       // Next line
    window.DC.CursorMaxPos.x = ImMax(window.DC.CursorMaxPos.x, window.DC.CursorPosPrevLine.x);
    window.DC.CursorMaxPos.y = ImMax(window.DC.CursorMaxPos.y, window.DC.CursorPos.y - g.Style.ItemSpacing.y);
    //if (g.IO.KeyAlt) window.DrawList.AddCircle(window.DC.CursorMaxPos, 3.0f, IM_COL32(255,0,0,255), 4); // [DEBUG]

    window.DC.PrevLineSize.y = line_height;
    window.DC.CurrLineSize.y = 0.0;
    window.DC.PrevLineTextBaseOffset = ImMax(window.DC.CurrLineTextBaseOffset, text_baseline_y);
    window.DC.CurrLineTextBaseOffset = 0.0;
    window.DC.IsSetPos = false;
    window.DC.IsSameLine = false

    // Horizontal layout mode
    if (window.DC.LayoutType == .Horizontal)   do SameLine()
}

// Gets back to previous line and continue with horizontal layout
//      offset_from_start_x == 0 : follow right after previous item
//      offset_from_start_x != 0 : align to specified x position (relative to window/group left)
//      spacing_w < 0            : use default spacing if offset_from_start_x == 0, no spacing if offset_from_start_x != 0
//      spacing_w >= 0           : enforce spacing amount
// [forward declared comment]:
// call between widgets or groups to layout them horizontally. X position given in window coordinates.
SameLine :: proc(offset_from_start_x : f32, spacing_w : f32)
{
    g := GImGui;
    window := g.CurrentWindow;
    if (window.SkipItems)   do return

    if (offset_from_start_x != 0.0)
    {
        if (spacing_w < 0.0)   do spacing_w = 0.0
        window.DC.CursorPos.x = window.Pos.x - window.Scroll.x + offset_from_start_x + spacing_w + window.DC.GroupOffset.x + window.DC.ColumnsOffset.x;
        window.DC.CursorPos.y = window.DC.CursorPosPrevLine.y;
    }
    else
    {
        if (spacing_w < 0.0) do spacing_w = g.Style.ItemSpacing.x;
        window.DC.CursorPos.x = window.DC.CursorPosPrevLine.x + spacing_w;
        window.DC.CursorPos.y = window.DC.CursorPosPrevLine.y;
    }
    window.DC.CurrLineSize = window.DC.PrevLineSize;
    window.DC.CurrLineTextBaseOffset = window.DC.PrevLineTextBaseOffset;
    window.DC.IsSameLine = true;
}

// [forward declared comment]:
// cursor position, absolute coordinates. THIS IS YOUR BEST FRIEND (prefer using this rather than GetCursorPos(), also more useful to work with ImDrawList API).
GetCursorScreenPos :: proc() -> ImVec2
{
    window := GetCurrentWindowRead();
    return window.DC.CursorPos;
}

// [forward declared comment]:
// cursor position, absolute coordinates. THIS IS YOUR BEST FRIEND.
SetCursorScreenPos :: proc(pos : ImVec2)
{
    window := GetCurrentWindow();
    window.DC.CursorPos = pos;
    //window.DC.CursorMaxPos = ImMax(window.DC.CursorMaxPos, window.DC.CursorPos);
    window.DC.IsSetPos = true;
}

// User generally sees positions in window coordinates. Internally we store CursorPos in absolute screen coordinates because it is more convenient.
// Conversion happens as we pass the value to user, but it makes our naming convention confusing because GetCursorPos() == (DC.CursorPos - window.Pos). May want to rename 'DC.CursorPos'.
GetCursorPos :: proc() -> ImVec2
{
    window := GetCurrentWindowRead();
    return window.DC.CursorPos - window.Pos + window.Scroll;
}

// [forward declared comment]:
// [window-local] "
GetCursorPosX :: proc() -> f32
{
    window := GetCurrentWindowRead();
    return window.DC.CursorPos.x - window.Pos.x + window.Scroll.x;
}

// [forward declared comment]:
// [window-local] "
GetCursorPosY :: proc() -> f32
{
    window := GetCurrentWindowRead();
    return window.DC.CursorPos.y - window.Pos.y + window.Scroll.y;
}

// [forward declared comment]:
// [window-local] "
SetCursorPos :: proc(local_pos : ImVec2)
{
    window := GetCurrentWindow();
    window.DC.CursorPos = window.Pos - window.Scroll + local_pos;
    //window.DC.CursorMaxPos = ImMax(window.DC.CursorMaxPos, window.DC.CursorPos);
    window.DC.IsSetPos = true;
}

// [forward declared comment]:
// [window-local] "
SetCursorPosX :: proc(x : f32)
{
    window := GetCurrentWindow();
    window.DC.CursorPos.x = window.Pos.x - window.Scroll.x + x;
    //window.DC.CursorMaxPos.x = ImMax(window.DC.CursorMaxPos.x, window.DC.CursorPos.x);
    window.DC.IsSetPos = true;
}

// [forward declared comment]:
// [window-local] "
SetCursorPosY :: proc(y : f32)
{
    window := GetCurrentWindow();
    window.DC.CursorPos.y = window.Pos.y - window.Scroll.y + y;
    //window.DC.CursorMaxPos.y = ImMax(window.DC.CursorMaxPos.y, window.DC.CursorPos.y);
    window.DC.IsSetPos = true;
}

// [forward declared comment]:
// [window-local] initial cursor position, in window-local coordinates. Call GetCursorScreenPos() after Begin() to get the absolute coordinates version.
GetCursorStartPos :: proc() -> ImVec2
{
    window := GetCurrentWindowRead();
    return window.DC.CursorStartPos - window.Pos;
}

// [forward declared comment]:
// move content position toward the right, by indent_w, or style.IndentSpacing if indent_w <= 0
Indent :: proc(indent_w : f32 = 0.0)
{
    g := GImGui;
    window := GetCurrentWindow();
    window.DC.Indent.x += (indent_w != 0.0) ? indent_w : g.Style.IndentSpacing;
    window.DC.CursorPos.x = window.Pos.x + window.DC.Indent.x + window.DC.ColumnsOffset.x;
}

// [forward declared comment]:
// move content position back to the left, by indent_w, or style.IndentSpacing if indent_w <= 0
Unindent :: proc(indent_w : f32 = 0.0)
{
    g := GImGui;
    window := GetCurrentWindow();
    window.DC.Indent.x -= (indent_w != 0.0) ? indent_w : g.Style.IndentSpacing;
    window.DC.CursorPos.x = window.Pos.x + window.DC.Indent.x + window.DC.ColumnsOffset.x;
}

// Affect large frame+labels widgets only.
// [forward declared comment]:
// set width of the _next_ common large "item+label" widget. >0.0f: width in pixels, <0.0f align xx pixels to the right of window (so -FLT_MIN always align width to the right side)
SetNextItemWidth :: proc(item_width : f32)
{
    g := GImGui;
    g.NextItemData.HasFlags |= ImGuiNextItemDataFlags_HasWidth;
    g.NextItemData.Width = item_width;
}

// FIXME: Remove the == 0.0f behavior?
// [forward declared comment]:
// push width of items for common large "item+label" widgets. >0.0f: width in pixels, <0.0f align xx pixels to the right of window (so -FLT_MIN always align width to the right side).
PushItemWidth :: proc(item_width : f32)
{
    g := GImGui;
    window := g.CurrentWindow;
    window.DC.ItemWidthStack.append(window.DC.ItemWidth); // Backup current width
    window.DC.ItemWidth = (item_width == 0.0 ? window.ItemWidthDefault : item_width);
    g.NextItemData.HasFlags &= ~ImGuiNextItemDataFlags_HasWidth;
}

PushMultiItemsWidths :: proc(components : i32, w_full : f32)
{
    g := GImGui;
    window := g.CurrentWindow;
    assert(components > 0);
    style := &g.Style;
    window.DC.ItemWidthStack.append(window.DC.ItemWidth); // Backup current width
    w_items := w_full - style.ItemInnerSpacing.x * (components - 1);
    prev_split := w_items;
    for i := components - 1; i > 0; i -= 1
    {
        next_split := math.trunc(w_items * i / components);
        window.DC.ItemWidthStack.append(ImMax(prev_split - next_split, 1.0));
        prev_split = next_split;
    }
    window.DC.ItemWidth = ImMax(prev_split, 1.0);
    g.NextItemData.HasFlags &= ~ImGuiNextItemDataFlags_HasWidth;
}

PopItemWidth :: proc()
{
    g := GImGui;
    window := g.CurrentWindow;
    if (len(window.DC.ItemWidthStack) <= 0)
    {
        IM_ASSERT_USER_ERROR(false, "Calling PopItemWidth() too many times!");
        return;
    }
    window.DC.ItemWidth = window.DC.ItemWidthStack.back();
    window.DC.ItemWidthStack.pop_back();
}

// Calculate default item width given value passed to PushItemWidth() or SetNextItemWidth().
// The SetNextItemWidth() data is generally cleared/consumed by ItemAdd() or NextItemData.ClearFlags()
// [forward declared comment]:
// width of item given pushed settings and current cursor position. NOT necessarily the width of last item unlike most 'Item' functions.
CalcItemWidth :: proc() -> f32
{
    g := GImGui;
    window := g.CurrentWindow;
    w : f32
    if (.HasWidth in g.NextItemData.HasFlags)   do w = g.NextItemData.Width
    else do w = window.DC.ItemWidth;
    if (w < 0.0)
    {
        region_avail_x := GetContentRegionAvail().x;
        w = ImMax(1.0, region_avail_x + w);
    }
    w = math.trunc(w);
    return w;
}

// [Internal] Calculate full item size given user provided 'size' parameter and default width/height. Default width is often == CalcItemWidth().
// Those two functions CalcItemWidth vs CalcItemSize are awkwardly named because they are not fully symmetrical.
// Note that only CalcItemWidth() is publicly exposed.
// The 4.0f here may be changed to match CalcItemWidth() and/or BeginChild() (right now we have a mismatch which is harmless but undesirable)
CalcItemSize :: proc(size : ImVec2, default_w : f32, default_h : f32) -> ImVec2
{
    avail : ImVec2
    if (size.x < 0.0 || size.y < 0.0) {
        avail = GetContentRegionAvail();
    }

    if (size.x == 0.0)   do size.x = default_w
    else if (size.x < 0.0)  do size.x = ImMax(4.0, avail.x + size.x); // <-- size.x is negative here so we are subtracting

    if (size.y == 0.0)   do size.y = default_h
    else if (size.y < 0.0)   do size.y = ImMax(4.0, avail.y + size.y); // <-- size.y is negative here so we are subtracting

    return size;
}

// [forward declared comment]:
// ~ FontSize
GetTextLineHeight :: proc() -> f32
{
    g := GImGui;
    return g.FontSize;
}

// [forward declared comment]:
// ~ FontSize + style.ItemSpacing.y (distance in pixels between 2 consecutive lines of text)
GetTextLineHeightWithSpacing :: proc() -> f32
{
    g := GImGui;
    return g.FontSize + g.Style.ItemSpacing.y;
}

// [forward declared comment]:
// ~ FontSize + style.FramePadding.y * 2
GetFrameHeight :: proc() -> f32
{
    g := GImGui;
    return g.FontSize + g.Style.FramePadding.y * 2.0;
}

// [forward declared comment]:
// ~ FontSize + style.FramePadding.y * 2 + style.ItemSpacing.y (distance in pixels between 2 consecutive lines of framed widgets)
GetFrameHeightWithSpacing :: proc() -> f32
{
    g := GImGui;
    return g.FontSize + g.Style.FramePadding.y * 2.0 + g.Style.ItemSpacing.y;
}

// [forward declared comment]:
// available space from current position. THIS IS YOUR BEST FRIEND.
GetContentRegionAvail :: proc() -> ImVec2
{
    g := GImGui;
    window := g.CurrentWindow;
    mx := (window.DC.CurrentColumns || g.CurrentTable) ? window.WorkRect.Max : window.ContentRegionRect.Max;
    return mx - window.DC.CursorPos;
}


// Lock horizontal starting position + capture group bounding box into one "item" (so you can use IsItemHovered() or layout primitives such as SameLine() on whole group, etc.)
// Groups are currently a mishmash of functionalities which should perhaps be clarified and separated.
// FIXME-OPT: Could we safely early out on ->SkipItems?
// [forward declared comment]:
// lock horizontal starting position
BeginGroup :: proc()
{
    g := GImGui;
    window := g.CurrentWindow;

    g.GroupStack.resize(len(g.GroupStack) + 1);
    group_data := &g.GroupStack.back();
    group_data.WindowID = window.ID;
    group_data.BackupCursorPos = window.DC.CursorPos;
    group_data.BackupCursorPosPrevLine = window.DC.CursorPosPrevLine;
    group_data.BackupCursorMaxPos = window.DC.CursorMaxPos;
    group_data.BackupIndent = window.DC.Indent;
    group_data.BackupGroupOffset = window.DC.GroupOffset;
    group_data.BackupCurrLineSize = window.DC.CurrLineSize;
    group_data.BackupCurrLineTextBaseOffset = window.DC.CurrLineTextBaseOffset;
    group_data.BackupActiveIdIsAlive = g.ActiveIdIsAlive;
    group_data.BackupHoveredIdIsAlive = g.HoveredId != 0;
    group_data.BackupIsSameLine = window.DC.IsSameLine;
    group_data.BackupActiveIdPreviousFrameIsAlive = g.ActiveIdPreviousFrameIsAlive;
    group_data.EmitItem = true;

    window.DC.GroupOffset.x = window.DC.CursorPos.x - window.Pos.x - window.DC.ColumnsOffset.x;
    window.DC.Indent = window.DC.GroupOffset;
    window.DC.CursorMaxPos = window.DC.CursorPos;
    window.DC.CurrLineSize = ImVec2{0.0, 0.0};
    if (g.LogEnabled)  do g.LogLinePosY = -math.F32_MAX; // To enforce a carriage return
}

// [forward declared comment]:
// unlock horizontal starting position + capture the whole group bounding box into one "item" (so you can use IsItemHovered() or layout primitives such as SameLine() on whole group, etc.)
EndGroup :: proc()
{
    g := GImGui;
    window := g.CurrentWindow;
    assert(len(g.GroupStack) > 0); // Mismatched BeginGroup()/EndGroup() calls

    group_data := &g.GroupStack.back();
    assert(group_data.WindowID == window.ID); // EndGroup() in wrong window?

    if (window.DC.IsSetPos) {
        ErrorCheckUsingSetCursorPosToExtendParentBoundaries();
    }

    // Include LastItemData.Rect.Max as a workaround for e.g. EndTable() undershooting with CursorMaxPos report. (#7543)
    group_bb := ImRect(group_data.BackupCursorPos, ImMax(ImMax(window.DC.CursorMaxPos, g.LastItemData.Rect.Max), group_data.BackupCursorPos));
    window.DC.CursorPos = group_data.BackupCursorPos;
    window.DC.CursorPosPrevLine = group_data.BackupCursorPosPrevLine;
    window.DC.CursorMaxPos = ImMax(group_data.BackupCursorMaxPos, group_bb.Max);
    window.DC.Indent = group_data.BackupIndent;
    window.DC.GroupOffset = group_data.BackupGroupOffset;
    window.DC.CurrLineSize = group_data.BackupCurrLineSize;
    window.DC.CurrLineTextBaseOffset = group_data.BackupCurrLineTextBaseOffset;
    window.DC.IsSameLine = group_data.BackupIsSameLine;
    if (g.LogEnabled) {
        g.LogLinePosY = -math.F32_MAX; // To enforce a carriage return
    }

    if (!group_data.EmitItem)
    {
        g.GroupStack.pop_back();
        return;
    }

    window.DC.CurrLineTextBaseOffset = ImMax(window.DC.PrevLineTextBaseOffset, group_data.BackupCurrLineTextBaseOffset); // FIXME: Incorrect, we should grab the base offset from the *first line* of the group but it is hard to obtain now.
    ItemSize(group_bb.GetSize());
    ItemAdd(group_bb, 0, nil, ImGuiItemFlags_NoTabStop);

    // If the current ActiveId was declared within the boundary of our group, we copy it to LastItemId so IsItemActive(), IsItemDeactivated() etc. will be functional on the entire group.
    // It would be neater if we replaced window.DC.LastItemId by e.g. 'bool LastItemIsActive', but would put a little more burden on individual widgets.
    // Also if you grep for LastItemId you'll notice it is only used in that context.
    // (The two tests not the same because ActiveIdIsAlive is an ID itself, in order to be able to handle ActiveId being overwritten during the frame.)
    group_contains_curr_active_id := (group_data.BackupActiveIdIsAlive != g.ActiveId) && (g.ActiveIdIsAlive == g.ActiveId) && g.ActiveId;
    group_contains_prev_active_id := (group_data.BackupActiveIdPreviousFrameIsAlive == false) && (g.ActiveIdPreviousFrameIsAlive == true);
    if (group_contains_curr_active_id) {
        g.LastItemData.ID = g.ActiveId;
    }
    else if (group_contains_prev_active_id) {
        g.LastItemData.ID = g.ActiveIdPreviousFrame;
    }
    g.LastItemData.Rect = group_bb;

    // Forward Hovered flag
    group_contains_curr_hovered_id := (group_data.BackupHoveredIdIsAlive == false) && g.HoveredId != 0;
    if (group_contains_curr_hovered_id) {
        g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_HoveredWindow;
    }

    // Forward Edited flag
    if (group_contains_curr_active_id && g.ActiveIdHasBeenEditedThisFrame) {
        g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_Edited;
    }

    // Forward Deactivated flag
    g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_HasDeactivated;
    if (group_contains_prev_active_id && g.ActiveId != g.ActiveIdPreviousFrame) {
        g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_Deactivated;
    }

    g.GroupStack.pop_back();
    if (g.DebugShowGroupRects) {
        window.DrawList.AddRect(group_bb.Min, group_bb.Max, IM_COL32(255,0,255,255));   // [Debug]
    }
}


//-----------------------------------------------------------------------------
// [SECTION] SCROLLING
//-----------------------------------------------------------------------------

// Helper to snap on edges when aiming at an item very close to the edge,
// So the difference between WindowPadding and ItemSpacing will be in the visible area after scrolling.
// When we refactor the scrolling API this may be configurable with a flag?
// Note that the effect for this won't be visible on X axis with default Style settings as WindowPadding.x == ItemSpacing.x by default.
CalcScrollEdgeSnap :: proc(target : f32, snap_min : f32, snap_max : f32, snap_threshold : f32, center_ratio : f32) -> f32
{
    if (target <= snap_min + snap_threshold) {
        return ImLerp(snap_min, target, center_ratio);
    }
    if (target >= snap_max - snap_threshold) {
        return ImLerp(target, snap_max, center_ratio);
    }
    return target;
}

CalcNextScrollFromScrollTargetAndClamp :: proc(window : ^ImGuiWindow) -> ImVec2
{
    scroll := window.Scroll;
    decoration_size := ImVec2{window.DecoOuterSizeX1 + window.DecoInnerSizeX1 + window.DecoOuterSizeX2, window.DecoOuterSizeY1 + window.DecoInnerSizeY1 + window.DecoOuterSizeY2};
    for axis := 0; axis < 2; axis += 1
    {
        if (window.ScrollTarget[axis] < math.F32_MAX)
        {
            center_ratio := window.ScrollTargetCenterRatio[axis];
            scroll_target := window.ScrollTarget[axis];
            if (window.ScrollTargetEdgeSnapDist[axis] > 0.0)
            {
                snap_min := 0.0;
                snap_max := window.ScrollMax[axis] + window.SizeFull[axis] - decoration_size[axis];
                scroll_target = CalcScrollEdgeSnap(scroll_target, snap_min, snap_max, window.ScrollTargetEdgeSnapDist[axis], center_ratio);
            }
            scroll[axis] = scroll_target - center_ratio * (window.SizeFull[axis] - decoration_size[axis]);
        }
        scroll[axis] = math.round(ImMax(scroll[axis], 0.0));
        if (!window.Collapsed && !window.SkipItems) {
            scroll[axis] = ImMin(scroll[axis], window.ScrollMax[axis]);
        }
    }
    return scroll;
}

ScrollToItem :: proc(flags : ImGuiScrollFlags = {})
{
    g := GImGui;
    window := g.CurrentWindow;
    ScrollToRectEx(window, g.LastItemData.NavRect, flags);
}

ScrollToRect :: proc(window : ^ImGuiWindow, item_rect : ^ImRect, flags : ImGuiScrollFlags = {})
{
    ScrollToRectEx(window, item_rect, flags);
}

// Scroll to keep newly navigated item fully into view
ScrollToRectEx :: proc(window : ^ImGuiWindow, item_rect : ^ImRect, flags : ImGuiScrollFlags = {}) -> ImVec2
{
    g := GImGui;
    scroll_rect := ImRect{ _r = {window.InnerRect.Min - ImVec2{1, 1}, window.InnerRect.Max + ImVec2{1, 1}}};
    scroll_rect.Min.x = ImMin(scroll_rect.Min.x + window.DecoInnerSizeX1, scroll_rect.Max.x);
    scroll_rect.Min.y = ImMin(scroll_rect.Min.y + window.DecoInnerSizeY1, scroll_rect.Max.y);
    //GetForegroundDrawList(window)->AddRect(item_rect.Min, item_rect.Max, IM_COL32(255,0,0,255), 0.0f, 0, 5.0f); // [DEBUG]
    //GetForegroundDrawList(window)->AddRect(scroll_rect.Min, scroll_rect.Max, IM_COL32_WHITE); // [DEBUG]

    // Check that only one behavior is selected per axis
    assert((flags & ImGuiScrollFlags_MaskX_) == 0 || math.is_power_of_two(flags & ImGuiScrollFlags_MaskX_));
    assert((flags & ImGuiScrollFlags_MaskY_) == 0 || math.is_power_of_two(flags & ImGuiScrollFlags_MaskY_));

    // Defaults
    in_flags := flags;
    if ((flags & ImGuiScrollFlags_MaskX_) == 0 && window.ScrollbarX) {
        flags |= ImGuiScrollFlags_KeepVisibleEdgeX;
    }
    if ((flags & ImGuiScrollFlags_MaskY_) == 0) {
        flags |= window.Appearing ? ImGuiScrollFlags_AlwaysCenterY : ImGuiScrollFlags_KeepVisibleEdgeY;
    }

    fully_visible_x := item_rect.Min.x >= scroll_rect.Min.x && item_rect.Max.x <= scroll_rect.Max.x;
    fully_visible_y := item_rect.Min.y >= scroll_rect.Min.y && item_rect.Max.y <= scroll_rect.Max.y;
    can_be_fully_visible_x := (item_rect.GetWidth() + g.Style.ItemSpacing.x * 2.0) <= scroll_rect.GetWidth() || (window.AutoFitFramesX > 0) || (.AlwaysAutoResize in window.Flags) != 0;
    can_be_fully_visible_y := (item_rect.GetHeight() + g.Style.ItemSpacing.y * 2.0) <= scroll_rect.GetHeight() || (window.AutoFitFramesY > 0) || (.AlwaysAutoResize in window.Flags) != 0;

    if ((.KeepVisibleEdgeX in flags) && !fully_visible_x)
    {
        if (item_rect.Min.x < scroll_rect.Min.x || !can_be_fully_visible_x) {
            SetScrollFromPosX(window, item_rect.Min.x - g.Style.ItemSpacing.x - window.Pos.x, 0.0);
        }
        else if (item_rect.Max.x >= scroll_rect.Max.x) {
            SetScrollFromPosX(window, item_rect.Max.x + g.Style.ItemSpacing.x - window.Pos.x, 1.0);
        }
    }
    else if (((.KeepVisibleCenterX in flags) && !fully_visible_x) || (.AlwaysCenterX in flags))
    {
        if (can_be_fully_visible_x) {
            SetScrollFromPosX(window, ImTrunc((item_rect.Min.x + item_rect.Max.x) * 0.5) - window.Pos.x, 0.5);
        }
        else {
            SetScrollFromPosX(window, item_rect.Min.x - window.Pos.x, 0.0);
        }
    }

    if ((.KeepVisibleEdgeY in flags) && !fully_visible_y)
    {
        if (item_rect.Min.y < scroll_rect.Min.y || !can_be_fully_visible_y) {
            SetScrollFromPosY(window, item_rect.Min.y - g.Style.ItemSpacing.y - window.Pos.y, 0.0);
        }
        else if (item_rect.Max.y >= scroll_rect.Max.y) {
            SetScrollFromPosY(window, item_rect.Max.y + g.Style.ItemSpacing.y - window.Pos.y, 1.0);
        }
    }
    else if (((.KeepVisibleCenterY in flags) && !fully_visible_y) || (.AlwaysCenterY in flags))
    {
        if (can_be_fully_visible_y) {
            SetScrollFromPosY(window, ImTrunc((item_rect.Min.y + item_rect.Max.y) * 0.5) - window.Pos.y, 0.5);
        }
        else {
            SetScrollFromPosY(window, item_rect.Min.y - window.Pos.y, 0.0);
        }
    }

    next_scroll := CalcNextScrollFromScrollTargetAndClamp(window);
    delta_scroll := next_scroll - window.Scroll;

    // Also scroll parent window to keep us into view if necessary
    if (!(.NoScrollParent in flags) && (.ChildWindow in window.Flags))
    {
        // FIXME-SCROLL: May be an option?
        if ((in_flags & (ImGuiScrollFlags_AlwaysCenterX | ImGuiScrollFlags_KeepVisibleCenterX)) != 0) {
            in_flags = (in_flags & ~ImGuiScrollFlags_MaskX_) | ImGuiScrollFlags_KeepVisibleEdgeX;
        }
        if ((in_flags & (ImGuiScrollFlags_AlwaysCenterY | ImGuiScrollFlags_KeepVisibleCenterY)) != 0) {
            in_flags = (in_flags & ~ImGuiScrollFlags_MaskY_) | ImGuiScrollFlags_KeepVisibleEdgeY;
        }
        delta_scroll += ScrollToRectEx(window.ParentWindow, ImRect{ _v = {item_rect.Min - delta_scroll, item_rect.Max - delta_scroll}}, in_flags);
    }

    return delta_scroll;
}

// [forward declared comment]:
// get scrolling amount [0 .. GetScrollMaxX()]
GetScrollX :: proc() -> f32
{
    window := GImGui.CurrentWindow;
    return window.Scroll.x;
}

// [forward declared comment]:
// get scrolling amount [0 .. GetScrollMaxY()]
GetScrollY :: proc() -> f32
{
    window := GImGui.CurrentWindow;
    return window.Scroll.y;
}

// [forward declared comment]:
// get maximum scrolling amount ~~ ContentSize.x - WindowSize.x - DecorationsSize.x
GetScrollMaxX :: proc() -> f32
{
    window := GImGui.CurrentWindow;
    return window.ScrollMax.x;
}

// [forward declared comment]:
// get maximum scrolling amount ~~ ContentSize.y - WindowSize.y - DecorationsSize.y
GetScrollMaxY :: proc() -> f32
{
    window := GImGui.CurrentWindow;
    return window.ScrollMax.y;
}

SetScrollX :: proc(window : ^ImGuiWindow, scroll_x : f32)
{
    window.ScrollTarget.x = scroll_x;
    window.ScrollTargetCenterRatio.x = 0.0;
    window.ScrollTargetEdgeSnapDist.x = 0.0;
}

SetScrollY :: proc(window : ^ImGuiWindow, scroll_y : f32)
{
    window.ScrollTarget.y = scroll_y;
    window.ScrollTargetCenterRatio.y = 0.0;
    window.ScrollTargetEdgeSnapDist.y = 0.0;
}

SetScrollX :: proc(scroll_x : f32)
{
    g := GImGui;
    SetScrollX(g.CurrentWindow, scroll_x);
}

SetScrollY :: proc(scroll_y : f32)
{
    g := GImGui;
    SetScrollY(g.CurrentWindow, scroll_y);
}

// Note that a local position will vary depending on initial scroll value,
// This is a little bit confusing so bear with us:
//  - local_pos = (absolution_pos - window.Pos)
//  - So local_x/local_y are 0.0f for a position at the upper-left corner of a window,
//    and generally local_x/local_y are >(padding+decoration) && <(size-padding-decoration) when in the visible area.
//  - They mostly exist because of legacy API.
// Following the rules above, when trying to work with scrolling code, consider that:
//  - SetScrollFromPosY(0.0f) == SetScrollY(0.0f + scroll.y) == has no effect!
//  - SetScrollFromPosY(-scroll.y) == SetScrollY(-scroll.y + scroll.y) == SetScrollY(0.0f) == reset scroll. Of course writing SetScrollY(0.0f) directly then makes more sense
// We store a target position so centering and clamping can occur on the next frame when we are guaranteed to have a known window size
SetScrollFromPosX :: proc(window : ^ImGuiWindow, local_x : f32, center_x_ratio : f32)
{
    assert(center_x_ratio >= 0.0 && center_x_ratio <= 1.0);
    window.ScrollTarget.x = math.trunc(local_x - window.DecoOuterSizeX1 - window.DecoInnerSizeX1 + window.Scroll.x); // Convert local position to scroll offset
    window.ScrollTargetCenterRatio.x = center_x_ratio;
    window.ScrollTargetEdgeSnapDist.x = 0.0;
}

SetScrollFromPosY :: proc(window : ^ImGuiWindow, local_y : f32, center_y_ratio : f32)
{
    assert(center_y_ratio >= 0.0 && center_y_ratio <= 1.0);
    window.ScrollTarget.y = math.trunc(local_y - window.DecoOuterSizeY1 - window.DecoInnerSizeY1 + window.Scroll.y); // Convert local position to scroll offset
    window.ScrollTargetCenterRatio.y = center_y_ratio;
    window.ScrollTargetEdgeSnapDist.y = 0.0;
}

SetScrollFromPosX :: proc(local_x : f32, center_x_ratio : f32)
{
    g := GImGui;
    SetScrollFromPosX(g.CurrentWindow, local_x, center_x_ratio);
}

SetScrollFromPosY :: proc(local_y : f32, center_y_ratio : f32)
{
    g := GImGui;
    SetScrollFromPosY(g.CurrentWindow, local_y, center_y_ratio);
}

// center_x_ratio: 0.0f left of last item, 0.5f horizontal center of last item, 1.0f right of last item.
// [forward declared comment]:
// adjust scrolling amount to make current cursor position visible. center_x_ratio=0.0: left, 0.5: center, 1.0: right. When using to make a "default/current item" visible, consider using SetItemDefaultFocus() instead.
SetScrollHereX :: proc(center_x_ratio : f32 = 0.5)
{
    g := GImGui;
    window := g.CurrentWindow;
    spacing_x := ImMax(window.WindowPadding.x, g.Style.ItemSpacing.x);
    target_pos_x := ImLerp(g.LastItemData.Rect.Min.x - spacing_x, g.LastItemData.Rect.Max.x + spacing_x, center_x_ratio);
    SetScrollFromPosX(window, target_pos_x - window.Pos.x, center_x_ratio); // Convert from absolute to local pos

    // Tweak: snap on edges when aiming at an item very close to the edge
    window.ScrollTargetEdgeSnapDist.x = ImMax(0.0, window.WindowPadding.x - spacing_x);
}

// center_y_ratio: 0.0f top of last item, 0.5f vertical center of last item, 1.0f bottom of last item.
// [forward declared comment]:
// adjust scrolling amount to make current cursor position visible. center_y_ratio=0.0: top, 0.5: center, 1.0: bottom. When using to make a "default/current item" visible, consider using SetItemDefaultFocus() instead.
SetScrollHereY :: proc(center_y_ratio : f32 = 0.5)
{
    g := GImGui;
    window := g.CurrentWindow;
    spacing_y := ImMax(window.WindowPadding.y, g.Style.ItemSpacing.y);
    target_pos_y := ImLerp(window.DC.CursorPosPrevLine.y - spacing_y, window.DC.CursorPosPrevLine.y + window.DC.PrevLineSize.y + spacing_y, center_y_ratio);
    SetScrollFromPosY(window, target_pos_y - window.Pos.y, center_y_ratio); // Convert from absolute to local pos

    // Tweak: snap on edges when aiming at an item very close to the edge
    window.ScrollTargetEdgeSnapDist.y = ImMax(0.0, window.WindowPadding.y - spacing_y);
}

//-----------------------------------------------------------------------------
// [SECTION] TOOLTIPS
//-----------------------------------------------------------------------------

// [forward declared comment]:
// begin/append a tooltip window.
BeginTooltip :: proc() -> bool
{
    return BeginTooltipEx(ImGuiTooltipFlags_None, ImGuiWindowFlags_None);
}

// [forward declared comment]:
// begin/append a tooltip window if preceding item was hovered.
BeginItemTooltip :: proc() -> bool
{
    if (!IsItemHovered(ImGuiHoveredFlags_ForTooltip))   do return false
    return BeginTooltipEx(ImGuiTooltipFlags_None, ImGuiWindowFlags_None);
}

BeginTooltipEx :: proc(tooltip_flags : ImGuiTooltipFlags, extra_window_flags : ImGuiWindowFlags) -> bool
{
    g := GImGui;

    is_dragdrop_tooltip := g.DragDropWithinSource || g.DragDropWithinTarget;
    if (is_dragdrop_tooltip)
    {
        // Drag and Drop tooltips are positioning differently than other tooltips:
        // - offset visibility to increase visibility around mouse.
        // - never clamp within outer viewport boundary.
        // We call SetNextWindowPos() to enforce position and disable clamping.
        // See FindBestWindowPosForPopup() for positionning logic of other tooltips (not drag and drop ones).
        //ImVec2 tooltip_pos = g.IO.MousePos - g.ActiveIdClickOffset - g.Style.WindowPadding;
        is_touchscreen := (g.IO.MouseSource == ImGuiMouseSource_TouchScreen);
        if ((.HasPos not_in g.NextWindowData.Flags))
        {
            tooltip_pos := is_touchscreen ? (g.IO.MousePos + TOOLTIP_DEFAULT_OFFSET_TOUCH * g.Style.MouseCursorScale) : (g.IO.MousePos + TOOLTIP_DEFAULT_OFFSET_MOUSE * g.Style.MouseCursorScale);
            tooltip_pivot := is_touchscreen ? TOOLTIP_DEFAULT_PIVOT_TOUCH : ImVec2{0.0, 0.0};
            SetNextWindowPos(tooltip_pos, ImGuiCond_None, tooltip_pivot);
        }

        SetNextWindowBgAlpha(g.Style.Colors[ImGuiCol.PopupBg].w * 0.60);
        //PushStyleVar(ImGuiStyleVar_Alpha, g.Style.Alpha * 0.60f); // This would be nice but e.g ColorButton with checkboard has issue with transparent colors :(
        tooltip_flags |= ImGuiTooltipFlags_OverridePrevious;
    }

    window_name_template := is_dragdrop_tooltip ? "##Tooltip_DragDrop_%02d" : "##Tooltip_%02d";
    window_name : [32]u8;
    ImFormatString(window_name, len(window_name), window_name_template, g.TooltipOverrideCount);
    if ((.OverridePrevious in tooltip_flags) && g.TooltipPreviousWindow != nil && g.TooltipPreviousWindow.Active)
    {
        // Hide previous tooltip from being displayed. We can't easily "reset" the content of a window so we create a new one.
        //IMGUI_DEBUG_LOG("[tooltip] '%s' already active, using +1 for this frame\n", window_name);
        SetWindowHiddenAndSkipItemsForCurrentFrame(g.TooltipPreviousWindow);
        g.TooltipOverrideCount += 1
        ImFormatString(window_name, len(window_name), window_name_template, g.TooltipOverrideCount);
    }

    flags := ImGuiWindowFlags_Tooltip | ImGuiWindowFlags_NoInputs | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoSavedSettings | ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoDocking;
    Begin(window_name, nil, flags | extra_window_flags);
    // 2023-03-09: Added bool return value to the API, but currently always returning true.
    // If this ever returns false we need to update BeginDragDropSource() accordingly.
    //if (!ret)   do //    End()
    //return ret;
    return true;
}

// [forward declared comment]:
// only call EndTooltip() if BeginTooltip()/BeginItemTooltip() returns true!
EndTooltip :: proc()
{
    assert(GetCurrentWindowRead()->Flags & ImGuiWindowFlags_Tooltip);   // Mismatched BeginTooltip()/EndTooltip() calls
    End();
}

// [forward declared comment]:
// set a text-only tooltip. Often used after a ImGui::IsItemHovered() check. Override any previous call to SetTooltip().
SetTooltip :: proc(fmt : string, args : ..any)
{
    if (!BeginTooltipEx(ImGuiTooltipFlags_OverridePrevious, ImGuiWindowFlags_None))   do return
    TextV(fmt, args);
    EndTooltip();
}

// Shortcut to use 'style.HoverFlagsForTooltipMouse' or 'style.HoverFlagsForTooltipNav'.
// Defaults to == ImGuiHoveredFlags_Stationary | ImGuiHoveredFlags_DelayShort when using the mouse.
// [forward declared comment]:
// set a text-only tooltip if preceding item was hovered. override any previous call to SetTooltip().
SetItemTooltip :: proc(fmt : string, args : ..any)
{
    if (IsItemHovered(ImGuiHoveredFlags_ForTooltip))   do SetTooltipV(fmt, args)
}


//-----------------------------------------------------------------------------
// [SECTION] POPUPS
//-----------------------------------------------------------------------------

// Supported flags: ImGuiPopupFlags_AnyPopupId, ImGuiPopupFlags_AnyPopupLevel
IsPopupOpen :: proc(id : ImGuiID, popup_flags : ImGuiPopupFlags) -> bool
{
    g := GImGui;
    if (.AnyPopupId in popup_flags)
    {
        // Return true if any popup is open at the current BeginPopup() level of the popup stack
        // This may be used to e.g. test for another popups already opened to handle popups priorities at the same level.
        assert(id == 0);
        if (.AnyPopupLevel in popup_flags)   do return len(g.OpenPopupStack) > 0
        else  do return len(g.OpenPopupStack) > len(g.BeginPopupStack);
    }
    else
    {
        if (.AnyPopupLevel in popup_flags)
        {
            // Return true if the popup is open anywhere in the popup stack
            for &popup_data in g.OpenPopupStack {
                if (popup_data.PopupId == id)   do return true
            }
            return false;
        }
        else
        {
            // Return true if the popup is open at the current BeginPopup() level of the popup stack (this is the most-common query)
            return len(g.OpenPopupStack) > len(g.BeginPopupStack) && g.OpenPopupStack[g.BeginPopupStack.Size].PopupId == id;
        }
    }
}

IsPopupOpen :: proc(str_id : ^u8, popup_flags : ImGuiPopupFlags) -> bool
{
    g := GImGui;
    id := (.AnyPopupId in popup_flags) ? 0 : g.CurrentWindow.GetID(str_id);
    if ((.AnyPopupLevel in popup_flags) && id != 0) {
        assert(false, "Cannot use IsPopupOpen() with a string id and ImGuiPopupFlags_AnyPopupLevel."); // But non-string version is legal and used internally
    }
    return IsPopupOpen(id, popup_flags);
}

// Also see FindBlockingModal(NULL)
GetTopMostPopupModal :: proc() -> ^ImGuiWindow
{
    g := GImGui;
    for n := len(g.OpenPopupStack) - 1; n >= 0; n -= 1 {
        if popup := g.OpenPopupStack.Data[n].Window; popup != nil {
            if (.Modal in popup.Flags)   do return popup
        }
    }
    return nil;
}

// See Demo->Stacked Modal to confirm what this is for.
GetTopMostAndVisiblePopupModal :: proc() -> ^ImGuiWindow
{
    g := GImGui;
    for n := len(g.OpenPopupStack) - 1; n >= 0; n -= 1 {
        if popup := g.OpenPopupStack.Data[n].Window; popup != nil {
            if ((.Modal in popup.Flags) && IsWindowActiveAndVisible(popup))   do return popup
        }
    }
    return nil;
}


// When a modal popup is open, newly created windows that want focus (i.e. are not popups and do not specify ImGuiWindowFlags_NoFocusOnAppearing)
// should be positioned behind that modal window, unless the window was created inside the modal begin-stack.
// In case of multiple stacked modals newly created window honors begin stack order and does not go below its own modal parent.
// - WindowA            // FindBlockingModal() returns Modal1
//   - WindowB          //                  .. returns Modal1
//   - Modal1           //                  .. returns Modal2
//      - WindowC       //                  .. returns Modal2
//          - WindowD   //                  .. returns Modal2
//          - Modal2    //                  .. returns Modal2
//            - WindowE //                  .. returns NULL
// Notes:
// - FindBlockingModal(NULL) == NULL is generally equivalent to GetTopMostPopupModal() == NULL.
//   Only difference is here we check for ->Active/WasActive but it may be unnecessary.
FindBlockingModal :: proc(window : ^ImGuiWindow) -> ^ImGuiWindow
{
    g := GImGui;
    if (len(g.OpenPopupStack) <= 0)   do return nil

    // Find a modal that has common parent with specified window. Specified window should be positioned behind that modal.
    for &popup_data in g.OpenPopupStack
    {
        popup_window := popup_data.Window;
        if (popup_window == nil || !(.Modal in popup_window.Flags))   do continue
        if (!popup_window.Active && !popup_window.WasActive) do continue // Check WasActive, because this code may run before popup renders on current frame, also check Active to handle newly created windows.
        if (window == nil)   do return popup_window                                  // FindBlockingModal(NULL) test for if FocusWindow(NULL) is naturally possible via a mouse click.
        if (IsWindowWithinBeginStackOf(window, popup_window))  do continue // Window may be over modal
        return popup_window;                                    // Place window right below first block modal
    }
    return nil;
}

// [forward declared comment]:
// id overload to facilitate calling from nested stacks
OpenPopup :: proc(str_id : ^u8, popup_flags : ImGuiPopupFlags = {})
{
    g := GImGui;
    id := g.CurrentWindow.GetID(str_id);
    IMGUI_DEBUG_LOG_POPUP("[popup] OpenPopup(\"%s\" -> 0x%08X)\n", str_id, id);
    OpenPopupEx(id, popup_flags);
}

// [forward declared comment]:
// id overload to facilitate calling from nested stacks
OpenPopup :: proc(id : ImGuiID, popup_flags : ImGuiPopupFlags = {})
{
    OpenPopupEx(id, popup_flags);
}

// Mark popup as open (toggle toward open state).
// Popups are closed when user click outside, or activate a pressable item, or CloseCurrentPopup() is called within a BeginPopup()/EndPopup() block.
// Popup identifiers are relative to the current ID-stack (so OpenPopup and BeginPopup needs to be at the same level).
// One open popup per level of the popup hierarchy (NB: when assigning we reset the Window member of ImGuiPopupRef to NULL)
OpenPopupEx :: proc(id : ImGuiID, popup_flags : ImGuiPopupFlags = ImGuiPopupFlags_None)
{
    g := GImGui;
    parent_window := g.CurrentWindow;
    current_stack_size := len(g.BeginPopupStack);

    if (.NoOpenOverExistingPopup in popup_flags) {
        if (IsPopupOpen(cast(ImGuiID)0, ImGuiPopupFlags_AnyPopupId))   do return
    }

    popup_ref : ImGuiPopupData // Tagged as new ref as Window will be set back to NULL if we write this into OpenPopupStack.
    popup_ref.PopupId = id;
    popup_ref.Window = nil;
    popup_ref.RestoreNavWindow = g.NavWindow;           // When popup closes focus may be restored to NavWindow (depend on window type).
    popup_ref.OpenFrameCount = g.FrameCount;
    popup_ref.OpenParentId = parent_window.IDStack.back();
    popup_ref.OpenPopupPos = NavCalcPreferredRefPos();
    popup_ref.OpenMousePos = IsMousePosValid(&g.IO.MousePos) ? g.IO.MousePos : popup_ref.OpenPopupPos;

    IMGUI_DEBUG_LOG_POPUP("[popup] OpenPopupEx(0x%08X)\n", id);
    if (len(g.OpenPopupStack) < current_stack_size + 1)
    {
        g.OpenPopupStack.append(popup_ref);
    }
    else
    {
        // Gently handle the user mistakenly calling OpenPopup() every frames: it is likely a programming mistake!
        // However, if we were to run the regular code path, the ui would become completely unusable because the popup will always be
        // in hidden-while-calculating-size state _while_ claiming focus. Which is extremely confusing situation for the programmer.
        // Instead, for successive frames calls to OpenPopup(), we silently avoid reopening even if ImGuiPopupFlags_NoReopen is not specified.
        keep_existing := false;
        if (g.OpenPopupStack[current_stack_size].PopupId == id) {
            if ((g.OpenPopupStack[current_stack_size].OpenFrameCount == g.FrameCount - 1) || (.NoReopen in popup_flags))   do keep_existing = true
        }
        if (keep_existing)
        {
            // No reopen
            g.OpenPopupStack[current_stack_size].OpenFrameCount = popup_ref.OpenFrameCount;
        }
        else
        {
            // Reopen: close child popups if any, then flag popup for open/reopen (set position, focus, init navigation)
            ClosePopupToLevel(current_stack_size, true);
            g.OpenPopupStack.append(popup_ref);
        }

        // When reopening a popup we first refocus its parent, otherwise if its parent is itself a popup it would get closed by ClosePopupsOverWindow().
        // This is equivalent to what ClosePopupToLevel() does.
        //if (g.OpenPopupStack[current_stack_size].PopupId == id)
        //    FocusWindow(parent_window);
    }
}

// When popups are stacked, clicking on a lower level popups puts focus back to it and close popups above it.
// This function closes any popups that are over 'ref_window'.
ClosePopupsOverWindow :: proc(ref_window : ^ImGuiWindow, restore_focus_to_window_under_popup : bool)
{
    g := GImGui;
    if (len(g.OpenPopupStack) == 0)   do return

    // Don't close our own child popup windows.
    //IMGUI_DEBUG_LOG_POPUP("[popup] ClosePopupsOverWindow(\"%s\") restore_under=%d\n", ref_window ? ref_window.Name : "<NULL>", restore_focus_to_window_under_popup);
    popup_count_to_keep := 0;
    if (ref_window)
    {
        // Find the highest popup which is a descendant of the reference window (generally reference window = NavWindow)
        for ; popup_count_to_keep < len(g.OpenPopupStack); popup_count_to_keep += 1
        {
            popup := &g.OpenPopupStack[popup_count_to_keep];
            if (!popup.Window)   do continue
            assert((.Popup in popup.Window.Flags) != 0);

            // Trim the stack unless the popup is a direct parent of the reference window (the reference window is often the NavWindow)
            // - Clicking/Focusing Window2 won't close Popup1:
            //     Window -> Popup1 -> Window2(Ref)
            // - Clicking/focusing Popup1 will close Popup2 and Popup3:
            //     Window -> Popup1(Ref) -> Popup2 -> Popup3
            // - Each popups may contain child windows, which is why we compare ->RootWindowDockTree!
            //     Window -> Popup1 -> Popup1_Child -> Popup2 -> Popup2_Child
            // We step through every popup from bottom to top to validate their position relative to reference window.
            ref_window_is_descendent_of_popup := false;
            for n := popup_count_to_keep; n < len(g.OpenPopupStack); n += 1 {
                if popup_window := g.OpenPopupStack[n].Window; popup_window != nil {
                    //if (popup_window.RootWindowDockTree == ref_window.RootWindowDockTree) // FIXME-MERGE
                    if (IsWindowWithinBeginStackOf(ref_window, popup_window))
                    {
                        ref_window_is_descendent_of_popup = true;
                        break;
                    }
                }
            }
            if (!ref_window_is_descendent_of_popup)   do break
        }
    }
    if (popup_count_to_keep < g.OpenPopupStack.Size) // This test is not required but it allows to set a convenient breakpoint on the statement below
    {
        IMGUI_DEBUG_LOG_POPUP("[popup] ClosePopupsOverWindow(\"%s\")\n", ref_window ? ref_window.Name : "<nil>");
        ClosePopupToLevel(popup_count_to_keep, restore_focus_to_window_under_popup);
    }
}

ClosePopupsExceptModals :: proc()
{
    g := GImGui;

    popup_count_to_keep : i32
    for popup_count_to_keep = len(g.OpenPopupStack); popup_count_to_keep > 0; popup_count_to_keep -= 1
    {
        window := g.OpenPopupStack[popup_count_to_keep - 1].Window;
        if (!window || (.Modal in window.Flags))   do break
    }
    if (popup_count_to_keep < g.OpenPopupStack.Size) { // This test is not required but it allows to set a convenient breakpoint on the statement below
        ClosePopupToLevel(popup_count_to_keep, true);
    }
}

ClosePopupToLevel :: proc(remaining : i32, restore_focus_to_window_under_popup : bool)
{
    g := GImGui;
    IMGUI_DEBUG_LOG_POPUP("[popup] ClosePopupToLevel(%d), restore_under=%d\n", remaining, restore_focus_to_window_under_popup);
    assert(remaining >= 0 && remaining < g.OpenPopupStack.Size);
    if (.EventPopup in g.DebugLogFlags) {
        for n := remaining; n < len(g.OpenPopupStack); n += 1 {
            IMGUI_DEBUG_LOG_POPUP("[popup] - Closing PopupID 0x%08X Window \"%s\"\n", g.OpenPopupStack[n].PopupId, g.OpenPopupStack[n].Window ? g.OpenPopupStack[n].Window.Name : nil);
        }
    }

    // Trim open popup stack
    prev_popup := g.OpenPopupStack[remaining];
    g.OpenPopupStack.resize(remaining);

    // Restore focus (unless popup window was not yet submitted, and didn't have a chance to take focus anyhow. See #7325 for an edge case)
    if (restore_focus_to_window_under_popup && prev_popup.Window)
    {
        popup_window := prev_popup.Window;
        focus_window := (.ChildMenu in popup_window.Flags) ? popup_window.ParentWindow : prev_popup.RestoreNavWindow;
        if (focus_window && !focus_window.WasActive) {
            FocusTopMostWindowUnderOne(popup_window, nil, nil, ImGuiFocusRequestFlags_RestoreFocusedChild); // Fallback
        }
        else {
            FocusWindow(focus_window, (g.NavLayer == ImGuiNavLayer_Main) ? ImGuiFocusRequestFlags_RestoreFocusedChild : ImGuiFocusRequestFlags_None);
        }
    }
}

// Close the popup we have begin-ed into.
// [forward declared comment]:
// manually close the popup we have begin-ed into.
CloseCurrentPopup :: proc()
{
    g := GImGui;
    popup_idx := len(g.BeginPopupStack) - 1;
    if (popup_idx < 0 || popup_idx >= len(g.OpenPopupStack) || g.BeginPopupStack[popup_idx].PopupId != g.OpenPopupStack[popup_idx].PopupId)   do return

    // Closing a menu closes its top-most parent popup (unless a modal)
    for (popup_idx > 0)
    {
        popup_window := g.OpenPopupStack[popup_idx].Window;
        parent_popup_window := g.OpenPopupStack[popup_idx - 1].Window;
        close_parent := false;
        if (popup_window && (.ChildMenu in popup_window.Flags)) {
            if (parent_popup_window && !(.MenuBar in parent_popup_window.Flags))   do close_parent = true
        }
        if (!close_parent)   do break
        popup_idx -= 1;
    }
    IMGUI_DEBUG_LOG_POPUP("[popup] CloseCurrentPopup %d -> %d\n", len(g.BeginPopupStack) - 1, popup_idx);
    ClosePopupToLevel(popup_idx, true);

    // A common pattern is to close a popup when selecting a menu item/selectable that will open another window.
    // To improve this usage pattern, we avoid nav highlight for a single frame in the parent window.
    // Similarly, we could avoid mouse hover highlight in this window but it is less visually problematic.
    if window := g.NavWindow; window != nil {
        window.DC.NavHideHighlightOneFrame = true;
    }
}

// Attention! BeginPopup() adds default flags when calling BeginPopupEx()!
BeginPopupEx :: proc(id : ImGuiID, extra_window_flags : ImGuiWindowFlags) -> bool
{
    g := GImGui;
    if (!IsPopupOpen(id, ImGuiPopupFlags_None))
    {
        g.NextWindowData.ClearFlags(); // We behave like Begin() and need to consume those values
        return false;
    }

    name : [20]u8;
    if (.ChildMenu in extra_window_flags) {
        ImFormatString(name, len(name), "##Menu_%02d", g.BeginMenuDepth); // Recycle windows based on depth
    }
    else {
        ImFormatString(name, len(name), "##Popup_%08x", id); // Not recycling, so we can close/open during the same frame
    }

    is_open := Begin(name, nil, extra_window_flags | ImGuiWindowFlags_Popup | ImGuiWindowFlags_NoDocking);
    if (!is_open) do EndPopup() // NB: Begin can return false when the popup is completely clipped (e.g. zero size display)

    //g.CurrentWindow.FocusRouteParentWindow = g.CurrentWindow.ParentWindowInBeginStack;

    return is_open;
}

// [forward declared comment]:
// return true if the popup is open, and you can start outputting to it.
BeginPopup :: proc(str_id : ^u8, flags : ImGuiWindowFlags = {}) -> bool
{
    g := GImGui;
    if (len(g.OpenPopupStack) <= g.BeginPopupStack.Size) // Early out for performance
    {
        g.NextWindowData.ClearFlags(); // We behave like Begin() and need to consume those values
        return false;
    }
    flags |= ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoSavedSettings;
    id := g.CurrentWindow.GetID(str_id);
    return BeginPopupEx(id, flags);
}

// If 'p_open' is specified for a modal popup window, the popup will have a regular close button which will close the popup.
// Note that popup visibility status is owned by Dear ImGui (and manipulated with e.g. OpenPopup).
// - *p_open set back to false in BeginPopupModal() when popup is not open.
// - if you set *p_open to false before calling BeginPopupModal(), it will close the popup.
// [forward declared comment]:
// return true if the modal is open, and you can start outputting to it.
BeginPopupModal :: proc(name : ^u8, p_open : ^bool = nil, flags : ImGuiWindowFlags = {}) -> bool
{
    g := GImGui;
    window := g.CurrentWindow;
    id := GetID(window, name);
    if (!IsPopupOpen(id, ImGuiPopupFlags_None))
    {
        g.NextWindowData.ClearFlags(); // We behave like Begin() and need to consume those values
        if (p_open != nil && p_open^)   do p_open^ = false
        return false;
    }

    // Center modal windows by default for increased visibility
    // (this won't really last as settings will kick in, and is mostly for backward compatibility. user may do the same themselves)
    // FIXME: Should test for (PosCond & window.SetWindowPosAllowFlags) with the upcoming window.
    if ((.HasPos not_in g.NextWindowData.Flags))
    {
        viewport := window.WasActive ? window.Viewport : GetMainViewport(); // FIXME-VIEWPORT: What may be our reference viewport?
        SetNextWindowPos(viewport.GetCenter(), ImGuiCond_FirstUseEver, ImVec2{0.5, 0.5});
    }

    flags |= ImGuiWindowFlags_Popup | ImGuiWindowFlags_Modal | ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_NoDocking;
    is_open := Begin(name, p_open, flags);
    if (!is_open || (p_open != nil && !p_open^)) // NB: is_open can be 'false' when the popup is completely clipped (e.g. zero size display)
    {
        EndPopup();
        if (is_open) {
            ClosePopupToLevel(g.BeginPopupStack.Size, true);
        }
        return false;
    }
    return is_open;
}

// [forward declared comment]:
// only call EndPopup() if BeginPopupXXX() returns true!
EndPopup :: proc()
{
    g := GImGui;
    window := g.CurrentWindow;
    assert(.Popup in window.Flags);  // Mismatched BeginPopup()/EndPopup() calls
    assert(len(g.BeginPopupStack) > 0);

    // Make all menus and popups wrap around for now, may need to expose that policy (e.g. focus scope could include wrap/loop policy flags used by new move requests)
    if (g.NavWindow == window) {
        NavMoveRequestTryWrapping(window, ImGuiNavMoveFlags_LoopY);
    }

    // Child-popups don't need to be laid out
    backup_within_end_child_id := g.WithinEndChildID;
    if (.ChildWindow in window.Flags) {
        g.WithinEndChildID = window.ID;
    }
    End();
    g.WithinEndChildID = backup_within_end_child_id;
}

// Helper to open a popup if mouse button is released over the item
// - This is essentially the same as BeginPopupContextItem() but without the trailing BeginPopup()
// [forward declared comment]:
// helper to open popup when clicked on last item. Default to ImGuiPopupFlags_MouseButtonRight == 1. (note: actually triggers on the mouse _released_ event to be consistent with popup behaviors)
OpenPopupOnItemClick :: proc(str_id : ^u8 = nil, popup_flags : ImGuiPopupFlags = 1)
{
    g := GImGui;
    window := g.CurrentWindow;
    mouse_button := (popup_flags & ImGuiPopupFlags_MouseButtonMask_);
    if (IsMouseReleased(mouse_button) && IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByPopup))
    {
        id := str_id ? GetID(window, str_id) : g.LastItemData.ID;    // If user hasn't passed an ID, we can use the LastItemID. Using LastItemID as a Popup ID won't conflict!
        assert(id != 0);                                             // You cannot pass a NULL str_id if the last item has no identifier (e.g. a Text() item)
        OpenPopupEx(id, popup_flags);
    }
}

// This is a helper to handle the simplest case of associating one named popup to one given widget.
// - To create a popup associated to the last item, you generally want to pass a NULL value to str_id.
// - To create a popup with a specific identifier, pass it in str_id.
//    - This is useful when using using BeginPopupContextItem() on an item which doesn't have an identifier, e.g. a Text() call.
//    - This is useful when multiple code locations may want to manipulate/open the same popup, given an explicit id.
// - You may want to handle the whole on user side if you have specific needs (e.g. tweaking IsItemHovered() parameters).
//   This is essentially the same as:
//       id = str_id ? GetID(str_id) : GetItemID();
//       OpenPopupOnItemClick(str_id, ImGuiPopupFlags_MouseButtonRight);
//       return BeginPopup(id);
//   Which is essentially the same as:
//       id = str_id ? GetID(str_id) : GetItemID();
//       if (IsItemHovered() && IsMouseReleased(ImGuiMouseButton_Right))
//           OpenPopup(id);
//       return BeginPopup(id);
//   The main difference being that this is tweaked to avoid computing the ID twice.
// [forward declared comment]:
// open+begin popup when clicked on last item. Use str_id==NULL to associate the popup to previous item. If you want to use that on a non-interactive item such as Text() you need to pass in an explicit ID here. read comments in .cpp!
BeginPopupContextItem :: proc(str_id : ^u8 = nil, popup_flags : ImGuiPopupFlags = 1) -> bool
{
    g := GImGui;
    window := g.CurrentWindow;
    if (window.SkipItems)   do return false
    id := str_id ? GetID(window, str_id) : g.LastItemData.ID;    // If user hasn't passed an ID, we can use the LastItemID. Using LastItemID as a Popup ID won't conflict!
    assert(id != 0);                                             // You cannot pass a NULL str_id if the last item has no identifier (e.g. a Text() item)
    mouse_button := (popup_flags & ImGuiPopupFlags_MouseButtonMask_);
    if (IsMouseReleased(mouse_button) && IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByPopup)) {
        OpenPopupEx(id, popup_flags);
    }
    return BeginPopupEx(id, ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoSavedSettings);
}

// [forward declared comment]:
// open+begin popup when clicked on current window.
BeginPopupContextWindow :: proc(str_id : ^u8 = nil, popup_flags : ImGuiPopupFlags = 1) -> bool
{
    g := GImGui;
    window := g.CurrentWindow;
    if (!str_id)   do str_id = "window_context"
    id := GetID(window, str_id);
    mouse_button := (popup_flags & ImGuiPopupFlags_MouseButtonMask_);
    if (IsMouseReleased(mouse_button) && IsWindowHovered(ImGuiHoveredFlags_AllowWhenBlockedByPopup)) {
        if (!(.NoOpenOverItems in popup_flags) || !IsAnyItemHovered()) {
            OpenPopupEx(id, popup_flags);
        }
    }
    return BeginPopupEx(id, ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoSavedSettings);
}

// [forward declared comment]:
// open+begin popup when clicked in void (where there are no windows).
BeginPopupContextVoid :: proc(str_id : ^u8 = nil, popup_flags : ImGuiPopupFlags = 1) -> bool
{
    g := GImGui;
    window := g.CurrentWindow;
    if (!str_id)   do str_id = "void_context"
    id := GetID(window, str_id);
    mouse_button := (popup_flags & ImGuiPopupFlags_MouseButtonMask_);
    if (IsMouseReleased(mouse_button) && !IsWindowHovered(ImGuiHoveredFlags_AnyWindow)) {
        if (GetTopMostPopupModal() == nil) {
            OpenPopupEx(id, popup_flags);
        }
    }
    return BeginPopupEx(id, ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoSavedSettings);
}

// r_avoid = the rectangle to avoid (e.g. for tooltip it is a rectangle around the mouse cursor which we want to avoid. for popups it's a small point around the cursor.)
// r_outer = the visible area rectangle, minus safe area padding. If our popup size won't fit because of safe area padding we ignore it.
// (r_outer is usually equivalent to the viewport rectangle minus padding, but when multi-viewports are enabled and monitor
//  information are available, it may represent the entire platform monitor from the frame of reference of the current viewport.
//  this allows us to have tooltips/popups displayed out of the parent viewport.)
FindBestWindowPosForPopupEx :: proc(ref_pos : ImVec2, size : ImVec2, last_dir : ^ImGuiDir, r_outer : ^ImRect, r_avoid : ^ImRect, policy : ImGuiPopupPositionPolicy) -> ImVec2
{
    base_pos_clamped := ImClamp(ref_pos, r_outer.Min, r_outer.Max - size);
    //AddRect(GetForegroundDrawList(), r_avoid.Min, r_avoid.Max, IM_COL32(255,0,0,255));
    //AddRect(GetForegroundDrawList(), r_outer.Min, r_outer.Max, IM_COL32(0,255,0,255));

    // Combo Box policy (we want a connecting edge)
    if (policy == ImGuiPopupPositionPolicy_ComboBox)
    {
        dir_prefered_order : [ImGuiDir.COUNT]ImGuiDir = { ImGuiDir.Down, .Right, .Left, ImGuiDir.Up };
        for n := (last_dir^ != nil) ? -1 : 0; n < ImGuiDir.COUNT; n += 1
        {
            dir := (n == -1) ? last_dir^ : dir_prefered_order[n];
            if (n != -1 && dir == last_dir^)  {// Already tried this direction?
                continue;
            }
            pos : ImVec2
            if (dir == ImGuiDir.Down)  do pos = ImVec2{r_avoid.Min.x, r_avoid.Max.y};          // Below, Toward Right (default)
            if (dir == .Right) do pos = ImVec2{r_avoid.Min.x, r_avoid.Min.y - size.y}; // Above, Toward Right
            if (dir == .Left)  do pos = ImVec2{r_avoid.Max.x - size.x, r_avoid.Max.y}; // Below, Toward Left
            if (dir == ImGuiDir.Up)    do pos = ImVec2{r_avoid.Max.x - size.x, r_avoid.Min.y - size.y}; // Above, Toward Left
            if (!r_outer.Contains(ImRect{ _v = {pos, pos + size}}))   do continue
            last_dir^ = dir;
            return pos;
        }
    }

    // Tooltip and Default popup policy
    // (Always first try the direction we used on the last frame, if any)
    if (policy == ImGuiPopupPositionPolicy_Tooltip || policy == ImGuiPopupPositionPolicy_Default)
    {
        dir_prefered_order : [ImGuiDir.COUNT]ImGuiDir = { .Right, ImGuiDir.Down, ImGuiDir.Up, .Left };
        for n := (last_dir^ != nil) ? -1 : 0; n < ImGuiDir.COUNT; n += 1
        {
            dir := (n == -1) ? last_dir^ : dir_prefered_order[n];
            if (n != -1 && dir == last_dir^)  {// Already tried this direction?
                continue;
            }

            avail_w := (dir == .Left ? r_avoid.Min.x : r_outer.Max.x) - (dir == .Right ? r_avoid.Max.x : r_outer.Min.x);
            avail_h := (dir == ImGuiDir.Up ? r_avoid.Min.y : r_outer.Max.y) - (dir == ImGuiDir.Down ? r_avoid.Max.y : r_outer.Min.y);

            // If there's not enough room on one axis, there's no point in positioning on a side on this axis (e.g. when not enough width, use a top/bottom position to maximize available width)
            if (avail_w < size.x && (dir == .Left || dir == .Right))   do continue
            if (avail_h < size.y && (dir == ImGuiDir.Up || dir == ImGuiDir.Down))   do continue

            pos : ImVec2
            pos.x = (dir == .Left) ? r_avoid.Min.x - size.x : (dir == .Right) ? r_avoid.Max.x : base_pos_clamped.x;
            pos.y = (dir == ImGuiDir.Up) ? r_avoid.Min.y - size.y : (dir == ImGuiDir.Down) ? r_avoid.Max.y : base_pos_clamped.y;

            // Clamp top-left corner of popup
            pos.x = ImMax(pos.x, r_outer.Min.x);
            pos.y = ImMax(pos.y, r_outer.Min.y);

            last_dir^ = dir;
            return pos;
        }
    }

    // Fallback when not enough room:
    last_dir^ = nil;

    // For tooltip we prefer avoiding the cursor at all cost even if it means that part of the tooltip won't be visible.
    if (policy == ImGuiPopupPositionPolicy_Tooltip)   do return ref_pos + ImVec2{2, 2}

    // Otherwise try to keep within display
    pos := ref_pos;
    pos.x = ImMax(ImMin(pos.x + size.x, r_outer.Max.x) - size.x, r_outer.Min.x);
    pos.y = ImMax(ImMin(pos.y + size.y, r_outer.Max.y) - size.y, r_outer.Min.y);
    return pos;
}

// Note that this is used for popups, which can overlap the non work-area of individual viewports.
GetPopupAllowedExtentRect :: proc(window : ^ImGuiWindow) -> ImRect
{
    g := GImGui;
    r_screen : ImRect
    if (window.ViewportAllowPlatformMonitorExtend >= 0)
    {
        // Extent with be in the frame of reference of the given viewport (so Min is likely to be negative here)
        monitor := &g.PlatformIO.Monitors[window.ViewportAllowPlatformMonitorExtend];
        r_screen.Min = monitor.WorkPos;
        r_screen.Max = monitor.WorkPos + monitor.WorkSize;
    }
    else
    {
        // Use the full viewport area (not work area) for popups
        r_screen = GetMainRect(window.Viewport);
    }
    padding := g.Style.DisplaySafeAreaPadding;
    r_screen.Expand(ImVec2{(r_screen.GetWidth() > padding.x * 2) ? -padding.x : 0.0, (r_screen.GetHeight() > padding.y * 2) ? -padding.y : 0.0});
    return r_screen;
}

FindBestWindowPosForPopup :: proc(window : ^ImGuiWindow) -> ImVec2
{
    g := GImGui;

    r_outer := GetPopupAllowedExtentRect(window);
    if (.ChildMenu in window.Flags)
    {
        // Child menus typically request _any_ position within the parent menu item, and then we move the new menu outside the parent bounds.
        // This is how we end up with child menus appearing (most-commonly) on the right of the parent menu.
        parent_window := window.ParentWindow;
        horizontal_overlap := g.Style.ItemInnerSpacing.x; // We want some overlap to convey the relative depth of each menu (currently the amount of overlap is hard-coded to style.ItemSpacing.x).
        r_avoid : ImRect
        if (parent_window.DC.MenuBarAppending) {
            r_avoid = ImRect{ _r = {-math.F32_MAX, parent_window.ClipRect.Min.y, math.F32_MAX, parent_window.ClipRect.Max.y}}; // Avoid parent menu-bar. If we wanted multi-line menu-bar, we may instead want to have the calling window setup e.g. a NextWindowData.PosConstraintAvoidRect field
        }
        else {
            r_avoid = ImRect{ _r = {parent_window.Pos.x + horizontal_overlap, -math.F32_MAX, parent_window.Pos.x + parent_window.Size.x - horizontal_overlap - parent_window.ScrollbarSizes.x, math.F32_MAX}};
        }
        return FindBestWindowPosForPopupEx(window.Pos, window.Size, &window.AutoPosLastDirection, r_outer, r_avoid, ImGuiPopupPositionPolicy_Default);
    }
    if (.Popup in window.Flags)
    {
        return FindBestWindowPosForPopupEx(window.Pos, window.Size, &window.AutoPosLastDirection, r_outer, ImRect{ _v = {window.Pos, window.Pos}}, ImGuiPopupPositionPolicy_Default); // Ideally we'd disable r_avoid here
    }
    if (.Tooltip in window.Flags)
    {
        // Position tooltip (always follows mouse + clamp within outer boundaries)
        // FIXME:
        // - Too many paths. One problem is that FindBestWindowPosForPopupEx() doesn't allow passing a suggested position (so touch screen path doesn't use it by default).
        // - Drag and drop tooltips are not using this path either: BeginTooltipEx() manually sets their position.
        // - Require some tidying up. In theory we could handle both cases in same location, but requires a bit of shuffling
        //   as drag and drop tooltips are calling SetNextWindowPos() leading to 'window_pos_set_by_api' being set in Begin().
        assert(g.CurrentWindow == window);
        scale := g.Style.MouseCursorScale;
        ref_pos := NavCalcPreferredRefPos();

        if (g.IO.MouseSource == ImGuiMouseSource_TouchScreen && NavCalcPreferredRefPosSource() == .Mouse)
        {
            tooltip_pos := ref_pos + TOOLTIP_DEFAULT_OFFSET_TOUCH * scale - (TOOLTIP_DEFAULT_PIVOT_TOUCH * window.Size);
            if (r_outer.Contains(ImRect{ _v = {tooltip_pos, tooltip_pos + window.Size}}))   do return tooltip_pos
        }

        tooltip_pos := ref_pos + TOOLTIP_DEFAULT_OFFSET_MOUSE * scale;
        r_avoid : ImRect
        if (g.NavCursorVisible && g.NavHighlightItemUnderNav && !g.IO.ConfigNavMoveSetMousePos) {
            r_avoid = ImRect{ _r = {ref_pos.x - 16, ref_pos.y - 8, ref_pos.x + 16, ref_pos.y + 8}};
        }
        else {
            r_avoid = ImRect{ _r = {ref_pos.x - 16, ref_pos.y - 8, ref_pos.x + 24 * scale, ref_pos.y + 24 * scale}}; // FIXME: Hard-coded based on mouse cursor shape expectation. Exact dimension not very important.
        }
        //AddRect(GetForegroundDrawList(), r_avoid.Min, r_avoid.Max, IM_COL32(255, 0, 255, 255));

        return FindBestWindowPosForPopupEx(tooltip_pos, window.Size, &window.AutoPosLastDirection, r_outer, r_avoid, ImGuiPopupPositionPolicy_Tooltip);
    }
    assert(false)
    return window.Pos;
}

//-----------------------------------------------------------------------------
// [SECTION] WINDOW FOCUS
//----------------------------------------------------------------------------
// - SetWindowFocus()
// - SetNextWindowFocus()
// - IsWindowFocused()
// - UpdateWindowInFocusOrderList() [Internal]
// - BringWindowToFocusFront() [Internal]
// - BringWindowToDisplayFront() [Internal]
// - BringWindowToDisplayBack() [Internal]
// - BringWindowToDisplayBehind() [Internal]
// - FindWindowDisplayIndex() [Internal]
// - FocusWindow() [Internal]
// - FocusTopMostWindowUnderOne() [Internal]
//-----------------------------------------------------------------------------

// [forward declared comment]:
// set named window to be focused / top-most. use NULL to remove focus.
SetWindowFocus :: proc()
{
    FocusWindow(GImGui.CurrentWindow);
}

// [forward declared comment]:
// set named window to be focused / top-most. use NULL to remove focus.
SetWindowFocus :: proc(name : ^u8)
{
    if (name)
    {
        if window := FindWindowByName(name); window != nil   do FocusWindow(window)
    }
    else
    {
        FocusWindow(nil);
    }
}

// [forward declared comment]:
// set next window to be focused / top-most. call before Begin()
SetNextWindowFocus :: proc()
{
    g := GImGui;
    g.NextWindowData.Flags |= ImGuiNextWindowDataFlags_HasFocus;
}

// Similar to IsWindowHovered()
// [forward declared comment]:
// is current window focused? or its root/child, depending on flags. see flags for options.
IsWindowFocused :: proc(flags : ImGuiFocusedFlags) -> bool
{
    g := GImGui;
    ref_window := g.NavWindow;
    cur_window := g.CurrentWindow;

    if (ref_window == nil)   do return false
    if (.AnyWindow in flags)   do return true

    assert(cur_window); // Not inside a Begin()/End()
    popup_hierarchy := (.NoPopupHierarchy not_in flags);
    dock_hierarchy := (.DockHierarchy in flags)
    if (.RootWindow in flags) {
        cur_window = GetCombinedRootWindow(cur_window, popup_hierarchy, dock_hierarchy);
    }

    if (.ChildWindows in flags) {
        return IsWindowChildOf(ref_window, cur_window, popup_hierarchy, dock_hierarchy);
    }
    else {
        return (ref_window == cur_window);
    }
}

FindWindowFocusIndex :: proc(window : ^ImGuiWindow) -> i32
{
    g := GImGui;
    _ = g;
    order := window.FocusOrder;
    assert(window.RootWindow == window); // No child window (not testing _ChildWindow because of docking)
    assert(g.WindowsFocusOrder[order] == window);
    return order;
}

UpdateWindowInFocusOrderList :: proc(window : ^ImGuiWindow, just_created : bool, new_flags : ImGuiWindowFlags)
{
    g := GImGui;

    new_is_explicit_child := (.ChildWindow in new_flags) != 0 && ((.Popup not_in new_flags) || (.ChildMenu in new_flags) != 0);
    child_flag_changed := new_is_explicit_child != window.IsExplicitChild;
    if ((just_created || child_flag_changed) && !new_is_explicit_child)
    {
        assert(!g.WindowsFocusOrder.contains(window));
        g.WindowsFocusOrder.append(window);
        window.FocusOrder = (short)(len(g.WindowsFocusOrder) - 1);
    }
    else if (!just_created && child_flag_changed && new_is_explicit_child)
    {
        assert(g.WindowsFocusOrder[window.FocusOrder] == window);
        for n := window.FocusOrder + 1; n < len(g.WindowsFocusOrder); n += 1 {
            g.WindowsFocusOrder[n]->FocusOrder -= 1;
        }
        g.WindowsFocusOrder.erase(g.WindowsFocusOrder.Data + window.FocusOrder);
        window.FocusOrder = -1;
    }
    window.IsExplicitChild = new_is_explicit_child;
}

BringWindowToFocusFront :: proc(window : ^ImGuiWindow)
{
    g := GImGui;
    assert(window == window.RootWindow);

    cur_order := window.FocusOrder;
    assert(g.WindowsFocusOrder[cur_order] == window);
    if (g.WindowsFocusOrder.back() == window)   do return

    new_order := len(g.WindowsFocusOrder) - 1;
    for n := cur_order; n < new_order; n += 1
    {
        g.WindowsFocusOrder[n] = g.WindowsFocusOrder[n + 1];
        g.WindowsFocusOrder[n]->FocusOrder -= 1;
        assert(g.WindowsFocusOrder[n]->FocusOrder == n);
    }
    g.WindowsFocusOrder[new_order] = window;
    window.FocusOrder = cast(i16)new_order;
}

// Note technically focus related but rather adjacent and close to BringWindowToFocusFront()
BringWindowToDisplayFront :: proc(window : ^ImGuiWindow)
{
    g := GImGui;
    current_front_window := g.Windows.back();
    if (current_front_window == window || current_front_window.RootWindowDockTree == window) do return // Cheap early out (could be better)
    for i := len(g.Windows) - 2; i >= 0; i -= 1 {// We can ignore the top-most window
        if (g.Windows[i] == window)
        {
            memmove(&g.Windows[i], &g.Windows[i + 1], cast(int)(len(g.Windows) - i - 1) * size_of(^ImGuiWindow));
            g.Windows[len(g.Windows) - 1] = window;
            break;
        }
    }
}

BringWindowToDisplayBack :: proc(window : ^ImGuiWindow)
{
    g := GImGui;
    if (g.Windows[0] == window)   do return
    for i := 0; i < len(g.Windows); i += 1 {
        if (g.Windows[i] == window)
        {
            memmove(&g.Windows[1], &g.Windows[0], cast(int) i * size_of(^ImGuiWindow));
            g.Windows[0] = window;
            break;
        }
    }
}

BringWindowToDisplayBehind :: proc(window : ^ImGuiWindow, behind_window : ^ImGuiWindow)
{
    assert(window != nil && behind_window != nil);
    g := GImGui;
    window = window.RootWindow;
    behind_window = behind_window.RootWindow;
    pos_wnd := FindWindowDisplayIndex(window);
    pos_beh := FindWindowDisplayIndex(behind_window);
    if (pos_wnd < pos_beh)
    {
        copy_bytes := (pos_beh - pos_wnd - 1) * size_of(^ImGuiWindow);
        memmove(&g.Windows.Data[pos_wnd], &g.Windows.Data[pos_wnd + 1], copy_bytes);
        g.Windows[pos_beh - 1] = window;
    }
    else
    {
        copy_bytes := (pos_wnd - pos_beh) * size_of(^ImGuiWindow);
        memmove(&g.Windows.Data[pos_beh + 1], &g.Windows.Data[pos_beh], copy_bytes);
        g.Windows[pos_beh] = window;
    }
}

FindWindowDisplayIndex :: proc(window : ^ImGuiWindow) -> i32
{
    g := GImGui;
    return g.Windows.index_from_ptr(g.Windows.find(window));
}

// Moving window to front of display and set focus (which happens to be back of our sorted list)
FocusWindow :: proc(window : ^ImGuiWindow, flags : ImGuiFocusRequestFlags = {})
{
    g := GImGui;

    // Modal check?
    if ((.UnlessBelowModal in flags) && (g.NavWindow != window)) {// Early out in common case.
        if blocking_modal = FindBlockingModal(window); blocking_modal != nil
        {
            // This block would typically be reached in two situations:
            // - API call to FocusWindow() with a window under a modal and ImGuiFocusRequestFlags_UnlessBelowModal flag.
            // - User clicking on void or anything behind a modal while a modal is open (window == NULL)
            IMGUI_DEBUG_LOG_FOCUS("[focus] FocusWindow(\"%s\", UnlessBelowModal): prevented by \"%s\".\n", window ? window.Name : "<nil>", blocking_modal.Name);
            if (window && window == window.RootWindow && (.NoBringToFrontOnFocus not_in window.Flags)) {
                BringWindowToDisplayBehind(window, blocking_modal); // Still bring right under modal. (FIXME: Could move in focus list too?)
            }

            ClosePopupsOverWindow(GetTopMostPopupModal(), false); // Note how we need to use GetTopMostPopupModal() aad NOT blocking_modal, to handle nested modals
            return;
        }
    }

    // Find last focused child (if any) and focus it instead.
    if ((.RestoreFocusedChild in flags) && window != nil) {
        window = NavRestoreLastChildNavWindow(window);
    }

    // Apply focus
    if (g.NavWindow != window)
    {
        SetNavWindow(window);
        if (window && g.NavHighlightItemUnderNav)   do g.NavMousePosDirty = true
        g.NavId = window ? window.NavLastIds[0] : 0; // Restore NavId
        g.NavLayer = ImGuiNavLayer_Main;
        SetNavFocusScope(window ? window.NavRootFocusScopeId : 0);
        g.NavIdIsAlive = false;
        g.NavLastValidSelectionUserData = ImGuiSelectionUserData_Invalid;

        // Close popups if any
        ClosePopupsOverWindow(window, false);
    }

    // Move the root window to the top of the pile
    assert(window == nil || window.RootWindowDockTree != nil);
    focus_front_window := window ? window.RootWindow : nil;
    display_front_window := window ? window.RootWindowDockTree : nil;
    dock_node := window ? window.DockNode : nil;
    active_id_window_is_dock_node_host := (g.ActiveIdWindow && dock_node && dock_node.HostWindow == g.ActiveIdWindow);

    // Steal active widgets. Some of the cases it triggers includes:
    // - Focus a window while an InputText in another window is active, if focus happens before the old InputText can run.
    // - When using Nav to activate menu items (due to timing of activating on press.new window appears.losing ActiveId)
    // - Using dock host items (tab, collapse button) can trigger this before we redirect the ActiveIdWindow toward the child window.
    if (g.ActiveId != 0 && g.ActiveIdWindow && g.ActiveIdWindow.RootWindow != focus_front_window) {
        if (!g.ActiveIdNoClearOnFocusLoss && !active_id_window_is_dock_node_host)   do ClearActiveID()
    }

    // Passing NULL allow to disable keyboard focus
    if (!window)   do return
    window.LastFrameJustFocused = g.FrameCount;

    // Select in dock node
    // For #2304 we avoid applying focus immediately before the tabbar is visible.
    //if (dock_node && dock_node.TabBar)
    //    dock_node.TabBar.SelectedTabId = dock_node.TabBar.NextSelectedTabId = window.TabId;

    // Bring to front
    BringWindowToFocusFront(focus_front_window);
    if (((window.Flags | focus_front_window.Flags | display_front_window.Flags) & ImGuiWindowFlags_NoBringToFrontOnFocus) == 0) {
        BringWindowToDisplayFront(display_front_window);
    }
}

FocusTopMostWindowUnderOne :: proc(under_this_window : ^ImGuiWindow, ignore_window : ^ImGuiWindow, filter_viewport : ^ImGuiViewport, flags : ImGuiFocusRequestFlags)
{
    g := GImGui;
    start_idx := len(g.WindowsFocusOrder) - 1;
    if (under_this_window != nil)
    {
        // Aim at root window behind us, if we are in a child window that's our own root (see #4640)
        offset := -1;
        for (.ChildWindow in under_this_window.Flags)
        {
            under_this_window = under_this_window.ParentWindow;
            offset = 0;
        }
        start_idx = FindWindowFocusIndex(under_this_window) + offset;
    }
    for i := start_idx; i >= 0; i -= 1
    {
        // We may later decide to test for different NoXXXInputs based on the active navigation input (mouse vs nav) but that may feel more confusing to the user.
        window := g.WindowsFocusOrder[i];
        if (window == ignore_window || !window.WasActive)   do continue
        if (filter_viewport != nil && window.Viewport != filter_viewport)   do continue
        if ((window.Flags & (ImGuiWindowFlags_NoMouseInputs | ImGuiWindowFlags_NoNavInputs)) != (ImGuiWindowFlags_NoMouseInputs | ImGuiWindowFlags_NoNavInputs))
        {
            // FIXME-DOCK: When ImGuiFocusRequestFlags_RestoreFocusedChild is set...
            // This is failing (lagging by one frame) for docked windows.
            // If A and B are docked into window and B disappear, at the NewFrame() call site window.NavLastChildNavWindow will still point to B.
            // We might leverage the tab order implicitly stored in window.DockNodeAsHost.TabBar (essentially the 'most_recently_selected_tab' code in tab bar will do that but on next update)
            // to tell which is the "previous" window. Or we may leverage 'LastFrameFocused/LastFrameJustFocused' and have this function handle child window itself?
            FocusWindow(window, flags);
            return;
        }
    }
    FocusWindow(nil, flags);
}

//-----------------------------------------------------------------------------
// [SECTION] KEYBOARD/GAMEPAD NAVIGATION
//-----------------------------------------------------------------------------

// FIXME-NAV: The existence of SetNavID vs SetFocusID vs FocusWindow() needs to be clarified/reworked.
// In our terminology those should be interchangeable, yet right now this is super confusing.
// Those two functions are merely a legacy artifact, so at minimum naming should be clarified.

// [forward declared comment]:
// alter visibility of keyboard/gamepad cursor. by case: show when using an arrow key, hide when clicking with mouse.
SetNavCursorVisible :: proc(visible : bool)
{
    g := GImGui;
    if (g.IO.ConfigNavCursorVisibleAlways)   do visible = true
    g.NavCursorVisible = visible;
}

// (was called NavRestoreHighlightAfterMove() before 1.91.4)
SetNavCursorVisibleAfterMove :: proc()
{
    g := GImGui;
    if (g.IO.ConfigNavCursorVisibleAuto)   do g.NavCursorVisible = true
    g.NavMousePosDirty = true;
    g.NavHighlightItemUnderNav = true
}

SetNavWindow :: proc(window : ^ImGuiWindow)
{
    g := GImGui;
    if (g.NavWindow != window)
    {
        IMGUI_DEBUG_LOG_FOCUS("[focus] SetNavWindow(\"%s\")\n", window ? window.Name : "<nil>");
        g.NavWindow = window;
        g.NavLastValidSelectionUserData = ImGuiSelectionUserData_Invalid;
    }
    g.NavMoveScoringItems = false;
    g.NavMoveSubmitted = false
    g.NavInitRequest = false
    NavUpdateAnyRequestFlag();
}

NavHighlightActivated :: proc(id : ImGuiID)
{
    g := GImGui;
    g.NavHighlightActivatedId = id;
    g.NavHighlightActivatedTimer = NAV_ACTIVATE_HIGHLIGHT_TIMER;
}

NavClearPreferredPosForAxis :: proc(axis : ImGuiAxis)
{
    g := GImGui;
    g.NavWindow.RootWindowForNav.NavPreferredScoringPosRel[g.NavLayer][axis] = math.F32_MAX;
}

SetNavID :: proc(id : ImGuiID, nav_layer : ImGuiNavLayer, focus_scope_id : ImGuiID, rect_rel : ^ImRect)
{
    g := GImGui;
    assert(g.NavWindow != nil);
    assert(nav_layer == ImGuiNavLayer_Main || nav_layer == ImGuiNavLayer_Menu);
    g.NavId = id;
    g.NavLayer = nav_layer;
    SetNavFocusScope(focus_scope_id);
    g.NavWindow.NavLastIds[nav_layer] = id;
    g.NavWindow.NavRectRel[nav_layer] = rect_rel;

    // Clear preferred scoring position (NavMoveRequestApplyResult() will tend to restore it)
    NavClearPreferredPosForAxis(ImGuiAxis.X);
    NavClearPreferredPosForAxis(ImGuiAxis.Y);
}

SetFocusID :: proc(id : ImGuiID, window : ^ImGuiWindow)
{
    g := GImGui;
    assert(id != 0);

    if (g.NavWindow != window)   do SetNavWindow(window)

    // Assume that SetFocusID() is called in the context where its window.DC.NavLayerCurrent and g.CurrentFocusScopeId are valid.
    // Note that window may be != g.CurrentWindow (e.g. SetFocusID call in InputTextEx for multi-line text)
    nav_layer := window.DC.NavLayerCurrent;
    g.NavId = id;
    g.NavLayer = nav_layer;
    SetNavFocusScope(g.CurrentFocusScopeId);
    window.NavLastIds[nav_layer] = id;
    if (g.LastItemData.ID == id) {
        window.NavRectRel[nav_layer] = WindowRectAbsToRel(window, g.LastItemData.NavRect);
    }

    if (g.ActiveIdSource == .Keyboard || g.ActiveIdSource == .Gamepad) {
        g.NavHighlightItemUnderNav = true;
    }
    else if (g.IO.ConfigNavCursorVisibleAuto) {
        g.NavCursorVisible = false;
    }

    // Clear preferred scoring position (NavMoveRequestApplyResult() will tend to restore it)
    NavClearPreferredPosForAxis(ImGuiAxis.X);
    NavClearPreferredPosForAxis(ImGuiAxis.Y);
}

ImGetDirQuadrantFromDelta :: proc(dx : f32, dy : f32) -> ImGuiDir
{
    if (ImAbs(dx) > ImAbs(dy)) {
        return (dx > 0.0) ? .Right : .Left;
    }
    return (dy > 0.0) ? ImGuiDir.Down : ImGuiDir.Up;
}

NavScoreItemDistInterval :: #force_inline proc(cand_min, cand_max, curr_min, curr_max : f32) -> f32
{
    if (cand_max < curr_min)   do return cand_max - curr_min
    if (curr_max < cand_min)   do return cand_min - curr_max
    return 0.0;
}

// Scoring function for keyboard/gamepad directional navigation. Based on https://gist.github.com/rygorous/6981057
NavScoreItem :: proc(result : ^ImGuiNavItemData) -> bool
{
    g := GImGui;
    window := g.CurrentWindow;
    if (g.NavLayer != window.DC.NavLayerCurrent)   do return false

    // FIXME: Those are not good variables names
    cand := g.LastItemData.NavRect;   // Current item nav rectangle
    curr := g.NavScoringRect;   // Current modified source rect (NB: we've applied Max.x = Min.x in NavUpdate() to inhibit the effect of having varied item width)
    g.NavScoringDebugCount += 1;

    // When entering through a NavFlattened border, we consider child window items as fully clipped for scoring
    if (window.ParentWindow == g.NavWindow)
    {
        assert((window.ChildFlags | g.NavWindow.ChildFlags) & ImGuiChildFlags_NavFlattened);
        if (!window.ClipRect.Overlaps(cand))   do return false
        cand.ClipWithFull(window.ClipRect); // This allows the scored item to not overlap other candidates in the parent window
    }

    // Compute distance between boxes
    // FIXME-NAV: Introducing biases for vertical navigation, needs to be removed.
    dbx := NavScoreItemDistInterval(cand.Min.x, cand.Max.x, curr.Min.x, curr.Max.x);
    dby := NavScoreItemDistInterval(ImLerp(cand.Min.y, cand.Max.y, 0.2), ImLerp(cand.Min.y, cand.Max.y, 0.8), ImLerp(curr.Min.y, curr.Max.y, 0.2), ImLerp(curr.Min.y, curr.Max.y, 0.8)); // Scale down on Y to keep using box-distance for vertically touching items
    if (dby != 0.0 && dbx != 0.0) {
        dbx = (dbx / 1000.0) + ((dbx > 0.0) ? +1.0 : -1.0);
    }
    dist_box := ImAbs(dbx) + ImAbs(dby);

    // Compute distance between centers (this is off by a factor of 2, but we only compare center distances with each other so it doesn't matter)
    dcx := (cand.Min.x + cand.Max.x) - (curr.Min.x + curr.Max.x);
    dcy := (cand.Min.y + cand.Max.y) - (curr.Min.y + curr.Max.y);
    dist_center := ImAbs(dcx) + ImAbs(dcy); // L1 metric (need this for our connectedness guarantee)

    // Determine which quadrant of 'curr' our candidate item 'cand' lies in based on distance
    quadrant : ImGuiDir
    dax := 0.0; day := 0.0; dist_axial := 0.0;
    if (dbx != 0.0 || dby != 0.0)
    {
        // For non-overlapping boxes, use distance between boxes
        // FIXME-NAV: Quadrant may be incorrect because of (1) dbx bias and (2) curr.Max.y bias applied by NavBiasScoringRect() where typically curr.Max.y==curr.Min.y
        // One typical case where this happens, with style.WindowMenuButtonPosition == .Right, pressing Left to navigate from Close to Collapse tends to fail.
        // Also see #6344. Calling ImGetDirQuadrantFromDelta() with unbiased values may be good but side-effects are plenty.
        dax = dbx;
        day = dby;
        dist_axial = dist_box;
        quadrant = ImGetDirQuadrantFromDelta(dbx, dby);
    }
    else if (dcx != 0.0 || dcy != 0.0)    
    {
        // For overlapping boxes with different centers, use distance between centers
        dax = dcx;
        day = dcy;
        dist_axial = dist_center;
        quadrant = ImGetDirQuadrantFromDelta(dcx, dcy);
    }
    else
    {
        // Degenerate case: two overlapping buttons with same center, break ties arbitrarily (note that LastItemId here is really the _previous_ item order, but it doesn't matter)
        quadrant = (g.LastItemData.ID < g.NavId) ? .Left : .Right;
    }

    move_dir := g.NavMoveDir;
when IMGUI_DEBUG_NAV_SCORING {
    buf : [200]u8;
    if (g.IO.KeyCtrl) // Hold CTRL to preview score in matching quadrant. CTRL+Arrow to rotate.
    {
        if (quadrant == move_dir)
        {
            ImFormatString(buf, len(buf), "%.0/%.0", dist_box, dist_center);
            draw_list := GetForegroundDrawList(window);
            AddRectFilled(draw_list, cand.Min, cand.Max, IM_COL32(255, 0, 0, 80));
            AddRectFilled(draw_list, cand.Min, cand.Min + CalcTextSize(buf), IM_COL32(255, 0, 0, 200));
            draw_list.AddText(cand.Min, IM_COL32(255, 255, 255, 255), buf);
        }
    }
    debug_hovering := IsMouseHoveringRect(cand.Min, cand.Max);
    debug_tty := (g.IO.KeyCtrl && IsKeyPressed(ImGuiKey.Space));
    if (debug_hovering || debug_tty)
    {
        ImFormatString(buf, len(buf),
            "d-box    (%7.3,%7.3) -> %7.3\nd-center (%7.3,%7.3) -> %7.3\nd-axial  (%7.3,%7.3) -> %7.3\nnav %c, quadrant %c",
            dbx, dby, dist_box, dcx, dcy, dist_center, dax, day, dist_axial, "-WENS"[move_dir+1], "-WENS"[quadrant+1]);
        if (debug_hovering)
        {
            draw_list := GetForegroundDrawList(window);
            draw_list.AddRect(curr.Min, curr.Max, IM_COL32(255, 200, 0, 100));
            draw_list.AddRect(cand.Min, cand.Max, IM_COL32(255, 255, 0, 200));
            AddRectFilled(draw_list, cand.Max - ImVec2{4, 4}, cand.Max + CalcTextSize(buf) + ImVec2{4, 4}, IM_COL32(40, 0, 0, 200));
            draw_list.AddText(cand.Max, ~0, buf);
        }
        if (debug_tty) { IMGUI_DEBUG_LOG_NAV("id 0x%08X\n%s\n", g.LastItemData.ID, buf); }
    }
}

    // Is it in the quadrant we're interested in moving to?
    new_best := false;
    if (quadrant == move_dir)
    {
        // Does it beat the current best candidate?
        if (dist_box < result.DistBox)
        {
            result.DistBox = dist_box;
            result.DistCenter = dist_center;
            return true;
        }
        if (dist_box == result.DistBox)
        {
            // Try using distance between center points to break ties
            if (dist_center < result.DistCenter)
            {
                result.DistCenter = dist_center;
                new_best = true;
            }
            else if (dist_center == result.DistCenter)
            {
                // Still tied! we need to be extra-careful to make sure everything gets linked properly. We consistently break ties by symbolically moving "later" items
                // (with higher index) to the right/downwards by an infinitesimal amount since we the current "best" button already (so it must have a lower index),
                // this is fairly easy. This rule ensures that all buttons with dx==dy==0 will end up being linked in order of appearance along the x axis.
                if (((move_dir == ImGuiDir.Up || move_dir == ImGuiDir.Down) ? dby : dbx) < 0.0) {// moving bj to the right/down decreases distance
                    new_best = true;
                }
            }
        }
    }

    // Axial check: if 'curr' has no link at all in some direction and 'cand' lies roughly in that direction, add a tentative link. This will only be kept if no "real" matches
    // are found, so it only augments the graph produced by the above method using extra links. (important, since it doesn't guarantee strong connectedness)
    // This is just to avoid buttons having no links in a particular direction when there's a suitable neighbor. you get good graphs without this too.
    // 2017/09/29: FIXME: This now currently only enabled inside menu bars, ideally we'd disable it everywhere. Menus in particular need to catch failure. For general navigation it feels awkward.
    // Disabling it may lead to disconnected graphs when nodes are very spaced out on different axis. Perhaps consider offering this as an option?
    if (result.DistBox == math.F32_MAX && dist_axial < result.DistAxial) { // Check axial match
        if (g.NavLayer == ImGuiNavLayer_Menu && !(.ChildMenu in g.NavWindow.Flags)) {
            if ((move_dir == .Left && dax < 0.0) || (move_dir == .Right && dax > 0.0) || (move_dir == ImGuiDir.Up && day < 0.0) || (move_dir == ImGuiDir.Down && day > 0.0))
            {
                result.DistAxial = dist_axial;
                new_best = true;
            }
        }
    }

    return new_best;
}

NavApplyItemToResult :: proc(result : ^ImGuiNavItemData)
{
    g := GImGui;
    window := g.CurrentWindow;
    result.Window = window;
    result.ID = g.LastItemData.ID;
    result.FocusScopeId = g.CurrentFocusScopeId;
    result.ItemFlags = g.LastItemData.ItemFlags;
    result.RectRel = WindowRectAbsToRel(window, g.LastItemData.NavRect);
    if (.HasSelectionUserData in result.ItemFlags)
    {
        assert(g.NextItemData.SelectionUserData != ImGuiSelectionUserData_Invalid);
        result.SelectionUserData = g.NextItemData.SelectionUserData; // INTENTIONAL: At this point this field is not cleared in NextItemData. Avoid unnecessary copy to LastItemData.
    }
}

// True when current work location may be scrolled horizontally when moving left / right.
// This is generally always true UNLESS within a column. We don't have a vertical equivalent.
NavUpdateCurrentWindowIsScrollPushableX :: proc()
{
    g := GImGui;
    window := g.CurrentWindow;
    window.DC.NavIsScrollPushableX = (g.CurrentTable == nil && window.DC.CurrentColumns == nil);
}

// We get there when either NavId == id, or when g.NavAnyRequest is set (which is updated by NavUpdateAnyRequestFlag above)
// This is called after LastItemData is set, but NextItemData is also still valid.
NavProcessItem :: proc()
{
    g := GImGui;
    window := g.CurrentWindow;
    id := g.LastItemData.ID;
    item_flags := g.LastItemData.ItemFlags;

    // When inside a container that isn't scrollable with Left<>Right, clip NavRect accordingly (#2221)
    if (window.DC.NavIsScrollPushableX == false)
    {
        g.LastItemData.NavRect.Min.x = ImClamp(g.LastItemData.NavRect.Min.x, window.ClipRect.Min.x, window.ClipRect.Max.x);
        g.LastItemData.NavRect.Max.x = ImClamp(g.LastItemData.NavRect.Max.x, window.ClipRect.Min.x, window.ClipRect.Max.x);
    }
    nav_bb := g.LastItemData.NavRect;

    // Process Init Request
    if (g.NavInitRequest && g.NavLayer == window.DC.NavLayerCurrent && (.Disabled not_in item_flags))
    {
        // Even if 'ImGuiItemFlags_NoNavDefaultFocus' is on (typically collapse/close button) we record the first ResultId so they can be used as a fallback
        candidate_for_nav_default_focus := (.NoNavDefaultFocus not_in item_flags);
        if (candidate_for_nav_default_focus || g.NavInitResult.ID == 0)
        {
            NavApplyItemToResult(&g.NavInitResult);
        }
        if (candidate_for_nav_default_focus)
        {
            g.NavInitRequest = false; // Found a match, clear request
            NavUpdateAnyRequestFlag();
        }
    }

    // Process Move Request (scoring for navigation)
    // FIXME-NAV: Consider policy for double scoring (scoring from NavScoringRect + scoring from a rect wrapped according to current wrapping policy)
    if (g.NavMoveScoringItems && (.Disabled not_in item_flags))
    {
        if ((.FocusApi in g.NavMoveFlags) || (.NoNavInputs not_in window.Flags))
        {
            is_tabbing := (.IsTabbing in g.NavMoveFlags) != 0;
            if (is_tabbing)
            {
                NavProcessItemForTabbingRequest(id, item_flags, g.NavMoveFlags);
            }
            else if (g.NavId != id || (.AllowCurrentNavId in g.NavMoveFlags))
            {
                result := (window == g.NavWindow) ? &g.NavMoveResultLocal : &g.NavMoveResultOther;
                if (NavScoreItem(result)) {
                    NavApplyItemToResult(result);
                }

                // Features like PageUp/PageDown need to maintain a separate score for the visible set of items.
                VISIBLE_RATIO := 0.70;
                if ((.AlsoScoreVisibleSet in g.NavMoveFlags) && window.ClipRect.Overlaps(nav_bb)) {
                    if (ImClamp(nav_bb.Max.y, window.ClipRect.Min.y, window.ClipRect.Max.y) - ImClamp(nav_bb.Min.y, window.ClipRect.Min.y, window.ClipRect.Max.y) >= (nav_bb.Max.y - nav_bb.Min.y) * VISIBLE_RATIO) {
                        if (NavScoreItem(&g.NavMoveResultLocalVisible)) {
                            NavApplyItemToResult(&g.NavMoveResultLocalVisible);
                        }
                    }
                }
            }
        }
    }

    // Update information for currently focused/navigated item
    if (g.NavId == id)
    {
        if (g.NavWindow != window) {
            SetNavWindow(window); // Always refresh g.NavWindow, because some operations such as FocusItem() may not have a window.
        }
        g.NavLayer = window.DC.NavLayerCurrent;
        SetNavFocusScope(g.CurrentFocusScopeId); // Will set g.NavFocusScopeId AND store g.NavFocusScopePath
        g.NavFocusScopeId = g.CurrentFocusScopeId;
        g.NavIdIsAlive = true;
        if (.HasSelectionUserData in g.LastItemData.ItemFlags)
        {
            assert(g.NextItemData.SelectionUserData != ImGuiSelectionUserData_Invalid);
            g.NavLastValidSelectionUserData = g.NextItemData.SelectionUserData; // INTENTIONAL: At this point this field is not cleared in NextItemData. Avoid unnecessary copy to LastItemData.
        }
        window.NavRectRel[window.DC.NavLayerCurrent] = WindowRectAbsToRel(window, nav_bb); // Store item bounding box (relative to window position)
    }
}

// Handle "scoring" of an item for a tabbing/focusing request initiated by NavUpdateCreateTabbingRequest().
// Note that SetKeyboardFocusHere() API calls are considered tabbing requests!
// - Case 1: no nav/active id:    set result to first eligible item, stop storing.
// - Case 2: tab forward:         on ref id set counter, on counter elapse store result
// - Case 3: tab forward wrap:    set result to first eligible item (preemptively), on ref id set counter, on next frame if counter hasn't elapsed store result. // FIXME-TABBING: Could be done as a next-frame forwarded request
// - Case 4: tab backward:        store all results, on ref id pick prev, stop storing
// - Case 5: tab backward wrap:   store all results, on ref id if no result keep storing until last // FIXME-TABBING: Could be done as next-frame forwarded requested
NavProcessItemForTabbingRequest :: proc(id : ImGuiID, item_flags : ImGuiItemFlags, move_flags : ImGuiNavMoveFlags)
{
    g := GImGui;

    if ((.FocusApi not_in move_flags))
    {
        if (g.NavLayer != g.CurrentWindow.DC.NavLayerCurrent)   do return
        if (g.NavFocusScopeId != g.CurrentFocusScopeId)   do return
    }

    // - Can always land on an item when using API call.
    // - Tabbing with _NavEnableKeyboard (space/enter/arrows): goes through every item.
    // - Tabbing without _NavEnableKeyboard: goes through inputable items only.
    can_stop : bool
    if (.FocusApi in move_flags)   do can_stop = true
    else {
        can_stop = (.NoTabStop not_in item_flags) && ((.NavEnableKeyboard in g.IO.ConfigFlags) || (.Inputable in item_flags));
    }

    // Always store in NavMoveResultLocal (unlike directional request which uses NavMoveResultOther on sibling/flattened windows)
    result := &g.NavMoveResultLocal;
    if (g.NavTabbingDir == +1)
    {
        // Tab Forward or SetKeyboardFocusHere() with >= 0
        if (can_stop && g.NavTabbingResultFirst.ID == 0) {
            NavApplyItemToResult(&g.NavTabbingResultFirst);
        }
        if (can_stop && g.NavTabbingCounter > 0) {
            g.NavTabbingCounter -= 1
            if (g.NavTabbingCounter == 0) {
                NavMoveRequestResolveWithLastItem(result);
            }
            else if (g.NavId == id)   do g.NavTabbingCounter = 1
        }
        else if (g.NavId == id)   do g.NavTabbingCounter = 1
    }
    else if (g.NavTabbingDir == -1)
    {
        // Tab Backward
        if (g.NavId == id)
        {
            if (result.ID)
            {
                g.NavMoveScoringItems = false;
                NavUpdateAnyRequestFlag();
            }
        }
        else if (can_stop)
        {
            // Keep applying until reaching NavId
            NavApplyItemToResult(result);
        }
    }
    else if (g.NavTabbingDir == 0)
    {
        if (can_stop && g.NavId == id) {
            NavMoveRequestResolveWithLastItem(result);
        }
        if (can_stop && g.NavTabbingResultFirst.ID == 0) {// Tab init
            NavApplyItemToResult(&g.NavTabbingResultFirst);
        }
    }
}

NavMoveRequestButNoResultYet :: proc() -> bool
{
    g := GImGui;
    return g.NavMoveScoringItems && g.NavMoveResultLocal.ID == 0 && g.NavMoveResultOther.ID == 0;
}

// FIXME: ScoringRect is not set
NavMoveRequestSubmit :: proc(move_dir : ImGuiDir, clip_dir : ImGuiDir, move_flags : ImGuiNavMoveFlags, scroll_flags : ImGuiScrollFlags)
{
    g := GImGui;
    assert(g.NavWindow != nil);
    //IMGUI_DEBUG_LOG_NAV("[nav] NavMoveRequestSubmit: dir %c, window \"%s\"\n", "-WENS"[move_dir + 1], g.NavWindow.Name);

    if (.IsTabbing in move_flags) {
        move_flags |= ImGuiNavMoveFlags_AllowCurrentNavId;
    }

    g.NavMoveScoringItems = true;
    g.NavMoveSubmitted = true
    g.NavMoveDir = move_dir;
    g.NavMoveDirForDebug = move_dir;
    g.NavMoveClipDir = clip_dir;
    g.NavMoveFlags = move_flags;
    g.NavMoveScrollFlags = scroll_flags;
    g.NavMoveForwardToNextFrame = false;
    g.NavMoveKeyMods = (.FocusApi in move_flags) ? 0 : g.IO.KeyMods;
    g.NavMoveResultLocal.Clear();
    g.NavMoveResultLocalVisible.Clear();
    g.NavMoveResultOther.Clear();
    g.NavTabbingCounter = 0;
    g.NavTabbingResultFirst.Clear();
    NavUpdateAnyRequestFlag();
}

NavMoveRequestResolveWithLastItem :: proc(result : ^ImGuiNavItemData)
{
    g := GImGui;
    g.NavMoveScoringItems = false; // Ensure request doesn't need more processing
    NavApplyItemToResult(result);
    NavUpdateAnyRequestFlag();
}

// Called by TreePop() to implement ImGuiTreeNodeFlags_NavLeftJumpsBackHere
NavMoveRequestResolveWithPastTreeNode :: proc(result : ^ImGuiNavItemData, tree_node_data : ^ImGuiTreeNodeStackData)
{
    g := GImGui;
    g.NavMoveScoringItems = false;
    g.LastItemData.ID = tree_node_data.ID;
    g.LastItemData.ItemFlags = tree_node_data.ItemFlags & ~ImGuiItemFlags_HasSelectionUserData; // Losing SelectionUserData, recovered next-frame (cheaper).
    g.LastItemData.NavRect = tree_node_data.NavRect;
    NavApplyItemToResult(result); // Result this instead of implementing a NavApplyPastTreeNodeToResult()
    NavClearPreferredPosForAxis(ImGuiAxis.Y);
    NavUpdateAnyRequestFlag();
}

NavMoveRequestCancel :: proc()
{
    g := GImGui;
    g.NavMoveScoringItems = false;
    g.NavMoveSubmitted = false
    NavUpdateAnyRequestFlag();
}

// Forward will reuse the move request again on the next frame (generally with modifications done to it)
NavMoveRequestForward :: proc(move_dir : ImGuiDir, clip_dir : ImGuiDir, move_flags : ImGuiNavMoveFlags, scroll_flags : ImGuiScrollFlags)
{
    g := GImGui;
    assert(g.NavMoveForwardToNextFrame == false);
    NavMoveRequestCancel();
    g.NavMoveForwardToNextFrame = true;
    g.NavMoveDir = move_dir;
    g.NavMoveClipDir = clip_dir;
    g.NavMoveFlags = move_flags | ImGuiNavMoveFlags_Forwarded;
    g.NavMoveScrollFlags = scroll_flags;
}

// Navigation wrap-around logic is delayed to the end of the frame because this operation is only valid after entire
// popup is assembled and in case of appended popups it is not clear which EndPopup() call is final.
NavMoveRequestTryWrapping :: proc(window : ^ImGuiWindow, wrap_flags : ImGuiNavMoveFlags)
{
    g := GImGui;
    assert((.WrapMask_  in wrap_flags) != 0 && (wrap_flags & ~ImGuiNavMoveFlags_WrapMask_) == 0); // Call with _WrapX, _WrapY, _LoopX, _LoopY

    // In theory we should test for NavMoveRequestButNoResultYet() but there's no point doing it:
    // as NavEndFrame() will do the same test. It will end up calling NavUpdateCreateWrappingRequest().
    if (g.NavWindow == window && g.NavMoveScoringItems && g.NavLayer == ImGuiNavLayer_Main) {
        g.NavMoveFlags = (g.NavMoveFlags & ~ImGuiNavMoveFlags_WrapMask_) | wrap_flags;
    }
}

// FIXME: This could be replaced by updating a frame number in each window when (window == NavWindow) and (NavLayer == 0).
// This way we could find the last focused window among our children. It would be much less confusing this way?
NavSaveLastChildNavWindowIntoParent :: proc(nav_window : ^ImGuiWindow)
{
    parent := nav_window;
    for (parent && parent.RootWindow != parent && (parent.Flags & (ImGuiWindowFlags_Popup | ImGuiWindowFlags_ChildMenu)) == 0) {
        parent = parent.ParentWindow;
    }
    if (parent && parent != nav_window) {
        parent.NavLastChildNavWindow = nav_window;
    }
}

// Restore the last focused child.
// Call when we are expected to land on the Main Layer (0) after FocusWindow()
NavRestoreLastChildNavWindow :: proc(window : ^ImGuiWindow) -> ^ImGuiWindow
{
    if (window.NavLastChildNavWindow && window.NavLastChildNavWindow.WasActive) {
        return window.NavLastChildNavWindow;
    }
    if (window.DockNodeAsHost && window.DockNodeAsHost.TabBar) {
        if tab := TabBarFindMostRecentlySelectedTabForActiveWindow(window.DockNodeAsHost.TabBar); tab != nil   do return tab.Window
    }
    return window;
}

NavRestoreLayer :: proc(layer : ImGuiNavLayer)
{
    g := GImGui;
    if (layer == ImGuiNavLayer_Main)
    {
        prev_nav_window := g.NavWindow;
        g.NavWindow = NavRestoreLastChildNavWindow(g.NavWindow);    // FIXME-NAV: Should clear ongoing nav requests?
        g.NavLastValidSelectionUserData = ImGuiSelectionUserData_Invalid;
        if (prev_nav_window) {
            IMGUI_DEBUG_LOG_FOCUS("[focus] NavRestoreLayer: from \"%s\" to SetNavWindow(\"%s\")\n", prev_nav_window.Name, g.NavWindow.Name);
        }
    }
    window := g.NavWindow;
    if (window.NavLastIds[layer] != 0)
    {
        SetNavID(window.NavLastIds[layer], layer, 0, window.NavRectRel[layer]);
    }
    else
    {
        g.NavLayer = layer;
        NavInitWindow(window, true);
    }
}

NavUpdateAnyRequestFlag :: #force_inline proc()
{
    g := GImGui;
    g.NavAnyRequest = g.NavMoveScoringItems || g.NavInitRequest || (IMGUI_DEBUG_NAV_SCORING && g.NavWindow != nil);
    if (g.NavAnyRequest) {
        assert(g.NavWindow != nil);
    }
}

// This needs to be called before we submit any widget (aka in or before Begin)
NavInitWindow :: proc(window : ^ImGuiWindow, force_reinit : bool)
{
    // FIXME: ChildWindow test here is wrong for docking
    g := GImGui;
    assert(window == g.NavWindow);

    if (.NoNavInputs in window.Flags)
    {
        g.NavId = 0;
        SetNavFocusScope(window.NavRootFocusScopeId);
        return;
    }

    init_for_nav := false;
    if (window == window.RootWindow || (.Popup in window.Flags) || (window.NavLastIds[0] == 0) || force_reinit)   do init_for_nav = true
    IMGUI_DEBUG_LOG_NAV("[nav] NavInitRequest: from NavInitWindow(), init_for_nav=%d, window=\"%s\", layer=%d\n", init_for_nav, window.Name, g.NavLayer);
    if (init_for_nav)
    {
        SetNavID(0, g.NavLayer, window.NavRootFocusScopeId, ImRect());
        g.NavInitRequest = true;
        g.NavInitRequestFromMove = false;
        g.NavInitResult.ID = 0;
        NavUpdateAnyRequestFlag();
    }
    else
    {
        g.NavId = window.NavLastIds[0];
        SetNavFocusScope(window.NavRootFocusScopeId);
    }
}

NavCalcPreferredRefPosSource :: proc() -> ImGuiInputSource
{
    g := GImGui;
    window := g.NavWindow;
    activated_shortcut := g.ActiveId != 0 && g.ActiveIdFromShortcut && g.ActiveId == g.LastItemData.ID;

    // Testing for !activated_shortcut here could in theory be removed if we decided that activating a remote shortcut altered one of the g.NavDisableXXX flag.
    if ((!g.NavCursorVisible || !g.NavHighlightItemUnderNav || !window) && !activated_shortcut)   do return .Mouse
    else {
        return .Keyboard; // or Nav in general
    }
}

NavCalcPreferredRefPos :: proc() -> ImVec2
{
    g := GImGui;
    window := g.NavWindow;
    source := NavCalcPreferredRefPosSource();

    activated_shortcut := g.ActiveId != 0 && g.ActiveIdFromShortcut && g.ActiveId == g.LastItemData.ID;

    // Testing for !activated_shortcut here could in theory be removed if we decided that activating a remote shortcut altered one of the g.NavDisableXXX flag.
    if (source == .Mouse)
    {
        // Mouse (we need a fallback in case the mouse becomes invalid after being used)
        // The +1.0f offset when stored by OpenPopupEx() allows reopening this or another popup (same or another mouse button) while not moving the mouse, it is pretty standard.
        // In theory we could move that +1.0f offset in OpenPopupEx()
        p := IsMousePosValid(&g.IO.MousePos) ? g.IO.MousePos : g.MouseLastValidPos;
        return ImVec2{p.x + 1.0, p.y};
    }
    else
    {
        // When navigation is active and mouse is disabled, pick a position around the bottom left of the currently navigated item
        ref_rect : ImRect
        if (activated_shortcut) {
            ref_rect = g.LastItemData.NavRect;
        }
        else {
            ref_rect = WindowRectRelToAbs(window, window.NavRectRel[g.NavLayer]);
        }

        // Take account of upcoming scrolling (maybe set mouse pos should be done in EndFrame?)
        if (window.LastFrameActive != g.FrameCount && (window.ScrollTarget.x != math.F32_MAX || window.ScrollTarget.y != math.F32_MAX))
        {
            next_scroll := CalcNextScrollFromScrollTargetAndClamp(window);
            ref_rect.Translate(window.Scroll - next_scroll);
        }
        pos := ImVec2{ref_rect.Min.x + ImMin(g.Style.FramePadding.x * 4, ref_rect.GetWidth()), ref_rect.Max.y - ImMin(g.Style.FramePadding.y, ref_rect.GetHeight())};
        viewport := window.Viewport;
        return ImTrunc(ImClamp(pos, viewport.Pos, viewport.Pos + viewport.Size)); // ImTrunc() is important because non-integer mouse position application in backend might be lossy and result in undesirable non-zero delta.
    }
}

GetNavTweakPressedAmount :: proc(axis : ImGuiAxis) -> f32
{
    g := GImGui;
    repeat_delay, repeat_rate : f32
    GetTypematicRepeatRate(ImGuiInputFlags_RepeatRateNavTweak, &repeat_delay, &repeat_rate);

    key_less, key_more : ImGuiKey
    if (g.NavInputSource == .Gamepad)
    {
        key_less = (axis == ImGuiAxis.X) ? ImGuiKey.GamepadDpadLeft : ImGuiKey.GamepadDpadUp;
        key_more = (axis == ImGuiAxis.X) ? ImGuiKey.GamepadDpadRight : ImGuiKey.GamepadDpadDown;
    }
    else
    {
        key_less = (axis == ImGuiAxis.X) ? ImGuiKey.LeftArrow : ImGuiKey.UpArrow;
        key_more = (axis == ImGuiAxis.X) ? ImGuiKey.RightArrow : ImGuiKey.DownArrow;
    }
    amount := cast(f32) GetKeyPressedAmount(key_more, repeat_delay, repeat_rate) - cast(f32) GetKeyPressedAmount(key_less, repeat_delay, repeat_rate);
    if (amount != 0.0 && IsKeyDown(key_less) && IsKeyDown(key_more)) {// Cancel when opposite directions are held, regardless of repeat phase
        amount = 0.0;
    }
    return amount;
}

NavUpdate :: proc()
{
    g := GImGui;
    io := &g.IO;

    io.WantSetMousePos = false;
    //if (g.NavScoringDebugCount > 0) IMGUI_DEBUG_LOG_NAV("[nav] NavScoringDebugCount %d for '%s' layer %d (Init:%d, Move:%d)\n", g.NavScoringDebugCount, g.NavWindow ? g.NavWindow.Name : "NULL", g.NavLayer, g.NavInitRequest || g.NavInitResultId != 0, g.NavMoveRequest);

    // Set input source based on which keys are last pressed (as some features differs when used with Gamepad vs Keyboard)
    // FIXME-NAV: Now that keys are separated maybe we can get rid of NavInputSource?
    nav_gamepad_active := (.NavEnableGamepad in io.ConfigFlags) != 0 && (.HasGamepad in io.BackendFlags) != 0;
    nav_gamepad_keys_to_change_source := [?]ImGuiKey { ImGuiKey.GamepadFaceRight, ImGuiKey.GamepadFaceLeft, ImGuiKey.GamepadFaceUp, ImGuiKey.GamepadFaceDown, ImGuiKey.GamepadDpadRight, ImGuiKey.GamepadDpadLeft, ImGuiKey.GamepadDpadUp, ImGuiKey.GamepadDpadDown };
    if (nav_gamepad_active) {
        for key in nav_gamepad_keys_to_change_source {
            if (IsKeyDown(key)) {
                g.NavInputSource = .Gamepad;
            }
        }
    }
    nav_keyboard_active := (.NavEnableKeyboard in io.ConfigFlags) != 0;
    nav_keyboard_keys_to_change_source := [?]ImGuiKey { ImGuiKey.Space, ImGuiKey.Enter, ImGuiKey.Escape, ImGuiKey.RightArrow, ImGuiKey.LeftArrow, ImGuiKey.UpArrow, ImGuiKey.DownArrow };
    if (nav_keyboard_active) {
        for key in nav_keyboard_keys_to_change_source {
            if (IsKeyDown(key)) {
                g.NavInputSource = .Keyboard;
            }
        }
    }

    // Process navigation init request (select first/default focus)
    g.NavJustMovedToId = 0;
    g.NavJustMovedFromFocusScopeId = 0;
    g.NavJustMovedToFocusScopeId = 0
    if (g.NavInitResult.ID != 0) {
        NavInitRequestApplyResult();
    }
    g.NavInitRequest = false;
    g.NavInitRequestFromMove = false;
    g.NavInitResult.ID = 0;

    // Process navigation move request
    if (g.NavMoveSubmitted) {
        NavMoveRequestApplyResult();
    }
    g.NavTabbingCounter = 0;
    g.NavMoveScoringItems = false;
    g.NavMoveSubmitted = false
    if (g.NavCursorHideFrames > 0) {
        g.NavCursorHideFrames -= 1
        if (g.NavCursorHideFrames == 0)   do g.NavCursorVisible = true
    }

    // Schedule mouse position update (will be done at the bottom of this function, after 1) processing all move requests and 2) updating scrolling)
    set_mouse_pos := false;
    if (g.NavMousePosDirty && g.NavIdIsAlive) {
        if (g.NavCursorVisible && g.NavHighlightItemUnderNav && g.NavWindow)   do set_mouse_pos = true
    }
    g.NavMousePosDirty = false;
    assert(g.NavLayer == ImGuiNavLayer_Main || g.NavLayer == ImGuiNavLayer_Menu);

    // Store our return window (for returning from Menu Layer to Main Layer) and clear it as soon as we step back in our own Layer 0
    if (g.NavWindow) {
        NavSaveLastChildNavWindowIntoParent(g.NavWindow);
    }
    if (g.NavWindow && g.NavWindow.NavLastChildNavWindow != nil && g.NavLayer == ImGuiNavLayer_Main) {
        g.NavWindow.NavLastChildNavWindow = nil;
    }

    // Update CTRL+TAB and Windowing features (hold Square to move/resize/etc.)
    NavUpdateWindowing();

    // Set output flags for user application
    io.NavActive = (nav_keyboard_active || nav_gamepad_active) && g.NavWindow && !(.NoNavInputs in g.NavWindow.Flags);
    io.NavVisible = (io.NavActive && g.NavId != 0 && g.NavCursorVisible) || (g.NavWindowingTarget != nil);

    // Process NavCancel input (to close a popup, get back to parent, clear focus)
    NavUpdateCancelRequest();

    // Process manual activation request
    g.NavActivatePressedId = 0;
    g.NavActivateDownId = 0
    g.NavActivateId = 0
    g.NavActivateFlags = ImGuiActivateFlags_None;
    if (g.NavId != 0 && g.NavCursorVisible && !g.NavWindowingTarget && g.NavWindow && !(.NoNavInputs in g.NavWindow.Flags))
    {
        activate_down := (nav_keyboard_active && IsKeyDown(ImGuiKey.Space, ImGuiKeyOwner_NoOwner)) || (nav_gamepad_active && IsKeyDown(ImGuiKey_NavGamepadActivate(g), ImGuiKeyOwner_NoOwner));
        activate_pressed := activate_down && ((nav_keyboard_active && IsKeyPressed(ImGuiKey.Space, 0, ImGuiKeyOwner_NoOwner)) || (nav_gamepad_active && IsKeyPressed(ImGuiKey_NavGamepadActivate(g), 0, ImGuiKeyOwner_NoOwner)));
        input_down := (nav_keyboard_active && (IsKeyDown(ImGuiKey.Enter, ImGuiKeyOwner_NoOwner) || IsKeyDown(ImGuiKey.KeypadEnter, ImGuiKeyOwner_NoOwner))) || (nav_gamepad_active && IsKeyDown(ImGuiKey_NavGamepadInput, ImGuiKeyOwner_NoOwner));
        input_pressed := input_down && ((nav_keyboard_active && (IsKeyPressed(ImGuiKey.Enter, 0, ImGuiKeyOwner_NoOwner) || IsKeyPressed(ImGuiKey.KeypadEnter, 0, ImGuiKeyOwner_NoOwner))) || (nav_gamepad_active && IsKeyPressed(ImGuiKey_NavGamepadInput, 0, ImGuiKeyOwner_NoOwner)));
        if (g.ActiveId == 0 && activate_pressed)
        {
            g.NavActivateId = g.NavId;
            g.NavActivateFlags = ImGuiActivateFlags_PreferTweak;
        }
        if ((g.ActiveId == 0 || g.ActiveId == g.NavId) && input_pressed)
        {
            g.NavActivateId = g.NavId;
            g.NavActivateFlags = ImGuiActivateFlags_PreferInput;
        }
        if ((g.ActiveId == 0 || g.ActiveId == g.NavId) && (activate_down || input_down)) {
            g.NavActivateDownId = g.NavId;
        }
        if ((g.ActiveId == 0 || g.ActiveId == g.NavId) && (activate_pressed || input_pressed))
        {
            g.NavActivatePressedId = g.NavId;
            NavHighlightActivated(g.NavId);
        }
    }
    if (g.NavWindow && (.NoNavInputs in g.NavWindow.Flags)) {
        g.NavCursorVisible = false;
    }
    else if (g.IO.ConfigNavCursorVisibleAlways && g.NavCursorHideFrames == 0)   do g.NavCursorVisible = true
    if (g.NavActivateId != 0) {
        assert(g.NavActivateDownId == g.NavActivateId);
    }

    // Highlight
    if (g.NavHighlightActivatedTimer > 0.0) {
        g.NavHighlightActivatedTimer = ImMax(0.0, g.NavHighlightActivatedTimer - io.DeltaTime);
    }
    if (g.NavHighlightActivatedTimer == 0.0) {
        g.NavHighlightActivatedId = 0;
    }

    // Process programmatic activation request
    // FIXME-NAV: Those should eventually be queued (unlike focus they don't cancel each others)
    if (g.NavNextActivateId != 0)
    {
        g.NavActivatePressedId = g.NavNextActivateId;
        g.NavActivateDownId = g.NavNextActivateId
        g.NavActivateId = g.NavNextActivateId
        g.NavActivateFlags = g.NavNextActivateFlags;
    }
    g.NavNextActivateId = 0;

    // Process move requests
    NavUpdateCreateMoveRequest();
    if (g.NavMoveDir == nil) {
        NavUpdateCreateTabbingRequest();
    }
    NavUpdateAnyRequestFlag();
    g.NavIdIsAlive = false;

    // Scrolling
    if (g.NavWindow && !(.NoNavInputs in g.NavWindow.Flags) && !g.NavWindowingTarget)
    {
        // *Fallback* manual-scroll with Nav directional keys when window has no navigable item
        window := g.NavWindow;
        scroll_speed := math.round(window.CalcFontSize() * 100 * io.DeltaTime); // We need round the scrolling speed because sub-pixel scroll isn't reliably supported.
        move_dir := g.NavMoveDir;
        if (window.DC.NavLayersActiveMask == 0x00 && window.DC.NavWindowHasScrollY && move_dir != nil)
        {
            if (move_dir == .Left || move_dir == .Right) {
                SetScrollX(window, ImTrunc(window.Scroll.x + ((move_dir == .Left) ? -1.0 : +1.0) * scroll_speed));
            }
            if (move_dir == ImGuiDir.Up || move_dir == ImGuiDir.Down) {
                SetScrollY(window, ImTrunc(window.Scroll.y + ((move_dir == ImGuiDir.Up) ? -1.0 : +1.0) * scroll_speed));
            }
        }

        // *Normal* Manual scroll with LStick
        // Next movement request will clamp the NavId reference rectangle to the visible area, so navigation will resume within those bounds.
        if (nav_gamepad_active)
        {
            scroll_dir := GetKeyMagnitude2d(ImGuiKey.GamepadLStickLeft, ImGuiKey.GamepadLStickRight, ImGuiKey.GamepadLStickUp, ImGuiKey.GamepadLStickDown);
            tweak_factor := IsKeyDown(ImGuiKey.NavGamepadTweakSlow) ? 1.0 / 10.0 : IsKeyDown(ImGuiKey.NavGamepadTweakFast) ? 10.0 : 1.0;
            if (scroll_dir.x != 0.0 && window.ScrollbarX) {
                SetScrollX(window, ImTrunc(window.Scroll.x + scroll_dir.x * scroll_speed * tweak_factor));
            }
            if (scroll_dir.y != 0.0) {
                SetScrollY(window, ImTrunc(window.Scroll.y + scroll_dir.y * scroll_speed * tweak_factor));
            }
        }
    }

    // Always prioritize mouse highlight if navigation is disabled
    if (!nav_keyboard_active && !nav_gamepad_active)
    {
        g.NavCursorVisible = false;
        set_mouse_pos = false;
        g.NavHighlightItemUnderNav = false
    }

    // Update mouse position if requested
    // (This will take into account the possibility that a Scroll was queued in the window to offset our absolute mouse position before scroll has been applied)
    if (set_mouse_pos && io.ConfigNavMoveSetMousePos && (.HasSetMousePos in io.BackendFlags)) {
        TeleportMousePos(NavCalcPreferredRefPos());
    }

    // [DEBUG]
    g.NavScoringDebugCount = 0;
when IMGUI_DEBUG_NAV_RECTS {
    if debug_window := g.NavWindow; debug_window != nil
    {
        draw_list := GetForegroundDrawList(debug_window);
        layer := g.NavLayer; /* for (i32 layer = 0; layer < 2; layer++)*/ { r := WindowRectRelToAbs(debug_window, debug_window.NavRectRel[layer]); draw_list.AddRect(r.Min, r.Max, IM_COL32(255, 200, 0, 255)); }
        //if (1) { ImU32 col = (!debug_window.Hidden) ? IM_COL32(255,0,255,255) : IM_COL32(255,0,0,255); ImVec2 p = NavCalcPreferredRefPos(); char buf[32]; ImFormatString(buf, 32, "%d", g.NavLayer); draw_list.AddCircleFilled(p, 3.0f, col); draw_list.AddText(NULL, 13.0f, p + ImVec2(8,-4), col, buf); }
    }
}
}

NavInitRequestApplyResult :: proc()
{
    // In very rare cases g.NavWindow may be null (e.g. clearing focus after requesting an init request, which does happen when releasing Alt while clicking on void)
    g := GImGui;
    if (!g.NavWindow)   do return

    result := &g.NavInitResult;
    if (g.NavId != result.ID)
    {
        g.NavJustMovedFromFocusScopeId = g.NavFocusScopeId;
        g.NavJustMovedToId = result.ID;
        g.NavJustMovedToFocusScopeId = result.FocusScopeId;
        g.NavJustMovedToKeyMods = 0;
        g.NavJustMovedToIsTabbing = false;
        g.NavJustMovedToHasSelectionData = (.HasSelectionUserData in result.ItemFlags) != 0;
    }

    // Apply result from previous navigation init request (will typically select the first item, unless SetItemDefaultFocus() has been called)
    // FIXME-NAV: On _NavFlattened windows, g.NavWindow will only be updated during subsequent frame. Not a problem currently.
    IMGUI_DEBUG_LOG_NAV("[nav] NavInitRequest: ApplyResult: NavID 0x%08X in Layer %d Window \"%s\"\n", result.ID, g.NavLayer, g.NavWindow.Name);
    SetNavID(result.ID, g.NavLayer, result.FocusScopeId, result.RectRel);
    g.NavIdIsAlive = true; // Mark as alive from previous frame as we got a result
    if (result.SelectionUserData != ImGuiSelectionUserData_Invalid) {
        g.NavLastValidSelectionUserData = result.SelectionUserData;
    }
    if (g.NavInitRequestFromMove) {
        SetNavCursorVisibleAfterMove();
    }
}

// Bias scoring rect ahead of scoring + update preferred pos (if missing) using source position
NavBiasScoringRect :: proc(r : ^ImRect, preferred_pos_rel : ImVec2, move_dir : ImGuiDir, move_flags : ImGuiNavMoveFlags)
{
    // Bias initial rect
    g := GImGui;
    rel_to_abs_offset := g.NavWindow.DC.CursorStartPos;

    // Initialize bias on departure if we don't have any. So mouse-click + arrow will record bias.
    // - We default to L/U bias, so moving down from a large source item into several columns will land on left-most column.
    // - But each successful move sets new bias on one axis, only cleared when using mouse.
    if ((.Forwarded not_in move_flags))
    {
        if (preferred_pos_rel.x == math.F32_MAX) {
            preferred_pos_rel.x = ImMin(r.Min.x + 1.0, r.Max.x) - rel_to_abs_offset.x;
        }
        if (preferred_pos_rel.y == math.F32_MAX) {
            preferred_pos_rel.y = r.GetCenter().y - rel_to_abs_offset.y;
        }
    }

    // Apply general bias on the other axis
    if ((move_dir == ImGuiDir.Up || move_dir == ImGuiDir.Down) && preferred_pos_rel.x != math.F32_MAX) {
        r.Max.x = preferred_pos_rel.x + rel_to_abs_offset.x;
        r.Min.x = r.Max.x
    }
    else if ((move_dir == .Left || move_dir == .Right) && preferred_pos_rel.y != math.F32_MAX) {
        r.Max.y = preferred_pos_rel.y + rel_to_abs_offset.y;
        r.Min.y = r.Max.y
    }
}

NavUpdateCreateMoveRequest :: proc()
{
    g := GImGui;
    io := &g.IO;
    window := g.NavWindow;
    nav_gamepad_active := (.NavEnableGamepad in io.ConfigFlags) != 0 && (.HasGamepad in io.BackendFlags) != 0;
    nav_keyboard_active := (.NavEnableKeyboard in io.ConfigFlags) != 0;

    if (g.NavMoveForwardToNextFrame && window != nil)
    {
        // Forwarding previous request (which has been modified, e.g. wrap around menus rewrite the requests with a starting rectangle at the other side of the window)
        // (preserve most state, which were already set by the NavMoveRequestForward() function)
        assert(g.NavMoveDir != nil && g.NavMoveClipDir != nil);
        assert(.Forwarded in g.NavMoveFlags);
        IMGUI_DEBUG_LOG_NAV("[nav] NavMoveRequestForward %d\n", g.NavMoveDir);
    }
    else
    {
        // Initiate directional inputs request
        g.NavMoveDir = nil;
        g.NavMoveFlags = ImGuiNavMoveFlags_None;
        g.NavMoveScrollFlags = ImGuiScrollFlags_None;
        if (window && !g.NavWindowingTarget && !(.NoNavInputs in window.Flags))
        {
            repeat_mode := ImGuiInputFlags_Repeat | ImGuiInputFlags_RepeatRateNavMove;
            if (!IsActiveIdUsingNavDir(.Left)  && ((nav_gamepad_active && IsKeyPressed(ImGuiKey.GamepadDpadLeft,  repeat_mode, ImGuiKeyOwner_NoOwner)) || (nav_keyboard_active && IsKeyPressed(ImGuiKey.LeftArrow,  repeat_mode, ImGuiKeyOwner_NoOwner)))) { g.NavMoveDir = .Left; }
            if (!IsActiveIdUsingNavDir(.Right) && ((nav_gamepad_active && IsKeyPressed(ImGuiKey.GamepadDpadRight, repeat_mode, ImGuiKeyOwner_NoOwner)) || (nav_keyboard_active && IsKeyPressed(ImGuiKey.RightArrow, repeat_mode, ImGuiKeyOwner_NoOwner)))) { g.NavMoveDir = .Right; }
            if (!IsActiveIdUsingNavDir(ImGuiDir.Up)    && ((nav_gamepad_active && IsKeyPressed(ImGuiKey.GamepadDpadUp,    repeat_mode, ImGuiKeyOwner_NoOwner)) || (nav_keyboard_active && IsKeyPressed(ImGuiKey.UpArrow,    repeat_mode, ImGuiKeyOwner_NoOwner)))) { g.NavMoveDir = ImGuiDir.Up; }
            if (!IsActiveIdUsingNavDir(ImGuiDir.Down)  && ((nav_gamepad_active && IsKeyPressed(ImGuiKey.GamepadDpadDown,  repeat_mode, ImGuiKeyOwner_NoOwner)) || (nav_keyboard_active && IsKeyPressed(ImGuiKey.DownArrow,  repeat_mode, ImGuiKeyOwner_NoOwner)))) { g.NavMoveDir = ImGuiDir.Down; }
        }
        g.NavMoveClipDir = g.NavMoveDir;
        g.NavScoringNoClipRect = ImRect{ _r = {+math.F32_MAX, +math.F32_MAX, -math.F32_MAX, -math.F32_MAX}};
    }

    // Update PageUp/PageDown/Home/End scroll
    // FIXME-NAV: Consider enabling those keys even without the master ImGuiConfigFlags_NavEnableKeyboard flag?
    scoring_rect_offset_y := 0.0;
    if (window && g.NavMoveDir == nil && nav_keyboard_active) {
        scoring_rect_offset_y = NavUpdatePageUpPageDown();
    }
    if (scoring_rect_offset_y != 0.0)
    {
        g.NavScoringNoClipRect = window.InnerRect;
        g.NavScoringNoClipRect.TranslateY(scoring_rect_offset_y);
    }

    // [DEBUG] Always send a request when holding CTRL. Hold CTRL + Arrow change the direction.
when IMGUI_DEBUG_NAV_SCORING {
    //if (io.KeyCtrl && IsKeyPressed(ImGuiKey.C))
    //    g.NavMoveDirForDebug = (ImGuiDir)((g.NavMoveDirForDebug + 1) & 3);
    if (io.KeyCtrl)
    {
        if (g.NavMoveDir == nil) {
            g.NavMoveDir = g.NavMoveDirForDebug;
        }
        g.NavMoveClipDir = g.NavMoveDir;
        g.NavMoveFlags |= ImGuiNavMoveFlags_DebugNoResult;
    }
}

    // Submit
    g.NavMoveForwardToNextFrame = false;
    if (g.NavMoveDir != nil) {
        NavMoveRequestSubmit(g.NavMoveDir, g.NavMoveClipDir, g.NavMoveFlags, g.NavMoveScrollFlags);
    }

    // Moving with no reference triggers an init request (will be used as a fallback if the direction fails to find a match)
    if (g.NavMoveSubmitted && g.NavId == 0)
    {
        IMGUI_DEBUG_LOG_NAV("[nav] NavInitRequest: from move, window \"%s\", layer=%d\n", window ? window.Name : "<nil>", g.NavLayer);
        g.NavInitRequestFromMove = true;
        g.NavInitRequest = true
        g.NavInitResult.ID = 0;
        if (g.IO.ConfigNavCursorVisibleAuto)   do g.NavCursorVisible = true
    }

    // When using gamepad, we project the reference nav bounding box into window visible area.
    // This is to allow resuming navigation inside the visible area after doing a large amount of scrolling,
    // since with gamepad all movements are relative (can't focus a visible object like we can with the mouse).
    if (g.NavMoveSubmitted && g.NavInputSource == .Gamepad && g.NavLayer == ImGuiNavLayer_Main && window != nil)// && (.Forwarded in g.NavMoveFlags))
    {
        clamp_x := (g.NavMoveFlags & (ImGuiNavMoveFlags_LoopX | ImGuiNavMoveFlags_WrapX)) == 0;
        clamp_y := (g.NavMoveFlags & (ImGuiNavMoveFlags_LoopY | ImGuiNavMoveFlags_WrapY)) == 0;
        inner_rect_rel := WindowRectAbsToRel(window, ImRect{ _r = {window.InnerRect.Min - ImVec2{1, 1}, window.InnerRect.Max + ImVec2{1, 1}}});

        // Take account of changing scroll to handle triggering a new move request on a scrolling frame. (#6171)
        // Otherwise 'inner_rect_rel' would be off on the move result frame.
        inner_rect_rel.Translate(CalcNextScrollFromScrollTargetAndClamp(window) - window.Scroll);

        if ((clamp_x || clamp_y) && !inner_rect_rel.Contains(window.NavRectRel[g.NavLayer]))
        {
            IMGUI_DEBUG_LOG_NAV("[nav] NavMoveRequest: clamp NavRectRel for gamepad move\n");
            pad_x := ImMin(inner_rect_rel.GetWidth(), window.CalcFontSize() * 0.5);
            pad_y := ImMin(inner_rect_rel.GetHeight(), window.CalcFontSize() * 0.5); // Terrible approximation for the intent of starting navigation from first fully visible item
            inner_rect_rel.Min.x = clamp_x ? (inner_rect_rel.Min.x + pad_x) : -math.F32_MAX;
            inner_rect_rel.Max.x = clamp_x ? (inner_rect_rel.Max.x - pad_x) : +math.F32_MAX;
            inner_rect_rel.Min.y = clamp_y ? (inner_rect_rel.Min.y + pad_y) : -math.F32_MAX;
            inner_rect_rel.Max.y = clamp_y ? (inner_rect_rel.Max.y - pad_y) : +math.F32_MAX;
            window.NavRectRel[g.NavLayer].ClipWithFull(inner_rect_rel);
            g.NavId = 0;
        }
    }

    // For scoring we use a single segment on the left side our current item bounding box (not touching the edge to avoid box overlap with zero-spaced items)
    scoring_rect : ImRect
    if (window != nil)
    {
        nav_rect_rel := !window.NavRectRel[g.NavLayer].IsInverted() ? window.NavRectRel[g.NavLayer] : ImRect{ _r = {0, 0, 0, 0}};
        scoring_rect = WindowRectRelToAbs(window, nav_rect_rel);
        scoring_rect.TranslateY(scoring_rect_offset_y);
        if (g.NavMoveSubmitted) {
            NavBiasScoringRect(scoring_rect, window.RootWindowForNav.NavPreferredScoringPosRel[g.NavLayer], g.NavMoveDir, g.NavMoveFlags);
        }
        assert(!scoring_rect.IsInverted()); // Ensure we have a non-inverted bounding box here will allow us to remove extraneous ImAbs() calls in NavScoreItem().
        //AddRect(GetForegroundDrawList(), scoring_rect.Min, scoring_rect.Max, IM_COL32(255,200,0,255)); // [DEBUG]
        //if (!g.NavScoringNoClipRect.IsInverted()) { AddRect(GetForegroundDrawList(), g.NavScoringNoClipRect.Min, g.NavScoringNoClipRect.Max, IM_COL32(255, 200, 0, 255)); } // [DEBUG]
    }
    g.NavScoringRect = scoring_rect;
    g.NavScoringNoClipRect.Add(scoring_rect);
}

NavUpdateCreateTabbingRequest :: proc()
{
    g := GImGui;
    window := g.NavWindow;
    assert(g.NavMoveDir == nil);
    if (window == nil || g.NavWindowingTarget != nil || (.NoNavInputs in window.Flags))   do return

    tab_pressed := IsKeyPressed(ImGuiKey.Tab, ImGuiInputFlags_Repeat, ImGuiKeyOwner_NoOwner) && !g.IO.KeyCtrl && !g.IO.KeyAlt;
    if (!tab_pressed)   do return

    // Initiate tabbing request
    // (this is ALWAYS ENABLED, regardless of ImGuiConfigFlags_NavEnableKeyboard flag!)
    // See NavProcessItemForTabbingRequest() for a description of the various forward/backward tabbing cases with and without wrapping.
    nav_keyboard_active := (.NavEnableKeyboard in g.IO.ConfigFlags) != 0;
    if (nav_keyboard_active) {
        g.NavTabbingDir = g.IO.KeyShift ? -1 : (g.NavCursorVisible == false && g.ActiveId == 0) ? 0 : +1;
    }
    else {
        g.NavTabbingDir = g.IO.KeyShift ? -1 : (g.ActiveId == 0) ? 0 : +1;
    }
    move_flags := ImGuiNavMoveFlags_IsTabbing | ImGuiNavMoveFlags_Activate;
    scroll_flags := window.Appearing ? ImGuiScrollFlags_KeepVisibleEdgeX | ImGuiScrollFlags_AlwaysCenterY : ImGuiScrollFlags_KeepVisibleEdgeX | ImGuiScrollFlags_KeepVisibleEdgeY;
    clip_dir := (g.NavTabbingDir < 0) ? ImGuiDir.Up : ImGuiDir.Down;
    NavMoveRequestSubmit(nil, clip_dir, move_flags, scroll_flags); // FIXME-NAV: Once we refactor tabbing, add LegacyApi flag to not activate non-inputable.
    g.NavTabbingCounter = -1;
}

// Apply result from previous frame navigation directional move request. Always called from NavUpdate()
NavMoveRequestApplyResult :: proc()
{
    g := GImGui;
when IMGUI_DEBUG_NAV_SCORING {
    if (.DebugNoResult in g.NavMoveFlags) do return // [DEBUG] Scoring all items in NavWindow at all times
}

    // Select which result to use
    result := (g.NavMoveResultLocal.ID != 0) ? &g.NavMoveResultLocal : (g.NavMoveResultOther.ID != 0) ? &g.NavMoveResultOther : nil;

    // Tabbing forward wrap
    if ((.IsTabbing in g.NavMoveFlags) && result == nil) {
        if ((g.NavTabbingCounter == 1 || g.NavTabbingDir == 0) && g.NavTabbingResultFirst.ID) {
            result = &g.NavTabbingResultFirst;
        }
    }

    // In a situation when there are no results but NavId != 0, re-enable the Navigation highlight (because g.NavId is not considered as a possible result)
    axis := (g.NavMoveDir == ImGuiDir.Up || g.NavMoveDir == ImGuiDir.Down) ? ImGuiAxis.Y : ImGuiAxis.X;
    if (result == nil)
    {
        if (.IsTabbing in g.NavMoveFlags) {
            g.NavMoveFlags |= ImGuiNavMoveFlags_NoSetNavCursorVisible;
        }
        if (g.NavId != 0 && (.NoSetNavCursorVisible not_in g.NavMoveFlags)) {
            SetNavCursorVisibleAfterMove();
        }
        NavClearPreferredPosForAxis(axis); // On a failed move, clear preferred pos for this axis.
        IMGUI_DEBUG_LOG_NAV("[nav] NavMoveSubmitted but not led to a result!\n");
        return;
    }

    // PageUp/PageDown behavior first jumps to the bottom/top mostly visible item, _otherwise_ use the result from the previous/next page.
    if (.AlsoScoreVisibleSet in g.NavMoveFlags) {
        if (g.NavMoveResultLocalVisible.ID != 0 && g.NavMoveResultLocalVisible.ID != g.NavId) {
            result = &g.NavMoveResultLocalVisible;
        }
    }

    // Maybe entering a flattened child from the outside? In this case solve the tie using the regular scoring rules.
    if (result != &g.NavMoveResultOther && g.NavMoveResultOther.ID != 0 && g.NavMoveResultOther.Window.ParentWindow == g.NavWindow) {
        if ((g.NavMoveResultOther.DistBox < result.DistBox) || (g.NavMoveResultOther.DistBox == result.DistBox && g.NavMoveResultOther.DistCenter < result.DistCenter)) {
            result = &g.NavMoveResultOther;
        }
    }
    assert(g.NavWindow && result.Window);

    // Scroll to keep newly navigated item fully into view.
    if (g.NavLayer == ImGuiNavLayer_Main)
    {
        rect_abs := WindowRectRelToAbs(result.Window, result.RectRel);
        ScrollToRectEx(result.Window, rect_abs, g.NavMoveScrollFlags);

        if (.ScrollToEdgeY in g.NavMoveFlags)
        {
            // FIXME: Should remove this? Or make more precise: use ScrollToRectEx() with edge?
            scroll_target := (g.NavMoveDir == ImGuiDir.Up) ? result.Window.ScrollMax.y : 0.0;
            SetScrollY(result.Window, scroll_target);
        }
    }

    if (g.NavWindow != result.Window)
    {
        IMGUI_DEBUG_LOG_FOCUS("[focus] NavMoveRequest: SetNavWindow(\"%s\")\n", result.Window.Name);
        g.NavWindow = result.Window;
        g.NavLastValidSelectionUserData = ImGuiSelectionUserData_Invalid;
    }

    // Clear active id unless requested not to
    // FIXME: ImGuiNavMoveFlags_NoClearActiveId is currently unused as we don't have a clear strategy to preserve active id after interaction,
    // so this is mostly provided as a gateway for further experiments (see #1418, #2890)
    if (g.ActiveId != result.ID && (.NoClearActiveId not_in g.NavMoveFlags))   do ClearActiveID()

    // Don't set NavJustMovedToId if just landed on the same spot (which may happen with ImGuiNavMoveFlags_AllowCurrentNavId)
    // PageUp/PageDown however sets always set NavJustMovedTo (vs Home/End which doesn't) mimicking Windows behavior.
    if ((g.NavId != result.ID || (.IsPageMove in g.NavMoveFlags)) && (.NoSelect not_in g.NavMoveFlags))
    {
        g.NavJustMovedFromFocusScopeId = g.NavFocusScopeId;
        g.NavJustMovedToId = result.ID;
        g.NavJustMovedToFocusScopeId = result.FocusScopeId;
        g.NavJustMovedToKeyMods = g.NavMoveKeyMods;
        g.NavJustMovedToIsTabbing = (.IsTabbing in g.NavMoveFlags) != 0;
        g.NavJustMovedToHasSelectionData = (.HasSelectionUserData in result.ItemFlags) != 0;
        //IMGUI_DEBUG_LOG_NAV("[nav] NavJustMovedFromFocusScopeId = 0x%08X, NavJustMovedToFocusScopeId = 0x%08X\n", g.NavJustMovedFromFocusScopeId, g.NavJustMovedToFocusScopeId);
    }

    // Apply new NavID/Focus
    IMGUI_DEBUG_LOG_NAV("[nav] NavMoveRequest: result NavID 0x%08X in Layer %d Window \"%s\"\n", result.ID, g.NavLayer, g.NavWindow.Name);
    preferred_scoring_pos_rel := g.NavWindow.RootWindowForNav.NavPreferredScoringPosRel[g.NavLayer];
    SetNavID(result.ID, g.NavLayer, result.FocusScopeId, result.RectRel);
    if (result.SelectionUserData != ImGuiSelectionUserData_Invalid) {
        g.NavLastValidSelectionUserData = result.SelectionUserData;
    }

    // Restore last preferred position for current axis
    // (storing in RootWindowForNav-> as the info is desirable at the beginning of a Move Request. In theory all storage should use RootWindowForNav..)
    if ((.IsTabbing not_in g.NavMoveFlags))
    {
        preferred_scoring_pos_rel[axis] = result.RectRel.GetCenter()[axis];
        g.NavWindow.RootWindowForNav.NavPreferredScoringPosRel[g.NavLayer] = preferred_scoring_pos_rel;
    }

    // Tabbing: Activates Inputable, otherwise only Focus
    if ((.IsTabbing in g.NavMoveFlags) && (.Inputable not_in result.ItemFlags)) {
        g.NavMoveFlags &= ~ImGuiNavMoveFlags_Activate;
    }

    // Activate
    if (.Activate in g.NavMoveFlags)
    {
        g.NavNextActivateId = result.ID;
        g.NavNextActivateFlags = ImGuiActivateFlags_None;
        if (.IsTabbing in g.NavMoveFlags) {
            g.NavNextActivateFlags |= ImGuiActivateFlags_PreferInput | ImGuiActivateFlags_TryToPreserveState | ImGuiActivateFlags_FromTabbing;
        }
    }

    // Make nav cursor visible
    if ((.NoSetNavCursorVisible not_in g.NavMoveFlags)) {
        SetNavCursorVisibleAfterMove();
    }
}

// Process Escape/NavCancel input (to close a popup, get back to parent, clear focus)
// FIXME: In order to support e.g. Escape to clear a selection we'll need:
// - either to store the equivalent of ActiveIdUsingKeyInputMask for a FocusScope and test for it.
// - either to move most/all of those tests to the epilogue/end functions of the scope they are dealing with (e.g. exit child window in EndChild()) or in EndFrame(), to allow an earlier intercept
NavUpdateCancelRequest :: proc()
{
    g := GImGui;
    nav_gamepad_active := (.NavEnableGamepad in g.IO.ConfigFlags) != 0 && (.HasGamepad in g.IO.BackendFlags) != 0;
    nav_keyboard_active := (.NavEnableKeyboard in g.IO.ConfigFlags) != 0;
    if (!(nav_keyboard_active && IsKeyPressed(ImGuiKey.Escape, 0, ImGuiKeyOwner_NoOwner)) && !(nav_gamepad_active && IsKeyPressed(ImGuiKey.NavGamepadCancel, 0, ImGuiKeyOwner_NoOwner)))   do return

    IMGUI_DEBUG_LOG_NAV("[nav] NavUpdateCancelRequest()\n");
    if (g.ActiveId != 0)
    {
        ClearActiveID();
    }
    else if (g.NavLayer != ImGuiNavLayer_Main)
    {
        // Leave the "menu" layer
        NavRestoreLayer(ImGuiNavLayer_Main);
        SetNavCursorVisibleAfterMove();
    }
    else if (g.NavWindow && g.NavWindow != g.NavWindow.RootWindow && !(g.NavWindow.RootWindowForNav.Flags & ImGuiWindowFlags_Popup) && g.NavWindow.RootWindowForNav.ParentWindow)
    {
        // Exit child window
        child_window := g.NavWindow.RootWindowForNav;
        parent_window := child_window.ParentWindow;
        assert(child_window.ChildId != 0);
        FocusWindow(parent_window);
        SetNavID(child_window.ChildId, ImGuiNavLayer_Main, 0, WindowRectAbsToRel(parent_window, child_Rect(window)));
        SetNavCursorVisibleAfterMove();
    }
    else if (len(g.OpenPopupStack) > 0 && g.OpenPopupStack.back().Window != nil && !(g.OpenPopupStack.back().Window.Flags & ImGuiWindowFlags_Modal))
    {
        // Close open popup/menu
        ClosePopupToLevel(len(g.OpenPopupStack) - 1, true);
    }
    else
    {
        // Clear NavLastId for popups but keep it for regular child window so we can leave one and come back where we were
        // FIXME-NAV: This should happen on window appearing.
        if (g.IO.ConfigNavEscapeClearFocusItem || g.IO.ConfigNavEscapeClearFocusWindow) {
            if (g.NavWindow && ((.Popup in g.NavWindow.Flags))) {// || !(g.NavWindow.Flags & ImGuiWindowFlags_ChildWindow)))
                g.NavWindow.NavLastIds[0] = 0;
            }
        }

        // Clear nav focus
        if (g.IO.ConfigNavEscapeClearFocusItem || g.IO.ConfigNavEscapeClearFocusWindow)   do g.NavId = 0
        if (g.IO.ConfigNavEscapeClearFocusWindow)   do FocusWindow(nil)
    }
}

// Handle PageUp/PageDown/Home/End keys
// Called from NavUpdateCreateMoveRequest() which will use our output to create a move request
// FIXME-NAV: This doesn't work properly with NavFlattened siblings as we use NavWindow rectangle for reference
// FIXME-NAV: how to get Home/End to aim at the beginning/end of a 2D grid?
NavUpdatePageUpPageDown :: proc() -> f32
{
    g := GImGui;
    window := g.NavWindow;
    if ((.NoNavInputs in window.Flags) || g.NavWindowingTarget != nil)   do return 0.0

    page_up_held := IsKeyDown(ImGuiKey.PageUp, ImGuiKeyOwner_NoOwner);
    page_down_held := IsKeyDown(ImGuiKey.PageDown, ImGuiKeyOwner_NoOwner);
    home_pressed := IsKeyPressed(ImGuiKey.Home, ImGuiInputFlags_Repeat, ImGuiKeyOwner_NoOwner);
    end_pressed := IsKeyPressed(ImGuiKey.End, ImGuiInputFlags_Repeat, ImGuiKeyOwner_NoOwner);
    if (page_up_held == page_down_held && home_pressed == end_pressed) { // Proceed if either (not both) are pressed, otherwise early out
        return 0.0;
    }

    if (g.NavLayer != ImGuiNavLayer_Main) {
        NavRestoreLayer(ImGuiNavLayer_Main);
    }

    if (window.DC.NavLayersActiveMask == 0x00 && window.DC.NavWindowHasScrollY)
    {
        // Fallback manual-scroll when window has no navigable item
        if (IsKeyPressed(ImGuiKey.PageUp, ImGuiInputFlags_Repeat, ImGuiKeyOwner_NoOwner)) {
            SetScrollY(window, window.Scroll.y - GetHeight(window.InnerRect));
        }
        else if (IsKeyPressed(ImGuiKey.PageDown, ImGuiInputFlags_Repeat, ImGuiKeyOwner_NoOwner)) {
            SetScrollY(window, window.Scroll.y + GetHeight(window.InnerRect));
        }
        else if (home_pressed)   do SetScrollY(window, 0.0)
        else if (end_pressed) {
            SetScrollY(window, window.ScrollMax.y);
        }
    }
    else
    {
        nav_rect_rel := &window.NavRectRel[g.NavLayer];
        page_offset_y := ImMax(0.0, GetHeight(window.InnerRect) - window.CalcFontSize() * 1.0 + nav_rect_rel.GetHeight());
        nav_scoring_rect_offset_y := 0.0;
        if (IsKeyPressed(ImGuiKey.PageUp, true))
        {
            nav_scoring_rect_offset_y = -page_offset_y;
            g.NavMoveDir = ImGuiDir.Down; // Because our scoring rect is offset up, we request the down direction (so we can always land on the last item)
            g.NavMoveClipDir = ImGuiDir.Up;
            g.NavMoveFlags = ImGuiNavMoveFlags_AllowCurrentNavId | ImGuiNavMoveFlags_AlsoScoreVisibleSet | ImGuiNavMoveFlags_IsPageMove;
        }
        else if (IsKeyPressed(ImGuiKey.PageDown, true))
        {
            nav_scoring_rect_offset_y = +page_offset_y;
            g.NavMoveDir = ImGuiDir.Up; // Because our scoring rect is offset down, we request the up direction (so we can always land on the last item)
            g.NavMoveClipDir = ImGuiDir.Down;
            g.NavMoveFlags = ImGuiNavMoveFlags_AllowCurrentNavId | ImGuiNavMoveFlags_AlsoScoreVisibleSet | ImGuiNavMoveFlags_IsPageMove;
        }
        else if (home_pressed)
        {
            // FIXME-NAV: handling of Home/End is assuming that the top/bottom most item will be visible with Scroll.y == 0/ScrollMax.y
            // Scrolling will be handled via the ImGuiNavMoveFlags_ScrollToEdgeY flag, we don't scroll immediately to avoid scrolling happening before nav result.
            // Preserve current horizontal position if we have any.
            nav_rect_rel.Max.y = 0.0;
            nav_rect_rel.Min.y = 0
            if (nav_rect_rel.IsInverted()) {
                nav_rect_rel.Max.x = 0.0;
                nav_rect_rel.Min.x = 0
            }
            g.NavMoveDir = ImGuiDir.Down;
            g.NavMoveFlags = ImGuiNavMoveFlags_AllowCurrentNavId | ImGuiNavMoveFlags_ScrollToEdgeY;
            // FIXME-NAV: MoveClipDir left to _None, intentional?
        }
        else if (end_pressed)
        {
            nav_rect_rel.Max.y = window.ContentSize.y;
            nav_rect_rel.Min.y = window.ContentSize.y;
            if (nav_rect_rel.IsInverted()) {
                nav_rect_rel.Max.x = 0.0;
                nav_rect_rel.Min.x = 0
            }
            g.NavMoveDir = ImGuiDir.Up;
            g.NavMoveFlags = ImGuiNavMoveFlags_AllowCurrentNavId | ImGuiNavMoveFlags_ScrollToEdgeY;
            // FIXME-NAV: MoveClipDir left to _None, intentional?
        }
        return nav_scoring_rect_offset_y;
    }
    return 0.0;
}

NavEndFrame :: proc()
{
    g := GImGui;

    // Show CTRL+TAB list window
    if (g.NavWindowingTarget != nil) {
        NavUpdateWindowingOverlay();
    }

    // Perform wrap-around in menus
    // FIXME-NAV: Wrap may need to apply a weight bias on the other axis. e.g. 4x4 grid with 2 last items missing on last item won't handle LoopY/WrapY correctly.
    // FIXME-NAV: Wrap (not Loop) support could be handled by the scoring function and then WrapX would function without an extra frame.
    if (g.NavWindow && NavMoveRequestButNoResultYet() && (g.NavMoveFlags & ImGuiNavMoveFlags_WrapMask_) && (.Forwarded not_in g.NavMoveFlags)) {
        NavUpdateCreateWrappingRequest();
    }
}

NavUpdateCreateWrappingRequest :: proc()
{
    g := GImGui;
    window := g.NavWindow;

    do_forward := false;
    bb_rel := window.NavRectRel[g.NavLayer];
    clip_dir := g.NavMoveDir;

    move_flags := g.NavMoveFlags;
    //const ImGuiAxis move_axis = (g.NavMoveDir == ImGuiDir.Up || g.NavMoveDir == ImGuiDir.Down) ? ImGuiAxis.Y : ImGuiAxis.X;
    if (g.NavMoveDir == .Left && (move_flags & (ImGuiNavMoveFlags_WrapX | ImGuiNavMoveFlags_LoopX)))
    {
        bb_rel.Max.x = window.ContentSize.x + window.WindowPadding.x;
        bb_rel.Min.x = bb_rel.Max.x
        if (.WrapX in move_flags)
        {
            bb_rel.TranslateY(-bb_rel.GetHeight()); // Previous row
            clip_dir = ImGuiDir.Up;
        }
        do_forward = true;
    }
    if (g.NavMoveDir == .Right && (move_flags & (ImGuiNavMoveFlags_WrapX | ImGuiNavMoveFlags_LoopX)))
    {
        bb_rel.Max.x = -window.WindowPadding.x;
        bb_rel.Min.x = bb_rel.Max.x
        if (.WrapX in move_flags)
        {
            bb_rel.TranslateY(+bb_rel.GetHeight()); // Next row
            clip_dir = ImGuiDir.Down;
        }
        do_forward = true;
    }
    if (g.NavMoveDir == ImGuiDir.Up && (move_flags & (ImGuiNavMoveFlags_WrapY | ImGuiNavMoveFlags_LoopY)))
    {
        bb_rel.Max.y = window.ContentSize.y + window.WindowPadding.y;
        bb_rel.Min.y = bb_rel.Max.y
        if (.WrapY in move_flags)
        {
            bb_rel.TranslateX(-bb_rel.GetWidth()); // Previous column
            clip_dir = .Left;
        }
        do_forward = true;
    }
    if (g.NavMoveDir == ImGuiDir.Down && (move_flags & (ImGuiNavMoveFlags_WrapY | ImGuiNavMoveFlags_LoopY)))
    {
        bb_rel.Max.y = -window.WindowPadding.y;
        bb_rel.Min.y = bb_rel.Max.y
        if (.WrapY in move_flags)
        {
            bb_rel.TranslateX(+bb_rel.GetWidth()); // Next column
            clip_dir = .Right;
        }
        do_forward = true;
    }
    if (!do_forward)   do return
    window.NavRectRel[g.NavLayer] = bb_rel;
    NavClearPreferredPosForAxis(ImGuiAxis.X);
    NavClearPreferredPosForAxis(ImGuiAxis.Y);
    NavMoveRequestForward(g.NavMoveDir, clip_dir, move_flags, g.NavMoveScrollFlags);
}

// Can we focus this window with CTRL+TAB (or PadMenu + PadFocusPrev/PadFocusNext)
// Note that NoNavFocus makes the window not reachable with CTRL+TAB but it can still be focused with mouse or programmatically.
// If you want a window to never be focused, you may use the e.g. NoInputs flag.
IsWindowNavFocusable :: proc(window : ^ImGuiWindow) -> bool
{
    return window.WasActive && window == window.RootWindow && !(.NoNavFocus in window.Flags);
}

FindWindowNavFocusable :: proc(i_start : i32, i_stop : i32, dir : i32) -> ^ImGuiWindow // FIXME-OPT O(N)
{
    g := GImGui;
    for i := i_start; i >= 0 && i < len(g.WindowsFocusOrder) && i != i_stop; i += dir {
        if (IsWindowNavFocusable(g.WindowsFocusOrder[i]))   do return g.WindowsFocusOrder[i]
    }
    return nil;
}

NavUpdateWindowingTarget :: proc(focus_change_dir : i32)
{
    g := GImGui;
    assert(g.NavWindowingTarget);
    if (.Modal in g.NavWindowingTarget.Flags)   do return

    i_current := FindWindowFocusIndex(g.NavWindowingTarget);
    window_target := FindWindowNavFocusable(i_current + focus_change_dir, -INT_MAX, focus_change_dir);
    if (!window_target) {
        window_target = FindWindowNavFocusable((focus_change_dir < 0) ? (len(g.WindowsFocusOrder) - 1) : 0, i_current, focus_change_dir);
    }
    if (window_target) // Don't reset windowing target if there's a single window in the list
    {
        g.NavWindowingTargetAnim = window_target;
        g.NavWindowingTarget = window_target;
        g.NavWindowingAccumDeltaSize = {};
        g.NavWindowingAccumDeltaPos = {}
    }
    g.NavWindowingToggleLayer = false;
}

// Windowing management mode
// Keyboard: CTRL+Tab (change focus/move/resize), Alt (toggle menu layer)
// Gamepad:  Hold Menu/Square (change focus/move/resize), Tap Menu/Square (toggle menu layer)
NavUpdateWindowing :: proc()
{
    g := GImGui;
    io := &g.IO;

    apply_focus_window := nil;
    apply_toggle_layer := false;

    modal_window := GetTopMostPopupModal();
    allow_windowing := (modal_window == nil); // FIXME: This prevent CTRL+TAB from being usable with windows that are inside the Begin-stack of that modal.
    if (!allow_windowing) {
        g.NavWindowingTarget = nil;
    }

    // Fade out
    if (g.NavWindowingTargetAnim && g.NavWindowingTarget == nil)
    {
        g.NavWindowingHighlightAlpha = ImMax(g.NavWindowingHighlightAlpha - io.DeltaTime * 10.0, 0.0);
        if (g.DimBgRatio <= 0.0 && g.NavWindowingHighlightAlpha <= 0.0) {
            g.NavWindowingTargetAnim = nil;
        }
    }

    // Start CTRL+Tab or Square+L/R window selection
    // (g.ConfigNavWindowingKeyNext/g.ConfigNavWindowingKeyPrev defaults are ImGuiKey.Mod_Ctrl|ImGuiKey.Tab and ImGuiKey.Mod_Ctrl|ImGuiKey.Mod_Shift|ImGuiKey.Tab)
    owner_id := ImHashStr("###NavUpdateWindowing");
    nav_gamepad_active := (.NavEnableGamepad in io.ConfigFlags) != 0 && (.HasGamepad in io.BackendFlags) != 0;
    nav_keyboard_active := (.NavEnableKeyboard in io.ConfigFlags) != 0;
    keyboard_next_window := allow_windowing && g.ConfigNavWindowingKeyNext && Shortcut(g.ConfigNavWindowingKeyNext, ImGuiInputFlags_Repeat | ImGuiInputFlags_RouteAlways, owner_id);
    keyboard_prev_window := allow_windowing && g.ConfigNavWindowingKeyPrev && Shortcut(g.ConfigNavWindowingKeyPrev, ImGuiInputFlags_Repeat | ImGuiInputFlags_RouteAlways, owner_id);
    start_windowing_with_gamepad := allow_windowing && nav_gamepad_active && !g.NavWindowingTarget && IsKeyPressed(ImGuiKey.NavGamepadMenu, ImGuiInputFlags_None);
    start_windowing_with_keyboard := allow_windowing && !g.NavWindowingTarget && (keyboard_next_window || keyboard_prev_window); // Note: enabled even without NavEnableKeyboard!
    just_started_windowing_from_null_focus := false;
    if (start_windowing_with_gamepad || start_windowing_with_keyboard) {
        if window := g.NavWindow ? g.NavWindow : FindWindowNavFocusable(len(g.WindowsFocusOrder) - 1, -INT_MAX, -1); window != nil
        {
            g.NavWindowingTargetAnim = window.RootWindow; // Current location
            g.NavWindowingTarget = window.RootWindow
            g.NavWindowingHighlightAlpha = 0.0;
            g.NavWindowingTimer = 0
            g.NavWindowingAccumDeltaSize = {};
            g.NavWindowingAccumDeltaPos = {}
            g.NavWindowingToggleLayer = start_windowing_with_gamepad ? true : false; // Gamepad starts toggling layer
            g.NavInputSource = start_windowing_with_keyboard ? .Keyboard : .Gamepad;
            if (g.NavWindow == nil) {
                just_started_windowing_from_null_focus = true;
            }

            // Manually register ownership of our mods. Using a global route in the Shortcut() calls instead would probably be correct but may have more side-effects.
            if (keyboard_next_window || keyboard_prev_window) {
                SetKeyOwnersForKeyChord((g.ConfigNavWindowingKeyNext | g.ConfigNavWindowingKeyPrev) & ImGuiKey.Mod_Mask_, owner_id);
            }
        }
    }

    // Gamepad update
    g.NavWindowingTimer += io.DeltaTime;
    if (g.NavWindowingTarget && g.NavInputSource == .Gamepad)
    {
        // Highlight only appears after a brief time holding the button, so that a fast tap on PadMenu (to toggle NavLayer) doesn't add visual noise
        g.NavWindowingHighlightAlpha = ImMax(g.NavWindowingHighlightAlpha, ImSaturate((g.NavWindowingTimer - NAV_WINDOWING_HIGHLIGHT_DELAY) / 0.05));

        // Select window to focus
        focus_change_dir := cast(i32) IsKeyPressed(ImGuiKey.GamepadL1) - cast(i32) IsKeyPressed(ImGuiKey.GamepadR1);
        if (focus_change_dir != 0 && !just_started_windowing_from_null_focus)
        {
            NavUpdateWindowingTarget(focus_change_dir);
            g.NavWindowingHighlightAlpha = 1.0;
        }

        // Single press toggles NavLayer, long press with L/R apply actual focus on release (until then the window was merely rendered top-most)
        if (!IsKeyDown(ImGuiKey.NavGamepadMenu))
        {
            g.NavWindowingToggleLayer &= (g.NavWindowingHighlightAlpha < 1.0); // Once button was held long enough we don't consider it a tap-to-toggle-layer press anymore.
            if (g.NavWindowingToggleLayer && g.NavWindow)   do apply_toggle_layer = true
            else if (!g.NavWindowingToggleLayer) {
                apply_focus_window = g.NavWindowingTarget;
            }
            g.NavWindowingTarget = nil;
        }
    }

    // Keyboard: Focus
    if (g.NavWindowingTarget && g.NavInputSource == .Keyboard)
    {
        // Visuals only appears after a brief time after pressing TAB the first time, so that a fast CTRL+TAB doesn't add visual noise
        shared_mods := ((g.ConfigNavWindowingKeyNext ? g.ConfigNavWindowingKeyNext : ImGuiKey.Mod_Mask_) & (g.ConfigNavWindowingKeyPrev ? g.ConfigNavWindowingKeyPrev : ImGuiKey.Mod_Mask_)) & ImGuiKey.Mod_Mask_;
        assert(shared_mods != 0); // Next/Prev shortcut currently needs a shared modifier to "hold", otherwise Prev actions would keep cycling between two windows.
        g.NavWindowingHighlightAlpha = ImMax(g.NavWindowingHighlightAlpha, ImSaturate((g.NavWindowingTimer - NAV_WINDOWING_HIGHLIGHT_DELAY) / 0.05)); // 1.0f
        if ((keyboard_next_window || keyboard_prev_window) && !just_started_windowing_from_null_focus) {
            NavUpdateWindowingTarget(keyboard_next_window ? -1 : +1);
        }
        else if ((io.KeyMods & shared_mods) != shared_mods) {
            apply_focus_window = g.NavWindowingTarget;
        }
    }

    // Keyboard: Press and Release ALT to toggle menu layer
    windowing_toggle_keys := [?]ImGuiKey { ImGuiKey.LeftAlt, ImGuiKey.RightAlt };
    windowing_toggle_layer_start := false;
    if (g.NavWindow != nil && !(.NoNavInputs in g.NavWindow.Flags)) {
        for windowing_toggle_key in windowing_toggle_keys {
            if (nav_keyboard_active && IsKeyPressed(windowing_toggle_key, 0, ImGuiKeyOwner_NoOwner))
            {
                windowing_toggle_layer_start = true;
                g.NavWindowingToggleLayer = true;
                g.NavWindowingToggleKey = windowing_toggle_key;
                g.NavInputSource = .Keyboard;
                break;
            }
        }
    }
    if (g.NavWindowingToggleLayer && g.NavInputSource == .Keyboard)
    {
        // We cancel toggling nav layer when any text has been typed (generally while holding Alt). (See #370)
        // We cancel toggling nav layer when other modifiers are pressed. (See #4439)
        // - AltGR is Alt+Ctrl on some layout but we can't reliably detect it (not all backends/systems/layout emit it as Alt+Ctrl).
        // We cancel toggling nav layer if an owner has claimed the key.
        if (len(io.InputQueueCharacters) > 0 || io.KeyCtrl || io.KeyShift || io.KeySuper) {
            g.NavWindowingToggleLayer = false;
        }
        else if (windowing_toggle_layer_start == false && g.LastKeyboardKeyPressTime == g.Time) {
            g.NavWindowingToggleLayer = false;
        }
        else if (TestKeyOwner(g.NavWindowingToggleKey, ImGuiKeyOwner_NoOwner) == false || TestKeyOwner(ImGuiKey.Mod_Alt, ImGuiKeyOwner_NoOwner) == false) {
            g.NavWindowingToggleLayer = false;
        }

        // Apply layer toggle on Alt release
        // Important: as before version <18314 we lacked an explicit IO event for focus gain/loss, we also compare mouse validity to detect old backends clearing mouse pos on focus loss.
        if (IsKeyReleased(g.NavWindowingToggleKey) && g.NavWindowingToggleLayer) {
            if (g.ActiveId == 0 || g.ActiveIdAllowOverlap) {
                if (IsMousePosValid(&io.MousePos) == IsMousePosValid(&io.MousePosPrev))   do apply_toggle_layer = true
            }
        }
        if (!IsKeyDown(g.NavWindowingToggleKey)) {
            g.NavWindowingToggleLayer = false;
        }
    }

    // Move window
    if (g.NavWindowingTarget && !(.NoMove in g.NavWindowingTarget.Flags))
    {
        nav_move_dir : ImVec2
        if (g.NavInputSource == .Keyboard && !io.KeyShift) {
            nav_move_dir = GetKeyMagnitude2d(ImGuiKey.LeftArrow, ImGuiKey.RightArrow, ImGuiKey.UpArrow, ImGuiKey.DownArrow);
        }

        if (g.NavInputSource == .Gamepad) {
            nav_move_dir = GetKeyMagnitude2d(ImGuiKey.GamepadLStickLeft, ImGuiKey.GamepadLStickRight, ImGuiKey.GamepadLStickUp, ImGuiKey.GamepadLStickDown);
        }

        if (nav_move_dir.x != 0.0 || nav_move_dir.y != 0.0)
        {
            NAV_MOVE_SPEED := 800.0;
            move_step := NAV_MOVE_SPEED * io.DeltaTime * ImMin(io.DisplayFramebufferScale.x, io.DisplayFramebufferScale.y);
            g.NavWindowingAccumDeltaPos += nav_move_dir * move_step;
            g.NavHighlightItemUnderNav = true;
            accum_floored := ImTrunc(g.NavWindowingAccumDeltaPos);
            if (accum_floored.x != 0.0 || accum_floored.y != 0.0)
            {
                moving_window := g.NavWindowingTarget.RootWindowDockTree;
                SetWindowPos(moving_window, moving_window.Pos + accum_floored, { .Always });
                g.NavWindowingAccumDeltaPos -= accum_floored;
            }
        }
    }

    // Apply final focus
    if (apply_focus_window && (g.NavWindow == nil || apply_focus_window != g.NavWindow.RootWindow))
    {
        // FIXME: Many actions here could be part of a higher-level/reused function. Why aren't they in FocusWindow()
        // Investigate for each of them: ClearActiveID(), NavRestoreHighlightAfterMove(), NavRestoreLastChildNavWindow(), ClosePopupsOverWindow(), NavInitWindow()
        previous_viewport := g.NavWindow ? g.NavWindow.Viewport : nil;
        ClearActiveID();
        SetNavCursorVisibleAfterMove();
        ClosePopupsOverWindow(apply_focus_window, false);
        FocusWindow(apply_focus_window, ImGuiFocusRequestFlags_RestoreFocusedChild);
        apply_focus_window = g.NavWindow;
        if (apply_focus_window.NavLastIds[0] == 0) {
            NavInitWindow(apply_focus_window, false);
        }

        // If the window has ONLY a menu layer (no main layer), select it directly
        // Use NavLayersActiveMaskNext since windows didn't have a chance to be Begin()-ed on this frame,
        // so CTRL+Tab where the keys are only held for 1 frame will be able to use correct layers mask since
        // the target window as already been previewed once.
        // FIXME-NAV: This should be done in NavInit.. or in FocusWindow... However in both of those cases,
        // we won't have a guarantee that windows has been visible before and therefore NavLayersActiveMask*
        // won't be valid.
        if (apply_focus_window.DC.NavLayersActiveMaskNext == (1 << ImGuiNavLayer_Menu)) {
            g.NavLayer = ImGuiNavLayer_Menu;
        }


        // Request OS level focus
        if (apply_focus_window.Viewport != previous_viewport && g.PlatformIO.Platform_SetWindowFocus) {
            g.PlatformIO.Platform_SetWindowFocus(apply_focus_window.Viewport);
        }
    }
    if (apply_focus_window) {
        g.NavWindowingTarget = nil;
    }

    // Apply menu/layer toggle
    if (apply_toggle_layer && g.NavWindow)
    {
        ClearActiveID();

        // Move to parent menu if necessary
        new_nav_window := g.NavWindow;
        for (new_nav_window.ParentWindow \
            && (new_nav_window.DC.NavLayersActiveMask & (1 << ImGuiNavLayer_Menu)) == 0 \
            && (.ChildWindow in new_nav_window.Flags) != 0 \
            && (new_nav_window.Flags & (ImGuiWindowFlags_Popup | ImGuiWindowFlags_ChildMenu)) == 0) {
            new_nav_window = new_nav_window.ParentWindow;
        }
        if (new_nav_window != g.NavWindow)
        {
            old_nav_window := g.NavWindow;
            FocusWindow(new_nav_window);
            new_nav_window.NavLastChildNavWindow = old_nav_window;
        }

        // Toggle layer
        new_nav_layer := (g.NavWindow.DC.NavLayersActiveMask & (1 << ImGuiNavLayer_Menu)) ? cast(ImGuiNavLayer)(cast(i32)(g.NavLayer) ~ 1) : ImGuiNavLayer_Main;
        if (new_nav_layer != g.NavLayer)
        {
            // Reinitialize navigation when entering menu bar with the Alt key (FIXME: could be a properly of the layer?)
            preserve_layer_1_nav_id := (new_nav_window.DockNodeAsHost != nil);
            if (new_nav_layer == ImGuiNavLayer_Menu && !preserve_layer_1_nav_id) {
                g.NavWindow.NavLastIds[new_nav_layer] = 0;
            }
            NavRestoreLayer(new_nav_layer);
            SetNavCursorVisibleAfterMove();
        }
    }
}

// Window has already passed the IsWindowNavFocusable()
GetFallbackWindowNameForWindowingList :: proc(window : ^ImGuiWindow) -> ^u8
{
    if (.Popup in window.Flags) {
        return LocalizeGetMsg(ImGuiLocKey_WindowingPopup);
    }
    if ((.MenuBar in window.Flags) && strcmp(window.Name, "##MainMenuBar") == 0) {
        return LocalizeGetMsg(ImGuiLocKey_WindowingMainMenuBar);
    }
    if (window.DockNodeAsHost) {
        return "(Dock node)"; // Not normally shown to user.
    }
    return LocalizeGetMsg(ImGuiLocKey_WindowingUntitled);
}

// Overlay displayed when using CTRL+TAB. Called by EndFrame().
NavUpdateWindowingOverlay :: proc()
{
    g := GImGui;
    assert(g.NavWindowingTarget != nil);

    if (g.NavWindowingTimer < NAV_WINDOWING_LIST_APPEAR_DELAY)   do return

    if (g.NavWindowingListWindow == nil) {
        g.NavWindowingListWindow = FindWindowByName("###NavWindowingList");
    }
    viewport := /*g.NavWindow ? g.NavWindow.Viewport :*/ GetMainViewport();
    SetNextWindowSizeConstraints(ImVec2{viewport.Size.x * 0.20, viewport.Size.y * 0.20}, ImVec2{math.F32_MAX, math.F32_MAX});
    SetNextWindowPos(viewport.GetCenter(), ImGuiCond_Always, ImVec2{0.5, 0.5});
    PushStyleVar(ImGuiStyleVar_WindowPadding, g.Style.WindowPadding * 2.0);
    Begin("###NavWindowingList", nil, ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoFocusOnAppearing | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoInputs | ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoSavedSettings);
    if (g.ContextName[0] != 0) {
        SeparatorText(g.ContextName);
    }
    for n := len(g.WindowsFocusOrder) - 1; n >= 0; n -= 1
    {
        window := g.WindowsFocusOrder[n];
        assert(window != nil); // Fix static analyzers
        if (!IsWindowNavFocusable(window))   do continue
        label := window.Name;
        if (label == FindRenderedText(label)) {
            label = GetFallbackWindowNameForWindowingList(window);
        }
        Selectable(label, g.NavWindowingTarget == window);
    }
    End();
    PopStyleVar();
}

//-----------------------------------------------------------------------------
// [SECTION] DRAG AND DROP
//-----------------------------------------------------------------------------

IsDragDropActive :: proc() -> bool
{
    g := GImGui;
    return g.DragDropActive;
}

ClearDragDrop :: proc()
{
    g := GImGui;
    if (g.DragDropActive) {
        IMGUI_DEBUG_LOG_ACTIVEID(g, "[dragdrop] ClearDragDrop()\n");
    }
    g.DragDropActive = false;
    g.DragDropPayload.Clear();
    g.DragDropAcceptFlags = ImGuiDragDropFlags_None;
    g.DragDropAcceptIdPrev = 0;
    g.DragDropAcceptIdCurr = 0
    g.DragDropAcceptIdCurrRectSurface = math.F32_MAX;
    g.DragDropAcceptFrameCount = -1;

    g.DragDropPayloadBufHeap.clear();
    memset(&g.DragDropPayloadBufLocal, 0, size_of(g.DragDropPayloadBufLocal));
}

BeginTooltipHidden :: proc() -> bool
{
    g := GImGui;
    ret := Begin("##Tooltip_Hidden", nil, ImGuiWindowFlags_Tooltip | ImGuiWindowFlags_NoInputs | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoSavedSettings | ImGuiWindowFlags_AlwaysAutoResize);
    SetWindowHiddenAndSkipItemsForCurrentFrame(g.CurrentWindow);
    return ret;
}

// When this returns true you need to: a) call SetDragDropPayload() exactly once, b) you may render the payload visual/description, c) call EndDragDropSource()
// If the item has an identifier:
// - This assume/require the item to be activated (typically via ButtonBehavior).
// - Therefore if you want to use this with a mouse button other than left mouse button, it is up to the item itself to activate with another button.
// - We then pull and use the mouse button that was used to activate the item and use it to carry on the drag.
// If the item has no identifier:
// - Currently always assume left mouse button.
// [forward declared comment]:
// call after submitting an item which may be dragged. when this return true, you can call SetDragDropPayload() + EndDragDropSource()
BeginDragDropSource :: proc(flags : ImGuiDragDropFlags = {}) -> bool
{
    g := GImGui;
    window := g.CurrentWindow;

    // FIXME-DRAGDROP: While in the common-most "drag from non-zero active id" case we can tell the mouse button,
    // in both SourceExtern and id==0 cases we may requires something else (explicit flags or some heuristic).
    mouse_button := ImGuiMouseButton_Left;

    source_drag_active := false;
    source_id := 0;
    source_parent_id := 0;
    if ((.SourceExtern not_in flags))
    {
        source_id = g.LastItemData.ID;
        if (source_id != 0)
        {
            // Common path: items with ID
            if (g.ActiveId != source_id)   do return false
            if (g.ActiveIdMouseButton != -1) {
                mouse_button = g.ActiveIdMouseButton;
            }
            if (g.IO.MouseDown[mouse_button] == false || window.SkipItems)   do return false
            g.ActiveIdAllowOverlap = false;
        }
        else
        {
            // Uncommon path: items without ID
            if (g.IO.MouseDown[mouse_button] == false || window.SkipItems)   do return false
            if ((.HoveredRect not_in g.LastItemData.StatusFlags) && (g.ActiveId == 0 || g.ActiveIdWindow != window))   do return false

            // If you want to use BeginDragDropSource() on an item with no unique identifier for interaction, such as Text() or Image(), you need to:
            // A) Read the explanation below, B) Use the ImGuiDragDropFlags_SourceAllowNullID flag.
            if (!(.SourceAllowNullID in flags))
            {
                assert(false)
                return false;
            }

            // Magic fallback to handle items with no assigned ID, e.g. Text(), Image()
            // We build a throwaway ID based on current ID stack + relative AABB of items in window.
            // THE IDENTIFIER WON'T SURVIVE ANY REPOSITIONING/RESIZINGG OF THE WIDGET, so if your widget moves your dragging operation will be canceled.
            // We don't need to maintain/call ClearActiveID() as releasing the button will early out this function and trigger !ActiveIdIsAlive.
            // Rely on keeping other window.LastItemXXX fields intact.
            g.LastItemData.ID = window.GetIDFromRectangle(g.LastItemData.Rect);
            source_id = g.LastItemData.ID
            KeepAliveID(source_id);
            is_hovered := ItemHoverable(g.LastItemData.Rect, source_id, g.LastItemData.ItemFlags);
            if (is_hovered && g.IO.MouseClicked[mouse_button])
            {
                SetActiveID(source_id, window);
                FocusWindow(window);
            }
            if (g.ActiveId == source_id) { // Allow the underlying widget to display/return hovered during the mouse release frame, else we would get a flicker.
                g.ActiveIdAllowOverlap = is_hovered;
            }
        }
        if (g.ActiveId != source_id)   do return false
        source_parent_id = window.IDStack.back();
        source_drag_active = IsMouseDragging(mouse_button);

        // Disable navigation and key inputs while dragging + cancel existing request if any
        SetActiveIdUsingAllKeyboardKeys();
    }
    else
    {
        // When ImGuiDragDropFlags_SourceExtern is set:
        window = nil;
        source_id = ImHashStr("#SourceExtern");
        source_drag_active = true;
        mouse_button = g.IO.MouseDown[0] ? 0 : -1;
        KeepAliveID(source_id);
        SetActiveID(source_id, nil);
    }

    assert(g.DragDropWithinTarget == false); // Can't nest BeginDragDropSource() and BeginDragDropTarget()
    if (!source_drag_active)   do return false

    // Activate drag and drop
    if (!g.DragDropActive)
    {
        assert(source_id != 0);
        ClearDragDrop();
        IMGUI_DEBUG_LOG_ACTIVEID(g, "[dragdrop] BeginDragDropSource() DragDropActive = true, source_id = 0x%08X%s\n",
            source_id, (.SourceExtern in flags) ? " (EXTERN)" : "");
        payload := &g.DragDropPayload;
        payload.SourceId = source_id;
        payload.SourceParentId = source_parent_id;
        g.DragDropActive = true;
        g.DragDropSourceFlags = flags;
        g.DragDropMouseButton = mouse_button;
        if (payload.SourceId == g.ActiveId) {
            g.ActiveIdNoClearOnFocusLoss = true;
        }
    }
    g.DragDropSourceFrameCount = g.FrameCount;
    g.DragDropWithinSource = true;

    if (!(.SourceNoPreviewTooltip in flags))
    {
        // Target can request the Source to not display its tooltip (we use a dedicated flag to make this request explicit)
        // We unfortunately can't just modify the source flags and skip the call to BeginTooltip, as caller may be emitting contents.
        ret : bool
        if (g.DragDropAcceptIdPrev && (.AcceptNoPreviewTooltip in g.DragDropAcceptFlags)) {
            ret = BeginTooltipHidden();
        }
        else {
            ret = BeginTooltip();
        }
        assert(ret); // FIXME-NEWBEGIN: If this ever becomes false, we need to Begin("##Hidden", NULL, ImGuiWindowFlags_NoSavedSettings) + SetWindowHiddendAndSkipItemsForCurrentFrame().
        _ = ret;
    }

    if (!(.SourceNoDisableHover in flags) && !(.SourceExtern in flags)) {
        g.LastItemData.StatusFlags &= ~ImGuiItemStatusFlags_HoveredRect;
    }

    return true;
}

// [forward declared comment]:
// only call EndDragDropSource() if BeginDragDropSource() returns true!
EndDragDropSource :: proc()
{
    g := GImGui;
    assert(g.DragDropActive);
    assert(g.DragDropWithinSource, "Not after a BeginDragDropSource()?");

    if (!(.SourceNoPreviewTooltip in g.DragDropSourceFlags))   do EndTooltip()

    // Discard the drag if have not called SetDragDropPayload()
    if (g.DragDropPayload.DataFrameCount == -1)   do ClearDragDrop()
    g.DragDropWithinSource = false;
}

// Use 'cond' to choose to submit payload on drag start or every frame
// [forward declared comment]:
// type is a user defined string of maximum 32 characters. Strings starting with '_' are reserved for dear imgui internal types. Data is copied and held by imgui. Return true when payload has been accepted.
SetDragDropPayload :: proc(type : ^u8, data : rawptr, data_size : int, cond : ImGuiCond = {}) -> bool
{
    g := GImGui;
    payload := &g.DragDropPayload;
    if (cond == 0)   do cond = ImGuiCond_Always

    assert(type != nil);
    assert(strlen(type) < len(payload.DataType), "Payload type can be at most 32 characters long");
    assert((data != nil && data_size > 0) || (data == nil && data_size == 0));
    assert(cond == ImGuiCond_Always || cond == ImGuiCond_Once);
    assert(payload.SourceId != 0); // Not called between BeginDragDropSource() and EndDragDropSource()

    if (cond == ImGuiCond_Always || payload.DataFrameCount == -1)
    {
        // Copy payload
        ImStrncpy(payload.DataType, type, len(payload.DataType));
        g.DragDropPayloadBufHeap.resize(0);
        if (data_size > size_of(g.DragDropPayloadBufLocal))
        {
            // Store in heap
            g.DragDropPayloadBufHeap.resize(cast(i32) data_size);
            payload.Data = g.DragDropPayloadBufHeap.Data;
            memcpy(payload.Data, data, data_size);
        }
        else if (data_size > 0)
        {
            // Store locally
            memset(&g.DragDropPayloadBufLocal, 0, size_of(g.DragDropPayloadBufLocal));
            payload.Data = g.DragDropPayloadBufLocal;
            memcpy(payload.Data, data, data_size);
        }
        else
        {
            payload.Data = nil;
        }
        payload.DataSize = cast(i32) data_size;
    }
    payload.DataFrameCount = g.FrameCount;

    // Return whether the payload has been accepted
    return (g.DragDropAcceptFrameCount == g.FrameCount) || (g.DragDropAcceptFrameCount == g.FrameCount - 1);
}

BeginDragDropTargetCustom :: proc(bb : ^ImRect, id : ImGuiID) -> bool
{
    g := GImGui;
    if (!g.DragDropActive)   do return false

    window := g.CurrentWindow;
    hovered_window := g.HoveredWindowUnderMovingWindow;
    if (hovered_window == nil || window.RootWindowDockTree != hovered_window.RootWindowDockTree)   do return false
    assert(id != 0);
    if (!IsMouseHoveringRect(bb.Min, bb.Max) || (id == g.DragDropPayload.SourceId))   do return false
    if (window.SkipItems)   do return false

    assert(g.DragDropWithinTarget == false && g.DragDropWithinSource == false); // Can't nest BeginDragDropSource() and BeginDragDropTarget()
    g.DragDropTargetRect = bb;
    g.DragDropTargetClipRect = window.ClipRect; // May want to be overridden by user depending on use case?
    g.DragDropTargetId = id;
    g.DragDropWithinTarget = true;
    return true;
}

// We don't use BeginDragDropTargetCustom() and duplicate its code because:
// 1) we use LastItemData's ImGuiItemStatusFlags_HoveredRect which handles items that push a temporarily clip rectangle in their code. Calling BeginDragDropTargetCustom(LastItemRect) would not handle them.
// 2) and it's faster. as this code may be very frequently called, we want to early out as fast as we can.
// Also note how the HoveredWindow test is positioned differently in both functions (in both functions we optimize for the cheapest early out case)
// [forward declared comment]:
// call after submitting an item that may receive a payload. If this returns true, you can call AcceptDragDropPayload() + EndDragDropTarget()
BeginDragDropTarget :: proc() -> bool
{
    g := GImGui;
    if (!g.DragDropActive)   do return false

    window := g.CurrentWindow;
    if (!(.HoveredRect in g.LastItemData.StatusFlags))   do return false
    hovered_window := g.HoveredWindowUnderMovingWindow;
    if (hovered_window == nil || window.RootWindowDockTree != hovered_window.RootWindowDockTree || window.SkipItems)   do return false

    display_rect := (.HasDisplayRect in g.LastItemData.StatusFlags) ? g.LastItemData.DisplayRect : g.LastItemData.Rect;
    id := g.LastItemData.ID;
    if (id == 0)
    {
        id = window.GetIDFromRectangle(display_rect);
        KeepAliveID(id);
    }
    if (g.DragDropPayload.SourceId == id)   do return false

    assert(g.DragDropWithinTarget == false && g.DragDropWithinSource == false); // Can't nest BeginDragDropSource() and BeginDragDropTarget()
    g.DragDropTargetRect = display_rect;
    g.DragDropTargetClipRect = (.HasClipRect in g.LastItemData.StatusFlags) ? g.LastItemData.ClipRect : window.ClipRect;
    g.DragDropTargetId = id;
    g.DragDropWithinTarget = true;
    return true;
}

IsDragDropPayloadBeingAccepted :: proc() -> bool
{
    g := GImGui;
    return g.DragDropActive && g.DragDropAcceptIdPrev != 0;
}

// [forward declared comment]:
// accept contents of a given type. If ImGuiDragDropFlags_AcceptBeforeDelivery is set you can peek into the payload before the mouse button is released.
AcceptDragDropPayload :: proc(type : ^u8, flags : ImGuiDragDropFlags = {}) -> ^ImGuiPayload
{
    g := GImGui;
    payload := &g.DragDropPayload;
    assert(g.DragDropActive);                        // Not called between BeginDragDropTarget() and EndDragDropTarget() ?
    assert(payload.DataFrameCount != -1);            // Forgot to call EndDragDropTarget() ?
    if (type != nil && !payload.IsDataType(type))   do return nil

    // Accept smallest drag target bounding box, this allows us to nest drag targets conveniently without ordering constraints.
    // NB: We currently accept NULL id as target. However, overlapping targets requires a unique ID to function!
    was_accepted_previously := (g.DragDropAcceptIdPrev == g.DragDropTargetId);
    r := g.DragDropTargetRect;
    r_surface := r.GetWidth() * r.GetHeight();
    if (r_surface > g.DragDropAcceptIdCurrRectSurface)   do return nil

    g.DragDropAcceptFlags = flags;
    g.DragDropAcceptIdCurr = g.DragDropTargetId;
    g.DragDropAcceptIdCurrRectSurface = r_surface;
    //IMGUI_DEBUG_LOG("AcceptDragDropPayload(): %08X: accept\n", g.DragDropTargetId);

    // Render default drop visuals
    payload.Preview = was_accepted_previously;
    flags |= (.AcceptNoDrawDefaultRect in g.DragDropSourceFlags); // Source can also inhibit the preview (useful for external sources that live for 1 frame)
    if (!(.AcceptNoDrawDefaultRect in flags) && payload.Preview) {
        RenderDragDropTargetRect(r, g.DragDropTargetClipRect);
    }

    g.DragDropAcceptFrameCount = g.FrameCount;
    if ((.SourceExtern in g.DragDropSourceFlags) && g.DragDropMouseButton == -1) {
        payload.Delivery = was_accepted_previously && (g.DragDropSourceFrameCount < g.FrameCount);
    }
    else {
        payload.Delivery = was_accepted_previously && !IsMouseDown(g.DragDropMouseButton); // For extern drag sources affecting OS window focus, it's easier to just test !IsMouseDown() instead of IsMouseReleased()
    }
    if (!payload.Delivery && !(.AcceptBeforeDelivery in flags))   do return nil

    if (payload.Delivery) {
        IMGUI_DEBUG_LOG_ACTIVEID(g, "[dragdrop] AcceptDragDropPayload(): 0x%08X: payload delivery\n", g.DragDropTargetId);
    }
    return &payload;
}

// FIXME-STYLE FIXME-DRAGDROP: Settle on a proper default visuals for drop target.
RenderDragDropTargetRect :: proc(bb : ^ImRect, item_clip_rect : ^ImRect)
{
    g := GImGui;
    window := g.CurrentWindow;
    bb_display := bb;
    bb_display.ClipWith(item_clip_rect); // Clip THEN expand so we have a way to visualize that target is not entirely visible.
    bb_display.Expand(3.5);
    push_clip_rect := !window.ClipRect.Contains(bb_display);
    if (push_clip_rect) {
        window.DrawList.PushClipRectFullScreen();
    }
    window.DrawList.AddRect(bb_display.Min, bb_display.Max, GetColorU32(ImGuiCol.DragDropTarget), 0.0, 0, 2.0);
    if (push_clip_rect) {
        window.DrawList.PopClipRect();
    }
}

// [forward declared comment]:
// peek directly into the current payload from anywhere. returns NULL when drag and drop is finished or inactive. use ImGuiPayload::IsDataType() to test for the payload type.
GetDragDropPayload :: proc() -> ^ImGuiPayload
{
    g := GImGui;
    return (g.DragDropActive && g.DragDropPayload.DataFrameCount != -1) ? &g.DragDropPayload : nil;
}

// [forward declared comment]:
// only call EndDragDropTarget() if BeginDragDropTarget() returns true!
EndDragDropTarget :: proc()
{
    g := GImGui;
    assert(g.DragDropActive);
    assert(g.DragDropWithinTarget);
    g.DragDropWithinTarget = false;

    // Clear drag and drop state payload right after delivery
    if (g.DragDropPayload.Delivery)   do ClearDragDrop()
}

//-----------------------------------------------------------------------------
// [SECTION] LOGGING/CAPTURING
//-----------------------------------------------------------------------------
// All text output from the interface can be captured into tty/file/clipboard.
// By default, tree nodes are automatically opened during logging.
//-----------------------------------------------------------------------------

// Pass text data straight to log (without being displayed)
LogTextV :: #force_inline proc(g : ^ImGuiContext, fmt : ^u8, args : .. any)
{
    if (g.LogFile)
    {
        g.LogBuffer.Buf.resize(0);
        g.LogBuffer.appendfv(fmt, args);
        ImFileWrite(g.LogBuffer.c_str(), size_of(u8), cast(u64) g.LogBuffer.size(), g.LogFile);
    }
    else
    {
        g.LogBuffer.appendfv(fmt, args);
    }
}

// [forward declared comment]:
// pass text data straight to log (without being displayed)
LogTextV :: proc(fmt : string, args : .. any)
{
    g := GImGui;
    if (!g.LogEnabled)   do return

    LogTextV(g, fmt, args);
}

// Internal version that takes a position to decide on newline placement and pad items according to their depth.
// We split text into individual lines to add current tree level padding
// FIXME: This code is a little complicated perhaps, considering simplifying the whole system.
LogRenderedText :: proc(ref_pos : ^ImVec2, text : string)
{
    g := GImGui;
    window := g.CurrentWindow;

    prefix := g.LogNextPrefix;
    suffix := g.LogNextSuffix;
    g.LogNextSuffix = nil;
    g.LogNextPrefix = nil

    text, _ := FindRenderedText(text);

    log_new_line := ref_pos != nil && (ref_pos.y > g.LogLinePosY + g.Style.FramePadding.y + 1);
    if (ref_pos != nil)   do g.LogLinePosY = ref_pos.y
    if (log_new_line)
    {
        LogText(IM_NEWLINE);
        g.LogLineFirstItem = true;
    }

    if (prefix) {
        LogRenderedText(ref_pos, prefix, prefix + strlen(prefix)); // Calculate end ourself to ensure "##" are included here.
    }

    // Re-adjust padding if we have popped out of our starting depth
    if (g.LogDepthRef > window.DC.TreeDepth) {
        g.LogDepthRef = window.DC.TreeDepth;
    }
    tree_depth := (window.DC.TreeDepth - g.LogDepthRef);

    text_remaining := raw_data(text);
    text_end := end(text)
    for {
        // Split the string. Each new line (after a '\n') is followed by indentation corresponding to the current depth of our log entry.
        // We don't add a trailing \n yet to allow a subsequent item on the same line to be captured.
        line_start := text_remaining;
        line_end := ImStreolRange(line_start, text_end);
        is_last_line := (line_end == text_end);
        if (line_start != line_end || !is_last_line)
        {
            line_length := (i32)(mem.ptr_sub(line_end, line_start));
            indentation := g.LogLineFirstItem ? tree_depth * 4 : 1;
            LogText("%*s%.*s", indentation, "", line_length, line_start);
            g.LogLineFirstItem = false;
            if (line_end^ == '\n')
            {
                LogText(IM_NEWLINE);
                g.LogLineFirstItem = true;
            }
        }
        if (is_last_line)   do break
        text_remaining = line_end + 1;
    }

    if (suffix) do LogRenderedText(ref_pos, suffix, suffix + strlen(suffix));
}

// Start logging/capturing text output
// [forward declared comment]:
// -> BeginCapture() when we design v2 api, for now stay under the radar by using the old name.
LogBegin :: proc(flags : ImGuiLogFlags, auto_open_depth : i32)
{
    g := GImGui;
    window := g.CurrentWindow;
    assert(g.LogEnabled == false);
    assert(g.LogFile == nil && g.LogBuffer.empty());
    assert(math.is_power_of_two(flags & ImGuiLogFlags_OutputMask_)); // Check that only 1 type flag is used

    g.ItemUnclipByLog = true;
    g.LogEnabled = true
    g.LogFlags = flags;
    g.LogWindow = window;
    g.LogNextSuffix = nil;
    g.LogNextPrefix = nil
    g.LogDepthRef = window.DC.TreeDepth;
    g.LogDepthToExpand = ((auto_open_depth >= 0) ? auto_open_depth : g.LogDepthToExpandDefault);
    g.LogLinePosY = math.F32_MAX;
    g.LogLineFirstItem = true;
}

// Important: doesn't copy underlying data, use carefully (prefix/suffix must be in scope at the time of the next LogRenderedText)
LogSetNextTextDecoration :: proc(prefix : ^u8, suffix : ^u8)
{
    g := GImGui;
    g.LogNextPrefix = prefix;
    g.LogNextSuffix = suffix;
}

// [forward declared comment]:
// start logging to tty (stdout)
LogToTTY :: proc(auto_open_depth : i32 = -1)
{
    g := GImGui;
    if (g.LogEnabled)   do return
    _ = auto_open_depth;
when !(IMGUI_DISABLE_TTY_FUNCTIONS) {
    LogBegin(ImGuiLogFlags_OutputTTY, auto_open_depth);
    g.LogFile = stdout;
}
}

// Start logging/capturing text output to given file
// [forward declared comment]:
// start logging to file
LogToFile :: proc(auto_open_depth : i32 = -1, filename : ^u8 = nil)
{
    g := GImGui;
    if (g.LogEnabled)   do return

    // FIXME: We could probably open the file in text mode "at", however note that clipboard/buffer logging will still
    // be subject to outputting OS-incompatible carriage return if within strings the user doesn't use IM_NEWLINE.
    // By opening the file in binary mode "ab" we have consistent output everywhere.
    if (!filename) {
        filename = g.IO.LogFilename;
    }

    if (!filename || !filename[0])   do return
    f := ImFileOpen(filename, "ab");
    if (!f)
    {
        assert(false)
        return;
    }

    LogBegin(ImGuiLogFlags_OutputFile, auto_open_depth);
    g.LogFile = f;
}

// Start logging/capturing text output to clipboard
// [forward declared comment]:
// start logging to OS clipboard
LogToClipboard :: proc(auto_open_depth : i32 = -1)
{
    g := GImGui;
    if (g.LogEnabled)   do return
    LogBegin(ImGuiLogFlags_OutputClipboard, auto_open_depth);
}

// [forward declared comment]:
// Start logging/capturing to internal buffer
LogToBuffer :: proc(auto_open_depth : i32 = -1)
{
    g := GImGui;
    if (g.LogEnabled)   do return
    LogBegin(ImGuiLogFlags_OutputBuffer, auto_open_depth);
}

// [forward declared comment]:
// stop logging (close file, etc.)
LogFinish :: proc()
{
    g := GImGui;
    if (!g.LogEnabled)   do return

    LogText(IM_NEWLINE);
    switch (g.LogFlags & ImGuiLogFlags_OutputMask_)
    {
    case ImGuiLogFlags_OutputTTY:
when !(IMGUI_DISABLE_TTY_FUNCTIONS) {
        fflush(g.LogFile);
}
        break;
    case ImGuiLogFlags_OutputFile:
        ImFileClose(g.LogFile);
        break;
    case ImGuiLogFlags_OutputBuffer:
        break;
    case ImGuiLogFlags_OutputClipboard:
        if (!g.LogBuffer.empty()) {
            SetClipboardText(g.LogBuffer.begin());
        }

        break;
    case:
        assert(false)
        break;
    }

    g.ItemUnclipByLog = false;
    g.LogEnabled = false
    g.LogFlags = ImGuiLogFlags_None;
    g.LogFile = nil;
    g.LogBuffer.clear();
}

// Helper to display logging buttons
// FIXME-OBSOLETE: We should probably obsolete this and let the user have their own helper (this is one of the oldest function alive!)
// [forward declared comment]:
// helper to display buttons for logging to tty/file/clipboard
LogButtons :: proc()
{
    g := GImGui;

    PushID("LogButtons");
when !(IMGUI_DISABLE_TTY_FUNCTIONS) {
    log_to_tty := Button("Log To TTY"); SameLine();
} else {
    log_to_tty := false;
}
    log_to_file := Button("Log To File"); SameLine();
    log_to_clipboard := Button("Log To Clipboard"); SameLine();
    PushItemFlag(ImGuiItemFlags_NoTabStop, true);
    SetNextItemWidth(80.0);
    SliderInt("Default Depth", &g.LogDepthToExpandDefault, 0, 9, nil);
    PopItemFlag();
    PopID();

    // Start logging at the end of the function so that the buttons don't appear in the log
    if (log_to_tty)   do LogToTTY()
    if (log_to_file)   do LogToFile()
    if (log_to_clipboard)   do LogToClipboard()
}

//-----------------------------------------------------------------------------
// [SECTION] SETTINGS
//-----------------------------------------------------------------------------
// - UpdateSettings() [Internal]
// - MarkIniSettingsDirty() [Internal]
// - FindSettingsHandler() [Internal]
// - ClearIniSettings() [Internal]
// - LoadIniSettingsFromDisk()
// - LoadIniSettingsFromMemory()
// - SaveIniSettingsToDisk()
// - SaveIniSettingsToMemory()
//-----------------------------------------------------------------------------
// - CreateNewWindowSettings() [Internal]
// - FindWindowSettingsByID() [Internal]
// - FindWindowSettingsByWindow() [Internal]
// - ClearWindowSettings() [Internal]
// - WindowSettingsHandler_***() [Internal]
//-----------------------------------------------------------------------------

// Called by NewFrame()
UpdateSettings :: proc()
{
    // Load settings on first frame (if not explicitly loaded manually before)
    g := GImGui;
    if (!g.SettingsLoaded)
    {
        assert(g.SettingsWindows.empty());
        if (g.IO.IniFilename) do LoadIniSettingsFromDisk(g.IO.IniFilename);
        g.SettingsLoaded = true;
    }

    // Save settings (with a delay after the last modification, so we don't spam disk too much)
    if (g.SettingsDirtyTimer > 0.0)
    {
        g.SettingsDirtyTimer -= g.IO.DeltaTime;
        if (g.SettingsDirtyTimer <= 0.0)
        {
            if (g.IO.IniFilename != nil) {
                SaveIniSettingsToDisk(g.IO.IniFilename);
            }
            else {
                g.IO.WantSaveIniSettings = true;  // Let user know they can call SaveIniSettingsToMemory(). user will need to clear io.WantSaveIniSettings themselves.
            }
            g.SettingsDirtyTimer = 0.0;
        }
    }
}

MarkIniSettingsDirty :: proc()
{
    g := GImGui;
    if (g.SettingsDirtyTimer <= 0.0)  do g.SettingsDirtyTimer = g.IO.IniSavingRate;
}

MarkIniSettingsDirty :: proc(window : ^ImGuiWindow)
{
    g := GImGui;
    if (!(.NoSavedSettings in window.Flags)) {
        if (g.SettingsDirtyTimer <= 0.0) {
            g.SettingsDirtyTimer = g.IO.IniSavingRate;
        }
    }
}

AddSettingsHandler :: proc(handler : ^ImGuiSettingsHandler)
{
    g := GImGui;
    assert(FindSettingsHandler(handler.TypeName) == nil);
    append(&g.SettingsHandlers, handler^);
}

RemoveSettingsHandler :: proc(type_name : ^u8)
{
    g := GImGui;
    if handler := FindSettingsHandler(type_name); handler != nil {
        g.SettingsHandlers.erase(handler);
    }
}

FindSettingsHandler :: proc(type_name : ^u8) -> ^ImGuiSettingsHandler
{
    g := GImGui;
    type_hash := ImHashStr(type_name);
    for &handler in g.SettingsHandlers {
        if (handler.TypeHash == type_hash)   do return &handler
    }
    return nil;
}

// Clear all settings (windows, tables, docking etc.)
ClearIniSettings :: proc()
{
    g := GImGui;
    g.SettingsIniData.clear();
    for &handler in g.SettingsHandlers {
        if (handler.ClearAllFn != nil) {
            handler.ClearAllFn(g, &handler);
        }
    }
}

// [forward declared comment]:
// call after CreateContext() and before the first call to NewFrame(). NewFrame() automatically calls LoadIniSettingsFromDisk(io.IniFilename).
LoadIniSettingsFromDisk :: proc(ini_filename : ^u8)
{
    file_data_size := 0;
    file_data := cast(^u8)ImFileLoadToMemory(ini_filename, "rb", &file_data_size);
    if (!file_data)   do return
    if (file_data_size > 0)  do LoadIniSettingsFromMemory(file_data, cast(int) file_data_size);
    IM_FREE(file_data);
}

// Zero-tolerance, no error reporting, cheap .ini parsing
// Set ini_size==0 to let us use strlen(ini_data). Do not call this function with a 0 if your buffer is actually empty!
// [forward declared comment]:
// call after CreateContext() and before the first call to NewFrame() to provide .ini data from your own data source.
LoadIniSettingsFromMemory :: proc(ini_data : ^u8, ini_size : int)
{
    g := GImGui;
    assert(g.Initialized);
    //assert(!g.WithinFrameScope && "Cannot be called between NewFrame() and EndFrame()");
    //assert(g.SettingsLoaded == false && g.FrameCount == 0);

    // For user convenience, we allow passing a non zero-terminated string (hence the ini_size parameter).
    // For our convenience and to make the code simpler, we'll also write zero-terminators within the buffer. So let's create a writable copy..
    if (ini_size == 0) do ini_size = strlen(ini_data);
    g.SettingsIniData.Buf.resize(cast(i32) ini_size + 1);
    buf := g.SettingsIniData.Buf.Data;
    buf_end := buf + ini_size;
    memcpy(buf, ini_data, ini_size);
    buf_end[0] = 0;

    // Call pre-read handlers
    // Some types will clear their data (e.g. dock information) some types will allow merge/override (window)
    for &handler in g.SettingsHandlers {
        if (handler.ReadInitFn != nil) {
            handler.ReadInitFn(g, &handler);
        }
    }

    entry_data := nil;
    entry_handler := nil;

    line_end := nil;
    for u8* line = buf; line < buf_end; line = line_end + 1
    {
        // Skip new lines markers, then find end of the line
        for (line^ == '\n' || line^ == '\r') {
            line += 1;
        }
        line_end = line;
        for (line_end < buf_end && line_end^ != '\n' && line_end^ != '\r') {
            line_end += 1;
        }
        line_end[0] = 0;
        if (line[0] == ';')   do continue
        if (line[0] == '[' && line_end > line && line_end[-1] == ']')
        {
            // Parse "[Type][Name]". Note that 'Name' can itself contains [] characters, which is acceptable with the current format and parsing code.
            line_end[-1] = 0;
            name_end := line_end - 1;
            type_start := line + 1;
            type_end := cast(^u8)cast(rawptr)ImStrchrRange(type_start, name_end, ']');
            name_start := type_end ? ImStrchrRange(type_end + 1, name_end, '[') : nil;
            if (!type_end || !name_start)   do continue
            type_end^ = 0; // Overwrite first ']'
            name_start += 1;  // Skip second '['
            entry_handler = FindSettingsHandler(type_start);
            entry_data = entry_handler ? entry_handler.ReadOpenFn(g, entry_handler, name_start) : nil;
        }
        else if (entry_handler != nil && entry_data != nil)
        {
            // Let type handler parse the line
            entry_handler.ReadLineFn(g, entry_handler, entry_data, line);
        }
    }
    g.SettingsLoaded = true;

    // [DEBUG] Restore untouched copy so it can be browsed in Metrics (not strictly necessary)
    memcpy(buf, ini_data, ini_size);

    // Call post-read handlers
    for &handler in g.SettingsHandlers {
        if (handler.ApplyAllFn != nil) {
            handler.ApplyAllFn(g, &handler);
        }
    }
}

// [forward declared comment]:
// this is automatically called (if io.IniFilename is not empty) a few seconds after any modification that should be reflected in the .ini file (and also by DestroyContext).
SaveIniSettingsToDisk :: proc(ini_filename : ^u8)
{
    g := GImGui;
    g.SettingsDirtyTimer = 0.0;
    if (!ini_filename)   do return

    ini_data_size := 0;
    ini_data := SaveIniSettingsToMemory(&ini_data_size);
    f := ImFileOpen(ini_filename, "wt");
    if (!f)   do return
    ImFileWrite(ini_data, size_of(u8), ini_data_size, f);
    ImFileClose(f);
}

// Call registered handlers (e.g. SettingsHandlerWindow_WriteAll() + custom handlers) to write their stuff into a text buffer
// [forward declared comment]:
// return a zero-terminated string with the .ini data which you can save by your own mean. call when io.WantSaveIniSettings is set, then save data by your own mean and clear io.WantSaveIniSettings.
SaveIniSettingsToMemory :: proc(out_size : ^int = nil) -> ^u8
{
    g := GImGui;
    g.SettingsDirtyTimer = 0.0;
    g.SettingsIniData.Buf.resize(0);
    g.SettingsIniData.Buf.append(0);
    for &handler in g.SettingsHandlers {
        handler.WriteAllFn(g, &handler, &g.SettingsIniData);
    }
    if (out_size) {
        out_size^ = cast(int) g.SettingsIniData.size();
    }
    return g.SettingsIniData.c_str();
}

CreateNewWindowSettings :: proc(name : ^u8) -> ^ImGuiWindowSettings
{
    g := GImGui;

    if (g.IO.ConfigDebugIniSettings == false)
    {
        // Skip to the "###" marker if any. We don't skip past to match the behavior of GetID()
        // Preserve the full string when ConfigDebugVerboseIniSettings is set to make .ini inspection easier.
        if p := strstr(name, "###"); p != nil   do name = p
    }
    name_len := strlen(name);

    // Allocate chunk
    chunk_size := size_of(ImGuiWindowSettings) + name_len + 1;
    settings := g.SettingsWindows.alloc_chunk(chunk_size);
    __inplace_constructor(settings)
    settings.ID = ImHashStr(name, name_len);
    memcpy(settings.GetName(), name, name_len + 1);   // Store with zero terminator

    return settings;
}

// We don't provide a FindWindowSettingsByName() because Docking system doesn't always hold on names.
// This is called once per window .ini entry + once per newly instantiated window.
FindWindowSettingsByID :: proc(id : ImGuiID) -> ^ImGuiWindowSettings
{
    g := GImGui;
    for settings := begin(&g.SettingsWindows); settings != nil; settings = next_chunk(&g.SettingsWindows, settings) {
        if (settings.ID == id && !settings.WantDelete)   do return settings
    }
    return nil;
}

// This is faster if you are holding on a Window already as we don't need to perform a search.
FindWindowSettingsByWindow :: proc(window : ^ImGuiWindow) -> ^ImGuiWindowSettings
{
    g := GImGui;
    if (window.SettingsOffset != -1) {
        return g.SettingsWindows.ptr_from_offset(window.SettingsOffset);
    }
    return FindWindowSettingsByID(window.ID);
}

// This will revert window to its initial state, including enabling the ImGuiCond_FirstUseEver/ImGuiCond_Once conditions once more.
ClearWindowSettings :: proc(name : ^u8)
{
    //IMGUI_DEBUG_LOG("ClearWindowSettings('%s')\n", name);
    g := GImGui;
    window := FindWindowByName(name);
    if (window != nil)
    {
        window.Flags |= ImGuiWindowFlags_NoSavedSettings;
        InitOrLoadWindowSettings(window, nil);
        if (window.DockId != 0) {
            DockContextProcessUndockWindow(g, window, true);
        }
    }
    if settings := window ? FindWindowSettingsByWindow(window) : FindWindowSettingsByID(ImHashStr(name)); settings != nil {
        settings.WantDelete = true;
    }

}

WindowSettingsHandler_ClearAll :: proc(ctx : ^ImGuiContext, _ : ^ImGuiSettingsHandler)
{
    g := ctx;
    for window in g.Windows {
        window.SettingsOffset = -1;
    }
    g.SettingsWindows.clear();
}

WindowSettingsHandler_ReadOpen :: proc(_ : ^ImGuiContext, _ : ^ImGuiSettingsHandler, name : ^u8) -> rawptr
{
    id := ImHashStr(name);
    settings := FindWindowSettingsByID(id);
    if (settings) {
        settings^ = ImGuiWindowSettings(); // Clear existing if recycling previous entry
    }
    else {
        settings = CreateNewWindowSettings(name);
    }
    settings.ID = id;
    settings.WantApply = true;
    return cast(rawptr) settings;
}

WindowSettingsHandler_ReadLine :: proc(_ : ^ImGuiContext, _ : ^ImGuiSettingsHandler, entry : rawptr, line : ^u8)
{
    settings := cast(^ImGuiWindowSettings)entry;
    x, y : i32
    i : i32
    u1 : u32
    if (sscanf(line, "Pos=%i,%i", &x, &y) == 2)             { settings.Pos = ImVec2ih(cast(i16)x, cast(i16)y); }
    else if (sscanf(line, "Size=%i,%i", &x, &y) == 2)       { len(settings) = ImVec2ih(cast(i16)x, cast(i16)y); }
    else if (sscanf(line, "ViewportId=0x%08X", &u1) == 1)   { settings.ViewportId = u1; }
    else if (sscanf(line, "ViewportPos=%i,%i", &x, &y) == 2){ settings.ViewportPos = ImVec2ih(cast(i16)x, cast(i16)y); }
    else if (sscanf(line, "Collapsed=%d", &i) == 1)         { settings.Collapsed = (i != 0); }
    else if (sscanf(line, "IsChild=%d", &i) == 1)           { settings.IsChild = (i != 0); }
    else if (sscanf(line, "DockId=0x%X,%d", &u1, &i) == 2)  { settings.DockId = u1; settings.DockOrder = cast(i16)i; }
    else if (sscanf(line, "DockId=0x%X", &u1) == 1)         { settings.DockId = u1; settings.DockOrder = -1; }
    else if (sscanf(line, "ClassId=0x%X", &u1) == 1)        { settings.ClassId = u1; }
}

// Apply to existing windows (if any)
WindowSettingsHandler_ApplyAll :: proc(ctx : ^ImGuiContext, _ : ^ImGuiSettingsHandler)
{
    g := ctx;
    for settings := begin(&g.SettingsWindows); settings != nil; settings = next_chunk(&g.SettingsWindows, settings) {
        if (settings.WantApply)
        {
            if window := FindWindowByID(settings.ID); window != nil {
                ApplyWindowSettings(window, settings);
            }
            settings.WantApply = false;
        }
    }
}

WindowSettingsHandler_WriteAll :: proc(ctx : ^ImGuiContext, handler : ^ImGuiSettingsHandler, buf : ^ImGuiTextBuffer)
{
    // Gather data from windows that were active during this session
    // (if a window wasn't opened in this session we preserve its settings)
    g := ctx;
    for window in g.Windows
    {
        if (.NoSavedSettings in window.Flags)   do continue

        settings := FindWindowSettingsByWindow(window);
        if (!settings)
        {
            settings = CreateNewWindowSettings(window.Name);
            window.SettingsOffset = g.SettingsWindows.offset_from_ptr(settings);
        }
        assert(settings.ID == window.ID);
        settings.Pos = ImVec2ih(window.Pos - window.ViewportPos);
        len(settings) = ImVec2ih(window.SizeFull);
        settings.ViewportId = window.ViewportId;
        settings.ViewportPos = ImVec2ih(window.ViewportPos);
        assert(window.DockNode == nil || window.DockNode.ID == window.DockId);
        settings.DockId = window.DockId;
        settings.ClassId = window.WindowClass.ClassId;
        settings.DockOrder = window.DockOrder;
        settings.Collapsed = window.Collapsed;
        settings.IsChild = (window.RootWindow != window); // Cannot rely on ImGuiWindowFlags_ChildWindow here as docked windows have this set.
        settings.WantDelete = false;
    }

    // Write to text buffer
    buf.reserve(buf.size() + g.SettingsWindows.size() * 6); // ballpark reserve
    for settings := begin(&g.SettingsWindows); settings != nil; settings = next_chunk(&g.SettingsWindows, settings)
    {
        if (settings.WantDelete)   do continue
        settings_name := settings.GetName();
        buf.appendf("[%s][%s]\n", handler.TypeName, settings_name);
        if (settings.IsChild)
        {
            buf.appendf("IsChild=1\n");
            buf.appendf("Size=%d,%d\n", settings.Size.x, settings.Size.y);
        }
        else
        {
            if (settings.ViewportId != 0 && settings.ViewportId != IMGUI_VIEWPORT_DEFAULT_ID)
            {
                buf.appendf("ViewportPos=%d,%d\n", settings.ViewportPos.x, settings.ViewportPos.y);
                buf.appendf("ViewportId=0x%08X\n", settings.ViewportId);
            }
            if (settings.Pos.x != 0 || settings.Pos.y != 0 || settings.ViewportId == IMGUI_VIEWPORT_DEFAULT_ID) {
                buf.appendf("Pos=%d,%d\n", settings.Pos.x, settings.Pos.y);
            }
            if (settings.Size.x != 0 || settings.Size.y != 0) {
                buf.appendf("Size=%d,%d\n", settings.Size.x, settings.Size.y);
            }
            buf.appendf("Collapsed=%d\n", settings.Collapsed);
            if (settings.DockId != 0)
            {
                //buf.appendf("TabId=0x%08X\n", ImHashStr("#TAB", 4, settings.ID)); // window.TabId: this is not read back but writing it makes "debugging" the .ini data easier.
                if (settings.DockOrder == -1) {
                    buf.appendf("DockId=0x%08X\n", settings.DockId);
                }
                else {
                    buf.appendf("DockId=0x%08X,%d\n", settings.DockId, settings.DockOrder);
                }
                if (settings.ClassId != 0) {
                    buf.appendf("ClassId=0x%08X\n", settings.ClassId);
                }
            }
        }
        buf.append("\n");
    }
}

//-----------------------------------------------------------------------------
// [SECTION] LOCALIZATION
//-----------------------------------------------------------------------------

LocalizeRegisterEntries :: proc(entries : ^ImGuiLocEntry, count : i32)
{
    g := GImGui;
    for n := 0; n < count; n += 1 {
        g.LocalizationTable[entries[n].Key] = entries[n].Text;
    }
}

//-----------------------------------------------------------------------------
// [SECTION] VIEWPORTS, PLATFORM WINDOWS
//-----------------------------------------------------------------------------
// - GetMainViewport()
// - FindViewportByID()
// - FindViewportByPlatformHandle()
// - SetCurrentViewport() [Internal]
// - SetWindowViewport() [Internal]
// - GetWindowAlwaysWantOwnViewport() [Internal]
// - UpdateTryMergeWindowIntoHostViewport() [Internal]
// - UpdateTryMergeWindowIntoHostViewports() [Internal]
// - TranslateWindowsInViewport() [Internal]
// - ScaleWindowsInViewport() [Internal]
// - FindHoveredViewportFromPlatformWindowStack() [Internal]
// - UpdateViewportsNewFrame() [Internal]
// - UpdateViewportsEndFrame() [Internal]
// - AddUpdateViewport() [Internal]
// - WindowSelectViewport() [Internal]
// - WindowSyncOwnedViewport() [Internal]
// - UpdatePlatformWindows()
// - RenderPlatformWindowsDefault()
// - FindPlatformMonitorForPos() [Internal]
// - FindPlatformMonitorForRect() [Internal]
// - UpdateViewportPlatformMonitor() [Internal]
// - DestroyPlatformWindow() [Internal]
// - DestroyPlatformWindows()
//-----------------------------------------------------------------------------

// [forward declared comment]:
// return primary/default viewport. This can never be NULL.
GetMainViewport :: proc() -> ^ImGuiViewport
{
    g := GImGui;
    return g.Viewports[0];
}

// FIXME: This leaks access to viewports not listed in PlatformIO.Viewports[]. Problematic? (#4236)
// [forward declared comment]:
// this is a helper for backends.
FindViewportByID :: proc(id : ImGuiID) -> ^ImGuiViewport
{
    g := GImGui;
    for viewport in g.Viewports {
        if (viewport.ID == id)   do return viewport
    }
    return nil;
}

// [forward declared comment]:
// this is a helper for backends. the type platform_handle is decided by the backend (e.g. HWND, MyWindow*, GLFWwindow* etc.)
FindViewportByPlatformHandle :: proc(platform_handle : rawptr) -> ^ImGuiViewport
{
    g := GImGui;
    for viewport in g.Viewports {
        if (viewport.PlatformHandle == platform_handle)   do return viewport
    }
    return nil;
}

SetCurrentViewport :: proc(current_window : ^ImGuiWindow, viewport : ^ImGuiViewportP)
{
    g := GImGui;
    _ := current_window;

    if (viewport) {
        viewport.LastFrameActive = g.FrameCount;
    }
    if (g.CurrentViewport == viewport)   do return
    g.CurrentDpiScale = viewport ? viewport.DpiScale : 1.0;
    g.CurrentViewport = viewport;
    assert(g.CurrentDpiScale > 0.0 && g.CurrentDpiScale < 99.0); // Typical correct values would be between 1.0f and 4.0f
    //IMGUI_DEBUG_LOG_VIEWPORT("[viewport] SetCurrentViewport changed '%s' 0x%08X\n", current_window ? current_window.Name : NULL, viewport ? viewport.ID : 0);

    // Notify platform layer of viewport changes
    // FIXME-DPI: This is only currently used for experimenting with handling of multiple DPI
    if (g.CurrentViewport && g.PlatformIO.Platform_OnChangedViewport) {
        g.PlatformIO.Platform_OnChangedViewport(g.CurrentViewport);
    }

}

SetWindowViewport :: proc(window : ^ImGuiWindow, viewport : ^ImGuiViewportP)
{
    // Abandon viewport
    if (window.ViewportOwned && window.Viewport.Window == window) {
        len(window.Viewport) = ImVec2{0.0, 0.0};
    }

    window.Viewport = viewport;
    window.ViewportId = viewport.ID;
    window.ViewportOwned = (viewport.Window == window);
}

GetWindowAlwaysWantOwnViewport :: proc(window : ^ImGuiWindow) -> bool
{
    // Tooltips and menus are not automatically forced into their own viewport when the NoMerge flag is set, however the multiplication of viewports makes them more likely to protrude and create their own.
    g := GImGui;
    if (g.IO.ConfigViewportsNoAutoMerge || (window.WindowClass.ViewportFlagsOverrideSet & ImGuiViewportFlags_NoAutoMerge)) {
        if (g.ConfigFlagsCurrFrame & ImGuiConfigFlags_ViewportsEnable) {
            if (!window.DockIsActive) {
                if ((window.Flags & (ImGuiWindowFlags_ChildWindow | ImGuiWindowFlags_ChildMenu | ImGuiWindowFlags_Tooltip)) == 0) {
                    if ((.Popup not_in window.Flags) || (.Modal in window.Flags) != 0)   do return true
                }
            }
        }
    }
    return false;
}

UpdateTryMergeWindowIntoHostViewport :: proc(window : ^ImGuiWindow, viewport : ^ImGuiViewportP) -> bool
{
    g := GImGui;
    if (window.Viewport == viewport)   do return false
    if ((.CanHostOtherWindows not_in viewport.Flags))   do return false
    if ((.IsMinimized in viewport.Flags) != 0)   do return false
    if (!viewport.GetMainRect().Contains(Rect(window)))   do return false
    if (GetWindowAlwaysWantOwnViewport(window))   do return false

    // FIXME: Can't use g.WindowsFocusOrder[] for root windows only as we care about Z order. If we maintained a DisplayOrder along with FocusOrder we could..
    for window_behind in g.Windows
    {
        if (window_behind == window)   do break
        if (window_behind.WasActive && window_behind.ViewportOwned && !(.ChildWindow in window_behind.Flags)) {
            if (window_behind.Viewport.GetMainRect().Overlaps(Rect(window)))   do return false
        }
    }

    // Move to the existing viewport, Move child/hosted windows as well (FIXME-OPT: iterate child)
    old_viewport := window.Viewport;
    if (window.ViewportOwned) {
        for n := 0; n < len(g.Windows); n += 1 {
            if (g.Windows[n]->Viewport == old_viewport) {
                SetWindowViewport(g.Windows[n], viewport);
            }
        }
    }
    SetWindowViewport(window, viewport);
    BringWindowToDisplayFront(window);

    return true;
}

// FIXME: handle 0 to N host viewports
UpdateTryMergeWindowIntoHostViewports :: proc(window : ^ImGuiWindow) -> bool
{
    g := GImGui;
    return UpdateTryMergeWindowIntoHostViewport(window, g.Viewports[0]);
}

// Translate Dear ImGui windows when a Host Viewport has been moved
// (This additionally keeps windows at the same place when ImGuiConfigFlags_ViewportsEnable is toggled!)
TranslateWindowsInViewport :: proc(viewport : ^ImGuiViewportP, old_pos : ImVec2, new_pos : ImVec2, old_size : ImVec2, new_size : ImVec2)
{
    g := GImGui;
    assert(viewport.Window == nil && (.CanHostOtherWindows in viewport.Flags));

    // 1) We test if ImGuiConfigFlags_ViewportsEnable was just toggled, which allows us to conveniently
    // translate imgui windows from OS-window-local to absolute coordinates or vice-versa.
    // 2) If it's not going to fit into the new size, keep it at same absolute position.
    // One problem with this is that most Win32 applications doesn't update their render while dragging,
    // and so the window will appear to teleport when releasing the mouse.
    translate_all_windows := (g.ConfigFlagsCurrFrame & ImGuiConfigFlags_ViewportsEnable) != (g.ConfigFlagsLastFrame & ImGuiConfigFlags_ViewportsEnable);
    test_still_fit_rect := ImRect{ _v = {old_pos, old_pos + viewport.Size}};
    delta_pos := new_pos - old_pos;
    for window in g.Windows  {// FIXME-OPT
        if (translate_all_windows || (window.Viewport == viewport && (old_size == new_size || test_still_fit_rect.Contains(Rect(window))))) {
            TranslateWindow(window, delta_pos);
        }
    }
}

// Scale all windows (position, size). Use when e.g. changing DPI. (This is a lossy operation!)
ScaleWindowsInViewport :: proc(viewport : ^ImGuiViewportP, scale : f32)
{
    g := GImGui;
    if (viewport.Window)
    {
        ScaleWindow(viewport.Window, scale);
    }
    else
    {
        for window in g.Windows {
            if (window.Viewport == viewport) {
                ScaleWindow(window, scale);
            }
        }
    }
}

// If the backend doesn't set MouseLastHoveredViewport or doesn't honor ImGuiViewportFlags_NoInputs, we do a search ourselves.
// A) It won't take account of the possibility that non-imgui windows may be in-between our dragged window and our target window.
// B) It requires Platform_GetWindowFocus to be implemented by backend.
FindHoveredViewportFromPlatformWindowStack :: proc(mouse_platform_pos : ImVec2) -> ^ImGuiViewportP
{
    g := GImGui;
    best_candidate := nil;
    for viewport in g.Viewports {
        if (!(viewport.Flags & (ImGuiViewportFlags_NoInputs | ImGuiViewportFlags_IsMinimized)) && viewport.GetMainRect().Contains(mouse_platform_pos)) {
            if (best_candidate == nil || best_candidate.LastFocusedStampCount < viewport.LastFocusedStampCount)   do best_candidate = viewport
        }
    }
    return best_candidate;
}

// Update viewports and monitor infos
// Note that this is running even if 'ImGuiConfigFlags_ViewportsEnable' is not set, in order to clear unused viewports (if any) and update monitor info.
UpdateViewportsNewFrame :: proc()
{
    g := GImGui;
    assert(len(g.PlatformIO.Viewports) <= g.Viewports.Size);

    // Update Minimized status (we need it first in order to decide if we'll apply Pos/Size of the main viewport)
    // Update Focused status
    viewports_enabled := (g.ConfigFlagsCurrFrame & ImGuiConfigFlags_ViewportsEnable) != 0;
    if (viewports_enabled)
    {
        focused_viewport := nil;
        for viewport in g.Viewports
        {
            platform_funcs_available := viewport.PlatformWindowCreated;
            if (g.PlatformIO.Platform_GetWindowMinimized && platform_funcs_available)
            {
                is_minimized := g.PlatformIO.Platform_GetWindowMinimized(viewport);
                if (is_minimized) {
                    viewport.Flags |= ImGuiViewportFlags_IsMinimized;
                }
                else {
                    viewport.Flags &= ~ImGuiViewportFlags_IsMinimized;
                }
            }

            // Update our implicit z-order knowledge of platform windows, which is used when the backend cannot provide io.MouseHoveredViewport.
            // When setting Platform_GetWindowFocus, it is expected that the platform backend can handle calls without crashing if it doesn't have data stored.
            if (g.PlatformIO.Platform_GetWindowFocus && platform_funcs_available)
            {
                is_focused := g.PlatformIO.Platform_GetWindowFocus(viewport);
                if (is_focused) {
                    viewport.Flags |= ImGuiViewportFlags_IsFocused;
                }
                else {
                    viewport.Flags &= ~ImGuiViewportFlags_IsFocused;
                }
                if (is_focused) {
                    focused_viewport = viewport;
                }
            }
        }

        // Focused viewport has changed?
        if (focused_viewport && g.PlatformLastFocusedViewportId != focused_viewport.ID)
        {
            IMGUI_DEBUG_LOG_VIEWPORT("[viewport] Focused viewport changed %08X -> %08X, attempting to apply our focus.\n", g.PlatformLastFocusedViewportId, focused_viewport.ID);
            prev_focused_viewport := FindViewportByID(g.PlatformLastFocusedViewportId);
            prev_focused_has_been_destroyed := (prev_focused_viewport == nil) || (prev_focused_viewport.PlatformWindowCreated == false);

            // Store a tag so we can infer z-order easily from all our windows
            // We compare PlatformLastFocusedViewportId so newly created viewports with _NoFocusOnAppearing flag
            // will keep the front most stamp instead of losing it back to their parent viewport.
            if (focused_viewport.LastFocusedStampCount != g.ViewportFocusedStampCount) {
                g.ViewportFocusedStampCount += 1
                focused_viewport.LastFocusedStampCount = g.ViewportFocusedStampCount;
            }
            g.PlatformLastFocusedViewportId = focused_viewport.ID;

            // Focus associated dear imgui window
            // - if focus didn't happen with a click within imgui boundaries, e.g. Clicking platform title bar. (#6299)
            // - if focus didn't happen because we destroyed another window (#6462)
            // FIXME: perhaps 'FocusTopMostWindowUnderOne()' can handle the 'focused_window.Window != NULL' case as well.
            apply_imgui_focus_on_focused_viewport := !IsAnyMouseDown() && !prev_focused_has_been_destroyed;
            if (apply_imgui_focus_on_focused_viewport)
            {
                focused_viewport.LastFocusedHadNavWindow |= (g.NavWindow != nil) && (g.NavWindow.Viewport == focused_viewport); // Update so a window changing viewport won't lose focus.
                focus_request_flags := ImGuiFocusRequestFlags_UnlessBelowModal | ImGuiFocusRequestFlags_RestoreFocusedChild;
                if (focused_viewport.Window != nil) {
                    FocusWindow(focused_viewport.Window, focus_request_flags);
                }
                else if (focused_viewport.LastFocusedHadNavWindow) {
                    FocusTopMostWindowUnderOne(nil, nil, focused_viewport, focus_request_flags); // Focus top most in viewport
                }
                else {
                    FocusWindow(nil, focus_request_flags); // No window had focus last time viewport was focused
                }
            }
        }
        if (focused_viewport) {
            focused_viewport.LastFocusedHadNavWindow = (g.NavWindow != nil) && (g.NavWindow.Viewport == focused_viewport);
        }
    }

    // Create/update main viewport with current platform position.
    // FIXME-VIEWPORT: Size is driven by backend/user code for backward-compatibility but we should aim to make this more consistent.
    main_viewport := g.Viewports[0];
    assert(main_viewport.ID == IMGUI_VIEWPORT_DEFAULT_ID);
    assert(main_viewport.Window == nil);
    main_viewport_pos := viewports_enabled ? g.PlatformIO.Platform_GetWindowPos(main_viewport) : ImVec2{0.0, 0.0};
    main_viewport_size := g.IO.DisplaySize;
    if (viewports_enabled && (.IsMinimized in main_viewport.Flags))
    {
        main_viewport_pos = main_viewport.Pos;    // Preserve last pos/size when minimized (FIXME: We don't do the same for Size outside of the viewport path)
        main_viewport_size = len(main_viewport);
    }
    AddUpdateViewport(nil, IMGUI_VIEWPORT_DEFAULT_ID, main_viewport_pos, main_viewport_size, ImGuiViewportFlags_OwnedByApp | ImGuiViewportFlags_CanHostOtherWindows);

    g.CurrentDpiScale = 0.0;
    g.CurrentViewport = nil;
    g.MouseViewport = nil;
    for n := 0; n < len(g.Viewports); n += 1
    {
        viewport := g.Viewports[n];
        viewport.Idx = n;

        // Erase unused viewports
        if (n > 0 && viewport.LastFrameActive < g.FrameCount - 2)
        {
            DestroyViewport(viewport);
            n -= 1;
            continue;
        }

        platform_funcs_available := viewport.PlatformWindowCreated;
        if (viewports_enabled)
        {
            // Update Position and Size (from Platform Window to ImGui) if requested.
            // We do it early in the frame instead of waiting for UpdatePlatformWindows() to avoid a frame of lag when moving/resizing using OS facilities.
            if (!(.IsMinimized in viewport.Flags) && platform_funcs_available)
            {
                // Viewport.WorkPos and WorkSize will be updated below
                if (viewport.PlatformRequestMove) {
                    viewport.LastPlatformPos = g.PlatformIO.Platform_GetWindowPos(viewport);
                    viewport.Pos = viewport.LastPlatformPos
                }
                if (viewport.PlatformRequestResize) {
                    viewport.LastPlatformSize = g.PlatformIO.Platform_GetWindowSize(viewport);
                    len(viewport) = viewport.LastPlatformSize
                }
            }
        }

        // Update/copy monitor info
        UpdateViewportPlatformMonitor(viewport);

        // Lock down space taken by menu bars and status bars + query initial insets from backend
        // Setup initial value for functions like BeginMainMenuBar(), DockSpaceOverViewport() etc.
        viewport.WorkInsetMin = viewport.BuildWorkInsetMin;
        viewport.WorkInsetMax = viewport.BuildWorkInsetMax;
        viewport.BuildWorkInsetMax = {};
        viewport.BuildWorkInsetMin = {}
        if (g.PlatformIO.Platform_GetWindowWorkAreaInsets != nil && platform_funcs_available)
        {
            insets := g.PlatformIO.Platform_GetWindowWorkAreaInsets(viewport);
            assert(insets.x >= 0.0 && insets.y >= 0.0 && insets.z >= 0.0 && insets.w >= 0.0);
            viewport.BuildWorkInsetMin = ImVec2{insets.x, insets.y};
            viewport.BuildWorkInsetMax = ImVec2{insets.z, insets.w};
        }
        viewport.UpdateWorkRect();

        // Reset alpha every frame. Users of transparency (docking) needs to request a lower alpha back.
        viewport.Alpha = 1.0;

        // Translate Dear ImGui windows when a Host Viewport has been moved
        // (This additionally keeps windows at the same place when ImGuiConfigFlags_ViewportsEnable is toggled!)
        viewport_delta_pos := viewport.Pos - viewport.LastPos;
        if ((.CanHostOtherWindows in viewport.Flags) && (viewport_delta_pos.x != 0.0 || viewport_delta_pos.y != 0.0)) {
            TranslateWindowsInViewport(viewport, viewport.LastPos, viewport.Pos, viewport.LastSize, viewport.Size);
        }

        // Update DPI scale
        new_dpi_scale : f32
        if (g.PlatformIO.Platform_GetWindowDpiScale && platform_funcs_available) {
            new_dpi_scale = g.PlatformIO.Platform_GetWindowDpiScale(viewport);
        }
        else if (viewport.PlatformMonitor != -1) {
            new_dpi_scale = g.PlatformIO.Monitors[viewport.PlatformMonitor].DpiScale;
        }
        else {
            new_dpi_scale = (viewport.DpiScale != 0.0) ? viewport.DpiScale : 1.0;
        }
        assert(new_dpi_scale > 0.0 && new_dpi_scale < 99.0); // Typical correct values would be between 1.0f and 4.0f
        if (viewport.DpiScale != 0.0 && new_dpi_scale != viewport.DpiScale)
        {
            scale_factor := new_dpi_scale / viewport.DpiScale;
            if (.DpiEnableScaleViewports in g.IO.ConfigFlags) {
                ScaleWindowsInViewport(viewport, scale_factor);
            }
            //if (viewport == GetMainViewport())
            //    g.PlatformInterface.SetWindowSize(viewport, len(viewport) * scale_factor);

            // Scale our window moving pivot so that the window will rescale roughly around the mouse position.
            // FIXME-VIEWPORT: This currently creates a resizing feedback loop when a window is straddling a DPI transition border.
            // (Minor: since our sizes do not perfectly linearly scale, deferring the click offset scale until we know the actual window scale ratio may get us slightly more precise mouse positioning.)
            //if (g.MovingWindow != NULL && g.MovingWindow.Viewport == viewport)
            //    g.ActiveIdClickOffset = ImTrunc(g.ActiveIdClickOffset * scale_factor);
        }
        viewport.DpiScale = new_dpi_scale;
    }

    // Update fallback monitor
    g.PlatformMonitorsFullWorkRect = ImRect{ _r = {+math.F32_MAX, +math.F32_MAX, -math.F32_MAX, -math.F32_MAX}};
    if (len(g.PlatformIO.Monitors) == 0)
    {
        monitor := &g.FallbackMonitor;
        monitor.MainPos = main_viewport.Pos;
        monitor.MainSize = len(main_viewport);
        monitor.WorkPos = main_viewport.WorkPos;
        monitor.WorkSize = main_viewport.WorkSize;
        monitor.DpiScale = main_viewport.DpiScale;
        g.PlatformMonitorsFullWorkRect.Add(monitor.WorkPos);
        g.PlatformMonitorsFullWorkRect.Add(monitor.WorkPos + monitor.WorkSize);
    }
    else
    {
        g.FallbackMonitor = g.PlatformIO.Monitors[0];
    }
    for &monitor in g.PlatformIO.Monitors
    {
        g.PlatformMonitorsFullWorkRect.Add(monitor.WorkPos);
        g.PlatformMonitorsFullWorkRect.Add(monitor.WorkPos + monitor.WorkSize);
    }

    if (!viewports_enabled)
    {
        g.MouseViewport = main_viewport;
        return;
    }

    // Mouse handling: decide on the actual mouse viewport for this frame between the active/focused viewport and the hovered viewport.
    // Note that 'viewport_hovered' should skip over any viewport that has the ImGuiViewportFlags_NoInputs flags set.
    viewport_hovered := nil;
    if (.HasMouseHoveredViewport in g.IO.BackendFlags)
    {
        viewport_hovered = g.IO.MouseHoveredViewport ? cast(^ImGuiViewportP)FindViewportByID(g.IO.MouseHoveredViewport) : nil;
        if (viewport_hovered && (.NoInputs in viewport_hovered.Flags)) {
            viewport_hovered = FindHoveredViewportFromPlatformWindowStack(g.IO.MousePos); // Backend failed to handle _NoInputs viewport: revert to our fallback.
        }
    }
    else
    {
        // If the backend doesn't know how to honor ImGuiViewportFlags_NoInputs, we do a search ourselves. Note that this search:
        // A) won't take account of the possibility that non-imgui windows may be in-between our dragged window and our target window.
        // B) won't take account of how the backend apply parent<>child relationship to secondary viewports, which affects their Z order.
        // C) uses LastFrameAsRefViewport as a flawed replacement for the last time a window was focused (we could/should fix that by introducing Focus functions in PlatformIO)
        viewport_hovered = FindHoveredViewportFromPlatformWindowStack(g.IO.MousePos);
    }
    if (viewport_hovered != nil) {
        g.MouseLastHoveredViewport = viewport_hovered;
    }
    else if (g.MouseLastHoveredViewport == nil) {
        g.MouseLastHoveredViewport = g.Viewports[0];
    }

    // Update mouse reference viewport
    // (when moving a window we aim at its viewport, but this will be overwritten below if we go in drag and drop mode)
    // (MovingViewport.Viewport will be NULL in the rare situation where the window disappared while moving, set UpdateMouseMovingWindowNewFrame() for details)
    if (g.MovingWindow && g.MovingWindow.Viewport) {
        g.MouseViewport = g.MovingWindow.Viewport;
    }
    else {
        g.MouseViewport = g.MouseLastHoveredViewport;
    }

    // When dragging something, always refer to the last hovered viewport.
    // - when releasing a moving window we will revert to aiming behind (at viewport_hovered)
    // - when we are between viewports, our dragged preview will tend to show in the last viewport _even_ if we don't have tooltips in their viewports (when lacking monitor info)
    // - consider the case of holding on a menu item to browse child menus: even thou a mouse button is held, there's no active id because menu items only react on mouse release.
    // FIXME-VIEWPORT: This is essentially broken, when ImGuiBackendFlags_HasMouseHoveredViewport is set we want to trust when viewport_hovered==NULL and use that.
    is_mouse_dragging_with_an_expected_destination := g.DragDropActive;
    if (is_mouse_dragging_with_an_expected_destination && viewport_hovered == nil) {
        viewport_hovered = g.MouseLastHoveredViewport;
    }
    if (is_mouse_dragging_with_an_expected_destination || g.ActiveId == 0 || !IsAnyMouseDown()) {
        if (viewport_hovered != nil && viewport_hovered != g.MouseViewport && !(.NoInputs in viewport_hovered.Flags)) {
            g.MouseViewport = viewport_hovered;
        }
    }

    assert(g.MouseViewport != nil);
}

// Update user-facing viewport list (g.Viewports -> g.PlatformIO.Viewports after filtering out some)
UpdateViewportsEndFrame :: proc()
{
    g := GImGui;
    g.PlatformIO.Viewports.resize(0);
    for i := 0; i < len(g.Viewports); i += 1
    {
        viewport := g.Viewports[i];
        viewport.LastPos = viewport.Pos;
        viewport.LastSize = len(viewport);
        if (viewport.LastFrameActive < g.FrameCount || viewport.Size.x <= 0.0 || viewport.Size.y <= 0.0) {
            if (i > 0) { // Always include main viewport in the list
                continue;
            }
        }
        if (viewport.Window && !IsWindowActiveAndVisible(viewport.Window))   do continue
        if (i > 0) {
            assert(viewport.Window != nil);
        }
        g.PlatformIO.Viewports.append(viewport);
    }
    g.Viewports[0]->ClearRequestFlags(); // Clear main viewport flags because UpdatePlatformWindows() won't do it and may not even be called
}

// FIXME: We should ideally refactor the system to call this every frame (we currently don't)
AddUpdateViewport :: proc(window : ^ImGuiWindow, id : ImGuiID, pos : ImVec2, size : ImVec2, flags : ImGuiViewportFlags) -> ^ImGuiViewportP
{
    g := GImGui;
    assert(id != 0);

    flags |= ImGuiViewportFlags_IsPlatformWindow;
    if (window != nil)
    {
        if (g.MovingWindow && g.MovingWindow.RootWindowDockTree == window) {
            flags |= ImGuiViewportFlags_NoInputs | ImGuiViewportFlags_NoFocusOnAppearing;
        }
        if ((.NoMouseInputs in window.Flags) && (.NoNavInputs in window.Flags)) {
            flags |= ImGuiViewportFlags_NoInputs;
        }
        if (.NoFocusOnAppearing in window.Flags) {
            flags |= ImGuiViewportFlags_NoFocusOnAppearing;
        }
    }

    viewport := cast(^ImGuiViewportP)FindViewportByID(id);
    if (viewport)
    {
        // Always update for main viewport as we are already pulling correct platform pos/size (see #4900)
        if (!viewport.PlatformRequestMove || viewport.ID == IMGUI_VIEWPORT_DEFAULT_ID)   do viewport.Pos = pos
        if (!viewport.PlatformRequestResize || viewport.ID == IMGUI_VIEWPORT_DEFAULT_ID)   do len(viewport) = size
        viewport.Flags = flags | (viewport.Flags & (ImGuiViewportFlags_IsMinimized | ImGuiViewportFlags_IsFocused)); // Preserve existing flags
    }
    else
    {
        // New viewport
        viewport = IM_NEW(ImGuiViewportP)();
        viewport.ID = id;
        viewport.Idx = len(g.Viewports);
        viewport.LastPos = pos;
        viewport.Pos = pos
        viewport.LastSize = size;
        len(viewport) = size
        viewport.Flags = flags;
        UpdateViewportPlatformMonitor(viewport);
        g.Viewports.append(viewport);
        g.ViewportCreatedCount += 1;
        IMGUI_DEBUG_LOG_VIEWPORT("[viewport] Add Viewport %08X '%s'\n", id, window ? window.Name : "<nil>");

        // We normally setup for all viewports in NewFrame() but here need to handle the mid-frame creation of a new viewport.
        // We need to extend the fullscreen clip rect so the OverlayDrawList clip is correct for that the first frame
        g.DrawListSharedData.ClipRectFullscreen.x = ImMin(g.DrawListSharedData.ClipRectFullscreen.x, viewport.Pos.x);
        g.DrawListSharedData.ClipRectFullscreen.y = ImMin(g.DrawListSharedData.ClipRectFullscreen.y, viewport.Pos.y);
        g.DrawListSharedData.ClipRectFullscreen.z = ImMax(g.DrawListSharedData.ClipRectFullscreen.z, viewport.Pos.x + viewport.Size.x);
        g.DrawListSharedData.ClipRectFullscreen.w = ImMax(g.DrawListSharedData.ClipRectFullscreen.w, viewport.Pos.y + viewport.Size.y);

        // Store initial DpiScale before the OS platform window creation, based on expected monitor data.
        // This is so we can select an appropriate font size on the first frame of our window lifetime
        if (viewport.PlatformMonitor != -1) {
            viewport.DpiScale = g.PlatformIO.Monitors[viewport.PlatformMonitor].DpiScale;
        }
    }

    viewport.Window = window;
    viewport.LastFrameActive = g.FrameCount;
    viewport.UpdateWorkRect();
    assert(window == nil || viewport.ID == window.ID);

    if (window != nil) {
        window.ViewportOwned = true;
    }

    return viewport;
}

DestroyViewport :: proc(viewport : ^ImGuiViewportP)
{
    // Clear references to this viewport in windows (window.ViewportId becomes the master data)
    g := GImGui;
    for window in g.Windows
    {
        if (window.Viewport != viewport)   do continue
        window.Viewport = nil;
        window.ViewportOwned = false;
    }
    if (viewport == g.MouseLastHoveredViewport) {
        g.MouseLastHoveredViewport = nil;
    }

    // Destroy
    IMGUI_DEBUG_LOG_VIEWPORT("[viewport] Delete Viewport %08X '%s'\n", viewport.ID, viewport.Window ? viewport.Window.Name : "n/a");
    DestroyPlatformWindow(viewport); // In most circumstances the platform window will already be destroyed here.
    assert(g.PlatformIO.Viewports.contains(viewport) == false);
    assert(g.Viewports[viewport.Idx] == viewport);
    g.Viewports.erase(g.Viewports.Data + viewport.Idx);
    IM_DELETE(viewport);
}

// FIXME-VIEWPORT: This is all super messy and ought to be clarified or rewritten.
WindowSelectViewport :: proc(window : ^ImGuiWindow)
{
    g := GImGui;
    flags := window.Flags;
    window.ViewportAllowPlatformMonitorExtend = -1;

    // Restore main viewport if multi-viewport is not supported by the backend
    main_viewport := cast(^ImGuiViewportP)cast(rawptr)GetMainViewport();
    if (!(g.ConfigFlagsCurrFrame & ImGuiConfigFlags_ViewportsEnable))
    {
        SetWindowViewport(window, main_viewport);
        return;
    }
    window.ViewportOwned = false;

    // Appearing popups reset their viewport so they can inherit again
    if ((flags & (ImGuiWindowFlags_Popup | ImGuiWindowFlags_Tooltip)) && window.Appearing)
    {
        window.Viewport = nil;
        window.ViewportId = 0;
    }

    if ((.HasViewport not_in g.NextWindowData.Flags))
    {
        // By default inherit from parent window
        if (window.Viewport == nil && window.ParentWindow && (!window.ParentWindow.IsFallbackWindow || window.ParentWindow.WasActive)) {
            window.Viewport = window.ParentWindow.Viewport;
        }

        // Attempt to restore saved viewport id (= window that hasn't been activated yet), try to restore the viewport based on saved 'window.ViewportPos' restored from .ini file
        if (window.Viewport == nil && window.ViewportId != 0)
        {
            window.Viewport = cast(^ImGuiViewportP)FindViewportByID(window.ViewportId);
            if (window.Viewport == nil && window.ViewportPos.x != math.F32_MAX && window.ViewportPos.y != math.F32_MAX) {
                window.Viewport = AddUpdateViewport(window, window.ID, window.ViewportPos, window.Size, ImGuiViewportFlags_None);
            }
        }
    }

    lock_viewport := false;
    if (.HasViewport in g.NextWindowData.Flags)
    {
        // Code explicitly request a viewport
        window.Viewport = cast(^ImGuiViewportP)FindViewportByID(g.NextWindowData.ViewportId);
        window.ViewportId = g.NextWindowData.ViewportId; // Store ID even if Viewport isn't resolved yet.
        if (window.Viewport && (.DockNodeHost in window.Flags) != 0 && window.Viewport.Window != nil)
        {
            window.Viewport.Window = window;
            window.ViewportId = window.ID; // Overwrite ID (always owned by node)
            window.Viewport.ID = window.ID
        }
        lock_viewport = true;
    }
    else if ((.ChildWindow in flags) || (.ChildMenu in flags))
    {
        // Always inherit viewport from parent window
        if (window.DockNode && window.DockNode.HostWindow) {
            assert(window.DockNode.HostWindow.Viewport == window.ParentWindow.Viewport);
        }
        window.Viewport = window.ParentWindow.Viewport;
    }
    else if (window.DockNode && window.DockNode.HostWindow)
    {
        // This covers the "always inherit viewport from parent window" case for when a window reattach to a node that was just created mid-frame
        window.Viewport = window.DockNode.HostWindow.Viewport;
    }
    else if (.Tooltip in flags)
    {
        window.Viewport = g.MouseViewport;
    }
    else if (GetWindowAlwaysWantOwnViewport(window))
    {
        window.Viewport = AddUpdateViewport(window, window.ID, window.Pos, window.Size, ImGuiViewportFlags_None);
    }
    else if (g.MovingWindow && g.MovingWindow.RootWindowDockTree == window && IsMousePosValid())
    {
        if (window.Viewport != nil && window.Viewport.Window == window) {
            window.Viewport = AddUpdateViewport(window, window.ID, window.Pos, window.Size, ImGuiViewportFlags_None);
        }
    }
    else
    {
        // Merge into host viewport?
        // We cannot test window.ViewportOwned as it set lower in the function.
        // Testing (g.ActiveId == 0 || g.ActiveIdAllowOverlap) to avoid merging during a short-term widget interaction. Main intent was to avoid during resize (see #4212)
        try_to_merge_into_host_viewport := (window.Viewport && window == window.Viewport.Window && (g.ActiveId == 0 || g.ActiveIdAllowOverlap));
        if (try_to_merge_into_host_viewport) {
            UpdateTryMergeWindowIntoHostViewports(window);
        }
    }

    // Fallback: merge in default viewport if z-order matches, otherwise create a new viewport
    if (window.Viewport == nil) {
        if (!UpdateTryMergeWindowIntoHostViewport(window, main_viewport)) {
            window.Viewport = AddUpdateViewport(window, window.ID, window.Pos, window.Size, ImGuiViewportFlags_None);
        }
    }

    // Mark window as allowed to protrude outside of its viewport and into the current monitor
    if (!lock_viewport)
    {
        if (flags & (ImGuiWindowFlags_Tooltip | ImGuiWindowFlags_Popup))
        {
            // We need to take account of the possibility that mouse may become invalid.
            // Popups/Tooltip always set ViewportAllowPlatformMonitorExtend so GetWindowAllowedExtentRect() will return full monitor bounds.
            mouse_ref := (.Tooltip in flags) ? g.IO.MousePos : g.BeginPopupStack.back().OpenMousePos;
            use_mouse_ref := (!g.NavCursorVisible || !g.NavHighlightItemUnderNav || !g.NavWindow);
            mouse_valid := IsMousePosValid(&mouse_ref);
            if ((window.Appearing || (flags & (ImGuiWindowFlags_Tooltip | ImGuiWindowFlags_ChildMenu))) && (!use_mouse_ref || mouse_valid)) {
                window.ViewportAllowPlatformMonitorExtend = FindPlatformMonitorForPos((use_mouse_ref && mouse_valid) ? mouse_ref : NavCalcPreferredRefPos());
            }
            else {
                window.ViewportAllowPlatformMonitorExtend = window.Viewport.PlatformMonitor;
            }
        }
        else if (window.Viewport && window != window.Viewport.Window && window.Viewport.Window && !(.ChildWindow in flags) && window.DockNode == nil)
        {
            // When called from Begin() we don't have access to a proper version of the Hidden flag yet, so we replicate this code.
            will_be_visible := (window.DockIsActive && !window.DockTabIsVisible) ? false : true;
            if ((.DockNodeHost in window.Flags) && window.Viewport.LastFrameActive < g.FrameCount && will_be_visible)
            {
                // Steal/transfer ownership
                IMGUI_DEBUG_LOG_VIEWPORT("[viewport] Window '%s' steal Viewport %08X from Window '%s'\n", window.Name, window.Viewport.ID, window.Viewport.Window.Name);
                window.Viewport.Window = window;
                window.Viewport.ID = window.ID;
                window.Viewport.LastNameHash = 0;
            }
            else if (!UpdateTryMergeWindowIntoHostViewports(window)) // Merge?
            {
                // New viewport
                window.Viewport = AddUpdateViewport(window, window.ID, window.Pos, window.Size, ImGuiViewportFlags_NoFocusOnAppearing);
            }
        }
        else if (window.ViewportAllowPlatformMonitorExtend < 0 && (.ChildWindow not_in flags))
        {
            // Regular (non-child, non-popup) windows by default are also allowed to protrude
            // Child windows are kept contained within their parent.
            window.ViewportAllowPlatformMonitorExtend = window.Viewport.PlatformMonitor;
        }
    }

    // Update flags
    window.ViewportOwned = (window == window.Viewport.Window);
    window.ViewportId = window.Viewport.ID;

    // If the OS window has a title bar, hide our imgui title bar
    //if (window.ViewportOwned && !(window.Viewport.Flags & ImGuiViewportFlags_NoDecoration))
    //    window.Flags |= ImGuiWindowFlags_NoTitleBar;
}

WindowSyncOwnedViewport :: proc(window : ^ImGuiWindow, parent_window_in_stack : ^ImGuiWindow)
{
    g := GImGui;

    viewport_rect_changed := false;

    // Synchronize window --> viewport in most situations
    // Synchronize viewport -> window in case the platform window has been moved or resized from the OS/WM
    if (window.Viewport.PlatformRequestMove)
    {
        window.Pos = window.Viewport.Pos;
        MarkIniSettingsDirty(window);
    }
    else if (memcmp(&window.Viewport.Pos, &window.Pos, size_of(window.Pos)) != 0)
    {
        viewport_rect_changed = true;
        window.Viewport.Pos = window.Pos;
    }

    if (window.Viewport.PlatformRequestResize)
    {
        window.SizeFull = len(window.Viewport);
        window.Size = window.SizeFull
        MarkIniSettingsDirty(window);
    }
    else if (memcmp(&window.Viewport.Size, &window.Size, size_of(window.Size)) != 0)
    {
        viewport_rect_changed = true;
        len(window.Viewport) = window.Size;
    }
    UpdateWorkRect(window.Viewport);

    // The viewport may have changed monitor since the global update in UpdateViewportsNewFrame()
    // Either a SetNextWindowPos() call in the current frame or a SetWindowPos() call in the previous frame may have this effect.
    if (viewport_rect_changed) {
        UpdateViewportPlatformMonitor(window.Viewport);
    }

    // Update common viewport flags
    viewport_flags_to_clear := ImGuiViewportFlags_TopMost | ImGuiViewportFlags_NoTaskBarIcon | ImGuiViewportFlags_NoDecoration | ImGuiViewportFlags_NoRendererClear;
    viewport_flags := window.Viewport.Flags & ~viewport_flags_to_clear;
    window_flags := window.Flags;
    is_modal := (.Modal in window_flags) != 0;
    is_short_lived_floating_window := (window_flags & (ImGuiWindowFlags_ChildMenu | ImGuiWindowFlags_Tooltip | ImGuiWindowFlags_Popup)) != 0;
    if (.Tooltip in window_flags) {
        viewport_flags |= ImGuiViewportFlags_TopMost;
    }
    if ((g.IO.ConfigViewportsNoTaskBarIcon || is_short_lived_floating_window) && !is_modal) {
        viewport_flags |= ImGuiViewportFlags_NoTaskBarIcon;
    }
    if (g.IO.ConfigViewportsNoDecoration || is_short_lived_floating_window) {
        viewport_flags |= ImGuiViewportFlags_NoDecoration;
    }

    // Not correct to set modal as topmost because:
    // - Because other popups can be stacked above a modal (e.g. combo box in a modal)
    // - ImGuiViewportFlags_TopMost is currently handled different in backends: in Win32 it is "appear top most" whereas in GLFW and SDL it is "stay topmost"
    //if (.Modal in flags)
    //    viewport_flags |= ImGuiViewportFlags_TopMost;

    // For popups and menus that may be protruding out of their parent viewport, we enable _NoFocusOnClick so that clicking on them
    // won't steal the OS focus away from their parent window (which may be reflected in OS the title bar decoration).
    // Setting _NoFocusOnClick would technically prevent us from bringing back to front in case they are being covered by an OS window from a different app,
    // but it shouldn't be much of a problem considering those are already popups that are closed when clicking elsewhere.
    if (is_short_lived_floating_window && !is_modal) {
        viewport_flags |= ImGuiViewportFlags_NoFocusOnAppearing | ImGuiViewportFlags_NoFocusOnClick;
    }

    // We can overwrite viewport flags using ImGuiWindowClass (advanced users)
    if (window.WindowClass.ViewportFlagsOverrideSet) {
        viewport_flags |= window.WindowClass.ViewportFlagsOverrideSet;
    }
    if (window.WindowClass.ViewportFlagsOverrideClear) {
        viewport_flags &= ~window.WindowClass.ViewportFlagsOverrideClear;
    }

    // We can also tell the backend that clearing the platform window won't be necessary,
    // as our window background is filling the viewport and we have disabled BgAlpha.
    // FIXME: Work on support for per-viewport transparency (#2766)
    if (!(.NoBackground in window_flags)) {
        viewport_flags |= ImGuiViewportFlags_NoRendererClear;
    }

    window.Viewport.Flags = viewport_flags;

    // Update parent viewport ID
    // (the !IsFallbackWindow test mimic the one done in WindowSelectViewport())
    if (window.WindowClass.ParentViewportId != (ImGuiID)-1) {
        window.Viewport.ParentViewportId = window.WindowClass.ParentViewportId;
    }
    else if ((window_flags & (ImGuiWindowFlags_Popup | ImGuiWindowFlags_Tooltip)) && parent_window_in_stack && (!parent_window_in_stack.IsFallbackWindow || parent_window_in_stack.WasActive)) {
        window.Viewport.ParentViewportId = parent_window_in_stack.Viewport.ID;
    }
    else {
        window.Viewport.ParentViewportId = g.IO.ConfigViewportsNoDefaultParent ? 0 : IMGUI_VIEWPORT_DEFAULT_ID;
    }
}

// Called by user at the end of the main loop, after EndFrame()
// This will handle the creation/update of all OS windows via function defined in the ImGuiPlatformIO api.
// [forward declared comment]:
// call in main loop. will call CreateWindow/ResizeWindow/etc. platform functions for each secondary viewport, and DestroyWindow for each inactive viewport.
UpdatePlatformWindows :: proc()
{
    g := GImGui;
    assert(g.FrameCountEnded == g.FrameCount, "Forgot to call Render() or EndFrame() before UpdatePlatformWindows()?");
    assert(g.FrameCountPlatformEnded < g.FrameCount);
    g.FrameCountPlatformEnded = g.FrameCount;
    if (!(g.ConfigFlagsCurrFrame & ImGuiConfigFlags_ViewportsEnable))   do return

    // Create/resize/destroy platform windows to match each active viewport.
    // Skip the main viewport (index 0), which is always fully handled by the application!
    for i := 1; i < len(g.Viewports); i += 1
    {
        viewport := g.Viewports[i];

        // Destroy platform window if the viewport hasn't been submitted or if it is hosting a hidden window
        // (the implicit/fallback Debug##Default window will be registering its viewport then be disabled, causing a dummy DestroyPlatformWindow to be made each frame)
        destroy_platform_window := false;
        destroy_platform_window |= (viewport.LastFrameActive < g.FrameCount - 1);
        destroy_platform_window |= (viewport.Window && !IsWindowActiveAndVisible(viewport.Window));
        if (destroy_platform_window)
        {
            DestroyPlatformWindow(viewport);
            continue;
        }

        // New windows that appears directly in a new viewport won't always have a size on their first frame
        if (viewport.LastFrameActive < g.FrameCount || viewport.Size.x <= 0 || viewport.Size.y <= 0)   do continue

        // Create window
        is_new_platform_window := (viewport.PlatformWindowCreated == false);
        if (is_new_platform_window)
        {
            IMGUI_DEBUG_LOG_VIEWPORT("[viewport] Create Platform Window %08X '%s'\n", viewport.ID, viewport.Window ? viewport.Window.Name : "n/a");
            g.PlatformIO.Platform_CreateWindow(viewport);
            if (g.PlatformIO.Renderer_CreateWindow != nil) {
                g.PlatformIO.Renderer_CreateWindow(viewport);
            }
            g.PlatformWindowsCreatedCount += 1;
            viewport.LastNameHash = 0;
            viewport.LastPlatformSize = ImVec2{math.F32_MAX, math.F32_MAX};
            viewport.LastPlatformPos = ImVec2{math.F32_MAX, math.F32_MAX}; // By clearing those we'll enforce a call to Platform_SetWindowPos/Size below, before Platform_ShowWindow (FIXME: Is that necessary?)
            viewport.LastRendererSize = len(viewport);                                       // We don't need to call Renderer_SetWindowSize() as it is expected Renderer_CreateWindow() already did it.
            viewport.PlatformWindowCreated = true;
        }

        // Apply Position and Size (from ImGui to Platform/Renderer backends)
        if ((viewport.LastPlatformPos.x != viewport.Pos.x || viewport.LastPlatformPos.y != viewport.Pos.y) && !viewport.PlatformRequestMove) {
            g.PlatformIO.Platform_SetWindowPos(viewport, viewport.Pos);
        }
        if ((viewport.LastPlatformSize.x != viewport.Size.x || viewport.LastPlatformSize.y != viewport.Size.y) && !viewport.PlatformRequestResize) {
            g.PlatformIO.Platform_SetWindowSize(viewport, viewport.Size);
        }
        if ((viewport.LastRendererSize.x != viewport.Size.x || viewport.LastRendererSize.y != viewport.Size.y) && g.PlatformIO.Renderer_SetWindowSize) {
            g.PlatformIO.Renderer_SetWindowSize(viewport, viewport.Size);
        }
        viewport.LastPlatformPos = viewport.Pos;
        viewport.LastRendererSize = len(viewport);
        viewport.LastPlatformSize = viewport.Size

        // Update title bar (if it changed)
        if window_for_title := GetWindowForTitleDisplay(viewport.Window); window_for_title != nil
        {
            title_begin := window_for_title.Name;
            title_end := cast(^u8)cast(rawptr)FindRenderedText(title_begin);
            title_hash := ImHashStr(title_begin, title_end - title_begin);
            if (viewport.LastNameHash != title_hash)
            {
                title_end_backup_c := title_end^;
                title_end^ = 0; // Cut existing buffer short instead of doing an alloc/free, no small gain.
                g.PlatformIO.Platform_SetWindowTitle(viewport, title_begin);
                title_end^ = title_end_backup_c;
                viewport.LastNameHash = title_hash;
            }
        }

        // Update alpha (if it changed)
        if (viewport.LastAlpha != viewport.Alpha && g.PlatformIO.Platform_SetWindowAlpha) {
            g.PlatformIO.Platform_SetWindowAlpha(viewport, viewport.Alpha);
        }
        viewport.LastAlpha = viewport.Alpha;

        // Optional, general purpose call to allow the backend to perform general book-keeping even if things haven't changed.
        if (g.PlatformIO.Platform_UpdateWindow) {
            g.PlatformIO.Platform_UpdateWindow(viewport);
        }

        if (is_new_platform_window)
        {
            // On startup ensure new platform window don't steal focus (give it a few frames, as nested contents may lead to viewport being created a few frames late)
            if (g.FrameCount < 3) {
                viewport.Flags |= ImGuiViewportFlags_NoFocusOnAppearing;
            }

            // Show window
            g.PlatformIO.Platform_ShowWindow(viewport);

            // Even without focus, we assume the window becomes front-most.
            // This is useful for our platform z-order heuristic when io.MouseHoveredViewport is not available.
            if (viewport.LastFocusedStampCount != g.ViewportFocusedStampCount) {
                g.ViewportFocusedStampCount += 1
                viewport.LastFocusedStampCount = g.ViewportFocusedStampCount;
            }
        }

        // Clear request flags
        viewport.ClearRequestFlags();
    }
}

// This is a default/basic function for performing the rendering/swap of multiple Platform Windows.
// Custom renderers may prefer to not call this function at all, and instead iterate the publicly exposed platform data and handle rendering/sync themselves.
// The Render/Swap functions stored in ImGuiPlatformIO are merely here to allow for this helper to exist, but you can do it yourself:
//
//    platform_io := &ImGui::GetPlatformIO();
//    for int i = 1; i < len(platform_io.Viewports); i += 1
//        if ((platform_io.Viewports[i]->Flags & ImGuiViewportFlags_Minimized) == 0)
//            MyRenderFunction(platform_io.Viewports[i], my_args);
//    for int i = 1; i < len(platform_io.Viewports); i += 1
//        if ((platform_io.Viewports[i]->Flags & ImGuiViewportFlags_Minimized) == 0)
//            MySwapBufferFunction(platform_io.Viewports[i], my_args);
//
// [forward declared comment]:
// call in main loop. will call RenderWindow/SwapBuffers platform functions for each secondary viewport which doesn't have the ImGuiViewportFlags_Minimized flag set. May be reimplemented by user for custom rendering needs.
RenderPlatformWindowsDefault :: proc(platform_render_arg : rawptr = nil, renderer_render_arg : rawptr = nil)
{
    // Skip the main viewport (index 0), which is always fully handled by the application!
    platform_io := &GetPlatformIO();
    for i := 1; i < len(platform_io.Viewports); i += 1
    {
        viewport := platform_io.Viewports[i];
        if (.IsMinimized in viewport.Flags)   do continue
        if (platform_io.Platform_RenderWindow) do platform_io.Platform_RenderWindow(viewport, platform_render_arg);
        if (platform_io.Renderer_RenderWindow) do platform_io.Renderer_RenderWindow(viewport, renderer_render_arg);
    }
    for i := 1; i < len(platform_io.Viewports); i += 1
    {
        viewport := platform_io.Viewports[i];
        if (.IsMinimized in viewport.Flags)   do continue
        if (platform_io.Platform_SwapBuffers) do platform_io.Platform_SwapBuffers(viewport, platform_render_arg);
        if (platform_io.Renderer_SwapBuffers) do platform_io.Renderer_SwapBuffers(viewport, renderer_render_arg);
    }
}

FindPlatformMonitorForPos :: proc(pos : ImVec2) -> i32
{
    g := GImGui;
    for monitor_n := 0; monitor_n < len(g.PlatformIO.Monitors); monitor_n += 1
    {
        monitor := &g.PlatformIO.Monitors[monitor_n];
        if (ImRect{ _v = {monitor.MainPos, monitor.MainPos + monitor.MainSize}}.Contains(pos))   do return monitor_n
    }
    return -1;
}

// Search for the monitor with the largest intersection area with the given rectangle
// We generally try to avoid searching loops but the monitor count should be very small here
// FIXME-OPT: We could test the last monitor used for that viewport first, and early
FindPlatformMonitorForRect :: proc(rect : ^ImRect) -> i32
{
    g := GImGui;

    monitor_count := len(g.PlatformIO.Monitors);
    if (monitor_count <= 1)   do return monitor_count - 1

    // Use a minimum threshold of 1.0f so a zero-sized rect won't false positive, and will still find the correct monitor given its position.
    // This is necessary for tooltips which always resize down to zero at first.
    surface_threshold := ImMax(rect.GetWidth() * rect.GetHeight() * 0.5, 1.0);
    best_monitor_n := -1;
    best_monitor_surface := 0.001;

    for monitor_n := 0; monitor_n < len(g.PlatformIO.Monitors) && best_monitor_surface < surface_threshold; monitor_n += 1
    {
        monitor := &g.PlatformIO.Monitors[monitor_n];
        monitor_rect := ImRect{ _v = {monitor.MainPos, monitor.MainPos + monitor.MainSize}};
        if (monitor_rect.Contains(rect))   do return monitor_n
        overlapping_rect := rect;
        overlapping_rect.ClipWithFull(monitor_rect);
        overlapping_surface := overlapping_rect.GetWidth() * overlapping_rect.GetHeight();
        if (overlapping_surface < best_monitor_surface)   do continue
        best_monitor_surface = overlapping_surface;
        best_monitor_n = monitor_n;
    }
    return best_monitor_n;
}

// Update monitor from viewport rectangle (we'll use this info to clamp windows and save windows lost in a removed monitor)
UpdateViewportPlatformMonitor :: proc(viewport : ^ImGuiViewportP)
{
    viewport.PlatformMonitor = cast(i16)FindPlatformMonitorForRect(viewport.GetMainRect());
}

// Return value is always != NULL, but don't hold on it across frames.
GetViewportPlatformMonitor :: proc(viewport_p : ^ImGuiViewport) -> ^ImGuiPlatformMonitor
{
    g := GImGui;
    viewport := cast(^ImGuiViewportP)cast(rawptr)viewport_p;
    monitor_idx := viewport.PlatformMonitor;
    if (monitor_idx >= 0 && monitor_idx < g.PlatformIO.Monitors.Size) {
        return &g.PlatformIO.Monitors[monitor_idx];
    }
    return &g.FallbackMonitor;
}

DestroyPlatformWindow :: proc(viewport : ^ImGuiViewportP)
{
    g := GImGui;
    if (viewport.PlatformWindowCreated)
    {
        IMGUI_DEBUG_LOG_VIEWPORT("[viewport] Destroy Platform Window %08X '%s'\n", viewport.ID, viewport.Window ? viewport.Window.Name : "n/a");
        if (g.PlatformIO.Renderer_DestroyWindow) {
            g.PlatformIO.Renderer_DestroyWindow(viewport);
        }
        if (g.PlatformIO.Platform_DestroyWindow) {
            g.PlatformIO.Platform_DestroyWindow(viewport);
        }
        assert(viewport.RendererUserData == nil && viewport.PlatformUserData == nil);

        // Don't clear PlatformWindowCreated for the main viewport, as we initially set that up to true in Initialize()
        // The righter way may be to leave it to the backend to set this flag all-together, and made the flag public.
        if (viewport.ID != IMGUI_VIEWPORT_DEFAULT_ID) {
            viewport.PlatformWindowCreated = false;
        }
    }
    else
    {
        assert(viewport.RendererUserData == nil && viewport.PlatformUserData == nil && viewport.PlatformHandle == nil);
    }
    viewport.PlatformHandle = nil;
    viewport.PlatformUserData = nil
    viewport.RendererUserData = nil
    viewport.ClearRequestFlags();
}

// [forward declared comment]:
// call DestroyWindow platform functions for all viewports. call from backend Shutdown() if you need to close platform windows before imgui shutdown. otherwise will be called by DestroyContext().
DestroyPlatformWindows :: proc()
{
    // We call the destroy window on every viewport (including the main viewport, index 0) to give a chance to the backend
    // to clear any data they may have stored in e.g. PlatformUserData, RendererUserData.
    // It is convenient for the platform backend code to store something in the main viewport, in order for e.g. the mouse handling
    // code to operator a consistent manner.
    // It is expected that the backend can handle calls to Renderer_DestroyWindow/Platform_DestroyWindow without
    // crashing if it doesn't have data stored.
    g := GImGui;
    for viewport in g.Viewports {
        DestroyPlatformWindow(viewport);
    }
}


//-----------------------------------------------------------------------------
// [SECTION] DOCKING
//-----------------------------------------------------------------------------
// Docking: Internal Types
// Docking: Forward Declarations
// Docking: ImGuiDockContext
// Docking: ImGuiDockContext Docking/Undocking functions
// Docking: ImGuiDockNode
// Docking: ImGuiDockNode Tree manipulation functions
// Docking: Public Functions (SetWindowDock, DockSpace, DockSpaceOverViewport)
// Docking: Builder Functions
// Docking: Begin/End Support Functions (called from Begin/End)
// Docking: Settings
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// Typical Docking call flow: (root level is generally public API):
//-----------------------------------------------------------------------------
// - NewFrame()                               new dear imgui frame
//    | DockContextNewFrameUpdateUndocking()  - process queued undocking requests
//    | - DockContextProcessUndockWindow()    - process one window undocking request
//    | - DockContextProcessUndockNode()      - process one whole node undocking request
//    | DockContextNewFrameUpdateUndocking()  - process queue docking requests, create floating dock nodes
//    | - update g.HoveredDockNode            - [debug] update node hovered by mouse
//    | - DockContextProcessDock()            - process one docking request
//    | - DockNodeUpdate()
//    |   - DockNodeUpdateForRootNode()
//    |     - DockNodeUpdateFlagsAndCollapse()
//    |     - DockNodeFindInfo()
//    |   - destroy unused node or tab bar
//    |   - create dock node host window
//    |      - Begin() etc.
//    |   - DockNodeStartMouseMovingWindow()
//    |   - DockNodeTreeUpdatePosSize()
//    |   - DockNodeTreeUpdateSplitter()
//    |   - draw node background
//    |   - DockNodeUpdateTabBar()            - create/update tab bar for a docking node
//    |     - DockNodeAddTabBar()
//    |     - DockNodeWindowMenuUpdate()
//    |     - DockNodeCalcTabBarLayout()
//    |     - BeginTabBarEx()
//    |     - TabItemEx() calls
//    |     - EndTabBar()
//    |   - BeginDockableDragDropTarget()
//    |      - DockNodeUpdate()               - recurse into child nodes...
//-----------------------------------------------------------------------------
// - DockSpace()                              user submit a dockspace into a window
//    | Begin(Child)                          - create a child window
//    | DockNodeUpdate()                      - call main dock node update function
//    | End(Child)
//    | ItemSize()
//-----------------------------------------------------------------------------
// - Begin()
//    | BeginDocked()
//    | BeginDockableDragDropSource()
//    | BeginDockableDragDropTarget()
//    | - DockNodePreviewDockRender()
//-----------------------------------------------------------------------------
// - EndFrame()
//    | DockContextEndFrame()
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// Docking: Internal Types
//-----------------------------------------------------------------------------
// - ImGuiDockRequestType
// - ImGuiDockRequest
// - ImGuiDockPreviewData
// - ImGuiDockNodeSettings
// - ImGuiDockContext
//-----------------------------------------------------------------------------

ImGuiDockRequestType :: enum i32
{
    // [removed] -> nil: None = 0,
    Dock,
    Undock,
    Split                  // Split is the same as Dock but without a DockPayload
};

ImGuiDockRequest :: struct
{
    Type : ImGuiDockRequestType,
    DockTargetWindow : ^ImGuiWindow,   // Destination/Target Window to dock into (may be a loose window or a DockNode, might be NULL in which case DockTargetNode cannot be NULL)
    DockTargetNode : ^ImGuiDockNode,     // Destination/Target Node to dock into
    DockPayload : ^ImGuiWindow,        // Source/Payload window to dock (may be a loose window or a DockNode), [Optional]
    DockSplitDir : ImGuiDir,
    DockSplitRatio : f32,
    DockSplitOuter : bool,
    UndockTargetWindow : ^ImGuiWindow,
    UndockTargetNode : ^ImGuiDockNode,

};

init_ImGuiDockRequest :: proc(this : ^ImGuiDockRequest)
{
    this^ = {}
    this.DockSplitRatio = 0.5;
}


ImGuiDockPreviewData :: struct
{
    FutureNode : ImGuiDockNode,
    IsDropAllowed : bool,
    IsCenterAvailable : bool,
    IsSidesAvailable : bool,           // Hold your breath, grammar freaks..
    IsSplitDirExplicit : bool,         // Set when hovered the drop rect (vs. implicit SplitDir==None when hovered the window)
    SplitNode : ^ImGuiDockNode,
    SplitDir : ImGuiDir,
    SplitRatio : f32,
    DropRectsDraw : [ImGuiDir.COUNT + 1]ImRect,  // May be slightly different from hit-testing drop rects used in DockNodeCalcDropRects()
};

init_ImGuiDockPreviewData :: proc(this : ^ImGuiDockPreviewData)  {
    this^ = {}
    init_FutureNode(this.FutureNode)
    for n := 0; n < len(this.DropRectsDraw); n += 1 do this.DropRectsDraw[n] = ImRect{ _r = {+math.F32_MAX, +math.F32_MAX, -math.F32_MAX, -math.F32_MAX}}; }
}


// Persistent Settings data, stored contiguously in SettingsNodes (size_of() ~32 bytes)
ImGuiDockNodeSettings :: struct
{
    ID : ImGuiID,
    ParentNodeId : ImGuiID,
    ParentWindowId : ImGuiID,
    SelectedTabId : ImGuiID,
    SplitAxis : i8,
    Depth : u8,
    Flags : ImGuiDockNodeFlags,                  // NB: We save individual flags one by one in ascii format (transmute(ImGuiDockNodeFlags) ImGuiDockNodeFlagsPrivate.SavedFlagsMask_)
    Pos : ImVec2ih,
    Size : ImVec2ih,
    SizeRef : ImVec2ih,
};


//-----------------------------------------------------------------------------
// Docking: Forward Declarations
//-----------------------------------------------------------------------------

DockNodeGetHostWindowTitle :: #force_inline proc(node : ^ImGuiDockNode, buf : ^u8, buf_size : i32) -> ^u8 { ImFormatString(buf, buf_size, "##DockNode_%02X", node.ID); return buf; }

//-----------------------------------------------------------------------------
// Docking: ImGuiDockContext
//-----------------------------------------------------------------------------
// The lifetime model is different from the one of regular windows: we always create a ImGuiDockNode for each ImGuiDockNodeSettings,
// or we always hold the entire docking node tree. Nodes are frequently hidden, e.g. if the window(s) or child nodes they host are not active.
// At boot time only, we run a simple GC to remove nodes that have no references.
// Because dock node settings (which are small, contiguous structures) are always mirrored by their corresponding dock nodes (more complete structures),
// we can also very easily recreate the nodes from scratch given the settings data (this is what DockContextRebuild() does).
// This is convenient as docking reconfiguration can be implemented by mostly poking at the simpler settings data.
//-----------------------------------------------------------------------------
// - DockContextInitialize()
// - DockContextShutdown()
// - DockContextClearNodes()
// - DockContextRebuildNodes()
// - DockContextNewFrameUpdateUndocking()
// - DockContextNewFrameUpdateDocking()
// - DockContextEndFrame()
// - DockContextFindNodeByID()
// - DockContextBindNodeToWindow()
// - DockContextGenNodeID()
// - DockContextAddNode()
// - DockContextRemoveNode()
// - ImGuiDockContextPruneNodeData
// - DockContextPruneUnusedSettingsNodes()
// - DockContextBuildNodesFromSettings()
// - DockContextBuildAddWindowsToNodes()
//-----------------------------------------------------------------------------

DockContextInitialize :: proc(ctx : ^ImGuiContext)
{
    g := ctx;

    // Add .ini handle for persistent docking data
    ini_handler : ImGuiSettingsHandler
    ini_handler.TypeName = "Docking";
    ini_handler.TypeHash = ImHashStr("Docking");
    ini_handler.ClearAllFn = DockSettingsHandler_ClearAll;
    ini_handler.ReadInitFn = DockSettingsHandler_ClearAll; // Also clear on read
    ini_handler.ReadOpenFn = DockSettingsHandler_ReadOpen;
    ini_handler.ReadLineFn = DockSettingsHandler_ReadLine;
    ini_handler.ApplyAllFn = DockSettingsHandler_ApplyAll;
    ini_handler.WriteAllFn = DockSettingsHandler_WriteAll;
    append(&g.SettingsHandlers, ini_handler);

    g.DockNodeWindowMenuHandler = DockNodeWindowMenuHandler_Default;
}

DockContextShutdown :: proc(ctx : ^ImGuiContext)
{
    dc := &ctx.DockContext;
    for n := 0; n < len(dc.Nodes.Data); n += 1 {
        if node := cast(^ImGuiDockNode)dc.Nodes.Data[n].val_p; node != nil   do IM_DELETE(node)
    }
}

// [forward declared comment]:
// Use root_id==0 to clear all
DockContextClearNodes :: proc(ctx : ^ImGuiContext, root_id : ImGuiID, clear_settings_refs : bool)
{
    _ = ctx;
    assert(ctx == GImGui);
    DockBuilderRemoveNodeDockedWindows(root_id, clear_settings_refs);
    DockBuilderRemoveNodeChildNodes(root_id);
}

// [DEBUG] This function also acts as a defacto test to make sure we can rebuild from scratch without a glitch
// (Different from DockSettingsHandler_ClearAll() + DockSettingsHandler_ApplyAll() because this reuses current settings!)
DockContextRebuildNodes :: proc(ctx : ^ImGuiContext)
{
    g := ctx;
    dc := &ctx.DockContext;
    IMGUI_DEBUG_LOG_DOCKING(g, "[docking] DockContextRebuildNodes\n");
    SaveIniSettingsToMemory();
    root_id := 0; // Rebuild all
    DockContextClearNodes(ctx, root_id, false);
    DockContextBuildNodesFromSettings(ctx, dc.NodesSettings.Data, dc.NodesSettings.Size);
    DockContextBuildAddWindowsToNodes(ctx, root_id);
}

// Docking context update function, called by NewFrame()
DockContextNewFrameUpdateUndocking :: proc(ctx : ^ImGuiContext)
{
    g := ctx;
    dc := &ctx.DockContext;
    if (!(.DockingEnable in g.IO.ConfigFlags))
    {
        if (len(dc.Nodes.Data) > 0 || len(dc.Requests) > 0) {
            DockContextClearNodes(ctx, 0, true);
        }
        return;
    }

    // Setting NoSplit at runtime merges all nodes
    if (g.IO.ConfigDockingNoSplit) {
        for n := 0; n < len(dc.Nodes.Data); n += 1 {
            if node := cast(^ImGuiDockNode)dc.Nodes.Data[n].val_p; node != nil {
                if (node.IsRootNode() && node.IsSplitNode())
                {
                    DockBuilderRemoveNodeChildNodes(node.ID);
                    //dc.WantFullRebuild = true;
                }
            }
        }
    }

    // Process full rebuild
when false {
    if (IsKeyPressed(GetKeyIndex(ImGuiKey.C)))   do dc.WantFullRebuild = true
}
    if (dc.WantFullRebuild)
    {
        DockContextRebuildNodes(ctx);
        dc.WantFullRebuild = false;
    }

    // Process Undocking requests (we need to process them _before_ the UpdateMouseMovingWindowNewFrame call in NewFrame)
    for &req in dc.Requests
    {
        if (req.Type == ImGuiDockRequestType_Undock && req.UndockTargetWindow) {
            DockContextProcessUndockWindow(ctx, req.UndockTargetWindow);
        }
        else if (req.Type == ImGuiDockRequestType_Undock && req.UndockTargetNode) {
            DockContextProcessUndockNode(ctx, req.UndockTargetNode);
        }
    }
}

// Docking context update function, called by NewFrame()
DockContextNewFrameUpdateDocking :: proc(ctx : ^ImGuiContext)
{
    g := ctx;
    dc := &ctx.DockContext;
    if (!(.DockingEnable in g.IO.ConfigFlags))   do return

    // [DEBUG] Store hovered dock node.
    // We could in theory use DockNodeTreeFindVisibleNodeByPos() on the root host dock node, but using ->DockNode is a good shortcut.
    // Note this is mostly a debug thing and isn't actually used for docking target, because docking involve more detailed filtering.
    g.DebugHoveredDockNode = nil;
    if hovered_window := g.HoveredWindowUnderMovingWindow; hovered_window != nil
    {
        if (hovered_window.DockNodeAsHost) {
            g.DebugHoveredDockNode = DockNodeTreeFindVisibleNodeByPos(hovered_window.DockNodeAsHost, g.IO.MousePos);
        }
        else if (hovered_window.RootWindow.DockNode) {
            g.DebugHoveredDockNode = hovered_window.RootWindow.DockNode;
        }
    }

    // Process Docking requests
    for &req in dc.Requests {
        if (req.Type == ImGuiDockRequestType_Dock) {
            DockContextProcessDock(ctx, &req);
        }
    }
    dc.Requests.resize(0);

    // Create windows for each automatic docking nodes
    // We can have NULL pointers when we delete nodes, but because ID are recycled this should amortize nicely (and our node count will never be very high)
    for n := 0; n < len(dc.Nodes.Data); n += 1 {
        if node := cast(^ImGuiDockNode)dc.Nodes.Data[n].val_p; node != nil {
            if (node.IsFloatingNode())   do DockNodeUpdate(node)
        }
    }

}

DockContextEndFrame :: proc(ctx : ^ImGuiContext)
{
    // Draw backgrounds of node missing their window
    g := ctx;
    dc := &g.DockContext;
    for n := 0; n < len(dc.Nodes.Data); n += 1 {
        if node := cast(^ImGuiDockNode)dc.Nodes.Data[n].val_p; node != nil {
            if (node.LastFrameActive == g.FrameCount && node.IsVisible && node.HostWindow && node.IsLeafNode() && !node.IsBgDrawnThisFrame)
            {
                bg_rect := ImRect(node.Pos + ImVec2{0.0, GetFrameHeight()}, node.Pos + node.Size);
                bg_rounding_flags := CalcRoundingFlagsForRectInRect(bg_rect, node.HostWindow.Rect(), g.Style.DockingSeparatorSize);
                node.HostWindow.DrawList.ChannelsSetCurrent(DOCKING_HOST_DRAW_CHANNEL_BG);
                node.HostWindow.DrawList.AddRectFilled(bg_rect.Min, bg_rect.Max, node.LastBgColor, node.HostWindow.WindowRounding, bg_rounding_flags);
            }
        }
    }
}

DockContextFindNodeByID :: proc(ctx : ^ImGuiContext, id : ImGuiID) -> ^ImGuiDockNode
{
    return cast(^ImGuiDockNode)ctx.DockContext.Nodes.GetVoidPtr(id);
}

DockContextGenNodeID :: proc(ctx : ^ImGuiContext) -> ImGuiID
{
    // Generate an ID for new node (the exact ID value doesn't matter as long as it is not already used)
    // FIXME-OPT FIXME-DOCK: This is suboptimal, even if the node count is small enough not to be a worry.0
    // We should poke in ctx.Nodes to find a suitable ID faster. Even more so trivial that ctx.Nodes lookup is already sorted.
    id := 0x0001;
    for (DockContextFindNodeByID(ctx, id) != nil) {
        id += 1;
    }
    return id;
}

DockContextAddNode :: proc(ctx : ^ImGuiContext, id : ImGuiID) -> ^ImGuiDockNode
{
    // Generate an ID for the new node (the exact ID value doesn't matter as long as it is not already used) and add the first window.
    g := ctx;
    if (id == 0) {
        id = DockContextGenNodeID(ctx);
    }
    else {
        assert(DockContextFindNodeByID(ctx, id) == nil);
    }

    // We don't set node.LastFrameAlive on construction. Nodes are always created at all time to reflect .ini settings!
    IMGUI_DEBUG_LOG_DOCKING(g, "[docking] DockContextAddNode 0x%08X\n", id);
    node := IM_NEW(ImGuiDockNode)(id);
    ctx.DockContext.Nodes.SetVoidPtr(node.ID, node);
    return node;
}

DockContextRemoveNode :: proc(ctx : ^ImGuiContext, node : ^ImGuiDockNode, merge_sibling_into_parent_node : bool)
{
    g := ctx;
    dc := &ctx.DockContext;

    IMGUI_DEBUG_LOG_DOCKING(g, "[docking] DockContextRemoveNode 0x%08X\n", node.ID);
    assert(DockContextFindNodeByID(ctx, node.ID) == node);
    assert(node.ChildNodes[0] == nil && node.ChildNodes[1] == nil);
    assert(len(node.Windows) == 0);

    if (node.HostWindow) {
        node.HostWindow.DockNodeAsHost = nil;
    }

    parent_node := node.ParentNode;
    merge := (merge_sibling_into_parent_node && parent_node != nil);
    if (merge)
    {
        assert(parent_node.ChildNodes[0] == node || parent_node.ChildNodes[1] == node);
        sibling_node := (parent_node.ChildNodes[0] == node ? parent_node.ChildNodes[1] : parent_node.ChildNodes[0]);
        DockNodeTreeMerge(g, parent_node, sibling_node);
    }
    else
    {
        for n := 0; parent_node && n < len(parent_node.ChildNodes); n += 1 {
            if (parent_node.ChildNodes[n] == node) {
                node.ParentNode.ChildNodes[n] = nil;
            }
        }
        dc.Nodes.SetVoidPtr(node.ID, nil);
        IM_DELETE(node);
    }
}

DockNodeComparerDepthMostFirst :: proc(lhs, rhs : ^^ImGuiDockNode) -> i32
{
    a := lhs^;
    b := rhs^;
    return DockNodeGetDepth(b) - DockNodeGetDepth(a);
}

// Pre C++0x doesn't allow us to use a function-local type (without linkage) as template parameter, so we moved this here.
ImGuiDockContextPruneNodeData :: struct
{
    CountWindows, CountChildWindows, CountChildNodes : i32,
    RootId : ImGuiID,
};

// Garbage collect unused nodes (run once at init time)
DockContextPruneUnusedSettingsNodes :: proc(ctx : ^ImGuiContext)
{
    g := ctx;
    dc := &ctx.DockContext;
    assert(len(g.Windows) == 0);

    pool : ImPool(ImGuiDockContextPruneNodeData);
    Reserve(&pool, len(dc.NodesSettings));

    // Count child nodes and compute RootID
    for settings_n := 0; settings_n < len(dc.NodesSettings); settings_n += 1
    {
        settings := &dc.NodesSettings[settings_n];
        parent_data := settings.ParentNodeId ? GetByKey(&pool, settings.ParentNodeId) : 0;
        GetOrAddByKey(&pool, settings.ID)->RootId = parent_data ? parent_data.RootId : settings.ID;
        if (settings.ParentNodeId) {
            GetOrAddByKey(&pool, settings.ParentNodeId)->CountChildNodes += 1;
        }
    }

    // Count reference to dock ids from dockspaces
    // We track the 'auto-DockNode <- manual-Window <- manual-DockSpace' in order to avoid 'auto-DockNode' being ditched by DockContextPruneUnusedSettingsNodes()
    for settings_n := 0; settings_n < len(dc.NodesSettings); settings_n += 1
    {
        settings := &dc.NodesSettings[settings_n];
        if (settings.ParentWindowId != 0) {
            if window_settings := FindWindowSettingsByID(settings.ParentWindowId); window_settings != nil {
                if (window_settings.DockId) {
                    if data := GetByKey(&pool, window_settings.DockId); data != nil   do data.CountChildNodes += 1
                }
            }
        }
    }

    // Count reference to dock ids from window settings
    // We guard against the possibility of an invalid .ini file (RootID may point to a missing node)
    for settings := begin(&g.SettingsWindows); settings != nil; settings = next_chunk(&g.SettingsWindows, settings) {
        if dock_id := settings.DockId; dock_id != {} {
            if data := GetByKey(&pool, dock_id); data != nil
            {
                data.CountWindows += 1;
                if data_root := (data.RootId == dock_id) ? data : GetByKey(&pool, data.RootId); data_root != nil {
                    data_root.CountChildWindows += 1;
                }
            }
        }
    }

    // Prune
    for settings_n := 0; settings_n < len(dc.NodesSettings); settings_n += 1
    {
        settings := &dc.NodesSettings[settings_n];
        data := GetByKey(&pool, settings.ID);
        if (data.CountWindows > 1)   do continue
        data_root := (data.RootId == settings.ID) ? data : GetByKey(&pool, data.RootId);

        remove := false;
        remove |= (data.CountWindows == 1 && settings.ParentNodeId == 0 && data.CountChildNodes == 0 && !(settings.Flags & ImGuiDockNodeFlagsPrivate.CentralNode != nil));  // Floating root node with only 1 window
        remove |= (data.CountWindows == 0 && settings.ParentNodeId == 0 && data.CountChildNodes == 0); // Leaf nodes with 0 window
        remove |= (data_root.CountChildWindows == 0);
        if (remove)
        {
            IMGUI_DEBUG_LOG_DOCKING(g, "[docking] DockContextPruneUnusedSettingsNodes: Prune 0x%08X\n", settings.ID);
            DockSettingsRemoveNodeReferences(&settings.ID, 1);
            settings.ID = 0;
        }
    }
}

DockContextBuildNodesFromSettings :: proc(ctx : ^ImGuiContext, node_settings_array : ^ImGuiDockNodeSettings, node_settings_count : i32)
{
    // Build nodes
    for node_n : i32 = 0; node_n < node_settings_count; node_n += 1
    {
        settings := &node_settings_array[node_n];
        if (settings.ID == 0)   do continue
        node := DockContextAddNode(ctx, settings.ID);
        node.ParentNode = settings.ParentNodeId ? DockContextFindNodeByID(ctx, settings.ParentNodeId) : nil;
        node.Pos = ImVec2{settings.Pos.x, settings.Pos.y};
        node.Size = ImVec2{settings.Size.x, settings.Size.y};
        node.SizeRef = ImVec2{settings.SizeRef.x, settings.SizeRef.y};
        node.AuthorityForViewport = .DockNode;
        node.AuthorityForSize = .DockNode
        node.AuthorityForPos = .DockNode
        if (node.ParentNode && node.ParentNode.ChildNodes[0] == nil) {
            node.ParentNode.ChildNodes[0] = node;
        }
        else if (node.ParentNode && node.ParentNode.ChildNodes[1] == nil) {
            node.ParentNode.ChildNodes[1] = node;
        }
        node.SelectedTabId = settings.SelectedTabId;
        node.SplitAxis = cast(ImGuiAxis)settings.SplitAxis;
        SetLocalFlags(node, settings.Flags & transmute(ImGuiDockNodeFlags) ImGuiDockNodeFlagsPrivate.SavedFlagsMask_);

        // Bind host window immediately if it already exist (in case of a rebuild)
        // This is useful as the RootWindowForTitleBarHighlight links necessary to highlight the currently focused node requires node.HostWindow to be set.
        host_window_title : [20]u8;
        root_node := DockNodeGetRootNode(node);
        node.HostWindow = FindWindowByName(DockNodeGetHostWindowTitle(root_node, host_window_title, len(host_window_title)));
    }
}

// [forward declared comment]:
// Use root_id==0 to add all
DockContextBuildAddWindowsToNodes :: proc(ctx : ^ImGuiContext, root_id : ImGuiID)
{
    // Rebind all windows to nodes (they can also lazily rebind but we'll have a visible glitch during the first frame)
    g := ctx;
    for window in g.Windows
    {
        if (window.DockId == 0 || window.LastFrameActive < g.FrameCount - 1)   do continue
        if (window.DockNode != nil)   do continue

        node := DockContextFindNodeByID(ctx, window.DockId);
        assert(node != nil);   // This should have been called after DockContextBuildNodesFromSettings()
        if (root_id == 0 || DockNodeGetRootNode(node).ID == root_id) {
            DockNodeAddWindow(node, window, true);
        }
    }
}

//-----------------------------------------------------------------------------
// Docking: ImGuiDockContext Docking/Undocking functions
//-----------------------------------------------------------------------------
// - DockContextQueueDock()
// - DockContextQueueUndockWindow()
// - DockContextQueueUndockNode()
// - DockContextQueueNotifyRemovedNode()
// - DockContextProcessDock()
// - DockContextProcessUndockWindow()
// - DockContextProcessUndockNode()
// - DockContextCalcDropPosForDocking()
//-----------------------------------------------------------------------------

DockContextQueueDock :: proc(ctx : ^ImGuiContext, target : ^ImGuiWindow, target_node : ^ImGuiDockNode, payload : ^ImGuiWindow, split_dir : ImGuiDir, split_ratio : f32, split_outer : bool)
{
    assert(target != payload);
    req : ImGuiDockRequest
    req.Type = ImGuiDockRequestType_Dock;
    req.DockTargetWindow = target;
    req.DockTargetNode = target_node;
    req.DockPayload = payload;
    req.DockSplitDir = split_dir;
    req.DockSplitRatio = split_ratio;
    req.DockSplitOuter = split_outer;
    ctx.DockContext.Requests.append(req);
}

DockContextQueueUndockWindow :: proc(ctx : ^ImGuiContext, window : ^ImGuiWindow)
{
    req : ImGuiDockRequest
    req.Type = ImGuiDockRequestType_Undock;
    req.UndockTargetWindow = window;
    ctx.DockContext.Requests.append(req);
}

DockContextQueueUndockNode :: proc(ctx : ^ImGuiContext, node : ^ImGuiDockNode)
{
    req : ImGuiDockRequest
    req.Type = ImGuiDockRequestType_Undock;
    req.UndockTargetNode = node;
    ctx.DockContext.Requests.append(req);
}

DockContextQueueNotifyRemovedNode :: proc(ctx : ^ImGuiContext, node : ^ImGuiDockNode)
{
    dc := &ctx.DockContext;
    for &req in dc.Requests {
        if (req.DockTargetNode == node) {
            req.Type = ImGuiDockRequestType_None;
        }
    }
}

DockContextProcessDock :: proc(ctx : ^ImGuiContext, req : ^ImGuiDockRequest)
{
    assert((req.Type == ImGuiDockRequestType_Dock && req.DockPayload != nil) || (req.Type == ImGuiDockRequestType_Split && req.DockPayload == nil));
    assert(req.DockTargetWindow != nil || req.DockTargetNode != nil);

    g := ctx;
    _ = g;

    payload_window := req.DockPayload;     // Optional
    target_window := req.DockTargetWindow;
    node := req.DockTargetNode;
    if (payload_window) {
        IMGUI_DEBUG_LOG_DOCKING(g, "[docking] DockContextProcessDock node 0x%08X target '%s' dock window '%s', split_dir %d\n", node ? node.ID : 0, target_window ? target_window.Name : "nil", payload_window.Name, req.DockSplitDir);
    }
    else {
        IMGUI_DEBUG_LOG_DOCKING(g, "[docking] DockContextProcessDock node 0x%08X, split_dir %d\n", node ? node.ID : 0, req.DockSplitDir);
    }

    // Decide which Tab will be selected at the end of the operation
    next_selected_id := 0;
    payload_node := nil;
    if (payload_window)
    {
        payload_node = payload_window.DockNodeAsHost;
        payload_window.DockNodeAsHost = nil; // Important to clear this as the node will have its life as a child which might be merged/deleted later.
        if (payload_node && payload_node.IsLeafNode()) {
            next_selected_id = payload_node.TabBar.NextSelectedTabId ? payload_node.TabBar.NextSelectedTabId : payload_node.TabBar.SelectedTabId;
        }
        if (payload_node == nil) {
            next_selected_id = payload_window.TabId;
        }
    }

    // FIXME-DOCK: When we are trying to dock an existing single-window node into a loose window, transfer Node ID as well
    // When processing an interactive split, usually LastFrameAlive will be < g.FrameCount. But DockBuilder operations can make it ==.
    if (node) {
        assert(node.LastFrameAlive <= g.FrameCount);
    }
    if (node && target_window && node == target_window.DockNodeAsHost) {
        assert(len(node.Windows) > 0 || node.IsSplitNode() || IsCentralNode(node));
    }

    // Create new node and add existing window to it
    if (node == nil)
    {
        node = DockContextAddNode(ctx, 0);
        node.Pos = target_window.Pos;
        len(node) = len(target_window);
        if (target_window.DockNodeAsHost == nil)
        {
            DockNodeAddWindow(node, target_window, true);
            node.TabBar.Tabs[0].Flags &= ~ImGuiTabItemFlags_Unsorted;
            target_window.DockIsActive = true;
        }
    }

    split_dir := req.DockSplitDir;
    if (split_dir != nil)
    {
        // Split into two, one side will be our payload node unless we are dropping a loose window
        split_axis := (split_dir == .Left || split_dir == .Right) ? ImGuiAxis.X : ImGuiAxis.Y;
        split_inheritor_child_idx := (split_dir == .Left || split_dir == ImGuiDir.Up) ? 1 : 0; // Current contents will be moved to the opposite side
        split_ratio := req.DockSplitRatio;
        DockNodeTreeSplit(ctx, node, split_axis, split_inheritor_child_idx, split_ratio, payload_node);  // payload_node may be NULL here!
        new_node := node.ChildNodes[split_inheritor_child_idx ~ 1];
        new_node.HostWindow = node.HostWindow;
        node = new_node;
    }
    SetLocalFlags(node, node.LocalFlags & ~ImGuiDockNodeFlags_HiddenTabBar);

    if (node != payload_node)
    {
        // Create tab bar before we call DockNodeMoveWindows (which would attempt to move the old tab-bar, which would lead us to payload tabs wrongly appearing before target tabs!)
        if (len(node.Windows) > 0 && node.TabBar == nil)
        {
            DockNodeAddTabBar(node);
            for n := 0; n < len(node.Windows); n += 1 {
                TabBarAddTab(node.TabBar, ImGuiTabItemFlags_None, node.Windows[n]);
            }
        }

        if (payload_node != nil)
        {
            // Transfer full payload node (with 1+ child windows or child nodes)
            if (payload_node.IsSplitNode())
            {
                if (len(node.Windows) > 0)
                {
                    // We can dock a split payload into a node that already has windows _only_ if our payload is a node tree with a single visible node.
                    // In this situation, we move the windows of the target node into the currently visible node of the payload.
                    // This allows us to preserve some of the underlying dock tree settings nicely.
                    assert(payload_node.OnlyNodeWithWindows != nil); // The docking should have been blocked by DockNodePreviewDockSetup() early on and never submitted.
                    visible_node := payload_node.OnlyNodeWithWindows;
                    if (visible_node.TabBar) {
                        assert(len(visible_node.TabBar.Tabs) > 0);
                    }
                    DockNodeMoveWindows(node, visible_node);
                    DockNodeMoveWindows(visible_node, node);
                    DockSettingsRenameNodeReferences(node.ID, visible_node.ID);
                }
                if (IsCentralNode(node))
                {
                    // Central node property needs to be moved to a leaf node, pick the last focused one.
                    // FIXME-DOCK: If we had to transfer other flags here, what would the policy be?
                    last_focused_node := DockContextFindNodeByID(ctx, payload_node.LastFocusedNodeId);
                    assert(last_focused_node != nil);
                    last_focused_root_node := DockNodeGetRootNode(last_focused_node);
                    assert(last_focused_root_node == DockNodeGetRootNode(payload_node));
                    last_focused_SetLocalFlags(node, last_focused_node.LocalFlags | ImGuiDockNodeFlags_CentralNode);
                    SetLocalFlags(node, node.LocalFlags & ~ImGuiDockNodeFlags_CentralNode);
                    last_focused_root_node.CentralNode = last_focused_node;
                }

                assert(len(node.Windows) == 0);
                DockNodeMoveChildNodes(node, payload_node);
            }
            else
            {
                payload_dock_id := payload_node.ID;
                DockNodeMoveWindows(node, payload_node);
                DockSettingsRenameNodeReferences(payload_dock_id, node.ID);
            }
            DockContextRemoveNode(ctx, payload_node, true);
        }
        else if (payload_window)
        {
            // Transfer single window
            payload_dock_id := payload_window.DockId;
            node.VisibleWindow = payload_window;
            DockNodeAddWindow(node, payload_window, true);
            if (payload_dock_id != 0) {
                DockSettingsRenameNodeReferences(payload_dock_id, node.ID);
            }
        }
    }
    else
    {
        // When docking a floating single window node we want to reevaluate auto-hiding of the tab bar
        node.WantHiddenTabBarUpdate = true;
    }

    // Update selection immediately
    if tab_bar := node.TabBar; tab_bar != nil {
        tab_bar.NextSelectedTabId = next_selected_id;
    }
    MarkIniSettingsDirty();
}

// Problem:
//   Undocking a large (~full screen) window would leave it so large that the bottom right sizing corner would more
//   than likely be off the screen and the window would be hard to resize to fit on screen. This can be particularly problematic
//   with 'ConfigWindowsMoveFromTitleBarOnly=true' and/or with 'ConfigWindowsResizeFromEdges=false' as well (the later can be
//   due to missing ImGuiBackendFlags_HasMouseCursors backend flag).
// Solution:
//   When undocking a window we currently force its maximum size to 90% of the host viewport or monitor.
// Reevaluate this when we implement preserving docked/undocked size ("docking_wip/undocked_size" branch).
FixLargeWindowsWhenUndocking :: proc(size : ImVec2, ref_viewport : ^ImGuiViewport) -> ImVec2
{
    if (ref_viewport == nil)   do return size

    g := GImGui;
    max_size := ImTrunc(ref_viewport.WorkSize * 0.90);
    if (.ViewportsEnable in g.ConfigFlagsCurrFrame)
    {
        monitor := GetViewportPlatformMonitor(ref_viewport);
        max_size = ImTrunc(monitor.WorkSize * 0.90);
    }
    return ImMin(size, max_size);
}

DockContextProcessUndockWindow :: proc(ctx : ^ImGuiContext, window : ^ImGuiWindow, clear_persistent_docking_ref : bool = true)
{
    g := ctx;
    IMGUI_DEBUG_LOG_DOCKING(g, "[docking] DockContextProcessUndockWindow window '%s', clear_persistent_docking_ref = %d\n", window.Name, clear_persistent_docking_ref);
    if (window.DockNode != nil) {
        DockNodeRemoveWindow(window.DockNode, window, clear_persistent_docking_ref ? 0 : window.DockId);
    }
    else {
        window.DockId = 0;
    }
    window.Collapsed = false;
    window.DockIsActive = false;
    window.DockTabIsVisible = false;
    window.DockNodeIsVisible = false
    window.SizeFull = FixLargeWindowsWhenUndocking(window.SizeFull, window.Viewport);
    window.Size = window.SizeFull

    MarkIniSettingsDirty();
}

DockContextProcessUndockNode :: proc(ctx : ^ImGuiContext, node : ^ImGuiDockNode)
{
    g := ctx;
    IMGUI_DEBUG_LOG_DOCKING(g, "[docking] DockContextProcessUndockNode node %08X\n", node.ID);
    assert(node.IsLeafNode());
    assert(len(node.Windows) >= 1);

    if (node.IsRootNode() || IsCentralNode(node))
    {
        // In the case of a root node or central node, the node will have to stay in place. Create a new node to receive the payload.
        new_node := DockContextAddNode(ctx, 0);
        new_node.Pos = node.Pos;
        len(new_node) = len(node);
        new_node.SizeRef = node.SizeRef;
        DockNodeMoveWindows(new_node, node);
        DockSettingsRenameNodeReferences(node.ID, new_node.ID);
        node = new_node;
    }
    else
    {
        // Otherwise extract our node and merge our sibling back into the parent node.
        assert(node.ParentNode.ChildNodes[0] == node || node.ParentNode.ChildNodes[1] == node);
        index_in_parent := (node.ParentNode.ChildNodes[0] == node) ? 0 : 1;
        node.ParentNode.ChildNodes[index_in_parent] = nil;
        DockNodeTreeMerge(ctx, node.ParentNode, node.ParentNode.ChildNodes[index_in_parent ~ 1]);
        node.ParentNode.AuthorityForViewport = ImGuiDataAuthority_Window; // The node that stays in place keeps the viewport, so our newly dragged out node will create a new viewport
        node.ParentNode = nil;
    }
    for window in node.Windows
    {
        window.Flags &= ~ImGuiWindowFlags_ChildWindow;
        if (window.ParentWindow != nil) {
            window.ParentWindow.DC.ChildWindows.find_erase(window);
        }
        UpdateWindowParentAndRootLinks(window, window.Flags, nil);
    }
    node.AuthorityForSize = .DockNode;
    node.AuthorityForPos = .DockNode;
    len(node) = FixLargeWindowsWhenUndocking(node.Size, node.Windows[0]->Viewport);
    node.WantMouseMove = true;
    MarkIniSettingsDirty();
}

// This is mostly used for automation.
DockContextCalcDropPosForDocking :: proc(target : ^ImGuiWindow, target_node : ^ImGuiDockNode, payload_window : ^ImGuiWindow, payload_node : ^ImGuiDockNode, split_dir : ImGuiDir, split_outer : bool, out_pos : ^ImVec2) -> bool
{
    if (target != nil && target_node == nil) {
        target_node = target.DockNode;
    }

    // In DockNodePreviewDockSetup() for a root central node instead of showing both "inner" and "outer" drop rects
    // (which would be functionally identical) we only show the outer one. Reflect this here.
    if (target_node && target_node.ParentNode == nil && target_IsCentralNode(node) && split_dir != nil)   do split_outer = true
    split_data : ImGuiDockPreviewData
    DockNodePreviewDockSetup(target, target_node, payload_window, payload_node, &split_data, false, split_outer);
    if (split_data.DropRectsDraw[split_dir+1].IsInverted())   do return false
    out_pos^ = split_data.DropRectsDraw[split_dir+1].GetCenter();
    return true;
}

//-----------------------------------------------------------------------------
// Docking: ImGuiDockNode
//-----------------------------------------------------------------------------
// - DockNodeGetTabOrder()
// - DockNodeAddWindow()
// - DockNodeRemoveWindow()
// - DockNodeMoveChildNodes()
// - DockNodeMoveWindows()
// - DockNodeApplyPosSizeToWindows()
// - DockNodeHideHostWindow()
// - ImGuiDockNodeFindInfoResults
// - DockNodeFindInfo()
// - DockNodeFindWindowByID()
// - DockNodeUpdateFlagsAndCollapse()
// - DockNodeUpdateHasCentralNodeFlag()
// - DockNodeUpdateVisibleFlag()
// - DockNodeStartMouseMovingWindow()
// - DockNodeUpdate()
// - DockNodeUpdateWindowMenu()
// - DockNodeBeginAmendTabBar()
// - DockNodeEndAmendTabBar()
// - DockNodeUpdateTabBar()
// - DockNodeAddTabBar()
// - DockNodeRemoveTabBar()
// - DockNodeIsDropAllowedOne()
// - DockNodeIsDropAllowed()
// - DockNodeCalcTabBarLayout()
// - DockNodeCalcSplitRects()
// - DockNodeCalcDropRectsAndTestMousePos()
// - DockNodePreviewDockSetup()
// - DockNodePreviewDockRender()
//-----------------------------------------------------------------------------

init_ImGuiDockNode :: proc(this : ^ImGuiDockNode, id : ImGuiID)
{
    this^ = {}
    this.ID = id;
    this.ChildNodes[1] = nil;
    this.ChildNodes[0] = nil

    this.State = .Unknown;
    this.LastBgColor = IM_COL32_WHITE;
    this.LastFrameFocused = -1;
    this.LastFrameActive = -1
    this.LastFrameAlive = -1
    this.AuthorityForSize = .DockNode;
    this.AuthorityForPos = .DockNode
    this.AuthorityForViewport = .Auto;
    this.IsVisible = true;
}

deinit_ImGuiDockNode :: proc(this : ^ImGuiDockNode)
{
    IM_DELETE(this.TabBar);
    this.TabBar = nil;
    this.ChildNodes[0] = nil
    this.ChildNodes[1] = nil;
}

DockNodeGetTabOrder :: proc(window : ^ImGuiWindow) -> i32
{
    tab_bar := window.DockNode.TabBar;
    if (tab_bar == nil)   do return -1
    tab := TabBarFindTabByID(tab_bar, window.TabId);
    return tab ? TabBarGetTabOrder(tab_bar, tab) : -1;
}

DockNodeHideWindowDuringHostWindowCreation :: proc(window : ^ImGuiWindow)
{
    window.Hidden = true;
    window.HiddenFramesCanSkipItems = window.Active ? 1 : 2;
}

DockNodeAddWindow :: proc(node : ^ImGuiDockNode, window : ^ImGuiWindow, add_to_tab_bar : bool)
{
    g := GImGui;
    _ := g;
    if (window.DockNode != nil)
    {
        // Can overwrite an existing window.DockNode (e.g. pointing to a disabled DockSpace node)
        assert(window.DockNode.ID != node.ID);
        DockNodeRemoveWindow(window.DockNode, window, 0);
    }
    assert(window.DockNode == nil || window.DockNodeAsHost == nil);
    IMGUI_DEBUG_LOG_DOCKING(g, "[docking] DockNodeAddWindow node 0x%08X window '%s'\n", node.ID, window.Name);

    // If more than 2 windows appeared on the same frame leading to the creation of a new hosting window,
    // we'll hide windows until the host window is ready. Hide the 1st window after its been output (so it is not visible for one frame).
    // We will call DockNodeHideWindowDuringHostWindowCreation() on ourselves in Begin()
    if (node.HostWindow == nil && len(node.Windows) == 1 && node.Windows[0]->WasActive == false) {
        DockNodeHideWindowDuringHostWindowCreation(node.Windows[0]);
    }

    node.Windows.append(window);
    node.WantHiddenTabBarUpdate = true;
    window.DockNode = node;
    window.DockId = node.ID;
    window.DockIsActive = (len(node.Windows) > 1);
    window.DockTabWantClose = false;

    // When reactivating a node with one or two loose window, the window pos/size/viewport are authoritative over the node storage.
    // In particular it is important we init the viewport from the first window so we don't create two viewports and drop one.
    if (node.HostWindow == nil && node.IsFloatingNode())
    {
        if (node.AuthorityForPos == ImGuiDataAuthority_Auto) {
            node.AuthorityForPos = ImGuiDataAuthority_Window;
        }
        if (node.AuthorityForSize == ImGuiDataAuthority_Auto) {
            node.AuthorityForSize = ImGuiDataAuthority_Window;
        }
        if (node.AuthorityForViewport == ImGuiDataAuthority_Auto) {
            node.AuthorityForViewport = ImGuiDataAuthority_Window;
        }
    }

    // Add to tab bar if requested
    if (add_to_tab_bar)
    {
        if (node.TabBar == nil)
        {
            DockNodeAddTabBar(node);
            node.TabBar.NextSelectedTabId = node.SelectedTabId;
            node.TabBar.SelectedTabId = node.SelectedTabId

            // Add existing windows
            for n := 0; n < len(node.Windows) - 1; n += 1 {
                TabBarAddTab(node.TabBar, ImGuiTabItemFlags_None, node.Windows[n]);
            }
        }
        TabBarAddTab(node.TabBar, ImGuiTabItemFlags_Unsorted, window);
    }

    DockNodeUpdateVisibleFlag(node);

    // Update this without waiting for the next time we Begin() in the window, so our host window will have the proper title bar color on its first frame.
    if (node.HostWindow) {
        UpdateWindowParentAndRootLinks(window, window.Flags | ImGuiWindowFlags_ChildWindow, node.HostWindow);
    }

}

DockNodeRemoveWindow :: proc(node : ^ImGuiDockNode, window : ^ImGuiWindow, save_dock_id : ImGuiID)
{
    g := GImGui;
    assert(window.DockNode == node);
    //assert(window.RootWindowDockTree == node.HostWindow);
    //assert(window.LastFrameActive < g.FrameCount);    // We may call this from Begin()
    assert(save_dock_id == 0 || save_dock_id == node.ID);
    IMGUI_DEBUG_LOG_DOCKING(g, "[docking] DockNodeRemoveWindow node 0x%08X window '%s'\n", node.ID, window.Name);

    window.DockNode = nil;
    window.DockTabWantClose = false;
    window.DockIsActive = false
    window.DockId = save_dock_id;
    window.Flags &= ~{.ChildWindow};
    if (window.ParentWindow != nil) {
        find_erase(&window.ParentWindow.DC.ChildWindows, window);
    }

    UpdateWindowParentAndRootLinks(window, window.Flags, nil); // Update immediately

    if (node.HostWindow != nil && node.HostWindow.ViewportOwned)
    {
        // When undocking from a user interaction this will always run in NewFrame() and have not much effect.
        // But mid-frame, if we clear viewport we need to mark window as hidden as well.
        window.Viewport = nil;
        window.ViewportId = 0;
        window.ViewportOwned = false;
        window.Hidden = true;
    }

    // Remove window
    erased := false;
    for n := 0; n < len(node.Windows); n += 1 {
        if (node.Windows[n] == window)
        {
            erase(&node.Windows, node.Windows.Data + n);
            erased = true;
            break;
        }
    }
    if (!erased)   do assert(erased)
    if (node.VisibleWindow == window)   do node.VisibleWindow = nil

    // Remove tab and possibly tab bar
    node.WantHiddenTabBarUpdate = true;
    if (node.TabBar)
    {
        TabBarRemoveTab(node.TabBar, window.TabId);
        tab_count_threshold_for_tab_bar := IsCentralNode(node) ? 1 : 2;
        if (len(node.Windows) < tab_count_threshold_for_tab_bar) {
            DockNodeRemoveTabBar(node);
        }
    }

    if (len(node.Windows) == 0 && !IsCentralNode(node) && !node.IsDockSpace() && window.DockId != node.ID)
    {
        // Automatic dock node delete themselves if they are not holding at least one tab
        DockContextRemoveNode(g, node, true);
        return;
    }

    if (len(node.Windows) == 1 && !IsCentralNode(node) && node.HostWindow)
    {
        remaining_window := node.Windows[0];
        // Note: we used to transport viewport ownership here.
        remaining_window.Collapsed = node.HostWindow.Collapsed;
    }

    // Update visibility immediately is required so the DockNodeUpdateRemoveInactiveChilds() processing can reflect changes up the tree
    DockNodeUpdateVisibleFlag(node);
}

DockNodeMoveChildNodes :: proc(dst_node : ^ImGuiDockNode, src_node : ^ImGuiDockNode)
{
    assert(len(dst_node.Windows) == 0);
    dst_node.ChildNodes[0] = src_node.ChildNodes[0];
    dst_node.ChildNodes[1] = src_node.ChildNodes[1];
    if (dst_node.ChildNodes[0]) {
        dst_node.ChildNodes[0]->ParentNode = dst_node;
    }
    if (dst_node.ChildNodes[1]) {
        dst_node.ChildNodes[1]->ParentNode = dst_node;
    }
    dst_node.SplitAxis = src_node.SplitAxis;
    dst_node.SizeRef = src_node.SizeRef;
    src_node.ChildNodes[1] = nil;
    src_node.ChildNodes[0] = nil
}

DockNodeMoveWindows :: proc(dst_node : ^ImGuiDockNode, src_node : ^ImGuiDockNode)
{
    // Insert tabs in the same orders as currently ordered (node.Windows isn't ordered)
    assert(src_node && dst_node && dst_node != src_node);
    src_tab_bar := src_node.TabBar;
    if (src_tab_bar != nil) {
        assert(len(src_node.Windows) <= src_node.TabBar.Tabs.Size);
    }

    // If the dst_node is empty we can just move the entire tab bar (to preserve selection, scrolling, etc.)
    move_tab_bar := (src_tab_bar != nil) && (dst_node.TabBar == nil);
    if (move_tab_bar)
    {
        dst_node.TabBar = src_node.TabBar;
        src_node.TabBar = nil;
    }

    // Tab order is not important here, it is preserved by sorting in DockNodeUpdateTabBar().
    for window in src_node.Windows
    {
        window.DockNode = nil;
        window.DockIsActive = false;
        DockNodeAddWindow(dst_node, window, !move_tab_bar);
    }
    src_node.Windows.clear();

    if (!move_tab_bar && src_node.TabBar)
    {
        if (dst_node.TabBar) {
            dst_node.TabBar.SelectedTabId = src_node.TabBar.SelectedTabId;
        }
        DockNodeRemoveTabBar(src_node);
    }
}

DockNodeApplyPosSizeToWindows :: proc(node : ^ImGuiDockNode)
{
    for window in node.Windows
    {
        SetWindowPos(window, node.Pos, { .Always }); // We don't assign directly to Pos because it can break the calculation of SizeContents on next frame
        SetWindowSize(window, node.Size, { .Always });
    }
}

DockNodeHideHostWindow :: proc(node : ^ImGuiDockNode)
{
    if (node.HostWindow)
    {
        if (node.HostWindow.DockNodeAsHost == node) {
            node.HostWindow.DockNodeAsHost = nil;
        }
        node.HostWindow = nil;
    }

    if (len(node.Windows) == 1)
    {
        node.VisibleWindow = node.Windows[0];
        node.Windows[0]->DockIsActive = false;
    }

    if (node.TabBar) {
        DockNodeRemoveTabBar(node);
    }
}

// Search function called once by root node in DockNodeUpdate()
ImGuiDockNodeTreeInfo :: struct
{
    CentralNode : ^ImGuiDockNode,
    FirstNodeWithWindows : ^ImGuiDockNode,
    CountNodesWithWindows : i32,
    //ImGuiWindowClass  WindowClassForMerges;
};

DockNodeFindInfo :: proc(node : ^ImGuiDockNode, info : ^ImGuiDockNodeTreeInfo)
{
    if (len(node.Windows) > 0)
    {
        if (info.FirstNodeWithWindows == nil) {
            info.FirstNodeWithWindows = node;
        }
        info.CountNodesWithWindows += 1;
    }
    if (IsCentralNode(node))
    {
        assert(info.CentralNode == nil); // Should be only one
        assert(node.IsLeafNode(), "If you get this assert: please submit .ini file + repro of actions leading to this.");
        info.CentralNode = node;
    }
    if (info.CountNodesWithWindows > 1 && info.CentralNode != nil)   do return
    if (node.ChildNodes[0]) {
        DockNodeFindInfo(node.ChildNodes[0], info);
    }
    if (node.ChildNodes[1]) {
        DockNodeFindInfo(node.ChildNodes[1], info);
    }
}

DockNodeFindWindowByID :: proc(node : ^ImGuiDockNode, id : ImGuiID) -> ^ImGuiWindow
{
    assert(id != 0);
    for window in node.Windows {
        if (window.ID == id)   do return window
    }
    return nil;
}

// - Remove inactive windows/nodes.
// - Update visibility flag.
DockNodeUpdateFlagsAndCollapse :: proc(node : ^ImGuiDockNode)
{
    g := GImGui;
    assert(node.ParentNode == nil || node.ParentNode.ChildNodes[0] == node || node.ParentNode.ChildNodes[1] == node);

    // Inherit most flags
    if (node.ParentNode) {
        node.SharedFlags = node.ParentNode.SharedFlags & ImGuiDockNodeFlags_SharedFlagsInheritMask_;
    }

    // Recurse into children
    // There is the possibility that one of our child becoming empty will delete itself and moving its sibling contents into 'node'.
    // If 'node.ChildNode[0]' delete itself, then 'node.ChildNode[1]->Windows' will be moved into 'node'
    // If 'node.ChildNode[1]' delete itself, then 'node.ChildNode[0]->Windows' will be moved into 'node' and the "remove inactive windows" loop will have run twice on those windows (harmless)
    node.HasCentralNodeChild = false;
    if (node.ChildNodes[0]) {
        DockNodeUpdateFlagsAndCollapse(node.ChildNodes[0]);
    }
    if (node.ChildNodes[1]) {
        DockNodeUpdateFlagsAndCollapse(node.ChildNodes[1]);
    }

    // Remove inactive windows, collapse nodes
    // Merge node flags overrides stored in windows
    node.LocalFlagsInWindows = ImGuiDockNodeFlags_None;
    for window_n := 0; window_n < len(node.Windows); window_n += 1
    {
        window := node.Windows[window_n];
        assert(window.DockNode == node);

        node_was_active := (node.LastFrameActive + 1 == g.FrameCount);
        remove := false;
        remove |= node_was_active && (window.LastFrameActive + 1 < g.FrameCount);
        remove |= node_was_active && (node.WantCloseAll || node.WantCloseTabId == window.TabId) && window.HasCloseButton && !(.UnsavedDocument in window.Flags);  // Submit all _expected_ closure from last frame
        remove |= (window.DockTabWantClose);
        if (remove)
        {
            window.DockTabWantClose = false;
            if (len(node.Windows) == 1 && !IsCentralNode(node))
            {
                DockNodeHideHostWindow(node);
                node.State = ImGuiDockNodeState_HostWindowHiddenBecauseSingleWindow;
                DockNodeRemoveWindow(node, window, node.ID); // Will delete the node so it'll be invalid on return
                return;
            }
            DockNodeRemoveWindow(node, window, node.ID);
            window_n -= 1;
            continue;
        }

        // FIXME-DOCKING: Missing policies for conflict resolution, hence the "Experimental" tag on this.
        //node.LocalFlagsInWindow &= ~window.WindowClass.DockNodeFlagsOverrideClear;
        node.LocalFlagsInWindows |= window.WindowClass.DockNodeFlagsOverrideSet;
    }
    node.UpdateMergedFlags();

    // Auto-hide tab bar option
    node_flags := node.MergedFlags;
    if (node.WantHiddenTabBarUpdate && len(node.Windows) == 1 && (.AutoHideTabBar in node_flags) && !node.IsHiddenTabBar()) {
        node.WantHiddenTabBarToggle = true;
    }

    node.WantHiddenTabBarUpdate = false;

    // Cancel toggling if we know our tab bar is enforced to be hidden at all times
    if (node.WantHiddenTabBarToggle && node.VisibleWindow && (node.VisibleWindow.WindowClass.DockNodeFlagsOverrideSet & ImGuiDockNodeFlags_HiddenTabBar)) {
        node.WantHiddenTabBarToggle = false;
    }

    // Apply toggles at a single point of the frame (here!)
    if (len(node.Windows) > 1) {
        SetLocalFlags(node, node.LocalFlags & ~ImGuiDockNodeFlags_HiddenTabBar);
    }
    else if (node.WantHiddenTabBarToggle) {
        SetLocalFlags(node, node.LocalFlags ~ ImGuiDockNodeFlags_HiddenTabBar);
    }

    node.WantHiddenTabBarToggle = false;

    DockNodeUpdateVisibleFlag(node);
}

// This is rarely called as DockNodeUpdateForRootNode() generally does it most frames.
DockNodeUpdateHasCentralNodeChild :: proc(node : ^ImGuiDockNode)
{
    node.HasCentralNodeChild = false;
    if (node.ChildNodes[0]) {
        DockNodeUpdateHasCentralNodeChild(node.ChildNodes[0]);
    }

    if (node.ChildNodes[1]) {
        DockNodeUpdateHasCentralNodeChild(node.ChildNodes[1]);
    }

    if (node.IsRootNode())
    {
        mark_node := node.CentralNode;
        for (mark_node)
        {
            mark_node.HasCentralNodeChild = true;
            mark_node = mark_node.ParentNode;
        }
    }
}

DockNodeUpdateVisibleFlag :: proc(node : ^ImGuiDockNode)
{
    // Update visibility flag
    is_visible := (node.ParentNode == nil) ? node.IsDockSpace() : IsCentralNode(node);
    is_visible |= (len(node.Windows) > 0);
    is_visible |= (node.ChildNodes[0] && node.ChildNodes[0]->IsVisible);
    is_visible |= (node.ChildNodes[1] && node.ChildNodes[1]->IsVisible);
    node.IsVisible = is_visible;
}

DockNodeStartMouseMovingWindow :: proc(node : ^ImGuiDockNode, window : ^ImGuiWindow)
{
    g := GImGui;
    assert(node.WantMouseMove == true);
    StartMouseMovingWindow(window);
    g.ActiveIdClickOffset = g.IO.MouseClickedPos[0] - node.Pos;
    g.MovingWindow = window; // If we are docked into a non moveable root window, StartMouseMovingWindow() won't set g.MovingWindow. Override that decision.
    node.WantMouseMove = false;
}

// Update CentralNode, OnlyNodeWithWindows, LastFocusedNodeID. Copy window class.
DockNodeUpdateForRootNode :: proc(node : ^ImGuiDockNode)
{
    DockNodeUpdateFlagsAndCollapse(node);

    // - Setup central node pointers
    // - Find if there's only a single visible window in the hierarchy (in which case we need to display a regular title bar -> FIXME-DOCK: that last part is not done yet!)
    // Cannot merge this with DockNodeUpdateFlagsAndCollapse() because FirstNodeWithWindows is found after window removal and child collapsing
    info : ImGuiDockNodeTreeInfo
    DockNodeFindInfo(node, &info);
    node.CentralNode = info.CentralNode;
    node.OnlyNodeWithWindows = (info.CountNodesWithWindows == 1) ? info.FirstNodeWithWindows : nil;
    node.CountNodeWithWindows = info.CountNodesWithWindows;
    if (node.LastFocusedNodeId == 0 && info.FirstNodeWithWindows != nil) {
        node.LastFocusedNodeId = info.FirstNodeWithWindows.ID;
    }

    // Copy the window class from of our first window so it can be used for proper dock filtering.
    // When node has mixed windows, prioritize the class with the most constraint (DockingAllowUnclassed = false) as the reference to copy.
    // FIXME-DOCK: We don't recurse properly, this code could be reworked to work from DockNodeUpdateScanRec.
    if first_node_with_windows := info.FirstNodeWithWindows; first_node_with_windows
    {
        node.WindowClass = first_node_with_windows.Windows[0]->WindowClass;
        for n := 1; n < len(first_node_with_windows.Windows); n += 1 {
            if (first_node_with_windows.Windows[n]->WindowClass.DockingAllowUnclassed == false)
            {
                node.WindowClass = first_node_with_windows.Windows[n]->WindowClass;
                break;
            }
        }
    }

    mark_node := node.CentralNode;
    for (mark_node)
    {
        mark_node.HasCentralNodeChild = true;
        mark_node = mark_node.ParentNode;
    }
}

DockNodeSetupHostWindow :: proc(node : ^ImGuiDockNode, host_window : ^ImGuiWindow)
{
    // Remove ourselves from any previous different host window
    // This can happen if a user mistakenly does (see #4295 for details):
    //  - N+0: DockBuilderAddNode(id, 0)    // missing ImGuiDockNodeFlags_DockSpace
    //  - N+1: NewFrame()                   // will create floating host window for that node
    //  - N+1: DockSpace(id)                // requalify node as dockspace, moving host window
    if (node.HostWindow && node.HostWindow != host_window && node.HostWindow.DockNodeAsHost == node) {
        node.HostWindow.DockNodeAsHost = nil;
    }

    host_window.DockNodeAsHost = node;
    node.HostWindow = host_window;
}

DockNodeUpdate :: proc(node : ^ImGuiDockNode)
{
    g := GImGui;
    assert(node.LastFrameActive != g.FrameCount);
    node.LastFrameAlive = g.FrameCount;
    node.IsBgDrawnThisFrame = false;

    node.OnlyNodeWithWindows = nil;
    node.CentralNode = nil
    if (node.IsRootNode()) {
        DockNodeUpdateForRootNode(node);
    }

    // Remove tab bar if not needed
    if (node.TabBar && node.IsNoTabBar()) {
        DockNodeRemoveTabBar(node);
    }

    // Early out for hidden root dock nodes (when all DockId references are in inactive windows, or there is only 1 floating window holding on the DockId)
    want_to_hide_host_window := false;
    if (node.IsFloatingNode())
    {
        if (len(node.Windows) <= 1 && node.IsLeafNode()) {
            if (!g.IO.ConfigDockingAlwaysTabBar && (len(node.Windows) == 0 || !node.Windows[0]->WindowClass.DockingAlwaysTabBar)) {
                want_to_hide_host_window = true;
            }
        }

        if (node.CountNodeWithWindows == 0) {
            want_to_hide_host_window = true;
        }

    }
    if (want_to_hide_host_window)
    {
        if (len(node.Windows) == 1)
        {
            // Floating window pos/size is authoritative
            single_window := node.Windows[0];
            node.Pos = single_window.Pos;
            len(node) = single_window.SizeFull;
            node.AuthorityForViewport = ImGuiDataAuthority_Window;
            node.AuthorityForSize = ImGuiDataAuthority_Window
            node.AuthorityForPos = ImGuiDataAuthority_Window

            // Transfer focus immediately so when we revert to a regular window it is immediately selected
            if (node.HostWindow && g.NavWindow == node.HostWindow) {
                FocusWindow(single_window);
            }

            if (node.HostWindow)
            {
                IMGUI_DEBUG_LOG_VIEWPORT("[viewport] Node %08X transfer Viewport %08X->%08X to Window '%s'\n", node.ID, node.HostWindow.Viewport.ID, single_window.ID, single_window.Name);
                single_window.Viewport = node.HostWindow.Viewport;
                single_window.ViewportId = node.HostWindow.ViewportId;
                if (node.HostWindow.ViewportOwned)
                {
                    single_window.Viewport.ID = single_window.ID;
                    single_window.Viewport.Window = single_window;
                    single_window.ViewportOwned = true;
                }
            }
            node.RefViewportId = single_window.ViewportId;
        }

        DockNodeHideHostWindow(node);
        node.State = ImGuiDockNodeState_HostWindowHiddenBecauseSingleWindow;
        node.WantCloseAll = false;
        node.WantCloseTabId = 0;
        node.HasWindowMenuButton = false;
        node.HasCloseButton = false
        node.LastFrameActive = g.FrameCount;

        if (node.WantMouseMove && len(node.Windows) == 1) {
            DockNodeStartMouseMovingWindow(node, node.Windows[0]);
        }

        return;
    }

    // In some circumstance we will defer creating the host window (so everything will be kept hidden),
    // while the expected visible window is resizing itself.
    // This is important for first-time (no ini settings restored) single window when io.ConfigDockingAlwaysTabBar is enabled,
    // otherwise the node ends up using the minimum window size. Effectively those windows will take an extra frame to show up:
    //   N+0: Begin(): window created (with no known size), node is created
    //   N+1: DockNodeUpdate(): node skip creating host window / Begin(): window size applied, not visible
    //   N+2: DockNodeUpdate(): node can create host window / Begin(): window becomes visible
    // We could remove this frame if we could reliably calculate the expected window size during node update, before the Begin() code.
    // It would require a generalization of CalcWindowExpectedSize(), probably extracting code away from Begin().
    // In reality it isn't very important as user quickly ends up with size data in .ini file.
    if (node.IsVisible && node.HostWindow == nil && node.IsFloatingNode() && node.IsLeafNode())
    {
        assert(len(node.Windows) > 0);
        ref_window := nil;
        if (node.SelectedTabId != 0) {// Note that we prune single-window-node settings on .ini loading, so this is generally 0 for them!
            ref_window = DockNodeFindWindowByID(node, node.SelectedTabId);
        }

        if (ref_window == nil) {
            ref_window = node.Windows[0];
        }

        if (ref_window.AutoFitFramesX > 0 || ref_window.AutoFitFramesY > 0)
        {
            node.State = ImGuiDockNodeState_HostWindowHiddenBecauseWindowsAreResizing;
            return;
        }
    }

    node_flags := node.MergedFlags;

    // Decide if the node will have a close button and a window menu button
    node.HasWindowMenuButton = (len(node.Windows) > 0) && (.NoWindowMenuButton not_in node_flags);
    node.HasCloseButton = false;
    for window in node.Windows
    {
        // FIXME-DOCK: Setting DockIsActive here means that for single active window in a leaf node, DockIsActive will be cleared until the next Begin() call.
        node.HasCloseButton |= window.HasCloseButton;
        window.DockIsActive = (len(node.Windows) > 1);
    }
    if (.NoCloseButton in node_flags) {
        node.HasCloseButton = false;
    }

    // Bind or create host window
    host_window := nil;
    beginned_into_host_window := false;
    if (node.IsDockSpace())
    {
        // [Explicit root dockspace node]
        assert(node.HostWindow);
        host_window = node.HostWindow;
    }
    else
    {
        // [Automatic root or child nodes]
        if (node.IsRootNode() && node.IsVisible)
        {
            ref_window := (len(node.Windows) > 0) ? node.Windows[0] : nil;

            // Sync Pos
            if (node.AuthorityForPos == ImGuiDataAuthority_Window && ref_window) {
                SetNextWindowPos(ref_window.Pos);
            }
            else if (node.AuthorityForPos == .DockNode) {
                SetNextWindowPos(node.Pos);
            }

            // Sync Size
            if (node.AuthorityForSize == ImGuiDataAuthority_Window && ref_window) {
                SetNextWindowSize(ref_window.SizeFull);
            }
            else if (node.AuthorityForSize == .DockNode) {
                SetNextWindowSize(node.Size);
            }

            // Sync Collapsed
            if (node.AuthorityForSize == ImGuiDataAuthority_Window && ref_window) {
                SetNextWindowCollapsed(ref_window.Collapsed);
            }

            // Sync Viewport
            if (node.AuthorityForViewport == ImGuiDataAuthority_Window && ref_window) {
                SetNextWindowViewport(ref_window.ViewportId);
            }
            else if (node.AuthorityForViewport == ImGuiDataAuthority_Window && node.RefViewportId != 0) {
                SetNextWindowViewport(node.RefViewportId);
            }

            SetNextWindowClass(&node.WindowClass);

            // Begin into the host window
            window_label : [20]u8;
            DockNodeGetHostWindowTitle(node, window_label, len(window_label));
            window_flags := ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_NoScrollWithMouse | ImGuiWindowFlags_DockNodeHost;
            window_flags |= ImGuiWindowFlags_NoFocusOnAppearing;
            window_flags |= ImGuiWindowFlags_NoSavedSettings | ImGuiWindowFlags_NoNavFocus | ImGuiWindowFlags_NoCollapse;
            window_flags |= ImGuiWindowFlags_NoTitleBar;

            SetNextWindowBgAlpha(0.0); // Don't set ImGuiWindowFlags_NoBackground because it disables borders
            PushStyleVar(ImGuiStyleVar_WindowPadding, ImVec2{0, 0});
            Begin(window_label, nil, window_flags);
            PopStyleVar();
            beginned_into_host_window = true;

            host_window = g.CurrentWindow;
            DockNodeSetupHostWindow(node, host_window);
            host_window.DC.CursorPos = host_window.Pos;
            node.Pos = host_window.Pos;
            len(node) = len(host_window);

            // We set ImGuiWindowFlags_NoFocusOnAppearing because we don't want the host window to take full focus (e.g. steal NavWindow)
            // But we still it bring it to the front of display. There's no way to choose this precise behavior via window flags.
            // One simple case to ponder if: window A has a toggle to create windows B/C/D. Dock B/C/D together, clear the toggle and enable it again.
            // When reappearing B/C/D will request focus and be moved to the top of the display pile, but they are not linked to the dock host window
            // during the frame they appear. The dock host window would keep its old display order, and the sorting in EndFrame would move B/C/D back
            // after the dock host window, losing their top-most status.
            if (node.HostWindow.Appearing) {
                BringWindowToDisplayFront(node.HostWindow);
            }

            node.AuthorityForViewport = ImGuiDataAuthority_Auto;
            node.AuthorityForSize = ImGuiDataAuthority_Auto
            node.AuthorityForPos = ImGuiDataAuthority_Auto
        }
        else if (node.ParentNode)
        {
            host_window = node.ParentNode.HostWindow;
            node.HostWindow = host_window
            node.AuthorityForViewport = ImGuiDataAuthority_Auto;
            node.AuthorityForSize = ImGuiDataAuthority_Auto
            node.AuthorityForPos = ImGuiDataAuthority_Auto
        }
        if (node.WantMouseMove && node.HostWindow) {
            DockNodeStartMouseMovingWindow(node, node.HostWindow);
        }

    }
    node.RefViewportId = 0; // Clear when we have a host window

    // Update focused node (the one whose title bar is highlight) within a node tree
    if (node.IsSplitNode()) {
        assert(node.TabBar == nil);
    }

    if (node.IsRootNode()) {
        if p_window := g.NavWindow ? g.NavWindow.RootWindow : nil; p_window != nil {
            for (p_window != nil && p_window.DockNode != nil)
            {
                p_node := DockNodeGetRootNode(p_window.DockNode);
                if (p_node == node)
                {
                    node.LastFocusedNodeId = p_window.DockNode.ID; // Note: not using root node ID!
                    break;
                }
                p_window = p_node.HostWindow ? p_node.HostWindow.RootWindow : nil;
            }
        }
    }

    // Register a hit-test hole in the window unless we are currently dragging a window that is compatible with our dockspace
    central_node := node.CentralNode;
    central_node_hole := node.IsRootNode() && host_window && (.PassthruCentralNode in node_flags) != 0 && central_node != nil && central_node.IsEmpty();
    central_node_hole_register_hit_test_hole := central_node_hole;
    if (central_node_hole) {
        if payload := GetDragDropPayload(); payload != nil {
            if (payload.IsDataType(IMGUI_PAYLOAD_TYPE_WINDOW) && DockNodeIsDropAllowed(host_window, (cast(^^ImGuiWindow)payload.Data)^)) {
                central_node_hole_register_hit_test_hole = false;
            }
        }
    }

    if (central_node_hole_register_hit_test_hole)
    {
        // We add a little padding to match the "resize from edges" behavior and allow grabbing the splitter easily.
        // (But we only add it if there's something else on the other side of the hole, otherwise for e.g. fullscreen
        // covering passthru node we'd have a gap on the edge not covered by the hole)
        assert(node.IsDockSpace()); // We cannot pass this flag without the DockSpace() api. Testing this because we also setup the hole in host_window.ParentNode
        root_node := DockNodeGetRootNode(central_node);
        root_rect := ImRect{ _v = {root_node.Pos, root_node.Pos + root_node.Size}};
        hole_rect := ImRect{ _v = {central_node.Pos, central_node.Pos + central_node.Size}};
        if (hole_rect.Min.x > root_rect.Min.x) { hole_rect.Min.x += WINDOWS_HOVER_PADDING; }
        if (hole_rect.Max.x < root_rect.Max.x) { hole_rect.Max.x -= WINDOWS_HOVER_PADDING; }
        if (hole_rect.Min.y > root_rect.Min.y) { hole_rect.Min.y += WINDOWS_HOVER_PADDING; }
        if (hole_rect.Max.y < root_rect.Max.y) { hole_rect.Max.y -= WINDOWS_HOVER_PADDING; }
        //AddRect(GetForegroundDrawList(), hole_rect.Min, hole_rect.Max, IM_COL32(255, 0, 0, 255));
        if (central_node_hole && !hole_rect.IsInverted())
        {
            SetWindowHitTestHole(host_window, hole_rect.Min, hole_rect.Max - hole_rect.Min);
            if (host_window.ParentWindow) {
                SetWindowHitTestHole(host_window.ParentWindow, hole_rect.Min, hole_rect.Max - hole_rect.Min);
            }

        }
    }

    // Update position/size, process and draw resizing splitters
    if (node.IsRootNode() && host_window)
    {
        DockNodeTreeUpdatePosSize(node, host_window.Pos, host_window.Size);
        PushStyleColor(ImGuiCol.Separator, g.Style.Colors[ImGuiCol.Border]);
        PushStyleColor(ImGuiCol.SeparatorActive, g.Style.Colors[ImGuiCol.ResizeGripActive]);
        PushStyleColor(ImGuiCol.SeparatorHovered, g.Style.Colors[ImGuiCol.ResizeGripHovered]);
        DockNodeTreeUpdateSplitter(node);
        PopStyleColor(3);
    }

    // Draw empty node background (currently can only be the Central Node)
    if (host_window && node.IsEmpty() && node.IsVisible)
    {
        host_window.DrawList.ChannelsSetCurrent(DOCKING_HOST_DRAW_CHANNEL_BG);
        node.LastBgColor = (.PassthruCentralNode in node_flags) ? 0 : GetColorU32(ImGuiCol.DockingEmptyBg);
        if (node.LastBgColor != 0) {
            host_window.DrawList.AddRectFilled(node.Pos, node.Pos + node.Size, node.LastBgColor);
        }

        node.IsBgDrawnThisFrame = true;
    }

    // Draw whole dockspace background if ImGuiDockNodeFlags_PassthruCentralNode if set.
    // We need to draw a background at the root level if requested by ImGuiDockNodeFlags_PassthruCentralNode, but we will only know the correct pos/size
    // _after_ processing the resizing splitters. So we are using the DrawList channel splitting facility to submit drawing primitives out of order!
    render_dockspace_bg := node.IsRootNode() && host_window && (.PassthruCentralNode in node_flags) != 0;
    if (render_dockspace_bg && node.IsVisible)
    {
        host_window.DrawList.ChannelsSetCurrent(DOCKING_HOST_DRAW_CHANNEL_BG);
        if (central_node_hole) {
            RenderRectFilledWithHole(host_window.DrawList, node.Rect(), central_node.Rect(), GetColorU32(ImGuiCol.WindowBg), 0.0);
        }
        else {
            host_window.DrawList.AddRectFilled(node.Pos, node.Pos + node.Size, GetColorU32(ImGuiCol.WindowBg), 0.0);
        }
    }

    // Draw and populate Tab Bar
    if (host_window) {
        host_window.DrawList.ChannelsSetCurrent(DOCKING_HOST_DRAW_CHANNEL_FG);
    }

    if (host_window && len(node.Windows) > 0)
    {
        DockNodeUpdateTabBar(node, host_window);
    }
    else
    {
        node.WantCloseAll = false;
        node.WantCloseTabId = 0;
        node.IsFocused = false;
    }
    if (node.TabBar && node.TabBar.SelectedTabId) {
        node.SelectedTabId = node.TabBar.SelectedTabId;
    }
    else if (len(node.Windows) > 0) {
        node.SelectedTabId = node.Windows[0]->TabId;
    }

    // Draw payload drop target
    if (host_window && node.IsVisible) {
        if (node.IsRootNode() && (g.MovingWindow == nil || g.MovingWindow.RootWindowDockTree != host_window)) {
            BeginDockableDragDropTarget(host_window);
        }
    }

    // We update this after DockNodeUpdateTabBar()
    node.LastFrameActive = g.FrameCount;

    // Recurse into children
    // FIXME-DOCK FIXME-OPT: Should not need to recurse into children
    if (host_window)
    {
        if (node.ChildNodes[0]) {
            DockNodeUpdate(node.ChildNodes[0]);
        }

        if (node.ChildNodes[1]) {
            DockNodeUpdate(node.ChildNodes[1]);
        }

        // Render outer borders last (after the tab bar)
        if (node.IsRootNode()) {
            RenderWindowOuterBorders(host_window);
        }

    }

    // End host window
    if (beginned_into_host_window) {//-V1020
        End();
    }

}

// Compare TabItem nodes given the last known DockOrder (will persist in .ini file as hint), used to sort tabs when multiple tabs are added on the same frame.
TabItemComparerByDockOrder :: proc(lhs, rhs : rawptr) -> i32
{
    a := (cast(^ImGuiTabItem)lhs).Window;
    b := (cast(^ImGuiTabItem)rhs).Window;
    if d := ((a.DockOrder == -1) ? INT_MAX : a.DockOrder) - ((b.DockOrder == -1) ? INT_MAX : b.DockOrder); d != 0   do return d
    return (a.BeginOrderWithinContext - b.BeginOrderWithinContext);
}

// Default handler for g.DockNodeWindowMenuHandler(): display the list of windows for a given dock-node.
// This is exceptionally stored in a function pointer to also user applications to tweak this menu (undocumented)
// Custom overrides may want to decorate, group, sort entries.
// Please note those are internal structures: if you copy this expect occasional breakage.
// (if you don't need to modify the "len(Tabs) == 1" behavior/path it is recommend you call this function in your handler)
DockNodeWindowMenuHandler_Default :: proc(ctx : ^ImGuiContext, node : ^ImGuiDockNode, tab_bar : ^ImGuiTabBar)
{
    _ = ctx;
    if (len(tab_bar.Tabs) == 1)
    {
        // "Hide tab bar" option. Being one of our rare user-facing string we pull it from a table.
        if (MenuItem(LocalizeGetMsg(ImGuiLocKey_DockingHideTabBar), nil, node.IsHiddenTabBar())) {
            node.WantHiddenTabBarToggle = true;
        }

    }
    else
    {
        // Display a selectable list of windows in this docking node
        for tab_n := 0; tab_n < len(tab_bar.Tabs); tab_n += 1
        {
            tab := &tab_bar.Tabs[tab_n];
            if (.Button in tab.Flags)   do continue
            if (Selectable(TabBarGetTabName(tab_bar, tab), tab.ID == tab_bar.SelectedTabId)) {
                TabBarQueueFocus(tab_bar, tab);
            }

            SameLine();
            Text("   ");
        }
    }
}

DockNodeWindowMenuUpdate :: proc(node : ^ImGuiDockNode, tab_bar : ^ImGuiTabBar)
{
    // Try to position the menu so it is more likely to stays within the same viewport
    g := GImGui;
    if (g.Style.WindowMenuButtonPosition == .Left) {
        SetNextWindowPos(ImVec2{node.Pos.x, node.Pos.y + GetFrameHeight()}, ImGuiCond_Always, ImVec2{0.0, 0.0});
    }
    else {
        SetNextWindowPos(ImVec2{node.Pos.x + node.Size.x, node.Pos.y + GetFrameHeight()}, ImGuiCond_Always, ImVec2{1.0, 0.0});
    }
    if (BeginPopup("#WindowMenu"))
    {
        node.IsFocused = true;
        g.DockNodeWindowMenuHandler(g, node, tab_bar);
        EndPopup();
    }
}

// User helper to append/amend into a dock node tab bar. Most commonly used to add e.g. a "+" button.
DockNodeBeginAmendTabBar :: proc(node : ^ImGuiDockNode) -> bool
{
    if (node.TabBar == nil || node.HostWindow == nil)   do return false
    if (.KeepAliveOnly in node.MergedFlags)   do return false
    if (node.TabBar.ID == 0)   do return false
    Begin(node.HostWindow.Name);
    PushOverrideID(node.ID);
    ret := BeginTabBarEx(node.TabBar, node.TabBar.BarRect, node.TabBar.Flags);
    _ = ret;
    assert(ret);
    return true;
}

DockNodeEndAmendTabBar :: proc()
{
    EndTabBar();
    PopID();
    End();
}

IsDockNodeTitleBarHighlighted :: proc(node : ^ImGuiDockNode, root_node : ^ImGuiDockNode) -> bool
{
    // CTRL+Tab highlight (only highlighting leaf node, not whole hierarchy)
    g := GImGui;
    if (g.NavWindowingTarget) {
        return (g.NavWindowingTarget.DockNode == node);
    }

    // FIXME-DOCKING: May want alternative to treat central node void differently? e.g. if (g.NavWindow == host_window)
    if (g.NavWindow && root_node.LastFocusedNodeId == node.ID)
    {
        // FIXME: This could all be backed in RootWindowForTitleBarHighlight? Probably need to reorganize for both dock nodes + other RootWindowForTitleBarHighlight users (not-node)
        parent_window := g.NavWindow.RootWindow;
        for (.ChildMenu in parent_window.Flags) {
            parent_window = parent_window.ParentWindow.RootWindow;
        }
        start_parent_node := parent_window.DockNodeAsHost ? parent_window.DockNodeAsHost : parent_window.DockNode;
        for parent_node := start_parent_node; parent_node != nil; parent_node = parent_node.HostWindow ? parent_node.HostWindow.RootWindow.DockNode : nil {
            parent_node = DockNodeGetRootNode(parent_node)
            if (parent_node == root_node)   do return true
        }
    }
    return false;
}

// Submit the tab bar corresponding to a dock node and various housekeeping details.
DockNodeUpdateTabBar :: proc(node : ^ImGuiDockNode, host_window : ^ImGuiWindow)
{
    g := GImGui;
    style := &g.Style;

    node_was_active := (node.LastFrameActive + 1 == g.FrameCount);
    closed_all := node.WantCloseAll && node_was_active;
    closed_one := node.WantCloseTabId && node_was_active;
    node.WantCloseAll = false;
    node.WantCloseTabId = 0;

    // Decide if we should use a focused title bar color
    is_focused := false;
    root_node := DockNodeGetRootNode(node);
    if (IsDockNodeTitleBarHighlighted(node, root_node))   do is_focused = true

    // Hidden tab bar will show a triangle on the upper-left (in Begin)
    if (node.IsHiddenTabBar() || node.IsNoTabBar())
    {
        node.VisibleWindow = (len(node.Windows) > 0) ? node.Windows[0] : nil;
        node.IsFocused = is_focused;
        if (is_focused) {
            node.LastFrameFocused = g.FrameCount;
        }

        if (node.VisibleWindow)
        {
            // Notify root of visible window (used to display title in OS task bar)
            if (is_focused || root_node.VisibleWindow == nil) {
                root_node.VisibleWindow = node.VisibleWindow;
            }

            if (node.TabBar) {
                node.TabBar.VisibleTabId = node.VisibleWindow.TabId;
            }

        }
        return;
    }

    // Move ourselves to the Menu layer (so we can be accessed by tapping Alt) + undo SkipItems flag in order to draw over the title bar even if the window is collapsed
    backup_skip_item := host_window.SkipItems;
    if (!node.IsDockSpace())
    {
        host_window.SkipItems = false;
        host_window.DC.NavLayerCurrent = ImGuiNavLayer_Menu;
    }

    // Use PushOverrideID() instead of PushID() to use the node id _without_ the host window ID.
    // This is to facilitate computing those ID from the outside, and will affect more or less only the ID of the collapse button, popup and tabs,
    // as docked windows themselves will override the stack with their own root ID.
    PushOverrideID(node.ID);
    tab_bar := node.TabBar;
    tab_bar_is_recreated := (tab_bar == nil); // Tab bar are automatically destroyed when a node gets hidden
    if (tab_bar == nil)
    {
        DockNodeAddTabBar(node);
        tab_bar = node.TabBar;
    }

    focus_tab_id := 0;
    node.IsFocused = is_focused;

    node_flags := node.MergedFlags;
    has_window_menu_button := (.NoWindowMenuButton not_in node_flags) && (style.WindowMenuButtonPosition != nil);

    // In a dock node, the Collapse Button turns into the Window Menu button.
    // FIXME-DOCK FIXME-OPT: Could we recycle popups id across multiple dock nodes?
    if (has_window_menu_button && IsPopupOpen("#WindowMenu"))
    {
        next_selected_tab_id := tab_bar.NextSelectedTabId;
        DockNodeWindowMenuUpdate(node, tab_bar);
        if (tab_bar.NextSelectedTabId != 0 && tab_bar.NextSelectedTabId != next_selected_tab_id) {
            focus_tab_id = tab_bar.NextSelectedTabId;
        }

        is_focused |= node.IsFocused;
    }

    // Layout
    title_bar_rect, tab_bar_rect : ImRect
    window_menu_button_pos : ImVec2
    close_button_pos : ImVec2
    DockNodeCalcTabBarLayout(node, &title_bar_rect, &tab_bar_rect, &window_menu_button_pos, &close_button_pos);

    // Submit new tabs, they will be added as Unsorted and sorted below based on relative DockOrder value.
    tabs_count_old := len(tab_bar.Tabs);
    for window_n := 0; window_n < len(node.Windows); window_n += 1
    {
        window := node.Windows[window_n];
        if (TabBarFindTabByID(tab_bar, window.TabId) == nil) {
            TabBarAddTab(tab_bar, ImGuiTabItemFlags_Unsorted, window);
        }

    }

    // Title bar
    if (is_focused) {
        node.LastFrameFocused = g.FrameCount;
    }

    title_bar_col := GetColorU32(host_window.Collapsed ? ImGuiCol.TitleBgCollapsed : is_focused ? ImGuiCol.TitleBgActive : ImGuiCol.TitleBg);
    rounding_flags := CalcRoundingFlagsForRectInRect(title_bar_rect, host_Rect(window), g.Style.DockingSeparatorSize);
    host_window.DrawList.AddRectFilled(title_bar_rect.Min, title_bar_rect.Max, title_bar_col, host_window.WindowRounding, rounding_flags);

    // Docking/Collapse button
    if (has_window_menu_button)
    {
        if (CollapseButton(host_window.GetID("#COLLAPSE"), window_menu_button_pos, node)) do OpenPopup("#WindowMenu") // == DockNodeGetWindowMenuButtonId(node)
        if (IsItemActive()) {
            focus_tab_id = tab_bar.SelectedTabId;
        }

        if (IsItemHovered(ImGuiHoveredFlags_ForTooltip | ImGuiHoveredFlags_DelayNormal) && g.HoveredIdTimer > 0.5) {
            SetTooltip("%s", LocalizeGetMsg(ImGuiLocKey_DockingDragToUndockOrMoveNode));
        }

    }

    // If multiple tabs are appearing on the same frame, sort them based on their persistent DockOrder value
    tabs_unsorted_start := len(tab_bar.Tabs);
    for tab_n := len(tab_bar.Tabs) - 1; tab_n >= 0 && (tab_bar.Tabs[tab_n].Flags & ImGuiTabItemFlags_Unsorted); tab_n -= 1
    {
        // FIXME-DOCK: Consider only clearing the flag after the tab has been alive for a few consecutive frames, allowing late comers to not break sorting?
        tab_bar.Tabs[tab_n].Flags &= ~ImGuiTabItemFlags_Unsorted;
        tabs_unsorted_start = tab_n;
    }
    if (len(tab_bar.Tabs) > tabs_unsorted_start)
    {
        IMGUI_DEBUG_LOG_DOCKING(g, "[docking] In node 0x%08X: %d new appearing tabs:%s\n", node.ID, len(tab_bar.Tabs) - tabs_unsorted_start, (len(tab_bar.Tabs) > tabs_unsorted_start + 1) ? " (will sort)" : "");
        for tab_n := tabs_unsorted_start; tab_n < len(tab_bar.Tabs); tab_n += 1
        {
            tab := &tab_bar.Tabs[tab_n];
            _ = tab;
            IMGUI_DEBUG_LOG_DOCKING(g, "[docking] - Tab 0x%08X '%s' Order %d\n", tab.ID, TabBarGetTabName(tab_bar, tab), tab.Window ? tab.Window.DockOrder : -1);
        }
        IMGUI_DEBUG_LOG_DOCKING(g, "[docking] SelectedTabId = 0x%08X, NavWindow.TabId = 0x%08X\n", node.SelectedTabId, g.NavWindow ? g.NavWindow.TabId : -1);
        if (len(tab_bar.Tabs) > tabs_unsorted_start + 1) {
            ImQsort(tab_bar.Tabs.Data + tabs_unsorted_start, len(tab_bar.Tabs) - tabs_unsorted_start, size_of(ImGuiTabItem), TabItemComparerByDockOrder);
        }
    }

    // Apply NavWindow focus back to the tab bar
    if (g.NavWindow && g.NavWindow.RootWindow.DockNode == node) {
        tab_bar.SelectedTabId = g.NavWindow.RootWindow.TabId;
    }

    // Selected newly added tabs, or persistent tab ID if the tab bar was just recreated
    if (tab_bar_is_recreated && TabBarFindTabByID(tab_bar, node.SelectedTabId) != nil) {
        tab_bar.NextSelectedTabId = node.SelectedTabId;
        tab_bar.SelectedTabId = tab_bar.NextSelectedTabId
    }
    else if (len(tab_bar.Tabs) > tabs_count_old) {
        tab_bar.NextSelectedTabId = tab_bar.Tabs.back().Window.TabId;
        tab_bar.SelectedTabId = tab_bar.NextSelectedTabId
    }

    // Begin tab bar
    tab_bar_flags := ImGuiTabBarFlags_Reorderable | ImGuiTabBarFlags_AutoSelectNewTabs; // | ImGuiTabBarFlags_NoTabListScrollingButtons);
    tab_bar_flags |= ImGuiTabBarFlags_SaveSettings | ImGuiTabBarFlags_DockNode;// | ImGuiTabBarFlags_FittingPolicyScroll;
    tab_bar_flags |= ImGuiTabBarFlags_DrawSelectedOverline;
    if (!host_window.Collapsed && is_focused) {
        tab_bar_flags |= ImGuiTabBarFlags_IsFocused;
    }

    tab_bar.ID = GetID("#TabBar");
    tab_bar.SeparatorMinX = node.Pos.x + host_window.WindowBorderSize; // Separator cover the whole node width
    tab_bar.SeparatorMaxX = node.Pos.x + node.Size.x - host_window.WindowBorderSize;
    BeginTabBarEx(tab_bar, tab_bar_rect, tab_bar_flags);
    //host_window.DrawList.AddRect(tab_bar_rect.Min, tab_bar_rect.Max, IM_COL32(255,0,255,255));

    // Backup style colors
    backup_style_cols : [ImGuiWindowDockStyleCol_COUNT]ImVec4;
    for color_n := 0; color_n < ImGuiWindowDockStyleCol_COUNT; color_n += 1 {
        backup_style_cols[color_n] = g.Style.Colors[GWindowDockStyleColors[color_n]];
    }

    // Submit actual tabs
    node.VisibleWindow = nil;
    for window_n := 0; window_n < len(node.Windows); window_n += 1
    {
        window := node.Windows[window_n];
        if ((closed_all || closed_one == window.TabId) && window.HasCloseButton && !(.UnsavedDocument in window.Flags))   do continue
        if (window.LastFrameActive + 1 >= g.FrameCount || !node_was_active)
        {
            tab_item_flags := 0;
            tab_item_flags |= window.WindowClass.TabItemFlagsOverrideSet;
            if (.UnsavedDocument in window.Flags) {
                tab_item_flags |= ImGuiTabItemFlags_UnsavedDocument;
            }

            if (.NoCloseWithMiddleMouseButton in tab_bar.Flags) {
                tab_item_flags |= ImGuiTabItemFlags_NoCloseWithMiddleMouseButton;
            }

            // Apply stored style overrides for the window
            for color_n := 0; color_n < ImGuiWindowDockStyleCol_COUNT; color_n += 1 {
                g.Style.Colors[GWindowDockStyleColors[color_n]] = ColorConvertU32ToFloat4(window.DockStyle.Colors[color_n]);
            }

            // Note that TabItemEx() calls TabBarCalcTabID() so our tab item ID will ignore the current ID stack (rightly so)
            tab_open := true;
            TabItemEx(tab_bar, window.Name, window.HasCloseButton ? &tab_open : nil, tab_item_flags, window);
            if (!tab_open) {
                node.WantCloseTabId = window.TabId;
            }

            if (tab_bar.VisibleTabId == window.TabId) {
                node.VisibleWindow = window;
            }

            // Store last item data so it can be queried with IsItemXXX functions after the user Begin() call
            window.DockTabItemStatusFlags = g.LastItemData.StatusFlags;
            window.DockTabItemRect = g.LastItemData.Rect;

            // Update navigation ID on menu layer
            if (g.NavWindow && g.NavWindow.RootWindow == window && (window.DC.NavLayersActiveMask & (1 << ImGuiNavLayer_Menu)) == 0) {
                host_window.NavLastIds[1] = window.TabId;
            }

        }
    }

    // Restore style colors
    for color_n := 0; color_n < ImGuiWindowDockStyleCol_COUNT; color_n += 1 {
        g.Style.Colors[GWindowDockStyleColors[color_n]] = backup_style_cols[color_n];
    }

    // Notify root of visible window (used to display title in OS task bar)
    if (node.VisibleWindow) {
        if (is_focused || root_node.VisibleWindow == nil) {
            root_node.VisibleWindow = node.VisibleWindow;
        }
    }

    // Close button (after VisibleWindow was updated)
    // Note that VisibleWindow may have been overrided by CTRL+Tabbing, so VisibleWindow.TabId may be != from tab_bar.SelectedTabId
    close_button_is_enabled := node.HasCloseButton && node.VisibleWindow && node.VisibleWindow.HasCloseButton;
    close_button_is_visible := node.HasCloseButton;
    //const bool close_button_is_visible = close_button_is_enabled; // Most people would expect this behavior of not even showing the button (leaving a hole since we can't claim that space as other windows in the tba bar have one)
    if (close_button_is_visible)
    {
        if (!close_button_is_enabled)
        {
            PushItemFlag(ImGuiItemFlags_Disabled, true);
            PushStyleColor(ImGuiCol.Text, style.Colors[ImGuiCol.Text] * ImVec4{1.0,1.0,1.0,0.4});
        }
        if (CloseButton(host_window.GetID("#CLOSE"), close_button_pos))
        {
            node.WantCloseAll = true;
            for n := 0; n < len(tab_bar.Tabs); n += 1 {
                TabBarCloseTab(tab_bar, &tab_bar.Tabs[n]);
            }
        }
        //if (IsItemActive())
        //    focus_tab_id = tab_bar.SelectedTabId;
        if (!close_button_is_enabled)
        {
            PopStyleColor();
            PopItemFlag();
        }
    }

    // When clicking on the title bar outside of tabs, we still focus the selected tab for that node
    // FIXME: TabItems submitted earlier use AllowItemOverlap so we manually perform a more specific test for now (hovered || held) in order to not cover them.
    title_bar_id := host_window.GetID("#TITLEBAR");
    if (g.HoveredId == 0 || g.HoveredId == title_bar_id || g.ActiveId == title_bar_id)
    {
        // AllowOverlap mode required for appending into dock node tab bar,
        // otherwise dragging window will steal HoveredId and amended tabs cannot get them.
        held : bool
        KeepAliveID(title_bar_id);
        ButtonBehavior(title_bar_rect, title_bar_id, nil, &held, ImGuiButtonFlags_AllowOverlap);
        if (g.HoveredId == title_bar_id)
        {
            g.LastItemData.ID = title_bar_id;
        }
        if (held)
        {
            if (IsMouseClicked(0)) {
                focus_tab_id = tab_bar.SelectedTabId;
            }

            // Forward moving request to selected window
            if tab := TabBarFindTabByID(tab_bar, tab_bar.SelectedTabId); tab != nil {
                StartMouseMovingWindowOrNode(tab.Window ? tab.Window : node.HostWindow, node, false); // Undock from tab bar empty space
            }

        }
    }

    // Forward focus from host node to selected window
    //if (is_focused && g.NavWindow == host_window && !g.NavWindowingTarget)
    //    focus_tab_id = tab_bar.SelectedTabId;

    // When clicked on a tab we requested focus to the docked child
    // This overrides the value set by "forward focus from host node to selected window".
    if (tab_bar.NextSelectedTabId) {
        focus_tab_id = tab_bar.NextSelectedTabId;
    }

    // Apply navigation focus
    if (focus_tab_id != 0) {
        if tab := TabBarFindTabByID(tab_bar, focus_tab_id); tab != nil {
            if (tab.Window)
            {
                FocusWindow(tab.Window);
                NavInitWindow(tab.Window, false);
            }
        }
    }

    EndTabBar();
    PopID();

    // Restore SkipItems flag
    if (!node.IsDockSpace())
    {
        host_window.DC.NavLayerCurrent = ImGuiNavLayer_Main;
        host_window.SkipItems = backup_skip_item;
    }
}

DockNodeAddTabBar :: proc(node : ^ImGuiDockNode)
{
    assert(node.TabBar == nil);
    node.TabBar = IM_NEW(ImGuiTabBar);
}

DockNodeRemoveTabBar :: proc(node : ^ImGuiDockNode)
{
    if (node.TabBar == nil)   do return
    IM_DELETE(node.TabBar);
    node.TabBar = nil;
}

DockNodeIsDropAllowedOne :: proc(payload : ^ImGuiWindow, host_window : ^ImGuiWindow) -> bool
{
    if (host_window.DockNodeAsHost && host_window.DockNodeAsHost.IsDockSpace() && payload.BeginOrderWithinContext < host_window.BeginOrderWithinContext)   do return false

    host_class := host_window.DockNodeAsHost ? &host_window.DockNodeAsHost.WindowClass : &host_window.WindowClass;
    payload_class := &payload.WindowClass;
    if (host_class.ClassId != payload_class.ClassId)
    {
        pass := false;
        if (host_class.ClassId != 0 && host_class.DockingAllowUnclassed && payload_class.ClassId == 0)   do pass = true
        if (payload_class.ClassId != 0 && payload_class.DockingAllowUnclassed && host_class.ClassId == 0)   do pass = true
        if (!pass)   do return false
    }

    // Prevent docking any window created above a popup
    // Technically we should support it (e.g. in the case of a long-lived modal window that had fancy docking features),
    // by e.g. adding a 'if (!ImGui::IsWindowWithinBeginStackOf(host_window, popup_window))' test.
    // But it would requires more work on our end because the dock host windows is technically created in NewFrame()
    // and our ->ParentXXX and ->RootXXX pointers inside windows are currently mislading or lacking.
    g := GImGui;
    for i := len(g.OpenPopupStack) - 1; i >= 0; i -= 1 {
        if popup_window := g.OpenPopupStack[i].Window; popup_window != nil {
            if (IsWindowWithinBeginStackOf(payload, popup_window)) {// Payload is created from within a popup begin stack.
                return false;
            }
        }
    }

    return true;
}

DockNodeIsDropAllowed :: proc(host_window : ^ImGuiWindow, root_payload : ^ImGuiWindow) -> bool
{
    if (root_payload.DockNodeAsHost && root_payload.DockNodeAsHost.IsSplitNode()) {// FIXME-DOCK: Missing filtering
        return true;
    }

    payload_count := root_payload.DockNodeAsHost ? len(root_payload.DockNodeAsHost.Windows) : 1;
    for payload_n := 0; payload_n < payload_count; payload_n += 1
    {
        payload := root_payload.DockNodeAsHost ? root_payload.DockNodeAsHost.Windows[payload_n] : root_payload;
        if (DockNodeIsDropAllowedOne(payload, host_window))   do return true
    }
    return false;
}

// window menu button == collapse button when not in a dock node.
// FIXME: This is similar to RenderWindowTitleBarContents(), may want to share code.
DockNodeCalcTabBarLayout :: proc(node : ^ImGuiDockNode, out_title_rect : ^ImRect, out_tab_bar_rect : ^ImRect, out_window_menu_button_pos : ^ImVec2, out_close_button_pos : ^ImVec2)
{
    g := GImGui;
    style := &g.Style;

    r := ImRect{ _r = {node.Pos.x, node.Pos.y, node.Pos.x + node.Size.x, node.Pos.y + g.FontSize + g.Style.FramePadding.y * 2.0}};
    if (out_title_rect) { out_title_rect^ = r; }

    r.Min.x += style.WindowBorderSize;
    r.Max.x -= style.WindowBorderSize;

    button_sz := g.FontSize;
    r.Min.x += style.FramePadding.x;
    r.Max.x -= style.FramePadding.x;
    window_menu_button_pos := ImVec2{r.Min.x, r.Min.y + style.FramePadding.y};
    if (node.HasCloseButton)
    {
        if (out_close_button_pos != nil) do  out_close_button_pos^ = ImVec2{r.Max.x - button_sz, r.Min.y + style.FramePadding.y};
        r.Max.x -= button_sz + style.ItemInnerSpacing.x;
    }
    if (node.HasWindowMenuButton && style.WindowMenuButtonPosition == .Left)
    {
        r.Min.x += button_sz + style.ItemInnerSpacing.x;
    }
    else if (node.HasWindowMenuButton && style.WindowMenuButtonPosition == .Right)
    {
        window_menu_button_pos = ImVec2{r.Max.x - button_sz, r.Min.y + style.FramePadding.y};
        r.Max.x -= button_sz + style.ItemInnerSpacing.x;
    }
    if (out_tab_bar_rect) { out_tab_bar_rect^ = r; }
    if (out_window_menu_button_pos) { out_window_menu_button_pos^ = window_menu_button_pos; }
}

DockNodeCalcSplitRects :: proc(pos_old : ImVec2, size_old : ImVec2, pos_new : ImVec2, size_new : ImVec2, dir : ImGuiDir, size_new_desired : ImVec2)
{
    g := GImGui;
    dock_spacing := g.Style.ItemInnerSpacing.x;
    axis := (dir == .Left || dir == .Right) ? ImGuiAxis.X : ImGuiAxis.Y;
    pos_new[axis ~ 1] = pos_old[axis ~ 1];
    size_new[axis ~ 1] = size_old[axis ~ 1];

    // Distribute size on given axis (with a desired size or equally)
    w_avail := size_old[axis] - dock_spacing;
    if (size_new_desired[axis] > 0.0 && size_new_desired[axis] <= w_avail * 0.5)
    {
        size_new[axis] = size_new_desired[axis];
        size_old[axis] = math.trunc(w_avail - size_new[axis]);
    }
    else
    {
        size_new[axis] = math.trunc(w_avail * 0.5);
        size_old[axis] = math.trunc(w_avail - size_new[axis]);
    }

    // Position each node
    if (dir == .Right || dir == ImGuiDir.Down)
    {
        pos_new[axis] = pos_old[axis] + size_old[axis] + dock_spacing;
    }
    else if (dir == .Left || dir == ImGuiDir.Up)
    {
        pos_new[axis] = pos_old[axis];
        pos_old[axis] = pos_new[axis] + size_new[axis] + dock_spacing;
    }
}

// Retrieve the drop rectangles for a given direction or for the center + perform hit testing.
DockNodeCalcDropRectsAndTestMousePos :: proc(parent : ^ImRect, dir : ImGuiDir, out_r : ^ImRect, outer_docking : bool, test_mouse_pos : ^ImVec2) -> bool
{
    g := GImGui;

    parent_smaller_axis := ImMin(parent.GetWidth(), parent.GetHeight());
    hs_for_central_nodes := ImMin(g.FontSize * 1.5, ImMax(g.FontSize * 0.5, parent_smaller_axis / 8.0));
    hs_w : f32 // Half-size, longer axis
    hs_h : f32 // Half-size, smaller axis
    off : ImVec2 // Distance from edge or center
    if (outer_docking)
    {
        //hs_w = ImTrunc(ImClamp(parent_smaller_axis - hs_for_central_nodes * 4.0f, g.FontSize * 0.5f, g.FontSize * 8.0f));
        //hs_h = ImTrunc(hs_w * 0.15f);
        //off = ImVec2(ImTrunc(parent.GetWidth() * 0.5f - GetFrameHeightWithSpacing() * 1.4f - hs_h), ImTrunc(parent.GetHeight() * 0.5f - GetFrameHeightWithSpacing() * 1.4f - hs_h));
        hs_w = ImTrunc(hs_for_central_nodes * 1.50);
        hs_h = ImTrunc(hs_for_central_nodes * 0.80);
        off = ImTrunc(ImVec2{parent.GetWidth() * 0.5 - hs_h, parent.GetHeight() * 0.5 - hs_h});
    }
    else
    {
        hs_w = ImTrunc(hs_for_central_nodes);
        hs_h = ImTrunc(hs_for_central_nodes * 0.90);
        off = ImTrunc(ImVec2{hs_w * 2.40, hs_w * 2.40});
    }

    c := ImTrunc(parent.GetCenter());
    if      (dir == nil)  { out_r = ImRect{ _r = {c.x - hs_w, c.y - hs_w,         c.x + hs_w, c.y + hs_w}};         }
    else if (dir == ImGuiDir.Up)    { out_r = ImRect{ _r = {c.x - hs_w, c.y - off.y - hs_h, c.x + hs_w, c.y - off.y + hs_h}}; }
    else if (dir == ImGuiDir.Down)  { out_r = ImRect{ _r = {c.x - hs_w, c.y + off.y - hs_h, c.x + hs_w, c.y + off.y + hs_h}}; }
    else if (dir == .Left)  { out_r = ImRect{ _r = {c.x - off.x - hs_h, c.y - hs_w, c.x - off.x + hs_h, c.y + hs_w}}; }
    else if (dir == .Right) { out_r = ImRect{ _r = {c.x + off.x - hs_h, c.y - hs_w, c.x + off.x + hs_h, c.y + hs_w}}; }

    if (test_mouse_pos == nil)   do return false

    hit_r := out_r;
    if (!outer_docking)
    {
        // Custom hit testing for the 5-way selection, designed to reduce flickering when moving diagonally between sides
        hit_r.Expand(ImTrunc(hs_w * 0.30));
        mouse_delta := (test_mouse_pos^ - c);
        mouse_delta_len2 := ImLengthSqr(mouse_delta);
        r_threshold_center := hs_w * 1.4;
        r_threshold_sides := hs_w * (1.4 + 1.2);
        if (mouse_delta_len2 < r_threshold_center * r_threshold_center)   do return (dir == nil)
        if (mouse_delta_len2 < r_threshold_sides * r_threshold_sides) {
            return (dir == ImGetDirQuadrantFromDelta(mouse_delta.x, mouse_delta.y));
        }

    }
    return hit_r.Contains(test_mouse_pos^);
}

// host_node may be NULL if the window doesn't have a DockNode already.
// FIXME-DOCK: This is misnamed since it's also doing the filtering.
DockNodePreviewDockSetup :: proc(host_window : ^ImGuiWindow, host_node : ^ImGuiDockNode, payload_window : ^ImGuiWindow, payload_node : ^ImGuiDockNode, data : ^ImGuiDockPreviewData, is_explicit_target : bool, is_outer_docking : bool)
{
    g := GImGui;

    // There is an edge case when docking into a dockspace which only has inactive nodes.
    // In this case DockNodeTreeFindNodeByPos() will have selected a leaf node which is inactive.
    // Because the inactive leaf node doesn't have proper pos/size yet, we'll use the root node as reference.
    if (payload_node == nil) {
        payload_node = payload_window.DockNodeAsHost;
    }

    ref_node_for_rect := (host_node && !host_node.IsVisible) ? DockNodeGetRootNode(host_node) : host_node;
    if (ref_node_for_rect) {
        assert(ref_node_for_rect.IsVisible == true);
    }

    // Filter, figure out where we are allowed to dock
    src_node_flags := payload_node ? payload_node.MergedFlags : payload_window.WindowClass.DockNodeFlagsOverrideSet;
    dst_node_flags := host_node ? host_node.MergedFlags : host_window.WindowClass.DockNodeFlagsOverrideSet;
    data.IsCenterAvailable = true;
    if (is_outer_docking) {
        data.IsCenterAvailable = false;
    }
    else if (.NoDockingOverMe in dst_node_flags) {
        data.IsCenterAvailable = false;
    }
    else if (host_node && (.NoDockingOverCentralNode in dst_node_flags) && host_IsCentralNode(node)) {
        data.IsCenterAvailable = false;
    }
    else if ((!host_node || !host_node.IsEmpty()) && payload_node && payload_node.IsSplitNode() && (payload_node.OnlyNodeWithWindows == nil)) {     // Is _visibly_ split?
        data.IsCenterAvailable = false;
    }
    else if ((.NoDockingOverOther in src_node_flags) && (!host_node || !host_node.IsEmpty())) {
        data.IsCenterAvailable = false;
    }
    else if ((.NoDockingOverEmpty in src_node_flags) && host_node && host_node.IsEmpty()) {
        data.IsCenterAvailable = false;
    }

    data.IsSidesAvailable = true;
    if ((.NoDockingSplit in dst_node_flags) || g.IO.ConfigDockingNoSplit) {
        data.IsSidesAvailable = false;
    }
    else if (!is_outer_docking && host_node && host_node.ParentNode == nil && host_IsCentralNode(node))     {
        data.IsSidesAvailable = false;
    }
    else if (.NoDockingSplitOther in src_node_flags) {
        data.IsSidesAvailable = false;
    }

    // Build a tentative future node (reuse same structure because it is practical. Shape will be readjusted when previewing a split)
    data.FutureNode.HasCloseButton = (host_node ? host_node.HasCloseButton : host_window.HasCloseButton) || (payload_window.HasCloseButton);
    data.FutureNode.HasWindowMenuButton = host_node ? true : ((.NoCollapse not_in host_window.Flags));
    data.FutureNode.Pos = ref_node_for_rect ? ref_node_for_rect.Pos : host_window.Pos;
    len(data.FutureNode) = ref_node_for_rect ? len(ref_node_for_rect) : len(host_window);

    // Calculate drop shapes geometry for allowed splitting directions
    assert(nil == -1);
    data.SplitNode = host_node;
    data.SplitDir = nil;
    data.IsSplitDirExplicit = false;
    if (!host_window.Collapsed) {
        for dir := nil; dir < ImGuiDir.COUNT; dir += 1
        {
            if (dir == nil && !data.IsCenterAvailable)   do continue
            if (dir != nil && !data.IsSidesAvailable)   do continue
            if (DockNodeCalcDropRectsAndTestMousePos(data.FutureNode.Rect(), cast(ImGuiDir)dir, data.DropRectsDraw[dir+1], is_outer_docking, &g.IO.MousePos))
            {
                data.SplitDir = cast(ImGuiDir)dir;
                data.IsSplitDirExplicit = true;
            }
        }
    }

    // When docking without holding Shift, we only allow and preview docking when hovering over a drop rect or over the title bar
    data.IsDropAllowed = (data.SplitDir != nil) || (data.IsCenterAvailable);
    if (!is_explicit_target && !data.IsSplitDirExplicit && !g.IO.ConfigDockingWithShift) {
        data.IsDropAllowed = false;
    }

    // Calculate split area
    data.SplitRatio = 0.0;
    if (data.SplitDir != nil)
    {
        split_dir := data.SplitDir;
        split_axis := (split_dir == .Left || split_dir == .Right) ? ImGuiAxis.X : ImGuiAxis.Y;
        pos_new : ImVec2; pos_old := data.FutureNode.Pos;
        size_new : ImVec2; size_old := len(data.FutureNode);
        DockNodeCalcSplitRects(pos_old, size_old, pos_new, size_new, split_dir, payload_window.Size);

        // Calculate split ratio so we can pass it down the docking request
        split_ratio := ImSaturate(size_new[split_axis] / data.FutureNode.Size[split_axis]);
        data.FutureNode.Pos = pos_new;
        len(data.FutureNode) = size_new;
        data.SplitRatio = (split_dir == .Right || split_dir == ImGuiDir.Down) ? (1.0 - split_ratio) : (split_ratio);
    }
}

DockNodePreviewDockRender :: proc(host_window : ^ImGuiWindow, host_node : ^ImGuiDockNode, root_payload : ^ImGuiWindow, data : ^ImGuiDockPreviewData)
{
    g := GImGui;
    assert(g.CurrentWindow == host_window);   // Because we rely on font size to calculate tab sizes

    // With this option, we only display the preview on the target viewport, and the payload viewport is made transparent.
    // To compensate for the single layer obstructed by the payload, we'll increase the alpha of the preview nodes.
    is_transparent_payload := g.IO.ConfigDockingTransparentPayload;

    // In case the two windows involved are on different viewports, we will draw the overlay on each of them.
    overlay_draw_lists_count := 0;
    ImDrawList* overlay_draw_lists[2];
    overlay_draw_lists_count += 1
    overlay_draw_lists[overlay_draw_lists_count] = GetForegroundDrawList(host_window.Viewport);
    if (host_window.Viewport != root_payload.Viewport && !is_transparent_payload) {
        overlay_draw_lists_count += 1
        overlay_draw_lists[overlay_draw_lists_count] = GetForegroundDrawList(root_payload.Viewport);
    }

    // Draw main preview rectangle
    overlay_col_main := GetColorU32(ImGuiCol.DockingPreview, is_transparent_payload ? 0.60 : 0.40);
    overlay_col_drop := GetColorU32(ImGuiCol.DockingPreview, is_transparent_payload ? 0.90 : 0.70);
    overlay_col_drop_hovered := GetColorU32(ImGuiCol.DockingPreview, is_transparent_payload ? 1.20 : 1.00);
    overlay_col_lines := GetColorU32(ImGuiCol.NavWindowingHighlight, is_transparent_payload ? 0.80 : 0.60);

    // Display area preview
    can_preview_tabs := (root_payload.DockNodeAsHost == nil || len(root_payload.DockNodeAsHost.Windows) > 0);
    if (data.IsDropAllowed)
    {
        overlay_rect := data.FutureNode.Rect();
        if (data.SplitDir == nil && can_preview_tabs) {
            overlay_rect.Min.y += GetFrameHeight();
        }

        if (data.SplitDir != nil || data.IsCenterAvailable) {
            for overlay_n := 0; overlay_n < overlay_draw_lists_count; overlay_n += 1 {
                overlay_draw_lists[overlay_n]->AddRectFilled(overlay_rect.Min, overlay_rect.Max, overlay_col_main, host_window.WindowRounding, CalcRoundingFlagsForRectInRect(overlay_rect, host_Rect(window), g.Style.DockingSeparatorSize));
            }
        }
    }

    // Display tab shape/label preview unless we are splitting node (it generally makes the situation harder to read)
    if (data.IsDropAllowed && can_preview_tabs && data.SplitDir == nil && data.IsCenterAvailable)
    {
        // Compute target tab bar geometry so we can locate our preview tabs
        tab_bar_rect : ImRect
        DockNodeCalcTabBarLayout(&data.FutureNode, nil, &tab_bar_rect, nil, nil);
        tab_pos := tab_bar_rect.Min;
        if (host_node && host_node.TabBar)
        {
            if (!host_node.IsHiddenTabBar() && !host_node.IsNoTabBar()) {
                tab_pos.x += host_node.TabBar.WidthAllTabs + g.Style.ItemInnerSpacing.x; // We don't use OffsetNewTab because when using non-persistent-order tab bar it is incremented with each Tab submission.
            }
            else {
                tab_pos.x += g.Style.ItemInnerSpacing.x + TabItemCalcSize(host_node.Windows[0]).x;
            }
        }
        else if (!(.DockNodeHost in host_window.Flags))
        {
            tab_pos.x += g.Style.ItemInnerSpacing.x + TabItemCalcSize(host_window).x; // Account for slight offset which will be added when changing from title bar to tab bar
        }

        // Draw tab shape/label preview (payload may be a loose window or a host window carrying multiple tabbed windows)
        if (root_payload.DockNodeAsHost) {
            assert(len(root_payload.DockNodeAsHost.Windows) <= root_payload.DockNodeAsHost.TabBar.Tabs.Size);
        }

        tab_bar_with_payload := root_payload.DockNodeAsHost ? root_payload.DockNodeAsHost.TabBar : nil;
        payload_count := tab_bar_with_payload ? len(tab_bar_with_payload.Tabs) : 1;
        for payload_n := 0; payload_n < payload_count; payload_n += 1
        {
            // DockNode's TabBar may have non-window Tabs manually appended by user
            payload_window := tab_bar_with_payload ? tab_bar_with_payload.Tabs[payload_n].Window : root_payload;
            if (tab_bar_with_payload && payload_window == nil)   do continue
            if (!DockNodeIsDropAllowedOne(payload_window, host_window))   do continue

            // Calculate the tab bounding box for each payload window
            tab_size := TabItemCalcSize(payload_window);
            tab_bb := ImRect{ _r = {tab_pos.x, tab_pos.y, tab_pos.x + tab_size.x, tab_pos.y + tab_size.y}};
            tab_pos.x += tab_size.x + g.Style.ItemInnerSpacing.x;
            overlay_col_text := GetColorU32(payload_window.DockStyle.Colors[ImGuiWindowDockStyleCol_Text]);
            overlay_col_tabs := GetColorU32(payload_window.DockStyle.Colors[ImGuiWindowDockStyleCol_TabSelected]);
            PushStyleColor(ImGuiCol.Text, overlay_col_text);
            for overlay_n := 0; overlay_n < overlay_draw_lists_count; overlay_n += 1
            {
                tab_flags := (.UnsavedDocument in payload_window.Flags) ? ImGuiTabItemFlags_UnsavedDocument : 0;
                if (!tab_bar_rect.Contains(tab_bb)) {
                    overlay_draw_lists[overlay_n]->PushClipRect(tab_bar_rect.Min, tab_bar_rect.Max);
                }

                TabItemBackground(overlay_draw_lists[overlay_n], tab_bb, tab_flags, overlay_col_tabs);
                TabItemLabelAndCloseButton(overlay_draw_lists[overlay_n], tab_bb, tab_flags, g.Style.FramePadding, payload_window.Name, 0, 0, false, nil, nil);
                if (!tab_bar_rect.Contains(tab_bb)) {
                    overlay_draw_lists[overlay_n]->PopClipRect();
                }

            }
            PopStyleColor();
        }
    }

    // Display drop boxes
    overlay_rounding := ImMax(3.0, g.Style.FrameRounding);
    for dir := nil; dir < ImGuiDir.COUNT; dir += 1
    {
        if (!data.DropRectsDraw[dir + 1].IsInverted())
        {
            draw_r := data.DropRectsDraw[dir + 1];
            draw_r_in := draw_r;
            draw_r_in.Expand(-2.0);
            overlay_col := (data.SplitDir == cast(ImGuiDir)dir && data.IsSplitDirExplicit) ? overlay_col_drop_hovered : overlay_col_drop;
            for overlay_n := 0; overlay_n < overlay_draw_lists_count; overlay_n += 1
            {
                center := ImFloor(draw_r_in.GetCenter());
                overlay_draw_lists[overlay_n]->AddRectFilled(draw_r.Min, draw_r.Max, overlay_col, overlay_rounding);
                overlay_draw_lists[overlay_n]->AddRect(draw_r_in.Min, draw_r_in.Max, overlay_col_lines, overlay_rounding);
                if (dir == .Left || dir == .Right) {
                    overlay_draw_lists[overlay_n]->AddLine(ImVec2{center.x, draw_r_in.Min.y}, ImVec2{center.x, draw_r_in.Max.y}, overlay_col_lines);
                }

                if (dir == ImGuiDir.Up || dir == ImGuiDir.Down) {
                    overlay_draw_lists[overlay_n]->AddLine(ImVec2{draw_r_in.Min.x, center.y}, ImVec2{draw_r_in.Max.x, center.y}, overlay_col_lines);
                }

            }
        }

        // Stop after nil
        if ((host_node && (.NoDockingSplit in host_node.MergedFlags)) || g.IO.ConfigDockingNoSplit)   do return
    }
}

//-----------------------------------------------------------------------------
// Docking: ImGuiDockNode Tree manipulation functions
//-----------------------------------------------------------------------------
// - DockNodeTreeSplit()
// - DockNodeTreeMerge()
// - DockNodeTreeUpdatePosSize()
// - DockNodeTreeUpdateSplitterFindTouchingNode()
// - DockNodeTreeUpdateSplitter()
// - DockNodeTreeFindFallbackLeafNode()
// - DockNodeTreeFindNodeByPos()
//-----------------------------------------------------------------------------

DockNodeTreeSplit :: proc(ctx : ^ImGuiContext, parent_node : ^ImGuiDockNode, split_axis : ImGuiAxis, split_inheritor_child_idx : i32, split_ratio : f32, new_node : ^ImGuiDockNode)
{
    g := GImGui;
    assert(split_axis != ImGuiAxis_None);

    child_0 := (new_node && split_inheritor_child_idx != 0) ? new_node : DockContextAddNode(ctx, 0);
    child_0.ParentNode = parent_node;

    child_1 := (new_node && split_inheritor_child_idx != 1) ? new_node : DockContextAddNode(ctx, 0);
    child_1.ParentNode = parent_node;

    child_inheritor := (split_inheritor_child_idx == 0) ? child_0 : child_1;
    DockNodeMoveChildNodes(child_inheritor, parent_node);
    parent_node.ChildNodes[0] = child_0;
    parent_node.ChildNodes[1] = child_1;
    parent_node.ChildNodes[split_inheritor_child_idx]->VisibleWindow = parent_node.VisibleWindow;
    parent_node.SplitAxis = split_axis;
    parent_node.VisibleWindow = nil;
    parent_node.AuthorityForSize = .DockNode;
    parent_node.AuthorityForPos = .DockNode;

    size_avail := (parent_node.Size[split_axis] - g.Style.DockingSeparatorSize);
    size_avail = ImMax(size_avail, g.Style.WindowMinSize[split_axis] * 2.0);
    assert(size_avail > 0.0); // If you created a node manually with DockBuilderAddNode(), you need to also call DockBuilderSetNodeSize() before splitting.
    child_1.SizeRef = len(parent_node);
    child_0.SizeRef = len(parent_node);
    child_0.SizeRef[split_axis] = ImTrunc(size_avail * split_ratio);
    child_1.SizeRef[split_axis] = ImTrunc(size_avail - child_0.SizeRef[split_axis]);

    DockNodeMoveWindows(parent_node.ChildNodes[split_inheritor_child_idx], parent_node);
    DockSettingsRenameNodeReferences(parent_node.ID, parent_node.ChildNodes[split_inheritor_child_idx].ID);
    DockNodeUpdateHasCentralNodeChild(DockNodeGetRootNode(parent_node));
    DockNodeTreeUpdatePosSize(parent_node, parent_node.Pos, parent_node.Size);

    // Flags transfer (e.g. this is where we transfer the ImGuiDockNodeFlags_CentralNode property)
    child_0.SharedFlags = parent_node.SharedFlags & ImGuiDockNodeFlags_SharedFlagsInheritMask_;
    child_1.SharedFlags = parent_node.SharedFlags & ImGuiDockNodeFlags_SharedFlagsInheritMask_;
    child_inheritor.LocalFlags = parent_node.LocalFlags & ImGuiDockNodeFlags_LocalFlagsTransferMask_;
    parent_node.LocalFlags &= ~ImGuiDockNodeFlags_LocalFlagsTransferMask_;
    child_0.UpdateMergedFlags();
    child_1.UpdateMergedFlags();
    parent_node.UpdateMergedFlags();
    if (child_inheritor.IsCentralNode()) {
        DockNodeGetRootNode(parent_node)->CentralNode = child_inheritor;
    }

}

DockNodeTreeMerge :: proc(ctx : ^ImGuiContext, parent_node : ^ImGuiDockNode, merge_lead_child : ^ImGuiDockNode)
{
    // When called from DockContextProcessUndockNode() it is possible that one of the child is NULL.
    g := GImGui;
    child_0 := parent_node.ChildNodes[0];
    child_1 := parent_node.ChildNodes[1];
    assert(child_0 != nil || child_1 != nil);
    assert(merge_lead_child == child_0 || merge_lead_child == child_1);
    if ((child_0 != nil && len(child_0.Windows) > 0) || (child_1 != nil && len(child_1.Windows) > 0))
    {
        assert(parent_node.TabBar == nil);
        assert(len(parent_node.Windows) == 0);
    }
    IMGUI_DEBUG_LOG_DOCKING(g, "[docking] DockNodeTreeMerge: 0x%08X + 0x%08X back into parent 0x%08X\n", child_0 != nil ? child_0.ID : 0, child_1 != nil ? child_1.ID : 0, parent_node.ID);

    backup_last_explicit_size := parent_node.SizeRef;
    DockNodeMoveChildNodes(parent_node, merge_lead_child);
    if (child_0 != nil)
    {
        DockNodeMoveWindows(parent_node, child_0); // Generally only 1 of the 2 child node will have windows
        DockSettingsRenameNodeReferences(child_0.ID, parent_node.ID);
    }
    if (child_1 != nil)
    {
        DockNodeMoveWindows(parent_node, child_1);
        DockSettingsRenameNodeReferences(child_1.ID, parent_node.ID);
    }
    DockNodeApplyPosSizeToWindows(parent_node);
    parent_node.AuthorityForViewport = .Auto;
    parent_node.AuthorityForSize = .Auto;
    parent_node.AuthorityForPos = .Auto;
    parent_node.VisibleWindow = merge_lead_child.VisibleWindow;
    parent_node.SizeRef = backup_last_explicit_size;

    // Flags transfer
    parent_node.LocalFlags &= ~(transmute(ImGuiDockNodeFlags) ImGuiDockNodeFlagsPrivate.LocalFlagsTransferMask_); // Preserve Dockspace flag
    parent_node.LocalFlags |= (child_0 != nil ? child_0.LocalFlags : nil) & transmute(ImGuiDockNodeFlags) ImGuiDockNodeFlagsPrivate.LocalFlagsTransferMask_;
    parent_node.LocalFlags |= (child_1 != nil ? child_1.LocalFlags : nil) & transmute(ImGuiDockNodeFlags) ImGuiDockNodeFlagsPrivate.LocalFlagsTransferMask_;
    parent_node.LocalFlagsInWindows = (child_0 != nil ? child_0.LocalFlagsInWindows : nil) | (child_1 != nil ? child_1.LocalFlagsInWindows : nil); // FIXME: Would be more consistent to update from actual windows
    UpdateMergedFlags(parent_node);

    if (child_0 != nil)
    {
        SetVoidPtr(&ctx.DockContext.Nodes, child_0.ID, nil);
        IM_DELETE(child_0);
    }
    if (child_1 != nil)
    {
        SetVoidPtr(&ctx.DockContext.Nodes, child_1.ID, nil);
        IM_DELETE(child_1);
    }
}

// Update Pos/Size for a node hierarchy (don't affect child Windows yet)
// (Depth-first, Pre-Order)
DockNodeTreeUpdatePosSize :: proc(node : ^ImGuiDockNode, pos : ImVec2, size : ImVec2, only_write_to_single_node : ^ImGuiDockNode = nil)
{
    // During the regular dock node update we write to all nodes.
    // 'only_write_to_single_node' is only set when turning a node visible mid-frame and we need its size right-away.
    g := GImGui;
    write_to_node := only_write_to_single_node == nil || only_write_to_single_node == node;
    if (write_to_node)
    {
        node.Pos = pos;
        len(node) = size;
    }

    if (node.IsLeafNode())   do return

    child_0 := node.ChildNodes[0];
    child_1 := node.ChildNodes[1];
    child_0_pos := pos; child_1_pos := pos;
    child_0_size := size; child_1_size := size;

    child_0_is_toward_single_node := (only_write_to_single_node != nil && DockNodeIsInHierarchyOf(only_write_to_single_node, child_0));
    child_1_is_toward_single_node := (only_write_to_single_node != nil && DockNodeIsInHierarchyOf(only_write_to_single_node, child_1));
    child_0_is_or_will_be_visible := child_0.IsVisible || child_0_is_toward_single_node;
    child_1_is_or_will_be_visible := child_1.IsVisible || child_1_is_toward_single_node;

    if (child_0_is_or_will_be_visible && child_1_is_or_will_be_visible)
    {
        spacing := g.Style.DockingSeparatorSize;
        axis := cast(ImGuiAxis)node.SplitAxis;
        size_avail := ImMax(size[axis] - spacing, 0.0);

        // Size allocation policy
        // 1) The first 0..WindowMinSize[axis]*2 are allocated evenly to both windows.
        size_min_each := ImTrunc(ImMin(size_avail, g.Style.WindowMinSize[axis] * 2.0) * 0.5);

        // FIXME: Blocks 2) and 3) are essentially doing nearly the same thing.
        // Difference are: write-back to SizeRef; application of a minimum size; rounding before ImTrunc()
        // Clarify and rework differences between Size & SizeRef and purpose of WantLockSizeOnce

        // 2) Process locked absolute size (during a splitter resize we preserve the child of nodes not touching the splitter edge)
        if (child_0.WantLockSizeOnce && !child_1.WantLockSizeOnce)
        {
            child_0.SizeRef[axis] = ImMin(size_avail - 1.0, child_0.Size[axis]);
            child_0_size[axis] = child_0.SizeRef[axis]
            child_1.SizeRef[axis] = (size_avail - child_0_size[axis]);
            child_1_size[axis] = child_1.SizeRef[axis]
            assert(child_0.SizeRef[axis] > 0.0 && child_1.SizeRef[axis] > 0.0);
        }
        else if (child_1.WantLockSizeOnce && !child_0.WantLockSizeOnce)
        {
            child_1.SizeRef[axis] = ImMin(size_avail - 1.0, child_1.Size[axis]);
            child_1_size[axis] = child_1.SizeRef[axis]
            child_0.SizeRef[axis] = (size_avail - child_1_size[axis]);
            child_0_size[axis] = child_0.SizeRef[axis]
            assert(child_0.SizeRef[axis] > 0.0 && child_1.SizeRef[axis] > 0.0);
        }
        else if (child_0.WantLockSizeOnce && child_1.WantLockSizeOnce)
        {
            // FIXME-DOCK: We cannot honor the requested size, so apply ratio.
            // Currently this path will only be taken if code programmatically sets WantLockSizeOnce
            split_ratio := child_0_size[axis] / (child_0_size[axis] + child_1_size[axis]);
            child_0.SizeRef[axis] = ImTrunc(size_avail * split_ratio);
            child_0_size[axis] = child_0.SizeRef[axis]
            child_1.SizeRef[axis] = (size_avail - child_0_size[axis]);
            child_1_size[axis] = child_1.SizeRef[axis]
            assert(child_0.SizeRef[axis] > 0.0 && child_1.SizeRef[axis] > 0.0);
        }
        else if (child_0.SizeRef[axis] != 0.0 && child_1.HasCentralNodeChild)        
        {
            // 3) If one window is the central node (~ use remaining space, should be made explicit!), use explicit size from the other, and remainder for the central node
            child_0_size[axis] = ImMin(size_avail - size_min_each, child_0.SizeRef[axis]);
            child_1_size[axis] = (size_avail - child_0_size[axis]);
        }
        else if (child_1.SizeRef[axis] != 0.0 && child_0.HasCentralNodeChild)        
        {
            child_1_size[axis] = ImMin(size_avail - size_min_each, child_1.SizeRef[axis]);
            child_0_size[axis] = (size_avail - child_1_size[axis]);
        }
        else
        {
            // 4) Otherwise distribute according to the relative ratio of each SizeRef value
            split_ratio := child_0.SizeRef[axis] / (child_0.SizeRef[axis] + child_1.SizeRef[axis]);
            child_0_size[axis] = ImMax(size_min_each, ImTrunc(size_avail * split_ratio + 0.5));
            child_1_size[axis] = (size_avail - child_0_size[axis]);
        }

        child_1_pos[axis] += spacing + child_0_size[axis];
    }

    if (only_write_to_single_node == nil) {
        child_1.WantLockSizeOnce = false;
        child_0.WantLockSizeOnce = false
    }

    child_0_recurse := only_write_to_single_node ? child_0_is_toward_single_node : child_0.IsVisible;
    child_1_recurse := only_write_to_single_node ? child_1_is_toward_single_node : child_1.IsVisible;
    if (child_0_recurse) {
        DockNodeTreeUpdatePosSize(child_0, child_0_pos, child_0_size);
    }

    if (child_1_recurse) {
        DockNodeTreeUpdatePosSize(child_1, child_1_pos, child_1_size);
    }

}

DockNodeTreeUpdateSplitterFindTouchingNode :: proc(node : ^ImGuiDockNode, axis : ImGuiAxis, side : i32, touching_nodes : ^[]^ImGuiDockNode)
{
    if (node.IsLeafNode())
    {
        touching_nodes.append(node);
        return;
    }
    if (node.ChildNodes[0]->IsVisible) {
        if (node.SplitAxis != axis || side == 0 || !node.ChildNodes[1]->IsVisible) {
            DockNodeTreeUpdateSplitterFindTouchingNode(node.ChildNodes[0], axis, side, touching_nodes);
        }
    }

    if (node.ChildNodes[1]->IsVisible) {
        if (node.SplitAxis != axis || side == 1 || !node.ChildNodes[0]->IsVisible) {
            DockNodeTreeUpdateSplitterFindTouchingNode(node.ChildNodes[1], axis, side, touching_nodes);
        }
    }

}

// (Depth-First, Pre-Order)
DockNodeTreeUpdateSplitter :: proc(node : ^ImGuiDockNode)
{
    if (node.IsLeafNode())   do return

    g := GImGui;

    child_0 := node.ChildNodes[0];
    child_1 := node.ChildNodes[1];
    if (child_0.IsVisible && child_1.IsVisible)
    {
        // Bounding box of the splitter cover the space between both nodes (w = Spacing, h = Size[xy^1] for when splitting horizontally)
        axis := cast(ImGuiAxis)node.SplitAxis;
        assert(axis != ImGuiAxis_None);
        bb : ImRect
        bb.Min = child_0.Pos;
        bb.Max = child_1.Pos;
        bb.Min[axis] += child_0.Size[axis];
        bb.Max[axis ~ 1] += child_1.Size[axis ~ 1];
        //if (g.IO.KeyCtrl) GetForegroundDrawList(g.CurrentWindow.Viewport)->AddRect(bb.Min, bb.Max, IM_COL32(255,0,255,255));

        merged_flags := child_0.MergedFlags | child_1.MergedFlags; // Merged flags for BOTH childs
        no_resize_axis_flag := (axis == ImGuiAxis.X) ? ImGuiDockNodeFlags_NoResizeX : ImGuiDockNodeFlags_NoResizeY;
        if ((.NoResize in merged_flags) || (.flag in merged_flags))
        {
            window := g.CurrentWindow;
            AddRectFilled(window.DrawList, bb.Min, bb.Max, GetColorU32(ImGuiCol.Separator), g.Style.FrameRounding);
        }
        else
        {
            //bb.Min[axis] += 1; // Display a little inward so highlight doesn't connect with nearby tabs on the neighbor node.
            //bb.Max[axis] -= 1;
            PushID(node.ID);

            // Find resizing limits by gathering list of nodes that are touching the splitter line.
            touching_nodes : [2][dynamic]^ImGuiDockNode;
            min_size := g.Style.WindowMinSize[axis];
            resize_limits : [2]f32;
            resize_limits[0] = node.ChildNodes[0]->Pos[axis] + min_size;
            resize_limits[1] = node.ChildNodes[1]->Pos[axis] + node.ChildNodes[1]->Size[axis] - min_size;

            splitter_id := GetID("##Splitter");
            if (g.ActiveId == splitter_id) // Only process when splitter is active
            {
                DockNodeTreeUpdateSplitterFindTouchingNode(child_0, axis, 1, &touching_nodes[0]);
                DockNodeTreeUpdateSplitterFindTouchingNode(child_1, axis, 0, &touching_nodes[1]);
                for touching_node_n := 0; touching_node_n < touching_nodes[0].Size; touching_node_n += 1 {
                    resize_limits[0] = ImMax(resize_limits[0], touching_nodes[0][touching_node_n]->Rect().Min[axis] + min_size);
                }
                for touching_node_n := 0; touching_node_n < touching_nodes[1].Size; touching_node_n += 1 {
                    resize_limits[1] = ImMin(resize_limits[1], touching_nodes[1][touching_node_n]->Rect().Max[axis] - min_size);
                }

                // [DEBUG] Render touching nodes & limits
                /*
                draw_list := node.HostWindow ? GetForegroundDrawList(node.HostWindow) : GetForegroundDrawList(GetMainViewport());
                for n := 0; n < 2; n += 1
                {
                    for touching_node_n := 0; touching_node_n < touching_nodes[n].Size; touching_node_n += 1
                        draw_list.AddRect(touching_nodes[n][touching_node_n]->Pos, touching_nodes[n][touching_node_n]->Pos + touching_nodes[n][touching_node_n]->Size, IM_COL32(0, 255, 0, 255));
                    if (axis == ImGuiAxis.X) {
                        draw_list.AddLine(ImVec2{resize_limits[n], node.ChildNodes[n]->Pos.y}, ImVec2{resize_limits[n], node.ChildNodes[n]->Pos.y + node.ChildNodes[n]->Size.y}, IM_COL32(255, 0, 255, 255), 3.0);
                    }

                    else
                        draw_list.AddLine(ImVec2{node.ChildNodes[n]->Pos.x, resize_limits[n]}, ImVec2{node.ChildNodes[n]->Pos.x + node.ChildNodes[n]->Size.x, resize_limits[n]}, IM_COL32(255, 0, 255, 255), 3.0);
                }
                */
            }

            // Use a short delay before highlighting the splitter (and changing the mouse cursor) in order for regular mouse movement to not highlight many splitters
            cur_size_0 := child_0.Size[axis];
            cur_size_1 := child_1.Size[axis];
            min_size_0 := resize_limits[0] - child_0.Pos[axis];
            min_size_1 := child_1.Pos[axis] + child_1.Size[axis] - resize_limits[1];
            bg_col := GetColorU32(ImGuiCol.WindowBg);
            if (SplitterBehavior(bb, GetID("##Splitter"), axis, &cur_size_0, &cur_size_1, min_size_0, min_size_1, WINDOWS_HOVER_PADDING, WINDOWS_RESIZE_FROM_EDGES_FEEDBACK_TIMER, bg_col))
            {
                if (touching_nodes[0].Size > 0 && touching_nodes[1].Size > 0)
                {
                    child_0.SizeRef[axis] = cur_size_0;
                    child_0.Size[axis] = cur_size_0;
                    child_1.Pos[axis] -= cur_size_1 - child_1.Size[axis];
                    child_1.SizeRef[axis] = cur_size_1;
                    child_1.Size[axis] = cur_size_1;

                    // Lock the size of every node that is a sibling of the node we are touching
                    // This might be less desirable if we can merge sibling of a same axis into the same parental level.
                    for side_n := 0; side_n < 2; side_n += 1 {
                        for touching_node_n := 0; touching_node_n < touching_nodes[side_n].Size; touching_node_n += 1
                        {
                            touching_node := touching_nodes[side_n][touching_node_n];
                            //ImDrawList* draw_list = node.HostWindow ? GetForegroundDrawList(node.HostWindow) : GetForegroundDrawList(GetMainViewport());
                            //draw_list.AddRect(touching_node.Pos, touching_node.Pos + touching_node.Size, IM_COL32(255, 128, 0, 255));
                            for (touching_node.ParentNode != node)
                            {
                                if (touching_node.ParentNode.SplitAxis == axis)
                                {
                                    // Mark other node so its size will be preserved during the upcoming call to DockNodeTreeUpdatePosSize().
                                    node_to_preserve := touching_node.ParentNode.ChildNodes[side_n];
                                    node_to_preserve.WantLockSizeOnce = true;
                                    //draw_list.AddRect(touching_node.Pos, touching_node.Rect().Max, IM_COL32(255, 0, 0, 255));
                                    //AddRectFilled(draw_list, node_to_preserve.Pos, node_to_preserve.Rect().Max, IM_COL32(0, 255, 0, 100));
                                }
                                touching_node = touching_node.ParentNode;
                            }
                        }
                    }

                    DockNodeTreeUpdatePosSize(child_0, child_0.Pos, child_0.Size);
                    DockNodeTreeUpdatePosSize(child_1, child_1.Pos, child_1.Size);
                    MarkIniSettingsDirty();
                }
            }
            PopID();
        }
    }

    if (child_0.IsVisible) {
        DockNodeTreeUpdateSplitter(child_0);
    }

    if (child_1.IsVisible) {
        DockNodeTreeUpdateSplitter(child_1);
    }

}

DockNodeTreeFindFallbackLeafNode :: proc(node : ^ImGuiDockNode) -> ^ImGuiDockNode
{
    if (node.IsLeafNode())   do return node
    if leaf_node := DockNodeTreeFindFallbackLeafNode(node.ChildNodes[0]); leaf_node  != nil   do return leaf_node
    if leaf_node := DockNodeTreeFindFallbackLeafNode(node.ChildNodes[1]); leaf_node  != nil   do return leaf_node
    return nil;
}

DockNodeTreeFindVisibleNodeByPos :: proc(node : ^ImGuiDockNode, pos : ImVec2) -> ^ImGuiDockNode
{
    if (!node.IsVisible)   do return nil

    dock_spacing := 0.0;// g.Style.ItemInnerSpacing.x; // FIXME: Relation to DOCKING_SPLITTER_SIZE?
    r := ImRect{ _v = {node.Pos, node.Pos + node.Size}};
    r.Expand(dock_spacing * 0.5);
    inside := r.Contains(pos);
    if (!inside)   do return nil

    if (node.IsLeafNode())   do return node
    if hovered_node := DockNodeTreeFindVisibleNodeByPos(node.ChildNodes[0], pos); hovered_node != nil   do return hovered_node
    if hovered_node := DockNodeTreeFindVisibleNodeByPos(node.ChildNodes[1], pos); hovered_node != nil   do return hovered_node

    // This means we are hovering over the splitter/spacing of a parent node
    return node;
}

//-----------------------------------------------------------------------------
// Docking: Public Functions (SetWindowDock, DockSpace, DockSpaceOverViewport)
//-----------------------------------------------------------------------------
// - SetWindowDock() [Internal]
// - DockSpace()
// - DockSpaceOverViewport()
//-----------------------------------------------------------------------------

// [Internal] Called via SetNextWindowDockID()
SetWindowDock :: proc(window : ^ImGuiWindow, dock_id : ImGuiID, cond : ImGuiCond)
{
    dock_id := dock_id

    // Test condition (NB: bit 0 is always true) and clear flags for next time
    if (cond != nil && (window.SetWindowDockAllowFlags & cond) == nil)   do return
    window.SetWindowDockAllowFlags &= ~{.Once, .FirstUseEver, .Appearing};

    if (window.DockId == dock_id)   do return

    // If the user attempt to set a dock id that is a split node, we'll dig within to find a suitable docking spot
    g := GImGui;
    if new_node := DockContextFindNodeByID(g, dock_id); new_node != nil {
        if (IsSplitNode(new_node))
        {
            // Policy: Find central node or latest focused node. We first move back to our root node.
            new_node = DockNodeGetRootNode(new_node);
            if (new_node.CentralNode != nil)
            {
                assert(IsCentralNode(new_node.CentralNode));
                dock_id = new_node.CentralNode.ID;
            }
            else
            {
                dock_id = new_node.LastFocusedNodeId;
            }
        }
    }

    if (window.DockId == dock_id)   do return

    if (window.DockNode != nil) {
        DockNodeRemoveWindow(window.DockNode, window, 0);
    }

    window.DockId = dock_id;
}

// Create an explicit dockspace node within an existing window. Also expose dock node flags and creates a CentralNode by default.
// The Central Node is always displayed even when empty and shrink/extend according to the requested size of its neighbors.
// DockSpace() needs to be submitted _before_ any window they can host. If you use a dockspace, submit it early in your app.
// When ImGuiDockNodeFlags_KeepAliveOnly is set, nothing is submitted in the current window (function may be called from any location).
DockSpace :: proc(dockspace_id : ImGuiID, size_arg : ImVec2 = {}, flags : ImGuiDockNodeFlags = {}, window_class : ^ImGuiWindowClass = nil) -> ImGuiID
{
    g := GImGui;
    window := GetCurrentWindowRead();
    if (!(.DockingEnable in g.IO.ConfigFlags))   do return 0

    // Early out if parent window is hidden/collapsed
    // This is faster but also DockNodeUpdateTabBar() relies on TabBarLayout() running (which won't if SkipItems=true) to set NextSelectedTabId = 0). See #2960.
    // If for whichever reason this is causing problem we would need to ensure that DockNodeUpdateTabBar() ends up clearing NextSelectedTabId even if SkipItems=true.
    if (window.SkipItems) {
        flags |= ImGuiDockNodeFlags_KeepAliveOnly;
    }

    if ((.KeepAliveOnly not_in flags)) {
        window = GetCurrentWindow(); // call to set window.WriteAccessed = true;
    }

    assert((.DockSpace not_in flags)); // Flag is automatically set by DockSpace() as LocalFlags, not SharedFlags!
    assert((.CentralNode not_in flags)); // Flag is automatically set by DockSpace() as LocalFlags, not SharedFlags! (#8145)

    assert(dockspace_id != 0);
    node := DockContextFindNodeByID(g, dockspace_id);
    if (node == nil)
    {
        IMGUI_DEBUG_LOG_DOCKING(g, "[docking] DockSpace: dockspace node 0x%08X created\n", dockspace_id);
        node = DockContextAddNode(g, dockspace_id);
        SetLocalFlags(node, ImGuiDockNodeFlags_CentralNode);
    }
    if (window_class && window_class.ClassId != node.WindowClass.ClassId) {
        IMGUI_DEBUG_LOG_DOCKING(g, "[docking] DockSpace: dockspace node 0x%08X: setup WindowClass 0x%08X -> 0x%08X\n", dockspace_id, node.WindowClass.ClassId, window_class.ClassId);
    }
    node.SharedFlags = flags;
    node.WindowClass = window_class ? window_class^ : make_ImGuiWindowClass();

    // When a DockSpace transitioned form implicit to explicit this may be called a second time
    // It is possible that the node has already been claimed by a docked window which appeared before the DockSpace() node, so we overwrite IsDockSpace again.
    if (node.LastFrameActive == g.FrameCount && !(.KeepAliveOnly in flags))
    {
        assert(node.IsDockSpace() == false, "Cannot call DockSpace() twice a frame with the same ID");
        SetLocalFlags(node, node.LocalFlags | ImGuiDockNodeFlags_DockSpace);
        return dockspace_id;
    }
    SetLocalFlags(node, node.LocalFlags | ImGuiDockNodeFlags_DockSpace);

    // Keep alive mode, this is allow windows docked into this node so stay docked even if they are not visible
    if (.KeepAliveOnly in flags)
    {
        node.LastFrameAlive = g.FrameCount;
        return dockspace_id;
    }

    content_avail := GetContentRegionAvail();
    size := ImTrunc(size_arg);
    if (size.x <= 0.0) {
        size.x = ImMax(content_avail.x + size.x, 4.0); // Arbitrary minimum child size (0.0f causing too much issues)
    }

    if (size.y <= 0.0) {
        size.y = ImMax(content_avail.y + size.y, 4.0);
    }

    assert(size.x > 0.0 && size.y > 0.0);

    node.Pos = window.DC.CursorPos;
    node.SizeRef = size;
    len(node) = size
    SetNextWindowPos(node.Pos);
    SetNextWindowSize(node.Size);
    g.NextWindowData.PosUndock = false;

    // FIXME-DOCK: Why do we need a child window to host a dockspace, could we host it in the existing window?
    // FIXME-DOCK: What is the reason for not simply calling BeginChild()? (OK to have a reason but should be commented)
    window_flags := ImGuiWindowFlags_ChildWindow | ImGuiWindowFlags_DockNodeHost;
    window_flags |= ImGuiWindowFlags_NoSavedSettings | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_NoTitleBar;
    window_flags |= ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_NoScrollWithMouse;
    window_flags |= ImGuiWindowFlags_NoBackground;

    title : [256]u8;
    ImFormatString(title, len(title), "%s/DockSpace_%08X", window.Name, dockspace_id);

    PushStyleVar(ImGuiStyleVar_ChildBorderSize, 0.0);
    Begin(title, nil, window_flags);
    PopStyleVar();

    host_window := g.CurrentWindow;
    DockNodeSetupHostWindow(node, host_window);
    host_window.ChildId = GetID(window, title);
    node.OnlyNodeWithWindows = nil;

    assert(node.IsRootNode());

    // We need to handle the rare case were a central node is missing.
    // This can happen if the node was first created manually with DockBuilderAddNode() but _without_ the ImGuiDockNodeFlags_Dockspace.
    // Doing it correctly would set the _CentralNode flags, which would then propagate according to subsequent split.
    // It would also be ambiguous to attempt to assign a central node while there are split nodes, so we wait until there's a single node remaining.
    // The specific sub-property of _CentralNode we are interested in recovering here is the "Don't delete when empty" property,
    // as it doesn't make sense for an empty dockspace to not have this property.
    if (node.IsLeafNode() && !IsCentralNode(node)) {
        SetLocalFlags(node, node.LocalFlags | ImGuiDockNodeFlags_CentralNode);
    }

    // Update the node
    DockNodeUpdate(node);

    End();

    bb := ImRect{ _v = {node.Pos, node.Pos + size}};
    ItemSize(size);
    ItemAdd(bb, dockspace_id, nil, ImGuiItemFlags_NoNav); // Not a nav point (could be, would need to draw the nav rect and replicate/refactor activation from BeginChild(), but seems like CTRL+Tab works better here?)
    if ((.HoveredRect in g.LastItemData.StatusFlags) && IsWindowChildOf(g.HoveredWindow, host_window, false, true)) {// To fullfill IsItemHovered(), similar to EndChild()
        g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_HoveredWindow;
    }

    return dockspace_id;
}

// Tips: Use with ImGuiDockNodeFlags_PassthruCentralNode!
// The limitation with this call is that your window won't have a local menu bar, but you can also use BeginMainMenuBar().
// Even though we could pass window flags, it would also require the user to be able to call BeginMenuBar() somehow meaning we can't Begin/End in a single function.
// If you really want a menu bar inside the same window as the one hosting the dockspace, you will need to copy this code somewhere and tweak it.
DockSpaceOverViewport :: proc(dockspace_id : ImGuiID = {}, viewport : ^ImGuiViewport = nil, dockspace_flags : ImGuiDockNodeFlags = {}, window_class : ^ImGuiWindowClass = nil) -> ImGuiID
{
    if (viewport == nil) {
        viewport = GetMainViewport();
    }

    // Submit a window filling the entire viewport
    SetNextWindowPos(viewport.WorkPos);
    SetNextWindowSize(viewport.WorkSize);
    SetNextWindowViewport(viewport.ID);

    host_window_flags := 0;
    host_window_flags |= ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoDocking;
    host_window_flags |= ImGuiWindowFlags_NoBringToFrontOnFocus | ImGuiWindowFlags_NoNavFocus;
    if (.PassthruCentralNode in dockspace_flags) {
        host_window_flags |= ImGuiWindowFlags_NoBackground;
    }

    // FIXME-OPT: When using ImGuiDockNodeFlags_KeepAliveOnly with DockSpaceOverViewport() we might be able to spare submitting the window,
    // since DockSpace() with that flag doesn't need a window. We'd only need to compute the default ID accordingly.
    if (.KeepAliveOnly in dockspace_flags) {
        host_window_flags |= ImGuiWindowFlags_NoMouseInputs;
    }

    label : [32]u8;
    ImFormatString(label, len(label), "WindowOverViewport_%08X", viewport.ID);

    PushStyleVar(ImGuiStyleVar_WindowRounding, 0.0);
    PushStyleVar(ImGuiStyleVar_WindowBorderSize, 0.0);
    PushStyleVar(ImGuiStyleVar_WindowPadding, ImVec2{0.0, 0.0});
    Begin(label, nil, host_window_flags);
    PopStyleVar(3);

    // Submit the dockspace
    if (dockspace_id == 0) {
        dockspace_id = GetID("DockSpace");
    }

    DockSpace(dockspace_id, ImVec2{0.0, 0.0}, dockspace_flags, window_class);

    End();

    return dockspace_id;
}

//-----------------------------------------------------------------------------
// Docking: Builder Functions
//-----------------------------------------------------------------------------
// Very early end-user API to manipulate dock nodes.
// Only available in imgui_internal.h. Expect this API to change/break!
// It is expected that those functions are all called _before_ the dockspace node submission.
//-----------------------------------------------------------------------------
// - DockBuilderDockWindow()
// - DockBuilderGetNode()
// - DockBuilderSetNodePos()
// - DockBuilderSetNodeSize()
// - DockBuilderAddNode()
// - DockBuilderRemoveNode()
// - DockBuilderRemoveNodeChildNodes()
// - DockBuilderRemoveNodeDockedWindows()
// - DockBuilderSplitNode()
// - DockBuilderCopyNodeRec()
// - DockBuilderCopyNode()
// - DockBuilderCopyWindowSettings()
// - DockBuilderCopyDockSpace()
// - DockBuilderFinish()
//-----------------------------------------------------------------------------

DockBuilderDockWindow :: proc(window_name : ^u8, node_id : ImGuiID)
{
    // We don't preserve relative order of multiple docked windows (by clearing DockOrder back to -1)
    g := GImGui; _ = g;
    IMGUI_DEBUG_LOG_DOCKING(g, "[docking] DockBuilderDockWindow '%s' to node 0x%08X\n", window_name, node_id);
    window_id := ImHashStr(window_name);
    if window := FindWindowByID(window_id); window != nil
    {
        // Apply to created window
        prev_node_id := window.DockId;
        SetWindowDock(window, node_id, { .Always });
        if (window.DockId != prev_node_id)   do window.DockOrder = -1
    }
    else
    {
        // Apply to settings
        settings := FindWindowSettingsByID(window_id);
        if (settings == nil) {
            settings = CreateNewWindowSettings(window_name);
        }

        if (settings.DockId != node_id)   do settings.DockOrder = -1
        settings.DockId = node_id;
    }
}

DockBuilderGetNode :: proc(node_id : ImGuiID) -> ^ImGuiDockNode
{
    g := GImGui;
    return DockContextFindNodeByID(g, node_id);
}

DockBuilderSetNodePos :: proc(node_id : ImGuiID, pos : ImVec2)
{
    g := GImGui;
    node := DockContextFindNodeByID(g, node_id);
    if (node == nil)   do return
    node.Pos = pos;
    node.AuthorityForPos = .DockNode;
}

DockBuilderSetNodeSize :: proc(node_id : ImGuiID, size : ImVec2)
{
    g := GImGui;
    node := DockContextFindNodeByID(g, node_id);
    if (node == nil)   do return
    assert(size.x > 0.0 && size.y > 0.0);
    node.SizeRef = size;
    len(node) = size
    node.AuthorityForSize = .DockNode;
}

// Make sure to use the ImGuiDockNodeFlags_DockSpace flag to create a dockspace node! Otherwise this will create a floating node!
// - Floating node: you can then call DockBuilderSetNodePos()/DockBuilderSetNodeSize() to position and size the floating node.
// - Dockspace node: calling DockBuilderSetNodePos() is unnecessary.
// - If you intend to split a node immediately after creation using DockBuilderSplitNode(), make sure to call DockBuilderSetNodeSize() beforehand!
//   For various reason, the splitting code currently needs a base size otherwise space may not be allocated as precisely as you would expect.
// - Use (id == 0) to let the system allocate a node identifier.
// - Existing node with a same id will be removed.
DockBuilderAddNode :: proc(node_id : ImGuiID = {}, flags : ImGuiDockNodeFlags = {}) -> ImGuiID
{
    g := GImGui; _ = g;
    IMGUI_DEBUG_LOG_DOCKING(g, "[docking] DockBuilderAddNode 0x%08X flags=%08X\n", node_id, flags);

    if (node_id != 0) {
        DockBuilderRemoveNode(node_id);
    }

    node := nil;
    if (.DockSpace in flags)
    {
        DockSpace(node_id, ImVec2{0, 0}, (flags & ~ImGuiDockNodeFlags_DockSpace) | ImGuiDockNodeFlags_KeepAliveOnly);
        node = DockContextFindNodeByID(g, node_id);
    }
    else
    {
        node = DockContextAddNode(g, node_id);
        SetLocalFlags(node, flags);
    }
    node.LastFrameAlive = g.FrameCount;   // Set this otherwise BeginDocked will undock during the same frame.
    return node.ID;
}

// [forward declared comment]:
// Remove node and all its child, undock all windows
DockBuilderRemoveNode :: proc(node_id : ImGuiID)
{
    g := GImGui; _ = g;
    IMGUI_DEBUG_LOG_DOCKING(g, "[docking] DockBuilderRemoveNode 0x%08X\n", node_id);

    node := DockContextFindNodeByID(g, node_id);
    if (node == nil)   do return
    DockBuilderRemoveNodeDockedWindows(node_id, true);
    DockBuilderRemoveNodeChildNodes(node_id);
    // Node may have moved or deleted if e.g. any merge happened
    node = DockContextFindNodeByID(g, node_id);
    if (node == nil)   do return
    if (IsCentralNode(node) && node.ParentNode) {
        node.ParentSetLocalFlags(node, node.ParentNode.LocalFlags | ImGuiDockNodeFlags_CentralNode);
    }

    DockContextRemoveNode(g, node, true);
}

// root_id = 0 to remove all, root_id != 0 to remove child of given node.
// [forward declared comment]:
// Remove all split/hierarchy. All remaining docked windows will be re-docked to the remaining root node (node_id).
DockBuilderRemoveNodeChildNodes :: proc(root_id : ImGuiID)
{
    g := GImGui;
    dc := &g.DockContext;

    root_node := root_id != 0 ? DockContextFindNodeByID(g, root_id) : nil;
    if (root_id != 0 && root_node == nil)   do return
    has_central_node := false;

    backup_root_node_authority_for_pos := root_node != nil ? root_node.AuthorityForPos : .Auto;
    backup_root_node_authority_for_size := root_node != nil ? root_node.AuthorityForSize : .Auto;

    // Process active windows
    nodes_to_remove : [dynamic]^ImGuiDockNode;
    for n := 0; n < len(dc.Nodes.Data); n += 1 {
        if node := cast(^ImGuiDockNode)dc.Nodes.Data[n].val_p; node != nil
        {
            want_removal := (root_id == 0) || (node.ID != root_id && DockNodeGetRootNode(node).ID == root_id);
            if (want_removal)
            {
                if (IsCentralNode(node))   do has_central_node = true
                if (root_id != 0) {
                    DockContextQueueNotifyRemovedNode(g, node);
                }

                if (root_node != nil)
                {
                    DockNodeMoveWindows(root_node, node);
                    DockSettingsRenameNodeReferences(node.ID, root_node.ID);
                }
                append(&nodes_to_remove, node);
            }
        }
    }

    // DockNodeMoveWindows.DockNodeAddWindow will normally set those when reaching two windows (which is only adequate during interactive merge)
    // Make sure we don't lose our current pos/size. (FIXME-DOCK: Consider tidying up that code in DockNodeAddWindow instead)
    if (root_node != nil)
    {
        root_node.AuthorityForPos = backup_root_node_authority_for_pos;
        root_node.AuthorityForSize = backup_root_node_authority_for_size;
    }

    // Apply to settings
    for settings := begin(&g.SettingsWindows); settings != nil; settings = next_chunk(&g.SettingsWindows, settings) {
        if window_settings_dock_id := settings.DockId; window_settings_dock_id != {} {
            for n := 0; n < len(nodes_to_remove); n += 1 {
                if (nodes_to_remove[n].ID == window_settings_dock_id)
                {
                    settings.DockId = root_id;
                    break;
                }
            }
        }
    }

    // Not really efficient, but easier to destroy a whole hierarchy considering DockContextRemoveNode is attempting to merge nodes
    if (len(nodes_to_remove) > 1) {
        ImQsort(nodes_to_remove[:], len(nodes_to_remove), size_of(^ImGuiDockNode), DockNodeComparerDepthMostFirst);
    }
    for n := 0; n < len(nodes_to_remove); n += 1 {
        DockContextRemoveNode(g, nodes_to_remove[n], false);
    }

    if (root_id == 0)
    {
        clear(&dc.Nodes);
        clear(&dc.Requests);
    }
    else if (has_central_node)
    {
        root_node.CentralNode = root_node;
        SetLocalFlags(root_node, root_node.LocalFlags | ImGuiDockNodeFlags_CentralNode);
    }
}

DockBuilderRemoveNodeDockedWindows :: proc(root_id : ImGuiID, clear_settings_refs : bool = true)
{
    // Clear references in settings
    g := GImGui;
    if (clear_settings_refs)
    {
        for settings := begin(&g.SettingsWindows); settings != nil; settings = next_chunk(&g.SettingsWindows, settings)
        {
            want_removal := (root_id == 0) || (settings.DockId == root_id);
            if (!want_removal && settings.DockId != 0) {
                if node := DockContextFindNodeByID(g, settings.DockId); node != nil {
                    if (DockNodeGetRootNode(node).ID == root_id)   do want_removal = true
                }
            }
            if (want_removal)   do settings.DockId = 0
        }
    }

    // Clear references in windows
    for n := 0; n < len(g.Windows); n += 1
    {
        window := g.Windows[n];
        want_removal := (root_id == 0) || (window.DockNode && DockNodeGetRootNode(window.DockNode).ID == root_id) || (window.DockNodeAsHost && window.DockNodeAsHost.ID == root_id);
        if (want_removal)
        {
            backup_dock_id := window.DockId;
            _ = backup_dock_id;
            DockContextProcessUndockWindow(g, window, clear_settings_refs);
            if (!clear_settings_refs) {
                assert(window.DockId == backup_dock_id);
            }

        }
    }
}

// If 'out_id_at_dir' or 'out_id_at_opposite_dir' are non NULL, the function will write out the ID of the two new nodes created.
// Return value is ID of the node at the specified direction, so same as (*out_id_at_dir) if that pointer is set.
// FIXME-DOCK: We are not exposing nor using split_outer.
// [forward declared comment]:
// Create 2 child nodes in this parent node.
DockBuilderSplitNode :: proc(id : ImGuiID, split_dir : ImGuiDir, size_ratio_for_node_at_dir : f32, out_id_at_dir : ^ImGuiID, out_id_at_opposite_dir : ^ImGuiID) -> ImGuiID
{
    g := GImGui;
    assert(split_dir != nil);
    IMGUI_DEBUG_LOG_DOCKING(g, "[docking] DockBuilderSplitNode: node 0x%08X, split_dir %d\n", id, split_dir);

    node := DockContextFindNodeByID(g, id);
    if (node == nil)
    {
        assert(node != nil);
        return 0;
    }

    assert(!node.IsSplitNode()); // Assert if already Split

    req : ImGuiDockRequest
    req.Type = ImGuiDockRequestType_Split;
    req.DockTargetWindow = nil;
    req.DockTargetNode = node;
    req.DockPayload = nil;
    req.DockSplitDir = split_dir;
    req.DockSplitRatio = ImSaturate((split_dir == .Left || split_dir == ImGuiDir.Up) ? size_ratio_for_node_at_dir : 1.0 - size_ratio_for_node_at_dir);
    req.DockSplitOuter = false;
    DockContextProcessDock(g, &req);

    id_at_dir := node.ChildNodes[(split_dir == .Left || split_dir == ImGuiDir.Up) ? 0 : 1].ID;
    id_at_opposite_dir := node.ChildNodes[(split_dir == .Left || split_dir == ImGuiDir.Up) ? 1 : 0].ID;
    if (out_id_at_dir) {
        out_id_at_dir^ = id_at_dir;
    }

    if (out_id_at_opposite_dir) {
        out_id_at_opposite_dir^ = id_at_opposite_dir;
    }

    return id_at_dir;
}

DockBuilderCopyNodeRec :: proc(src_node : ^ImGuiDockNode, dst_node_id_if_known : ImGuiID, out_node_remap_pairs : ^[]ImGuiID) -> ^ImGuiDockNode
{
    g := GImGui;
    dst_node := DockContextAddNode(g, dst_node_id_if_known);
    dst_node.SharedFlags = src_node.SharedFlags;
    dst_node.LocalFlags = src_node.LocalFlags;
    dst_node.LocalFlagsInWindows = ImGuiDockNodeFlags_None;
    dst_node.Pos = src_node.Pos;
    len(dst_node) = len(src_node);
    dst_node.SizeRef = src_node.SizeRef;
    dst_node.SplitAxis = src_node.SplitAxis;
    dst_node.UpdateMergedFlags();

    out_node_remap_pairs.append(src_node.ID);
    out_node_remap_pairs.append(dst_node.ID);

    for child_n := 0; child_n < len(src_node.ChildNodes); child_n += 1 {
        if (src_node.ChildNodes[child_n])
        {
            dst_node.ChildNodes[child_n] = DockBuilderCopyNodeRec(src_node.ChildNodes[child_n], 0, out_node_remap_pairs);
            dst_node.ChildNodes[child_n]->ParentNode = dst_node;
        }
    }

    IMGUI_DEBUG_LOG_DOCKING(g, "[docking] Fork node %08X -> %08X (%d childs)\n", src_node.ID, dst_node.ID, dst_node.IsSplitNode() ? 2 : 0);
    return dst_node;
}

DockBuilderCopyNode :: proc(src_node_id : ImGuiID, dst_node_id : ImGuiID, out_node_remap_pairs : ^[]ImGuiID)
{
    g := GImGui;
    assert(src_node_id != 0);
    assert(dst_node_id != 0);
    assert(out_node_remap_pairs != nil);

    DockBuilderRemoveNode(dst_node_id);

    src_node := DockContextFindNodeByID(g, src_node_id);
    assert(src_node != nil);

    out_node_remap_pairs.clear();
    DockBuilderCopyNodeRec(src_node, dst_node_id, out_node_remap_pairs);

    assert((len(out_node_remap_pairs) % 2) == 0);
}

DockBuilderCopyWindowSettings :: proc(src_name : ^u8, dst_name : ^u8)
{
    src_window := FindWindowByName(src_name);
    if (src_window == nil)   do return
    if dst_window := FindWindowByName(dst_name); dst_window != nil
    {
        dst_window.Pos = src_window.Pos;
        len(dst_window) = len(src_window);
        dst_window.SizeFull = src_window.SizeFull;
        dst_window.Collapsed = src_window.Collapsed;
    }
    else
    {
        dst_settings := FindWindowSettingsByID(ImHashStr(dst_name));
        if (!dst_settings) {
            dst_settings = CreateNewWindowSettings(dst_name);
        }

        window_pos_2ih := ImVec2ih(src_window.Pos);
        if (src_window.ViewportId != 0 && src_window.ViewportId != IMGUI_VIEWPORT_DEFAULT_ID)
        {
            dst_settings.ViewportPos = window_pos_2ih;
            dst_settings.ViewportId = src_window.ViewportId;
            dst_settings.Pos = ImVec2ih(0, 0);
        }
        else
        {
            dst_settings.Pos = window_pos_2ih;
        }
        len(dst_settings) = ImVec2ih(src_window.SizeFull);
        dst_settings.Collapsed = src_window.Collapsed;
    }
}

// FIXME: Will probably want to change this signature, in particular how the window remapping pairs are passed.
DockBuilderCopyDockSpace :: proc(src_dockspace_id : ImGuiID, dst_dockspace_id : ImGuiID, in_window_remap_pairs : ^[]^u8)
{
    g := GImGui;
    assert(src_dockspace_id != 0);
    assert(dst_dockspace_id != 0);
    assert(in_window_remap_pairs != nil);
    assert((len(in_window_remap_pairs) % 2) == 0);

    // Duplicate entire dock
    // FIXME: When overwriting dst_dockspace_id, windows that aren't part of our dockspace window class but that are docked in a same node will be split apart,
    // whereas we could attempt to at least keep them together in a new, same floating node.
    ImVector<ImGuiID> node_remap_pairs;
    DockBuilderCopyNode(src_dockspace_id, dst_dockspace_id, &node_remap_pairs);

    // Attempt to transition all the upcoming windows associated to dst_dockspace_id into the newly created hierarchy of dock nodes
    // (The windows associated to src_dockspace_id are staying in place)
    ImVector<ImGuiID> src_windows;
    for remap_window_n := 0; remap_window_n < len(in_window_remap_pairs); remap_window_n += 2
    {
        src_window_name := in_window_remap_pairs^[remap_window_n];
        dst_window_name := in_window_remap_pairs^[remap_window_n + 1];
        src_window_id := ImHashStr(src_window_name);
        src_windows.append(src_window_id);

        // Search in the remapping tables
        src_dock_id := 0;
        if src_window := FindWindowByID(src_window_id); src_window != nil {
            src_dock_id = src_window.DockId;
        }
        else if src_window_settings := FindWindowSettingsByID(src_window_id); src_window_settings != nil {
            src_dock_id = src_window_settings.DockId;
        }

        dst_dock_id := 0;
        for dock_remap_n := 0; dock_remap_n < len(node_remap_pairs); dock_remap_n += 2 {
            if (node_remap_pairs[dock_remap_n] == src_dock_id)
            {
                dst_dock_id = node_remap_pairs[dock_remap_n + 1];
                //node_remap_pairs[dock_remap_n] = node_remap_pairs[dock_remap_n + 1] = 0; // Clear
                break;
            }
        }

        if (dst_dock_id != 0)
        {
            // Docked windows gets redocked into the new node hierarchy.
            IMGUI_DEBUG_LOG_DOCKING(g, "[docking] Remap live window '%s' 0x%08X -> '%s' 0x%08X\n", src_window_name, src_dock_id, dst_window_name, dst_dock_id);
            DockBuilderDockWindow(dst_window_name, dst_dock_id);
        }
        else
        {
            // Floating windows gets their settings transferred (regardless of whether the new window already exist or not)
            // When this is leading to a Copy and not a Move, we would get two overlapping floating windows. Could we possibly dock them together?
            IMGUI_DEBUG_LOG_DOCKING(g, "[docking] Remap window settings '%s' -> '%s'\n", src_window_name, dst_window_name);
            DockBuilderCopyWindowSettings(src_window_name, dst_window_name);
        }
    }

    // Anything else in the source nodes of 'node_remap_pairs' are windows that are not included in the remapping list.
    // Find those windows and move to them to the cloned dock node. This may be optional?
    // Dock those are a second step as undocking would invalidate source dock nodes.
    DockRemainingWindowTask :: struct { Window: ^ImGuiWindow, DockId : ImGuiID, };
    dock_remaining_windows : [dynamic]DockRemainingWindowTask;
    for dock_remap_n := 0; dock_remap_n < len(node_remap_pairs); dock_remap_n += 2 {
        if src_dock_id := node_remap_pairs[dock_remap_n]; src_dock_id != {}
        {
            dst_dock_id := node_remap_pairs[dock_remap_n + 1];
            node := DockBuilderGetNode(src_dock_id);
            for window_n := 0; window_n < len(node.Windows); window_n += 1
            {
                window := node.Windows[window_n];
                if (src_windows.contains(window.ID))   do continue

                // Docked windows gets redocked into the new node hierarchy.
                IMGUI_DEBUG_LOG_DOCKING(g, "[docking] Remap window '%s' %08X -> %08X\n", window.Name, src_dock_id, dst_dock_id);
                dock_remaining_windows.append(DockRemainingWindowTask(window, dst_dock_id));
            }
        }
    }
    for task in dock_remaining_windows {
        DockBuilderDockWindow(task.Window.Name, task.DockId);
    }
}

// FIXME-DOCK: This is awkward because in series of split user is likely to loose access to its root node.
DockBuilderFinish :: proc(root_id : ImGuiID)
{
    g := GImGui;
    //DockContextRebuild(&g);
    DockContextBuildAddWindowsToNodes(g, root_id);
}

//-----------------------------------------------------------------------------
// Docking: Begin/End Support Functions (called from Begin/End)
//-----------------------------------------------------------------------------
// - GetWindowAlwaysWantOwnTabBar()
// - DockContextBindNodeToWindow()
// - BeginDocked()
// - BeginDockableDragDropSource()
// - BeginDockableDragDropTarget()
//-----------------------------------------------------------------------------

GetWindowAlwaysWantOwnTabBar :: proc(window : ^ImGuiWindow) -> bool
{
    g := GImGui;
    if (g.IO.ConfigDockingAlwaysTabBar || window.WindowClass.DockingAlwaysTabBar) {
        if ((window.Flags & (ImGuiWindowFlags_ChildWindow | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoDocking)) == 0) {
            if (!window.IsFallbackWindow) {// We don't support AlwaysTabBar on the fallback/implicit window to avoid unused dock-node overhead/noise
                return true;
            }
        }
    }

    return false;
}

DockContextBindNodeToWindow :: proc(ctx : ^ImGuiContext, window : ^ImGuiWindow) -> ^ImGuiDockNode
{
    g := ctx;
    node := DockContextFindNodeByID(ctx, window.DockId);
    assert(window.DockNode == nil);

    // We should not be docking into a split node (SetWindowDock should avoid this)
    if (node && node.IsSplitNode())
    {
        DockContextProcessUndockWindow(ctx, window);
        return nil;
    }

    // Create node
    if (node == nil)
    {
        node = DockContextAddNode(ctx, window.DockId);
        node.AuthorityForViewport = ImGuiDataAuthority_Window;
        node.AuthorityForSize = ImGuiDataAuthority_Window
        node.AuthorityForPos = ImGuiDataAuthority_Window
        node.LastFrameAlive = g.FrameCount;
    }

    // If the node just turned visible and is part of a hierarchy, it doesn't have a Size assigned by DockNodeTreeUpdatePosSize() yet,
    // so we're forcing a Pos/Size update from the first ancestor that is already visible (often it will be the root node).
    // If we don't do this, the window will be assigned a zero-size on its first frame, which won't ideally warm up the layout.
    // This is a little wonky because we don't normally update the Pos/Size of visible node mid-frame.
    if (!node.IsVisible)
    {
        ancestor_node := node;
        for (!ancestor_node.IsVisible && ancestor_node.ParentNode) {
            ancestor_node = ancestor_node.ParentNode;
        }
        assert(ancestor_node.Size.x > 0.0 && ancestor_node.Size.y > 0.0);
        DockNodeUpdateHasCentralNodeChild(DockNodeGetRootNode(ancestor_node));
        DockNodeTreeUpdatePosSize(ancestor_node, ancestor_node.Pos, ancestor_node.Size, node);
    }

    // Add window to node
    node_was_visible := node.IsVisible;
    DockNodeAddWindow(node, window, true);
    node.IsVisible = node_was_visible; // Don't mark visible right away (so DockContextEndFrame() doesn't render it, maybe other side effects? will see)
    assert(node == window.DockNode);
    return node;
}

StoreDockStyleForWindow :: proc(window : ^ImGuiWindow)
{
    g := GImGui;
    for color_n := 0; color_n < ImGuiWindowDockStyleCol_COUNT; color_n += 1 {
        window.DockStyle.Colors[color_n] = ColorConvertFloat4ToU32(g.Style.Colors[GWindowDockStyleColors[color_n]]);
    }
}

BeginDocked :: proc(window : ^ImGuiWindow, p_open : ^bool)
{
    g := GImGui;

    // Clear fields ahead so most early-out paths don't have to do it
    window.DockTabIsVisible = false;
    window.DockNodeIsVisible = false
    window.DockIsActive = false

    auto_dock_node := GetWindowAlwaysWantOwnTabBar(window);
    if (auto_dock_node)
    {
        if (window.DockId == 0)
        {
            assert(window.DockNode == nil);
            window.DockId = DockContextGenNodeID(&g);
        }
    }
    else
    {
        // Calling SetNextWindowPos() undock windows by default (by setting PosUndock)
        want_undock := false;
        want_undock |= (.NoDocking in window.Flags) != 0;
        want_undock |= (.HasPos in g.NextWindowData.Flags) && (window.SetWindowPosAllowFlags & g.NextWindowData.PosCond) && g.NextWindowData.PosUndock;
        if (want_undock)
        {
            DockContextProcessUndockWindow(g, window);
            return;
        }
    }

    // Bind to our dock node
    node := window.DockNode;
    if (node != nil) {
        assert(window.DockId == node.ID);
    }

    if (window.DockId != 0 && node == nil)
    {
        node = DockContextBindNodeToWindow(g, window);
        if (node == nil)   do return
    }

when false {
    // Undock if the ImGuiDockNodeFlags_NoDockingInCentralNode got set
    if (node.IsCentralNode && (.NoDockingInCentralNode in node.Flags))
    {
        DockContextProcessUndockWindow(ctx, window);
        return;
    }
}

    // Undock if our dockspace node disappeared
    // Note how we are testing for LastFrameAlive and NOT LastFrameActive. A DockSpace node can be maintained alive while being inactive with ImGuiDockNodeFlags_KeepAliveOnly.
    if (node.LastFrameAlive < g.FrameCount)
    {
        // If the window has been orphaned, transition the docknode to an implicit node processed in DockContextNewFrameUpdateDocking()
        root_node := DockNodeGetRootNode(node);
        if (root_node.LastFrameAlive < g.FrameCount) {
            DockContextProcessUndockWindow(g, window);
        }
        else {
            window.DockIsActive = true;
        }
        return;
    }

    // Store style overrides
    StoreDockStyleForWindow(window);

    // Fast path return. It is common for windows to hold on a persistent DockId but be the only visible window,
    // and never create neither a host window neither a tab bar.
    // FIXME-DOCK: replace ->HostWindow NULL compare with something more explicit (~was initially intended as a first frame test)
    if (node.HostWindow == nil)
    {
        if (node.State == ImGuiDockNodeState_HostWindowHiddenBecauseWindowsAreResizing) {
            window.DockIsActive = true;
        }

        if (len(node.Windows) > 1 && window.Appearing) {// Only hide appearing window
            DockNodeHideWindowDuringHostWindowCreation(window);
        }

        return;
    }

    // We can have zero-sized nodes (e.g. children of a small-size dockspace)
    assert(node.HostWindow);
    assert(node.IsLeafNode());
    assert(node.Size.x >= 0.0 && node.Size.y >= 0.0);
    node.State = ImGuiDockNodeState_HostWindowVisible;

    // Undock if we are submitted earlier than the host window
    if (!(.KeepAliveOnly in node.MergedFlags) && window.BeginOrderWithinContext < node.HostWindow.BeginOrderWithinContext)
    {
        DockContextProcessUndockWindow(g, window);
        return;
    }

    // Position/Size window
    SetNextWindowPos(node.Pos);
    SetNextWindowSize(node.Size);
    g.NextWindowData.PosUndock = false; // Cancel implicit undocking of SetNextWindowPos()
    window.DockIsActive = true;
    window.DockNodeIsVisible = true;
    window.DockTabIsVisible = false;
    if (.KeepAliveOnly in node.MergedFlags)   do return

    // When the window is selected we mark it as visible.
    if (node.VisibleWindow == window) {
        window.DockTabIsVisible = true;
    }

    // Update window flag
    assert((.ChildWindow not_in window.Flags));
    window.Flags |= ImGuiWindowFlags_ChildWindow | ImGuiWindowFlags_NoResize;
    window.ChildFlags |= ImGuiChildFlags_AlwaysUseWindowPadding;
    if (node.IsHiddenTabBar() || node.IsNoTabBar()) {
        window.Flags |= ImGuiWindowFlags_NoTitleBar;
    }
    else {
        window.Flags &= ~ImGuiWindowFlags_NoTitleBar;      // Clear the NoTitleBar flag in case the user set it: confusingly enough we need a title bar height so we are correctly offset, but it won't be displayed!
    }

    // Save new dock order only if the window has been visible once already
    // This allows multiple windows to be created in the same frame and have their respective dock orders preserved.
    if (node.TabBar && window.WasActive) {
        window.DockOrder = cast(i16)DockNodeGetTabOrder(window);
    }

    if ((node.WantCloseAll || node.WantCloseTabId == window.TabId) && p_open != nil)   do p_open^ = false

    // Update ChildId to allow returning from Child to Parent with Escape
    parent_window := window.DockNode.HostWindow;
    window.ChildId = parent_window.GetID(window.Name);
}

BeginDockableDragDropSource :: proc(window : ^ImGuiWindow)
{
    g := GImGui;
    assert(g.ActiveId == window.MoveId);
    assert(g.MovingWindow == window);
    assert(g.CurrentWindow == window);

    // 0: Hold SHIFT to disable docking, 1: Hold SHIFT to enable docking.
    if (g.IO.ConfigDockingWithShift != g.IO.KeyShift)
    {
        // When ConfigDockingWithShift is set, display a tooltip to increase UI affordance.
        // We cannot set for HoveredWindowUnderMovingWindow != NULL here, as it is only valid/useful when drag and drop is already active
        // (because of the 'is_mouse_dragging_with_an_expected_destination' logic in UpdateViewportsNewFrame() function)
        assert(g.NextWindowData.Flags == 0);
        if (g.IO.ConfigDockingWithShift && g.MouseStationaryTimer >= 1.0 && g.ActiveId >= 1.0) {
            SetTooltip("%s", LocalizeGetMsg(ImGuiLocKey_DockingHoldShiftToDock));
        }

        return;
    }

    g.LastItemData.ID = window.MoveId;
    window = window.RootWindowDockTree;
    assert((.NoDocking not_in window.Flags));
    is_drag_docking := (g.IO.ConfigDockingWithShift) || ImRect(0, 0, window.SizeFull.x, GetFrameHeight()).Contains(g.ActiveIdClickOffset); // FIXME-DOCKING: Need to make this stateful and explicit
    drag_drop_flags := ImGuiDragDropFlags_SourceNoPreviewTooltip | ImGuiDragDropFlags_SourceNoHoldToOpenOthers | ImGuiDragDropFlags_PayloadAutoExpire | ImGuiDragDropFlags_PayloadNoCrossContext | ImGuiDragDropFlags_PayloadNoCrossProcess;
    if (is_drag_docking && BeginDragDropSource(drag_drop_flags))
    {
        SetDragDropPayload(IMGUI_PAYLOAD_TYPE_WINDOW, &window, size_of(window));
        EndDragDropSource();
        StoreDockStyleForWindow(window); // Store style overrides while dragging (even when not docked) because docking preview may need it.
    }
}

BeginDockableDragDropTarget :: proc(window : ^ImGuiWindow)
{
    g := GImGui;

    //assert(window.RootWindowDockTree == window); // May also be a DockSpace
    assert((.NoDocking not_in window.Flags));
    if (!g.DragDropActive)   do return
    //GetForegroundDrawList(window)->AddRect(window.Pos, window.Pos + window.Size, IM_COL32(255, 255, 0, 255));
    if (!BeginDragDropTargetCustom(Rect(window), window.ID))   do return

    // Peek into the payload before calling AcceptDragDropPayload() so we can handle overlapping dock nodes with filtering
    // (this is a little unusual pattern, normally most code would call AcceptDragDropPayload directly)
    payload := &g.DragDropPayload;
    if (!payload.IsDataType(IMGUI_PAYLOAD_TYPE_WINDOW) || !DockNodeIsDropAllowed(window, (cast(^^ImGuiWindow)payload.Data)^))
    {
        EndDragDropTarget();
        return;
    }

    payload_window := (cast(^^ImGuiWindow)payload.Data)^;
    if (AcceptDragDropPayload(IMGUI_PAYLOAD_TYPE_WINDOW, ImGuiDragDropFlags_AcceptBeforeDelivery | ImGuiDragDropFlags_AcceptNoDrawDefaultRect))
    {
        // Select target node
        // (Important: we cannot use g.HoveredDockNode here! Because each of our target node have filters based on payload, each candidate drop target will do its own evaluation)
        dock_into_floating_window := false;
        node := nil;
        if (window.DockNodeAsHost)
        {
            // Cannot assume that node will != NULL even though we passed the rectangle test: it depends on padding/spacing handled by DockNodeTreeFindVisibleNodeByPos().
            node = DockNodeTreeFindVisibleNodeByPos(window.DockNodeAsHost, g.IO.MousePos);

            // There is an edge case when docking into a dockspace which only has _inactive_ nodes (because none of the windows are active)
            // In this case we need to fallback into any leaf mode, possibly the central node.
            // FIXME-20181220: We should not have to test for IsLeafNode() here but we have another bug to fix first.
            if (node && node.IsDockSpace() && node.IsRootNode()) {
                node = (node.CentralNode && node.IsLeafNode()) ? node.CentralNode : DockNodeTreeFindFallbackLeafNode(node);
            }

        }
        else
        {
            if (window.DockNode != nil)   do node = window.DockNode
            else do dock_into_floating_window = true; // Dock into a regular window
        }

        explicit_target_rect := (node && node.TabBar && !node.IsHiddenTabBar() && !node.IsNoTabBar()) ? node.TabBar.BarRect : ImRect(window.Pos, window.Pos + ImVec2{window.Size.x, GetFrameHeight()});
        is_explicit_target := g.IO.ConfigDockingWithShift || IsMouseHoveringRect(explicit_target_rect.Min, explicit_target_rect.Max);

        // Preview docking request and find out split direction/ratio
        //const bool do_preview = true;     // Ignore testing for payload.IsPreview() which removes one frame of delay, but breaks overlapping drop targets within the same window.
        do_preview := payload.IsPreview() || payload.IsDelivery();
        if (do_preview && (node != nil || dock_into_floating_window))
        {
            // If we have a non-leaf node it means we are hovering the border of a parent node, in which case only outer markers will appear.
            split_inner : ImGuiDockPreviewData
            split_outer : ImGuiDockPreviewData
            split_data := &split_inner;
            if (node && (node.ParentNode || IsCentralNode(node) || !node.IsLeafNode())) {
                if root_node := DockNodeGetRootNode(node); root_node != nil
                {
                    DockNodePreviewDockSetup(window, root_node, payload_window, nil, &split_outer, is_explicit_target, true);
                    if (split_outer.IsSplitDirExplicit)   do split_data = &split_outer
                }
            }
            if (!node || node.IsLeafNode()) {
                DockNodePreviewDockSetup(window, node, payload_window, nil, &split_inner, is_explicit_target, false);
            }

            if (split_data == &split_outer) {
                split_inner.IsDropAllowed = false;
            }

            // Draw inner then outer, so that previewed tab (in inner data) will be behind the outer drop boxes
            DockNodePreviewDockRender(window, node, payload_window, &split_inner);
            DockNodePreviewDockRender(window, node, payload_window, &split_outer);

            // Queue docking request
            if (split_data.IsDropAllowed && payload.IsDelivery()) {
                DockContextQueueDock(g, window, split_data.SplitNode, payload_window, split_data.SplitDir, split_data.SplitRatio, split_data == &split_outer);
            }

        }
    }
    EndDragDropTarget();
}

//-----------------------------------------------------------------------------
// Docking: Settings
//-----------------------------------------------------------------------------
// - DockSettingsRenameNodeReferences()
// - DockSettingsRemoveNodeReferences()
// - DockSettingsFindNodeSettings()
// - DockSettingsHandler_ApplyAll()
// - DockSettingsHandler_ReadOpen()
// - DockSettingsHandler_ReadLine()
// - DockSettingsHandler_DockNodeToSettings()
// - DockSettingsHandler_WriteAll()
//-----------------------------------------------------------------------------

DockSettingsRenameNodeReferences :: proc(old_node_id : ImGuiID, new_node_id : ImGuiID)
{
    g := GImGui;
    IMGUI_DEBUG_LOG_DOCKING(g, "[docking] DockSettingsRenameNodeReferences: from 0x%08X -> to 0x%08X\n", old_node_id, new_node_id);
    for window_n := 0; window_n < len(g.Windows); window_n += 1
    {
        window := g.Windows[window_n];
        if (window.DockId == old_node_id && window.DockNode == nil) {
            window.DockId = new_node_id;
        }

    }
    //// FIXME-OPT: We could remove this loop by storing the index in the map
    for settings := begin(&g.SettingsWindows); settings != nil; settings = next_chunk(g.SettingsWindows, settings) {
        if (settings.DockId == old_node_id) {
            settings.DockId = new_node_id;
        }
    }

}

// Remove references stored in ImGuiWindowSettings to the given ImGuiDockNodeSettings
DockSettingsRemoveNodeReferences :: proc(node_ids : ^ImGuiID, node_ids_count : i32)
{
    g := GImGui;
    found := 0;
    //// FIXME-OPT: We could remove this loop by storing the index in the map
    for settings := begin(&g.SettingsWindows); settings != nil; settings = next_chunk(&g.SettingsWindows, settings) {
        for node_n := 0; node_n < node_ids_count; node_n += 1 {
            if (settings.DockId == node_ids[node_n])
            {
                settings.DockId = 0;
                settings.DockOrder = -1;
                found += 1
                if (found < node_ids_count)   do break
                return;
            }
        }
    }
}

DockSettingsFindNodeSettings :: proc(ctx : ^ImGuiContext, id : ImGuiID) -> ^ImGuiDockNodeSettings
{
    // FIXME-OPT
    dc := &ctx.DockContext;
    for n := 0; n < len(dc.NodesSettings); n += 1 {
        if (dc.NodesSettings[n].ID == id)   do return &dc.NodesSettings[n]
    }
    return nil;
}

// Clear settings data
DockSettingsHandler_ClearAll :: proc(ctx : ^ImGuiContext,  _ : ^ImGuiSettingsHandler)
{
    dc := &ctx.DockContext;
    dc.NodesSettings.clear();
    DockContextClearNodes(ctx, 0, true);
}

// Recreate nodes based on settings data
DockSettingsHandler_ApplyAll :: proc(ctx : ^ImGuiContext, _ : ^ImGuiSettingsHandler)
{
    // Prune settings at boot time only
    dc := &ctx.DockContext;
    if (len(ctx.Windows) == 0) {
        DockContextPruneUnusedSettingsNodes(ctx);
    }

    DockContextBuildNodesFromSettings(ctx, dc.NodesSettings.Data, dc.NodesSettings.Size);
    DockContextBuildAddWindowsToNodes(ctx, 0);
}

DockSettingsHandler_ReadOpen :: proc(_ : ^ImGuiContext, _ : ^ImGuiSettingsHandler, name : ^u8) -> rawptr
{
    if (strcmp(name, "Data") != 0)   do return nil
    return cast(rawptr) 1;
}

DockSettingsHandler_ReadLine :: proc(ctx : ^ImGuiContext, _ : ^ImGuiSettingsHandler, _ : rawptr, line : ^u8)
{
    c := 0;
    x := 0; y := 0;
    r := 0;

    // Parsing, e.g.
    // " DockNode   ID=0x00000001 Pos=383,193 Size=201,322 Split=Y,0.506 "
    // "   DockNode ID=0x00000002 Parent=0x00000001 "
    // Important: this code expect currently fields in a fixed order.
    node : ImGuiDockNodeSettings
    line = ImStrSkipBlank(line);
    if      (strncmp(line, "DockNode", 8) == 0)  { line = ImStrSkipBlank(line + strlen("DockNode")); }
    else if (strncmp(line, "DockSpace", 9) == 0) { line = ImStrSkipBlank(line + strlen("DockSpace")); node.Flags |= ImGuiDockNodeFlags_DockSpace; }
    else do return
    if (sscanf(line, "ID=0x%08X%n",      &node.ID, &r) == 1)            { line += r; } else do return;
    if (sscanf(line, " Parent=0x%08X%n", &node.ParentNodeId, &r) == 1)  { line += r; if (node.ParentNodeId == 0) do return; }
    if (sscanf(line, " Window=0x%08X%n", &node.ParentWindowId, &r) ==1) { line += r; if (node.ParentWindowId == 0) do return; }
    if (node.ParentNodeId == 0)
    {
        if (sscanf(line, " Pos=%i,%i%n",  &x, &y, &r) == 2)         { line += r; node.Pos = ImVec2ih(cast(i16)x, cast(i16)y); } else do return;
        if (sscanf(line, " Size=%i,%i%n", &x, &y, &r) == 2)         { line += r; len(node) = ImVec2ih(cast(i16)x, cast(i16)y); } else do return;
    }
    else
    {
        if (sscanf(line, " SizeRef=%i,%i%n", &x, &y, &r) == 2)      { line += r; node.SizeRef = ImVec2ih(cast(i16)x, cast(i16)y); }
    }
    if (sscanf(line, " Split=%c%n", &c, &r) == 1)                   { line += r; if (c == 'X') do node.SplitAxis = ImGuiAxis.X; else do if (c == 'Y') do node.SplitAxis = ImGuiAxis.Y; }
    if (sscanf(line, " NoResize=%d%n", &x, &r) == 1)                { line += r; if (x != 0) do node.Flags |= ImGuiDockNodeFlags_NoResize; }
    if (sscanf(line, " CentralNode=%d%n", &x, &r) == 1)             { line += r; if (x != 0) do node.Flags |= ImGuiDockNodeFlags_CentralNode; }
    if (sscanf(line, " NoTabBar=%d%n", &x, &r) == 1)                { line += r; if (x != 0) do node.Flags |= ImGuiDockNodeFlags_NoTabBar; }
    if (sscanf(line, " HiddenTabBar=%d%n", &x, &r) == 1)            { line += r; if (x != 0) do node.Flags |= ImGuiDockNodeFlags_HiddenTabBar; }
    if (sscanf(line, " NoWindowMenuButton=%d%n", &x, &r) == 1)      { line += r; if (x != 0) do node.Flags |= ImGuiDockNodeFlags_NoWindowMenuButton; }
    if (sscanf(line, " NoCloseButton=%d%n", &x, &r) == 1)           { line += r; if (x != 0) do node.Flags |= ImGuiDockNodeFlags_NoCloseButton; }
    if (sscanf(line, " Selected=0x%08X%n", &node.SelectedTabId,&r) == 1) { line += r; }
    if (node.ParentNodeId != 0) {
        if parent_settings := DockSettingsFindNodeSettings(ctx, node.ParentNodeId); parent_settings != nil {
            node.Depth = parent_settings.Depth + 1;
        }
    }

    ctx.DockContext.NodesSettings.append(node);
}

DockSettingsHandler_DockNodeToSettings :: proc(dc : ^ImGuiDockContext, node : ^ImGuiDockNode, depth : i32)
{
    node_settings : ImGuiDockNodeSettings
    assert(depth < (1 << (size_of(node_settings.Depth) << 3)));
    node_settings.ID = node.ID;
    node_settings.ParentNodeId = node.ParentNode ? node.ParentNode.ID : 0;
    node_settings.ParentWindowId = (node.IsDockSpace() && node.HostWindow && node.HostWindow.ParentWindow) ? node.HostWindow.ParentWindow.ID : 0;
    node_settings.SelectedTabId = node.SelectedTabId;
    node_settings.SplitAxis = (i8)(node.IsSplitNode() ? node.SplitAxis : ImGuiAxis_None);
    node_settings.Depth = cast(u8) depth;
    node_settings.Flags = (node.LocalFlags & transmute(ImGuiDockNodeFlags) ImGuiDockNodeFlagsPrivate.SavedFlagsMask_);
    node_settings.Pos = ImVec2ih(node.Pos);
    len(node_settings) = ImVec2ih(node.Size);
    node_settings.SizeRef = ImVec2ih(node.SizeRef);
    dc.NodesSettings.append(node_settings);
    if (node.ChildNodes[0]) {
        DockSettingsHandler_DockNodeToSettings(dc, node.ChildNodes[0], depth + 1);
    }

    if (node.ChildNodes[1]) {
        DockSettingsHandler_DockNodeToSettings(dc, node.ChildNodes[1], depth + 1);
    }

}

DockSettingsHandler_WriteAll :: proc(ctx : ^ImGuiContext, handler : ^ImGuiSettingsHandler, buf : ^ImGuiTextBuffer)
{
    g := ctx;
    dc := &ctx.DockContext;
    if (!(.DockingEnable in g.IO.ConfigFlags))   do return

    // Gather settings data
    // (unlike our windows settings, because nodes are always built we can do a full rewrite of the SettingsNode buffer)
    dc.NodesSettings.resize(0);
    dc.NodesSettings.reserve(dc.Nodes.Data.Size);
    for n := 0; n < len(dc.Nodes.Data); n += 1 {
        if node := cast(^ImGuiDockNode)dc.Nodes.Data[n].val_p; node != nil {
            if (node.IsRootNode()) {
                DockSettingsHandler_DockNodeToSettings(dc, node, 0);
            }
        }
    }

    max_depth := 0;
    for node_n := 0; node_n < len(dc.NodesSettings); node_n += 1 {
        max_depth = ImMax(cast(i32) dc.NodesSettings[node_n].Depth, max_depth);
    }

    // Write to text buffer
    buf.appendf("[%s][Data]\n", handler.TypeName);
    for node_n := 0; node_n < len(dc.NodesSettings); node_n += 1
    {
        line_start_pos := buf.size();
        _ := line_start_pos;
        node_settings := &dc.NodesSettings[node_n];
        buf.appendf("%*s%s%*s", node_settings.Depth * 2, "", (.DockSpace in node_settings.Flags) ? "DockSpace" : "DockNode ", (max_depth - node_settings.Depth) * 2, "");  // Text align nodes to facilitate looking at .ini file
        buf.appendf(" ID=0x%08X", node_settings.ID);
        if (node_settings.ParentNodeId)
        {
            buf.appendf(" Parent=0x%08X SizeRef=%d,%d", node_settings.ParentNodeId, node_settings.SizeRef.x, node_settings.SizeRef.y);
        }
        else
        {
            if (node_settings.ParentWindowId) {
                buf.appendf(" Window=0x%08X", node_settings.ParentWindowId);
            }

            buf.appendf(" Pos=%d,%d Size=%d,%d", node_settings.Pos.x, node_settings.Pos.y, node_settings.Size.x, node_settings.Size.y);
        }
        if (node_settings.SplitAxis != ImGuiAxis_None) {
            buf.appendf(" Split=%c", (node_settings.SplitAxis == ImGuiAxis.X) ? 'X' : 'Y');
        }

        if (.NoResize in node_settings.Flags) {
            buf.appendf(" NoResize=1");
        }

        if (.CentralNode in node_settings.Flags) {
            buf.appendf(" CentralNode=1");
        }

        if (.NoTabBar in node_settings.Flags) {
            buf.appendf(" NoTabBar=1");
        }

        if (.HiddenTabBar in node_settings.Flags) {
            buf.appendf(" HiddenTabBar=1");
        }

        if (.NoWindowMenuButton in node_settings.Flags) {
            buf.appendf(" NoWindowMenuButton=1");
        }

        if (.NoCloseButton in node_settings.Flags) {
            buf.appendf(" NoCloseButton=1");
        }

        if (node_settings.SelectedTabId) {
            buf.appendf(" Selected=0x%08X", node_settings.SelectedTabId);
        }

        // [DEBUG] Include comments in the .ini file to ease debugging (this makes saving slower!)
        if (g.IO.ConfigDebugIniSettings) {
            if node := DockContextFindNodeByID(ctx, node_settings.ID); node != nil
            {
                buf.appendf("%*s", ImMax(2, (line_start_pos + 92) - buf.size()), "");     // Align everything
                if (node.IsDockSpace() && node.HostWindow && node.HostWindow.ParentWindow) {
                    buf.appendf(" ; in '%s'", node.HostWindow.ParentWindow.Name);
                }

                // Iterate settings so we can give info about windows that didn't exist during the session.
                contains_window := 0;
                for settings := begin(&g.SettingsWindows); settings != nil; settings = next_chunk(&g.SettingsWindows, settings) {
                    if (settings.DockId == node_settings.ID)
                    {
                        if (contains_window == 0) {
                            buf.appendf(" ; contains ");
                        }
                        contains_window += 1

                        buf.appendf("'%s' ", settings.GetName());
                    }
                }
            }
        }

        buf.appendf("\n");
    }
    buf.appendf("\n");
}


//-----------------------------------------------------------------------------
// [SECTION] METRICS/DEBUGGER WINDOW
//-----------------------------------------------------------------------------
// - DebugRenderViewportThumbnail() [Internal]
// - RenderViewportsThumbnails() [Internal]
// - DebugTextEncoding()
// - MetricsHelpMarker() [Internal]
// - ShowFontAtlas() [Internal]
// - ShowMetricsWindow()
// - DebugNodeColumns() [Internal]
// - DebugNodeDockNode() [Internal]
// - DebugNodeDrawList() [Internal]
// - DebugNodeDrawCmdShowMeshAndBoundingBox() [Internal]
// - DebugNodeFont() [Internal]
// - DebugNodeFontGlyph() [Internal]
// - DebugNodeStorage() [Internal]
// - DebugNodeTabBar() [Internal]
// - DebugNodeViewport() [Internal]
// - DebugNodeWindow() [Internal]
// - DebugNodeWindowSettings() [Internal]
// - DebugNodeWindowsList() [Internal]
// - DebugNodeWindowsListByBeginStackParent() [Internal]
//-----------------------------------------------------------------------------

when !(IMGUI_DISABLE_DEBUG_TOOLS) {

DebugRenderViewportThumbnail :: proc(draw_list : ^ImDrawList, viewport : ^ImGuiViewportP, bb : ^ImRect)
{
    g := GImGui;
    window := g.CurrentWindow;

    scale := bb.GetSize() / len(viewport);
    off := bb.Min - viewport.Pos * scale;
    alpha_mul := (.IsMinimized in viewport.Flags) ? 0.30 : 1.00;
    AddRectFilled(window.DrawList, bb.Min, bb.Max, GetColorU32(ImGuiCol.Border, alpha_mul * 0.40));
    for thumb_window in g.Windows
    {
        if (!thumb_window.WasActive || (.ChildWindow in thumb_window.Flags))   do continue
        if (thumb_window.Viewport != viewport)   do continue

        thumb_r := thumb_Rect(window);
        title_r := thumb_TitleBarRect(window);
        thumb_r = ImRect(ImTrunc(off + thumb_r.Min * scale), ImTrunc(off +  thumb_r.Max * scale));
        title_r = ImRect(ImTrunc(off + title_r.Min * scale), ImTrunc(off +  ImVec2{title_r.Max.x, title_r.Min.y + title_r.GetHeight() * 3.0} * scale)); // Exaggerate title bar height
        thumb_r.ClipWithFull(bb);
        title_r.ClipWithFull(bb);
        window_is_focused := (g.NavWindow && thumb_window.RootWindowForTitleBarHighlight == g.NavWindow.RootWindowForTitleBarHighlight);
        AddRectFilled(window.DrawList, thumb_r.Min, thumb_r.Max, GetColorU32(ImGuiCol.WindowBg, alpha_mul));
        AddRectFilled(window.DrawList, title_r.Min, title_r.Max, GetColorU32(window_is_focused ? ImGuiCol.TitleBgActive : ImGuiCol.TitleBg, alpha_mul));
        window.DrawList.AddRect(thumb_r.Min, thumb_r.Max, GetColorU32(ImGuiCol.Border, alpha_mul));
        window.DrawList.AddText(g.Font, g.FontSize * 1.0, title_r.Min, GetColorU32(ImGuiCol.Text, alpha_mul), thumb_window.Name, FindRenderedText(thumb_window.Name));
    }
    draw_list.AddRect(bb.Min, bb.Max, GetColorU32(ImGuiCol.Border, alpha_mul));
    if (viewport.ID == g.DebugMetricsConfig.HighlightViewportID) {
        window.DrawList.AddRect(bb.Min, bb.Max, IM_COL32(255, 255, 0, 255));
    }

}

RenderViewportsThumbnails :: proc()
{
    g := GImGui;
    window := g.CurrentWindow;

    // Draw monitor and calculate their boundaries
    SCALE := 1.0 / 8.0;
    bb_full := ImRect{ _r = {math.F32_MAX, math.F32_MAX, -math.F32_MAX, -math.F32_MAX}};
    for &monitor in g.PlatformIO.Monitors {
        bb_full.Add(ImRect{ _v = {monitor.MainPos, monitor.MainPos + monitor.MainSize}});
    }
    p := window.DC.CursorPos;
    off := p - bb_full.Min * SCALE;
    for &monitor in g.PlatformIO.Monitors
    {
        monitor_draw_bb := ImRect(off + (monitor.MainPos) * SCALE, off + (monitor.MainPos + monitor.MainSize) * SCALE);
        window.DrawList.AddRect(monitor_draw_bb.Min, monitor_draw_bb.Max, (g.DebugMetricsConfig.HighlightMonitorIdx == g.PlatformIO.Monitors.index_from_ptr(&monitor)) ? IM_COL32(255, 255, 0, 255) : GetColorU32(ImGuiCol.Border), 4.0);
        AddRectFilled(window.DrawList, monitor_draw_bb.Min, monitor_draw_bb.Max, GetColorU32(ImGuiCol.Border, 0.10), 4.0);
    }

    // Draw viewports
    for viewport in g.Viewports
    {
        viewport_draw_bb := ImRect(off + (viewport.Pos) * SCALE, off + (viewport.Pos + viewport.Size) * SCALE);
        DebugRenderViewportThumbnail(window.DrawList, viewport, viewport_draw_bb);
    }
    Dummy(bb_full.GetSize() * SCALE);
}

ViewportComparerByLastFocusedStampCount :: proc(lhs, rhs : rawptr) -> i32
{
    a := (cast(^^ImGuiViewportP)lhs)^;
    b := (cast(^^ImGuiViewportP)rhs)^;
    return b.LastFocusedStampCount - a.LastFocusedStampCount;
}

// Draw an arbitrary US keyboard layout to visualize translated keys
DebugRenderKeyboardPreview :: proc(draw_list : ^ImDrawList)
{
    scale := GetFontSize() / 13.0;
    key_size := ImVec2{35.0, 35.0} * scale;
    key_rounding := 3.0 * scale;
    key_face_size := ImVec2{25.0, 25.0} * scale;
    key_face_pos := ImVec2{5.0, 3.0} * scale;
    key_face_rounding := 2.0 * scale;
    key_label_pos := ImVec2{7.0, 4.0} * scale;
    key_step := ImVec2{key_size.x - 1.0, key_size.y - 1.0};
    key_row_offset := 9.0 * scale;

    board_min := GetCursorScreenPos();
    board_max := ImVec2{board_min.x + 3 * key_step.x + 2 * key_row_offset + 10.0, board_min.y + 3 * key_step.y + 10.0};
    start_pos := ImVec2{board_min.x + 5.0 - key_step.x, board_min.y};

    KeyLayoutData :: struct { Row, Col : i32, label : string, Key : ImGuiKey, };
    keys_to_display := [?]KeyLayoutData {
        { 0, 0, "", ImGuiKey.Tab },      { 0, 1, "Q", ImGuiKey.Q }, { 0, 2, "W", ImGuiKey.W }, { 0, 3, "E", ImGuiKey.E }, { 0, 4, "R", ImGuiKey.R },
        { 1, 0, "", ImGuiKey.CapsLock }, { 1, 1, "A", ImGuiKey.A }, { 1, 2, "S", ImGuiKey.S }, { 1, 3, "D", ImGuiKey.D }, { 1, 4, "F", ImGuiKey.F },
        { 2, 0, "", ImGuiKey.LeftShift },{ 2, 1, "Z", ImGuiKey.Z }, { 2, 2, "X", ImGuiKey.X }, { 2, 3, "C", ImGuiKey.C }, { 2, 4, "V", ImGuiKey.V }
    };

    // Elements rendered manually via ImDrawList API are not clipped automatically.
    // While not strictly necessary, here IsItemVisible() is used to avoid rendering these shapes when they are out of view.
    Dummy(board_max - board_min);
    if (!IsItemVisible())   do return
    draw_list.PushClipRect(board_min, board_max, true);
    for n := 0; n < len(keys_to_display); n += 1
    {
        key_data := &keys_to_display[n];
        key_min := ImVec2{start_pos.x + key_data.Col * key_step.x + key_data.Row * key_row_offset, start_pos.y + key_data.Row * key_step.y};
        key_max := key_min + key_size;
        AddRectFilled(draw_list, key_min, key_max, IM_COL32(204, 204, 204, 255), key_rounding);
        draw_list.AddRect(key_min, key_max, IM_COL32(24, 24, 24, 255), key_rounding);
        face_min := ImVec2{key_min.x + key_face_pos.x, key_min.y + key_face_pos.y};
        face_max := ImVec2{face_min.x + key_face_size.x, face_min.y + key_face_size.y};
        draw_list.AddRect(face_min, face_max, IM_COL32(193, 193, 193, 255), key_face_rounding, ImDrawFlags_None, 2.0);
        AddRectFilled(draw_list, face_min, face_max, IM_COL32(252, 252, 252, 255), key_face_rounding);
        label_min := ImVec2{key_min.x + key_label_pos.x, key_min.y + key_label_pos.y};
        draw_list.AddText(label_min, IM_COL32(64, 64, 64, 255), key_data.Label);
        if (IsKeyDown(key_data.Key)) {
            AddRectFilled(draw_list, key_min, key_max, IM_COL32(255, 0, 0, 128), key_rounding);
        }

    }
    draw_list.PopClipRect();
}

// Helper tool to diagnose between text encoding issues and font loading issues. Pass your UTF-8 string and verify that there are correct.
DebugTextEncoding :: proc(str : [^]u8)
{
    Text("Text: \"%s\"", str);
    if (!BeginTable("##DebugTextEncoding", 4, ImGuiTableFlags_Borders | ImGuiTableFlags_RowBg | ImGuiTableFlags_SizingFixedFit | ImGuiTableFlags_Resizable))   do return
    TableSetupColumn("Offset");
    TableSetupColumn("UTF-8");
    TableSetupColumn("Glyph");
    TableSetupColumn("Codepoint");
    TableHeadersRow();
    for p := str; p[0] != 0; 
    {
        c : u32
        c_utf8_len := ImTextCharFromUtf8(&c, p, nil);
        TableNextColumn();
        Text("%d", (i32)(mem.ptr_sub(p, str)));
        TableNextColumn();
        for byte_index : i32 = 0; byte_index < c_utf8_len; byte_index += 1
        {
            if (byte_index > 0)   do SameLine()
            Text("0x%02X", cast(i32)cast(u8) p[byte_index]);
        }
        TableNextColumn();
        if (FindGlyphNoFallback(GetFont(), cast(ImWchar)c)) {
            TextUnformatted(p, p + c_utf8_len);
        }
        else {
            TextUnformatted((c == IM_UNICODE_CODEPOINT_INVALID) ? "[invalid]" : "[missing]");
        }
        TableNextColumn();
        Text("U+%04X", cast(i32) c);
        p = p[c_utf8_len:];
    }
    EndTable();
}

DebugFlashStyleColorStop :: proc()
{
    g := GImGui;
    if (g.DebugFlashStyleColorIdx != ImGuiCol.COUNT) {
        g.Style.Colors[g.DebugFlashStyleColorIdx] = g.DebugFlashStyleColorBackup;
    }

    g.DebugFlashStyleColorIdx = ImGuiCol.COUNT;
}

// Flash a given style color for some + inhibit modifications of this color via PushStyleColor() calls.
DebugFlashStyleColor :: proc(idx : ImGuiCol)
{
    g := GImGui;
    DebugFlashStyleColorStop();
    g.DebugFlashStyleColorTime = 0.5;
    g.DebugFlashStyleColorIdx = idx;
    g.DebugFlashStyleColorBackup = g.Style.Colors[idx];
}

UpdateDebugToolFlashStyleColor :: proc()
{
    g := GImGui;
    if (g.DebugFlashStyleColorTime <= 0.0)   do return
    ColorConvertHSVtoRGB(math.cos(g.DebugFlashStyleColorTime * 6.0) * 0.5 + 0.5, 0.5, 0.5, g.Style.Colors[g.DebugFlashStyleColorIdx].x, g.Style.Colors[g.DebugFlashStyleColorIdx].y, g.Style.Colors[g.DebugFlashStyleColorIdx].z);
    g.Style.Colors[g.DebugFlashStyleColorIdx].w = 1.0;
    DebugFlashStyleColorTime -= g.IO.DeltaTime
    if (gDebugFlashStyleColorTime <= 0.0) {
        DebugFlashStyleColorStop();
    }

}

FormatTextureIDForDebugDisplay :: proc(buf : [^]u8, buf_size : i32, tex_id : ImTextureID) -> [^]u8
{
    tex_id_opaque : struct #raw_union { ptr : rawptr, integer : i32, };

    memcpy(&tex_id_opaque, &tex_id, ImMin(size_of(rawptr), size_of(tex_id)));
    if (size_of(tex_id) >= size_of(rawptr)) {
        ImFormatString(buf, buf_size, "0x%p", tex_id_opaque.ptr);
    }
    else {
        ImFormatString(buf, buf_size, "0x%04X", tex_id_opaque.integer);
    }
    return buf;
}

// Avoid naming collision with imgui_demo.cpp's HelpMarker() for unity builds.
MetricsHelpMarker :: proc(desc : string)
{
    TextDisabled("(?)");
    if (BeginItemTooltip())
    {
        PushTextWrapPos(GetFontSize() * 35.0);
        TextUnformatted(desc);
        PopTextWrapPos();
        EndTooltip();
    }
}

// [DEBUG] List fonts in a font atlas and display its texture
ShowFontAtlas :: proc(atlas : ^ImFontAtlas)
{
    for font in atlas.Fonts
    {
        PushID(font);
        DebugNodeFont(font);
        PopID();
    }
    if (TreeNode("Font Atlas", "Font Atlas (%dx%d pixels)", atlas.TexWidth, atlas.TexHeight))
    {
        g := GImGui;
        cfg := &g.DebugMetricsConfig;
        Checkbox("Tint with Text Color", &cfg.ShowAtlasTintedWithTextColor); // Using text color ensure visibility of core atlas data, but will alter custom colored icons
        tint_col := cfg.ShowAtlasTintedWithTextColor ? GetStyleColorVec4(ImGuiCol.Text) : ImVec4{1.0, 1.0, 1.0, 1.0};
        border_col := GetStyleColorVec4(ImGuiCol.Border);
        Image(atlas.TexID, ImVec2{cast(f32)atlas.TexWidth, cast(f32) atlas.TexHeight}, ImVec2{0.0, 0.0}, ImVec2{1.0, 1.0}, tint_col, border_col);
        TreePop();
    }
}

// [forward declared comment]:
// create Metrics/Debugger window. display Dear ImGui internals: windows, draw commands, various internal state, etc.
ShowMetricsWindow :: proc(p_open : ^bool = nil)
{
    g := GImGui;
    io := &g.IO;
    cfg := &g.DebugMetricsConfig;
    if (cfg.ShowDebugLog) {
        ShowDebugLogWindow(&cfg.ShowDebugLog);
    }

    if (cfg.ShowIDStackTool) {
        ShowIDStackToolWindow(&cfg.ShowIDStackTool);
    }

    if (!Begin("Dear ImGui Metrics/Debugger", p_open) || GetCurrentWindow()->BeginCount > 1)
    {
        End();
        return;
    }

    // [DEBUG] Clear debug breaks hooks after exactly one cycle.
    DebugBreakClearData();

    // Basic info
    Text("Dear ImGui %s (%d)", IMGUI_VERSION, IMGUI_VERSION_NUM);
    if (g.ContextName[0] != 0)
    {
        SameLine();
        Text("(Context Name: \"%s\")", g.ContextName);
    }
    Text("Application average %.3 ms/frame (%.1 FPS)", 1000.0 / io.Framerate, io.Framerate);
    Text("%d vertices, %d indices (%d triangles)", io.MetricsRenderVertices, io.MetricsRenderIndices, io.MetricsRenderIndices / 3);
    Text("%d visible windows, %d current allocations", io.MetricsRenderWindows, g.DebugAllocInfo.TotalAllocCount - g.DebugAllocInfo.TotalFreeCount);
    //SameLine(); if (SmallButton("GC")) { g.GcCompactAll = true; }

    Separator();

    // Debugging enums
    WRT :: enum { WRT_OuterRect, WRT_OuterRectClipped, WRT_InnerRect, WRT_InnerClipRect, WRT_WorkRect, WRT_Content, WRT_ContentIdeal, WRT_ContentRegionRect, WRT_Count }; // Windows Rect Type
    wrt_rects_names := [WRT_Count]string { "OuterRect", "OuterRectClipped", "InnerRect", "InnerClipRect", "WorkRect", "Content", "ContentIdeal", "ContentRegionRect" };
    TRT :: enum { TRT_OuterRect, TRT_InnerRect, TRT_WorkRect, TRT_HostClipRect, TRT_InnerClipRect, TRT_BackgroundClipRect, TRT_ColumnsRect, TRT_ColumnsWorkRect, TRT_ColumnsClipRect, TRT_ColumnsContentHeadersUsed, TRT_ColumnsContentHeadersIdeal, TRT_ColumnsContentFrozen, TRT_ColumnsContentUnfrozen, TRT_Count }; // Tables Rect Type
    trt_rects_names := [TRT_Count]string { "OuterRect", "InnerRect", "WorkRect", "HostClipRect", "InnerClipRect", "BackgroundClipRect", "ColumnsRect", "ColumnsWorkRect", "ColumnsClipRect", "ColumnsContentHeadersUsed", "ColumnsContentHeadersIdeal", "ColumnsContentFrozen", "ColumnsContentUnfrozen" };
    if (cfg.ShowWindowsRectsType < 0) {
        cfg.ShowWindowsRectsType = WRT_WorkRect;
    }
    if (cfg.ShowTablesRectsType < 0) {
        cfg.ShowTablesRectsType = TRT_WorkRect;
    }

    GetTableRect : proc(table : ^ImGuiTable, rect_type, n : i32) -> ImRect
    {
        table_instance := TableGetInstanceData(table, table.InstanceCurrent); // Always using last submitted instance
        if (rect_type == TRT_OuterRect)                     { return table.OuterRect; }
        else if (rect_type == TRT_InnerRect)                { return table.InnerRect; }
        else if (rect_type == TRT_WorkRect)                 { return table.WorkRect; }
        else if (rect_type == TRT_HostClipRect)             { return table.HostClipRect; }
        else if (rect_type == TRT_InnerClipRect)            { return table.InnerClipRect; }
        else if (rect_type == TRT_BackgroundClipRect)       { return table.BgClipRect; }
        else if (rect_type == TRT_ColumnsRect)              { ImGuiTableColumn* c = &table.Columns[n]; return ImRect{ _r = {c.MinX, table.InnerClipRect.Min.y, c.MaxX, table.InnerClipRect.Min.y + table_instance.LastOuterHeight}}; }
        else if (rect_type == TRT_ColumnsWorkRect)          { ImGuiTableColumn* c = &table.Columns[n]; return ImRect{ _r = {c.WorkMinX, table.WorkRect.Min.y, c.WorkMaxX, table.WorkRect.Max.y}}; }
        else if (rect_type == TRT_ColumnsClipRect)          { ImGuiTableColumn* c = &table.Columns[n]; return c.ClipRect; }
        else if (rect_type == TRT_ColumnsContentHeadersUsed){ ImGuiTableColumn* c = &table.Columns[n]; return ImRect{ _r = {c.WorkMinX, table.InnerClipRect.Min.y, c.ContentMaxXHeadersUsed, table.InnerClipRect.Min.y + table_instance.LastTopHeadersRowHeight}}; } // Note: y1/y2 not always accurate
        else if (rect_type == TRT_ColumnsContentHeadersIdeal){ImGuiTableColumn* c = &table.Columns[n]; return ImRect{ _r = {c.WorkMinX, table.InnerClipRect.Min.y, c.ContentMaxXHeadersIdeal, table.InnerClipRect.Min.y + table_instance.LastTopHeadersRowHeight}}; }
        else if (rect_type == TRT_ColumnsContentFrozen)     { ImGuiTableColumn* c = &table.Columns[n]; return ImRect{ _r = {c.WorkMinX, table.InnerClipRect.Min.y, c.ContentMaxXFrozen, table.InnerClipRect.Min.y + table_instance.LastFrozenHeight}}; }
        else if (rect_type == TRT_ColumnsContentUnfrozen)   { ImGuiTableColumn* c = &table.Columns[n]; return ImRect{ _r = {c.WorkMinX, table.InnerClipRect.Min.y + table_instance.LastFrozenHeight, c.ContentMaxXUnfrozen, table.InnerClipRect.Max.y}}; }
        assert(false)
        return ImRect();
    }

    GetWindowRect :: proc(window : ^ImGuiWindow, rect_type : i32) -> ImRect
    {
        if (rect_type == WRT_OuterRect)                 { return Rect(window); }
        else if (rect_type == WRT_OuterRectClipped)     { return window.OuterRectClipped; }
        else if (rect_type == WRT_InnerRect)            { return window.InnerRect; }
        else if (rect_type == WRT_InnerClipRect)        { return window.InnerClipRect; }
        else if (rect_type == WRT_WorkRect)             { return window.WorkRect; }
        else if (rect_type == WRT_Content)              { min := window.InnerRect.Min - window.Scroll + window.WindowPadding; return ImRect{ _v = {min, min + window.ContentSize}}; }
        else if (rect_type == WRT_ContentIdeal)         { min := window.InnerRect.Min - window.Scroll + window.WindowPadding; return ImRect{ _v = {min, min + window.ContentSizeIdeal}}; }
        else if (rect_type == WRT_ContentRegionRect)    { return window.ContentRegionRect; }
        assert(false)
        return ImRect();
    }

    // Tools
    if (TreeNode("Tools"))
    {
        // Debug Break features
        // The Item Picker tool is super useful to visually select an item and break into the call-stack of where it was submitted.
        SeparatorTextEx(0, "Debug breaks", nil, CalcTextSize("(?)").x + g.Style.SeparatorTextPadding.x);
        SameLine();
        MetricsHelpMarker("Will call the runtime.debug_trap macro to break in debugger.\nWarning: If you don't have a debugger attached, this will probably crash.");
        if (Checkbox("Show Item Picker", &g.DebugItemPickerActive) && g.DebugItemPickerActive)   do DebugStartItemPicker()
        Checkbox("Show \"Debug Break\" buttons in other sections (io.ConfigDebugIsDebuggerPresent)", &g.IO.ConfigDebugIsDebuggerPresent);

        SeparatorText("Visualize");

        Checkbox("Show Debug Log", &cfg.ShowDebugLog);
        SameLine();
        MetricsHelpMarker("You can also call ShowDebugLogWindow() from your code.");

        Checkbox("Show ID Stack Tool", &cfg.ShowIDStackTool);
        SameLine();
        MetricsHelpMarker("You can also call ShowIDStackToolWindow() from your code.");

        Checkbox("Show windows begin order", &cfg.ShowWindowsBeginOrder);
        Checkbox("Show windows rectangles", &cfg.ShowWindowsRects);
        SameLine();
        SetNextItemWidth(GetFontSize() * 12);
        cfg.ShowWindowsRects |= Combo("##show_windows_rect_type", &cfg.ShowWindowsRectsType, wrt_rects_names, WRT_Count, WRT_Count);
        if (cfg.ShowWindowsRects && g.NavWindow != nil)
        {
            BulletText("'%s':", g.NavWindow.Name);
            Indent();
            for rect_n := 0; rect_n < WRT_Count; rect_n += 1
            {
                r := GetWindowRect(g.NavWindow, rect_n);
                Text("(%6.1,%6.1) (%6.1,%6.1) Size (%6.1,%6.1) %s", r.Min.x, r.Min.y, r.Max.x, r.Max.y, r.GetWidth(), r.GetHeight(), wrt_rects_names[rect_n]);
            }
            Unindent();
        }

        Checkbox("Show tables rectangles", &cfg.ShowTablesRects);
        SameLine();
        SetNextItemWidth(GetFontSize() * 12);
        cfg.ShowTablesRects |= Combo("##show_table_rects_type", &cfg.ShowTablesRectsType, trt_rects_names, TRT_Count, TRT_Count);
        if (cfg.ShowTablesRects && g.NavWindow != nil)
        {
            for table_n := 0; table_n < g.Tables.GetMapSize(); table_n += 1
            {
                table := g.Tables.TryGetMapData(table_n);
                if (table == nil || table.LastFrameActive < g.FrameCount - 1 || (table.OuterWindow != g.NavWindow && table.InnerWindow != g.NavWindow))   do continue

                BulletText("Table 0x%08X (%d columns, in '%s')", table.ID, table.ColumnsCount, table.OuterWindow.Name);
                if (IsItemHovered()) {
                    AddRect(GetForegroundDrawList(), table.OuterRect.Min - ImVec2{1, 1}, table.OuterRect.Max + ImVec2{1, 1}, IM_COL32(255, 255, 0, 255), 0.0, 0, 2.0);
                }

                Indent();
                buf : [128]u8;
                for rect_n := 0; rect_n < TRT_Count; rect_n += 1
                {
                    if (rect_n >= TRT_ColumnsRect)
                    {
                        if (rect_n != TRT_ColumnsRect && rect_n != TRT_ColumnsClipRect)   do continue
                        for column_n := 0; column_n < table.ColumnsCount; column_n += 1
                        {
                            r := GetTableRect(table, rect_n, column_n);
                            ImFormatString(buf, len(buf), "(%6.1,%6.1) (%6.1,%6.1) Size (%6.1,%6.1) Col %d %s", r.Min.x, r.Min.y, r.Max.x, r.Max.y, r.GetWidth(), r.GetHeight(), column_n, trt_rects_names[rect_n]);
                            Selectable(buf);
                            if (IsItemHovered()) {
                                AddRect(GetForegroundDrawList(), r.Min - ImVec2{1, 1}, r.Max + ImVec2{1, 1}, IM_COL32(255, 255, 0, 255), 0.0, 0, 2.0);
                            }

                        }
                    }
                    else
                    {
                        r := GetTableRect(table, rect_n, -1);
                        ImFormatString(buf, len(buf), "(%6.1,%6.1) (%6.1,%6.1) Size (%6.1,%6.1) %s", r.Min.x, r.Min.y, r.Max.x, r.Max.y, r.GetWidth(), r.GetHeight(), trt_rects_names[rect_n]);
                        Selectable(buf);
                        if (IsItemHovered()) {
                            AddRect(GetForegroundDrawList(), r.Min - ImVec2{1, 1}, r.Max + ImVec2{1, 1}, IM_COL32(255, 255, 0, 255), 0.0, 0, 2.0);
                        }

                    }
                }
                Unindent();
            }
        }
        Checkbox("Show groups rectangles", &g.DebugShowGroupRects); // Storing in context as this is used by group code and prefers to be in hot-data

        SeparatorText("Validate");

        Checkbox("Debug Begin/BeginChild return value", &io.ConfigDebugBeginReturnValueLoop);
        SameLine();
        MetricsHelpMarker("Some calls to Begin()/BeginChild() will return false.\n\nWill cycle through window depths then repeat. Windows should be flickering while running.");

        Checkbox("UTF-8 Encoding viewer", &cfg.ShowTextEncodingViewer);
        SameLine();
        MetricsHelpMarker("You can also call DebugTextEncoding() from your code with a given string to test that your UTF-8 encoding settings are correct.");
        if (cfg.ShowTextEncodingViewer)
        {
            @(static) buf : [64]u8 = "";
            SetNextItemWidth(-math.F32_MIN);
            InputText("##DebugTextEncodingBuf", buf, len(buf));
            if (buf[0] != 0)   do DebugTextEncoding(buf)
        }

        TreePop();
    }

    // Windows
    if (TreeNode("Windows", "Windows (%d)", g.Windows.Size))
    {
        //SetNextItemOpen(true, ImGuiCond_Once);
        DebugNodeWindowsList(&g.Windows, "By display order");
        DebugNodeWindowsList(&g.WindowsFocusOrder, "By focus order (root windows)");
        if (TreeNode("By submission order (begin stack)"))
        {
            // Here we display windows in their submitted order/hierarchy, however note that the Begin stack doesn't constitute a Parent<>Child relationship!
            temp_buffer := &g.WindowsTempSortBuffer;
            temp_buffer.resize(0);
            for window in g.Windows {
                if (window.LastFrameActive + 1 >= g.FrameCount) {
                    temp_buffer.append(window);
                }
            }

            WindowComparerByBeginOrder :: proc(lhs, rhs : rawptr) -> i32 {
                return (cast(i32) (cast(^^ImGuiWindow)lhs)^.BeginOrderWithinContext - (cast(^^ImGuiWindow)rhs)^.BeginOrderWithinContext);
            }
            ImQsort(temp_buffer.Data, cast(int) temp_buffer.Size, size_of(^ImGuiWindow), WindowComparerByBeginOrder);
            DebugNodeWindowsListByBeginStackParent(temp_buffer.Data, temp_buffer.Size, nil);
            TreePop();
        }

        TreePop();
    }

    // DrawLists
    drawlist_count := 0;
    for viewport in g.Viewports {
        drawlist_count += len(viewport.DrawDataP.CmdLists);
    }
    if (TreeNode("DrawLists", "DrawLists (%d)", drawlist_count))
    {
        Checkbox("Show ImDrawCmd mesh when hovering", &cfg.ShowDrawCmdMesh);
        Checkbox("Show ImDrawCmd bounding boxes when hovering", &cfg.ShowDrawCmdBoundingBoxes);
        for viewport in g.Viewports
        {
            viewport_has_drawlist := false;
            for draw_list in viewport.DrawDataP.CmdLists
            {
                if (!viewport_has_drawlist) {
                    Text("Active DrawLists in Viewport #%d, ID: 0x%08X", viewport.Idx, viewport.ID);
                }

                viewport_has_drawlist = true;
                DebugNodeDrawList(nil, viewport, draw_list, "DrawList");
            }
        }
        TreePop();
    }

    // Viewports
    if (TreeNode("Viewports", "Viewports (%d)", g.Viewports.Size))
    {
        cfg.HighlightMonitorIdx = -1;
        open := TreeNode("Monitors", "Monitors (%d)", g.PlatformIO.Monitors.Size);
        SameLine();
        MetricsHelpMarker("Dear ImGui uses monitor data:\n- to query DPI settings on a per monitor basis\n- to position popup/tooltips so they don't straddle monitors.");
        if (open)
        {
            for i := 0; i < len(g.PlatformIO.Monitors); i += 1
            {
                DebugNodePlatformMonitor(&g.PlatformIO.Monitors[i], "Monitor", i);
                if (IsItemHovered()) {
                    cfg.HighlightMonitorIdx = i;
                }
            }
            DebugNodePlatformMonitor(&g.FallbackMonitor, "Fallback", 0);
            TreePop();
        }

        SetNextItemOpen(true, ImGuiCond_Once);
        if (TreeNode("Windows Minimap"))
        {
            RenderViewportsThumbnails();
            TreePop();
        }
        cfg.HighlightViewportID = 0;

        BulletText("MouseViewport: 0x%08X (UserHovered 0x%08X, LastHovered 0x%08X)", g.MouseViewport ? g.MouseViewport.ID : 0, g.IO.MouseHoveredViewport, g.MouseLastHoveredViewport ? g.MouseLastHoveredViewport.ID : 0);
        if (TreeNode("Inferred Z order (front-to-back)"))
        {
            @(static) viewports : [dynamic]^ImGuiViewportP;
            viewports.resize(g.Viewports.Size);
            memcpy(viewports.Data, g.Viewports.Data, g.Viewports.size_in_bytes());
            if (len(viewports) > 1) {
                ImQsort(viewports.Data, viewports.Size, size_of(^ImGuiViewport), ViewportComparerByLastFocusedStampCount);
            }
            for viewport in viewports
            {
                BulletText("Viewport #%d, ID: 0x%08X, LastFocused = %08d, PlatformFocused = %s, Window: \"%s\"",
                    viewport.Idx, viewport.ID, viewport.LastFocusedStampCount,
                    (g.PlatformIO.Platform_GetWindowFocus && viewport.PlatformWindowCreated) ? (g.PlatformIO.Platform_GetWindowFocus(viewport) ? "1" : "0") : "N/A",
                    viewport.Window ? viewport.Window.Name : "N/A");
                if (IsItemHovered()) {
                    cfg.HighlightViewportID = viewport.ID;
                }
            }
            TreePop();
        }

        for viewport in g.Viewports {
            DebugNodeViewport(viewport);
        }
        TreePop();
    }

    // Details for Popups
    if (TreeNode("Popups", "Popups (%d)", g.OpenPopupStack.Size))
    {
        for &popup_data in g.OpenPopupStack {
            // As it's difficult to interact with tree nodes while popups are open, we display everything inline.
            window := popup_data.Window;
            BulletText("PopupID: %08x, Window: '%s' (%s%s), RestoreNavWindow '%s', ParentWindow '%s'",
                popup_data.PopupId, window ? window.Name : "nil", window && (.ChildWindow in window.Flags) ? "Child;" : "", window && (.ChildMenu in window.Flags) ? "Menu;" : "",
                popup_data.RestoreNavWindow ? popup_data.RestoreNavWindow.Name : "nil", window && window.ParentWindow ? window.ParentWindow.Name : "nil");
        }
        TreePop();
    }

    // Details for TabBars
    if (TreeNode("TabBars", "Tab Bars (%d)", g.TabBars.GetAliveCount()))
    {
        for n := 0; n < g.TabBars.GetMapSize(); n += 1 {
            if tab_bar := g.TabBars.TryGetMapData(n); tab_bar != nil
            {
                PushID(tab_bar);
                DebugNodeTabBar(tab_bar, "TabBar");
                PopID();
            }
        }
        TreePop();
    }

    // Details for Tables
    if (TreeNode("Tables", "Tables (%d)", g.Tables.GetAliveCount()))
    {
        for n := 0; n < g.Tables.GetMapSize(); n += 1 {
            if table := g.Tables.TryGetMapData(n); table != nil  do DebugNodeTable(table)
        }
        TreePop();
    }

    // Details for Fonts
    atlas := g.IO.Fonts;
    if (TreeNode("Fonts", "Fonts (%d)", atlas.Fonts.Size))
    {
        ShowFontAtlas(atlas);
        TreePop();
    }

    // Details for InputText
    if (TreeNode("InputText"))
    {
        DebugNodeInputTextState(&g.InputTextState);
        TreePop();
    }

    // Details for TypingSelect
    if (TreeNode("TypingSelect", "TypingSelect (%d)", g.TypingSelectState.SearchBuffer[0] != 0 ? 1 : 0))
    {
        DebugNodeTypingSelectState(&g.TypingSelectState);
        TreePop();
    }

    // Details for MultiSelect
    if (TreeNode("MultiSelect", "MultiSelect (%d)", g.MultiSelectStorage.GetAliveCount()))
    {
        bs := &g.BoxSelectState;
        BulletText("BoxSelect ID=0x%08X, Starting = %d, Active %d", bs.ID, bs.IsStarting, bs.IsActive);
        for n := 0; n < g.MultiSelectStorage.GetMapSize(); n += 1 {
            if state := g.MultiSelectStorage.TryGetMapData(n); state != nil {
                DebugNodeMultiSelectState(state);
            }
        }

        TreePop();
    }

    // Details for Docking
when IMGUI_HAS_DOCK {
    if (TreeNode("Docking"))
    {
        @(static) root_nodes_only : bool = true;
        dc := &g.DockContext;
        Checkbox("List root nodes", &root_nodes_only);
        Checkbox("Ctrl shows window dock info", &cfg.ShowDockingNodes);
        if (SmallButton("Clear nodes")) { DockContextClearNodes(g, 0, true); }
        SameLine();
        if (SmallButton("Rebuild all")) { dc.WantFullRebuild = true; }
        for n := 0; n < len(dc.Nodes.Data); n += 1 {
            if node := cast(^ImGuiDockNode)dc.Nodes.Data[n].val_p; node != nil {
                if (!root_nodes_only || node.IsRootNode()) {
                    DebugNodeDockNode(node, "Node");
                }
            }
        }

        TreePop();
    }
} // #ifdef IMGUI_HAS_DOCK

    // Settings
    if (TreeNode("Settings"))
    {
        if (SmallButton("Clear"))   do ClearIniSettings()
        SameLine();
        if (SmallButton("Save to memory"))   do SaveIniSettingsToMemory()
        SameLine();
        if (SmallButton("Save to disk")) {
            SaveIniSettingsToDisk(g.IO.IniFilename);
        }

        SameLine();
        if (g.IO.IniFilename) {
            Text("\"%s\"", g.IO.IniFilename);
        }
        else {
            TextUnformatted("<nil>");
        }
        Checkbox("io.ConfigDebugIniSettings", &io.ConfigDebugIniSettings);
        Text("SettingsDirtyTimer %.2", g.SettingsDirtyTimer);
        if (TreeNode("SettingsHandlers", "Settings handlers: (%d)", g.SettingsHandlers.Size))
        {
            for &handler in g.SettingsHandlers {
                BulletText("\"%s\"", handler.TypeName);
            }
            TreePop();
        }
        if (TreeNode("SettingsWindows", "Settings packed data: Windows: %d bytes", g.SettingsWindows.size()))
        {
            for settings := begin(&g.SettingsWindows); settings != nil; settings = next_chunk(&g.SettingsWindows, settings) {
                DebugNodeWindowSettings(settings);
            }
            TreePop();
        }

        if (TreeNode("SettingsTables", "Settings packed data: Tables: %d bytes", g.SettingsTables.size()))
        {
            for ImGuiTableSettings* settings = g.SettingsTables.begin(); settings != nil; settings = g.SettingsTables.next_chunk(settings) {
                DebugNodeTableSettings(settings);
            }
            TreePop();
        }

when IMGUI_HAS_DOCK {
        if (TreeNode("SettingsDocking", "Settings packed data: Docking"))
        {
            dc := &g.DockContext;
            Text("In SettingsWindows:");
            for settings := begin(&g.SettingsWindows); settings != nil; settings = next_chunk(&g.SettingsWindows, settings) {
                if (settings.DockId != 0) {
                    BulletText("Window '%s' -> DockId %08X DockOrder=%d", settings.GetName(), settings.DockId, settings.DockOrder);
                }
            }

            Text("In SettingsNodes:");
            for n := 0; n < len(dc.NodesSettings); n += 1
            {
                settings := &dc.NodesSettings[n];
                selected_tab_name := nil;
                if (settings.SelectedTabId)
                {
                    if window := FindWindowByID(settings.SelectedTabId); window != nil {
                        selected_tab_name = window.Name;
                    }
                    else if window_settings := FindWindowSettingsByID(settings.SelectedTabId); window_settings != nil {
                        selected_tab_name = window_settings.GetName();
                    }

                }
                BulletText("Node %08X, Parent %08X, SelectedTab %08X ('%s')", settings.ID, settings.ParentNodeId, settings.SelectedTabId, selected_tab_name ? selected_tab_name : settings.SelectedTabId ? "N/A" : "");
            }
            TreePop();
        }
} // #ifdef IMGUI_HAS_DOCK

        if (TreeNode("SettingsIniData", "Settings unpacked data (.ini): %d bytes", g.SettingsIniData.size()))
        {
            InputTextMultiline("##Ini", cast(^u8)cast(rawptr)g.SettingsIniData.c_str(), g.SettingsIniData.Buf.Size, ImVec2{-math.F32_MIN, GetTextLineHeight() * 20}, ImGuiInputTextFlags_ReadOnly);
            TreePop();
        }
        TreePop();
    }

    // Settings
    if (TreeNode("Memory allocations"))
    {
        info := &g.DebugAllocInfo;
        Text("%d current allocations", info.TotalAllocCount - info.TotalFreeCount);
        if (SmallButton("GC now")) { g.GcCompactAll = true; }
        Text("Recent frames with allocations:");
        buf_size := len(info.LastEntriesBuf);
        for n := buf_size - 1; n >= 0; n -= 1
        {
            entry := &info.LastEntriesBuf[(info.LastEntriesIdx - n + buf_size) % buf_size];
            BulletText("Frame %06d: %+3d ( %2d alloc, %2d free )", entry.FrameCount, entry.AllocCount - entry.FreeCount, entry.AllocCount, entry.FreeCount);
            if (n == 0)
            {
                SameLine();
                Text("<- %d frames ago", g.FrameCount - entry.FrameCount);
            }
        }
        TreePop();
    }

    if (TreeNode("Inputs"))
    {
        Text("KEYBOARD/GAMEPAD/MOUSE KEYS");
        {
            // User code should never have to go through such hoops! You can generally iterate between ImGuiKey.NamedKey_BEGIN and ImGuiKey.NamedKey_END.
            Indent();
            Text("Keys down:");         for key := ImGuiKey.NamedKey_BEGIN; key < ImGuiKey.NamedKey_END; key = (ImGuiKey)(key + 1) { if (!IsKeyDown(key)) do continue;     SameLine(); Text(IsNamedKey(key) ? "\"%s\"" : "\"%s\" %d", GetKeyName(key), key); SameLine(); Text("(%.02)", GetKeyData(key)->DownDuration); }
            Text("Keys pressed:");      for key := ImGuiKey.NamedKey_BEGIN; key < ImGuiKey.NamedKey_END; key = (ImGuiKey)(key + 1) { if (!IsKeyPressed(key)) do continue;  SameLine(); Text(IsNamedKey(key) ? "\"%s\"" : "\"%s\" %d", GetKeyName(key), key); }
            Text("Keys released:");     for key := ImGuiKey.NamedKey_BEGIN; key < ImGuiKey.NamedKey_END; key = (ImGuiKey)(key + 1) { if (!IsKeyReleased(key)) do continue; SameLine(); Text(IsNamedKey(key) ? "\"%s\"" : "\"%s\" %d", GetKeyName(key), key); }
            Text("Keys mods: %s%s%s%s", io.KeyCtrl ? "CTRL " : "", io.KeyShift ? "SHIFT " : "", io.KeyAlt ? "ALT " : "", io.KeySuper ? "SUPER " : "");
            Text("Chars queue:");       for i := 0; i < len(io.InputQueueCharacters); i += 1 { c := io.InputQueueCharacters[i]; SameLine(); Text("\'%c\' (0x%04X)", (c > ' ' && c <= 255) ? cast(u8) c : '?', c); } // FIXME: We should convert 'c' to UTF-8 here but the functions are not public.
            DebugRenderKeyboardPreview(GetWindowDrawList());
            Unindent();
        }

        Text("MOUSE STATE");
        {
            Indent();
            if (IsMousePosValid()) {
                Text("Mouse pos: (%g, %g)", io.MousePos.x, io.MousePos.y);
            }
            else {
                Text("Mouse pos: <INVALID>");
            }
            Text("Mouse delta: (%g, %g)", io.MouseDelta.x, io.MouseDelta.y);
            count := len(io.MouseDown);
            Text("Mouse down:");     for i := 0; i < count; i += 1 do  if (IsMouseDown(i)) { SameLine(); Text("b%d (%.02 secs)", i, io.MouseDownDuration[i]); }
            Text("Mouse clicked:");  for i := 0; i < count; i += 1 do  if (IsMouseClicked(i)) { SameLine(); Text("b%d (%d)", i, io.MouseClickedCount[i]); }
            Text("Mouse released:"); for i := 0; i < count; i += 1 do  if (IsMouseReleased(i)) { SameLine(); Text("b%d", i); }
            Text("Mouse wheel: %.1", io.MouseWheel);
            Text("MouseStationaryTimer: %.2", g.MouseStationaryTimer);
            Text("Mouse source: %s", GetMouseSourceName(io.MouseSource));
            Text("Pen Pressure: %.1", io.PenPressure); // Note: currently unused
            Unindent();
        }

        Text("MOUSE WHEELING");
        {
            Indent();
            Text("WheelingWindow: '%s'", g.WheelingWindow ? g.WheelingWindow.Name : "nil");
            Text("WheelingWindowReleaseTimer: %.2", g.WheelingWindowReleaseTimer);
            Text("WheelingAxisAvg[] = { %.3, %.3 }, Main Axis: %s", g.WheelingAxisAvg.x, g.WheelingAxisAvg.y, (g.WheelingAxisAvg.x > g.WheelingAxisAvg.y) ? "X" : (g.WheelingAxisAvg.x < g.WheelingAxisAvg.y) ? "Y" : "<none>");
            Unindent();
        }

        Text("KEY OWNERS");
        {
            Indent();
            if (BeginChild("##owners", ImVec2{-math.F32_MIN, GetTextLineHeightWithSpacing() * 8}, ImGuiChildFlags_FrameStyle | ImGuiChildFlags_ResizeY, ImGuiWindowFlags_NoSavedSettings)) {
                for key := ImGuiKey.NamedKey_BEGIN; key < ImGuiKey.NamedKey_END; key = (ImGuiKey)(key + 1)
                {
                    owner_data := GetKeyOwnerData(g, key);
                    if (owner_data.OwnerCurr == ImGuiKeyOwner_NoOwner)   do continue
                    Text("%s: 0x%08X%s", GetKeyName(key), owner_data.OwnerCurr,
                        owner_data.LockUntilRelease ? " LockUntilRelease" : owner_data.LockThisFrame ? " LockThisFrame" : "");
                    DebugLocateItemOnHover(owner_data.OwnerCurr);
                }
            }
            EndChild();
            Unindent();
        }
        Text("SHORTCUT ROUTING");
        SameLine();
        MetricsHelpMarker("Declared shortcut routes automatically set key owner when mods matches.");
        {
            Indent();
            if (BeginChild("##routes", ImVec2{-math.F32_MIN, GetTextLineHeightWithSpacing() * 8}, ImGuiChildFlags_FrameStyle | ImGuiChildFlags_ResizeY, ImGuiWindowFlags_NoSavedSettings)) {
                for key := ImGuiKey.NamedKey_BEGIN; key < ImGuiKey.NamedKey_END; key = (ImGuiKey)(key + 1)
                {
                    rt := &g.KeysRoutingTable;
                    for idx := rt.Index[key - ImGuiKey.NamedKey_BEGIN]; idx != -1; 
                    {
                        routing_data := &rt.Entries[idx];
                        key_chord := key | routing_data.Mods;
                        Text("%s: 0x%08X (scored %d)", GetKeyChordName(key_chord), routing_data.RoutingCurr, routing_data.RoutingCurrScore);
                        DebugLocateItemOnHover(routing_data.RoutingCurr);
                        if (g.IO.ConfigDebugIsDebuggerPresent)
                        {
                            SameLine();
                            if (DebugBreakButton("**DebugBreak**", "in SetShortcutRouting() for this KeyChord")) {
                                g.DebugBreakInShortcutRouting = key_chord;
                            }

                        }
                        idx = routing_data.NextEntryIndex;
                    }
                }
            }
            EndChild();
            Text("(ActiveIdUsing: AllKeyboardKeys: %d, NavDirMask: 0x%X)", g.ActiveIdUsingAllKeyboardKeys, g.ActiveIdUsingNavDirMask);
            Unindent();
        }
        TreePop();
    }

    if (TreeNode("Internal state"))
    {
        Text("WINDOWING");
        Indent();
        Text("HoveredWindow: '%s'", g.HoveredWindow ? g.HoveredWindow.Name : "nil");
        Text("HoveredWindow.Root: '%s'", g.HoveredWindow ? g.HoveredWindow.RootWindowDockTree.Name : "nil");
        Text("HoveredWindowUnderMovingWindow: '%s'", g.HoveredWindowUnderMovingWindow ? g.HoveredWindowUnderMovingWindow.Name : "nil");
        Text("HoveredDockNode: 0x%08X", g.DebugHoveredDockNode ? g.DebugHoveredDockNode.ID : 0);
        Text("MovingWindow: '%s'", g.MovingWindow ? g.MovingWindow.Name : "nil");
        Text("MouseViewport: 0x%08X (UserHovered 0x%08X, LastHovered 0x%08X)", g.MouseViewport.ID, g.IO.MouseHoveredViewport, g.MouseLastHoveredViewport ? g.MouseLastHoveredViewport.ID : 0);
        Unindent();

        Text("ITEMS");
        Indent();
        Text("ActiveId: 0x%08X/0x%08X (%.2 sec), AllowOverlap: %d, Source: %s", g.ActiveId, g.ActiveIdPreviousFrame, g.ActiveIdTimer, g.ActiveIdAllowOverlap, GetInputSourceName(g.ActiveIdSource));
        DebugLocateItemOnHover(g.ActiveId);
        Text("ActiveIdWindow: '%s'", g.ActiveIdWindow ? g.ActiveIdWindow.Name : "nil");
        Text("ActiveIdUsing: AllKeyboardKeys: %d, NavDirMask: %X", g.ActiveIdUsingAllKeyboardKeys, g.ActiveIdUsingNavDirMask);
        Text("HoveredId: 0x%08X (%.2 sec), AllowOverlap: %d", g.HoveredIdPreviousFrame, g.HoveredIdTimer, g.HoveredIdAllowOverlap); // Not displaying g.HoveredId as it is update mid-frame
        Text("HoverItemDelayId: 0x%08X, Timer: %.2, ClearTimer: %.2", g.HoverItemDelayId, g.HoverItemDelayTimer, g.HoverItemDelayClearTimer);
        Text("DragDrop: %d, SourceId = 0x%08X, Payload \"%s\" (%d bytes)", g.DragDropActive, g.DragDropPayload.SourceId, g.DragDropPayload.DataType, g.DragDropPayload.DataSize);
        DebugLocateItemOnHover(g.DragDropPayload.SourceId);
        Unindent();

        Text("NAV,FOCUS");
        Indent();
        Text("NavWindow: '%s'", g.NavWindow != nil ? g.NavWindow.Name : "nil");
        Text("NavId: 0x%08X, NavLayer: %d", g.NavId, g.NavLayer);
        DebugLocateItemOnHover(g.NavId);
        Text("NavInputSource: %s", GetInputSourceName(g.NavInputSource));
        Text("NavLastValidSelectionUserData = %v (0x%x)", g.NavLastValidSelectionUserData, g.NavLastValidSelectionUserData);
        Text("NavActive: %d, NavVisible: %d", g.IO.NavActive, g.IO.NavVisible);
        Text("NavActivateId/DownId/PressedId: %08X/%08X/%08X", g.NavActivateId, g.NavActivateDownId, g.NavActivatePressedId);
        Text("NavActivateFlags: %04X", g.NavActivateFlags);
        Text("NavCursorVisible: %d, NavHighlightItemUnderNav: %d", g.NavCursorVisible, g.NavHighlightItemUnderNav);
        Text("NavFocusScopeId = 0x%08X", g.NavFocusScopeId);
        Text("NavFocusRoute[] = ");
        for path_n := len(g.NavFocusRoute) - 1; path_n >= 0; path_n -= 1
        {
            focus_scope := &g.NavFocusRoute[path_n];
            SameLine(0.0, 0.0);
            Text("0x%08X/", focus_scope.ID);
            SetItemTooltip("In window \"%s\"", FindWindowByID(focus_scope.WindowID).Name);
        }
        Text("NavWindowingTarget: '%s'", g.NavWindowingTarget != nil ? g.NavWindowingTarget.Name : "nil");
        Unindent();

        TreePop();
    }

    // Overlay: Display windows Rectangles and Begin Order
    if (cfg.ShowWindowsRects || cfg.ShowWindowsBeginOrder)
    {
        for window in g.Windows
        {
            if (!window.WasActive)   do continue
            draw_list := GetForegroundDrawList(window);
            if (cfg.ShowWindowsRects)
            {
                r := GetWindowRect(window, cfg.ShowWindowsRectsType);
                AddRect(draw_list, r.Min, r.Max, IM_COL32(255, 0, 128, 255));
            }
            if (cfg.ShowWindowsBeginOrder && !(.ChildWindow in window.Flags))
            {
                buf : [32]u8;
                ImFormatString(raw_data(buf), len(buf), "%d", window.BeginOrderWithinContext);
                font_size := GetFontSize();
                AddRectFilled(draw_list, window.Pos, window.Pos + ImVec2{font_size, font_size}, IM_COL32(200, 100, 100, 255));
                AddText(draw_list, window.Pos, IM_COL32(255, 255, 255, 255), buf);
            }
        }
    }

    // Overlay: Display Tables Rectangles
    if (cfg.ShowTablesRects)
    {
        for table_n := 0; table_n < GetMapSize(g.Tables); table_n += 1
        {
            table := TryGetMapData(&g.Tables, table_n);
            if (table == nil || table.LastFrameActive < g.FrameCount - 1)   do continue
            draw_list := GetForegroundDrawList(table.OuterWindow);
            if (cfg.ShowTablesRectsType >= TRT.TRT_ColumnsRect)
            {
                for column_n := 0; column_n < table.ColumnsCount; column_n += 1
                {
                    r := GetTableRect(table, cfg.ShowTablesRectsType, column_n);
                    col := (table.HoveredColumnBody == column_n) ? IM_COL32(255, 255, 128, 255) : IM_COL32(255, 0, 128, 255);
                    thickness := (table.HoveredColumnBody == column_n) ? 3.0 : 1.0;
                    draw_list.AddRect(r.Min, r.Max, col, 0.0, 0, thickness);
                }
            }
            else
            {
                r := GetTableRect(table, cfg.ShowTablesRectsType, -1);
                draw_list.AddRect(r.Min, r.Max, IM_COL32(255, 0, 128, 255));
            }
        }
    }

when IMGUI_HAS_DOCK {
    // Overlay: Display Docking info
    if (cfg.ShowDockingNodes && g.IO.KeyCtrl && g.DebugHoveredDockNode)
    {
        buf : [64]u8;
        buf_start := raw_data(buf)
        p := raw_data(buf);
        node := g.DebugHoveredDockNode;
        overlay_draw_list := node.HostWindow != nil ? GetForegroundDrawList(node.HostWindow) : GetForegroundDrawList(GetMainViewport());
        p = p[ImFormatString(p, mem.ptr_sub(end(buf), cast(^u8) p), "DockId: %X%s\n", node.ID, IsCentralNode(node) ? " *CentralNode*" : ""):];
        p = p[ImFormatString(p, mem.ptr_sub(end(buf), cast(^u8) p), "WindowClass: %08X\n", node.WindowClass.ClassId):];
        p = p[ImFormatString(p, mem.ptr_sub(end(buf), cast(^u8) p), "Size: (%.0, %.0)\n", node.Size.x, node.Size.y):];
        p = p[ImFormatString(p, mem.ptr_sub(end(buf), cast(^u8) p), "SizeRef: (%.0, %.0)\n", node.SizeRef.x, node.SizeRef.y):];
        depth := DockNodeGetDepth(node);
        overlay_draw_list.AddRect(node.Pos + ImVec2{3, 3} * cast(f32) depth, node.Pos + node.Size - ImVec2{3, 3} * cast(f32) depth, IM_COL32(200, 100, 100, 255));
        pos := node.Pos + ImVec2{3, 3} * cast(f32) depth;
        overlay_AddRectFilled(draw_list, pos - ImVec2{1, 1}, pos + CalcTextSize(buf) + ImVec2{1, 1}, IM_COL32(200, 100, 100, 255));
        overlay_draw_list.AddText(nil, 0.0, pos, IM_COL32(255, 255, 255, 255), buf);
    }
} // #ifdef IMGUI_HAS_DOCK

    End();
}

DebugBreakClearData :: proc()
{
    // Those fields are scattered in their respective subsystem to stay in hot-data locations
    g := GImGui;
    g.DebugBreakInWindow = 0;
    g.DebugBreakInTable = 0;
    g.DebugBreakInShortcutRouting = ImGuiKey.None;
}

DebugBreakButtonTooltip :: proc(keyboard_only : bool, description_of_location : string)
{
    if (!BeginItemTooltip())   do return
    Text("To call runtime.debug_trap %s:", description_of_location);
    Separator();
    TextUnformatted(keyboard_only ? "- Press 'Pause/Break' on keyboard." : "- Press 'Pause/Break' on keyboard.\n- or Click (may alter focus/active id).\n- or navigate using keyboard and press space.");
    Separator();
    TextUnformatted("Choose one way that doesn't interfere with what you are trying to debug!\nYou need a debugger attached or this will crash!");
    EndTooltip();
}

// Special button that doesn't take focus, doesn't take input owner, and can be activated without a click etc.
// In order to reduce interferences with the contents we are trying to debug into.
DebugBreakButton :: proc(label : string, description_of_location : string) -> bool
{
    window := GetCurrentWindow();
    if (window.SkipItems)   do return false

    g := GImGui;
    id := GetID(window, label);
    label_size := CalcTextSize(label, true);
    pos := window.DC.CursorPos + ImVec2{0.0, window.DC.CurrLineTextBaseOffset};
    size := ImVec2{label_size.x + g.Style.FramePadding.x * 2.0, label_size.y};

    bb := ImRect{ _v = {pos, pos + size} };
    ItemSize(size, 0.0);
    if (!ItemAdd(bb, id))   do return false

    // WE DO NOT USE ButtonEx() or ButtonBehavior() in order to reduce our side-effects.
    hovered := ItemHoverable(bb, id, g.CurrentItemFlags);
    pressed := hovered && (IsKeyChordPressed(g.DebugBreakKeyChord) || IsMouseClicked(0) || g.NavActivateId == id);
    DebugBreakButtonTooltip(false, description_of_location);

    col4f := GetStyleColorVec4(hovered ? ImGuiCol.ButtonHovered : ImGuiCol.Button);
    hsv : ImVec4
    ColorConvertRGBtoHSV(col4f.x, col4f.y, col4f.z, &hsv.x, &hsv.y, &hsv.z);
    ColorConvertHSVtoRGB(hsv.x + 0.20, hsv.y, hsv.z, &col4f.x, &col4f.y, &col4f.z);

    RenderNavCursor(bb, id);
    RenderFrame(bb.Min, bb.Max, GetColorU32(col4f^), true, g.Style.FrameRounding);
    RenderTextClipped(bb.Min, bb.Max, label, &label_size, g.Style.ButtonTextAlign, &bb);

    IMGUI_TEST_ENGINE_ITEM_INFO(id, label, g.LastItemData.StatusFlags);
    return pressed;
}

// [DEBUG] Display contents of Columns
DebugNodeColumns :: proc(columns : ^ImGuiOldColumns)
{
    if (!TreeNode(cast(rawptr)cast(uintptr)columns.ID, "Columns Id: 0x%08X, Count: %d, Flags: 0x%04X", columns.ID, columns.Count, columns.Flags))   do return
    BulletText("Width: %.1 (MinX: %.1, MaxX: %.1)", columns.OffMaxX - columns.OffMinX, columns.OffMinX, columns.OffMaxX);
    for &column in columns.Columns {
        BulletText("Column %02d: OffsetNorm %.3 (= %.1 px)", cast(i32) index_from_ptr(columns.Columns, &column), column.OffsetNorm, GetColumnOffsetFromNorm(columns, column.OffsetNorm));
    }
    TreePop();
}

DebugNodeDockNodeFlags :: proc(p_flags : ^ImGuiDockNodeFlags, label : string, enabled : bool)
{
    PushID(label);
    PushStyleVar(ImGuiStyleVar_FramePadding, ImVec2{0.0, 0.0});
    Text("%s:", label);
    if (!enabled)   do BeginDisabled()
    CheckboxFlags("NoResize", p_flags, .NoResize);
    CheckboxFlags("NoResizeX", p_flags, .NoResizeX);
    CheckboxFlags("NoResizeY",p_flags, .NoResizeY);
    CheckboxFlags("NoTabBar", p_flags, .NoTabBar);
    CheckboxFlags("HiddenTabBar", p_flags, .HiddenTabBar);
    CheckboxFlags("NoWindowMenuButton", p_flags, .NoWindowMenuButton);
    CheckboxFlags("NoCloseButton", p_flags, .NoCloseButton);
    CheckboxFlags("DockedWindowsInFocusRoute", p_flags, .DockedWindowsInFocusRoute);
    CheckboxFlags("NoDocking", p_flags, .NoDocking); // Multiple flags
    CheckboxFlags("NoDockingSplit", p_flags, .NoDockingSplit);
    CheckboxFlags("NoDockingSplitOther", p_flags, .NoDockingSplitOther);
    CheckboxFlags("NoDockingOver", p_flags, .NoDockingOverMe);
    CheckboxFlags("NoDockingOverOther", p_flags, .NoDockingOverOther);
    CheckboxFlags("NoDockingOverEmpty", p_flags, .NoDockingOverEmpty);
    CheckboxFlags("NoUndocking", p_flags, .NoUndocking);
    if (!enabled)   do EndDisabled()
    PopStyleVar();
    PopID();
}

// [DEBUG] Display contents of ImDockNode
DebugNodeDockNode :: proc(node : ^ImGuiDockNode, label : string)
{
    g := GImGui;
    is_alive := (g.FrameCount - node.LastFrameAlive < 2);    // Submitted with ImGuiDockNodeFlags_KeepAliveOnly
    is_active := (g.FrameCount - node.LastFrameActive < 2);  // Submitted
    if (!is_alive) { PushStyleColor(ImGuiCol.Text, GetStyleColorVec4(ImGuiCol.TextDisabled)^); }
    open : bool
    tree_node_flags := node.IsFocused ? ImGuiTreeNodeFlags{.Selected} : nil;
    if (len(node.Windows) > 0) {
        open = TreeNodeEx(cast(rawptr)cast(uintptr)node.ID, tree_node_flags, "%s 0x%04X%s: %d windows (vis: '%s')", label, node.ID, node.IsVisible ? "" : " (hidden)", node.Windows.Size, node.VisibleWindow != nil ? node.VisibleWindow.Name : "nil");
    }
    else {
        open = TreeNodeEx(cast(rawptr)cast(uintptr)node.ID, tree_node_flags, "%s 0x%04X%s: %s (vis: '%s')", label, node.ID, node.IsVisible ? "" : " (hidden)", (node.SplitAxis == .X) ? "horizontal split" : (node.SplitAxis == .Y) ? "vertical split" : "empty", node.VisibleWindow != nil ? node.VisibleWindow.Name : "nil");
    }
    if (!is_alive) { PopStyleColor(); }
    if (is_active && IsItemHovered()) {
        if window := node.HostWindow != nil ? node.HostWindow : node.VisibleWindow; window != nil {
            AddRect(GetForegroundDrawList(window), node.Pos, node.Pos + node.Size, IM_COL32(255, 255, 0, 255));
        }
    }

    if (open)
    {
        assert(node.ChildNodes[0] == nil || node.ChildNodes[0].ParentNode == node);
        assert(node.ChildNodes[1] == nil || node.ChildNodes[1].ParentNode == node);
        BulletText("Pos (%.0,%.0), Size (%.0, %.0) Ref (%.0, %.0)",
            node.Pos.x, node.Pos.y, node.Size.x, node.Size.y, node.SizeRef.x, node.SizeRef.y);
        DebugNodeWindow(node.HostWindow, "HostWindow");
        DebugNodeWindow(node.VisibleWindow, "VisibleWindow");
        BulletText("SelectedTabID: 0x%08X, LastFocusedNodeID: 0x%08X", node.SelectedTabId, node.LastFocusedNodeId);
        BulletText("Misc:%s%s%s%s%s%s%s",
            IsDockSpace(node) ? " IsDockSpace" : "",
            IsCentralNode(node) ? " IsCentralNode" : "",
            is_alive ? " IsAlive" : "", is_active ? " IsActive" : "", node.IsFocused ? " IsFocused" : "",
            node.WantLockSizeOnce ? " WantLockSizeOnce" : "",
            node.HasCentralNodeChild ? " HasCentralNodeChild" : "");
        if (TreeNode("flags", "Flags Merged: 0x%04X, Local: 0x%04X, InWindows: 0x%04X, Shared: 0x%04X", node.MergedFlags, node.LocalFlags, node.LocalFlagsInWindows, node.SharedFlags))
        {
            if (BeginTable("flags", 4))
            {
                TableNextColumn(); DebugNodeDockNodeFlags(&node.MergedFlags, "MergedFlags", false);
                TableNextColumn(); DebugNodeDockNodeFlags(&node.LocalFlags, "LocalFlags", true);
                TableNextColumn(); DebugNodeDockNodeFlags(&node.LocalFlagsInWindows, "LocalFlagsInWindows", false);
                TableNextColumn(); DebugNodeDockNodeFlags(&node.SharedFlags, "SharedFlags", true);
                EndTable();
            }
            TreePop();
        }
        if (node.ParentNode != nil) {
            DebugNodeDockNode(node.ParentNode, "ParentNode");
        }

        if (node.ChildNodes[0] != nil) {
            DebugNodeDockNode(node.ChildNodes[0], "Child[0]");
        }

        if (node.ChildNodes[1] != nil) {
            DebugNodeDockNode(node.ChildNodes[1], "Child[1]");
        }

        if (node.TabBar != nil) {
            DebugNodeTabBar(node.TabBar, "TabBar");
        }

        DebugNodeWindowsList(node.Windows[:], "Windows");

        TreePop();
    }
}

// [DEBUG] Display contents of ImDrawList
// Note that both 'window' and 'viewport' may be NULL here. Viewport is generally null of destroyed popups which previously owned a viewport.
DebugNodeDrawList :: proc(window : ^ImGuiWindow, viewport : ^ImGuiViewportP, draw_list : ^ImDrawList, label : string)
{
    g := GImGui;
    cfg := &g.DebugMetricsConfig;
    cmd_count := len(draw_list.CmdBuffer);
    if (cmd_count > 0 && back(draw_list.CmdBuffer).ElemCount == 0 && back(draw_list.CmdBuffer).UserCallback == nil)   do cmd_count -= 1
    node_open := TreeNode(draw_list, "%s: '%s' %d vtx, %d indices, %d cmds", label, draw_list._OwnerName ? draw_list._OwnerName : "", len(draw_list.VtxBuffer), len(draw_list.IdxBuffer), cmd_count);
    if (draw_list == GetWindowDrawList())
    {
        SameLine();
        TextColored(ImVec4{1.0, 0.4, 0.4, 1.0}, "CURRENTLY APPENDING"); // Can't display stats for active draw list! (we don't have the data double-buffered)
        if (node_open)   do TreePop()
        return;
    }

    fg_draw_list := viewport != nil ? GetForegroundDrawList(viewport) : nil; // Render additional visuals into the top-most draw list
    if (window != nil && IsItemHovered() && fg_draw_list != nil) {
        AddRect(fg_draw_list, window.Pos, window.Pos + window.Size, IM_COL32(255, 255, 0, 255));
    }

    if (!node_open)   do return

    if (window != nil && !window.WasActive) {
        TextDisabled("Warning: owning Window is inactive. This DrawList is not being rendered!");
    }


    for pcmd in draw_list.CmdBuffer[cmd_count:]
    {
        if (pcmd.UserCallback != nil)
        {
            BulletText("Callback %p, user_data %p", pcmd.UserCallback, pcmd.UserCallbackData);
            continue;
        }

        texid_desc : [20]u8;
        FormatTextureIDForDebugDisplay(raw_data(texid_desc), len(texid_desc), pcmd.TextureId);
        buf : [300]u8;
        ImFormatString(raw_data(buf), len(buf), "DrawCmd:%5d tris, Tex %s, ClipRect (%4.0,%4.0)-(%4.0,%4.0)",
            pcmd.ElemCount / 3, texid_desc, pcmd.ClipRect.x, pcmd.ClipRect.y, pcmd.ClipRect.z, pcmd.ClipRect.w);
        pcmd_node_open := TreeNode((rawptr)(pcmd - draw_list.CmdBuffer.begin()), "%s", buf);
        if (IsItemHovered() && (cfg.ShowDrawCmdMesh || cfg.ShowDrawCmdBoundingBoxes) && fg_draw_list) {
            DebugNodeDrawCmdShowMeshAndBoundingBox(fg_draw_list, draw_list, pcmd, cfg.ShowDrawCmdMesh, cfg.ShowDrawCmdBoundingBoxes);
        }

        if (!pcmd_node_open)   do continue

        // Calculate approximate coverage area (touched pixel count)
        // This will be in pixels squared as long there's no post-scaling happening to the renderer output.
        idx_buffer := (len(draw_list.IdxBuffer) > 0) ? raw_data(draw_list.IdxBuffer) : nil;
        vtx_buffer := raw_data(draw_list.VtxBuffer)[pcmd.VtxOffset:];
        total_area : f32 = 0.0;
        for idx_n := pcmd.IdxOffset; idx_n < pcmd.IdxOffset + pcmd.ElemCount; 
        {
            triangle : [3]ImVec2;
            for n := 0; n < 3; n, idx_n = n + 1, idx_n + 1 {
                triangle[n] = vtx_buffer[idx_buffer != nil ? idx_buffer[idx_n] : idx_n].pos;
            }
            total_area += ImTriangleArea(triangle[0], triangle[1], triangle[2]);
        }

        // Display vertex information summary. Hover to get all triangles drawn in wire-frame
        ImFormatString(raw_data(buf), len(buf), "Mesh: ElemCount: %d, VtxOffset: +%d, IdxOffset: +%d, Area: ~%0.f px", pcmd.ElemCount, pcmd.VtxOffset, pcmd.IdxOffset, total_area);
        Selectable(strings.string_from_ptr(cast(^u8) raw_data(buf), len(buf)));
        if (IsItemHovered() && fg_draw_list) {
            DebugNodeDrawCmdShowMeshAndBoundingBox(fg_draw_list, draw_list, pcmd, true, false);
        }

        // Display individual triangles/vertices. Hover on to get the corresponding triangle highlighted.
        clipper : ImGuiListClipper
        Begin(&clipper, pcmd.ElemCount / 3); // Manually coarse clip our print out of individual vertices to save CPU, only items that may be visible.
        for (Step(&clipper)) {
            for prim, idx_i := clipper.DisplayStart, pcmd.IdxOffset + clipper.DisplayStart * 3; prim < clipper.DisplayEnd; prim += 1
            {
                buf_p := buf; buf_end := end(buf)
                triangle : [3]ImVec2;
                for n := 0; n < 3; n, idx_i = n, idx_i + 1
                {
                    v := &vtx_buffer[idx_buffer ? idx_buffer[idx_i] : idx_i];
                    triangle[n] = v.pos;
                    buf_p += ImFormatString(buf_p, buf_end - buf_p, "%s %04d: pos (%8.2,%8.2), uv (%.6,%.6), col %08X\n",
                        (n == 0) ? "Vert:" : "     ", idx_i, v.pos.x, v.pos.y, v.uv.x, v.uv.y, v.col);
                }

                Selectable(buf, false);
                if (fg_draw_list != nil && IsItemHovered())
                {
                    backup_flags := fg_draw_list.Flags;
                    fg_draw_list.Flags &= ~{ImDrawListFlag.AntiAliasedLines}; // Disable AA on triangle outlines is more readable for very large and thin triangles.
                    AddPolyline(fg_draw_list, triangle, 3, IM_COL32(255, 255, 0, 255), ImDrawFlags_Closed, 1.0);
                    fg_draw_list.Flags = backup_flags;
                }
            }
        }
        TreePop();
    }
    TreePop();
}

// [DEBUG] Display mesh/aabb of a ImDrawCmd
DebugNodeDrawCmdShowMeshAndBoundingBox :: proc(out_draw_list : ^ImDrawList, draw_list : ^ImDrawList, draw_cmd : ^ImDrawCmd, show_mesh : bool, show_aabb : bool)
{
    assert(show_mesh || show_aabb);

    // Draw wire-frame version of all triangles
    clip_rect := draw_cmd.ClipRect;
    vtxs_rect := ImRect{_r = { math.F32_MAX, math.F32_MAX, -math.F32_MAX, -math.F32_MAX}};
    backup_flags := out_draw_list.Flags;
    out_draw_list.Flags &= ~ImDrawListFlags_AntiAliasedLines; // Disable AA on triangle outlines is more readable for very large and thin triangles.
    for idx_n, idx_end := draw_cmd.IdxOffset, draw_cmd.IdxOffset + draw_cmd.ElemCount; idx_n < idx_end; 
    {
        idx_buffer := (len(draw_list.IdxBuffer) > 0) ? raw_data(draw_list.IdxBuffer) : nil; // We don't hold on those pointers past iterations as ->AddPolyline() may invalidate them if out_draw_list==draw_list
        vtx_buffer := raw_data(draw_list.VtxBuffer)[draw_cmd.VtxOffset:];

        triangle : [3]ImVec2;
        for n := 0; n < 3; n, idx_n = n + 1, idx_n + 1 {
            triangle[n] = vtx_buffer[idx_buffer ? idx_buffer[idx_n] : idx_n].pos
            vtxs_rect.Add(triangle[n]);
        }
        if (show_mesh) {
            AddPolyline(out_draw_list, triangle, 3, IM_COL32(255, 255, 0, 255), ImDrawFlags_Closed, 1.0); // In yellow: mesh triangles
        }

    }
    // Draw bounding boxes
    if (show_aabb)
    {
        AddRect(out_draw_list, ImTrunc(clip_rect.Min), ImTrunc(clip_rect.Max), IM_COL32(255, 0, 255, 255)); // In pink: clipping rectangle submitted to GPU
        AddRect(out_draw_list, ImTrunc(vtxs_rect.Min), ImTrunc(vtxs_rect.Max), IM_COL32(0, 255, 255, 255)); // In cyan: bounding box of triangles
    }
    out_draw_list.Flags = backup_flags;
}

// [DEBUG] Display details for a single font, called by ShowStyleEditor().
DebugNodeFont :: proc(font : ^ImFont)
{
    opened := TreeNode(font, "Font: \"%s\"\n%.2 px, %d glyphs, %d file(s)",
        font.ConfigData != nil ? font.ConfigData[0].Name : "", font.FontSize, font.Glyphs.Size, font.ConfigDataCount);
    SameLine();
    if (SmallButton("Set as default")) {
        GetIO().FontDefault = font;
    }

    if (!opened)   do return

    // Display preview text
    PushFont(font);
    Text("The quick brown fox jumps over the lazy dog");
    PopFont();

    // Display details
    SetNextItemWidth(GetFontSize() * 8);
    DragFloat("Font scale", &font.Scale, 0.005, 0.3, 2.0, "%.1");
    SameLine(); MetricsHelpMarker(
        "Note that the default embedded font is NOT meant to be scaled.\n\n"+
        "Font are currently rendered into bitmaps at a given size at the time of building the atlas. "+
        "You may oversample them to get some flexibility with scaling. "+
        "You can also render at multiple sizes and select which one to use at runtime.\n\n"+
        "(Glimmer of hope: the atlas system will be rewritten in the future to make scaling more flexible.)");
    Text("Ascent: %f, Descent: %f, Height: %f", font.Ascent, font.Descent, font.Ascent - font.Descent);
    c_str : [5]u8;
    Text("Fallback character: '%s' (U+%04X)", ImTextCharToUtf8(c_str, font.FallbackChar), font.FallbackChar);
    Text("Ellipsis character: '%s' (U+%04X)", ImTextCharToUtf8(c_str, font.EllipsisChar), font.EllipsisChar);
    surface_sqrt := cast(i32) math.sqrt(cast(f32) font.MetricsTotalSurface);
    Text("Texture Area: about %d px ~%dx%d px", font.MetricsTotalSurface, surface_sqrt, surface_sqrt);
    for config_i := 0; config_i < font.ConfigDataCount; config_i += 1 {
        if (font.ConfigData != nil) {
            if cfg := &font.ConfigData[config_i]; cfg != nil {
                BulletText("Input %d: \'%s\', Oversample: (%d,%d), PixelSnapH: %d, Offset: (%.1,%.1)",
                    config_i, cfg.Name, cfg.OversampleH, cfg.OversampleV, cfg.PixelSnapH, cfg.GlyphOffset.x, cfg.GlyphOffset.y);
            }
        }
    }

    // Display all glyphs of the fonts in separate pages of 256 characters
    if (TreeNode("Glyphs", "Glyphs (%d)", font.Glyphs.Size))
    {
        draw_list := GetWindowDrawList();
        glyph_col := GetColorU32(ImGuiCol.Text);
        cell_size := font.FontSize * 1;
        cell_spacing := GetStyle().ItemSpacing.y;
        for base := 0; base <= IM_UNICODE_CODEPOINT_MAX; base += 256
        {
            // Skip ahead if a large bunch of glyphs are not present in the font (test in chunks of 4k)
            // This is only a small optimization to reduce the number of iterations when IM_UNICODE_MAX_CODEPOINT
            // is large // (if ImWchar==ImWchar32 we will do at least about 272 queries here)
            if (!(base & 4095 != nil) && IsGlyphRangeUnused(font, base, base + 4095))
            {
                base += 4096 - 256;
                continue;
            }

            count := 0;
            for n := 0; n < 256; n += 1 {
                if (FindGlyphNoFallback(font, (ImWchar)(base + n)))   do count += 1
            }
            if (count <= 0)   do continue
            if (!TreeNode(cast(rawptr)cast(uintptr)base, "U+%04X..U+%04X (%d %s)", base, base + 255, count, count > 1 ? "glyphs" : "glyph"))   do continue

            // Draw a 16x16 grid of glyphs
            base_pos := GetCursorScreenPos();
            for n := 0; n < 256; n += 1
            {
                // We use ImFont::RenderChar as a shortcut because we don't have UTF-8 conversion functions
                // available here and thus cannot easily generate a zero-terminated UTF-8 encoded string.
                cell_p1 := ImVec2(base_pos.x + (n % 16) * (cell_size + cell_spacing), base_pos.y + (n / 16) * (cell_size + cell_spacing));
                cell_p2 := ImVec2{cell_p1.x + cell_size, cell_p1.y + cell_size};
                glyph := FindGlyphNoFallback(font, (ImWchar)(base + n));
                draw_list.AddRect(cell_p1, cell_p2, glyph ? IM_COL32(255, 255, 255, 100) : IM_COL32(255, 255, 255, 50));
                if (!glyph)   do continue
                RenderChar(font, font, draw_list, cell_size, cell_p1, glyph_col, (ImWchar)(base + n));
                if (IsMouseHoveringRect(cell_p1, cell_p2) && BeginTooltip())
                {
                    DebugNodeFontGlyph(font, glyph);
                    EndTooltip();
                }
            }
            Dummy(ImVec2{(cell_size + cell_spacing) * 16, (cell_size + cell_spacing) * 16});
            TreePop();
        }
        TreePop();
    }
    TreePop();
}

DebugNodeFontGlyph :: proc(_ : ^ImFont, glyph : ^ImFontGlyph)
{
    Text("Codepoint: U+%04X", glyph.Codepoint);
    Separator();
    Text("Visible: %d", glyph.Visible);
    Text("AdvanceX: %.1", glyph.AdvanceX);
    Text("Pos: (%.2,%.2)->(%.2,%.2)", glyph.X0, glyph.Y0, glyph.X1, glyph.Y1);
    Text("UV: (%.3,%.3)->(%.3,%.3)", glyph.U0, glyph.V0, glyph.U1, glyph.V1);
}

// [DEBUG] Display contents of ImGuiStorage
DebugNodeStorage :: proc(storage : ^ImGuiStorage, label : string)
{
    if (!TreeNode(label, "%s: %d entries, %d bytes", label, storage.Data.Size, storage.Data.size_in_bytes()))   do return
    for &p in storage.Data
    {
        BulletText("Key 0x%08X Value { i: %d }", p.key, p.val_i); // Important: we currently don't store a type, real value may not be integer.
        DebugLocateItemOnHover(p.key);
    }
    TreePop();
}

// [DEBUG] Display contents of ImGuiTabBar
DebugNodeTabBar :: proc(tab_bar : ^ImGuiTabBar, label : string)
{
    // Standalone tab bars (not associated to docking/windows functionality) currently hold no discernible strings.
    buf : [256]u8;
    p := raw_data(buf);
    buf_end := end(buf);
    is_active := (tab_bar.PrevFrameVisible >= GetFrameCount() - 2);
    p = p[ImFormatString(p, buf_end - p, "%s 0x%08X (%d tabs)%s  {", label, tab_bar.ID, len(tab_bar.Tabs), is_active ? "" : " *Inactive*"):];
    for tab_n := 0; tab_n < ImMin(len(tab_bar.Tabs), 3); tab_n += 1
    {
        tab := &tab_bar.Tabs[tab_n];
        p = p[ImFormatString(p, buf_end - p, "%s'%s'", tab_n > 0 ? ", " : "", TabBarGetTabName(tab_bar, tab)):];
    }
    p = p[ImFormatString(p, buf_end - p, (len(tab_bar.Tabs) > 3) ? " ... }" : " } "):];
    if (!is_active) { PushStyleColor(ImGuiCol.Text, GetStyleColorVec4(ImGuiCol.TextDisabled)); }
    open := TreeNode(label, "%s", buf);
    if (!is_active) { PopStyleColor(); }
    if (is_active && IsItemHovered())
    {
        draw_list := GetForegroundDrawList();
        draw_list.AddRect(tab_bar.BarRect.Min, tab_bar.BarRect.Max, IM_COL32(255, 255, 0, 255));
        draw_list.AddLine(ImVec2{tab_bar.ScrollingRectMinX, tab_bar.BarRect.Min.y}, ImVec2{tab_bar.ScrollingRectMinX, tab_bar.BarRect.Max.y}, IM_COL32(0, 255, 0, 255));
        draw_list.AddLine(ImVec2{tab_bar.ScrollingRectMaxX, tab_bar.BarRect.Min.y}, ImVec2{tab_bar.ScrollingRectMaxX, tab_bar.BarRect.Max.y}, IM_COL32(0, 255, 0, 255));
    }
    if (open)
    {
        for tab_n := 0; tab_n < len(tab_bar.Tabs); tab_n += 1
        {
            tab := &tab_bar.Tabs[tab_n];
            PushID(tab);
            if (SmallButton("<")) { TabBarQueueReorder(tab_bar, tab, -1); } SameLine(0, 2);
            if (SmallButton(">")) { TabBarQueueReorder(tab_bar, tab, +1); } SameLine();
            Text("%02d%c Tab 0x%08X '%s' Offset: %.2, Width: %.2/%.2",
                tab_n, (tab.ID == tab_bar.SelectedTabId) ? '*' : ' ', tab.ID, TabBarGetTabName(tab_bar, tab), tab.Offset, tab.Width, tab.ContentWidth);
            PopID();
        }
        TreePop();
    }
}

DebugNodeViewport :: proc(viewport : ^ImGuiViewportP)
{
    g := GImGui;
    SetNextItemOpen(true, ImGuiCond_Once);
    open := TreeNode(cast(rawptr)viewport.ID, "Viewport #%d, ID: 0x%08X, Parent: 0x%08X, Window: \"%s\"", viewport.Idx, viewport.ID, viewport.ParentViewportId, viewport.Window != nil ? viewport.Window.Name : "N/A");
    if (IsItemHovered()) {
        g.DebugMetricsConfig.HighlightViewportID = viewport.ID;
    }

    if (open)
    {
        flags := viewport.Flags;
        BulletText("Main Pos: (%.0,%.0), Size: (%.0,%.0)\nWorkArea Inset Left: %.0 Top: %.0, Right: %.0, Bottom: %.0\nMonitor: %d, DpiScale: %.0%%",
            viewport.Pos.x, viewport.Pos.y, viewport.Size.x, viewport.Size.y,
            viewport.WorkInsetMin.x, viewport.WorkInsetMin.y, viewport.WorkInsetMax.x, viewport.WorkInsetMax.y,
            viewport.PlatformMonitor, viewport.DpiScale * 100.0);
        if (viewport.Idx > 0) { SameLine(); if (SmallButton("Reset Pos")) { viewport.Pos = ImVec2{200, 200}; viewport.UpdateWorkRect(); if (viewport.Window != nil) do viewport.Window.Pos = viewport.Pos; } }
        BulletText("Flags: 0x%04X =%s%s%s%s%s%s%s%s%s%s%s%s%s", viewport.Flags,
            //(.IsPlatformWindow in flags) ? " IsPlatformWindow" : "", // Omitting because it is the standard
            (.IsPlatformMonitor in flags) ? " IsPlatformMonitor" : "",
            (.IsMinimized in flags) ? " IsMinimized" : "",
            (.IsFocused in flags) ? " IsFocused" : "",
            (.OwnedByApp in flags) ? " OwnedByApp" : "",
            (.NoDecoration in flags) ? " NoDecoration" : "",
            (.NoTaskBarIcon in flags) ? " NoTaskBarIcon" : "",
            (.NoFocusOnAppearing in flags) ? " NoFocusOnAppearing" : "",
            (.NoFocusOnClick in flags) ? " NoFocusOnClick" : "",
            (.NoInputs in flags) ? " NoInputs" : "",
            (.NoRendererClear in flags) ? " NoRendererClear" : "",
            (.NoAutoMerge in flags) ? " NoAutoMerge" : "",
            (.TopMost in flags) ? " TopMost" : "",
            (.CanHostOtherWindows in flags) ? " CanHostOtherWindows" : "");
        for draw_list in viewport.DrawDataP.CmdLists {
            DebugNodeDrawList(nil, viewport, draw_list, "DrawList");
        }
        TreePop();
    }
}

DebugNodePlatformMonitor :: proc(monitor : ^ImGuiPlatformMonitor, label : string, idx : i32)
{
    BulletText("%s %d: DPI %.0%%\n MainMin (%.0,%.0), MainMax (%.0,%.0), MainSize (%.0,%.0)\n WorkMin (%.0,%.0), WorkMax (%.0,%.0), WorkSize (%.0,%.0)",
        label, idx, monitor.DpiScale * 100.0,
        monitor.MainPos.x, monitor.MainPos.y, monitor.MainPos.x + monitor.MainSize.x, monitor.MainPos.y + monitor.MainSize.y, monitor.MainSize.x, monitor.MainSize.y,
        monitor.WorkPos.x, monitor.WorkPos.y, monitor.WorkPos.x + monitor.WorkSize.x, monitor.WorkPos.y + monitor.WorkSize.y, monitor.WorkSize.x, monitor.WorkSize.y);
}

DebugNodeWindow :: proc(window : ^ImGuiWindow, label : string)
{
    if (window == nil)
    {
        BulletText("%s: nil", label);
        return;
    }

    g := GImGui;
    is_active := window.WasActive;
    tree_node_flags := (window == g.NavWindow) ? {ImGuiTreeNodeFlag.Selected} : nil;
    if (!is_active) { PushStyleColor(ImGuiCol.Text, GetStyleColorVec4(ImGuiCol.TextDisabled)); }
    open := TreeNodeEx(label, tree_node_flags, "%s '%s'%s", label, window.Name, is_active ? "" : " *Inactive*");
    if (!is_active) { PopStyleColor(); }
    if (IsItemHovered() && is_active) {
        AddRect(GetForegroundDrawList(window), window.Pos, window.Pos + window.Size, IM_COL32(255, 255, 0, 255));
    }

    if (!open)   do return

    if (window.MemoryCompacted) {
        TextDisabled("Note: some memory buffers have been compacted/freed.");
    }

    if (g.IO.ConfigDebugIsDebuggerPresent && DebugBreakButton("**DebugBreak**", "in Begin()")) {
        g.DebugBreakInWindow = window.ID;
    }

    flags := window.Flags;
    DebugNodeDrawList(window, window.Viewport, window.DrawList, "DrawList");
    BulletText("Pos: (%.1,%.1), Size: (%.1,%.1), ContentSize (%.1,%.1) Ideal (%.1,%.1)", window.Pos.x, window.Pos.y, window.Size.x, window.Size.y, window.ContentSize.x, window.ContentSize.y, window.ContentSizeIdeal.x, window.ContentSizeIdeal.y);
    BulletText("Flags: 0x%08X (%s%s%s%s%s%s%s%s%s..)", flags,
        (.ChildWindow in flags)  ? "Child " : "",      (.Tooltip in flags)     ? "Tooltip "   : "",  (.Popup in flags) ? "Popup " : "",
        (.Modal in flags)        ? "Modal " : "",      (.ChildMenu in flags)   ? "ChildMenu " : "",  (.NoSavedSettings in flags) ? "NoSavedSettings " : "",
        (.NoMouseInputs in flags)? "NoMouseInputs":"", (.NoNavInputs in flags) ? "NoNavInputs" : "", (.AlwaysAutoResize in flags) ? "AlwaysAutoResize" : "");
    if (.ChildWindow in flags) {
        BulletText("ChildFlags: 0x%08X (%s%s%s%s..)", window.ChildFlags,
            (.Borders in window.ChildFlags) ? "Borders " : "",
            (.ResizeX in window.ChildFlags) ? "ResizeX " : "",
            (.ResizeY in window.ChildFlags) ? "ResizeY " : "",
            (.NavFlattened in window.ChildFlags) ? "NavFlattened " : "");
    }
    BulletText("WindowClassId: 0x%08X", window.WindowClass.ClassId);
    BulletText("Scroll: (%.2/%.2,%.2/%.2) Scrollbar:%s%s", window.Scroll.x, window.ScrollMax.x, window.Scroll.y, window.ScrollMax.y, window.ScrollbarX ? "X" : "", window.ScrollbarY ? "Y" : "");
    BulletText("Active: %d/%d, WriteAccessed: %d, BeginOrderWithinContext: %d", window.Active, window.WasActive, window.WriteAccessed, (window.Active || window.WasActive) ? window.BeginOrderWithinContext : -1);
    BulletText("Appearing: %d, Hidden: %d (CanSkip %d Cannot %d), SkipItems: %d", window.Appearing, window.Hidden, window.HiddenFramesCanSkipItems, window.HiddenFramesCannotSkipItems, window.SkipItems);
    for layer := 0; layer < ImGuiNavLayer_COUNT; layer += 1
    {
        r := window.NavRectRel[layer];
        if (r.Min.x >= r.Max.x && r.Min.y >= r.Max.y) {
            BulletText("NavLastIds[%d]: 0x%08X", layer, window.NavLastIds[layer]);
        }
        else {
            BulletText("NavLastIds[%d]: 0x%08X at +(%.1,%.1)(%.1,%.1)", layer, window.NavLastIds[layer], r.Min.x, r.Min.y, r.Max.x, r.Max.y);
        }
        DebugLocateItemOnHover(window.NavLastIds[layer]);
    }
    pr := window.NavPreferredScoringPosRel;
    for layer := 0; layer < ImGuiNavLayer_COUNT; layer += 1 {
        BulletText("NavPreferredScoringPosRel[%d] = {%.1,%.1)", layer, (pr[layer].x == math.F32_MAX ? -99999.0 : pr[layer].x), (pr[layer].y == math.F32_MAX ? -99999.0 : pr[layer].y)); // Display as 99999.0f so it looks neater.
    }
    BulletText("NavLayersActiveMask: %X, NavLastChildNavWindow: %s", window.DC.NavLayersActiveMask, window.NavLastChildNavWindow ? window.NavLastChildNavWindow.Name : "nil");

    BulletText("Viewport: %d%s, ViewportId: 0x%08X, ViewportPos: (%.1,%.1)", window.Viewport ? window.Viewport.Idx : -1, window.ViewportOwned ? " (Owned)" : "", window.ViewportId, window.ViewportPos.x, window.ViewportPos.y);
    BulletText("ViewportMonitor: %d", window.Viewport ? window.Viewport.PlatformMonitor : -1);
    BulletText("DockId: 0x%04X, DockOrder: %d, Act: %d, Vis: %d", window.DockId, window.DockOrder, window.DockIsActive, window.DockTabIsVisible);
    if (window.DockNode || window.DockNodeAsHost) {
        DebugNodeDockNode(window.DockNodeAsHost ? window.DockNodeAsHost : window.DockNode, window.DockNodeAsHost ? "DockNodeAsHost" : "DockNode");
    }

    if (window.RootWindow != window)               { DebugNodeWindow(window.RootWindow, "RootWindow"); }
    if (window.RootWindowDockTree != window.RootWindow) { DebugNodeWindow(window.RootWindowDockTree, "RootWindowDockTree"); }
    if (window.ParentWindow != nil)               { DebugNodeWindow(window.ParentWindow, "ParentWindow"); }
    if (window.ParentWindowForFocusRoute != nil)  { DebugNodeWindow(window.ParentWindowForFocusRoute, "ParentWindowForFocusRoute"); }
    if (len(window.DC.ChildWindows) > 0)           { DebugNodeWindowsList(&window.DC.ChildWindows, "ChildWindows"); }
    if (len(window.ColumnsStorage) > 0 && TreeNode("Columns", "Columns sets (%d)", window.ColumnsStorage.Size))
    {
        for &columns in window.ColumnsStorage {
            DebugNodeColumns(&columns);
        }
        TreePop();
    }
    DebugNodeStorage(&window.StateStorage, "Storage");
    TreePop();
}

DebugNodeWindowSettings :: proc(settings : ^ImGuiWindowSettings)
{
    if (settings.WantDelete)   do BeginDisabled()
    Text("0x%08X \"%s\" Pos (%d,%d) Size (%d,%d) Collapsed=%d",
        settings.ID, settings.GetName(), settings.Pos.x, settings.Pos.y, settings.Size.x, settings.Size.y, settings.Collapsed);
    if (settings.WantDelete)   do EndDisabled()
}

DebugNodeWindowsList :: proc(windows : []^ImGuiWindow, label : string)
{
    if (!TreeNode(label, "%s (%d)", label, len(windows)))   do return
    #reverse for window in windows
    {
        PushID(windows);
        DebugNodeWindow(windows, "Window");
        PopID();
    }
    TreePop();
}

// FIXME-OPT: This is technically suboptimal, but it is simpler this way.
DebugNodeWindowsListByBeginStackParent :: proc(windows : ^^ImGuiWindow, windows_size : i32, parent_in_begin_stack : ^ImGuiWindow)
{
    for i := 0; i < windows_size; i += 1
    {
        window := windows[i];
        if (window.ParentWindowInBeginStack != parent_in_begin_stack)   do continue
        buf : [20]u8;
        ImFormatString(buf, len(buf), "[%04d] Window", window.BeginOrderWithinContext);
        //BulletText("[%04d] Window '%s'", window.BeginOrderWithinContext, window.Name);
        DebugNodeWindow(window, buf);
        Indent();
        DebugNodeWindowsListByBeginStackParent(windows + i + 1, windows_size - i - 1, window);
        Unindent();
    }
}

//-----------------------------------------------------------------------------
// [SECTION] DEBUG LOG WINDOW
//-----------------------------------------------------------------------------

// [forward declared comment]:
// Call via IMGUI_DEBUG_LOG() for maximum stripping in caller code!
DebugLog :: proc(fmt : string, args : ..any)
{
    g := GImGui;
    old_size := strings.builder_len(g.DebugLogBuf);
    if (g.ContextName[0] != 0) {
        appendf(&g.DebugLogBuf, "[%s] [%05d] ", g.ContextName, g.FrameCount);
    }
    else {
        appendf(&g.DebugLogBuf, "[%05d] ", g.FrameCount);
    }
    appendf(&g.DebugLogBuf, fmt, args);
    append(&g.DebugLogIndex, strings.to_string(g.DebugLogBuf), cast(i32) old_size, cast(i32) strings.builder_len(g.DebugLogBuf));
    if (.OutputToTTY in g.DebugLogFlags) {
        IMGUI_DEBUG_PRINTF("%s", strings.to_string(g.DebugLogBuf)[old_size:]);
    }
when IMGUI_ENABLE_TEST_ENGINE {
    // IMGUI_TEST_ENGINE_LOG() adds a trailing \n automatically
    new_size := g.DebugLogBuf.size();
    trailing_carriage_return := (g.DebugLogBuf[new_size - 1] == '\n');
    if (.OutputToTestEngine in g.DebugLogFlags) {
        IMGUI_TEST_ENGINE_LOG("%.*s", new_size - old_size - (trailing_carriage_return ? 1 : 0), g.DebugLogBuf.begin() + old_size);
    }
}
}

// FIXME-LAYOUT: To be done automatically via layout mode once we rework ItemSize/ItemAdd into ItemLayout.
SameLineOrWrap :: proc(size : ImVec2)
{
    g := GImGui;
    window := g.CurrentWindow;
    pos := ImVec2{window.DC.CursorPosPrevLine.x + g.Style.ItemSpacing.x, window.DC.CursorPosPrevLine.y};
    if (window.WorkRect.Contains(ImRect{ _v = {pos, pos + size}}))   do SameLine()
}

ShowDebugLogFlag :: proc(name : ^u8, flags : ImGuiDebugLogFlags)
{
    g := GImGui;
    size := ImVec2(GetFrameHeight() + g.Style.ItemInnerSpacing.x + CalcTextSize(name).x, GetFrameHeight());
    SameLineOrWrap(size); // FIXME-LAYOUT: To be done automatically once we rework ItemSize/ItemAdd into ItemLayout.

    highlight_errors := (flags == ImGuiDebugLogFlags_EventError && g.DebugLogSkippedErrors > 0);
    if (highlight_errors) {
        PushStyleColor(ImGuiCol.Text, ImLerp(g.Style.Colors[ImGuiCol.Text], ImVec4{1.0, 0.0, 0.0, 1.0}, 0.30));
    }

    if (CheckboxFlags(name, &g.DebugLogFlags, flags) && g.IO.KeyShift && (g.DebugLogFlags & flags) != 0)
    {
        g.DebugLogAutoDisableFrames = 2;
        g.DebugLogAutoDisableFlags |= flags;
    }
    if (highlight_errors)
    {
        PopStyleColor();
        SetItemTooltip("%d past errors skipped.", g.DebugLogSkippedErrors);
    }
    else
    {
        SetItemTooltip("Hold SHIFT when clicking to enable for 2 frames only (useful for spammy log entries)");
    }
}

// [forward declared comment]:
// create Debug Log window. display a simplified log of important dear imgui events.
ShowDebugLogWindow :: proc(p_open : ^bool = nil)
{
    g := GImGui;
    if ((.HasSize not_in g.NextWindowData.Flags)) {
        SetNextWindowSize(ImVec2{0.0, GetFontSize() * 12.0}, { .FirstUseEver });
    }

    if (!Begin("Dear ImGui Debug Log", p_open) || GetCurrentWindow()->BeginCount > 1)
    {
        End();
        return;
    }

    all_enable_flags := ImGuiDebugLogFlags_EventMask_ & ~ImGuiDebugLogFlags_EventInputRouting;
    CheckboxFlags("All", &g.DebugLogFlags, all_enable_flags);
    SetItemTooltip("(except InputRouting which is spammy)");

    ShowDebugLogFlag("Errors", ImGuiDebugLogFlags_EventError);
    ShowDebugLogFlag("ActiveId", ImGuiDebugLogFlags_EventActiveId);
    ShowDebugLogFlag("Clipper", ImGuiDebugLogFlags_EventClipper);
    ShowDebugLogFlag("Docking", ImGuiDebugLogFlags_EventDocking);
    ShowDebugLogFlag("Focus", ImGuiDebugLogFlags_EventFocus);
    ShowDebugLogFlag("IO", ImGuiDebugLogFlags_EventIO);
    //ShowDebugLogFlag("Font", ImGuiDebugLogFlags_EventFont);
    ShowDebugLogFlag("Nav", ImGuiDebugLogFlags_EventNav);
    ShowDebugLogFlag("Popup", ImGuiDebugLogFlags_EventPopup);
    ShowDebugLogFlag("Selection", ImGuiDebugLogFlags_EventSelection);
    ShowDebugLogFlag("Viewport", ImGuiDebugLogFlags_EventViewport);
    ShowDebugLogFlag("InputRouting", ImGuiDebugLogFlags_EventInputRouting);

    if (SmallButton("Clear"))
    {
        g.DebugLogBuf.clear();
        g.DebugLogIndex.clear();
        g.DebugLogSkippedErrors = 0;
    }
    SameLine();
    if (SmallButton("Copy")) {
        SetClipboardText(g.DebugLogBuf.c_str());
    }

    SameLine();
    if (SmallButton("Configure Outputs.."))   do OpenPopup("Outputs")
    if (BeginPopup("Outputs"))
    {
        CheckboxFlags("OutputToTTY", &g.DebugLogFlags, ImGuiDebugLogFlags_OutputToTTY);
when !(IMGUI_ENABLE_TEST_ENGINE) {
        BeginDisabled();
}
        CheckboxFlags("OutputToTestEngine", &g.DebugLogFlags, ImGuiDebugLogFlags_OutputToTestEngine);
when !(IMGUI_ENABLE_TEST_ENGINE) {
        EndDisabled();
}
        EndPopup();
    }

    BeginChild("##log", ImVec2{0.0, 0.0}, ImGuiChildFlags_Borders, ImGuiWindowFlags_AlwaysVerticalScrollbar | ImGuiWindowFlags_AlwaysHorizontalScrollbar);

    backup_log_flags := g.DebugLogFlags;
    g.DebugLogFlags &= ~ImGuiDebugLogFlags_EventClipper;

    clipper : ImGuiListClipper
    clipper.Begin(g.DebugLogIndex.size());
    for (clipper.Step()) {
        for line_no := clipper.DisplayStart; line_no < clipper.DisplayEnd; line_no += 1 {
            DebugTextUnformattedWithLocateItem(g.DebugLogIndex.get_line_begin(g.DebugLogBuf.c_str(), line_no), g.DebugLogIndex.get_line_end(g.DebugLogBuf.c_str(), line_no));
        }
    }
    g.DebugLogFlags = backup_log_flags;
    if (GetScrollY() >= GetScrollMaxY())   do SetScrollHereY(1.0)
    EndChild();

    End();
}

// Display line, search for 0xXXXXXXXX identifiers and call DebugLocateItemOnHover() when hovered.
DebugTextUnformattedWithLocateItem :: proc(line_begin : ^u8, line_end : ^u8)
{
    TextUnformatted(line_begin, line_end);
    if (!IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByPopup | ImGuiHoveredFlags_AllowWhenBlockedByActiveItem))   do return
    g := GImGui;
    text_rect := g.LastItemData.Rect;
    for p := line_begin; p <= line_end - 10; p += 1
    {
        id := 0;
        if (p[0] != '0' || (p[1] != 'x' && p[1] != 'X') || sscanf(p + 2, "%X", &id) != 1 || ImCharIsXdigitA(p[10]))   do continue
        p0 := CalcTextSize(line_begin, p);
        p1 := CalcTextSize(p, p + 10);
        g.LastItemData.Rect = ImRect{ _r = {text_rect.Min + ImVec2{p0.x, 0.0}, text_rect.Min + ImVec2{p0.x + p1.x, p1.y}}};
        if (IsMouseHoveringRect(g.LastItemData.Rect.Min, g.LastItemData.Rect.Max, true)) {
            DebugLocateItemOnHover(id);
        }

        p += 10;
    }
}

//-----------------------------------------------------------------------------
// [SECTION] OTHER DEBUG TOOLS (ITEM PICKER, ID STACK TOOL)
//-----------------------------------------------------------------------------

// Draw a small cross at current CursorPos in current window's DrawList
DebugDrawCursorPos :: proc(col : u32 = IM_COL32_RED)
{
    g := GImGui;
    window := g.CurrentWindow;
    pos := window.DC.CursorPos;
    AddLine(window.DrawList, ImVec2{pos.x, pos.y - 3.0}, ImVec2{pos.x, pos.y + 4.0}, col, 1.0);
    AddLine(window.DrawList, ImVec2{pos.x - 3.0, pos.y}, ImVec2{pos.x + 4.0, pos.y}, col, 1.0);
}

// Draw a 10px wide rectangle around CurposPos.x using Line Y1/Y2 in current window's DrawList
DebugDrawLineExtents :: proc(col : u32 = IM_COL32_RED)
{
    g := GImGui;
    window := g.CurrentWindow;
    curr_x := window.DC.CursorPos.x;
    line_y1 := (window.DC.IsSameLine ? window.DC.CursorPosPrevLine.y : window.DC.CursorPos.y);
    line_y2 := line_y1 + (window.DC.IsSameLine ? window.DC.PrevLineSize.y : window.DC.CurrLineSize.y);
    AddLine(window.DrawList, ImVec2{curr_x - 5.0, line_y1}, ImVec2{curr_x + 5.0, line_y1}, col, 1.0);
    AddLine(window.DrawList, ImVec2{curr_x - 0.5, line_y1}, ImVec2{curr_x - 0.5, line_y2}, col, 1.0);
    AddLine(window.DrawList, ImVec2{curr_x - 5.0, line_y2}, ImVec2{curr_x + 5.0, line_y2}, col, 1.0);
}

// Draw last item rect in ForegroundDrawList (so it is always visible)
DebugDrawItemRect :: proc(col : u32 = IM_COL32_RED)
{
    g := GImGui;
    window := g.CurrentWindow;
    GetForegroundDrawList(window)->AddRect(g.LastItemData.Rect.Min, g.LastItemData.Rect.Max, col);
}

// [DEBUG] Locate item position/rectangle given an ID.
DEBUG_LOCATE_ITEM_COLOR : u32 = IM_COL32_GREEN;

// [forward declared comment]:
// Call sparingly: only 1 at the same time!
DebugLocateItem :: proc(target_id : ImGuiID)
{
    g := GImGui;
    g.DebugLocateId = target_id;
    g.DebugLocateFrames = 2;
    g.DebugBreakInLocateId = false;
}

// FIXME: Doesn't work over through a modal window, because they clear HoveredWindow.
// [forward declared comment]:
// Only call on reaction to a mouse Hover: because only 1 at the same time!
DebugLocateItemOnHover :: proc(target_id : ImGuiID)
{
    if (target_id == 0 || !IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByActiveItem | ImGuiHoveredFlags_AllowWhenBlockedByPopup))   do return
    g := GImGui;
    DebugLocateItem(target_id);
    GetForegroundDrawList(g.CurrentWindow)->AddRect(g.LastItemData.Rect.Min - ImVec2{3.0, 3.0}, g.LastItemData.Rect.Max + ImVec2{3.0, 3.0}, DEBUG_LOCATE_ITEM_COLOR);

    // Can't easily use a context menu here because it will mess with focus, active id etc.
    if (g.IO.ConfigDebugIsDebuggerPresent && g.MouseStationaryTimer > 1.0)
    {
        DebugBreakButtonTooltip(false, "in ItemAdd()");
        if (IsKeyChordPressed(g.DebugBreakKeyChord)) {
            g.DebugBreakInLocateId = true;
        }

    }
}

DebugLocateItemResolveWithLastItem :: proc()
{
    g := GImGui;

    // [DEBUG] Debug break requested by user
    if (g.DebugBreakInLocateId)   do runtime.debug_trap()

    item_data := g.LastItemData;
    g.DebugLocateId = 0;
    draw_list := GetForegroundDrawList(g.CurrentWindow);
    r := item_data.Rect;
    r.Expand(3.0);
    p1 := g.IO.MousePos;
    p2 := ImVec2{(p1.x < r.Min.x) ? r.Min.x : (p1.x > r.Max.x) ? r.Max.x : p1.x, (p1.y < r.Min.y) ? r.Min.y : (p1.y > r.Max.y) ? r.Max.y : p1.y};
    draw_list.AddRect(r.Min, r.Max, DEBUG_LOCATE_ITEM_COLOR);
    draw_list.AddLine(p1, p2, DEBUG_LOCATE_ITEM_COLOR);
}

DebugStartItemPicker :: proc()
{
    g := GImGui;
    g.DebugItemPickerActive = true;
}

// [DEBUG] Item picker tool - start with DebugStartItemPicker() - useful to visually select an item and break into its call-stack.
UpdateDebugToolItemPicker :: proc()
{
    g := GImGui;
    g.DebugItemPickerBreakId = 0;
    if (!g.DebugItemPickerActive)   do return

    hovered_id := g.HoveredIdPreviousFrame;
    SetMouseCursor(ImGuiMouseCursor_Hand);
    if (IsKeyPressed(ImGuiKey.Escape)) {
        g.DebugItemPickerActive = false;
    }

    change_mapping := g.IO.KeyMods == (ImGuiKey.Mod_Ctrl | ImGuiKey.Mod_Shift);
    if (!change_mapping && IsMouseClicked(g.DebugItemPickerMouseButton) && hovered_id)
    {
        g.DebugItemPickerBreakId = hovered_id;
        g.DebugItemPickerActive = false;
    }
    for mouse_button := 0; mouse_button < 3; mouse_button += 1 {
        if (change_mapping && IsMouseClicked(mouse_button)) {
            g.DebugItemPickerMouseButton = cast(u8) mouse_button;
        }
    }

    SetNextWindowBgAlpha(0.70);
    if (!BeginTooltip())   do return
    Text("HoveredId: 0x%08X", hovered_id);
    Text("Press ESC to abort picking.");
    mouse_button_names := [?]string { "Left", "Right", "Middle" };
    if (change_mapping) {
        Text("Remap w/ Ctrl+Shift: click anywhere to select new mouse button.");
    }
    else {
        TextColored(GetStyleColorVec4(hovered_id ? ImGuiCol.Text : ImGuiCol.TextDisabled), "Click %s Button to break in debugger! (remap w/ Ctrl+Shift)", mouse_button_names[g.DebugItemPickerMouseButton]);
    }
    EndTooltip();
}

// [DEBUG] ID Stack Tool: update queries. Called by NewFrame()
UpdateDebugToolStackQueries :: proc()
{
    g := GImGui;
    tool := &g.DebugIDStackTool;

    // Clear hook when id stack tool is not visible
    g.DebugHookIdInfo = 0;
    if (g.FrameCount != tool.LastActiveFrame + 1)   do return

    // Update queries. The steps are: -1: query Stack, >= 0: query each stack item
    // We can only perform 1 ID Info query every frame. This is designed so the GetID() tests are cheap and constant-time
    query_id := g.HoveredIdPreviousFrame ? g.HoveredIdPreviousFrame : g.ActiveId;
    if (tool.QueryId != query_id)
    {
        tool.QueryId = query_id;
        tool.StackLevel = -1;
        tool.Results.resize(0);
    }
    if (query_id == 0)   do return

    // Advance to next stack level when we got our result, or after 2 frames (in case we never get a result)
    stack_level := tool.StackLevel;
    if (stack_level >= 0 && stack_level < tool.Results.Size) {
        if (tool.Results[stack_level].QuerySuccess || tool.Results[stack_level].QueryFrameCount > 2)   do tool.StackLevel += 1
    }

    // Update hook
    stack_level = tool.StackLevel;
    if (stack_level == -1) {
        g.DebugHookIdInfo = query_id;
    }

    if (stack_level >= 0 && stack_level < tool.Results.Size)
    {
        g.DebugHookIdInfo = tool.Results[stack_level].ID;
        tool.Results[stack_level].QueryFrameCount += 1;
    }
}

// [DEBUG] ID Stack tool: hooks called by GetID() family functions
DebugHookIdInfo :: proc(id : ImGuiID, data_type : ImGuiDataType, data_id : rawptr, data_id_end : rawptr)
{
    g := GImGui;
    window := g.CurrentWindow;
    tool := &g.DebugIDStackTool;

    // Step 0: stack query
    // This assumes that the ID was computed with the current ID stack, which tends to be the case for our widget.
    if (tool.StackLevel == -1)
    {
        tool.StackLevel += 1;
        resize(&tool.Results, len(window.IDStack) + 1, ImGuiStackLevelInfo());
        for n := 0; n < len(window.IDStack) + 1; n += 1 {
            tool.Results[n].ID = (n < len(window.IDStack)) ? window.IDStack[n] : id;
        }
        return;
    }

    // Step 1+: query for individual level
    assert(tool.StackLevel >= 0);
    if (tool.StackLevel != cast(i32) len(window.IDStack))   do return
    info := &tool.Results[tool.StackLevel];
    assert(info.ID == id && info.QueryFrameCount > 0);

    switch (data_type)
    {
    case ImGuiDataType.S32:
        ImFormatString(info.Desc, len(info.Desc), "%d", cast(i32)cast(rawptr)data_id);
        break;
    case ImGuiDataType.String:
        ImFormatString(info.Desc, len(info.Desc), "%.*s", data_id_end ? cast(i32)(cast(^u8) data_id_end - cast(^u8) data_id) : cast(i32) strlen(cast(^u8) data_id), cast(^u8) data_id);
        break;
    case ImGuiDataTypePrivate.Pointer:
        ImFormatString(info.Desc, len(info.Desc), "(rawptr)0x%p", data_id);
        break;
    case ImGuiDataTypePrivate.ID:
        if (info.Desc[0] != 0) {// PushOverrideID() is often used to avoid hashing twice, which would lead to 2 calls to DebugHookIdInfo(). We prioritize the first one.
            return;
        }

        ImFormatString(info.Desc, len(info.Desc), "0x%08X [override]", id);
        break;
    case:
        assert(false)
    }
    info.QuerySuccess = true;
    info.DataType = data_type;
}

StackToolFormatLevelInfo :: proc(tool : ^ImGuiIDStackTool, n : i32, format_for_ui : bool, buf : [^]u8, buf_size : int) -> i32
{
    info := &tool.Results[n];
    window := (info.Desc[0] == 0 && n == 0) ? FindWindowByID(info.ID) : nil;
    if (window != nil) {// Source: window name (because the root ID don't call GetID() and so doesn't get hooked)
        return ImFormatString(buf, buf_size, format_for_ui ? "\"%s\" [window]" : "%s", window.Name);
    }

    if (info.QuerySuccess) {// Source: GetID() hooks (prioritize over ItemInfo() because we frequently use patterns like: PushID(str), Button("") where they both have same id)
        return ImFormatString(buf, buf_size, (format_for_ui && info.DataType == ImGuiDataType.String) ? "\"%s\"" : "%s", info.Desc);
    }

    if (tool.StackLevel < cast(i32) len(tool.Results)) {// Only start using fallback below when all queries are done, so during queries we don't flickering ??? markers.
        buf^ = 0
        return 0;
    }

when IMGUI_ENABLE_TEST_ENGINE {
    if label := ImGuiTestEngine_FindItemDebugLabel(GImGui, info.ID); label != nil {// Source: ImGuiTestEngine's ItemInfo()
        return ImFormatString(buf, buf_size, format_for_ui ? "??? \"%s\"" : "%s", label);
    }

}
    return ImFormatString(buf, buf_size, "???");
}

// ID Stack Tool: Display UI
// [forward declared comment]:
// create Stack Tool window. hover items with mouse to query information about the source of their unique ID.
ShowIDStackToolWindow :: proc(p_open : ^bool = nil)
{
    g := GImGui;
    if ((.HasSize not_in g.NextWindowData.Flags)) {
        SetNextWindowSize(ImVec2{0.0, GetFontSize() * 8.0}, { .FirstUseEver });
    }

    if (!Begin("Dear ImGui ID Stack Tool", p_open) || GetCurrentWindow()->BeginCount > 1)
    {
        End();
        return;
    }

    // Display hovered/active status
    tool := &g.DebugIDStackTool;
    hovered_id := g.HoveredIdPreviousFrame;
    active_id := g.ActiveId;
when IMGUI_ENABLE_TEST_ENGINE {
    Text("HoveredId: 0x%08X (\"%s\"), ActiveId:  0x%08X (\"%s\")", hovered_id, hovered_id ? ImGuiTestEngine_FindItemDebugLabel(g, hovered_id) : "", active_id, active_id ? ImGuiTestEngine_FindItemDebugLabel(g, active_id) : "");
} else {
    Text("HoveredId: 0x%08X, ActiveId:  0x%08X", hovered_id, active_id);
}
    SameLine();
    MetricsHelpMarker("Hover an item with the mouse to display elements of the ID Stack leading to the item's final ID.\nEach level of the stack correspond to a PushID() call.\nAll levels of the stack are hashed together to make the final ID of a widget (ID displayed at the bottom level of the stack).\nRead FAQ entry about the ID stack for details.");

    // CTRL+C to copy path
    time_since_copy := cast(f32) g.Time - tool.CopyToClipboardLastTime;
    Checkbox("Ctrl+C: copy path to clipboard", &tool.CopyToClipboardOnCtrlC);
    SameLine();
    TextColored((time_since_copy >= 0.0 && time_since_copy < 0.75 && ImFmod(time_since_copy, 0.25) < 0.25 * 0.5) ? ImVec4{1.0, 1.0, 0.3, 1.00} : ImVec4{}, "*COPIED*");
    if (tool.CopyToClipboardOnCtrlC && Shortcut(ImGuiKey.Mod_Ctrl | ImGuiKey.C, {RouteGlobal, RouteOverFocused}))
    {
        tool.CopyToClipboardLastTime = cast(f32) g.Time;
        p := g.TempBuffer.Data;
        p_end := p + len(g.TempBuffer);
        for stack_n : i32 = 0; stack_n < len(tool.Results) && p + 3 < p_end; stack_n += 1
        {
            p^ = '/';
            p += 1
            level_desc : [256]u8;
            StackToolFormatLevelInfo(tool, stack_n, false, level_desc, len(level_desc));
            for n := 0; level_desc[n] && p + 2 < p_end; n += 1
            {
                if (level_desc[n] == '/')  {
                    p^ = '\\'
                    p += 1
                }
                p^ = level_desc[n];
                p += 1
            }
        }
        p^ = nil;
        SetClipboardText(g.TempBuffer.Data);
    }

    // Display decorated stack
    tool.LastActiveFrame = g.FrameCount;
    if (len(tool.Results) > 0 && BeginTable("##table", 3, ImGuiTableFlags_Borders))
    {
        id_width := CalcTextSize("0xDDDDDDDD").x;
        TableSetupColumn("Seed", ImGuiTableColumnFlags_WidthFixed, id_width);
        TableSetupColumn("PushID", ImGuiTableColumnFlags_WidthStretch);
        TableSetupColumn("Result", ImGuiTableColumnFlags_WidthFixed, id_width);
        TableHeadersRow();
        for n := 0; n < len(tool.Results); n += 1
        {
            info := &tool.Results[n];
            TableNextColumn();
            Text("0x%08X", (n > 0) ? tool.Results[n - 1].ID : 0);
            TableNextColumn();
            StackToolFormatLevelInfo(tool, n, true, g.TempBuffer.Data, g.TempBuffer.Size);
            TextUnformatted(g.TempBuffer.Data);
            TableNextColumn();
            Text("0x%08X", info.ID);
            if (n == len(tool.Results) - 1) {
                TableSetBgColor(ImGuiTableBgTarget_CellBg, GetColorU32(ImGuiCol.Header));
            }

        }
        EndTable();
    }
    End();
}

} else {

ShowMetricsWindow :: proc(_ : ^bool) {}
ShowFontAtlas :: proc(_ : ^ImFontAtlas) {}
DebugNodeColumns :: proc(_ : ^ImGuiOldColumns) {}
DebugNodeDrawList :: proc(_ : ^ImGuiWindow, _ : ^ImGuiViewportP, _ : ^ImDrawList, _ : ^u8) {}
DebugNodeDrawCmdShowMeshAndBoundingBox :: proc(_ : ^ImDrawList, _ : ^ImDrawList, _ : ^ImDrawCmd, _ : bool, _ : bool) {}
DebugNodeFont :: proc(_ : ^ImFont) {}
DebugNodeStorage :: proc(_ : ^ImGuiStorage, _ : ^u8) {}
DebugNodeTabBar :: proc(_ : ^ImGuiTabBar, _ : ^u8) {}
DebugNodeWindow :: proc(_ : ^ImGuiWindow, _ : ^u8) {}
DebugNodeWindowSettings :: proc(_ : ^ImGuiWindowSettings) {}
DebugNodeWindowsList :: proc(_ : ^[dynamic]^ImGuiWindow, _ : ^u8) {}
DebugNodeViewport :: proc(_ : ^ImGuiViewportP) {}

ShowDebugLogWindow :: proc(_ : ^bool) {}
ShowIDStackToolWindow :: proc(_ : ^bool) {}
DebugStartItemPicker :: proc() {}
DebugHookIdInfo :: proc(_ : ImGuiID, _ : ImGuiDataType, _ : rawptr, _ : rawptr) {}

} // #ifndef IMGUI_DISABLE_DEBUG_TOOLS

//-----------------------------------------------------------------------------
