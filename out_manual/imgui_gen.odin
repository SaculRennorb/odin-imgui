package test

import "base:intrinsics"
import "base:builtin"
import "core:math"
import "core:strconv"
import "core:os"
import "core:slice"
import "core:fmt"

has_target_feature :: intrinsics.has_target_feature
type_elem_type :: intrinsics.type_elem_type

// dear imgui, v1.91.7 WIP
// (main code and documentation)

// Help:
// - See links below.
// - Call and read ImGui::ShowDemoWindow() in imgui_demo.cpp. All applications in examples/ are doing that.
// - Read top of imgui.cpp for more details, links and comments.

// Resources:
// - FAQ ........................ https://dearimgui.com/faq (in repository as docs/FAQ.md)
// - Homepage ................... https://github.com/ocornut/imgui
// - Releases & changelog ....... https://github.com/ocornut/imgui/releases
// - Gallery .................... https://github.com/ocornut/imgui/issues?q=label%3Agallery (please post your screenshots/video there!)
// - Wiki ....................... https://github.com/ocornut/imgui/wiki (lots of good stuff there)
//   - Getting Started            https://github.com/ocornut/imgui/wiki/Getting-Started (how to integrate in an existing app by adding ~25 lines of code)
//   - Third-party Extensions     https://github.com/ocornut/imgui/wiki/Useful-Extensions (ImPlot & many more)
//   - Bindings/Backends          https://github.com/ocornut/imgui/wiki/Bindings (language bindings, backends for various tech/engines)
//   - Glossary                   https://github.com/ocornut/imgui/wiki/Glossary
//   - Debug Tools                https://github.com/ocornut/imgui/wiki/Debug-Tools
//   - Software using Dear ImGui  https://github.com/ocornut/imgui/wiki/Software-using-dear-imgui
// - Issues & support ........... https://github.com/ocornut/imgui/issues
// - Test Engine & Automation ... https://github.com/ocornut/imgui_test_engine (test suite, test engine to automate your apps)

// For first-time users having issues compiling/linking/running/loading fonts:
// please post in https://github.com/ocornut/imgui/discussions if you cannot find a solution in resources above.
// Everything else should be asked in 'Issues'! We are building a database of cross-linked knowledge there.

// Copyright (c) 2014-2025 Omar Cornut
// Developed by Omar Cornut and every direct or indirect contributors to the GitHub.
// See LICENSE.txt for copyright and licensing details (standard MIT License).
// This library is free but needs your support to sustain development and maintenance.
// Businesses: you can support continued development via B2B invoiced technical support, maintenance and sponsoring contracts.
// PLEASE reach out at omar AT dearimgui DOT com. See https://github.com/ocornut/imgui/wiki/Funding
// Businesses: you can also purchase licenses for the Dear ImGui Automation/Test Engine.

// It is recommended that you don't modify imgui.cpp! It will become difficult for you to update the library.
// Note that 'ImGui::' being a namespace, you can add functions into the namespace from your own source files, without
// modifying imgui.h or imgui.cpp. You may include imgui_internal.h to access internal data structures, but it doesn't
// come with any guarantee of forward compatibility. Discussing your changes on the GitHub Issue Tracker may lead you
// to a better solution or official support for them.

/*

Index of this file:

DOCUMENTATION

- MISSION STATEMENT
- CONTROLS GUIDE
- PROGRAMMER GUIDE
  - READ FIRST
  - HOW TO UPDATE TO A NEWER VERSION OF DEAR IMGUI
  - GETTING STARTED WITH INTEGRATING DEAR IMGUI IN YOUR CODE/ENGINE
  - HOW A SIMPLE APPLICATION MAY LOOK LIKE
  - HOW A SIMPLE RENDERING FUNCTION MAY LOOK LIKE
- API BREAKING CHANGES (read me when you update!)
- FREQUENTLY ASKED QUESTIONS (FAQ)
  - Read all answers online: https://www.dearimgui.com/faq, or in docs/FAQ.md (with a Markdown viewer)

CODE
(search for "[SECTION]" in the code to find them)

// [SECTION] INCLUDES
// [SECTION] FORWARD DECLARATIONS
// [SECTION] CONTEXT AND MEMORY ALLOCATORS
// [SECTION] USER FACING STRUCTURES (ImGuiStyle, ImGuiIO, ImGuiPlatformIO)
// [SECTION] MISC HELPERS/UTILITIES (Geometry functions)
// [SECTION] MISC HELPERS/UTILITIES (String, Format, Hash functions)
// [SECTION] MISC HELPERS/UTILITIES (File functions)
// [SECTION] MISC HELPERS/UTILITIES (ImText* functions)
// [SECTION] MISC HELPERS/UTILITIES (Color functions)
// [SECTION] ImGuiStorage
// [SECTION] ImGuiTextFilter
// [SECTION] ImGuiTextBuffer, ImGuiTextIndex
// [SECTION] ImGuiListClipper
// [SECTION] STYLING
// [SECTION] RENDER HELPERS
// [SECTION] INITIALIZATION, SHUTDOWN
// [SECTION] MAIN CODE (most of the code! lots of stuff, needs tidying up!)
// [SECTION] ID STACK
// [SECTION] INPUTS
// [SECTION] ERROR CHECKING, STATE RECOVERY
// [SECTION] ITEM SUBMISSION
// [SECTION] LAYOUT
// [SECTION] SCROLLING
// [SECTION] TOOLTIPS
// [SECTION] POPUPS
// [SECTION] WINDOW FOCUS
// [SECTION] KEYBOARD/GAMEPAD NAVIGATION
// [SECTION] DRAG AND DROP
// [SECTION] LOGGING/CAPTURING
// [SECTION] SETTINGS
// [SECTION] LOCALIZATION
// [SECTION] VIEWPORTS, PLATFORM WINDOWS
// [SECTION] DOCKING
// [SECTION] PLATFORM DEPENDENT HELPERS
// [SECTION] METRICS/DEBUGGER WINDOW
// [SECTION] DEBUG LOG WINDOW
// [SECTION] OTHER DEBUG TOOLS (ITEM PICKER, ID STACK TOOL)

*/

//-----------------------------------------------------------------------------
// DOCUMENTATION
//-----------------------------------------------------------------------------

/*

 MISSION STATEMENT
 =================

 - Easy to use to create code-driven and data-driven tools.
 - Easy to use to create ad hoc short-lived tools and long-lived, more elaborate tools.
 - Easy to hack and improve.
 - Minimize setup and maintenance.
 - Minimize state storage on user side.
 - Minimize state synchronization.
 - Portable, minimize dependencies, run on target (consoles, phones, etc.).
 - Efficient runtime and memory consumption.

 Designed primarily for developers and content-creators, not the typical end-user!
 Some of the current weaknesses (which we aim to address in the future) includes:

 - Doesn't look fancy.
 - Limited layout features, intricate layouts are typically crafted in code.


 CONTROLS GUIDE
 ==============

 - MOUSE CONTROLS
   - Mouse wheel:                   Scroll vertically.
   - SHIFT+Mouse wheel:             Scroll horizontally.
   - Click [X]:                     Close a window, available when 'bool* p_open' is passed to ImGui::Begin().
   - Click ^, Double-Click title:   Collapse window.
   - Drag on corner/border:         Resize window (double-click to auto fit window to its contents).
   - Drag on any empty space:       Move window (unless io.ConfigWindowsMoveFromTitleBarOnly = true).
   - Left-click outside popup:      Close popup stack (right-click over underlying popup: Partially close popup stack).

 - TEXT EDITOR
   - Hold SHIFT or Drag Mouse:      Select text.
   - CTRL+Left/Right:               Word jump.
   - CTRL+Shift+Left/Right:         Select words.
   - CTRL+A or Double-Click:        Select All.
   - CTRL+X, CTRL+C, CTRL+V:        Use OS clipboard.
   - CTRL+Z, CTRL+Y:                Undo, Redo.
   - ESCAPE:                        Revert text to its original value.
   - On OSX, controls are automatically adjusted to match standard OSX text editing 2ts and behaviors.

 - KEYBOARD CONTROLS
   - Basic:
     - Tab, SHIFT+Tab               Cycle through text editable fields.
     - CTRL+Tab, CTRL+Shift+Tab     Cycle through windows.
     - CTRL+Click                   Input text into a Slider or Drag widget.
   - Extended features with `io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard`:
     - Tab, SHIFT+Tab:              Cycle through every items.
     - Arrow keys                   Move through items using directional navigation. Tweak value.
     - Arrow keys + Alt, Shift      Tweak slower, tweak faster (when using arrow keys).
     - Enter                        Activate item (prefer text input when possible).
     - Space                        Activate item (prefer tweaking with arrows when possible).
     - Escape                       Deactivate item, leave child window, close popup.
     - Page Up, Page Down           Previous page, next page.
     - Home, End                    Scroll to top, scroll to bottom.
     - Alt                          Toggle between scrolling layer and menu layer.
     - CTRL+Tab then Ctrl+Arrows    Move window. Hold SHIFT to resize instead of moving.
   - Output when ImGuiConfigFlags_NavEnableKeyboard set,
     - io.WantCaptureKeyboard flag is set when keyboard is claimed.
     - io.NavActive: true when a window is focused and it doesn't have the ImGuiWindowFlags_NoNavInputs flag set.
     - io.NavVisible: true when the navigation cursor is visible (usually goes to back false when mouse is used).

 - GAMEPAD CONTROLS
   - Enable with 'io.ConfigFlags |= ImGuiConfigFlags_NavEnableGamepad'.
   - Particularly useful to use Dear ImGui on a console system (e.g. PlayStation, Switch, Xbox) without a mouse!
   - Download controller mapping PNG/PSD at http://dearimgui.com/controls_sheets
   - Backend support: backend needs to:
      - Set 'io.BackendFlags |= ImGuiBackendFlags_HasGamepad' + call io.AddKeyEvent/AddKeyAnalogEvent() with ImGuiKey_Gamepad_XXX keys.
      - For analog values (0.0f to 1.0f), backend is responsible to handling a dead-zone and rescaling inputs accordingly.
        Backend code will probably need to transform your raw inputs (such as e.g. remapping your 0.2..0.9 raw input range to 0.0..1.0 imgui range, etc.).
   - If you need to share inputs between your game and the Dear ImGui interface, the easiest approach is to go all-or-nothing,
     with a buttons combo to toggle the target. Please reach out if you think the game vs navigation input sharing could be improved.

 - REMOTE INPUTS SHARING & MOUSE EMULATION
   - PS4/PS5 users: Consider emulating a mouse cursor with DualShock touch pad or a spare analog stick as a mouse-emulation fallback.
   - Consoles/Tablet/Phone users: Consider using a Synergy 1.x server (on your PC) + run examples/libs/synergy/uSynergy.c (on your console/tablet/phone app)
     in order to share your PC mouse/keyboard.
   - See https://github.com/ocornut/imgui/wiki/Useful-Extensions#remoting for other remoting solutions.
   - On a TV/console system where readability may be lower or mouse inputs may be awkward, you may want to set the io.ConfigNavMoveSetMousePos flag.
     Enabling io.ConfigNavMoveSetMousePos + ImGuiBackendFlags_HasSetMousePos instructs Dear ImGui to move your mouse cursor along with navigation movements.
     When enabled, the NewFrame() function may alter 'io.MousePos' and set 'io.WantSetMousePos' to notify you that it wants the mouse cursor to be moved.
     When that happens your backend NEEDS to move the OS or underlying mouse cursor on the next frame. Some of the backends in examples/ do that.
     (If you set the NavEnableSetMousePos flag but don't honor 'io.WantSetMousePos' properly, Dear ImGui will misbehave as it will see your mouse moving back & forth!)
     (In a setup when you may not have easy control over the mouse cursor, e.g. uSynergy.c doesn't expose moving remote mouse cursor, you may want
     to set a boolean to ignore your other external mouse positions until the external source is moved again.)


 PROGRAMMER GUIDE
 ================

 READ FIRST
 ----------
 - Remember to check the wonderful Wiki (https://github.com/ocornut/imgui/wiki)
 - Your code creates the UI every frame of your application loop, if your code doesn't run the UI is gone!
   The UI can be highly dynamic, there are no construction or destruction steps, less superfluous
   data retention on your side, less state duplication, less state synchronization, fewer bugs.
 - Call and read ImGui::ShowDemoWindow() for demo code demonstrating most features.
   Or browse https://pthom.github.io/imgui_manual_online/manual/imgui_manual.html for interactive web version.
 - The library is designed to be built from sources. Avoid pre-compiled binaries and packaged versions. See imconfig.h to configure your build.
 - Dear ImGui is an implementation of the IMGUI paradigm (immediate-mode graphical user interface, a term coined by Casey Muratori).
   You can learn about IMGUI principles at http://www.johno.se/book/imgui.html, http://mollyrocket.com/861 & more links in Wiki.
 - Dear ImGui is a "single pass" rasterizing implementation of the IMGUI paradigm, aimed at ease of use and high-performances.
   For every application frame, your UI code will be called only once. This is in contrast to e.g. Unity's implementation of an IMGUI,
   where the UI code is called multiple times ("multiple passes") from a single entry point. There are pros and cons to both approaches.
 - Our origin is on the top-left. In axis aligned bounding boxes, Min = top-left, Max = bottom-right.
 - Please make sure you have asserts enabled (IM_ASSERT redirects to assert() by default, but can be redirected).
   If you get an assert, read the messages and comments around the assert.
 - This codebase aims to be highly optimized:
   - A typical idle frame should never call malloc/free.
   - We rely on a maximum of constant-time or O(N) algorithms. Limiting searches/scans as much as possible.
   - We put particular energy in making sure performances are decent with typical "Debug" build settings as well.
     Which mean we tend to avoid over-relying on "zero-cost abstraction" as they aren't zero-cost at all.
 - This codebase aims to be both highly opinionated and highly flexible:
   - This code works because of the things it choose to solve or not solve.
   - C++: this is a pragmatic C-ish codebase: we don't use fancy C++ features, we don't include C++ headers,
     and ImGui:: is a namespace. We rarely use member functions (and when we did, I am mostly regretting it now).
     This is to increase compatibility, increase maintainability and facilitate use from other languages.
   - C++: ImVec2/ImVec4 do not expose math operators by default, because it is expected that you use your own math types.
     See FAQ "How can I use my own math types instead of ImVec2/ImVec4?" for details about setting up imconfig.h for that.
     We can can optionally export math operators for ImVec2/ImVec4 using IMGUI_DEFINE_MATH_OPERATORS, which we use internally.
   - C++: pay attention that ImVector<> manipulates plain-old-data and does not honor construction/destruction
     (so don't use ImVector in your code or at our own risk!).
   - Building: We don't use nor mandate a build system for the main library.
     This is in an effort to ensure that it works in the real world aka with any esoteric build setup.
     This is also because providing a build system for the main library would be of little-value.
     The build problems are almost never coming from the main library but from specific backends.


 HOW TO UPDATE TO A NEWER VERSION OF DEAR IMGUI
 ----------------------------------------------
 - Update submodule or copy/overwrite every file.
 - About imconfig.h:
   - You may modify your copy of imconfig.h, in this case don't overwrite it.
   - or you may locally branch to modify imconfig.h and merge/rebase latest.
   - or you may '#define IMGUI_USER_CONFIG "my_config_file.h"' globally from your build system to
     specify a custom path for your imconfig.h file and instead not have to modify the default one.

 - Overwrite all the sources files except for imconfig.h (if you have modified your copy of imconfig.h)
 - Or maintain your own branch where you have imconfig.h modified as a top-most commit which you can regularly rebase over "master".
 - You can also use '#define IMGUI_USER_CONFIG "my_config_file.h" to redirect configuration to your own file.
 - Read the "API BREAKING CHANGES" section (below). This is where we list occasional API breaking changes.
   If a function/type has been renamed / or marked obsolete, try to fix the name in your code before it is permanently removed
   from the public API. If you have a problem with a missing function/symbols, search for its name in the code, there will
   likely be a comment about it. Please report any issue to the GitHub page!
 - To find out usage of old API, you can add '#define IMGUI_DISABLE_OBSOLETE_FUNCTIONS' in your configuration file.
 - Try to keep your copy of Dear ImGui reasonably up to date!


 GETTING STARTED WITH INTEGRATING DEAR IMGUI IN YOUR CODE/ENGINE
 ---------------------------------------------------------------
 - See https://github.com/ocornut/imgui/wiki/Getting-Started.
 - Run and study the examples and demo in imgui_demo.cpp to get acquainted with the library.
 - In the majority of cases you should be able to use unmodified backends files available in the backends/ folder.
 - Add the Dear ImGui source files + selected backend source files to your projects or using your preferred build system.
   It is recommended you build and statically link the .cpp files as part of your project and NOT as a shared library (DLL).
 - You can later customize the imconfig.h file to tweak some compile-time behavior, such as integrating Dear ImGui types with your own maths types.
 - When using Dear ImGui, your programming IDE is your friend: follow the declaration of variables, functions and types to find comments about them.
 - Dear ImGui never touches or knows about your GPU state. The only function that knows about GPU is the draw function that you provide.
   Effectively it means you can create widgets at any time in your code, regardless of considerations of being in "update" vs "render"
   phases of your own application. All rendering information is stored into command-lists that you will retrieve after calling ImGui::Render().
 - Refer to the backends and demo applications in the examples/ folder for instruction on how to setup your code.
 - If you are running over a standard OS with a common graphics API, you should be able to use unmodified imgui_impl_*** files from the examples/ folder.


 HOW A SIMPLE APPLICATION MAY LOOK LIKE
 --------------------------------------
 EXHIBIT 1: USING THE EXAMPLE BACKENDS (= imgui_impl_XXX.cpp files from the backends/ folder).
 The sub-folders in examples/ contain examples applications following this structure.

     // Application init: create a dear imgui context, setup some options, load fonts
     ImGui::CreateContext();
     ImGuiIO& io = ImGui::GetIO();
     // TODO: Set optional io.ConfigFlags values, e.g. 'io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard' to enable keyboard controls.
     // TODO: Fill optional fields of the io structure later.
     // TODO: Load TTF/OTF fonts if you don't want to use the default font.

     // Initialize helper Platform and Renderer backends (here we are using imgui_impl_win32.cpp and imgui_impl_dx11.cpp)
     ImGui_ImplWin32_Init(hwnd);
     ImGui_ImplDX11_Init(g_pd3dDevice, g_pd3dDeviceContext);

     // Application main loop
     while (true)
     {
         // Feed inputs to dear imgui, start new frame
         ImGui_ImplDX11_NewFrame();
         ImGui_ImplWin32_NewFrame();
         ImGui::NewFrame();

         // Any application code here
         ImGui::Text("Hello, world!");

         // Render dear imgui into screen
         ImGui::Render();
         ImGui_ImplDX11_RenderDrawData(ImGui::GetDrawData());
         g_pSwapChain->Present(1, 0);
     }

     // Shutdown
     ImGui_ImplDX11_Shutdown();
     ImGui_ImplWin32_Shutdown();
     ImGui::DestroyContext();

 EXHIBIT 2: IMPLEMENTING CUSTOM BACKEND / CUSTOM ENGINE

     // Application init: create a dear imgui context, setup some options, load fonts
     ImGui::CreateContext();
     ImGuiIO& io = ImGui::GetIO();
     // TODO: Set optional io.ConfigFlags values, e.g. 'io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard' to enable keyboard controls.
     // TODO: Fill optional fields of the io structure later.
     // TODO: Load TTF/OTF fonts if you don't want to use the default font.

     // Build and load the texture atlas into a texture
     // (In the examples/ app this is usually done within the ImGui_ImplXXX_Init() function from one of the demo Renderer)
     int width, height;
     unsigned char* pixels = nullptr;
     io.Fonts->GetTexDataAsRGBA32(&pixels, &width, &height);

     // At this point you've got the texture data and you need to upload that to your graphic system:
     // After we have created the texture, store its pointer/identifier (_in whichever format your engine uses_) in 'io.Fonts->TexID'.
     // This will be passed back to your via the renderer. Basically ImTextureID == void*. Read FAQ for details about ImTextureID.
     MyTexture* texture = MyEngine::CreateTextureFromMemoryPixels(pixels, width, height, TEXTURE_TYPE_RGBA32)
     io.Fonts->SetTexID((void*)texture);

     // Application main loop
     while (true)
     {
        // Setup low-level inputs, e.g. on Win32: calling GetKeyboardState(), or write to those fields from your Windows message handlers, etc.
        // (In the examples/ app this is usually done within the ImGui_ImplXXX_NewFrame() function from one of the demo Platform Backends)
        io.DeltaTime = 1.0f/60.0f;              // set the time elapsed since the previous frame (in seconds)
        io.DisplaySize.x = 1920.0f;             // set the current display width
        io.DisplaySize.y = 1280.0f;             // set the current display height here
        io.AddMousePosEvent(mouse_x, mouse_y);  // update mouse position
        io.AddMouseButtonEvent(0, mouse_b[0]);  // update mouse button states
        io.AddMouseButtonEvent(1, mouse_b[1]);  // update mouse button states

        // Call NewFrame(), after this point you can use ImGui::* functions anytime
        // (So you want to try calling NewFrame() as early as you can in your main loop to be able to use Dear ImGui everywhere)
        ImGui::NewFrame();

        // Most of your application code here
        ImGui::Text("Hello, world!");
        MyGameUpdate(); // may use any Dear ImGui functions, e.g. ImGui::Begin("My window"); ImGui::Text("Hello, world!"); ImGui::End();
        MyGameRender(); // may use any Dear ImGui functions as well!

        // Render dear imgui, swap buffers
        // (You want to try calling EndFrame/Render as late as you can, to be able to use Dear ImGui in your own game rendering code)
        ImGui::EndFrame();
        ImGui::Render();
        ImDrawData* draw_data = ImGui::GetDrawData();
        MyImGuiRenderFunction(draw_data);
        SwapBuffers();
     }

     // Shutdown
     ImGui::DestroyContext();

 To decide whether to dispatch mouse/keyboard inputs to Dear ImGui to the rest of your application,
 you should read the 'io.WantCaptureMouse', 'io.WantCaptureKeyboard' and 'io.WantTextInput' flags!
 Please read the FAQ entry "How can I tell whether to dispatch mouse/keyboard to Dear ImGui or my application?" about this.


 HOW A SIMPLE RENDERING FUNCTION MAY LOOK LIKE
 ---------------------------------------------
 The backends in impl_impl_XXX.cpp files contain many working implementations of a rendering function.

    void MyImGuiRenderFunction(ImDrawData* draw_data)
    {
       // TODO: Setup render state: alpha-blending enabled, no face culling, no depth testing, scissor enabled
       // TODO: Setup texture sampling state: sample with bilinear filtering (NOT point/nearest filtering). Use 'io.Fonts->Flags |= ImFontAtlasFlags_NoBakedLines;' to allow point/nearest filtering.
       // TODO: Setup viewport covering draw_data->DisplayPos to draw_data->DisplayPos + draw_data->DisplaySize
       // TODO: Setup orthographic projection matrix cover draw_data->DisplayPos to draw_data->DisplayPos + draw_data->DisplaySize
       // TODO: Setup shader: vertex { float2 pos, float2 uv, u32 color }, fragment shader sample color from 1 texture, multiply by vertex color.
       ImVec2 clip_off = draw_data->DisplayPos;
       for (int n = 0; n < draw_data->CmdListsCount; n++)
       {
          const ImDrawList* cmd_list = draw_data->CmdLists[n];
          const ImDrawVert* vtx_buffer = cmd_list->VtxBuffer.Data;  // vertex buffer generated by Dear ImGui
          const ImDrawIdx* idx_buffer = cmd_list->IdxBuffer.Data;   // index buffer generated by Dear ImGui
          for (int cmd_i = 0; cmd_i < cmd_list->CmdBuffer.Size; cmd_i++)
          {
             const ImDrawCmd* pcmd = &cmd_list->CmdBuffer[cmd_i];
             if (pcmd->UserCallback)
             {
                 pcmd->UserCallback(cmd_list, pcmd);
             }
             else
             {
                 // Project scissor/clipping rectangles into framebuffer space
                 ImVec2 clip_min(pcmd->ClipRect.x - clip_off.x, pcmd->ClipRect.y - clip_off.y);
                 ImVec2 clip_max(pcmd->ClipRect.z - clip_off.x, pcmd->ClipRect.w - clip_off.y);
                 if (clip_max.x <= clip_min.x || clip_max.y <= clip_min.y)
                     continue;

                 // We are using scissoring to clip some objects. All low-level graphics API should support it.
                 // - If your engine doesn't support scissoring yet, you may ignore this at first. You will get some small glitches
                 //   (some elements visible outside their bounds) but you can fix that once everything else works!
                 // - Clipping coordinates are provided in imgui coordinates space:
                 //   - For a given viewport, draw_data->DisplayPos == viewport->Pos and draw_data->DisplaySize == viewport->Size
                 //   - In a single viewport application, draw_data->DisplayPos == (0,0) and draw_data->DisplaySize == io.DisplaySize, but always use GetMainViewport()->Pos/Size instead of hardcoding those values.
                 //   - In the interest of supporting multi-viewport applications (see 'docking' branch on github),
                 //     always subtract draw_data->DisplayPos from clipping bounds to convert them to your viewport space.
                 // - Note that pcmd->ClipRect contains Min+Max bounds. Some graphics API may use Min+Max, other may use Min+Size (size being Max-Min)
                 MyEngineSetScissor(clip_min.x, clip_min.y, clip_max.x, clip_max.y);

                 // The texture for the draw call is specified by pcmd->GetTexID().
                 // The vast majority of draw calls will use the Dear ImGui texture atlas, which value you have set yourself during initialization.
                 MyEngineBindTexture((MyTexture*)pcmd->GetTexID());

                 // Render 'pcmd->ElemCount/3' indexed triangles.
                 // By default the indices ImDrawIdx are 16-bit, you can change them to 32-bit in imconfig.h if your engine doesn't support 16-bit indices.
                 MyEngineDrawIndexedTriangles(pcmd->ElemCount, sizeof(ImDrawIdx) == 2 ? GL_UNSIGNED_SHORT : GL_UNSIGNED_INT, idx_buffer + pcmd->IdxOffset, vtx_buffer, pcmd->VtxOffset);
             }
          }
       }
    }


 API BREAKING CHANGES
 ====================

 Occasionally introducing changes that are breaking the API. We try to make the breakage minor and easy to fix.
 Below is a change-log of API breaking changes only. If you are using one of the functions listed, expect to have to fix some code.
 When you are not sure about an old symbol or function name, try using the Search/Find function of your IDE to look for comments or references in all imgui files.
 You can read releases logs https://github.com/ocornut/imgui/releases for more details.

(Docking/Viewport Branch)
 - 2024/XX/XX (1.XXXX) - when multi-viewports are enabled, all positions will be in your natural OS coordinates space. It means that:
                          - reference to hard-coded positions such as in SetNextWindowPos(ImVec2(0,0)) are probably not what you want anymore.
                            you may use GetMainViewport()->Pos to offset hard-coded positions, e.g. SetNextWindowPos(GetMainViewport()->Pos)
                          - likewise io.MousePos and GetMousePos() will use OS coordinates.
                            If you query mouse positions to interact with non-imgui coordinates you will need to offset them, e.g. subtract GetWindowViewport()->Pos.

 - 2024/11/27 (1.91.6) - changed CRC32 table from CRC32-adler to CRC32c polynomial in order to be compatible with the result of SSE 4.2 instructions.
                         As a result, old .ini data may be partially lost (docking and tables information particularly).
                         Because some users have crafted and storing .ini data as a way to workaround limitations of the docking API, we are providing a '#define IMGUI_USE_LEGACY_CRC32_ADLER' compile-time option to keep using old CRC32 tables if you cannot afford invalidating old .ini data.
 - 2024/11/06 (1.91.5) - commented/obsoleted out pre-1.87 IO system (equivalent to using IMGUI_DISABLE_OBSOLETE_KEYIO or IMGUI_DISABLE_OBSOLETE_FUNCTIONS before)
                            - io.KeyMap[] and io.KeysDown[] are removed (obsoleted February 2022).
                            - io.NavInputs[] and ImGuiNavInput are removed (obsoleted July 2022).
                            - pre-1.87 backends are not supported:
                               - backends need to call io.AddKeyEvent(), io.AddMouseEvent() instead of writing to io.KeysDown[], io.MouseDown[] fields.
                               - backends need to call io.AddKeyAnalogEvent() for gamepad values instead of writing to io.NavInputs[] fields.
                            - for more reference:
                              - read 1.87 and 1.88 part of this section or read Changelog for 1.87 and 1.88.
                              - read https://github.com/ocornut/imgui/issues/4921
                            - if you have trouble updating a very old codebase using legacy backend-specific key codes: consider updating to 1.91.4 first, then #define IMGUI_DISABLE_OBSOLETE_KEYIO, then update to latest.
                       - obsoleted ImGuiKey_COUNT (it is unusually error-prone/misleading since valid keys don't start at 0). probably use ImGuiKey_NamedKey_BEGIN/ImGuiKey_NamedKey_END?
                       - fonts: removed const qualifiers from most font functions in prevision for upcoming font improvements.
 - 2024/10/18 (1.91.4) - renamed ImGuiCol_NavHighlight to ImGuiCol_NavCursor (for consistency with newly exposed and reworked features). Kept inline redirection enum (will obsolete).
 - 2024/10/14 (1.91.4) - moved ImGuiConfigFlags_NavEnableSetMousePos to standalone io.ConfigNavMoveSetMousePos bool.
                         moved ImGuiConfigFlags_NavNoCaptureKeyboard to standalone io.ConfigNavCaptureKeyboard bool (note the inverted value!).
                         kept legacy names (will obsolete) + code that copies settings once the first time. Dynamically changing the old value won't work. Switch to using the new value!
 - 2024/10/10 (1.91.4) - the typedef for ImTextureID now defaults to ImU64 instead of void*. (#1641)
                         this removes the requirement to redefine it for backends which are e.g. storing descriptor sets or other 64-bits structures when building on 32-bits archs. It therefore simplify various building scripts/helpers.
                         you may have compile-time issues if you were casting to 'void*' instead of 'ImTextureID' when passing your types to functions taking ImTextureID values, e.g. ImGui::Image().
                         in doubt it is almost always better to do an intermediate intptr_t cast, since it allows casting any pointer/integer type without warning:
                            - May warn:    ImGui::Image((void*)MyTextureData, ...);
                            - May warn:    ImGui::Image((void*)(intptr_t)MyTextureData, ...);
                            - Won't warn:  ImGui::Image((ImTextureID)(intptr_t)MyTextureData), ...);
  -                      note that you can always define ImTextureID to be your own high-level structures (with dedicated constructors) if you like.
 - 2024/10/03 (1.91.3) - drags: treat v_min==v_max as a valid clamping range when != 0.0f. Zero is a still special value due to legacy reasons, unless using ImGuiSliderFlags_ClampZeroRange. (#7968, #3361, #76)
                       - drags: extended behavior of ImGuiSliderFlags_AlwaysClamp to include _ClampZeroRange. It considers v_min==v_max==0.0f as a valid clamping range (aka edits not allowed).
                         although unlikely, it you wish to only clamp on text input but want v_min==v_max==0.0f to mean unclamped drags, you can use _ClampOnInput instead of _AlwaysClamp. (#7968, #3361, #76)
 - 2024/09/10 (1.91.2) - internals: using multiple overlayed ButtonBehavior() with same ID will now have io.ConfigDebugHighlightIdConflicts=true feature emit a warning. (#8030)
                         it was one of the rare case where using same ID is legal. workarounds: (1) use single ButtonBehavior() call with multiple _MouseButton flags, or (2) surround the calls with PushItemFlag(ImGuiItemFlags_AllowDuplicateId, true); ... PopItemFlag()
 - 2024/08/23 (1.91.1) - renamed ImGuiChildFlags_Border to ImGuiChildFlags_Borders for consistency. kept inline redirection flag.
 - 2024/08/22 (1.91.1) - moved some functions from ImGuiIO to ImGuiPlatformIO structure:
                            - io.GetClipboardTextFn         -> platform_io.Platform_GetClipboardTextFn + changed 'void* user_data' to 'ImGuiContext* ctx'. Pull your user data from platform_io.ClipboardUserData.
                            - io.SetClipboardTextFn         -> platform_io.Platform_SetClipboardTextFn + same as above line.
                            - io.PlatformOpenInShellFn      -> platform_io.Platform_OpenInShellFn (#7660)
                            - io.PlatformSetImeDataFn       -> platform_io.Platform_SetImeDataFn
                            - io.PlatformLocaleDecimalPoint -> platform_io.Platform_LocaleDecimalPoint (#7389, #6719, #2278)
                            - access those via GetPlatformIO() instead of GetIO().
                         some were introduced very recently and often automatically setup by core library and backends, so for those we are exceptionally not maintaining a legacy redirection symbol.
                       - commented the old ImageButton() signature obsoleted in 1.89 (~August 2022). As a reminder:
                            - old ImageButton() before 1.89 used ImTextureId as item id (created issue with e.g. multiple buttons in same scope, transient texture id values, opaque computation of ID)
                            - new ImageButton() since 1.89 requires an explicit 'const char* str_id'
                            - old ImageButton() before 1.89 had frame_padding' override argument.
                            - new ImageButton() since 1.89 always use style.FramePadding, which you can freely override with PushStyleVar()/PopStyleVar().
 - 2024/07/25 (1.91.0) - obsoleted GetContentRegionMax(), GetWindowContentRegionMin() and GetWindowContentRegionMax(). (see #7838 on GitHub for more info)
                         you should never need those functions. you can do everything with GetCursorScreenPos() and GetContentRegionAvail() in a more simple way.
                            - instead of:  GetWindowContentRegionMax().x - GetCursorPos().x
                            - you can use: GetContentRegionAvail().x
                            - instead of:  GetWindowContentRegionMax().x + GetWindowPos().x
                            - you can use: GetCursorScreenPos().x + GetContentRegionAvail().x // when called from left edge of window
                            - instead of:  GetContentRegionMax()
                            - you can use: GetContentRegionAvail() + GetCursorScreenPos() - GetWindowPos() // right edge in local coordinates
                            - instead of:  GetWindowContentRegionMax().x - GetWindowContentRegionMin().x
                            - you can use: GetContentRegionAvail() // when called from left edge of window
 - 2024/07/15 (1.91.0) - renamed ImGuiSelectableFlags_DontClosePopups to ImGuiSelectableFlags_NoAutoClosePopups. (#1379, #1468, #2200, #4936, #5216, #7302, #7573)
                         (internals: also renamed ImGuiItemFlags_SelectableDontClosePopup into ImGuiItemFlags_AutoClosePopups with inverted behaviors)
 - 2024/07/15 (1.91.0) - obsoleted PushButtonRepeat()/PopButtonRepeat() in favor of using new PushItemFlag(ImGuiItemFlags_ButtonRepeat, ...)/PopItemFlag().
 - 2024/07/02 (1.91.0) - commented out obsolete ImGuiModFlags (renamed to ImGuiKeyChord in 1.89). (#4921, #456)
                       - commented out obsolete ImGuiModFlags_XXX values (renamed to ImGuiMod_XXX in 1.89). (#4921, #456)
                            - ImGuiModFlags_Ctrl -> ImGuiMod_Ctrl, ImGuiModFlags_Shift -> ImGuiMod_Shift etc.
 - 2024/07/02 (1.91.0) - IO, IME: renamed platform IME hook and added explicit context for consistency and future-proofness.
                            - old: io.SetPlatformImeDataFn(ImGuiViewport* viewport, ImGuiPlatformImeData* data);
                            - new: io.PlatformSetImeDataFn(ImGuiContext* ctx, ImGuiViewport* viewport, ImGuiPlatformImeData* data);
 - 2024/06/21 (1.90.9) - BeginChild: added ImGuiChildFlags_NavFlattened as a replacement for the window flag ImGuiWindowFlags_NavFlattened: the feature only ever made sense for BeginChild() anyhow.
                            - old: BeginChild("Name", size, 0, ImGuiWindowFlags_NavFlattened);
                            - new: BeginChild("Name", size, ImGuiChildFlags_NavFlattened, 0);
 - 2024/06/21 (1.90.9) - io: ClearInputKeys() (first exposed in 1.89.8) doesn't clear mouse data, newly added ClearInputMouse() does.
 - 2024/06/20 (1.90.9) - renamed ImGuiDragDropFlags_SourceAutoExpirePayload to ImGuiDragDropFlags_PayloadAutoExpire.
 - 2024/06/18 (1.90.9) - style: renamed ImGuiCol_TabActive -> ImGuiCol_TabSelected, ImGuiCol_TabUnfocused -> ImGuiCol_TabDimmed, ImGuiCol_TabUnfocusedActive -> ImGuiCol_TabDimmedSelected.
 - 2024/06/10 (1.90.9) - removed old nested structure: renaming ImGuiStorage::ImGuiStoragePair type to ImGuiStoragePair (simpler for many languages).
 - 2024/06/06 (1.90.8) - reordered ImGuiInputTextFlags values. This should not be breaking unless you are using generated headers that have values not matching the main library.
 - 2024/06/06 (1.90.8) - removed 'ImGuiButtonFlags_MouseButtonDefault_ = ImGuiButtonFlags_MouseButtonLeft', was mostly unused and misleading.
 - 2024/05/27 (1.90.7) - commented out obsolete symbols marked obsolete in 1.88 (May 2022):
                            - old: CaptureKeyboardFromApp(bool)
                            - new: SetNextFrameWantCaptureKeyboard(bool)
                            - old: CaptureMouseFromApp(bool)
                            - new: SetNextFrameWantCaptureMouse(bool)
 - 2024/05/22 (1.90.7) - inputs (internals): renamed ImGuiKeyOwner_None to ImGuiKeyOwner_NoOwner, to make use more explicit and reduce confusion with the default it is a non-zero value and cannot be the default value (never made public, but disclosing as I expect a few users caught on owner-aware inputs).
                       - inputs (internals): renamed ImGuiInputFlags_RouteGlobalLow -> ImGuiInputFlags_RouteGlobal, ImGuiInputFlags_RouteGlobal -> ImGuiInputFlags_RouteGlobalOverFocused, ImGuiInputFlags_RouteGlobalHigh -> ImGuiInputFlags_RouteGlobalHighest.
                       - inputs (internals): Shortcut(), SetShortcutRouting(): swapped last two parameters order in function signatures:
                            - old: Shortcut(ImGuiKeyChord key_chord, ImGuiID owner_id = 0, ImGuiInputFlags flags = 0);
                            - new: Shortcut(ImGuiKeyChord key_chord, ImGuiInputFlags flags = 0, ImGuiID owner_id = 0);
                       - inputs (internals): owner-aware versions of IsKeyPressed(), IsKeyChordPressed(), IsMouseClicked(): swapped last two parameters order in function signatures.
                            - old: IsKeyPressed(ImGuiKey key, ImGuiID owner_id, ImGuiInputFlags flags = 0);
                            - new: IsKeyPressed(ImGuiKey key, ImGuiInputFlags flags, ImGuiID owner_id = 0);
                            - old: IsMouseClicked(ImGuiMouseButton button, ImGuiID owner_id, ImGuiInputFlags flags = 0);
                            - new: IsMouseClicked(ImGuiMouseButton button, ImGuiInputFlags flags, ImGuiID owner_id = 0);
                         for various reasons those changes makes sense. They are being made because making some of those API public.
                         only past users of imgui_internal.h with the extra parameters will be affected. Added asserts for valid flags in various functions to detect _some_ misuses, BUT NOT ALL.
 - 2024/05/21 (1.90.7) - docking: changed signature of DockSpaceOverViewport() to add explicit dockspace id if desired. pass 0 to use old behavior. (#7611)
                           - old: DockSpaceOverViewport(const ImGuiViewport* viewport = NULL, ImGuiDockNodeFlags flags = 0, ...);
                           - new: DockSpaceOverViewport(ImGuiID dockspace_id = 0, const ImGuiViewport* viewport = NULL, ImGuiDockNodeFlags flags = 0, ...);
 - 2024/05/16 (1.90.7) - inputs: on macOS X, Cmd and Ctrl keys are now automatically swapped by io.AddKeyEvent() as this naturally align with how macOS X uses those keys.
                           - it shouldn't really affect you unless you had custom shortcut swapping in place for macOS X apps.
                           - removed ImGuiMod_Shortcut which was previously dynamically remapping to Ctrl or Cmd/Super. It is now unnecessary to specific cross-platform idiomatic shortcuts. (#2343, #4084, #5923, #456)
 - 2024/05/14 (1.90.7) - backends: SDL_Renderer2 and SDL_Renderer3 backend now take a SDL_Renderer* in their RenderDrawData() functions.
 - 2024/04/18 (1.90.6) - TreeNode: Fixed a layout inconsistency when using an empty/hidden label followed by a SameLine() call. (#7505, #282)
                           - old: TreeNode("##Hidden"); SameLine(); Text("Hello");     // <-- This was actually incorrect! BUT appeared to look ok with the default style where ItemSpacing.x == FramePadding.x * 2 (it didn't look aligned otherwise).
                           - new: TreeNode("##Hidden"); SameLine(0, 0); Text("Hello"); // <-- This is correct for all styles values.
                         with the fix, IF you were successfully using TreeNode("")+SameLine(); you will now have extra spacing between your TreeNode and the following item.
                         You'll need to change the SameLine() call to SameLine(0,0) to remove this extraneous spacing. This seemed like the more sensible fix that's not making things less consistent.
                         (Note: when using this idiom you are likely to also use ImGuiTreeNodeFlags_SpanAvailWidth).
 - 2024/03/18 (1.90.5) - merged the radius_x/radius_y parameters in ImDrawList::AddEllipse(), AddEllipseFilled() and PathEllipticalArcTo() into a single ImVec2 parameter. Exceptionally, because those functions were added in 1.90, we are not adding inline redirection functions. The transition is easy and should affect few users. (#2743, #7417)
 - 2024/03/08 (1.90.5) - inputs: more formally obsoleted GetKeyIndex() when IMGUI_DISABLE_OBSOLETE_FUNCTIONS is set. It has been unnecessary and a no-op since 1.87 (it returns the same value as passed when used with a 1.87+ backend using io.AddKeyEvent() function). (#4921)
                           - IsKeyPressed(GetKeyIndex(ImGuiKey_XXX)) -> use IsKeyPressed(ImGuiKey_XXX)
 - 2024/01/15 (1.90.2) - commented out obsolete ImGuiIO::ImeWindowHandle marked obsolete in 1.87, favor of writing to 'void* ImGuiViewport::PlatformHandleRaw'.
 - 2023/12/19 (1.90.1) - commented out obsolete ImGuiKey_KeyPadEnter redirection to ImGuiKey_KeypadEnter.
 - 2023/11/06 (1.90.1) - removed CalcListClipping() marked obsolete in 1.86. Prefer using ImGuiListClipper which can return non-contiguous ranges.
 - 2023/11/05 (1.90.1) - imgui_freetype: commented out ImGuiFreeType::BuildFontAtlas() obsoleted in 1.81. prefer using #define IMGUI_ENABLE_FREETYPE or see commented code for manual calls.
 - 2023/11/05 (1.90.1) - internals,columns: commented out legacy ImGuiColumnsFlags_XXX symbols redirecting to ImGuiOldColumnsFlags_XXX, obsoleted from imgui_internal.h in 1.80.
 - 2023/11/09 (1.90.0) - removed IM_OFFSETOF() macro in favor of using offsetof() available in C++11. Kept redirection define (will obsolete).
 - 2023/11/07 (1.90.0) - removed BeginChildFrame()/EndChildFrame() in favor of using BeginChild() with the ImGuiChildFlags_FrameStyle flag. kept inline redirection function (will obsolete).
                         those functions were merely PushStyle/PopStyle helpers, the removal isn't so much motivated by needing to add the feature in BeginChild(), but by the necessity to avoid BeginChildFrame() signature mismatching BeginChild() signature and features.
 - 2023/11/02 (1.90.0) - BeginChild: upgraded 'bool border = true' parameter to 'ImGuiChildFlags flags' type, added ImGuiChildFlags_Border equivalent. As with our prior "bool-to-flags" API updates, the ImGuiChildFlags_Border value is guaranteed to be == true forever to ensure a smoother transition, meaning all existing calls will still work.
                           - old: BeginChild("Name", size, true)
                           - new: BeginChild("Name", size, ImGuiChildFlags_Border)
                           - old: BeginChild("Name", size, false)
                           - new: BeginChild("Name", size) or BeginChild("Name", 0) or BeginChild("Name", size, ImGuiChildFlags_None)
                         **AMEND FROM THE FUTURE: from 1.91.1, 'ImGuiChildFlags_Border' is called 'ImGuiChildFlags_Borders'**
 - 2023/11/02 (1.90.0) - BeginChild: added child-flag ImGuiChildFlags_AlwaysUseWindowPadding as a replacement for the window-flag ImGuiWindowFlags_AlwaysUseWindowPadding: the feature only ever made sense for BeginChild() anyhow.
                           - old: BeginChild("Name", size, 0, ImGuiWindowFlags_AlwaysUseWindowPadding);
                           - new: BeginChild("Name", size, ImGuiChildFlags_AlwaysUseWindowPadding, 0);
 - 2023/09/27 (1.90.0) - io: removed io.MetricsActiveAllocations introduced in 1.63. Same as 'g.DebugMemAllocCount - g.DebugMemFreeCount' (still displayed in Metrics, unlikely to be accessed by end-user).
 - 2023/09/26 (1.90.0) - debug tools: Renamed ShowStackToolWindow() ("Stack Tool") to ShowIDStackToolWindow() ("ID Stack Tool"), as earlier name was misleading. Kept inline redirection function. (#4631)
 - 2023/09/15 (1.90.0) - ListBox, Combo: changed signature of "name getter" callback in old one-liner ListBox()/Combo() apis. kept inline redirection function (will obsolete).
                           - old: bool Combo(const char* label, int* current_item, bool (*getter)(void* user_data, int idx, const char** out_text), ...)
                           - new: bool Combo(const char* label, int* current_item, const char* (*getter)(void* user_data, int idx), ...);
                           - old: bool ListBox(const char* label, int* current_item, bool (*getting)(void* user_data, int idx, const char** out_text), ...);
                           - new: bool ListBox(const char* label, int* current_item, const char* (*getter)(void* user_data, int idx), ...);
 - 2023/09/08 (1.90.0) - commented out obsolete redirecting functions:
                           - GetWindowContentRegionWidth()  -> use GetWindowContentRegionMax().x - GetWindowContentRegionMin().x. Consider that generally 'GetContentRegionAvail().x' is more useful.
                           - ImDrawCornerFlags_XXX          -> use ImDrawFlags_RoundCornersXXX flags. Read 1.82 Changelog for details + grep commented names in sources.
                       - commented out runtime support for hardcoded ~0 or 0x01..0x0F rounding flags values for AddRect()/AddRectFilled()/PathRect()/AddImageRounded() -> use ImDrawFlags_RoundCornersXXX flags. Read 1.82 Changelog for details
 - 2023/08/25 (1.89.9) - clipper: Renamed IncludeRangeByIndices() (also called ForceDisplayRangeByIndices() before 1.89.6) to IncludeItemsByIndex(). Kept inline redirection function. Sorry!
 - 2023/07/12 (1.89.8) - ImDrawData: CmdLists now owned, changed from ImDrawList** to ImVector<ImDrawList*>. Majority of users shouldn't be affected, but you cannot compare to NULL nor reassign manually anymore. Instead use AddDrawList(). (#6406, #4879, #1878)
 - 2023/06/28 (1.89.7) - overlapping items: obsoleted 'SetItemAllowOverlap()' (called after item) in favor of calling 'SetNextItemAllowOverlap()' (called before item). 'SetItemAllowOverlap()' didn't and couldn't work reliably since 1.89 (2022-11-15).
 - 2023/06/28 (1.89.7) - overlapping items: renamed 'ImGuiTreeNodeFlags_AllowItemOverlap' to 'ImGuiTreeNodeFlags_AllowOverlap', 'ImGuiSelectableFlags_AllowItemOverlap' to 'ImGuiSelectableFlags_AllowOverlap'. Kept redirecting enums (will obsolete).
 - 2023/06/28 (1.89.7) - overlapping items: IsItemHovered() now by default return false when querying an item using AllowOverlap mode which is being overlapped. Use ImGuiHoveredFlags_AllowWhenOverlappedByItem to revert to old behavior.
 - 2023/06/28 (1.89.7) - overlapping items: Selectable and TreeNode don't allow overlap when active so overlapping widgets won't appear as hovered. While this fixes a common small visual issue, it also means that calling IsItemHovered() after a non-reactive elements - e.g. Text() - overlapping an active one may fail if you don't use IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByActiveItem). (#6610)
 - 2023/06/20 (1.89.7) - moved io.HoverDelayShort/io.HoverDelayNormal to style.HoverDelayShort/style.HoverDelayNormal. As the fields were added in 1.89 and expected to be left unchanged by most users, or only tweaked once during app initialization, we are exceptionally accepting the breakage.
 - 2023/05/30 (1.89.6) - backends: renamed "imgui_impl_sdlrenderer.cpp" to "imgui_impl_sdlrenderer2.cpp" and "imgui_impl_sdlrenderer.h" to "imgui_impl_sdlrenderer2.h". This is in prevision for the future release of SDL3.
 - 2023/05/22 (1.89.6) - listbox: commented out obsolete/redirecting functions that were marked obsolete more than two years ago:
                           - ListBoxHeader()  -> use BeginListBox() (note how two variants of ListBoxHeader() existed. Check commented versions in imgui.h for reference)
                           - ListBoxFooter()  -> use EndListBox()
 - 2023/05/15 (1.89.6) - clipper: commented out obsolete redirection constructor 'ImGuiListClipper(int items_count, float items_height = -1.0f)' that was marked obsolete in 1.79. Use default constructor + clipper.Begin().
 - 2023/05/15 (1.89.6) - clipper: renamed ImGuiListClipper::ForceDisplayRangeByIndices() to ImGuiListClipper::IncludeRangeByIndices().
 - 2023/03/14 (1.89.4) - commented out redirecting enums/functions names that were marked obsolete two years ago:
                           - ImGuiSliderFlags_ClampOnInput        -> use ImGuiSliderFlags_AlwaysClamp
                           - ImGuiInputTextFlags_AlwaysInsertMode -> use ImGuiInputTextFlags_AlwaysOverwrite
                           - ImDrawList::AddBezierCurve()         -> use ImDrawList::AddBezierCubic()
                           - ImDrawList::PathBezierCurveTo()      -> use ImDrawList::PathBezierCubicCurveTo()
 - 2023/03/09 (1.89.4) - renamed PushAllowKeyboardFocus()/PopAllowKeyboardFocus() to PushTabStop()/PopTabStop(). Kept inline redirection functions (will obsolete).
 - 2023/03/09 (1.89.4) - tooltips: Added 'bool' return value to BeginTooltip() for API consistency. Please only submit contents and call EndTooltip() if BeginTooltip() returns true. In reality the function will _currently_ always return true, but further changes down the line may change this, best to clarify API sooner.
 - 2023/02/15 (1.89.4) - moved the optional "courtesy maths operators" implementation from imgui_internal.h in imgui.h.
                         Even though we encourage using your own maths types and operators by setting up IM_VEC2_CLASS_EXTRA,
                         it has been frequently requested by people to use our own. We had an opt-in define which was
                         previously fulfilled in imgui_internal.h. It is now fulfilled in imgui.h. (#6164)
                           - OK:     #define IMGUI_DEFINE_MATH_OPERATORS / #include "imgui.h" / #include "imgui_internal.h"
                           - Error:  #include "imgui.h" / #define IMGUI_DEFINE_MATH_OPERATORS / #include "imgui_internal.h"
 - 2023/02/07 (1.89.3) - backends: renamed "imgui_impl_sdl.cpp" to "imgui_impl_sdl2.cpp" and "imgui_impl_sdl.h" to "imgui_impl_sdl2.h". (#6146) This is in prevision for the future release of SDL3.
 - 2022/10/26 (1.89)   - commented out redirecting OpenPopupContextItem() which was briefly the name of OpenPopupOnItemClick() from 1.77 to 1.79.
 - 2022/10/12 (1.89)   - removed runtime patching of invalid "%f"/"%0.f" format strings for DragInt()/SliderInt(). This was obsoleted in 1.61 (May 2018). See 1.61 changelog for details.
 - 2022/09/26 (1.89)   - renamed and merged keyboard modifiers key enums and flags into a same set. Kept inline redirection enums (will obsolete).
                           - ImGuiKey_ModCtrl  and ImGuiModFlags_Ctrl  -> ImGuiMod_Ctrl
                           - ImGuiKey_ModShift and ImGuiModFlags_Shift -> ImGuiMod_Shift
                           - ImGuiKey_ModAlt   and ImGuiModFlags_Alt   -> ImGuiMod_Alt
                           - ImGuiKey_ModSuper and ImGuiModFlags_Super -> ImGuiMod_Super
                         the ImGuiKey_ModXXX were introduced in 1.87 and mostly used by backends.
                         the ImGuiModFlags_XXX have been exposed in imgui.h but not really used by any public api only by third-party extensions.
                         exceptionally commenting out the older ImGuiKeyModFlags_XXX names ahead of obsolescence schedule to reduce confusion and because they were not meant to be used anyway.
 - 2022/09/20 (1.89)   - ImGuiKey is now a typed enum, allowing ImGuiKey_XXX symbols to be named in debuggers.
                         this will require uses of legacy backend-dependent indices to be casted, e.g.
                            - with imgui_impl_glfw:  IsKeyPressed(GLFW_KEY_A) -> IsKeyPressed((ImGuiKey)GLFW_KEY_A);
                            - with imgui_impl_win32: IsKeyPressed('A')        -> IsKeyPressed((ImGuiKey)'A')
                            - etc. However if you are upgrading code you might well use the better, backend-agnostic IsKeyPressed(ImGuiKey_A) now!
 - 2022/09/12 (1.89) - removed the bizarre legacy default argument for 'TreePush(const void* ptr = NULL)', always pass a pointer value explicitly. NULL/nullptr is ok but require cast, e.g. TreePush((void*)nullptr);
 - 2022/09/05 (1.89) - commented out redirecting functions/enums names that were marked obsolete in 1.77 and 1.78 (June 2020):
                         - DragScalar(), DragScalarN(), DragFloat(), DragFloat2(), DragFloat3(), DragFloat4(): For old signatures ending with (..., const char* format, float power = 1.0f) -> use (..., format ImGuiSliderFlags_Logarithmic) if power != 1.0f.
                         - SliderScalar(), SliderScalarN(), SliderFloat(), SliderFloat2(), SliderFloat3(), SliderFloat4(): For old signatures ending with (..., const char* format, float power = 1.0f) -> use (..., format ImGuiSliderFlags_Logarithmic) if power != 1.0f.
                         - BeginPopupContextWindow(const char*, ImGuiMouseButton, bool) -> use BeginPopupContextWindow(const char*, ImGuiPopupFlags)
 - 2022/09/02 (1.89) - obsoleted using SetCursorPos()/SetCursorScreenPos() to extend parent window/cell boundaries.
                       this relates to when moving the cursor position beyond current boundaries WITHOUT submitting an item.
                         - previously this would make the window content size ~200x200:
                              Begin(...) + SetCursorScreenPos(GetCursorScreenPos() + ImVec2(200,200)) + End();
                         - instead, please submit an item:
                              Begin(...) + SetCursorScreenPos(GetCursorScreenPos() + ImVec2(200,200)) + Dummy(ImVec2(0,0)) + End();
                         - alternative:
                              Begin(...) + Dummy(ImVec2(200,200)) + End();
                         - content size is now only extended when submitting an item!
                         - with '#define IMGUI_DISABLE_OBSOLETE_FUNCTIONS' this will now be detected and assert.
                         - without '#define IMGUI_DISABLE_OBSOLETE_FUNCTIONS' this will silently be fixed until we obsolete it.
 - 2022/08/03 (1.89) - changed signature of ImageButton() function. Kept redirection function (will obsolete).
                        - added 'const char* str_id' parameter + removed 'int frame_padding = -1' parameter.
                        - old signature: bool ImageButton(ImTextureID tex_id, ImVec2 size, ImVec2 uv0 = ImVec2(0,0), ImVec2 uv1 = ImVec2(1,1), int frame_padding = -1, ImVec4 bg_col = ImVec4(0,0,0,0), ImVec4 tint_col = ImVec4(1,1,1,1));
                          - used the ImTextureID value to create an ID. This was inconsistent with other functions, led to ID conflicts, and caused problems with engines using transient ImTextureID values.
                          - had a FramePadding override which was inconsistent with other functions and made the already-long signature even longer.
                        - new signature: bool ImageButton(const char* str_id, ImTextureID tex_id, ImVec2 size, ImVec2 uv0 = ImVec2(0,0), ImVec2 uv1 = ImVec2(1,1), ImVec4 bg_col = ImVec4(0,0,0,0), ImVec4 tint_col = ImVec4(1,1,1,1));
                          - requires an explicit identifier. You may still use e.g. PushID() calls and then pass an empty identifier.
                          - always uses style.FramePadding for padding, to be consistent with other buttons. You may use PushStyleVar() to alter this.
 - 2022/07/08 (1.89) - inputs: removed io.NavInputs[] and ImGuiNavInput enum (following 1.87 changes).
                        - Official backends from 1.87+                  -> no issue.
                        - Official backends from 1.60 to 1.86           -> will build and convert gamepad inputs, unless IMGUI_DISABLE_OBSOLETE_KEYIO is defined. Need updating!
                        - Custom backends not writing to io.NavInputs[] -> no issue.
                        - Custom backends writing to io.NavInputs[]     -> will build and convert gamepad inputs, unless IMGUI_DISABLE_OBSOLETE_KEYIO is defined. Need fixing!
                        - TL;DR: Backends should call io.AddKeyEvent()/io.AddKeyAnalogEvent() with ImGuiKey_GamepadXXX values instead of filling io.NavInput[].
 - 2022/06/15 (1.88) - renamed IMGUI_DISABLE_METRICS_WINDOW to IMGUI_DISABLE_DEBUG_TOOLS for correctness. kept support for old define (will obsolete).
 - 2022/05/03 (1.88) - backends: osx: removed ImGui_ImplOSX_HandleEvent() from backend API in favor of backend automatically handling event capture. All ImGui_ImplOSX_HandleEvent() calls should be removed as they are now unnecessary.
 - 2022/04/05 (1.88) - inputs: renamed ImGuiKeyModFlags to ImGuiModFlags. Kept inline redirection enums (will obsolete). This was never used in public API functions but technically present in imgui.h and ImGuiIO.
 - 2022/01/20 (1.87) - inputs: reworded gamepad IO.
                        - Backend writing to io.NavInputs[]            -> backend should call io.AddKeyEvent()/io.AddKeyAnalogEvent() with ImGuiKey_GamepadXXX values.
 - 2022/01/19 (1.87) - sliders, drags: removed support for legacy arithmetic operators (+,+-,*,/) when inputing text. This doesn't break any api/code but a feature that used to be accessible by end-users (which seemingly no one used).
 - 2022/01/17 (1.87) - inputs: reworked mouse IO.
                        - Backend writing to io.MousePos               -> backend should call io.AddMousePosEvent()
                        - Backend writing to io.MouseDown[]            -> backend should call io.AddMouseButtonEvent()
                        - Backend writing to io.MouseWheel             -> backend should call io.AddMouseWheelEvent()
                        - Backend writing to io.MouseHoveredViewport   -> backend should call io.AddMouseViewportEvent() [Docking branch w/ multi-viewports only]
                       note: for all calls to IO new functions, the Dear ImGui context should be bound/current.
                       read https://github.com/ocornut/imgui/issues/4921 for details.
 - 2022/01/10 (1.87) - inputs: reworked keyboard IO. Removed io.KeyMap[], io.KeysDown[] in favor of calling io.AddKeyEvent(). Removed GetKeyIndex(), now unnecessary. All IsKeyXXX() functions now take ImGuiKey values. All features are still functional until IMGUI_DISABLE_OBSOLETE_KEYIO is defined. Read Changelog and Release Notes for details.
                        - IsKeyPressed(MY_NATIVE_KEY_XXX)              -> use IsKeyPressed(ImGuiKey_XXX)
                        - IsKeyPressed(GetKeyIndex(ImGuiKey_XXX))      -> use IsKeyPressed(ImGuiKey_XXX)
                        - Backend writing to io.KeyMap[],io.KeysDown[] -> backend should call io.AddKeyEvent() (+ call io.SetKeyEventNativeData() if you want legacy user code to stil function with legacy key codes).
                        - Backend writing to io.KeyCtrl, io.KeyShift.. -> backend should call io.AddKeyEvent() with ImGuiMod_XXX values. *IF YOU PULLED CODE BETWEEN 2021/01/10 and 2021/01/27: We used to have a io.AddKeyModsEvent() function which was now replaced by io.AddKeyEvent() with ImGuiMod_XXX values.*
                     - one case won't work with backward compatibility: if your custom backend used ImGuiKey as mock native indices (e.g. "io.KeyMap[ImGuiKey_A] = ImGuiKey_A") because those values are now larger than the legacy KeyDown[] array. Will assert.
                     - inputs: added ImGuiKey_ModCtrl/ImGuiKey_ModShift/ImGuiKey_ModAlt/ImGuiKey_ModSuper values to submit keyboard modifiers using io.AddKeyEvent(), instead of writing directly to io.KeyCtrl, io.KeyShift, io.KeyAlt, io.KeySuper.
 - 2022/01/05 (1.87) - inputs: renamed ImGuiKey_KeyPadEnter to ImGuiKey_KeypadEnter to align with new symbols. Kept redirection enum.
 - 2022/01/05 (1.87) - removed io.ImeSetInputScreenPosFn() in favor of more flexible io.SetPlatformImeDataFn(). Removed 'void* io.ImeWindowHandle' in favor of writing to 'void* ImGuiViewport::PlatformHandleRaw'.
 - 2022/01/01 (1.87) - commented out redirecting functions/enums names that were marked obsolete in 1.69, 1.70, 1.71, 1.72 (March-July 2019)
                        - ImGui::SetNextTreeNodeOpen()        -> use ImGui::SetNextItemOpen()
                        - ImGui::GetContentRegionAvailWidth() -> use ImGui::GetContentRegionAvail().x
                        - ImGui::TreeAdvanceToLabelPos()      -> use ImGui::SetCursorPosX(ImGui::GetCursorPosX() + ImGui::GetTreeNodeToLabelSpacing());
                        - ImFontAtlas::CustomRect             -> use ImFontAtlasCustomRect
                        - ImGuiColorEditFlags_RGB/HSV/HEX     -> use ImGuiColorEditFlags_DisplayRGB/HSV/Hex
 - 2021/12/20 (1.86) - backends: removed obsolete Marmalade backend (imgui_impl_marmalade.cpp) + example. Find last supported version at https://github.com/ocornut/imgui/wiki/Bindings
 - 2021/11/04 (1.86) - removed CalcListClipping() function. Prefer using ImGuiListClipper which can return non-contiguous ranges. Please open an issue if you think you really need this function.
 - 2021/08/23 (1.85) - removed GetWindowContentRegionWidth() function. keep inline redirection helper. can use 'GetWindowContentRegionMax().x - GetWindowContentRegionMin().x' instead for generally 'GetContentRegionAvail().x' is more useful.
 - 2021/07/26 (1.84) - commented out redirecting functions/enums names that were marked obsolete in 1.67 and 1.69 (March 2019):
                        - ImGui::GetOverlayDrawList() -> use ImGui::GetForegroundDrawList()
                        - ImFont::GlyphRangesBuilder  -> use ImFontGlyphRangesBuilder
 - 2021/05/19 (1.83) - backends: obsoleted direct access to ImDrawCmd::TextureId in favor of calling ImDrawCmd::GetTexID().
                        - if you are using official backends from the source tree: you have nothing to do.
                        - if you have copied old backend code or using your own: change access to draw_cmd->TextureId to draw_cmd->GetTexID().
 - 2021/03/12 (1.82) - upgraded ImDrawList::AddRect(), AddRectFilled(), PathRect() to use ImDrawFlags instead of ImDrawCornersFlags.
                        - ImDrawCornerFlags_TopLeft  -> use ImDrawFlags_RoundCornersTopLeft
                        - ImDrawCornerFlags_BotRight -> use ImDrawFlags_RoundCornersBottomRight
                        - ImDrawCornerFlags_None     -> use ImDrawFlags_RoundCornersNone etc.
                       flags now sanely defaults to 0 instead of 0x0F, consistent with all other flags in the API.
                       breaking: the default with rounding > 0.0f is now "round all corners" vs old implicit "round no corners":
                        - rounding == 0.0f + flags == 0 --> meant no rounding  --> unchanged (common use)
                        - rounding  > 0.0f + flags != 0 --> meant rounding     --> unchanged (common use)
                        - rounding == 0.0f + flags != 0 --> meant no rounding  --> unchanged (unlikely use)
                        - rounding  > 0.0f + flags == 0 --> meant no rounding  --> BREAKING (unlikely use): will now round all corners --> use ImDrawFlags_RoundCornersNone or rounding == 0.0f.
                       this ONLY matters for hard coded use of 0 + rounding > 0.0f. Use of named ImDrawFlags_RoundCornersNone (new) or ImDrawCornerFlags_None (old) are ok.
                       the old ImDrawCornersFlags used awkward default values of ~0 or 0xF (4 lower bits set) to signify "round all corners" and we sometimes encouraged using them as shortcuts.
                       legacy path still support use of hard coded ~0 or any value from 0x1 or 0xF. They will behave the same with legacy paths enabled (will assert otherwise).
 - 2021/03/11 (1.82) - removed redirecting functions/enums names that were marked obsolete in 1.66 (September 2018):
                        - ImGui::SetScrollHere()              -> use ImGui::SetScrollHereY()
 - 2021/03/11 (1.82) - clarified that ImDrawList::PathArcTo(), ImDrawList::PathArcToFast() won't render with radius < 0.0f. Previously it sorts of accidentally worked but would generally lead to counter-clockwise paths and have an effect on anti-aliasing.
 - 2021/03/10 (1.82) - upgraded ImDrawList::AddPolyline() and PathStroke() "bool closed" parameter to "ImDrawFlags flags". The matching ImDrawFlags_Closed value is guaranteed to always stay == 1 in the future.
 - 2021/02/22 (1.82) - (*undone in 1.84*) win32+mingw: Re-enabled IME functions by default even under MinGW. In July 2016, issue #738 had me incorrectly disable those default functions for MinGW. MinGW users should: either link with -limm32, either set their imconfig file  with '#define IMGUI_DISABLE_WIN32_DEFAULT_IME_FUNCTIONS'.
 - 2021/02/17 (1.82) - renamed rarely used style.CircleSegmentMaxError (old default = 1.60f) to style.CircleTessellationMaxError (new default = 0.30f) as the meaning of the value changed.
 - 2021/02/03 (1.81) - renamed ListBoxHeader(const char* label, ImVec2 size) to BeginListBox(). Kept inline redirection function (will obsolete).
                     - removed ListBoxHeader(const char* label, int items_count, int height_in_items = -1) in favor of specifying size. Kept inline redirection function (will obsolete).
                     - renamed ListBoxFooter() to EndListBox(). Kept inline redirection function (will obsolete).
 - 2021/01/26 (1.81) - removed ImGuiFreeType::BuildFontAtlas(). Kept inline redirection function. Prefer using '#define IMGUI_ENABLE_FREETYPE', but there's a runtime selection path available too. The shared extra flags parameters (very rarely used) are now stored in ImFontAtlas::FontBuilderFlags.
                     - renamed ImFontConfig::RasterizerFlags (used by FreeType) to ImFontConfig::FontBuilderFlags.
                     - renamed ImGuiFreeType::XXX flags to ImGuiFreeTypeBuilderFlags_XXX for consistency with other API.
 - 2020/10/12 (1.80) - removed redirecting functions/enums that were marked obsolete in 1.63 (August 2018):
                        - ImGui::IsItemDeactivatedAfterChange() -> use ImGui::IsItemDeactivatedAfterEdit().
                        - ImGuiCol_ModalWindowDarkening       -> use ImGuiCol_ModalWindowDimBg
                        - ImGuiInputTextCallback              -> use ImGuiTextEditCallback
                        - ImGuiInputTextCallbackData          -> use ImGuiTextEditCallbackData
 - 2020/12/21 (1.80) - renamed ImDrawList::AddBezierCurve() to AddBezierCubic(), and PathBezierCurveTo() to PathBezierCubicCurveTo(). Kept inline redirection function (will obsolete).
 - 2020/12/04 (1.80) - added imgui_tables.cpp file! Manually constructed project files will need the new file added!
 - 2020/11/18 (1.80) - renamed undocumented/internals ImGuiColumnsFlags_* to ImGuiOldColumnFlags_* in prevision of incoming Tables API.
 - 2020/11/03 (1.80) - renamed io.ConfigWindowsMemoryCompactTimer to io.ConfigMemoryCompactTimer as the feature will apply to other data structures
 - 2020/10/14 (1.80) - backends: moved all backends files (imgui_impl_XXXX.cpp, imgui_impl_XXXX.h) from examples/ to backends/.
 - 2020/10/12 (1.80) - removed redirecting functions/enums that were marked obsolete in 1.60 (April 2018):
                        - io.RenderDrawListsFn pointer        -> use ImGui::GetDrawData() value and call the render function of your backend
                        - ImGui::IsAnyWindowFocused()         -> use ImGui::IsWindowFocused(ImGuiFocusedFlags_AnyWindow)
                        - ImGui::IsAnyWindowHovered()         -> use ImGui::IsWindowHovered(ImGuiHoveredFlags_AnyWindow)
                        - ImGuiStyleVar_Count_                -> use ImGuiStyleVar_COUNT
                        - ImGuiMouseCursor_Count_             -> use ImGuiMouseCursor_COUNT
                      - removed redirecting functions names that were marked obsolete in 1.61 (May 2018):
                        - InputFloat (... int decimal_precision ...) -> use InputFloat (... const char* format ...) with format = "%.Xf" where X is your value for decimal_precision.
                        - same for InputFloat2()/InputFloat3()/InputFloat4() variants taking a `int decimal_precision` parameter.
 - 2020/10/05 (1.79) - removed ImGuiListClipper: Renamed constructor parameters which created an ambiguous alternative to using the ImGuiListClipper::Begin() function, with misleading edge cases (note: imgui_memory_editor <0.40 from imgui_club/ used this old clipper API. Update your copy if needed).
 - 2020/09/25 (1.79) - renamed ImGuiSliderFlags_ClampOnInput to ImGuiSliderFlags_AlwaysClamp. Kept redirection enum (will obsolete sooner because previous name was added recently).
 - 2020/09/25 (1.79) - renamed style.TabMinWidthForUnselectedCloseButton to style.TabMinWidthForCloseButton.
 - 2020/09/21 (1.79) - renamed OpenPopupContextItem() back to OpenPopupOnItemClick(), reverting the change from 1.77. For varieties of reason this is more self-explanatory.
 - 2020/09/21 (1.79) - removed return value from OpenPopupOnItemClick() - returned true on mouse release on an item - because it is inconsistent with other popup APIs and makes others misleading. It's also and unnecessary: you can use IsWindowAppearing() after BeginPopup() for a similar result.
 - 2020/09/17 (1.79) - removed ImFont::DisplayOffset in favor of ImFontConfig::GlyphOffset. DisplayOffset was applied after scaling and not very meaningful/useful outside of being needed by the default ProggyClean font. If you scaled this value after calling AddFontDefault(), this is now done automatically. It was also getting in the way of better font scaling, so let's get rid of it now!
 - 2020/08/17 (1.78) - obsoleted use of the trailing 'float power=1.0f' parameter for DragFloat(), DragFloat2(), DragFloat3(), DragFloat4(), DragFloatRange2(), DragScalar(), DragScalarN(), SliderFloat(), SliderFloat2(), SliderFloat3(), SliderFloat4(), SliderScalar(), SliderScalarN(), VSliderFloat() and VSliderScalar().
                       replaced the 'float power=1.0f' argument with integer-based flags defaulting to 0 (as with all our flags).
                       worked out a backward-compatibility scheme so hopefully most C++ codebase should not be affected. in short, when calling those functions:
                       - if you omitted the 'power' parameter (likely!), you are not affected.
                       - if you set the 'power' parameter to 1.0f (same as previous default value): 1/ your compiler may warn on float>int conversion, 2/ everything else will work. 3/ you can replace the 1.0f value with 0 to fix the warning, and be technically correct.
                       - if you set the 'power' parameter to >1.0f (to enable non-linear editing): 1/ your compiler may warn on float>int conversion, 2/ code will assert at runtime, 3/ in case asserts are disabled, the code will not crash and enable the _Logarithmic flag. 4/ you can replace the >1.0f value with ImGuiSliderFlags_Logarithmic to fix the warning/assert and get a _similar_ effect as previous uses of power >1.0f.
                       see https://github.com/ocornut/imgui/issues/3361 for all details.
                       kept inline redirection functions (will obsolete) apart for: DragFloatRange2(), VSliderFloat(), VSliderScalar(). For those three the 'float power=1.0f' version was removed directly as they were most unlikely ever used.
                       for shared code, you can version check at compile-time with `#if IMGUI_VERSION_NUM >= 17704`.
                     - obsoleted use of v_min > v_max in DragInt, DragFloat, DragScalar to lock edits (introduced in 1.73, was not demoed nor documented very), will be replaced by a more generic ReadOnly feature. You may use the ImGuiSliderFlags_ReadOnly internal flag in the meantime.
 - 2020/06/23 (1.77) - removed BeginPopupContextWindow(const char*, int mouse_button, bool also_over_items) in favor of BeginPopupContextWindow(const char*, ImGuiPopupFlags flags) with ImGuiPopupFlags_NoOverItems.
 - 2020/06/15 (1.77) - renamed OpenPopupOnItemClick() to OpenPopupContextItem(). Kept inline redirection function (will obsolete). [NOTE: THIS WAS REVERTED IN 1.79]
 - 2020/06/15 (1.77) - removed CalcItemRectClosestPoint() entry point which was made obsolete and asserting in December 2017.
 - 2020/04/23 (1.77) - removed unnecessary ID (first arg) of ImFontAtlas::AddCustomRectRegular().
 - 2020/01/22 (1.75) - ImDrawList::AddCircle()/AddCircleFilled() functions don't accept negative radius any more.
 - 2019/12/17 (1.75) - [undid this change in 1.76] made Columns() limited to 64 columns by asserting above that limit. While the current code technically supports it, future code may not so we're putting the restriction ahead.
 - 2019/12/13 (1.75) - [imgui_internal.h] changed ImRect() default constructor initializes all fields to 0.0f instead of (FLT_MAX,FLT_MAX,-FLT_MAX,-FLT_MAX). If you used ImRect::Add() to create bounding boxes by adding multiple points into it, you may need to fix your initial value.
 - 2019/12/08 (1.75) - removed redirecting functions/enums that were marked obsolete in 1.53 (December 2017):
                       - ShowTestWindow()                    -> use ShowDemoWindow()
                       - IsRootWindowFocused()               -> use IsWindowFocused(ImGuiFocusedFlags_RootWindow)
                       - IsRootWindowOrAnyChildFocused()     -> use IsWindowFocused(ImGuiFocusedFlags_RootAndChildWindows)
                       - SetNextWindowContentWidth(w)        -> use SetNextWindowContentSize(ImVec2(w, 0.0f)
                       - GetItemsLineHeightWithSpacing()     -> use GetFrameHeightWithSpacing()
                       - ImGuiCol_ChildWindowBg              -> use ImGuiCol_ChildBg
                       - ImGuiStyleVar_ChildWindowRounding   -> use ImGuiStyleVar_ChildRounding
                       - ImGuiTreeNodeFlags_AllowOverlapMode -> use ImGuiTreeNodeFlags_AllowItemOverlap
                       - IMGUI_DISABLE_TEST_WINDOWS          -> use IMGUI_DISABLE_DEMO_WINDOWS
 - 2019/12/08 (1.75) - obsoleted calling ImDrawList::PrimReserve() with a negative count (which was vaguely documented and rarely if ever used). Instead, we added an explicit PrimUnreserve() API.
 - 2019/12/06 (1.75) - removed implicit default parameter to IsMouseDragging(int button = 0) to be consistent with other mouse functions (none of the other functions have it).
 - 2019/11/21 (1.74) - ImFontAtlas::AddCustomRectRegular() now requires an ID larger than 0x110000 (instead of 0x10000) to conform with supporting Unicode planes 1-16 in a future update. ID below 0x110000 will now assert.
 - 2019/11/19 (1.74) - renamed IMGUI_DISABLE_FORMAT_STRING_FUNCTIONS to IMGUI_DISABLE_DEFAULT_FORMAT_FUNCTIONS for consistency.
 - 2019/11/19 (1.74) - renamed IMGUI_DISABLE_MATH_FUNCTIONS to IMGUI_DISABLE_DEFAULT_MATH_FUNCTIONS for consistency.
 - 2019/10/22 (1.74) - removed redirecting functions/enums that were marked obsolete in 1.52 (October 2017):
                       - Begin() [old 5 args version]        -> use Begin() [3 args], use SetNextWindowSize() SetNextWindowBgAlpha() if needed
                       - IsRootWindowOrAnyChildHovered()     -> use IsWindowHovered(ImGuiHoveredFlags_RootAndChildWindows)
                       - AlignFirstTextHeightToWidgets()     -> use AlignTextToFramePadding()
                       - SetNextWindowPosCenter()            -> use SetNextWindowPos() with a pivot of (0.5f, 0.5f)
                       - ImFont::Glyph                       -> use ImFontGlyph
 - 2019/10/14 (1.74) - inputs: Fixed a miscalculation in the keyboard/mouse "typematic" repeat delay/rate calculation, used by keys and e.g. repeating mouse buttons as well as the GetKeyPressedAmount() function.
                       if you were using a non-default value for io.KeyRepeatRate (previous default was 0.250), you can add +io.KeyRepeatDelay to it to compensate for the fix.
                       The function was triggering on: 0.0 and (delay+rate*N) where (N>=1). Fixed formula responds to (N>=0). Effectively it made io.KeyRepeatRate behave like it was set to (io.KeyRepeatRate + io.KeyRepeatDelay).
                       If you never altered io.KeyRepeatRate nor used GetKeyPressedAmount() this won't affect you.
 - 2019/07/15 (1.72) - removed TreeAdvanceToLabelPos() which is rarely used and only does SetCursorPosX(GetCursorPosX() + GetTreeNodeToLabelSpacing()). Kept redirection function (will obsolete).
 - 2019/07/12 (1.72) - renamed ImFontAtlas::CustomRect to ImFontAtlasCustomRect. Kept redirection typedef (will obsolete).
 - 2019/06/14 (1.72) - removed redirecting functions/enums names that were marked obsolete in 1.51 (June 2017): ImGuiCol_Column*, ImGuiSetCond_*, IsItemHoveredRect(), IsPosHoveringAnyWindow(), IsMouseHoveringAnyWindow(), IsMouseHoveringWindow(), IMGUI_ONCE_UPON_A_FRAME. Grep this log for details and new names, or see how they were implemented until 1.71.
 - 2019/06/07 (1.71) - rendering of child window outer decorations (bg color, border, scrollbars) is now performed as part of the parent window. If you have
                       overlapping child windows in a same parent, and relied on their relative z-order to be mapped to their submission order, this will affect your rendering.
                       This optimization is disabled if the parent window has no visual output, because it appears to be the most common situation leading to the creation of overlapping child windows.
                       Please reach out if you are affected.
 - 2019/05/13 (1.71) - renamed SetNextTreeNodeOpen() to SetNextItemOpen(). Kept inline redirection function (will obsolete).
 - 2019/05/11 (1.71) - changed io.AddInputCharacter(unsigned short c) signature to io.AddInputCharacter(unsigned int c).
 - 2019/04/29 (1.70) - improved ImDrawList thick strokes (>1.0f) preserving correct thickness up to 90 degrees angles (e.g. rectangles). If you have custom rendering using thick lines, they will appear thicker now.
 - 2019/04/29 (1.70) - removed GetContentRegionAvailWidth(), use GetContentRegionAvail().x instead. Kept inline redirection function (will obsolete).
 - 2019/03/04 (1.69) - renamed GetOverlayDrawList() to GetForegroundDrawList(). Kept redirection function (will obsolete).
 - 2019/02/26 (1.69) - renamed ImGuiColorEditFlags_RGB/ImGuiColorEditFlags_HSV/ImGuiColorEditFlags_HEX to ImGuiColorEditFlags_DisplayRGB/ImGuiColorEditFlags_DisplayHSV/ImGuiColorEditFlags_DisplayHex. Kept redirection enums (will obsolete).
 - 2019/02/14 (1.68) - made it illegal/assert when io.DisplayTime == 0.0f (with an exception for the first frame). If for some reason your time step calculation gives you a zero value, replace it with an arbitrarily small value!
 - 2019/02/01 (1.68) - removed io.DisplayVisibleMin/DisplayVisibleMax (which were marked obsolete and removed from viewport/docking branch already).
 - 2019/01/06 (1.67) - renamed io.InputCharacters[], marked internal as was always intended. Please don't access directly, and use AddInputCharacter() instead!
 - 2019/01/06 (1.67) - renamed ImFontAtlas::GlyphRangesBuilder to ImFontGlyphRangesBuilder. Kept redirection typedef (will obsolete).
 - 2018/12/20 (1.67) - made it illegal to call Begin("") with an empty string. This somehow half-worked before but had various undesirable side-effects.
 - 2018/12/10 (1.67) - renamed io.ConfigResizeWindowsFromEdges to io.ConfigWindowsResizeFromEdges as we are doing a large pass on configuration flags.
 - 2018/10/12 (1.66) - renamed misc/stl/imgui_stl.* to misc/cpp/imgui_stdlib.* in prevision for other C++ helper files.
 - 2018/09/28 (1.66) - renamed SetScrollHere() to SetScrollHereY(). Kept redirection function (will obsolete).
 - 2018/09/06 (1.65) - renamed stb_truetype.h to imstb_truetype.h, stb_textedit.h to imstb_textedit.h, and stb_rect_pack.h to imstb_rectpack.h.
                       If you were conveniently using the imgui copy of those STB headers in your project you will have to update your include paths.
 - 2018/09/05 (1.65) - renamed io.OptCursorBlink/io.ConfigCursorBlink to io.ConfigInputTextCursorBlink. (#1427)
 - 2018/08/31 (1.64) - added imgui_widgets.cpp file, extracted and moved widgets code out of imgui.cpp into imgui_widgets.cpp. Re-ordered some of the code remaining in imgui.cpp.
                       NONE OF THE FUNCTIONS HAVE CHANGED. THE CODE IS SEMANTICALLY 100% IDENTICAL, BUT _EVERY_ FUNCTION HAS BEEN MOVED.
                       Because of this, any local modifications to imgui.cpp will likely conflict when you update. Read docs/CHANGELOG.txt for suggestions.
 - 2018/08/22 (1.63) - renamed IsItemDeactivatedAfterChange() to IsItemDeactivatedAfterEdit() for consistency with new IsItemEdited() API. Kept redirection function (will obsolete soonish as IsItemDeactivatedAfterChange() is very recent).
 - 2018/08/21 (1.63) - renamed ImGuiTextEditCallback to ImGuiInputTextCallback, ImGuiTextEditCallbackData to ImGuiInputTextCallbackData for consistency. Kept redirection types (will obsolete).
 - 2018/08/21 (1.63) - removed ImGuiInputTextCallbackData::ReadOnly since it is a duplication of (ImGuiInputTextCallbackData::Flags & ImGuiInputTextFlags_ReadOnly).
 - 2018/08/01 (1.63) - removed per-window ImGuiWindowFlags_ResizeFromAnySide beta flag in favor of a global io.ConfigResizeWindowsFromEdges [update 1.67 renamed to ConfigWindowsResizeFromEdges] to enable the feature.
 - 2018/08/01 (1.63) - renamed io.OptCursorBlink to io.ConfigCursorBlink [-> io.ConfigInputTextCursorBlink in 1.65], io.OptMacOSXBehaviors to ConfigMacOSXBehaviors for consistency.
 - 2018/07/22 (1.63) - changed ImGui::GetTime() return value from float to double to avoid accumulating floating point imprecisions over time.
 - 2018/07/08 (1.63) - style: renamed ImGuiCol_ModalWindowDarkening to ImGuiCol_ModalWindowDimBg for consistency with other features. Kept redirection enum (will obsolete).
 - 2018/06/08 (1.62) - examples: the imgui_impl_XXX files have been split to separate platform (Win32, GLFW, SDL2, etc.) from renderer (DX11, OpenGL, Vulkan,  etc.).
                       old backends will still work as is, however prefer using the separated backends as they will be updated to support multi-viewports.
                       when adopting new backends follow the main.cpp code of your preferred examples/ folder to know which functions to call.
                       in particular, note that old backends called ImGui::NewFrame() at the end of their ImGui_ImplXXXX_NewFrame() function.
 - 2018/06/06 (1.62) - renamed GetGlyphRangesChinese() to GetGlyphRangesChineseFull() to distinguish other variants and discourage using the full set.
 - 2018/06/06 (1.62) - TreeNodeEx()/TreeNodeBehavior(): the ImGuiTreeNodeFlags_CollapsingHeader helper now include the ImGuiTreeNodeFlags_NoTreePushOnOpen flag. See Changelog for details.
 - 2018/05/03 (1.61) - DragInt(): the default compile-time format string has been changed from "%.0f" to "%d", as we are not using integers internally any more.
                       If you used DragInt() with custom format strings, make sure you change them to use %d or an integer-compatible format.
                       To honor backward-compatibility, the DragInt() code will currently parse and modify format strings to replace %*f with %d, giving time to users to upgrade their code.
                       If you have IMGUI_DISABLE_OBSOLETE_FUNCTIONS enabled, the code will instead assert! You may run a reg-exp search on your codebase for e.g. "DragInt.*%f" to help you find them.
 - 2018/04/28 (1.61) - obsoleted InputFloat() functions taking an optional "int decimal_precision" in favor of an equivalent and more flexible "const char* format",
                       consistent with other functions. Kept redirection functions (will obsolete).
 - 2018/04/09 (1.61) - IM_DELETE() helper function added in 1.60 doesn't clear the input _pointer_ reference, more consistent with expectation and allows passing r-value.
 - 2018/03/20 (1.60) - renamed io.WantMoveMouse to io.WantSetMousePos for consistency and ease of understanding (was added in 1.52, _not_ used by core and only honored by some backend ahead of merging the Nav branch).
 - 2018/03/12 (1.60) - removed ImGuiCol_CloseButton, ImGuiCol_CloseButtonActive, ImGuiCol_CloseButtonHovered as the closing cross uses regular button colors now.
 - 2018/03/08 (1.60) - changed ImFont::DisplayOffset.y to default to 0 instead of +1. Fixed rounding of Ascent/Descent to match TrueType renderer. If you were adding or subtracting to ImFont::DisplayOffset check if your fonts are correctly aligned vertically.
 - 2018/03/03 (1.60) - renamed ImGuiStyleVar_Count_ to ImGuiStyleVar_COUNT and ImGuiMouseCursor_Count_ to ImGuiMouseCursor_COUNT for consistency with other public enums.
 - 2018/02/18 (1.60) - BeginDragDropSource(): temporarily removed the optional mouse_button=0 parameter because it is not really usable in many situations at the moment.
 - 2018/02/16 (1.60) - obsoleted the io.RenderDrawListsFn callback, you can call your graphics engine render function after ImGui::Render(). Use ImGui::GetDrawData() to retrieve the ImDrawData* to display.
 - 2018/02/07 (1.60) - reorganized context handling to be more explicit,
                       - YOU NOW NEED TO CALL ImGui::CreateContext() AT THE BEGINNING OF YOUR APP, AND CALL ImGui::DestroyContext() AT THE END.
                       - removed Shutdown() function, as DestroyContext() serve this purpose.
                       - you may pass a ImFontAtlas* pointer to CreateContext() to share a font atlas between contexts. Otherwise CreateContext() will create its own font atlas instance.
                       - removed allocator parameters from CreateContext(), they are now setup with SetAllocatorFunctions(), and shared by all contexts.
                       - removed the default global context and font atlas instance, which were confusing for users of DLL reloading and users of multiple contexts.
 - 2018/01/31 (1.60) - moved sample TTF files from extra_fonts/ to misc/fonts/. If you loaded files directly from the imgui repo you may need to update your paths.
 - 2018/01/11 (1.60) - obsoleted IsAnyWindowHovered() in favor of IsWindowHovered(ImGuiHoveredFlags_AnyWindow). Kept redirection function (will obsolete).
 - 2018/01/11 (1.60) - obsoleted IsAnyWindowFocused() in favor of IsWindowFocused(ImGuiFocusedFlags_AnyWindow). Kept redirection function (will obsolete).
 - 2018/01/03 (1.60) - renamed ImGuiSizeConstraintCallback to ImGuiSizeCallback, ImGuiSizeConstraintCallbackData to ImGuiSizeCallbackData.
 - 2017/12/29 (1.60) - removed CalcItemRectClosestPoint() which was weird and not really used by anyone except demo code. If you need it it's easy to replicate on your side.
 - 2017/12/24 (1.53) - renamed the emblematic ShowTestWindow() function to ShowDemoWindow(). Kept redirection function (will obsolete).
 - 2017/12/21 (1.53) - ImDrawList: renamed style.AntiAliasedShapes to style.AntiAliasedFill for consistency and as a way to explicitly break code that manipulate those flag at runtime. You can now manipulate ImDrawList::Flags
 - 2017/12/21 (1.53) - ImDrawList: removed 'bool anti_aliased = true' final parameter of ImDrawList::AddPolyline() and ImDrawList::AddConvexPolyFilled(). Prefer manipulating ImDrawList::Flags if you need to toggle them during the frame.
 - 2017/12/14 (1.53) - using the ImGuiWindowFlags_NoScrollWithMouse flag on a child window forwards the mouse wheel event to the parent window, unless either ImGuiWindowFlags_NoInputs or ImGuiWindowFlags_NoScrollbar are also set.
 - 2017/12/13 (1.53) - renamed GetItemsLineHeightWithSpacing() to GetFrameHeightWithSpacing(). Kept redirection function (will obsolete).
 - 2017/12/13 (1.53) - obsoleted IsRootWindowFocused() in favor of using IsWindowFocused(ImGuiFocusedFlags_RootWindow). Kept redirection function (will obsolete).
                     - obsoleted IsRootWindowOrAnyChildFocused() in favor of using IsWindowFocused(ImGuiFocusedFlags_RootAndChildWindows). Kept redirection function (will obsolete).
 - 2017/12/12 (1.53) - renamed ImGuiTreeNodeFlags_AllowOverlapMode to ImGuiTreeNodeFlags_AllowItemOverlap. Kept redirection enum (will obsolete).
 - 2017/12/10 (1.53) - removed SetNextWindowContentWidth(), prefer using SetNextWindowContentSize(). Kept redirection function (will obsolete).
 - 2017/11/27 (1.53) - renamed ImGuiTextBuffer::append() helper to appendf(), appendv() to appendfv(). If you copied the 'Log' demo in your code, it uses appendv() so that needs to be renamed.
 - 2017/11/18 (1.53) - Style, Begin: removed ImGuiWindowFlags_ShowBorders window flag. Borders are now fully set up in the ImGuiStyle structure (see e.g. style.FrameBorderSize, style.WindowBorderSize). Use ImGui::ShowStyleEditor() to look them up.
                       Please note that the style system will keep evolving (hopefully stabilizing in Q1 2018), and so custom styles will probably subtly break over time. It is recommended you use the StyleColorsClassic(), StyleColorsDark(), StyleColorsLight() functions.
 - 2017/11/18 (1.53) - Style: removed ImGuiCol_ComboBg in favor of combo boxes using ImGuiCol_PopupBg for consistency.
 - 2017/11/18 (1.53) - Style: renamed ImGuiCol_ChildWindowBg to ImGuiCol_ChildBg.
 - 2017/11/18 (1.53) - Style: renamed style.ChildWindowRounding to style.ChildRounding, ImGuiStyleVar_ChildWindowRounding to ImGuiStyleVar_ChildRounding.
 - 2017/11/02 (1.53) - obsoleted IsRootWindowOrAnyChildHovered() in favor of using IsWindowHovered(ImGuiHoveredFlags_RootAndChildWindows);
 - 2017/10/24 (1.52) - renamed IMGUI_DISABLE_WIN32_DEFAULT_CLIPBOARD_FUNCS/IMGUI_DISABLE_WIN32_DEFAULT_IME_FUNCS to IMGUI_DISABLE_WIN32_DEFAULT_CLIPBOARD_FUNCTIONS/IMGUI_DISABLE_WIN32_DEFAULT_IME_FUNCTIONS for consistency.
 - 2017/10/20 (1.52) - changed IsWindowHovered() default parameters behavior to return false if an item is active in another window (e.g. click-dragging item from another window to this window). You can use the newly introduced IsWindowHovered() flags to requests this specific behavior if you need it.
 - 2017/10/20 (1.52) - marked IsItemHoveredRect()/IsMouseHoveringWindow() as obsolete, in favor of using the newly introduced flags for IsItemHovered() and IsWindowHovered(). See https://github.com/ocornut/imgui/issues/1382 for details.
                       removed the IsItemRectHovered()/IsWindowRectHovered() names introduced in 1.51 since they were merely more consistent names for the two functions we are now obsoleting.
                         IsItemHoveredRect()        --> IsItemHovered(ImGuiHoveredFlags_RectOnly)
                         IsMouseHoveringAnyWindow() --> IsWindowHovered(ImGuiHoveredFlags_AnyWindow)
                         IsMouseHoveringWindow()    --> IsWindowHovered(ImGuiHoveredFlags_AllowWhenBlockedByPopup | ImGuiHoveredFlags_AllowWhenBlockedByActiveItem) [weird, old behavior]
 - 2017/10/17 (1.52) - marked the old 5-parameters version of Begin() as obsolete (still available). Use SetNextWindowSize()+Begin() instead!
 - 2017/10/11 (1.52) - renamed AlignFirstTextHeightToWidgets() to AlignTextToFramePadding(). Kept inline redirection function (will obsolete).
 - 2017/09/26 (1.52) - renamed ImFont::Glyph to ImFontGlyph. Kept redirection typedef (will obsolete).
 - 2017/09/25 (1.52) - removed SetNextWindowPosCenter() because SetNextWindowPos() now has the optional pivot information to do the same and more. Kept redirection function (will obsolete).
 - 2017/08/25 (1.52) - io.MousePos needs to be set to ImVec2(-FLT_MAX,-FLT_MAX) when mouse is unavailable/missing. Previously ImVec2(-1,-1) was enough but we now accept negative mouse coordinates. In your backend if you need to support unavailable mouse, make sure to replace "io.MousePos = ImVec2(-1,-1)" with "io.MousePos = ImVec2(-FLT_MAX,-FLT_MAX)".
 - 2017/08/22 (1.51) - renamed IsItemHoveredRect() to IsItemRectHovered(). Kept inline redirection function (will obsolete). -> (1.52) use IsItemHovered(ImGuiHoveredFlags_RectOnly)!
                     - renamed IsMouseHoveringAnyWindow() to IsAnyWindowHovered() for consistency. Kept inline redirection function (will obsolete).
                     - renamed IsMouseHoveringWindow() to IsWindowRectHovered() for consistency. Kept inline redirection function (will obsolete).
 - 2017/08/20 (1.51) - renamed GetStyleColName() to GetStyleColorName() for consistency.
 - 2017/08/20 (1.51) - added PushStyleColor(ImGuiCol idx, ImU32 col) overload, which _might_ cause an "ambiguous call" compilation error if you are using ImColor() with implicit cast. Cast to ImU32 or ImVec4 explicily to fix.
 - 2017/08/15 (1.51) - marked the weird IMGUI_ONCE_UPON_A_FRAME helper macro as obsolete. prefer using the more explicit ImGuiOnceUponAFrame type.
 - 2017/08/15 (1.51) - changed parameter order for BeginPopupContextWindow() from (const char*,int buttons,bool also_over_items) to (const char*,int buttons,bool also_over_items). Note that most calls relied on default parameters completely.
 - 2017/08/13 (1.51) - renamed ImGuiCol_Column to ImGuiCol_Separator, ImGuiCol_ColumnHovered to ImGuiCol_SeparatorHovered, ImGuiCol_ColumnActive to ImGuiCol_SeparatorActive. Kept redirection enums (will obsolete).
 - 2017/08/11 (1.51) - renamed ImGuiSetCond_Always to ImGuiCond_Always, ImGuiSetCond_Once to ImGuiCond_Once, ImGuiSetCond_FirstUseEver to ImGuiCond_FirstUseEver, ImGuiSetCond_Appearing to ImGuiCond_Appearing. Kept redirection enums (will obsolete).
 - 2017/08/09 (1.51) - removed ValueColor() helpers, they are equivalent to calling Text(label) + SameLine() + ColorButton().
 - 2017/08/08 (1.51) - removed ColorEditMode() and ImGuiColorEditMode in favor of ImGuiColorEditFlags and parameters to the various Color*() functions. The SetColorEditOptions() allows to initialize default but the user can still change them with right-click context menu.
                     - changed prototype of 'ColorEdit4(const char* label, float col[4], bool show_alpha = true)' to 'ColorEdit4(const char* label, float col[4], ImGuiColorEditFlags flags = 0)', where passing flags = 0x01 is a safe no-op (hello dodgy backward compatibility!). - check and run the demo window, under "Color/Picker Widgets", to understand the various new options.
                     - changed prototype of rarely used 'ColorButton(ImVec4 col, bool small_height = false, bool outline_border = true)' to 'ColorButton(const char* desc_id, ImVec4 col, ImGuiColorEditFlags flags = 0, ImVec2 size = ImVec2(0, 0))'
 - 2017/07/20 (1.51) - removed IsPosHoveringAnyWindow(ImVec2), which was partly broken and misleading. ASSERT + redirect user to io.WantCaptureMouse
 - 2017/05/26 (1.50) - removed ImFontConfig::MergeGlyphCenterV in favor of a more multipurpose ImFontConfig::GlyphOffset.
 - 2017/05/01 (1.50) - renamed ImDrawList::PathFill() (rarely used directly) to ImDrawList::PathFillConvex() for clarity.
 - 2016/11/06 (1.50) - BeginChild(const char*) now applies the stack id to the provided label, consistently with other functions as it should always have been. It shouldn't affect you unless (extremely unlikely) you were appending multiple times to a same child from different locations of the stack id. If that's the case, generate an id with GetID() and use it instead of passing string to BeginChild().
 - 2016/10/15 (1.50) - avoid 'void* user_data' parameter to io.SetClipboardTextFn/io.GetClipboardTextFn pointers. We pass io.ClipboardUserData to it.
 - 2016/09/25 (1.50) - style.WindowTitleAlign is now a ImVec2 (ImGuiAlign enum was removed). set to (0.5f,0.5f) for horizontal+vertical centering, (0.0f,0.0f) for upper-left, etc.
 - 2016/07/30 (1.50) - SameLine(x) with x>0.0f is now relative to left of column/group if any, and not always to left of window. This was sort of always the intent and hopefully, breakage should be minimal.
 - 2016/05/12 (1.49) - title bar (using ImGuiCol_TitleBg/ImGuiCol_TitleBgActive colors) isn't rendered over a window background (ImGuiCol_WindowBg color) anymore.
                       If your TitleBg/TitleBgActive alpha was 1.0f or you are using the default theme it will not affect you, otherwise if <1.0f you need to tweak your custom theme to readjust for the fact that we don't draw a WindowBg background behind the title bar.
                       This helper function will convert an old TitleBg/TitleBgActive color into a new one with the same visual output, given the OLD color and the OLD WindowBg color:
                       ImVec4 ConvertTitleBgCol(const ImVec4& win_bg_col, const ImVec4& title_bg_col) { float new_a = 1.0f - ((1.0f - win_bg_col.w) * (1.0f - title_bg_col.w)), k = title_bg_col.w / new_a; return ImVec4((win_bg_col.x * win_bg_col.w + title_bg_col.x) * k, (win_bg_col.y * win_bg_col.w + title_bg_col.y) * k, (win_bg_col.z * win_bg_col.w + title_bg_col.z) * k, new_a); }
                       If this is confusing, pick the RGB value from title bar from an old screenshot and apply this as TitleBg/TitleBgActive. Or you may just create TitleBgActive from a tweaked TitleBg color.
 - 2016/05/07 (1.49) - removed confusing set of GetInternalState(), GetInternalStateSize(), SetInternalState() functions. Now using CreateContext(), DestroyContext(), GetCurrentContext(), SetCurrentContext().
 - 2016/05/02 (1.49) - renamed SetNextTreeNodeOpened() to SetNextTreeNodeOpen(), no redirection.
 - 2016/05/01 (1.49) - obsoleted old signature of CollapsingHeader(const char* label, const char* str_id = NULL, bool display_frame = true, bool default_open = false) as extra parameters were badly designed and rarely used. You can replace the "default_open = true" flag in new API with CollapsingHeader(label, ImGuiTreeNodeFlags_DefaultOpen).
 - 2016/04/26 (1.49) - changed ImDrawList::PushClipRect(ImVec4 rect) to ImDrawList::PushClipRect(Imvec2 min,ImVec2 max,bool intersect_with_current_clip_rect=false). Note that higher-level ImGui::PushClipRect() is preferable because it will clip at logic/widget level, whereas ImDrawList::PushClipRect() only affect your renderer.
 - 2016/04/03 (1.48) - removed style.WindowFillAlphaDefault setting which was redundant. Bake default BG alpha inside style.Colors[ImGuiCol_WindowBg] and all other Bg color values. (ref GitHub issue #337).
 - 2016/04/03 (1.48) - renamed ImGuiCol_TooltipBg to ImGuiCol_PopupBg, used by popups/menus and tooltips. popups/menus were previously using ImGuiCol_WindowBg. (ref github issue #337)
 - 2016/03/21 (1.48) - renamed GetWindowFont() to GetFont(), GetWindowFontSize() to GetFontSize(). Kept inline redirection function (will obsolete).
 - 2016/03/02 (1.48) - InputText() completion/history/always callbacks: if you modify the text buffer manually (without using DeleteChars()/InsertChars() helper) you need to maintain the BufTextLen field. added an assert.
 - 2016/01/23 (1.48) - fixed not honoring exact width passed to PushItemWidth(), previously it would add extra FramePadding.x*2 over that width. if you had manual pixel-perfect alignment in place it might affect you.
 - 2015/12/27 (1.48) - fixed ImDrawList::AddRect() which used to render a rectangle 1 px too large on each axis.
 - 2015/12/04 (1.47) - renamed Color() helpers to ValueColor() - dangerously named, rarely used and probably to be made obsolete.
 - 2015/08/29 (1.45) - with the addition of horizontal scrollbar we made various fixes to inconsistencies with dealing with cursor position.
                       GetCursorPos()/SetCursorPos() functions now include the scrolled amount. It shouldn't affect the majority of users, but take note that SetCursorPosX(100.0f) puts you at +100 from the starting x position which may include scrolling, not at +100 from the window left side.
                       GetContentRegionMax()/GetWindowContentRegionMin()/GetWindowContentRegionMax() functions allow include the scrolled amount. Typically those were used in cases where no scrolling would happen so it may not be a problem, but watch out!
 - 2015/08/29 (1.45) - renamed style.ScrollbarWidth to style.ScrollbarSize
 - 2015/08/05 (1.44) - split imgui.cpp into extra files: imgui_demo.cpp imgui_draw.cpp imgui_internal.h that you need to add to your project.
 - 2015/07/18 (1.44) - fixed angles in ImDrawList::PathArcTo(), PathArcToFast() (introduced in 1.43) being off by an extra PI for no justifiable reason
 - 2015/07/14 (1.43) - add new ImFontAtlas::AddFont() API. For the old AddFont***, moved the 'font_no' parameter of ImFontAtlas::AddFont** functions to the ImFontConfig structure.
                       you need to render your textured triangles with bilinear filtering to benefit from sub-pixel positioning of text.
 - 2015/07/08 (1.43) - switched rendering data to use indexed rendering. this is saving a fair amount of CPU/GPU and enables us to get anti-aliasing for a marginal cost.
                       this necessary change will break your rendering function! the fix should be very easy. sorry for that :(
                     - if you are using a vanilla copy of one of the imgui_impl_XXX.cpp provided in the example, you just need to update your copy and you can ignore the rest.
                     - the signature of the io.RenderDrawListsFn handler has changed!
                       old: ImGui_XXXX_RenderDrawLists(ImDrawList** const cmd_lists, int cmd_lists_count)
                       new: ImGui_XXXX_RenderDrawLists(ImDrawData* draw_data).
                         parameters: 'cmd_lists' becomes 'draw_data->CmdLists', 'cmd_lists_count' becomes 'draw_data->CmdListsCount'
                         ImDrawList: 'commands' becomes 'CmdBuffer', 'vtx_buffer' becomes 'VtxBuffer', 'IdxBuffer' is new.
                         ImDrawCmd:  'vtx_count' becomes 'ElemCount', 'clip_rect' becomes 'ClipRect', 'user_callback' becomes 'UserCallback', 'texture_id' becomes 'TextureId'.
                     - each ImDrawList now contains both a vertex buffer and an index buffer. For each command, render ElemCount/3 triangles using indices from the index buffer.
                     - if you REALLY cannot render indexed primitives, you can call the draw_data->DeIndexAllBuffers() method to de-index the buffers. This is slow and a waste of CPU/GPU. Prefer using indexed rendering!
                     - refer to code in the examples/ folder or ask on the GitHub if you are unsure of how to upgrade. please upgrade!
 - 2015/07/10 (1.43) - changed SameLine() parameters from int to float.
 - 2015/07/02 (1.42) - renamed SetScrollPosHere() to SetScrollFromCursorPos(). Kept inline redirection function (will obsolete).
 - 2015/07/02 (1.42) - renamed GetScrollPosY() to GetScrollY(). Necessary to reduce confusion along with other scrolling functions, because positions (e.g. cursor position) are not equivalent to scrolling amount.
 - 2015/06/14 (1.41) - changed ImageButton() default bg_col parameter from (0,0,0,1) (black) to (0,0,0,0) (transparent) - makes a difference when texture have transparence
 - 2015/06/14 (1.41) - changed Selectable() API from (label, selected, size) to (label, selected, flags, size). Size override should have been rarely used. Sorry!
 - 2015/05/31 (1.40) - renamed GetWindowCollapsed() to IsWindowCollapsed() for consistency. Kept inline redirection function (will obsolete).
 - 2015/05/31 (1.40) - renamed IsRectClipped() to IsRectVisible() for consistency. Note that return value is opposite! Kept inline redirection function (will obsolete).
 - 2015/05/27 (1.40) - removed the third 'repeat_if_held' parameter from Button() - sorry! it was rarely used and inconsistent. Use PushButtonRepeat(true) / PopButtonRepeat() to enable repeat on desired buttons.
 - 2015/05/11 (1.40) - changed BeginPopup() API, takes a string identifier instead of a bool. ImGui needs to manage the open/closed state of popups. Call OpenPopup() to actually set the "open" state of a popup. BeginPopup() returns true if the popup is opened.
 - 2015/05/03 (1.40) - removed style.AutoFitPadding, using style.WindowPadding makes more sense (the default values were already the same).
 - 2015/04/13 (1.38) - renamed IsClipped() to IsRectClipped(). Kept inline redirection function until 1.50.
 - 2015/04/09 (1.38) - renamed ImDrawList::AddArc() to ImDrawList::AddArcFast() for compatibility with future API
 - 2015/04/03 (1.38) - removed ImGuiCol_CheckHovered, ImGuiCol_CheckActive, replaced with the more general ImGuiCol_FrameBgHovered, ImGuiCol_FrameBgActive.
 - 2014/04/03 (1.38) - removed support for passing -FLT_MAX..+FLT_MAX as the range for a SliderFloat(). Use DragFloat() or Inputfloat() instead.
 - 2015/03/17 (1.36) - renamed GetItemBoxMin()/GetItemBoxMax()/IsMouseHoveringBox() to GetItemRectMin()/GetItemRectMax()/IsMouseHoveringRect(). Kept inline redirection function until 1.50.
 - 2015/03/15 (1.36) - renamed style.TreeNodeSpacing to style.IndentSpacing, ImGuiStyleVar_TreeNodeSpacing to ImGuiStyleVar_IndentSpacing
 - 2015/03/13 (1.36) - renamed GetWindowIsFocused() to IsWindowFocused(). Kept inline redirection function until 1.50.
 - 2015/03/08 (1.35) - renamed style.ScrollBarWidth to style.ScrollbarWidth (casing)
 - 2015/02/27 (1.34) - renamed OpenNextNode(bool) to SetNextTreeNodeOpened(bool, ImGuiSetCond). Kept inline redirection function until 1.50.
 - 2015/02/27 (1.34) - renamed ImGuiSetCondition_*** to ImGuiSetCond_***, and _FirstUseThisSession becomes _Once.
 - 2015/02/11 (1.32) - changed text input callback ImGuiTextEditCallback return type from void-->int. reserved for future use, return 0 for now.
 - 2015/02/10 (1.32) - renamed GetItemWidth() to CalcItemWidth() to clarify its evolving behavior
 - 2015/02/08 (1.31) - renamed GetTextLineSpacing() to GetTextLineHeightWithSpacing()
 - 2015/02/01 (1.31) - removed IO.MemReallocFn (unused)
 - 2015/01/19 (1.30) - renamed ImGuiStorage::GetIntPtr()/GetFloatPtr() to GetIntRef()/GetIntRef() because Ptr was conflicting with actual pointer storage functions.
 - 2015/01/11 (1.30) - big font/image API change! now loads TTF file. allow for multiple fonts. no need for a PNG loader.
 - 2015/01/11 (1.30) - removed GetDefaultFontData(). uses io.Fonts->GetTextureData*() API to retrieve uncompressed pixels.
                       - old:  const void* png_data; unsigned int png_size; ImGui::GetDefaultFontData(NULL, NULL, &png_data, &png_size); [..Upload texture to GPU..];
                       - new:  unsigned char* pixels; int width, height; io.Fonts->GetTexDataAsRGBA32(&pixels, &width, &height); [..Upload texture to GPU..]; io.Fonts->SetTexID(YourTexIdentifier);
                       you now have more flexibility to load multiple TTF fonts and manage the texture buffer for internal needs. It is now recommended that you sample the font texture with bilinear interpolation.
 - 2015/01/11 (1.30) - added texture identifier in ImDrawCmd passed to your render function (we can now render images). make sure to call io.Fonts->SetTexID()
 - 2015/01/11 (1.30) - removed IO.PixelCenterOffset (unnecessary, can be handled in user projection matrix)
 - 2015/01/11 (1.30) - removed ImGui::IsItemFocused() in favor of ImGui::IsItemActive() which handles all widgets
 - 2014/12/10 (1.18) - removed SetNewWindowDefaultPos() in favor of new generic API SetNextWindowPos(pos, ImGuiSetCondition_FirstUseEver)
 - 2014/11/28 (1.17) - moved IO.Font*** options to inside the IO.Font-> structure (FontYOffset, FontTexUvForWhite, FontBaseScale, FontFallbackGlyph)
 - 2014/11/26 (1.17) - reworked syntax of IMGUI_ONCE_UPON_A_FRAME helper macro to increase compiler compatibility
 - 2014/11/07 (1.15) - renamed IsHovered() to IsItemHovered()
 - 2014/10/02 (1.14) - renamed IMGUI_INCLUDE_IMGUI_USER_CPP to IMGUI_INCLUDE_IMGUI_USER_INL and imgui_user.cpp to imgui_user.inl (more IDE friendly)
 - 2014/09/25 (1.13) - removed 'text_end' parameter from IO.SetClipboardTextFn (the string is now always zero-terminated for simplicity)
 - 2014/09/24 (1.12) - renamed SetFontScale() to SetWindowFontScale()
 - 2014/09/24 (1.12) - moved IM_MALLOC/IM_REALLOC/IM_FREE preprocessor defines to IO.MemAllocFn/IO.MemReallocFn/IO.MemFreeFn
 - 2014/08/30 (1.09) - removed IO.FontHeight (now computed automatically)
 - 2014/08/30 (1.09) - moved IMGUI_FONT_TEX_UV_FOR_WHITE preprocessor define to IO.FontTexUvForWhite
 - 2014/08/28 (1.09) - changed the behavior of IO.PixelCenterOffset following various rendering fixes


 FREQUENTLY ASKED QUESTIONS (FAQ)
 ================================

 Read all answers online:
   https://www.dearimgui.com/faq or https://github.com/ocornut/imgui/blob/master/docs/FAQ.md (same url)
 Read all answers locally (with a text editor or ideally a Markdown viewer):
   docs/FAQ.md
 Some answers are copied down here to facilitate searching in code.

 Q&A: Basics
 ===========

 Q: Where is the documentation?
 A: This library is poorly documented at the moment and expects the user to be acquainted with C/C++.
    - Run the examples/ applications and explore them.
    - Read Getting Started (https://github.com/ocornut/imgui/wiki/Getting-Started) guide.
    - See demo code in imgui_demo.cpp and particularly the ImGui::ShowDemoWindow() function.
    - The demo covers most features of Dear ImGui, so you can read the code and see its output.
    - See documentation and comments at the top of imgui.cpp + effectively imgui.h.
    - 20+ standalone example applications using e.g. OpenGL/DirectX are provided in the
      examples/ folder to explain how to integrate Dear ImGui with your own engine/application.
    - The Wiki (https://github.com/ocornut/imgui/wiki) has many resources and links.
    - The Glossary (https://github.com/ocornut/imgui/wiki/Glossary) page also may be useful.
    - Your programming IDE is your friend, find the type or function declaration to find comments
      associated with it.

 Q: What is this library called?
 Q: Which version should I get?
 >> This library is called "Dear ImGui", please don't call it "ImGui" :)
 >> See https://www.dearimgui.com/faq for details.

 Q&A: Integration
 ================

 Q: How to get started?
 A: Read https://github.com/ocornut/imgui/wiki/Getting-Started. Read 'PROGRAMMER GUIDE' above. Read examples/README.txt.

 Q: How can I tell whether to dispatch mouse/keyboard to Dear ImGui or my application?
 A: You should read the 'io.WantCaptureMouse', 'io.WantCaptureKeyboard' and 'io.WantTextInput' flags!
 >> See https://www.dearimgui.com/faq for a fully detailed answer. You really want to read this.

 Q. How can I enable keyboard or gamepad controls?
 Q: How can I use this on a machine without mouse, keyboard or screen? (input share, remote display)
 Q: I integrated Dear ImGui in my engine and little squares are showing instead of text...
 Q: I integrated Dear ImGui in my engine and some elements are clipping or disappearing when I move windows around...
 Q: I integrated Dear ImGui in my engine and some elements are displaying outside their expected windows boundaries...
 >> See https://www.dearimgui.com/faq

 Q&A: Usage
 ----------

 Q: About the ID Stack system..
   - Why is my widget not reacting when I click on it?
   - How can I have widgets with an empty label?
   - How can I have multiple widgets with the same label?
   - How can I have multiple windows with the same label?
 Q: How can I display an image? What is ImTextureID, how does it work?
 Q: How can I use my own math types instead of ImVec2?
 Q: How can I interact with standard C++ types (such as std::string and std::vector)?
 Q: How can I display custom shapes? (using low-level ImDrawList API)
 >> See https://www.dearimgui.com/faq

 Q&A: Fonts, Text
 ================

 Q: How should I handle DPI in my application?
 Q: How can I load a different font than the default?
 Q: How can I easily use icons in my application?
 Q: How can I load multiple fonts?
 Q: How can I display and input non-Latin characters such as Chinese, Japanese, Korean, Cyrillic?
 >> See https://www.dearimgui.com/faq and https://github.com/ocornut/imgui/blob/master/docs/FONTS.md

 Q&A: Concerns
 =============

 Q: Who uses Dear ImGui?
 Q: Can you create elaborate/serious tools with Dear ImGui?
 Q: Can you reskin the look of Dear ImGui?
 Q: Why using C++ (as opposed to C)?
 >> See https://www.dearimgui.com/faq

 Q&A: Community
 ==============

 Q: How can I help?
 A: - Businesses: please reach out to "omar AT dearimgui DOT com" if you work in a place using Dear ImGui!
      We can discuss ways for your company to fund development via invoiced technical support, maintenance or sponsoring contacts.
      This is among the most useful thing you can do for Dear ImGui. With increased funding, we sustain and grow work on this project.
      >>> See https://github.com/ocornut/imgui/wiki/Funding
    - Businesses: you can also purchase licenses for the Dear ImGui Automation/Test Engine.
    - If you are experienced with Dear ImGui and C++, look at the GitHub issues, look at the Wiki, and see how you want to help and can help!
    - Disclose your usage of Dear ImGui via a dev blog post, a tweet, a screenshot, a mention somewhere etc.
      You may post screenshot or links in the gallery threads. Visuals are ideal as they inspire other programmers.
      But even without visuals, disclosing your use of dear imgui helps the library grow credibility, and help other teams and programmers with taking decisions.
    - If you have issues or if you need to hack into the library, even if you don't expect any support it is useful that you share your issues (on GitHub or privately).

*/

//-------------------------------------------------------------------------
// [SECTION] INCLUDES
//-------------------------------------------------------------------------

// dear imgui, v1.91.7 WIP
// (headers)

// Help:
// - See links below.
// - Call and read ImGui::ShowDemoWindow() in imgui_demo.cpp. All applications in examples/ are doing that.
// - Read top of imgui.cpp for more details, links and comments.

// Resources:
// - FAQ ........................ https://dearimgui.com/faq (in repository as docs/FAQ.md)
// - Homepage ................... https://github.com/ocornut/imgui
// - Releases & changelog ....... https://github.com/ocornut/imgui/releases
// - Gallery .................... https://github.com/ocornut/imgui/issues?q=label%3Agallery (please post your screenshots/video there!)
// - Wiki ....................... https://github.com/ocornut/imgui/wiki (lots of good stuff there)
//   - Getting Started            https://github.com/ocornut/imgui/wiki/Getting-Started (how to integrate in an existing app by adding ~25 lines of code)
//   - Third-party Extensions     https://github.com/ocornut/imgui/wiki/Useful-Extensions (ImPlot & many more)
//   - Bindings/Backends          https://github.com/ocornut/imgui/wiki/Bindings (language bindings, backends for various tech/engines)
//   - Glossary                   https://github.com/ocornut/imgui/wiki/Glossary
//   - Debug Tools                https://github.com/ocornut/imgui/wiki/Debug-Tools
//   - Software using Dear ImGui  https://github.com/ocornut/imgui/wiki/Software-using-dear-imgui
// - Issues & support ........... https://github.com/ocornut/imgui/issues
// - Test Engine & Automation ... https://github.com/ocornut/imgui_test_engine (test suite, test engine to automate your apps)

// For first-time users having issues compiling/linking/running/loading fonts:
// please post in https://github.com/ocornut/imgui/discussions if you cannot find a solution in resources above.
// Everything else should be asked in 'Issues'! We are building a database of cross-linked knowledge there.

// Library Version
// (Integer encoded as XYYZZ for use in #if preprocessor conditionals, e.g. '#if IMGUI_VERSION_NUM >= 12345')
IMGUI_VERSION :: "1.91.7 WIP"
IMGUI_VERSION_NUM :: 19164
IMGUI_HAS_TABLE :: true
IMGUI_HAS_VIEWPORT :: true// Viewport WIP branch
IMGUI_HAS_DOCK :: true// Docking WIP branch

/*

Index of this file:
// [SECTION] Header mess
// [SECTION] Forward declarations and basic types
// [SECTION] Dear ImGui end-user API functions
// [SECTION] Flags & Enumerations
// [SECTION] Tables API flags and structures (ImGuiTableFlags, ImGuiTableColumnFlags, ImGuiTableRowFlags, ImGuiTableBgTarget, ImGuiTableSortSpecs, ImGuiTableColumnSortSpecs)
// [SECTION] Helpers: Debug log, Memory allocations macros, ImVector<>
// [SECTION] ImGuiStyle
// [SECTION] ImGuiIO
// [SECTION] Misc data structures (ImGuiInputTextCallbackData, ImGuiSizeCallbackData, ImGuiWindowClass, ImGuiPayload)
// [SECTION] Helpers (ImGuiOnceUponAFrame, ImGuiTextFilter, ImGuiTextBuffer, ImGuiStorage, ImGuiListClipper, Math Operators, ImColor)
// [SECTION] Multi-Select API flags and structures (ImGuiMultiSelectFlags, ImGuiMultiSelectIO, ImGuiSelectionRequest, ImGuiSelectionBasicStorage, ImGuiSelectionExternalStorage)
// [SECTION] Drawing API (ImDrawCallback, ImDrawCmd, ImDrawIdx, ImDrawVert, ImDrawChannel, ImDrawListSplitter, ImDrawFlags, ImDrawListFlags, ImDrawList, ImDrawData)
// [SECTION] Font API (ImFontConfig, ImFontGlyph, ImFontGlyphRangesBuilder, ImFontAtlasFlags, ImFontAtlas, ImFont)
// [SECTION] Viewports (ImGuiViewportFlags, ImGuiViewport)
// [SECTION] ImGuiPlatformIO + other Platform Dependent Interfaces (ImGuiPlatformMonitor, ImGuiPlatformImeData)
// [SECTION] Obsolete functions and types

*/





//-----------------------------------------------------------------------------
// [SECTION] Header mess
//-----------------------------------------------------------------------------

// Helper Macros
IM_ASSERT :: #force_inline proc(_EXPR : $T0, _e := #caller_expression(_EXPR))
{
	assert(_EXPR, _e)// You can override the default assert handler by editing imconfig.h
}

IM_ARRAYSIZE :: #force_inline proc "contextless" (_ARR : $T0) -> int
{
	return len(_ARR)
}

IM_UNUSED :: #force_inline proc "contextless" (_VAR : $T0)
{
	_ = _VAR
}


// Check that version and structures layouts are matching between compiled imgui code and caller. Read comments above DebugCheckVersionAndDataLayout() for details.
CHECKVERSION :: #force_inline proc()
{
	DebugCheckVersionAndDataLayout(IMGUI_VERSION,size_of(ImGuiIO),size_of(ImGuiStyle),size_of(ImVec2),size_of(ImVec4),size_of(ImDrawVert),size_of(ImDrawIdx))
}


//-----------------------------------------------------------------------------
// [SECTION] Forward declarations and basic types
//-----------------------------------------------------------------------------

// Scalar data types
ImGuiID :: u32// A unique ID used by widgets (typically the result of hashing a stack of string)
ImS8 :: i8// 8-bit signed integer
ImU8 :: u8// 8-bit unsigned integer
ImS16 :: i16// 16-bit signed integer
ImU16 :: u16// 16-bit unsigned integer
ImS32 :: i32// 32-bit signed integer == int
ImU32 :: u32// 32-bit unsigned integer (often used to store packed colors)
ImS64 :: i64// 64-bit signed integer
ImU64 :: u64// -> enum ImGuiSortDirection    // Enum: A sorting direction (ascending or descending)
ImGuiCol :: ImGuiCol_// -> enum ImGuiCol_             // Enum: A color identifier for styling
ImGuiCond :: ImGuiCond_// -> enum ImGuiCond_            // Enum: A condition for many Set*() functions
ImGuiDataType :: ImGuiDataType_// -> enum ImGuiDataType_        // Enum: A primary data type
ImGuiMouseButton :: ImGuiMouseButton_// -> enum ImGuiMouseButton_     // Enum: A mouse button identifier (0=left, 1=right, 2=middle)
ImGuiMouseCursor :: ImGuiMouseCursor_// -> enum ImGuiMouseCursor_     // Enum: A mouse cursor shape
ImGuiStyleVar :: ImGuiStyleVar_// -> enum ImGuiStyleVar_        // Enum: A variable identifier for styling
ImGuiTableBgTarget :: ImGuiTableBgTarget_// -> enum ImGuiTableBgTarget_   // Enum: A color target for TableSetBgColor()

// Flags (declared as int to allow using as flags without overhead, and to not pollute the top of this file)
// - Tip: Use your programming IDE navigation facilities on the names in the _central column_ below to find the actual flags/enum lists!
//   - In Visual Studio: CTRL+comma ("Edit.GoToAll") can follow symbols inside comments, whereas CTRL+F12 ("Edit.GoToImplementation") cannot.
//   - In Visual Studio w/ Visual Assist installed: ALT+G ("VAssistX.GoToImplementation") can also follow symbols inside comments.
//   - In VS Code, CLion, etc.: CTRL+click can follow symbols inside comments.
ImDrawFlags :: i32// -> enum ImDrawFlags_          // Flags: for ImDrawList functions
ImDrawListFlags :: i32// -> enum ImDrawListFlags_      // Flags: for ImDrawList instance
ImFontAtlasFlags :: i32// -> enum ImFontAtlasFlags_     // Flags: for ImFontAtlas build
ImGuiBackendFlags :: i32// -> enum ImGuiBackendFlags_    // Flags: for io.BackendFlags
ImGuiButtonFlags :: i32// -> enum ImGuiButtonFlags_     // Flags: for InvisibleButton()
ImGuiChildFlags :: i32// -> enum ImGuiChildFlags_      // Flags: for BeginChild()
ImGuiColorEditFlags :: i32// -> enum ImGuiColorEditFlags_  // Flags: for ColorEdit4(), ColorPicker4() etc.
ImGuiConfigFlags :: i32// -> enum ImGuiConfigFlags_     // Flags: for io.ConfigFlags
ImGuiComboFlags :: i32// -> enum ImGuiComboFlags_      // Flags: for BeginCombo()
ImGuiDockNodeFlags :: i32// -> enum ImGuiDockNodeFlags_   // Flags: for DockSpace()
ImGuiDragDropFlags :: i32// -> enum ImGuiDragDropFlags_   // Flags: for BeginDragDropSource(), AcceptDragDropPayload()
ImGuiFocusedFlags :: i32// -> enum ImGuiFocusedFlags_    // Flags: for IsWindowFocused()
ImGuiHoveredFlags :: i32// -> enum ImGuiHoveredFlags_    // Flags: for IsItemHovered(), IsWindowHovered() etc.
ImGuiInputFlags :: i32// -> enum ImGuiInputFlags_      // Flags: for Shortcut(), SetNextItemShortcut()
ImGuiInputTextFlags :: i32// -> enum ImGuiInputTextFlags_  // Flags: for InputText(), InputTextMultiline()
ImGuiItemFlags :: i32// -> enum ImGuiItemFlags_       // Flags: for PushItemFlag(), shared by all items
ImGuiKeyChord :: i32// -> ImGuiKey | ImGuiMod_XXX    // Flags: for IsKeyChordPressed(), Shortcut() etc. an ImGuiKey optionally OR-ed with one or more ImGuiMod_XXX values.
ImGuiPopupFlags :: i32// -> enum ImGuiPopupFlags_      // Flags: for OpenPopup*(), BeginPopupContext*(), IsPopupOpen()
ImGuiMultiSelectFlags :: i32// -> enum ImGuiMultiSelectFlags_// Flags: for BeginMultiSelect()
ImGuiSelectableFlags :: i32// -> enum ImGuiSelectableFlags_ // Flags: for Selectable()
ImGuiSliderFlags :: i32// -> enum ImGuiSliderFlags_     // Flags: for DragFloat(), DragInt(), SliderFloat(), SliderInt() etc.
ImGuiTabBarFlags :: i32// -> enum ImGuiTabBarFlags_     // Flags: for BeginTabBar()
ImGuiTabItemFlags :: i32// -> enum ImGuiTabItemFlags_    // Flags: for BeginTabItem()
ImGuiTableFlags :: i32// -> enum ImGuiTableFlags_      // Flags: For BeginTable()
ImGuiTableColumnFlags :: i32// -> enum ImGuiTableColumnFlags_// Flags: For TableSetupColumn()
ImGuiTableRowFlags :: i32// -> enum ImGuiTableRowFlags_   // Flags: For TableNextRow()
ImGuiTreeNodeFlags :: i32// -> enum ImGuiTreeNodeFlags_   // Flags: for TreeNode(), TreeNodeEx(), CollapsingHeader()
ImGuiViewportFlags :: i32// -> enum ImGuiViewportFlags_   // Flags: for ImGuiViewport
ImGuiWindowFlags :: i32// -> enum ImGuiWindowFlags_     // Flags: for Begin(), BeginChild()

// ImTexture: user data for renderer backend to identify a texture [Compile-time configurable type]
// - To use something else than an opaque void* pointer: override with e.g. '#define ImTextureID MyTextureType*' in your imconfig.h file.
// - This can be whatever to you want it to be! read the FAQ about ImTextureID for details.
// - You can make this a structure with various constructors if you need. You will have to implement ==/!= operators.
// - (note: before v1.91.4 (2024/10/08) the default type for ImTextureID was void*. Use intermediary intptr_t cast and read FAQ if you have casting warnings)
//when ! defined ( ImTextureID ) {
ImTextureID :: ImU64// Default: store a pointer or an integer fitting in a pointer (most renderer backends are ok with that)
//} // preproc endif

// ImDrawIdx: vertex index. [Compile-time configurable type]
// - To use 16-bit indices + allow large meshes: backend need to set 'io.BackendFlags |= ImGuiBackendFlags_RendererHasVtxOffset' and handle ImDrawCmd::VtxOffset (recommended).
// - To use 32-bit indices: override with '#define ImDrawIdx unsigned int' in your imconfig.h file.
//when ! defined ( ImDrawIdx ) {
ImDrawIdx :: u16// Default: 16-bit (for maximum compatibility with renderer backends)
//} // preproc endif

// Character types
// (we generally use UTF-8 encoded string in the API. This is storage specifically for a decoded character used for keyboard input and display)
ImWchar32 :: u32// A single decoded U32 character/code point. We encode them as multi bytes UTF-8 when used in strings.
ImWchar16 :: u16// A single decoded U16 character/code point. We encode them as multi bytes UTF-8 when used in strings.
when IMGUI_USE_WCHAR32 { // ImWchar [configurable type: override in imconfig.h with '#define IMGUI_USE_WCHAR32' to support Unicode planes 1-16]
ImWchar :: ImWchar32
} else { // preproc else
ImWchar :: ImWchar16
} // preproc endif

// Multi-Selection item index or identifier when using BeginMultiSelect()
// - Used by SetNextItemSelectionUserData() + and inside ImGuiMultiSelectIO structure.
// - Most users are likely to use this store an item INDEX but this may be used to store a POINTER/ID as well. Read comments near ImGuiMultiSelectIO for details.
ImGuiSelectionUserData :: ImS64

// Callback and functions types
ImGuiInputTextCallback :: proc(data : ^ImGuiInputTextCallbackData) -> i32// Callback function for ImGui::InputText()
ImGuiSizeCallback :: proc(data : ^ImGuiSizeCallbackData)// Callback function for ImGui::SetNextWindowSizeConstraints()
ImGuiMemAllocFunc :: proc(sz : uint, user_data : rawptr) -> rawptr// Function signature for ImGui::SetAllocatorFunctions()
ImGuiMemFreeFunc :: proc(ptr : rawptr, user_data : rawptr)// Function signature for ImGui::SetAllocatorFunctions()

// ImVec2: 2D vector used to store positions, sizes etc. [Compile-time configurable type]

ImVec2 :: struct {
	x : f32, y : f32,
}

ImVec2_init_0 :: proc(this : ^ImVec2)
{
	this.x = 0.0
	this.y = 0.0
}

ImVec2_init_1 :: proc(this : ^ImVec2, _x : f32, _y : f32)
{
	this.x = _x
	this.y = _y
}

// ImVec4: 4D vector used to store clipping rectangles, colors etc. [Compile-time configurable type]
ImVec4 :: struct {
	x : f32, y : f32, z : f32, w : f32,
}

ImVec4_init_0 :: proc(this : ^ImVec4)
{
	this.x = 0.0
	this.y = 0.0
	this.z = 0.0
	this.w = 0.0
}

ImVec4_init_1 :: proc(this : ^ImVec4, _x : f32, _y : f32, _z : f32, _w : f32)
{
	this.x = _x
	this.y = _y
	this.z = _z
	this.w = _w
}


//-----------------------------------------------------------------------------
// [SECTION] Dear ImGui end-user API functions
// (Note that ImGui:: being a namespace, you can add extra ImGui:: functions in your own separate file. Please don't modify imgui source files!)
//-----------------------------------------------------------------------------

// namespace ImGui

//-----------------------------------------------------------------------------
// [SECTION] Flags & Enumerations
//-----------------------------------------------------------------------------

// Flags for ImGui::Begin()
// (Those are per-window flags. There are shared flags in ImGuiIO: io.ConfigWindowsResizeFromEdges and io.ConfigWindowsMoveFromTitleBarOnly)
ImGuiWindowFlags_ :: enum i32 {
	ImGuiWindowFlags_None = 0,
	ImGuiWindowFlags_NoTitleBar = 1 << 0, // Disable title-bar
	ImGuiWindowFlags_NoResize = 1 << 1, // Disable user resizing with the lower-right grip
	ImGuiWindowFlags_NoMove = 1 << 2, // Disable user moving the window
	ImGuiWindowFlags_NoScrollbar = 1 << 3, // Disable scrollbars (window can still scroll with mouse or programmatically)
	ImGuiWindowFlags_NoScrollWithMouse = 1 << 4, // Disable user vertically scrolling with mouse wheel. On child window, mouse wheel will be forwarded to the parent unless NoScrollbar is also set.
	ImGuiWindowFlags_NoCollapse = 1 << 5, // Disable user collapsing window by double-clicking on it. Also referred to as Window Menu Button (e.g. within a docking node).
	ImGuiWindowFlags_AlwaysAutoResize = 1 << 6, // Resize every window to its content every frame
	ImGuiWindowFlags_NoBackground = 1 << 7, // Disable drawing background color (WindowBg, etc.) and outside border. Similar as using SetNextWindowBgAlpha(0.0f).
	ImGuiWindowFlags_NoSavedSettings = 1 << 8, // Never load/save settings in .ini file
	ImGuiWindowFlags_NoMouseInputs = 1 << 9, // Disable catching mouse, hovering test with pass through.
	ImGuiWindowFlags_MenuBar = 1 << 10, // Has a menu-bar
	ImGuiWindowFlags_HorizontalScrollbar = 1 << 11, // Allow horizontal scrollbar to appear (off by default). You may use SetNextWindowContentSize(ImVec2(width,0.0f)); prior to calling Begin() to specify width. Read code in imgui_demo in the "Horizontal Scrolling" section.
	ImGuiWindowFlags_NoFocusOnAppearing = 1 << 12, // Disable taking focus when transitioning from hidden to visible state
	ImGuiWindowFlags_NoBringToFrontOnFocus = 1 << 13, // Disable bringing window to front when taking focus (e.g. clicking on it or programmatically giving it focus)
	ImGuiWindowFlags_AlwaysVerticalScrollbar = 1 << 14, // Always show vertical scrollbar (even if ContentSize.y < Size.y)
	ImGuiWindowFlags_AlwaysHorizontalScrollbar = 1 << 15, // Always show horizontal scrollbar (even if ContentSize.x < Size.x)
	ImGuiWindowFlags_NoNavInputs = 1 << 16, // No keyboard/gamepad navigation within the window
	ImGuiWindowFlags_NoNavFocus = 1 << 17, // No focusing toward this window with keyboard/gamepad navigation (e.g. skipped by CTRL+TAB)
	ImGuiWindowFlags_UnsavedDocument = 1 << 18, // Display a dot next to the title. When used in a tab/docking context, tab is selected when clicking the X + closure is not assumed (will wait for user to stop submitting the tab). Otherwise closure is assumed when pressing the X, so if you keep submitting the tab may reappear at end of tab bar.
	ImGuiWindowFlags_NoDocking = 1 << 19, // Disable docking of this window
	ImGuiWindowFlags_NoNav = ImGuiWindowFlags_NoNavInputs | ImGuiWindowFlags_NoNavFocus,
	ImGuiWindowFlags_NoDecoration = ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_NoCollapse,
	ImGuiWindowFlags_NoInputs = ImGuiWindowFlags_NoMouseInputs | ImGuiWindowFlags_NoNavInputs | ImGuiWindowFlags_NoNavFocus,

	// [Internal]
	ImGuiWindowFlags_ChildWindow = 1 << 24, // Don't use! For internal use by BeginChild()
	ImGuiWindowFlags_Tooltip = 1 << 25, // Don't use! For internal use by BeginTooltip()
	ImGuiWindowFlags_Popup = 1 << 26, // Don't use! For internal use by BeginPopup()
	ImGuiWindowFlags_Modal = 1 << 27, // Don't use! For internal use by BeginPopupModal()
	ImGuiWindowFlags_ChildMenu = 1 << 28, // Don't use! For internal use by BeginMenu()
	ImGuiWindowFlags_DockNodeHost = 1 << 29, // Don't use! For internal use by Begin()/NewFrame()
}

// Flags for ImGui::BeginChild()
// (Legacy: bit 0 must always correspond to ImGuiChildFlags_Borders to be backward compatible with old API using 'bool border = false'.
// About using AutoResizeX/AutoResizeY flags:
// - May be combined with SetNextWindowSizeConstraints() to set a min/max size for each axis (see "Demo->Child->Auto-resize with Constraints").
// - Size measurement for a given axis is only performed when the child window is within visible boundaries, or is just appearing.
//   - This allows BeginChild() to return false when not within boundaries (e.g. when scrolling), which is more optimal. BUT it won't update its auto-size while clipped.
//     While not perfect, it is a better default behavior as the always-on performance gain is more valuable than the occasional "resizing after becoming visible again" glitch.
//   - You may also use ImGuiChildFlags_AlwaysAutoResize to force an update even when child window is not in view.
//     HOWEVER PLEASE UNDERSTAND THAT DOING SO WILL PREVENT BeginChild() FROM EVER RETURNING FALSE, disabling benefits of coarse clipping.
ImGuiChildFlags_ :: enum i32 {
	ImGuiChildFlags_None = 0,
	ImGuiChildFlags_Borders = 1 << 0, // Show an outer border and enable WindowPadding. (IMPORTANT: this is always == 1 == true for legacy reason)
	ImGuiChildFlags_AlwaysUseWindowPadding = 1 << 1, // Pad with style.WindowPadding even if no border are drawn (no padding by default for non-bordered child windows because it makes more sense)
	ImGuiChildFlags_ResizeX = 1 << 2, // Allow resize from right border (layout direction). Enable .ini saving (unless ImGuiWindowFlags_NoSavedSettings passed to window flags)
	ImGuiChildFlags_ResizeY = 1 << 3, // Allow resize from bottom border (layout direction). "
	ImGuiChildFlags_AutoResizeX = 1 << 4, // Enable auto-resizing width. Read "IMPORTANT: Size measurement" details above.
	ImGuiChildFlags_AutoResizeY = 1 << 5, // Enable auto-resizing height. Read "IMPORTANT: Size measurement" details above.
	ImGuiChildFlags_AlwaysAutoResize = 1 << 6, // Combined with AutoResizeX/AutoResizeY. Always measure size even when child is hidden, always return true, always disable clipping optimization! NOT RECOMMENDED.
	ImGuiChildFlags_FrameStyle = 1 << 7, // Style the child window like a framed item: use FrameBg, FrameRounding, FrameBorderSize, FramePadding instead of ChildBg, ChildRounding, ChildBorderSize, WindowPadding.
	ImGuiChildFlags_NavFlattened = 1 << 8, // [BETA] Share focus scope, allow keyboard/gamepad navigation to cross over parent border to this child or between sibling child windows.
}

// Flags for ImGui::PushItemFlag()
// (Those are shared by all items)
ImGuiItemFlags_ :: enum i32 {
	ImGuiItemFlags_None = 0, // (Default)
	ImGuiItemFlags_NoTabStop = 1 << 0, // false    // Disable keyboard tabbing. This is a "lighter" version of ImGuiItemFlags_NoNav.
	ImGuiItemFlags_NoNav = 1 << 1, // false    // Disable any form of focusing (keyboard/gamepad directional navigation and SetKeyboardFocusHere() calls).
	ImGuiItemFlags_NoNavDefaultFocus = 1 << 2, // false    // Disable item being a candidate for default focus (e.g. used by title bar items).
	ImGuiItemFlags_ButtonRepeat = 1 << 3, // false    // Any button-like behavior will have repeat mode enabled (based on io.KeyRepeatDelay and io.KeyRepeatRate values). Note that you can also call IsItemActive() after any button to tell if it is being held.
	ImGuiItemFlags_AutoClosePopups = 1 << 4, // true     // MenuItem()/Selectable() automatically close their parent popup window.
	ImGuiItemFlags_AllowDuplicateId = 1 << 5, // false    // Allow submitting an item with the same identifier as an item already submitted this frame without triggering a warning tooltip if io.ConfigDebugHighlightIdConflicts is set.
}

// Flags for ImGui::InputText()
// (Those are per-item flags. There are shared flags in ImGuiIO: io.ConfigInputTextCursorBlink and io.ConfigInputTextEnterKeepActive)
ImGuiInputTextFlags_ :: enum i32 {
	// Basic filters (also see ImGuiInputTextFlags_CallbackCharFilter)
	ImGuiInputTextFlags_None = 0,
	ImGuiInputTextFlags_CharsDecimal = 1 << 0, // Allow 0123456789.+-*/
	ImGuiInputTextFlags_CharsHexadecimal = 1 << 1, // Allow 0123456789ABCDEFabcdef
	ImGuiInputTextFlags_CharsScientific = 1 << 2, // Allow 0123456789.+-*/eE (Scientific notation input)
	ImGuiInputTextFlags_CharsUppercase = 1 << 3, // Turn a..z into A..Z
	ImGuiInputTextFlags_CharsNoBlank = 1 << 4, // Filter out spaces, tabs

	// Inputs
	ImGuiInputTextFlags_AllowTabInput = 1 << 5, // Pressing TAB input a '\t' character into the text field
	ImGuiInputTextFlags_EnterReturnsTrue = 1 << 6, // Return 'true' when Enter is pressed (as opposed to every time the value was modified). Consider using IsItemDeactivatedAfterEdit() instead!
	ImGuiInputTextFlags_EscapeClearsAll = 1 << 7, // Escape key clears content if not empty, and deactivate otherwise (contrast to default behavior of Escape to revert)
	ImGuiInputTextFlags_CtrlEnterForNewLine = 1 << 8, // In multi-line mode, validate with Enter, add new line with Ctrl+Enter (default is opposite: validate with Ctrl+Enter, add line with Enter).

	// Other options
	ImGuiInputTextFlags_ReadOnly = 1 << 9, // Read-only mode
	ImGuiInputTextFlags_Password = 1 << 10, // Password mode, display all characters as '*', disable copy
	ImGuiInputTextFlags_AlwaysOverwrite = 1 << 11, // Overwrite mode
	ImGuiInputTextFlags_AutoSelectAll = 1 << 12, // Select entire text when first taking mouse focus
	ImGuiInputTextFlags_ParseEmptyRefVal = 1 << 13, // InputFloat(), InputInt(), InputScalar() etc. only: parse empty string as zero value.
	ImGuiInputTextFlags_DisplayEmptyRefVal = 1 << 14, // InputFloat(), InputInt(), InputScalar() etc. only: when value is zero, do not display it. Generally used with ImGuiInputTextFlags_ParseEmptyRefVal.
	ImGuiInputTextFlags_NoHorizontalScroll = 1 << 15, // Disable following the cursor horizontally
	ImGuiInputTextFlags_NoUndoRedo = 1 << 16, // Disable undo/redo. Note that input text owns the text data while active, if you want to provide your own undo/redo stack you need e.g. to call ClearActiveID().

	// Elide display / Alignment
	ImGuiInputTextFlags_ElideLeft = 1 << 17, // When text doesn't fit, elide left side to ensure right side stays visible. Useful for path/filenames. Single-line only!

	// Callback features
	ImGuiInputTextFlags_CallbackCompletion = 1 << 18, // Callback on pressing TAB (for completion handling)
	ImGuiInputTextFlags_CallbackHistory = 1 << 19, // Callback on pressing Up/Down arrows (for history handling)
	ImGuiInputTextFlags_CallbackAlways = 1 << 20, // Callback on each iteration. User code may query cursor position, modify text buffer.
	ImGuiInputTextFlags_CallbackCharFilter = 1 << 21, // Callback on character inputs to replace or discard them. Modify 'EventChar' to replace or discard, or return 1 in callback to discard.
	ImGuiInputTextFlags_CallbackResize = 1 << 22, // Callback on buffer capacity changes request (beyond 'buf_size' parameter value), allowing the string to grow. Notify when the string wants to be resized (for string types which hold a cache of their Size). You will be provided a new BufSize in the callback and NEED to honor it. (see misc/cpp/imgui_stdlib.h for an example of using this)
	ImGuiInputTextFlags_CallbackEdit = 1 << 23, // Callback on any edit (note that InputText() already returns true on edit, the callback is useful mainly to manipulate the underlying buffer while focus is active)

	// Obsolete names
	//ImGuiInputTextFlags_AlwaysInsertMode  = ImGuiInputTextFlags_AlwaysOverwrite   // [renamed in 1.82] name was not matching behavior
}

// Flags for ImGui::TreeNodeEx(), ImGui::CollapsingHeader*()
ImGuiTreeNodeFlags_ :: enum i32 {
	ImGuiTreeNodeFlags_None = 0,
	ImGuiTreeNodeFlags_Selected = 1 << 0, // Draw as selected
	ImGuiTreeNodeFlags_Framed = 1 << 1, // Draw frame with background (e.g. for CollapsingHeader)
	ImGuiTreeNodeFlags_AllowOverlap = 1 << 2, // Hit testing to allow subsequent widgets to overlap this one
	ImGuiTreeNodeFlags_NoTreePushOnOpen = 1 << 3, // Don't do a TreePush() when open (e.g. for CollapsingHeader) = no extra indent nor pushing on ID stack
	ImGuiTreeNodeFlags_NoAutoOpenOnLog = 1 << 4, // Don't automatically and temporarily open node when Logging is active (by default logging will automatically open tree nodes)
	ImGuiTreeNodeFlags_DefaultOpen = 1 << 5, // Default node to be open
	ImGuiTreeNodeFlags_OpenOnDoubleClick = 1 << 6, // Open on double-click instead of simple click (default for multi-select unless any _OpenOnXXX behavior is set explicitly). Both behaviors may be combined.
	ImGuiTreeNodeFlags_OpenOnArrow = 1 << 7, // Open when clicking on the arrow part (default for multi-select unless any _OpenOnXXX behavior is set explicitly). Both behaviors may be combined.
	ImGuiTreeNodeFlags_Leaf = 1 << 8, // No collapsing, no arrow (use as a convenience for leaf nodes).
	ImGuiTreeNodeFlags_Bullet = 1 << 9, // Display a bullet instead of arrow. IMPORTANT: node can still be marked open/close if you don't set the _Leaf flag!
	ImGuiTreeNodeFlags_FramePadding = 1 << 10, // Use FramePadding (even for an unframed text node) to vertically align text baseline to regular widget height. Equivalent to calling AlignTextToFramePadding() before the node.
	ImGuiTreeNodeFlags_SpanAvailWidth = 1 << 11, // Extend hit box to the right-most edge, even if not framed. This is not the default in order to allow adding other items on the same line without using AllowOverlap mode.
	ImGuiTreeNodeFlags_SpanFullWidth = 1 << 12, // Extend hit box to the left-most and right-most edges (cover the indent area).
	ImGuiTreeNodeFlags_SpanTextWidth = 1 << 13, // Narrow hit box + narrow hovering highlight, will only cover the label text.
	ImGuiTreeNodeFlags_SpanAllColumns = 1 << 14, // Frame will span all columns of its container table (text will still fit in current column)
	ImGuiTreeNodeFlags_NavLeftJumpsBackHere = 1 << 15, // (WIP) Nav: left direction may move to this TreeNode() from any of its child (items submitted between TreeNode and TreePop)
	//ImGuiTreeNodeFlags_NoScrollOnOpen     = 1 << 16,  // FIXME: TODO: Disable automatic scroll on TreePop() if node got just open and contents is not visible
	ImGuiTreeNodeFlags_CollapsingHeader = ImGuiTreeNodeFlags_Framed | ImGuiTreeNodeFlags_NoTreePushOnOpen | ImGuiTreeNodeFlags_NoAutoOpenOnLog,
}

// Flags for OpenPopup*(), BeginPopupContext*(), IsPopupOpen() functions.
// - To be backward compatible with older API which took an 'int mouse_button = 1' argument instead of 'ImGuiPopupFlags flags',
//   we need to treat small flags values as a mouse button index, so we encode the mouse button in the first few bits of the flags.
//   It is therefore guaranteed to be legal to pass a mouse button index in ImGuiPopupFlags.
// - For the same reason, we exceptionally default the ImGuiPopupFlags argument of BeginPopupContextXXX functions to 1 instead of 0.
//   IMPORTANT: because the default parameter is 1 (==ImGuiPopupFlags_MouseButtonRight), if you rely on the default parameter
//   and want to use another flag, you need to pass in the ImGuiPopupFlags_MouseButtonRight flag explicitly.
// - Multiple buttons currently cannot be combined/or-ed in those functions (we could allow it later).
ImGuiPopupFlags_ :: enum i32 {
	ImGuiPopupFlags_None = 0,
	ImGuiPopupFlags_MouseButtonLeft = 0, // For BeginPopupContext*(): open on Left Mouse release. Guaranteed to always be == 0 (same as ImGuiMouseButton_Left)
	ImGuiPopupFlags_MouseButtonRight = 1, // For BeginPopupContext*(): open on Right Mouse release. Guaranteed to always be == 1 (same as ImGuiMouseButton_Right)
	ImGuiPopupFlags_MouseButtonMiddle = 2, // For BeginPopupContext*(): open on Middle Mouse release. Guaranteed to always be == 2 (same as ImGuiMouseButton_Middle)
	ImGuiPopupFlags_MouseButtonMask_ = 0x1F,
	ImGuiPopupFlags_MouseButtonDefault_ = 1,
	ImGuiPopupFlags_NoReopen = 1 << 5, // For OpenPopup*(), BeginPopupContext*(): don't reopen same popup if already open (won't reposition, won't reinitialize navigation)
	//ImGuiPopupFlags_NoReopenAlwaysNavInit = 1 << 6,   // For OpenPopup*(), BeginPopupContext*(): focus and initialize navigation even when not reopening.
	ImGuiPopupFlags_NoOpenOverExistingPopup = 1 << 7, // For OpenPopup*(), BeginPopupContext*(): don't open if there's already a popup at the same level of the popup stack
	ImGuiPopupFlags_NoOpenOverItems = 1 << 8, // For BeginPopupContextWindow(): don't return true when hovering items, only when hovering empty space
	ImGuiPopupFlags_AnyPopupId = 1 << 10, // For IsPopupOpen(): ignore the ImGuiID parameter and test for any popup.
	ImGuiPopupFlags_AnyPopupLevel = 1 << 11, // For IsPopupOpen(): search/test at any level of the popup stack (default test in the current level)
	ImGuiPopupFlags_AnyPopup = ImGuiPopupFlags_AnyPopupId | ImGuiPopupFlags_AnyPopupLevel,
}

// Flags for ImGui::Selectable()
ImGuiSelectableFlags_ :: enum i32 {
	ImGuiSelectableFlags_None = 0,
	ImGuiSelectableFlags_NoAutoClosePopups = 1 << 0, // Clicking this doesn't close parent popup window (overrides ImGuiItemFlags_AutoClosePopups)
	ImGuiSelectableFlags_SpanAllColumns = 1 << 1, // Frame will span all columns of its container table (text will still fit in current column)
	ImGuiSelectableFlags_AllowDoubleClick = 1 << 2, // Generate press events on double clicks too
	ImGuiSelectableFlags_Disabled = 1 << 3, // Cannot be selected, display grayed out text
	ImGuiSelectableFlags_AllowOverlap = 1 << 4, // (WIP) Hit testing to allow subsequent widgets to overlap this one
	ImGuiSelectableFlags_Highlight = 1 << 5, // Make the item be displayed as if it is hovered
}

// Flags for ImGui::BeginCombo()
ImGuiComboFlags_ :: enum i32 {
	ImGuiComboFlags_None = 0,
	ImGuiComboFlags_PopupAlignLeft = 1 << 0, // Align the popup toward the left by default
	ImGuiComboFlags_HeightSmall = 1 << 1, // Max ~4 items visible. Tip: If you want your combo popup to be a specific size you can use SetNextWindowSizeConstraints() prior to calling BeginCombo()
	ImGuiComboFlags_HeightRegular = 1 << 2, // Max ~8 items visible (default)
	ImGuiComboFlags_HeightLarge = 1 << 3, // Max ~20 items visible
	ImGuiComboFlags_HeightLargest = 1 << 4, // As many fitting items as possible
	ImGuiComboFlags_NoArrowButton = 1 << 5, // Display on the preview box without the square arrow button
	ImGuiComboFlags_NoPreview = 1 << 6, // Display only a square arrow button
	ImGuiComboFlags_WidthFitPreview = 1 << 7, // Width dynamically calculated from preview contents
	ImGuiComboFlags_HeightMask_ = ImGuiComboFlags_HeightSmall | ImGuiComboFlags_HeightRegular | ImGuiComboFlags_HeightLarge | ImGuiComboFlags_HeightLargest,
}

// Flags for ImGui::BeginTabBar()
ImGuiTabBarFlags_ :: enum i32 {
	ImGuiTabBarFlags_None = 0,
	ImGuiTabBarFlags_Reorderable = 1 << 0, // Allow manually dragging tabs to re-order them + New tabs are appended at the end of list
	ImGuiTabBarFlags_AutoSelectNewTabs = 1 << 1, // Automatically select new tabs when they appear
	ImGuiTabBarFlags_TabListPopupButton = 1 << 2, // Disable buttons to open the tab list popup
	ImGuiTabBarFlags_NoCloseWithMiddleMouseButton = 1 << 3, // Disable behavior of closing tabs (that are submitted with p_open != NULL) with middle mouse button. You may handle this behavior manually on user's side with if (IsItemHovered() && IsMouseClicked(2)) *p_open = false.
	ImGuiTabBarFlags_NoTabListScrollingButtons = 1 << 4, // Disable scrolling buttons (apply when fitting policy is ImGuiTabBarFlags_FittingPolicyScroll)
	ImGuiTabBarFlags_NoTooltip = 1 << 5, // Disable tooltips when hovering a tab
	ImGuiTabBarFlags_DrawSelectedOverline = 1 << 6, // Draw selected overline markers over selected tab
	ImGuiTabBarFlags_FittingPolicyResizeDown = 1 << 7, // Resize tabs when they don't fit
	ImGuiTabBarFlags_FittingPolicyScroll = 1 << 8, // Add scroll buttons when tabs don't fit
	ImGuiTabBarFlags_FittingPolicyMask_ = ImGuiTabBarFlags_FittingPolicyResizeDown | ImGuiTabBarFlags_FittingPolicyScroll,
	ImGuiTabBarFlags_FittingPolicyDefault_ = ImGuiTabBarFlags_FittingPolicyResizeDown,
}

// Flags for ImGui::BeginTabItem()
ImGuiTabItemFlags_ :: enum i32 {
	ImGuiTabItemFlags_None = 0,
	ImGuiTabItemFlags_UnsavedDocument = 1 << 0, // Display a dot next to the title + set ImGuiTabItemFlags_NoAssumedClosure.
	ImGuiTabItemFlags_SetSelected = 1 << 1, // Trigger flag to programmatically make the tab selected when calling BeginTabItem()
	ImGuiTabItemFlags_NoCloseWithMiddleMouseButton = 1 << 2, // Disable behavior of closing tabs (that are submitted with p_open != NULL) with middle mouse button. You may handle this behavior manually on user's side with if (IsItemHovered() && IsMouseClicked(2)) *p_open = false.
	ImGuiTabItemFlags_NoPushId = 1 << 3, // Don't call PushID()/PopID() on BeginTabItem()/EndTabItem()
	ImGuiTabItemFlags_NoTooltip = 1 << 4, // Disable tooltip for the given tab
	ImGuiTabItemFlags_NoReorder = 1 << 5, // Disable reordering this tab or having another tab cross over this tab
	ImGuiTabItemFlags_Leading = 1 << 6, // Enforce the tab position to the left of the tab bar (after the tab list popup button)
	ImGuiTabItemFlags_Trailing = 1 << 7, // Enforce the tab position to the right of the tab bar (before the scrolling buttons)
	ImGuiTabItemFlags_NoAssumedClosure = 1 << 8, // Tab is selected when trying to close + closure is not immediately assumed (will wait for user to stop submitting the tab). Otherwise closure is assumed when pressing the X, so if you keep submitting the tab may reappear at end of tab bar.
}

// Flags for ImGui::IsWindowFocused()
ImGuiFocusedFlags_ :: enum i32 {
	ImGuiFocusedFlags_None = 0,
	ImGuiFocusedFlags_ChildWindows = 1 << 0, // Return true if any children of the window is focused
	ImGuiFocusedFlags_RootWindow = 1 << 1, // Test from root window (top most parent of the current hierarchy)
	ImGuiFocusedFlags_AnyWindow = 1 << 2, // Return true if any window is focused. Important: If you are trying to tell how to dispatch your low-level inputs, do NOT use this. Use 'io.WantCaptureMouse' instead! Please read the FAQ!
	ImGuiFocusedFlags_NoPopupHierarchy = 1 << 3, // Do not consider popup hierarchy (do not treat popup emitter as parent of popup) (when used with _ChildWindows or _RootWindow)
	ImGuiFocusedFlags_DockHierarchy = 1 << 4, // Consider docking hierarchy (treat dockspace host as parent of docked window) (when used with _ChildWindows or _RootWindow)
	ImGuiFocusedFlags_RootAndChildWindows = ImGuiFocusedFlags_RootWindow | ImGuiFocusedFlags_ChildWindows,
}

// Flags for ImGui::IsItemHovered(), ImGui::IsWindowHovered()
// Note: if you are trying to check whether your mouse should be dispatched to Dear ImGui or to your app, you should use 'io.WantCaptureMouse' instead! Please read the FAQ!
// Note: windows with the ImGuiWindowFlags_NoInputs flag are ignored by IsWindowHovered() calls.
ImGuiHoveredFlags_ :: enum i32 {
	ImGuiHoveredFlags_None = 0, // Return true if directly over the item/window, not obstructed by another window, not obstructed by an active popup or modal blocking inputs under them.
	ImGuiHoveredFlags_ChildWindows = 1 << 0, // IsWindowHovered() only: Return true if any children of the window is hovered
	ImGuiHoveredFlags_RootWindow = 1 << 1, // IsWindowHovered() only: Test from root window (top most parent of the current hierarchy)
	ImGuiHoveredFlags_AnyWindow = 1 << 2, // IsWindowHovered() only: Return true if any window is hovered
	ImGuiHoveredFlags_NoPopupHierarchy = 1 << 3, // IsWindowHovered() only: Do not consider popup hierarchy (do not treat popup emitter as parent of popup) (when used with _ChildWindows or _RootWindow)
	ImGuiHoveredFlags_DockHierarchy = 1 << 4, // IsWindowHovered() only: Consider docking hierarchy (treat dockspace host as parent of docked window) (when used with _ChildWindows or _RootWindow)
	ImGuiHoveredFlags_AllowWhenBlockedByPopup = 1 << 5, // Return true even if a popup window is normally blocking access to this item/window
	//ImGuiHoveredFlags_AllowWhenBlockedByModal     = 1 << 6,   // Return true even if a modal popup window is normally blocking access to this item/window. FIXME-TODO: Unavailable yet.
	ImGuiHoveredFlags_AllowWhenBlockedByActiveItem = 1 << 7, // Return true even if an active item is blocking access to this item/window. Useful for Drag and Drop patterns.
	ImGuiHoveredFlags_AllowWhenOverlappedByItem = 1 << 8, // IsItemHovered() only: Return true even if the item uses AllowOverlap mode and is overlapped by another hoverable item.
	ImGuiHoveredFlags_AllowWhenOverlappedByWindow = 1 << 9, // IsItemHovered() only: Return true even if the position is obstructed or overlapped by another window.
	ImGuiHoveredFlags_AllowWhenDisabled = 1 << 10, // IsItemHovered() only: Return true even if the item is disabled
	ImGuiHoveredFlags_NoNavOverride = 1 << 11, // IsItemHovered() only: Disable using keyboard/gamepad navigation state when active, always query mouse
	ImGuiHoveredFlags_AllowWhenOverlapped = ImGuiHoveredFlags_AllowWhenOverlappedByItem | ImGuiHoveredFlags_AllowWhenOverlappedByWindow,
	ImGuiHoveredFlags_RectOnly = ImGuiHoveredFlags_AllowWhenBlockedByPopup | ImGuiHoveredFlags_AllowWhenBlockedByActiveItem | ImGuiHoveredFlags_AllowWhenOverlapped,
	ImGuiHoveredFlags_RootAndChildWindows = ImGuiHoveredFlags_RootWindow | ImGuiHoveredFlags_ChildWindows,

	// Tooltips mode
	// - typically used in IsItemHovered() + SetTooltip() sequence.
	// - this is a shortcut to pull flags from 'style.HoverFlagsForTooltipMouse' or 'style.HoverFlagsForTooltipNav' where you can reconfigure desired behavior.
	//   e.g. 'TooltipHoveredFlagsForMouse' defaults to 'ImGuiHoveredFlags_Stationary | ImGuiHoveredFlags_DelayShort'.
	// - for frequently actioned or hovered items providing a tooltip, you want may to use ImGuiHoveredFlags_ForTooltip (stationary + delay) so the tooltip doesn't show too often.
	// - for items which main purpose is to be hovered, or items with low affordance, or in less consistent apps, prefer no delay or shorter delay.
	ImGuiHoveredFlags_ForTooltip = 1 << 12, // Shortcut for standard flags when using IsItemHovered() + SetTooltip() sequence.

	// (Advanced) Mouse Hovering delays.
	// - generally you can use ImGuiHoveredFlags_ForTooltip to use application-standardized flags.
	// - use those if you need specific overrides.
	ImGuiHoveredFlags_Stationary = 1 << 13, // Require mouse to be stationary for style.HoverStationaryDelay (~0.15 sec) _at least one time_. After this, can move on same item/window. Using the stationary test tends to reduces the need for a long delay.
	ImGuiHoveredFlags_DelayNone = 1 << 14, // IsItemHovered() only: Return true immediately (default). As this is the default you generally ignore this.
	ImGuiHoveredFlags_DelayShort = 1 << 15, // IsItemHovered() only: Return true after style.HoverDelayShort elapsed (~0.15 sec) (shared between items) + requires mouse to be stationary for style.HoverStationaryDelay (once per item).
	ImGuiHoveredFlags_DelayNormal = 1 << 16, // IsItemHovered() only: Return true after style.HoverDelayNormal elapsed (~0.40 sec) (shared between items) + requires mouse to be stationary for style.HoverStationaryDelay (once per item).
	ImGuiHoveredFlags_NoSharedDelay = 1 << 17, // IsItemHovered() only: Disable shared delay system where moving from one item to the next keeps the previous timer for a short time (standard for tooltips with long delays)
}

// Flags for ImGui::DockSpace(), shared/inherited by child nodes.
// (Some flags can be applied to individual nodes directly)
// FIXME-DOCK: Also see ImGuiDockNodeFlagsPrivate_ which may involve using the WIP and internal DockBuilder api.
ImGuiDockNodeFlags_ :: enum i32 {
	ImGuiDockNodeFlags_None = 0,
	ImGuiDockNodeFlags_KeepAliveOnly = 1 << 0, //       // Don't display the dockspace node but keep it alive. Windows docked into this dockspace node won't be undocked.
	//ImGuiDockNodeFlags_NoCentralNode              = 1 << 1,   //       // Disable Central Node (the node which can stay empty)
	ImGuiDockNodeFlags_NoDockingOverCentralNode = 1 << 2, //       // Disable docking over the Central Node, which will be always kept empty.
	ImGuiDockNodeFlags_PassthruCentralNode = 1 << 3, //       // Enable passthru dockspace: 1) DockSpace() will render a ImGuiCol_WindowBg background covering everything excepted the Central Node when empty. Meaning the host window should probably use SetNextWindowBgAlpha(0.0f) prior to Begin() when using this. 2) When Central Node is empty: let inputs pass-through + won't display a DockingEmptyBg background. See demo for details.
	ImGuiDockNodeFlags_NoDockingSplit = 1 << 4, //       // Disable other windows/nodes from splitting this node.
	ImGuiDockNodeFlags_NoResize = 1 << 5, // Saved // Disable resizing node using the splitter/separators. Useful with programmatically setup dockspaces.
	ImGuiDockNodeFlags_AutoHideTabBar = 1 << 6, //       // Tab bar will automatically hide when there is a single window in the dock node.
	ImGuiDockNodeFlags_NoUndocking = 1 << 7, //       // Disable undocking this node.
}

// Flags for ImGui::BeginDragDropSource(), ImGui::AcceptDragDropPayload()
ImGuiDragDropFlags_ :: enum i32 {
	ImGuiDragDropFlags_None = 0,
	// BeginDragDropSource() flags
	ImGuiDragDropFlags_SourceNoPreviewTooltip = 1 << 0, // Disable preview tooltip. By default, a successful call to BeginDragDropSource opens a tooltip so you can display a preview or description of the source contents. This flag disables this behavior.
	ImGuiDragDropFlags_SourceNoDisableHover = 1 << 1, // By default, when dragging we clear data so that IsItemHovered() will return false, to avoid subsequent user code submitting tooltips. This flag disables this behavior so you can still call IsItemHovered() on the source item.
	ImGuiDragDropFlags_SourceNoHoldToOpenOthers = 1 << 2, // Disable the behavior that allows to open tree nodes and collapsing header by holding over them while dragging a source item.
	ImGuiDragDropFlags_SourceAllowNullID = 1 << 3, // Allow items such as Text(), Image() that have no unique identifier to be used as drag source, by manufacturing a temporary identifier based on their window-relative position. This is extremely unusual within the dear imgui ecosystem and so we made it explicit.
	ImGuiDragDropFlags_SourceExtern = 1 << 4, // External source (from outside of dear imgui), won't attempt to read current item/window info. Will always return true. Only one Extern source can be active simultaneously.
	ImGuiDragDropFlags_PayloadAutoExpire = 1 << 5, // Automatically expire the payload if the source cease to be submitted (otherwise payloads are persisting while being dragged)
	ImGuiDragDropFlags_PayloadNoCrossContext = 1 << 6, // Hint to specify that the payload may not be copied outside current dear imgui context.
	ImGuiDragDropFlags_PayloadNoCrossProcess = 1 << 7, // Hint to specify that the payload may not be copied outside current process.
	// AcceptDragDropPayload() flags
	ImGuiDragDropFlags_AcceptBeforeDelivery = 1 << 10, // AcceptDragDropPayload() will returns true even before the mouse button is released. You can then call IsDelivery() to test if the payload needs to be delivered.
	ImGuiDragDropFlags_AcceptNoDrawDefaultRect = 1 << 11, // Do not draw the default highlight rectangle when hovering over target.
	ImGuiDragDropFlags_AcceptNoPreviewTooltip = 1 << 12, // Request hiding the BeginDragDropSource tooltip from the BeginDragDropTarget site.
	ImGuiDragDropFlags_AcceptPeekOnly = ImGuiDragDropFlags_AcceptBeforeDelivery | ImGuiDragDropFlags_AcceptNoDrawDefaultRect, // For peeking ahead and inspecting the payload before delivery.
}

// Standard Drag and Drop payload types. You can define you own payload types using short strings. Types starting with '_' are defined by Dear ImGui.
IMGUI_PAYLOAD_TYPE_COLOR_3F :: "_COL3F"// float[3]: Standard type for colors, without alpha. User code may use this type.
IMGUI_PAYLOAD_TYPE_COLOR_4F :: "_COL4F"// float[4]: Standard type for colors. User code may use this type.

// A primary data type
ImGuiDataType_ :: enum i32 {
	ImGuiDataType_S8, // signed char / char (with sensible compilers)
	ImGuiDataType_U8, // unsigned char
	ImGuiDataType_S16, // short
	ImGuiDataType_U16, // unsigned short
	ImGuiDataType_S32, // int
	ImGuiDataType_U32, // unsigned int
	ImGuiDataType_S64, // long long / __int64
	ImGuiDataType_U64, // unsigned long long / unsigned __int64
	ImGuiDataType_Float, // float
	ImGuiDataType_Double, // double
	ImGuiDataType_Bool, // bool (provided for user convenience, not supported by scalar widgets)
	ImGuiDataType_String, // char* (provided for user convenience, not supported by scalar widgets)
	ImGuiDataType_COUNT,
}

// Window class (rare/advanced uses: provide hints to the platform backend via altered viewport flags and parent/child info)

// Enumerations
// - We don't use strongly typed enums much because they add constraints (can't extend in private code, can't store typed in bit fields, extra casting on iteration)
// - Tip: Use your programming IDE navigation facilities on the names in the _central column_ below to find the actual flags/enum lists!
//   - In Visual Studio: CTRL+comma ("Edit.GoToAll") can follow symbols inside comments, whereas CTRL+F12 ("Edit.GoToImplementation") cannot.
//   - In Visual Studio w/ Visual Assist installed: ALT+G ("VAssistX.GoToImplementation") can also follow symbols inside comments.
//   - In VS Code, CLion, etc.: CTRL+click can follow symbols inside comments.
// A cardinal direction
ImGuiDir :: enum i32 {
	ImGuiDir_None = -1,
	ImGuiDir_Left = 0,
	ImGuiDir_Right = 1,
	ImGuiDir_Up = 2,
	ImGuiDir_Down = 3,
	ImGuiDir_COUNT,
}

// -> enum ImGuiMouseSource      // Enum; A mouse input source identifier (Mouse, TouchScreen, Pen)
// A sorting direction
ImGuiSortDirection :: enum ImU8 {
	ImGuiSortDirection_None = 0,
	ImGuiSortDirection_Ascending = 1, // Ascending = 0->9, A->Z etc.
	ImGuiSortDirection_Descending = 2,
}

// -> enum ImGuiDir              // Enum: A cardinal direction (Left, Right, Up, Down)
// A key identifier (ImGuiKey_XXX or ImGuiMod_XXX value): can represent Keyboard, Mouse and Gamepad values.
// All our named keys are >= 512. Keys value 0 to 511 are left unused and were legacy native/opaque key values (< 1.87).
// Support for legacy keys was completely removed in 1.91.5.
// Read details about the 1.87+ transition : https://github.com/ocornut/imgui/issues/4921
// Note that "Keys" related to physical keys and are not the same concept as input "Characters", the later are submitted via io.AddInputCharacter().
// The keyboard key enum values are named after the keys on a standard US keyboard, and on other keyboard types the keys reported may not match the keycaps.
ImGuiKey :: enum i32 {
	// Keyboard
	ImGuiKey_None = 0,
	ImGuiKey_NamedKey_BEGIN = 512, // First valid key value (other than 0)

	ImGuiKey_Tab = 512, // == ImGuiKey_NamedKey_BEGIN
	ImGuiKey_LeftArrow,
	ImGuiKey_RightArrow,
	ImGuiKey_UpArrow,
	ImGuiKey_DownArrow,
	ImGuiKey_PageUp,
	ImGuiKey_PageDown,
	ImGuiKey_Home,
	ImGuiKey_End,
	ImGuiKey_Insert,
	ImGuiKey_Delete,
	ImGuiKey_Backspace,
	ImGuiKey_Space,
	ImGuiKey_Enter,
	ImGuiKey_Escape,
	ImGuiKey_LeftCtrl, ImGuiKey_LeftShift, ImGuiKey_LeftAlt, ImGuiKey_LeftSuper,
	ImGuiKey_RightCtrl, ImGuiKey_RightShift, ImGuiKey_RightAlt, ImGuiKey_RightSuper,
	ImGuiKey_Menu,
	ImGuiKey_0, ImGuiKey_1, ImGuiKey_2, ImGuiKey_3, ImGuiKey_4, ImGuiKey_5, ImGuiKey_6, ImGuiKey_7, ImGuiKey_8, ImGuiKey_9,
	ImGuiKey_A, ImGuiKey_B, ImGuiKey_C, ImGuiKey_D, ImGuiKey_E, ImGuiKey_F, ImGuiKey_G, ImGuiKey_H, ImGuiKey_I, ImGuiKey_J,
	ImGuiKey_K, ImGuiKey_L, ImGuiKey_M, ImGuiKey_N, ImGuiKey_O, ImGuiKey_P, ImGuiKey_Q, ImGuiKey_R, ImGuiKey_S, ImGuiKey_T,
	ImGuiKey_U, ImGuiKey_V, ImGuiKey_W, ImGuiKey_X, ImGuiKey_Y, ImGuiKey_Z,
	ImGuiKey_F1, ImGuiKey_F2, ImGuiKey_F3, ImGuiKey_F4, ImGuiKey_F5, ImGuiKey_F6,
	ImGuiKey_F7, ImGuiKey_F8, ImGuiKey_F9, ImGuiKey_F10, ImGuiKey_F11, ImGuiKey_F12,
	ImGuiKey_F13, ImGuiKey_F14, ImGuiKey_F15, ImGuiKey_F16, ImGuiKey_F17, ImGuiKey_F18,
	ImGuiKey_F19, ImGuiKey_F20, ImGuiKey_F21, ImGuiKey_F22, ImGuiKey_F23, ImGuiKey_F24,
	ImGuiKey_Apostrophe, // '
	ImGuiKey_Comma, // ,
	ImGuiKey_Minus, // -
	ImGuiKey_Period, // .
	ImGuiKey_Slash, // /
	ImGuiKey_Semicolon, // ;
	ImGuiKey_Equal, // =
	ImGuiKey_LeftBracket, // [
	ImGuiKey_Backslash, // \ (this text inhibit multiline comment caused by backslash)
	ImGuiKey_RightBracket, // ]
	ImGuiKey_GraveAccent, // `
	ImGuiKey_CapsLock,
	ImGuiKey_ScrollLock,
	ImGuiKey_NumLock,
	ImGuiKey_PrintScreen,
	ImGuiKey_Pause,
	ImGuiKey_Keypad0, ImGuiKey_Keypad1, ImGuiKey_Keypad2, ImGuiKey_Keypad3, ImGuiKey_Keypad4,
	ImGuiKey_Keypad5, ImGuiKey_Keypad6, ImGuiKey_Keypad7, ImGuiKey_Keypad8, ImGuiKey_Keypad9,
	ImGuiKey_KeypadDecimal,
	ImGuiKey_KeypadDivide,
	ImGuiKey_KeypadMultiply,
	ImGuiKey_KeypadSubtract,
	ImGuiKey_KeypadAdd,
	ImGuiKey_KeypadEnter,
	ImGuiKey_KeypadEqual,
	ImGuiKey_AppBack, // Available on some keyboard/mouses. Often referred as "Browser Back"
	ImGuiKey_AppForward,

	// Gamepad (some of those are analog values, 0.0f to 1.0f)                          // NAVIGATION ACTION
	// (download controller mapping PNG/PSD at http://dearimgui.com/controls_sheets)
	ImGuiKey_GamepadStart, // Menu (Xbox)      + (Switch)   Start/Options (PS)
	ImGuiKey_GamepadBack, // View (Xbox)      - (Switch)   Share (PS)
	ImGuiKey_GamepadFaceLeft, // X (Xbox)         Y (Switch)   Square (PS)        // Tap: Toggle Menu. Hold: Windowing mode (Focus/Move/Resize windows)
	ImGuiKey_GamepadFaceRight, // B (Xbox)         A (Switch)   Circle (PS)        // Cancel / Close / Exit
	ImGuiKey_GamepadFaceUp, // Y (Xbox)         X (Switch)   Triangle (PS)      // Text Input / On-screen Keyboard
	ImGuiKey_GamepadFaceDown, // A (Xbox)         B (Switch)   Cross (PS)         // Activate / Open / Toggle / Tweak
	ImGuiKey_GamepadDpadLeft, // D-pad Left                                       // Move / Tweak / Resize Window (in Windowing mode)
	ImGuiKey_GamepadDpadRight, // D-pad Right                                      // Move / Tweak / Resize Window (in Windowing mode)
	ImGuiKey_GamepadDpadUp, // D-pad Up                                         // Move / Tweak / Resize Window (in Windowing mode)
	ImGuiKey_GamepadDpadDown, // D-pad Down                                       // Move / Tweak / Resize Window (in Windowing mode)
	ImGuiKey_GamepadL1, // L Bumper (Xbox)  L (Switch)   L1 (PS)            // Tweak Slower / Focus Previous (in Windowing mode)
	ImGuiKey_GamepadR1, // R Bumper (Xbox)  R (Switch)   R1 (PS)            // Tweak Faster / Focus Next (in Windowing mode)
	ImGuiKey_GamepadL2, // L Trig. (Xbox)   ZL (Switch)  L2 (PS) [Analog]
	ImGuiKey_GamepadR2, // R Trig. (Xbox)   ZR (Switch)  R2 (PS) [Analog]
	ImGuiKey_GamepadL3, // L Stick (Xbox)   L3 (Switch)  L3 (PS)
	ImGuiKey_GamepadR3, // R Stick (Xbox)   R3 (Switch)  R3 (PS)
	ImGuiKey_GamepadLStickLeft, // [Analog]                                         // Move Window (in Windowing mode)
	ImGuiKey_GamepadLStickRight, // [Analog]                                         // Move Window (in Windowing mode)
	ImGuiKey_GamepadLStickUp, // [Analog]                                         // Move Window (in Windowing mode)
	ImGuiKey_GamepadLStickDown, // [Analog]                                         // Move Window (in Windowing mode)
	ImGuiKey_GamepadRStickLeft, // [Analog]
	ImGuiKey_GamepadRStickRight, // [Analog]
	ImGuiKey_GamepadRStickUp, // [Analog]
	ImGuiKey_GamepadRStickDown, // [Analog]

	// Aliases: Mouse Buttons (auto-submitted from AddMouseButtonEvent() calls)
	// - This is mirroring the data also written to io.MouseDown[], io.MouseWheel, in a format allowing them to be accessed via standard key API.
	ImGuiKey_MouseLeft, ImGuiKey_MouseRight, ImGuiKey_MouseMiddle, ImGuiKey_MouseX1, ImGuiKey_MouseX2, ImGuiKey_MouseWheelX, ImGuiKey_MouseWheelY,

	// [Internal] Reserved for mod storage
	ImGuiKey_ReservedForModCtrl, ImGuiKey_ReservedForModShift, ImGuiKey_ReservedForModAlt, ImGuiKey_ReservedForModSuper,
	ImGuiKey_NamedKey_END,

	// Keyboard Modifiers (explicitly submitted by backend via AddKeyEvent() calls)
	// - This is mirroring the data also written to io.KeyCtrl, io.KeyShift, io.KeyAlt, io.KeySuper, in a format allowing
	//   them to be accessed via standard key API, allowing calls such as IsKeyPressed(), IsKeyReleased(), querying duration etc.
	// - Code polling every key (e.g. an interface to detect a key press for input mapping) might want to ignore those
	//   and prefer using the real keys (e.g. ImGuiKey_LeftCtrl, ImGuiKey_RightCtrl instead of ImGuiMod_Ctrl).
	// - In theory the value of keyboard modifiers should be roughly equivalent to a logical or of the equivalent left/right keys.
	//   In practice: it's complicated; mods are often provided from different sources. Keyboard layout, IME, sticky keys and
	//   backends tend to interfere and break that equivalence. The safer decision is to relay that ambiguity down to the end-user...
	// - On macOS, we swap Cmd(Super) and Ctrl keys at the time of the io.AddKeyEvent() call.
	ImGuiMod_None = 0,
	ImGuiMod_Ctrl = 1 << 12, // Ctrl (non-macOS), Cmd (macOS)
	ImGuiMod_Shift = 1 << 13, // Shift
	ImGuiMod_Alt = 1 << 14, // Option/Menu
	ImGuiMod_Super = 1 << 15, // Windows/Super (non-macOS), Ctrl (macOS)
	ImGuiMod_Mask_ = 0xF000, // 4-bits

	// [Internal] If you need to iterate all keys (for e.g. an input mapper) you may use ImGuiKey_NamedKey_BEGIN..ImGuiKey_NamedKey_END.
	ImGuiKey_NamedKey_COUNT = ImGuiKey_NamedKey_END - ImGuiKey_NamedKey_BEGIN,
	//ImGuiKey_KeysData_SIZE        = ImGuiKey_NamedKey_COUNT,  // Size of KeysData[]: only hold named keys
	//ImGuiKey_KeysData_OFFSET      = ImGuiKey_NamedKey_BEGIN,  // Accesses to io.KeysData[] must use (key - ImGuiKey_NamedKey_BEGIN) index.
}

// Flags for Shortcut(), SetNextItemShortcut(),
// (and for upcoming extended versions of IsKeyPressed(), IsMouseClicked(), Shortcut(), SetKeyOwner(), SetItemKeyOwner() that are still in imgui_internal.h)
// Don't mistake with ImGuiInputTextFlags! (which is for ImGui::InputText() function)
ImGuiInputFlags_ :: enum i32 {
	ImGuiInputFlags_None = 0,
	ImGuiInputFlags_Repeat = 1 << 0, // Enable repeat. Return true on successive repeats. Default for legacy IsKeyPressed(). NOT Default for legacy IsMouseClicked(). MUST BE == 1.

	// Flags for Shortcut(), SetNextItemShortcut()
	// - Routing policies: RouteGlobal+OverActive >> RouteActive or RouteFocused (if owner is active item) >> RouteGlobal+OverFocused >> RouteFocused (if in focused window stack) >> RouteGlobal.
	// - Default policy is RouteFocused. Can select only 1 policy among all available.
	ImGuiInputFlags_RouteActive = 1 << 10, // Route to active item only.
	ImGuiInputFlags_RouteFocused = 1 << 11, // Route to windows in the focus stack (DEFAULT). Deep-most focused window takes inputs. Active item takes inputs over deep-most focused window.
	ImGuiInputFlags_RouteGlobal = 1 << 12, // Global route (unless a focused window or active item registered the route).
	ImGuiInputFlags_RouteAlways = 1 << 13, // Do not register route, poll keys directly.
	// - Routing options
	ImGuiInputFlags_RouteOverFocused = 1 << 14, // Option: global route: higher priority than focused route (unless active item in focused route).
	ImGuiInputFlags_RouteOverActive = 1 << 15, // Option: global route: higher priority than active item. Unlikely you need to use that: will interfere with every active items, e.g. CTRL+A registered by InputText will be overridden by this. May not be fully honored as user/internal code is likely to always assume they can access keys when active.
	ImGuiInputFlags_RouteUnlessBgFocused = 1 << 16, // Option: global route: will not be applied if underlying background/void is focused (== no Dear ImGui windows are focused). Useful for overlay applications.
	ImGuiInputFlags_RouteFromRootWindow = 1 << 17, // Option: route evaluated from the point of view of root window rather than current window.

	// Flags for SetNextItemShortcut()
	ImGuiInputFlags_Tooltip = 1 << 18, // Automatically display a tooltip when hovering item [BETA] Unsure of right api (opt-in/opt-out)
}

// Configuration flags stored in io.ConfigFlags. Set by user/application.
ImGuiConfigFlags_ :: enum i32 {
	ImGuiConfigFlags_None = 0,
	ImGuiConfigFlags_NavEnableKeyboard = 1 << 0, // Master keyboard navigation enable flag. Enable full Tabbing + directional arrows + space/enter to activate.
	ImGuiConfigFlags_NavEnableGamepad = 1 << 1, // Master gamepad navigation enable flag. Backend also needs to set ImGuiBackendFlags_HasGamepad.
	ImGuiConfigFlags_NoMouse = 1 << 4, // Instruct dear imgui to disable mouse inputs and interactions.
	ImGuiConfigFlags_NoMouseCursorChange = 1 << 5, // Instruct backend to not alter mouse cursor shape and visibility. Use if the backend cursor changes are interfering with yours and you don't want to use SetMouseCursor() to change mouse cursor. You may want to honor requests from imgui by reading GetMouseCursor() yourself instead.
	ImGuiConfigFlags_NoKeyboard = 1 << 6, // Instruct dear imgui to disable keyboard inputs and interactions. This is done by ignoring keyboard events and clearing existing states.

	// [BETA] Docking
	ImGuiConfigFlags_DockingEnable = 1 << 7, // Docking enable flags.

	// [BETA] Viewports
	// When using viewports it is recommended that your default value for ImGuiCol_WindowBg is opaque (Alpha=1.0) so transition to a viewport won't be noticeable.
	ImGuiConfigFlags_ViewportsEnable = 1 << 10, // Viewport enable flags (require both ImGuiBackendFlags_PlatformHasViewports + ImGuiBackendFlags_RendererHasViewports set by the respective backends)
	ImGuiConfigFlags_DpiEnableScaleViewports = 1 << 14, // [BETA: Don't use] FIXME-DPI: Reposition and resize imgui windows when the DpiScale of a viewport changed (mostly useful for the main viewport hosting other window). Note that resizing the main window itself is up to your application.
	ImGuiConfigFlags_DpiEnableScaleFonts = 1 << 15, // [BETA: Don't use] FIXME-DPI: Request bitmap-scaled fonts to match DpiScale. This is a very low-quality workaround. The correct way to handle DPI is _currently_ to replace the atlas and/or fonts in the Platform_OnChangedViewport callback, but this is all early work in progress.

	// User storage (to allow your backend/engine to communicate to code that may be shared between multiple projects. Those flags are NOT used by core Dear ImGui)
	ImGuiConfigFlags_IsSRGB = 1 << 20, // Application is SRGB-aware.
	ImGuiConfigFlags_IsTouchScreen = 1 << 21, // Application is using a touch screen instead of a mouse.
}

// Backend capabilities flags stored in io.BackendFlags. Set by imgui_impl_xxx or custom backend.
ImGuiBackendFlags_ :: enum i32 {
	ImGuiBackendFlags_None = 0,
	ImGuiBackendFlags_HasGamepad = 1 << 0, // Backend Platform supports gamepad and currently has one connected.
	ImGuiBackendFlags_HasMouseCursors = 1 << 1, // Backend Platform supports honoring GetMouseCursor() value to change the OS cursor shape.
	ImGuiBackendFlags_HasSetMousePos = 1 << 2, // Backend Platform supports io.WantSetMousePos requests to reposition the OS mouse position (only used if io.ConfigNavMoveSetMousePos is set).
	ImGuiBackendFlags_RendererHasVtxOffset = 1 << 3, // Backend Renderer supports ImDrawCmd::VtxOffset. This enables output of large meshes (64K+ vertices) while still using 16-bit indices.

	// [BETA] Viewports
	ImGuiBackendFlags_PlatformHasViewports = 1 << 10, // Backend Platform supports multiple viewports.
	ImGuiBackendFlags_HasMouseHoveredViewport = 1 << 11, // Backend Platform supports calling io.AddMouseViewportEvent() with the viewport under the mouse. IF POSSIBLE, ignore viewports with the ImGuiViewportFlags_NoInputs flag (Win32 backend, GLFW 3.30+ backend can do this, SDL backend cannot). If this cannot be done, Dear ImGui needs to use a flawed heuristic to find the viewport under.
	ImGuiBackendFlags_RendererHasViewports = 1 << 12, // Backend Renderer supports multiple viewports.
}

// Enumeration for PushStyleColor() / PopStyleColor()
ImGuiCol_ :: enum i32 {
	ImGuiCol_Text,
	ImGuiCol_TextDisabled,
	ImGuiCol_WindowBg, // Background of normal windows
	ImGuiCol_ChildBg, // Background of child windows
	ImGuiCol_PopupBg, // Background of popups, menus, tooltips windows
	ImGuiCol_Border,
	ImGuiCol_BorderShadow,
	ImGuiCol_FrameBg, // Background of checkbox, radio button, plot, slider, text input
	ImGuiCol_FrameBgHovered,
	ImGuiCol_FrameBgActive,
	ImGuiCol_TitleBg, // Title bar
	ImGuiCol_TitleBgActive, // Title bar when focused
	ImGuiCol_TitleBgCollapsed, // Title bar when collapsed
	ImGuiCol_MenuBarBg,
	ImGuiCol_ScrollbarBg,
	ImGuiCol_ScrollbarGrab,
	ImGuiCol_ScrollbarGrabHovered,
	ImGuiCol_ScrollbarGrabActive,
	ImGuiCol_CheckMark, // Checkbox tick and RadioButton circle
	ImGuiCol_SliderGrab,
	ImGuiCol_SliderGrabActive,
	ImGuiCol_Button,
	ImGuiCol_ButtonHovered,
	ImGuiCol_ButtonActive,
	ImGuiCol_Header, // Header* colors are used for CollapsingHeader, TreeNode, Selectable, MenuItem
	ImGuiCol_HeaderHovered,
	ImGuiCol_HeaderActive,
	ImGuiCol_Separator,
	ImGuiCol_SeparatorHovered,
	ImGuiCol_SeparatorActive,
	ImGuiCol_ResizeGrip, // Resize grip in lower-right and lower-left corners of windows.
	ImGuiCol_ResizeGripHovered,
	ImGuiCol_ResizeGripActive,
	ImGuiCol_TabHovered, // Tab background, when hovered
	ImGuiCol_Tab, // Tab background, when tab-bar is focused & tab is unselected
	ImGuiCol_TabSelected, // Tab background, when tab-bar is focused & tab is selected
	ImGuiCol_TabSelectedOverline, // Tab horizontal overline, when tab-bar is focused & tab is selected
	ImGuiCol_TabDimmed, // Tab background, when tab-bar is unfocused & tab is unselected
	ImGuiCol_TabDimmedSelected, // Tab background, when tab-bar is unfocused & tab is selected
	ImGuiCol_TabDimmedSelectedOverline, //..horizontal overline, when tab-bar is unfocused & tab is selected
	ImGuiCol_DockingPreview, // Preview overlay color when about to docking something
	ImGuiCol_DockingEmptyBg, // Background color for empty node (e.g. CentralNode with no window docked into it)
	ImGuiCol_PlotLines,
	ImGuiCol_PlotLinesHovered,
	ImGuiCol_PlotHistogram,
	ImGuiCol_PlotHistogramHovered,
	ImGuiCol_TableHeaderBg, // Table header background
	ImGuiCol_TableBorderStrong, // Table outer and header borders (prefer using Alpha=1.0 here)
	ImGuiCol_TableBorderLight, // Table inner borders (prefer using Alpha=1.0 here)
	ImGuiCol_TableRowBg, // Table row background (even rows)
	ImGuiCol_TableRowBgAlt, // Table row background (odd rows)
	ImGuiCol_TextLink, // Hyperlink color
	ImGuiCol_TextSelectedBg,
	ImGuiCol_DragDropTarget, // Rectangle highlighting a drop target
	ImGuiCol_NavCursor, // Color of keyboard/gamepad navigation cursor/rectangle, when visible
	ImGuiCol_NavWindowingHighlight, // Highlight window when using CTRL+TAB
	ImGuiCol_NavWindowingDimBg, // Darken/colorize entire screen behind the CTRL+TAB window list, when active
	ImGuiCol_ModalWindowDimBg, // Darken/colorize entire screen behind a modal window, when one is active
	ImGuiCol_COUNT,
}

// Enumeration for PushStyleVar() / PopStyleVar() to temporarily modify the ImGuiStyle structure.
// - The enum only refers to fields of ImGuiStyle which makes sense to be pushed/popped inside UI code.
//   During initialization or between frames, feel free to just poke into ImGuiStyle directly.
// - Tip: Use your programming IDE navigation facilities on the names in the _second column_ below to find the actual members and their description.
//   - In Visual Studio: CTRL+comma ("Edit.GoToAll") can follow symbols inside comments, whereas CTRL+F12 ("Edit.GoToImplementation") cannot.
//   - In Visual Studio w/ Visual Assist installed: ALT+G ("VAssistX.GoToImplementation") can also follow symbols inside comments.
//   - In VS Code, CLion, etc.: CTRL+click can follow symbols inside comments.
// - When changing this enum, you need to update the associated internal table GStyleVarInfo[] accordingly. This is where we link enum values to members offset/type.
ImGuiStyleVar_ :: enum i32 {
	// Enum name -------------------------- // Member in ImGuiStyle structure (see ImGuiStyle for descriptions)
	ImGuiStyleVar_Alpha, // float     Alpha
	ImGuiStyleVar_DisabledAlpha, // float     DisabledAlpha
	ImGuiStyleVar_WindowPadding, // ImVec2    WindowPadding
	ImGuiStyleVar_WindowRounding, // float     WindowRounding
	ImGuiStyleVar_WindowBorderSize, // float     WindowBorderSize
	ImGuiStyleVar_WindowMinSize, // ImVec2    WindowMinSize
	ImGuiStyleVar_WindowTitleAlign, // ImVec2    WindowTitleAlign
	ImGuiStyleVar_ChildRounding, // float     ChildRounding
	ImGuiStyleVar_ChildBorderSize, // float     ChildBorderSize
	ImGuiStyleVar_PopupRounding, // float     PopupRounding
	ImGuiStyleVar_PopupBorderSize, // float     PopupBorderSize
	ImGuiStyleVar_FramePadding, // ImVec2    FramePadding
	ImGuiStyleVar_FrameRounding, // float     FrameRounding
	ImGuiStyleVar_FrameBorderSize, // float     FrameBorderSize
	ImGuiStyleVar_ItemSpacing, // ImVec2    ItemSpacing
	ImGuiStyleVar_ItemInnerSpacing, // ImVec2    ItemInnerSpacing
	ImGuiStyleVar_IndentSpacing, // float     IndentSpacing
	ImGuiStyleVar_CellPadding, // ImVec2    CellPadding
	ImGuiStyleVar_ScrollbarSize, // float     ScrollbarSize
	ImGuiStyleVar_ScrollbarRounding, // float     ScrollbarRounding
	ImGuiStyleVar_GrabMinSize, // float     GrabMinSize
	ImGuiStyleVar_GrabRounding, // float     GrabRounding
	ImGuiStyleVar_TabRounding, // float     TabRounding
	ImGuiStyleVar_TabBorderSize, // float     TabBorderSize
	ImGuiStyleVar_TabBarBorderSize, // float     TabBarBorderSize
	ImGuiStyleVar_TabBarOverlineSize, // float     TabBarOverlineSize
	ImGuiStyleVar_TableAngledHeadersAngle, // float     TableAngledHeadersAngle
	ImGuiStyleVar_TableAngledHeadersTextAlign, // ImVec2  TableAngledHeadersTextAlign
	ImGuiStyleVar_ButtonTextAlign, // ImVec2    ButtonTextAlign
	ImGuiStyleVar_SelectableTextAlign, // ImVec2    SelectableTextAlign
	ImGuiStyleVar_SeparatorTextBorderSize, // float     SeparatorTextBorderSize
	ImGuiStyleVar_SeparatorTextAlign, // ImVec2    SeparatorTextAlign
	ImGuiStyleVar_SeparatorTextPadding, // ImVec2    SeparatorTextPadding
	ImGuiStyleVar_DockingSeparatorSize, // float     DockingSeparatorSize
	ImGuiStyleVar_COUNT,
}

// Flags for InvisibleButton() [extended in imgui_internal.h]
ImGuiButtonFlags_ :: enum i32 {
	ImGuiButtonFlags_None = 0,
	ImGuiButtonFlags_MouseButtonLeft = 1 << 0, // React on left mouse button (default)
	ImGuiButtonFlags_MouseButtonRight = 1 << 1, // React on right mouse button
	ImGuiButtonFlags_MouseButtonMiddle = 1 << 2, // React on center mouse button
	ImGuiButtonFlags_MouseButtonMask_ = ImGuiButtonFlags_MouseButtonLeft | ImGuiButtonFlags_MouseButtonRight | ImGuiButtonFlags_MouseButtonMiddle, // [Internal]
	ImGuiButtonFlags_EnableNav = 1 << 3, // InvisibleButton(): do not disable navigation/tabbing. Otherwise disabled by default.
}

// Flags for ColorEdit3() / ColorEdit4() / ColorPicker3() / ColorPicker4() / ColorButton()
ImGuiColorEditFlags_ :: enum i32 {
	ImGuiColorEditFlags_None = 0,
	ImGuiColorEditFlags_NoAlpha = 1 << 1, //              // ColorEdit, ColorPicker, ColorButton: ignore Alpha component (will only read 3 components from the input pointer).
	ImGuiColorEditFlags_NoPicker = 1 << 2, //              // ColorEdit: disable picker when clicking on color square.
	ImGuiColorEditFlags_NoOptions = 1 << 3, //              // ColorEdit: disable toggling options menu when right-clicking on inputs/small preview.
	ImGuiColorEditFlags_NoSmallPreview = 1 << 4, //              // ColorEdit, ColorPicker: disable color square preview next to the inputs. (e.g. to show only the inputs)
	ImGuiColorEditFlags_NoInputs = 1 << 5, //              // ColorEdit, ColorPicker: disable inputs sliders/text widgets (e.g. to show only the small preview color square).
	ImGuiColorEditFlags_NoTooltip = 1 << 6, //              // ColorEdit, ColorPicker, ColorButton: disable tooltip when hovering the preview.
	ImGuiColorEditFlags_NoLabel = 1 << 7, //              // ColorEdit, ColorPicker: disable display of inline text label (the label is still forwarded to the tooltip and picker).
	ImGuiColorEditFlags_NoSidePreview = 1 << 8, //              // ColorPicker: disable bigger color preview on right side of the picker, use small color square preview instead.
	ImGuiColorEditFlags_NoDragDrop = 1 << 9, //              // ColorEdit: disable drag and drop target. ColorButton: disable drag and drop source.
	ImGuiColorEditFlags_NoBorder = 1 << 10, //              // ColorButton: disable border (which is enforced by default)

	// User Options (right-click on widget to change some of them).
	ImGuiColorEditFlags_AlphaBar = 1 << 16, //              // ColorEdit, ColorPicker: show vertical alpha bar/gradient in picker.
	ImGuiColorEditFlags_AlphaPreview = 1 << 17, //              // ColorEdit, ColorPicker, ColorButton: display preview as a transparent color over a checkerboard, instead of opaque.
	ImGuiColorEditFlags_AlphaPreviewHalf = 1 << 18, //              // ColorEdit, ColorPicker, ColorButton: display half opaque / half checkerboard, instead of opaque.
	ImGuiColorEditFlags_HDR = 1 << 19, //              // (WIP) ColorEdit: Currently only disable 0.0f..1.0f limits in RGBA edition (note: you probably want to use ImGuiColorEditFlags_Float flag as well).
	ImGuiColorEditFlags_DisplayRGB = 1 << 20, // [Display]    // ColorEdit: override _display_ type among RGB/HSV/Hex. ColorPicker: select any combination using one or more of RGB/HSV/Hex.
	ImGuiColorEditFlags_DisplayHSV = 1 << 21, // [Display]    // "
	ImGuiColorEditFlags_DisplayHex = 1 << 22, // [Display]    // "
	ImGuiColorEditFlags_Uint8 = 1 << 23, // [DataType]   // ColorEdit, ColorPicker, ColorButton: _display_ values formatted as 0..255.
	ImGuiColorEditFlags_Float = 1 << 24, // [DataType]   // ColorEdit, ColorPicker, ColorButton: _display_ values formatted as 0.0f..1.0f floats instead of 0..255 integers. No round-trip of value via integers.
	ImGuiColorEditFlags_PickerHueBar = 1 << 25, // [Picker]     // ColorPicker: bar for Hue, rectangle for Sat/Value.
	ImGuiColorEditFlags_PickerHueWheel = 1 << 26, // [Picker]     // ColorPicker: wheel for Hue, triangle for Sat/Value.
	ImGuiColorEditFlags_InputRGB = 1 << 27, // [Input]      // ColorEdit, ColorPicker: input and output data in RGB format.
	ImGuiColorEditFlags_InputHSV = 1 << 28, // [Input]      // ColorEdit, ColorPicker: input and output data in HSV format.

	// Defaults Options. You can set application defaults using SetColorEditOptions(). The intent is that you probably don't want to
	// override them in most of your calls. Let the user choose via the option menu and/or call SetColorEditOptions() once during startup.
	ImGuiColorEditFlags_DefaultOptions_ = ImGuiColorEditFlags_Uint8 | ImGuiColorEditFlags_DisplayRGB | ImGuiColorEditFlags_InputRGB | ImGuiColorEditFlags_PickerHueBar,

	// [Internal] Masks
	ImGuiColorEditFlags_DisplayMask_ = ImGuiColorEditFlags_DisplayRGB | ImGuiColorEditFlags_DisplayHSV | ImGuiColorEditFlags_DisplayHex,
	ImGuiColorEditFlags_DataTypeMask_ = ImGuiColorEditFlags_Uint8 | ImGuiColorEditFlags_Float,
	ImGuiColorEditFlags_PickerMask_ = ImGuiColorEditFlags_PickerHueWheel | ImGuiColorEditFlags_PickerHueBar,
	ImGuiColorEditFlags_InputMask_ = ImGuiColorEditFlags_InputRGB | ImGuiColorEditFlags_InputHSV,

	// Obsolete names
	//ImGuiColorEditFlags_RGB = ImGuiColorEditFlags_DisplayRGB, ImGuiColorEditFlags_HSV = ImGuiColorEditFlags_DisplayHSV, ImGuiColorEditFlags_HEX = ImGuiColorEditFlags_DisplayHex  // [renamed in 1.69]
}

// Flags for DragFloat(), DragInt(), SliderFloat(), SliderInt() etc.
// We use the same sets of flags for DragXXX() and SliderXXX() functions as the features are the same and it makes it easier to swap them.
// (Those are per-item flags. There is shared behavior flag too: ImGuiIO: io.ConfigDragClickToInputText)
ImGuiSliderFlags_ :: enum i32 {
	ImGuiSliderFlags_None = 0,
	ImGuiSliderFlags_Logarithmic = 1 << 5, // Make the widget logarithmic (linear otherwise). Consider using ImGuiSliderFlags_NoRoundToFormat with this if using a format-string with small amount of digits.
	ImGuiSliderFlags_NoRoundToFormat = 1 << 6, // Disable rounding underlying value to match precision of the display format string (e.g. %.3f values are rounded to those 3 digits).
	ImGuiSliderFlags_NoInput = 1 << 7, // Disable CTRL+Click or Enter key allowing to input text directly into the widget.
	ImGuiSliderFlags_WrapAround = 1 << 8, // Enable wrapping around from max to min and from min to max. Only supported by DragXXX() functions for now.
	ImGuiSliderFlags_ClampOnInput = 1 << 9, // Clamp value to min/max bounds when input manually with CTRL+Click. By default CTRL+Click allows going out of bounds.
	ImGuiSliderFlags_ClampZeroRange = 1 << 10, // Clamp even if min==max==0.0f. Otherwise due to legacy reason DragXXX functions don't clamp with those values. When your clamping limits are dynamic you almost always want to use it.
	ImGuiSliderFlags_NoSpeedTweaks = 1 << 11, // Disable keyboard modifiers altering tweak speed. Useful if you want to alter tweak speed yourself based on your own logic.
	ImGuiSliderFlags_AlwaysClamp = ImGuiSliderFlags_ClampOnInput | ImGuiSliderFlags_ClampZeroRange,
	ImGuiSliderFlags_InvalidMask_ = 0x7000000F, // [Internal] We treat using those bits as being potentially a 'float power' argument from the previous API that has got miscast to this enum, and will trigger an assert if needed.
}

// Identify a mouse button.
// Those values are guaranteed to be stable and we frequently use 0/1 directly. Named enums provided for convenience.
ImGuiMouseButton_ :: enum i32 {
	ImGuiMouseButton_Left = 0,
	ImGuiMouseButton_Right = 1,
	ImGuiMouseButton_Middle = 2,
	ImGuiMouseButton_COUNT = 5,
}

// Enumeration for GetMouseCursor()
// User code may request backend to display given cursor by calling SetMouseCursor(), which is why we have some cursors that are marked unused here
ImGuiMouseCursor_ :: enum i32 {
	ImGuiMouseCursor_None = -1,
	ImGuiMouseCursor_Arrow = 0,
	ImGuiMouseCursor_TextInput, // When hovering over InputText, etc.
	ImGuiMouseCursor_ResizeAll, // (Unused by Dear ImGui functions)
	ImGuiMouseCursor_ResizeNS, // When hovering over a horizontal border
	ImGuiMouseCursor_ResizeEW, // When hovering over a vertical border or a column
	ImGuiMouseCursor_ResizeNESW, // When hovering over the bottom-left corner of a window
	ImGuiMouseCursor_ResizeNWSE, // When hovering over the bottom-right corner of a window
	ImGuiMouseCursor_Hand, // (Unused by Dear ImGui functions. Use for e.g. hyperlinks)
	ImGuiMouseCursor_NotAllowed, // When hovering something with disallowed interaction. Usually a crossed circle.
	ImGuiMouseCursor_COUNT,
}

// -> enum ImGuiKey              // Enum: A key identifier (ImGuiKey_XXX or ImGuiMod_XXX value)
// Enumeration for AddMouseSourceEvent() actual source of Mouse Input data.
// Historically we use "Mouse" terminology everywhere to indicate pointer data, e.g. MousePos, IsMousePressed(), io.AddMousePosEvent()
// But that "Mouse" data can come from different source which occasionally may be useful for application to know about.
// You can submit a change of pointer type using io.AddMouseSourceEvent().
ImGuiMouseSource :: enum i32 {
	ImGuiMouseSource_Mouse = 0, // Input is coming from an actual mouse.
	ImGuiMouseSource_TouchScreen, // Input is coming from a touch screen (no hovering prior to initial press, less precise initial press aiming, dual-axis wheeling possible).
	ImGuiMouseSource_Pen, // Input is coming from a pressure/magnetic pen (often used in conjunction with high-sampling rates).
	ImGuiMouseSource_COUNT,
}

// Enumeration for ImGui::SetNextWindow***(), SetWindow***(), SetNextItem***() functions
// Represent a condition.
// Important: Treat as a regular enum! Do NOT combine multiple values using binary operators! All the functions above treat 0 as a shortcut to ImGuiCond_Always.
ImGuiCond_ :: enum i32 {
	ImGuiCond_None = 0, // No condition (always set the variable), same as _Always
	ImGuiCond_Always = 1 << 0, // No condition (always set the variable), same as _None
	ImGuiCond_Once = 1 << 1, // Set the variable once per runtime session (only the first call will succeed)
	ImGuiCond_FirstUseEver = 1 << 2, // Set the variable if the object/window has no persistently saved data (no entry in .ini file)
	ImGuiCond_Appearing = 1 << 3, // Set the variable if the object/window is appearing after being hidden/inactive (or the first time)
}

//-----------------------------------------------------------------------------
// [SECTION] Tables API flags and structures (ImGuiTableFlags, ImGuiTableColumnFlags, ImGuiTableRowFlags, ImGuiTableBgTarget, ImGuiTableSortSpecs, ImGuiTableColumnSortSpecs)
//-----------------------------------------------------------------------------

// Flags for ImGui::BeginTable()
// - Important! Sizing policies have complex and subtle side effects, much more so than you would expect.
//   Read comments/demos carefully + experiment with live demos to get acquainted with them.
// - The DEFAULT sizing policies are:
//    - Default to ImGuiTableFlags_SizingFixedFit    if ScrollX is on, or if host window has ImGuiWindowFlags_AlwaysAutoResize.
//    - Default to ImGuiTableFlags_SizingStretchSame if ScrollX is off.
// - When ScrollX is off:
//    - Table defaults to ImGuiTableFlags_SizingStretchSame -> all Columns defaults to ImGuiTableColumnFlags_WidthStretch with same weight.
//    - Columns sizing policy allowed: Stretch (default), Fixed/Auto.
//    - Fixed Columns (if any) will generally obtain their requested width (unless the table cannot fit them all).
//    - Stretch Columns will share the remaining width according to their respective weight.
//    - Mixed Fixed/Stretch columns is possible but has various side-effects on resizing behaviors.
//      The typical use of mixing sizing policies is: any number of LEADING Fixed columns, followed by one or two TRAILING Stretch columns.
//      (this is because the visible order of columns have subtle but necessary effects on how they react to manual resizing).
// - When ScrollX is on:
//    - Table defaults to ImGuiTableFlags_SizingFixedFit -> all Columns defaults to ImGuiTableColumnFlags_WidthFixed
//    - Columns sizing policy allowed: Fixed/Auto mostly.
//    - Fixed Columns can be enlarged as needed. Table will show a horizontal scrollbar if needed.
//    - When using auto-resizing (non-resizable) fixed columns, querying the content width to use item right-alignment e.g. SetNextItemWidth(-FLT_MIN) doesn't make sense, would create a feedback loop.
//    - Using Stretch columns OFTEN DOES NOT MAKE SENSE if ScrollX is on, UNLESS you have specified a value for 'inner_width' in BeginTable().
//      If you specify a value for 'inner_width' then effectively the scrolling space is known and Stretch or mixed Fixed/Stretch columns become meaningful again.
// - Read on documentation at the top of imgui_tables.cpp for details.
ImGuiTableFlags_ :: enum i32 {
	// Features
	ImGuiTableFlags_None = 0,
	ImGuiTableFlags_Resizable = 1 << 0, // Enable resizing columns.
	ImGuiTableFlags_Reorderable = 1 << 1, // Enable reordering columns in header row (need calling TableSetupColumn() + TableHeadersRow() to display headers)
	ImGuiTableFlags_Hideable = 1 << 2, // Enable hiding/disabling columns in context menu.
	ImGuiTableFlags_Sortable = 1 << 3, // Enable sorting. Call TableGetSortSpecs() to obtain sort specs. Also see ImGuiTableFlags_SortMulti and ImGuiTableFlags_SortTristate.
	ImGuiTableFlags_NoSavedSettings = 1 << 4, // Disable persisting columns order, width and sort settings in the .ini file.
	ImGuiTableFlags_ContextMenuInBody = 1 << 5, // Right-click on columns body/contents will display table context menu. By default it is available in TableHeadersRow().
	// Decorations
	ImGuiTableFlags_RowBg = 1 << 6, // Set each RowBg color with ImGuiCol_TableRowBg or ImGuiCol_TableRowBgAlt (equivalent of calling TableSetBgColor with ImGuiTableBgFlags_RowBg0 on each row manually)
	ImGuiTableFlags_BordersInnerH = 1 << 7, // Draw horizontal borders between rows.
	ImGuiTableFlags_BordersOuterH = 1 << 8, // Draw horizontal borders at the top and bottom.
	ImGuiTableFlags_BordersInnerV = 1 << 9, // Draw vertical borders between columns.
	ImGuiTableFlags_BordersOuterV = 1 << 10, // Draw vertical borders on the left and right sides.
	ImGuiTableFlags_BordersH = ImGuiTableFlags_BordersInnerH | ImGuiTableFlags_BordersOuterH, // Draw horizontal borders.
	ImGuiTableFlags_BordersV = ImGuiTableFlags_BordersInnerV | ImGuiTableFlags_BordersOuterV, // Draw vertical borders.
	ImGuiTableFlags_BordersInner = ImGuiTableFlags_BordersInnerV | ImGuiTableFlags_BordersInnerH, // Draw inner borders.
	ImGuiTableFlags_BordersOuter = ImGuiTableFlags_BordersOuterV | ImGuiTableFlags_BordersOuterH, // Draw outer borders.
	ImGuiTableFlags_Borders = ImGuiTableFlags_BordersInner | ImGuiTableFlags_BordersOuter, // Draw all borders.
	ImGuiTableFlags_NoBordersInBody = 1 << 11, // [ALPHA] Disable vertical borders in columns Body (borders will always appear in Headers). -> May move to style
	ImGuiTableFlags_NoBordersInBodyUntilResize = 1 << 12, // [ALPHA] Disable vertical borders in columns Body until hovered for resize (borders will always appear in Headers). -> May move to style
	// Sizing Policy (read above for defaults)
	ImGuiTableFlags_SizingFixedFit = 1 << 13, // Columns default to _WidthFixed or _WidthAuto (if resizable or not resizable), matching contents width.
	ImGuiTableFlags_SizingFixedSame = 2 << 13, // Columns default to _WidthFixed or _WidthAuto (if resizable or not resizable), matching the maximum contents width of all columns. Implicitly enable ImGuiTableFlags_NoKeepColumnsVisible.
	ImGuiTableFlags_SizingStretchProp = 3 << 13, // Columns default to _WidthStretch with default weights proportional to each columns contents widths.
	ImGuiTableFlags_SizingStretchSame = 4 << 13, // Columns default to _WidthStretch with default weights all equal, unless overridden by TableSetupColumn().
	// Sizing Extra Options
	ImGuiTableFlags_NoHostExtendX = 1 << 16, // Make outer width auto-fit to columns, overriding outer_size.x value. Only available when ScrollX/ScrollY are disabled and Stretch columns are not used.
	ImGuiTableFlags_NoHostExtendY = 1 << 17, // Make outer height stop exactly at outer_size.y (prevent auto-extending table past the limit). Only available when ScrollX/ScrollY are disabled. Data below the limit will be clipped and not visible.
	ImGuiTableFlags_NoKeepColumnsVisible = 1 << 18, // Disable keeping column always minimally visible when ScrollX is off and table gets too small. Not recommended if columns are resizable.
	ImGuiTableFlags_PreciseWidths = 1 << 19, // Disable distributing remainder width to stretched columns (width allocation on a 100-wide table with 3 columns: Without this flag: 33,33,34. With this flag: 33,33,33). With larger number of columns, resizing will appear to be less smooth.
	// Clipping
	ImGuiTableFlags_NoClip = 1 << 20, // Disable clipping rectangle for every individual columns (reduce draw command count, items will be able to overflow into other columns). Generally incompatible with TableSetupScrollFreeze().
	// Padding
	ImGuiTableFlags_PadOuterX = 1 << 21, // Default if BordersOuterV is on. Enable outermost padding. Generally desirable if you have headers.
	ImGuiTableFlags_NoPadOuterX = 1 << 22, // Default if BordersOuterV is off. Disable outermost padding.
	ImGuiTableFlags_NoPadInnerX = 1 << 23, // Disable inner padding between columns (double inner padding if BordersOuterV is on, single inner padding if BordersOuterV is off).
	// Scrolling
	ImGuiTableFlags_ScrollX = 1 << 24, // Enable horizontal scrolling. Require 'outer_size' parameter of BeginTable() to specify the container size. Changes default sizing policy. Because this creates a child window, ScrollY is currently generally recommended when using ScrollX.
	ImGuiTableFlags_ScrollY = 1 << 25, // Enable vertical scrolling. Require 'outer_size' parameter of BeginTable() to specify the container size.
	// Sorting
	ImGuiTableFlags_SortMulti = 1 << 26, // Hold shift when clicking headers to sort on multiple column. TableGetSortSpecs() may return specs where (SpecsCount > 1).
	ImGuiTableFlags_SortTristate = 1 << 27, // Allow no sorting, disable default sorting. TableGetSortSpecs() may return specs where (SpecsCount == 0).
	// Miscellaneous
	ImGuiTableFlags_HighlightHoveredColumn = 1 << 28, // Highlight column headers when hovered (may evolve into a fuller highlight)

	// [Internal] Combinations and masks
	ImGuiTableFlags_SizingMask_ = ImGuiTableFlags_SizingFixedFit | ImGuiTableFlags_SizingFixedSame | ImGuiTableFlags_SizingStretchProp | ImGuiTableFlags_SizingStretchSame,
}

// Flags for ImGui::TableSetupColumn()
ImGuiTableColumnFlags_ :: enum i32 {
	// Input configuration flags
	ImGuiTableColumnFlags_None = 0,
	ImGuiTableColumnFlags_Disabled = 1 << 0, // Overriding/master disable flag: hide column, won't show in context menu (unlike calling TableSetColumnEnabled() which manipulates the user accessible state)
	ImGuiTableColumnFlags_DefaultHide = 1 << 1, // Default as a hidden/disabled column.
	ImGuiTableColumnFlags_DefaultSort = 1 << 2, // Default as a sorting column.
	ImGuiTableColumnFlags_WidthStretch = 1 << 3, // Column will stretch. Preferable with horizontal scrolling disabled (default if table sizing policy is _SizingStretchSame or _SizingStretchProp).
	ImGuiTableColumnFlags_WidthFixed = 1 << 4, // Column will not stretch. Preferable with horizontal scrolling enabled (default if table sizing policy is _SizingFixedFit and table is resizable).
	ImGuiTableColumnFlags_NoResize = 1 << 5, // Disable manual resizing.
	ImGuiTableColumnFlags_NoReorder = 1 << 6, // Disable manual reordering this column, this will also prevent other columns from crossing over this column.
	ImGuiTableColumnFlags_NoHide = 1 << 7, // Disable ability to hide/disable this column.
	ImGuiTableColumnFlags_NoClip = 1 << 8, // Disable clipping for this column (all NoClip columns will render in a same draw command).
	ImGuiTableColumnFlags_NoSort = 1 << 9, // Disable ability to sort on this field (even if ImGuiTableFlags_Sortable is set on the table).
	ImGuiTableColumnFlags_NoSortAscending = 1 << 10, // Disable ability to sort in the ascending direction.
	ImGuiTableColumnFlags_NoSortDescending = 1 << 11, // Disable ability to sort in the descending direction.
	ImGuiTableColumnFlags_NoHeaderLabel = 1 << 12, // TableHeadersRow() will submit an empty label for this column. Convenient for some small columns. Name will still appear in context menu or in angled headers. You may append into this cell by calling TableSetColumnIndex() right after the TableHeadersRow() call.
	ImGuiTableColumnFlags_NoHeaderWidth = 1 << 13, // Disable header text width contribution to automatic column width.
	ImGuiTableColumnFlags_PreferSortAscending = 1 << 14, // Make the initial sort direction Ascending when first sorting on this column (default).
	ImGuiTableColumnFlags_PreferSortDescending = 1 << 15, // Make the initial sort direction Descending when first sorting on this column.
	ImGuiTableColumnFlags_IndentEnable = 1 << 16, // Use current Indent value when entering cell (default for column 0).
	ImGuiTableColumnFlags_IndentDisable = 1 << 17, // Ignore current Indent value when entering cell (default for columns > 0). Indentation changes _within_ the cell will still be honored.
	ImGuiTableColumnFlags_AngledHeader = 1 << 18, // TableHeadersRow() will submit an angled header row for this column. Note this will add an extra row.

	// Output status flags, read-only via TableGetColumnFlags()
	ImGuiTableColumnFlags_IsEnabled = 1 << 24, // Status: is enabled == not hidden by user/api (referred to as "Hide" in _DefaultHide and _NoHide) flags.
	ImGuiTableColumnFlags_IsVisible = 1 << 25, // Status: is visible == is enabled AND not clipped by scrolling.
	ImGuiTableColumnFlags_IsSorted = 1 << 26, // Status: is currently part of the sort specs
	ImGuiTableColumnFlags_IsHovered = 1 << 27, // Status: is hovered by mouse

	// [Internal] Combinations and masks
	ImGuiTableColumnFlags_WidthMask_ = ImGuiTableColumnFlags_WidthStretch | ImGuiTableColumnFlags_WidthFixed,
	ImGuiTableColumnFlags_IndentMask_ = ImGuiTableColumnFlags_IndentEnable | ImGuiTableColumnFlags_IndentDisable,
	ImGuiTableColumnFlags_StatusMask_ = ImGuiTableColumnFlags_IsEnabled | ImGuiTableColumnFlags_IsVisible | ImGuiTableColumnFlags_IsSorted | ImGuiTableColumnFlags_IsHovered,
	ImGuiTableColumnFlags_NoDirectResize_ = 1 << 30, // [Internal] Disable user resizing this column directly (it may however we resized indirectly from its left edge)
}

// Flags for ImGui::TableNextRow()
ImGuiTableRowFlags_ :: enum i32 {
	ImGuiTableRowFlags_None = 0,
	ImGuiTableRowFlags_Headers = 1 << 0, // Identify header row (set default background color + width of its contents accounted differently for auto column width)
}

// Enum for ImGui::TableSetBgColor()
// Background colors are rendering in 3 layers:
//  - Layer 0: draw with RowBg0 color if set, otherwise draw with ColumnBg0 if set.
//  - Layer 1: draw with RowBg1 color if set, otherwise draw with ColumnBg1 if set.
//  - Layer 2: draw with CellBg color if set.
// The purpose of the two row/columns layers is to let you decide if a background color change should override or blend with the existing color.
// When using ImGuiTableFlags_RowBg on the table, each row has the RowBg0 color automatically set for odd/even rows.
// If you set the color of RowBg0 target, your color will override the existing RowBg0 color.
// If you set the color of RowBg1 or ColumnBg1 target, your color will blend over the RowBg0 color.
ImGuiTableBgTarget_ :: enum i32 {
	ImGuiTableBgTarget_None = 0,
	ImGuiTableBgTarget_RowBg0 = 1, // Set row background color 0 (generally used for background, automatically set when ImGuiTableFlags_RowBg is used)
	ImGuiTableBgTarget_RowBg1 = 2, // Set row background color 1 (generally used for selection marking)
	ImGuiTableBgTarget_CellBg = 3, // Set cell background color (top-most color)
}

// Runtime data for styling/colors
// Sorting specifications for a table (often handling sort specs for a single column, occasionally more)
// Obtained by calling TableGetSortSpecs().
// When 'SpecsDirty == true' you can sort your data. It will be true with sorting specs have changed since last call, or the first time.
// Make sure to set 'SpecsDirty = false' after sorting, else you may wastefully sort your data every frame!
ImGuiTableSortSpecs :: struct {
	Specs : ^ImGuiTableColumnSortSpecs, // Pointer to sort spec array.
	SpecsCount : i32, // Sort spec count. Most often 1. May be > 1 when ImGuiTableFlags_SortMulti is enabled. May be == 0 when ImGuiTableFlags_SortTristate is enabled.
	SpecsDirty : bool, }

// Set to true when specs have changed since last time! Use this to sort again, then clear the flag.

ImGuiTableSortSpecs_init :: proc(this : ^ImGuiTableSortSpecs) { memset(this, 0, size_of(this)) }

// Sorting specifications for a table (often handling sort specs for a single column, occasionally more)
// Sorting specification for one column of a table (sizeof == 12 bytes)
ImGuiTableColumnSortSpecs :: struct {
	ColumnUserID : ImGuiID, // User id of the column (if specified by a TableSetupColumn() call)
	ColumnIndex : ImS16, // Index of the column
	SortOrder : ImS16, // Index within parent ImGuiTableSortSpecs (always stored in order starting from 0, tables sorted on a single criteria will always have a 0 here)
	SortDirection : ImGuiSortDirection, }

// ImGuiSortDirection_Ascending or ImGuiSortDirection_Descending

ImGuiTableColumnSortSpecs_init :: proc(this : ^ImGuiTableColumnSortSpecs) { memset(this, 0, size_of(this)) }

//-----------------------------------------------------------------------------
// [SECTION] Helpers: Debug log, memory allocations macros, ImVector<>
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// Debug Logging into ShowDebugLogWindow(), tty and more.
//-----------------------------------------------------------------------------

when !IMGUI_DISABLE_DEBUG_TOOLS {
IMGUI_DEBUG_LOG :: #force_inline proc "contextless" (args : ..[]any) //TODO @gen: Validate the parameters were not passed by reference.
{
	ImGui::DebugLog(args)
}

} else { // preproc else
IMGUI_DEBUG_LOG :: #force_inline proc "contextless" (args : ..[]any) //TODO @gen: Validate the parameters were not passed by reference.
{
	_ = args
}

} // preproc endif

//-----------------------------------------------------------------------------
// IM_MALLOC(), IM_FREE(), IM_NEW(), IM_PLACEMENT_NEW(), IM_DELETE()
// We call C++ constructor on own allocated memory via the placement "new(ptr) Type()" syntax.
// Defining a custom placement new() with a custom parameter allows us to bypass including <new> which on some platforms complains when user has disabled exceptions.
//-----------------------------------------------------------------------------

ImNewWrapper :: struct { }
// This is only required so we can use the symmetrical new()
IM_ALLOC :: #force_inline proc "contextless" (_SIZE : $T0) -> rawptr //TODO @gen: Validate the parameters were not passed by reference.
{
	return ImGui_MemAlloc(_SIZE)
}

IM_FREE :: #force_inline proc "contextless" (_PTR : ^$T0) //TODO @gen: Validate the parameters were not passed by reference.
{
	ImGui_MemFree(_PTR)
}

IM_PLACEMENT_NEW :: #force_inline proc "contextless" (_PTR : ^$T0) //TODO @gen: Validate the parameters were not passed by reference.
{
	init(_PTR)
}

IM_NEW :: #force_inline proc "contextless" ($_TYPE : typeid) //TODO @gen: Validate the parameters were not passed by reference.
{
	ptr := ImGui_MemAlloc(size_of(_TYPE))
	init(transmute(^_TYPE) ptr)
}

IM_DELETE :: proc(p : ^$T) { if p != nil { deinit(p); MemFree(p) } }

//-----------------------------------------------------------------------------
// ImVector<>
// Lightweight std::vector<>-like class to avoid dragging dependencies (also, some implementations of STL with debug enabled are absurdly slow, we bypass it so our code runs fast in debug).
//-----------------------------------------------------------------------------
// - You generally do NOT need to care or use this ever. But we need to make it available in imgui.h because some of our public structures are relying on it.
// - We use std-like naming convention here, which is a little unusual for this codebase.
// - Important: clear() frees memory, resize(0) keep the allocated buffer. We use resize(0) a lot to intentionally recycle allocated buffers across frames and amortize our costs.
// - Important: our implementation does NOT call C++ constructors/destructors, we treat everything as raw data! This is intentional but be extra mindful of that,
//   Do NOT use this class as a std::vector replacement in your own code! Many of the structures used by dear imgui can be safely initialized by a zero-memset.
//-----------------------------------------------------------------------------


ImVector :: struct($T : typeid) {
	Size : i32,
	Capacity : i32,
	Data : ^T,

	// Provide standard typedefs but we don't use them ourselves.




}

ImVector_deinit :: proc(this : ^ImVector)
{if this.Data { IM_FREE(this.Data) }}

// Constructors, destructor
ImVector_init_0 :: #force_inline proc(this : ^ImVector($T))
{
	this.Capacity = 0; this.Size = this.Capacity; this.Data = nil
}

// Constructors, destructor
ImVector_init_1 :: #force_inline proc(this : ^ImVector($T), src : ^ImVector(T))
{
	this.Capacity = 0; this.Size = this.Capacity; this.Data = nil; operator_Assign(src)
}

// Important: does not destruct anything
ImVector_clear :: #force_inline proc(this : ^ImVector($T)) { if this.Data {this.Capacity = 0; this.Size = this.Capacity; IM_FREE(this.Data); this.Data = nil
} }

// Important: never called automatically! always explicit.
ImVector_clear_delete :: #force_inline proc(this : ^ImVector($T))
{
	for n : i32 = 0; n < this.Size; post_incr(&n) { IM_DELETE(this.Data[n]) }; clear()
}

// Important: never called automatically! always explicit.
ImVector_clear_destruct :: #force_inline proc(this : ^ImVector($T))
{
	for n : i32 = 0; n < this.Size; post_incr(&n) { deinit(&this.Data[n]) }; clear()
}

ImVector_empty :: #force_inline proc(this : ^ImVector($T)) -> bool { return this.Size == 0 }

ImVector_size :: #force_inline proc(this : ^ImVector($T)) -> i32 { return this.Size }

ImVector_size_in_bytes :: #force_inline proc(this : ^ImVector($T)) -> i32 { return this.Size * cast(i32) size_of(T) }

ImVector_max_size :: #force_inline proc(this : ^ImVector($T)) -> i32 { return 0x7FFFFFFF / cast(i32) size_of(T) }

ImVector_capacity :: #force_inline proc(this : ^ImVector($T)) -> i32 { return this.Capacity }

ImVector_front_0 :: #force_inline proc(this : ^ImVector($T)) -> ^T
{
	IM_ASSERT(this.Size > 0); return this.Data[0]
}

ImVector_front_1 :: #force_inline proc(this : ^ImVector($T)) -> ^T
{
	IM_ASSERT(this.Size > 0); return this.Data[0]
}

ImVector_back_0 :: #force_inline proc(this : ^ImVector($T)) -> ^T
{
	IM_ASSERT(this.Size > 0); return this.Data[this.Size - 1]
}

ImVector_back_1 :: #force_inline proc(this : ^ImVector($T)) -> ^T
{
	IM_ASSERT(this.Size > 0); return this.Data[this.Size - 1]
}

ImVector_swap :: #force_inline proc(this : ^ImVector($T), rhs : ^ImVector(T))
{
	rhs_size : i32 = rhs.Size; rhs.Size = this.Size; this.Size = rhs_size; rhs_cap : i32 = rhs.Capacity; rhs.Capacity = this.Capacity; this.Capacity = rhs_cap; rhs_data : ^T = rhs.Data; rhs.Data = this.Data; this.Data = rhs_data
}

ImVector__grow_capacity :: #force_inline proc(this : ^ImVector($T), sz : i32) -> i32
{
	new_capacity : i32 = this.Capacity ? (this.Capacity + this.Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz
}

ImVector_resize_0 :: #force_inline proc(this : ^ImVector($T), new_size : i32)
{
	if new_size > this.Capacity { reserve(_grow_capacity(new_size)) }; this.Size = new_size
}

ImVector_resize_1 :: #force_inline proc(this : ^ImVector($T), new_size : i32, v : ^T)
{
	if new_size > this.Capacity { reserve(_grow_capacity(new_size)) }; if new_size > this.Size { for n : i32 = this.Size; n < new_size; post_incr(&n) { memcpy(&this.Data[n], &v, size_of(v)) } }; this.Size = new_size
}

// Resize a vector to a smaller size, guaranteed not to cause a reallocation
ImVector_shrink :: #force_inline proc(this : ^ImVector($T), new_size : i32)
{
	IM_ASSERT(new_size <= this.Size); this.Size = new_size
}

ImVector_reserve :: #force_inline proc(this : ^ImVector($T), new_capacity : i32)
{
	if new_capacity <= this.Capacity { return }; new_data : ^T = cast(^T) IM_ALLOC(cast(uint) new_capacity * size_of(T)); if this.Data {memcpy(new_data, this.Data, cast(uint) this.Size * size_of(T)); IM_FREE(this.Data)
	}; this.Data = new_data; this.Capacity = new_capacity
}

ImVector_reserve_discard :: #force_inline proc(this : ^ImVector($T), new_capacity : i32)
{
	if new_capacity <= this.Capacity { return }; if this.Data { IM_FREE(this.Data) }; this.Data = cast(^T) IM_ALLOC(cast(uint) new_capacity * size_of(T)); this.Capacity = new_capacity
}

// NB: It is illegal to call push_back/push_front/insert with a reference pointing inside the ImVector data itself! e.g. v.push_back(v[10]) is forbidden.
ImVector_push_back :: #force_inline proc(this : ^ImVector($T), v : ^T)
{
	if this.Size == this.Capacity { reserve(_grow_capacity(this.Size + 1)) }; memcpy(&this.Data[this.Size], &v, size_of(v)); post_incr(&this.Size)
}

ImVector_pop_back :: #force_inline proc(this : ^ImVector($T))
{
	IM_ASSERT(this.Size > 0); post_decr(&this.Size)
}

ImVector_push_front :: #force_inline proc(this : ^ImVector($T), v : ^T) { if this.Size == 0 { push_back(v) }
else { insert(this.Data, v) } }

ImVector_erase_0 :: #force_inline proc(this : ^ImVector($T), it : ^T) -> ^T
{
	IM_ASSERT(it >= this.Data && it < this.Data + this.Size); off : int = it - this.Data; memmove(this.Data + off, this.Data + off + 1, (cast(uint) this.Size - cast(uint) off - 1) * size_of(T)); post_decr(&this.Size); return this.Data + off
}

ImVector_erase_1 :: #force_inline proc(this : ^ImVector($T), it : ^T, it_last : ^T) -> ^T
{
	IM_ASSERT(it >= this.Data && it < this.Data + this.Size && it_last >= it && it_last <= this.Data + this.Size); count : int = it_last - it; off : int = it - this.Data; memmove(this.Data + off, this.Data + off + count, (cast(uint) this.Size - cast(uint) off - cast(uint) count) * size_of(T)); this.Size -= cast(i32) count; return this.Data + off
}

ImVector_erase_unsorted :: #force_inline proc(this : ^ImVector($T), it : ^T) -> ^T
{
	IM_ASSERT(it >= this.Data && it < this.Data + this.Size); off : int = it - this.Data; if it < this.Data + this.Size - 1 { memcpy(this.Data + off, this.Data + this.Size - 1, size_of(T)) }; post_decr(&this.Size); return this.Data + off
}

ImVector_insert :: #force_inline proc(this : ^ImVector($T), it : ^T, v : ^T) -> ^T
{
	IM_ASSERT(it >= this.Data && it <= this.Data + this.Size); off : int = it - this.Data; if this.Size == this.Capacity { reserve(_grow_capacity(this.Size + 1)) }; if off < cast(i32) this.Size { memmove(this.Data + off + 1, this.Data + off, (cast(uint) this.Size - cast(uint) off) * size_of(T)) }; memcpy(&this.Data[off], &v, size_of(v)); post_incr(&this.Size); return this.Data + off
}

ImVector_contains :: #force_inline proc(this : ^ImVector($T), v : ^T) -> bool
{
	data : ^T = this.Data; data_end : ^T = this.Data + this.Size; for data < data_end { if post_incr(&data)^ == v { return true } }; return false
}

ImVector_find_0 :: #force_inline proc(this : ^ImVector($T), v : ^T) -> ^T
{
	data : ^T = this.Data; data_end : ^T = this.Data + this.Size; for data < data_end { if data^ == v { break }
else { pre_incr(&data) } }; return data
}

ImVector_find_1 :: #force_inline proc(this : ^ImVector($T), v : ^T) -> ^T
{
	data : ^T = this.Data; data_end : ^T = this.Data + this.Size; for data < data_end { if data^ == v { break }
else { pre_incr(&data) } }; return data
}

ImVector_find_index :: #force_inline proc(this : ^ImVector($T), v : ^T) -> i32
{
	data_end : ^T = this.Data + this.Size; it : ^T = find(v); if it == data_end { return -1 }; off : int = it - this.Data; return cast(i32) off
}

ImVector_find_erase :: #force_inline proc(this : ^ImVector($T), v : ^T) -> bool
{
	it : ^T = find(v); if it < this.Data + this.Size {erase(it); return true
	}; return false
}

ImVector_find_erase_unsorted :: #force_inline proc(this : ^ImVector($T), v : ^T) -> bool
{
	it : ^T = find(v); if it < this.Data + this.Size {erase_unsorted(it); return true
	}; return false
}

ImVector_index_from_ptr :: #force_inline proc(this : ^ImVector($T), it : ^T) -> i32
{
	IM_ASSERT(it >= this.Data && it < this.Data + this.Size); off : int = it - this.Data; return cast(i32) off
}


// Helper for key->value storage (pair)
//-----------------------------------------------------------------------------
// [SECTION] ImGuiStyle
//-----------------------------------------------------------------------------
// You may modify the ImGui::GetStyle() main instance during initialization and before NewFrame().
// During the frame, use ImGui::PushStyleVar(ImGuiStyleVar_XXXX)/PopStyleVar() to alter the main style values,
// and ImGui::PushStyleColor(ImGuiCol_XXX)/PopStyleColor() for colors.
//-----------------------------------------------------------------------------

ImGuiStyle :: struct {
	Alpha : f32, // Global alpha applies to everything in Dear ImGui.
	DisabledAlpha : f32, // Additional alpha multiplier applied by BeginDisabled(). Multiply over current value of Alpha.
	WindowPadding : ImVec2, // Padding within a window.
	WindowRounding : f32, // Radius of window corners rounding. Set to 0.0f to have rectangular windows. Large values tend to lead to variety of artifacts and are not recommended.
	WindowBorderSize : f32, // Thickness of border around windows. Generally set to 0.0f or 1.0f. (Other values are not well tested and more CPU/GPU costly).
	WindowMinSize : ImVec2, // Minimum window size. This is a global setting. If you want to constrain individual windows, use SetNextWindowSizeConstraints().
	WindowTitleAlign : ImVec2, // Alignment for title bar text. Defaults to (0.0f,0.5f) for left-aligned,vertically centered.
	WindowMenuButtonPosition : ImGuiDir, // Side of the collapsing/docking button in the title bar (None/Left/Right). Defaults to ImGuiDir_Left.
	ChildRounding : f32, // Radius of child window corners rounding. Set to 0.0f to have rectangular windows.
	ChildBorderSize : f32, // Thickness of border around child windows. Generally set to 0.0f or 1.0f. (Other values are not well tested and more CPU/GPU costly).
	PopupRounding : f32, // Radius of popup window corners rounding. (Note that tooltip windows use WindowRounding)
	PopupBorderSize : f32, // Thickness of border around popup/tooltip windows. Generally set to 0.0f or 1.0f. (Other values are not well tested and more CPU/GPU costly).
	FramePadding : ImVec2, // Padding within a framed rectangle (used by most widgets).
	FrameRounding : f32, // Radius of frame corners rounding. Set to 0.0f to have rectangular frame (used by most widgets).
	FrameBorderSize : f32, // Thickness of border around frames. Generally set to 0.0f or 1.0f. (Other values are not well tested and more CPU/GPU costly).
	ItemSpacing : ImVec2, // Horizontal and vertical spacing between widgets/lines.
	ItemInnerSpacing : ImVec2, // Horizontal and vertical spacing between within elements of a composed widget (e.g. a slider and its label).
	CellPadding : ImVec2, // Padding within a table cell. Cellpadding.x is locked for entire table. CellPadding.y may be altered between different rows.
	TouchExtraPadding : ImVec2, // Expand reactive bounding box for touch-based system where touch position is not accurate enough. Unfortunately we don't sort widgets so priority on overlap will always be given to the first widget. So don't grow this too much!
	IndentSpacing : f32, // Horizontal indentation when e.g. entering a tree node. Generally == (FontSize + FramePadding.x*2).
	ColumnsMinSpacing : f32, // Minimum horizontal spacing between two columns. Preferably > (FramePadding.x + 1).
	ScrollbarSize : f32, // Width of the vertical scrollbar, Height of the horizontal scrollbar.
	ScrollbarRounding : f32, // Radius of grab corners for scrollbar.
	GrabMinSize : f32, // Minimum width/height of a grab box for slider/scrollbar.
	GrabRounding : f32, // Radius of grabs corners rounding. Set to 0.0f to have rectangular slider grabs.
	LogSliderDeadzone : f32, // The size in pixels of the dead-zone around zero on logarithmic sliders that cross zero.
	TabRounding : f32, // Radius of upper corners of a tab. Set to 0.0f to have rectangular tabs.
	TabBorderSize : f32, // Thickness of border around tabs.
	TabMinWidthForCloseButton : f32, // Minimum width for close button to appear on an unselected tab when hovered. Set to 0.0f to always show when hovering, set to FLT_MAX to never show close button unless selected.
	TabBarBorderSize : f32, // Thickness of tab-bar separator, which takes on the tab active color to denote focus.
	TabBarOverlineSize : f32, // Thickness of tab-bar overline, which highlights the selected tab-bar.
	TableAngledHeadersAngle : f32, // Angle of angled headers (supported values range from -50.0f degrees to +50.0f degrees).
	TableAngledHeadersTextAlign : ImVec2, // Alignment of angled headers within the cell
	ColorButtonPosition : ImGuiDir, // Side of the color button in the ColorEdit4 widget (left/right). Defaults to ImGuiDir_Right.
	ButtonTextAlign : ImVec2, // Alignment of button text when button is larger than text. Defaults to (0.5f, 0.5f) (centered).
	SelectableTextAlign : ImVec2, // Alignment of selectable text. Defaults to (0.0f, 0.0f) (top-left aligned). It's generally important to keep this left-aligned if you want to lay multiple items on a same line.
	SeparatorTextBorderSize : f32, // Thickness of border in SeparatorText()
	SeparatorTextAlign : ImVec2, // Alignment of text within the separator. Defaults to (0.0f, 0.5f) (left aligned, center).
	SeparatorTextPadding : ImVec2, // Horizontal offset of text from each edge of the separator + spacing on other axis. Generally small values. .y is recommended to be == FramePadding.y.
	DisplayWindowPadding : ImVec2, // Apply to regular windows: amount which we enforce to keep visible when moving near edges of your screen.
	DisplaySafeAreaPadding : ImVec2, // Apply to every windows, menus, popups, tooltips: amount where we avoid displaying contents. Adjust if you cannot see the edges of your screen (e.g. on a TV where scaling has not been configured).
	DockingSeparatorSize : f32, // Thickness of resizing border between docked windows
	MouseCursorScale : f32, // Scale software rendered mouse cursor (when io.MouseDrawCursor is enabled). We apply per-monitor DPI scaling over this scale. May be removed later.
	AntiAliasedLines : bool, // Enable anti-aliased lines/borders. Disable if you are really tight on CPU/GPU. Latched at the beginning of the frame (copied to ImDrawList).
	AntiAliasedLinesUseTex : bool, // Enable anti-aliased lines/borders using textures where possible. Require backend to render with bilinear filtering (NOT point/nearest filtering). Latched at the beginning of the frame (copied to ImDrawList).
	AntiAliasedFill : bool, // Enable anti-aliased edges around filled shapes (rounded rectangles, circles, etc.). Disable if you are really tight on CPU/GPU. Latched at the beginning of the frame (copied to ImDrawList).
	CurveTessellationTol : f32, // Tessellation tolerance when using PathBezierCurveTo() without a specific number of segments. Decrease for highly tessellated curves (higher quality, more polygons), increase to reduce quality.
	CircleTessellationMaxError : f32, // Maximum error (in pixels) allowed when using AddCircle()/AddCircleFilled() or drawing rounded corner rectangles with no explicit segment count specified. Decrease for higher quality but more geometry.
	Colors : [ImGuiCol_.ImGuiCol_COUNT]ImVec4,

	// Behaviors
	// (It is possible to modify those fields mid-frame if specific behavior need it, unlike e.g. configuration fields in ImGuiIO)
	HoverStationaryDelay : f32, // Delay for IsItemHovered(ImGuiHoveredFlags_Stationary). Time required to consider mouse stationary.
	HoverDelayShort : f32, // Delay for IsItemHovered(ImGuiHoveredFlags_DelayShort). Usually used along with HoverStationaryDelay.
	HoverDelayNormal : f32, // Delay for IsItemHovered(ImGuiHoveredFlags_DelayNormal). "
	HoverFlagsForTooltipMouse : ImGuiHoveredFlags, // Default flags when using IsItemHovered(ImGuiHoveredFlags_ForTooltip) or BeginItemTooltip()/SetItemTooltip() while using mouse.
	HoverFlagsForTooltipNav : ImGuiHoveredFlags, }

// Shared state of InputText() when using custom ImGuiInputTextCallback (rare/advanced use)
//-----------------------------------------------------------------------------
// [SECTION] ImGuiIO
//-----------------------------------------------------------------------------
// Communicate most settings and inputs/outputs to Dear ImGui using this structure.
// Access via ImGui::GetIO(). Read 'Programmer guide' section in .cpp file for general usage.
// It is generally expected that:
// - initialization: backends and user code writes to ImGuiIO.
// - main loop: backends writes to ImGuiIO, user code and imgui code reads from ImGuiIO.
//-----------------------------------------------------------------------------
// Also see ImGui::GetPlatformIO() and ImGuiPlatformIO struct for OS/platform related functions: clipboard, IME etc.
//-----------------------------------------------------------------------------

// [Internal] Storage used by IsKeyDown(), IsKeyPressed() etc functions.
// If prior to 1.87 you used io.KeysDownDuration[] (which was marked as internal), you should use GetKeyData(key)->DownDuration and *NOT* io.KeysData[key]->DownDuration.
ImGuiKeyData :: struct {
	Down : bool, // True for if key is down
	DownDuration : f32, // Duration the key has been down (<0.0f: not pressed, 0.0f: just pressed, >0.0f: time held)
	DownDurationPrev : f32, // Last frame duration the key has been down
	AnalogValue : f32, // 0.0f..1.0f for gamepad values
}

// Dear ImGui context (opaque structure, unless including imgui_internal.h)
ImGuiIO :: struct {
	//------------------------------------------------------------------
	// Configuration                            // Default value
	//------------------------------------------------------------------

	ConfigFlags : ImGuiConfigFlags, // = 0              // See ImGuiConfigFlags_ enum. Set by user/application. Keyboard/Gamepad navigation options, etc.
	BackendFlags : ImGuiBackendFlags, // = 0              // See ImGuiBackendFlags_ enum. Set by backend (imgui_impl_xxx files or custom backend) to communicate features supported by the backend.
	DisplaySize : ImVec2, // <unset>          // Main display size, in pixels (generally == GetMainViewport()->Size). May change every frame.
	DeltaTime : f32, // = 1.0f/60.0f     // Time elapsed since last frame, in seconds. May change every frame.
	IniSavingRate : f32, // = 5.0f           // Minimum time between saving positions/sizes to .ini file, in seconds.
	IniFilename : ^u8, // = "imgui.ini"    // Path to .ini file (important: default "imgui.ini" is relative to current working dir!). Set NULL to disable automatic .ini loading/saving or if you want to manually call LoadIniSettingsXXX() / SaveIniSettingsXXX() functions.
	LogFilename : ^u8, // = "imgui_log.txt"// Path to .log file (default parameter to ImGui::LogToFile when no file is specified).
	UserData : rawptr, // = NULL           // Store your own data.

	// Font system
	Fonts : ^ImFontAtlas, // <auto>           // Font atlas: load, rasterize and pack one or more fonts into a single texture.
	FontGlobalScale : f32, // = 1.0f           // Global scale all fonts
	FontAllowUserScaling : bool, // = false          // [OBSOLETE] Allow user scaling text of individual window with CTRL+Wheel.
	FontDefault : ^ImFont, // = NULL           // Font to use on NewFrame(). Use NULL to uses Fonts->Fonts[0].
	DisplayFramebufferScale : ImVec2, // = (1, 1)         // For retina display or other situations where window coordinates are different from framebuffer coordinates. This generally ends up in ImDrawData::FramebufferScale.

	// Keyboard/Gamepad Navigation options
	ConfigNavSwapGamepadButtons : bool, // = false          // Swap Activate<>Cancel (A<>B) buttons, matching typical "Nintendo/Japanese style" gamepad layout.
	ConfigNavMoveSetMousePos : bool, // = false          // Directional/tabbing navigation teleports the mouse cursor. May be useful on TV/console systems where moving a virtual mouse is difficult. Will update io.MousePos and set io.WantSetMousePos=true.
	ConfigNavCaptureKeyboard : bool, // = true           // Sets io.WantCaptureKeyboard when io.NavActive is set.
	ConfigNavEscapeClearFocusItem : bool, // = true           // Pressing Escape can clear focused item + navigation id/highlight. Set to false if you want to always keep highlight on.
	ConfigNavEscapeClearFocusWindow : bool, // = false          // Pressing Escape can clear focused window as well (super set of io.ConfigNavEscapeClearFocusItem).
	ConfigNavCursorVisibleAuto : bool, // = true           // Using directional navigation key makes the cursor visible. Mouse click hides the cursor.
	ConfigNavCursorVisibleAlways : bool, // = false          // Navigation cursor is always visible.

	// Docking options (when ImGuiConfigFlags_DockingEnable is set)
	ConfigDockingNoSplit : bool, // = false          // Simplified docking mode: disable window splitting, so docking is limited to merging multiple windows together into tab-bars.
	ConfigDockingWithShift : bool, // = false          // Enable docking with holding Shift key (reduce visual noise, allows dropping in wider space)
	ConfigDockingAlwaysTabBar : bool, // = false          // [BETA] [FIXME: This currently creates regression with auto-sizing and general overhead] Make every single floating window display within a docking node.
	ConfigDockingTransparentPayload : bool, // = false          // [BETA] Make window or viewport transparent when docking and only display docking boxes on the target viewport. Useful if rendering of multiple viewport cannot be synced. Best used with ConfigViewportsNoAutoMerge.

	// Viewport options (when ImGuiConfigFlags_ViewportsEnable is set)
	ConfigViewportsNoAutoMerge : bool, // = false;         // Set to make all floating imgui windows always create their own viewport. Otherwise, they are merged into the main host viewports when overlapping it. May also set ImGuiViewportFlags_NoAutoMerge on individual viewport.
	ConfigViewportsNoTaskBarIcon : bool, // = false          // Disable default OS task bar icon flag for secondary viewports. When a viewport doesn't want a task bar icon, ImGuiViewportFlags_NoTaskBarIcon will be set on it.
	ConfigViewportsNoDecoration : bool, // = true           // Disable default OS window decoration flag for secondary viewports. When a viewport doesn't want window decorations, ImGuiViewportFlags_NoDecoration will be set on it. Enabling decoration can create subsequent issues at OS levels (e.g. minimum window size).
	ConfigViewportsNoDefaultParent : bool, // = false          // Disable default OS parenting to main viewport for secondary viewports. By default, viewports are marked with ParentViewportId = <main_viewport>, expecting the platform backend to setup a parent/child relationship between the OS windows (some backend may ignore this). Set to true if you want the default to be 0, then all viewports will be top-level OS windows.

	// Miscellaneous options
	// (you can visualize and interact with all options in 'Demo->Configuration')
	MouseDrawCursor : bool, // = false          // Request ImGui to draw a mouse cursor for you (if you are on a platform without a mouse cursor). Cannot be easily renamed to 'io.ConfigXXX' because this is frequently used by backend implementations.
	ConfigMacOSXBehaviors : bool, // = defined(__APPLE__) // Swap Cmd<>Ctrl keys + OS X style text editing cursor movement using Alt instead of Ctrl, Shortcuts using Cmd/Super instead of Ctrl, Line/Text Start and End using Cmd+Arrows instead of Home/End, Double click selects by word instead of selecting whole text, Multi-selection in lists uses Cmd/Super instead of Ctrl.
	ConfigInputTrickleEventQueue : bool, // = true           // Enable input queue trickling: some types of events submitted during the same frame (e.g. button down + up) will be spread over multiple frames, improving interactions with low framerates.
	ConfigInputTextCursorBlink : bool, // = true           // Enable blinking cursor (optional as some users consider it to be distracting).
	ConfigInputTextEnterKeepActive : bool, // = false          // [BETA] Pressing Enter will keep item active and select contents (single-line only).
	ConfigDragClickToInputText : bool, // = false          // [BETA] Enable turning DragXXX widgets into text input with a simple mouse click-release (without moving). Not desirable on devices without a keyboard.
	ConfigWindowsResizeFromEdges : bool, // = true           // Enable resizing of windows from their edges and from the lower-left corner. This requires ImGuiBackendFlags_HasMouseCursors for better mouse cursor feedback. (This used to be a per-window ImGuiWindowFlags_ResizeFromAnySide flag)
	ConfigWindowsMoveFromTitleBarOnly : bool, // = false      // Enable allowing to move windows only when clicking on their title bar. Does not apply to windows without a title bar.
	ConfigWindowsCopyContentsWithCtrlC : bool, // = false      // [EXPERIMENTAL] CTRL+C copy the contents of focused window into the clipboard. Experimental because: (1) has known issues with nested Begin/End pairs (2) text output quality varies (3) text output is in submission order rather than spatial order.
	ConfigScrollbarScrollByPage : bool, // = true           // Enable scrolling page by page when clicking outside the scrollbar grab. When disabled, always scroll to clicked location. When enabled, Shift+Click scrolls to clicked location.
	ConfigMemoryCompactTimer : f32, // = 60.0f          // Timer (in seconds) to free transient windows/tables memory buffers when unused. Set to -1.0f to disable.

	// Inputs Behaviors
	// (other variables, ones which are expected to be tweaked within UI code, are exposed in ImGuiStyle)
	MouseDoubleClickTime : f32, // = 0.30f          // Time for a double-click, in seconds.
	MouseDoubleClickMaxDist : f32, // = 6.0f           // Distance threshold to stay in to validate a double-click, in pixels.
	MouseDragThreshold : f32, // = 6.0f           // Distance threshold before considering we are dragging.
	KeyRepeatDelay : f32, // = 0.275f         // When holding a key/button, time before it starts repeating, in seconds (for buttons in Repeat mode, etc.).
	KeyRepeatRate : f32, // = 0.050f         // When holding a key/button, rate at which it repeats, in seconds.

	//------------------------------------------------------------------
	// Debug options
	//------------------------------------------------------------------

	// Options to configure Error Handling and how we handle recoverable errors [EXPERIMENTAL]
	// - Error recovery is provided as a way to facilitate:
	//    - Recovery after a programming error (native code or scripting language - the later tends to facilitate iterating on code while running).
	//    - Recovery after running an exception handler or any error processing which may skip code after an error has been detected.
	// - Error recovery is not perfect nor guaranteed! It is a feature to ease development.
	//   You not are not supposed to rely on it in the course of a normal application run.
	// - Functions that support error recovery are using IM_ASSERT_USER_ERROR() instead of IM_ASSERT().
	// - By design, we do NOT allow error recovery to be 100% silent. One of the three options needs to be checked!
	// - Always ensure that on programmers seats you have at minimum Asserts or Tooltips enabled when making direct imgui API calls!
	//   Otherwise it would severely hinder your ability to catch and correct mistakes!
	// Read https://github.com/ocornut/imgui/wiki/Error-Handling for details.
	// - Programmer seats: keep asserts (default), or disable asserts and keep error tooltips (new and nice!)
	// - Non-programmer seats: maybe disable asserts, but make sure errors are resurfaced (tooltips, visible log entries, use callback etc.)
	// - Recovery after error/exception: record stack sizes with ErrorRecoveryStoreState(), disable assert, set log callback (to e.g. trigger high-level breakpoint), recover with ErrorRecoveryTryToRecoverState(), restore settings.
	ConfigErrorRecovery : bool, // = true       // Enable error recovery support. Some errors won't be detected and lead to direct crashes if recovery is disabled.
	ConfigErrorRecoveryEnableAssert : bool, // = true       // Enable asserts on recoverable error. By default call IM_ASSERT() when returning from a failing IM_ASSERT_USER_ERROR()
	ConfigErrorRecoveryEnableDebugLog : bool, // = true       // Enable debug log output on recoverable errors.
	ConfigErrorRecoveryEnableTooltip : bool, // = true       // Enable tooltip on recoverable errors. The tooltip include a way to enable asserts if they were disabled.

	// Option to enable various debug tools showing buttons that will call the IM_DEBUG_BREAK() macro.
	// - The Item Picker tool will be available regardless of this being enabled, in order to maximize its discoverability.
	// - Requires a debugger being attached, otherwise IM_DEBUG_BREAK() options will appear to crash your application.
	//   e.g. io.ConfigDebugIsDebuggerPresent = ::IsDebuggerPresent() on Win32, or refer to ImOsIsDebuggerPresent() imgui_test_engine/imgui_te_utils.cpp for a Unix compatible version).
	ConfigDebugIsDebuggerPresent : bool, // = false          // Enable various tools calling IM_DEBUG_BREAK().

	// Tools to detect code submitting items with conflicting/duplicate IDs
	// - Code should use PushID()/PopID() in loops, or append "##xx" to same-label identifiers.
	// - Empty label e.g. Button("") == same ID as parent widget/node. Use Button("##xx") instead!
	// - See FAQ https://github.com/ocornut/imgui/blob/master/docs/FAQ.md#q-about-the-id-stack-system
	ConfigDebugHighlightIdConflicts : bool, // = true           // Highlight and show an error message when multiple items have conflicting identifiers.

	// Tools to test correct Begin/End and BeginChild/EndChild behaviors.
	// - Presently Begin()/End() and BeginChild()/EndChild() needs to ALWAYS be called in tandem, regardless of return value of BeginXXX()
	// - This is inconsistent with other BeginXXX functions and create confusion for many users.
	// - We expect to update the API eventually. In the meanwhile we provide tools to facilitate checking user-code behavior.
	ConfigDebugBeginReturnValueOnce : bool, // = false          // First-time calls to Begin()/BeginChild() will return false. NEEDS TO BE SET AT APPLICATION BOOT TIME if you don't want to miss windows.
	ConfigDebugBeginReturnValueLoop : bool, // = false          // Some calls to Begin()/BeginChild() will return false. Will cycle through window depths then repeat. Suggested use: add "io.ConfigDebugBeginReturnValue = io.KeyShift" in your main loop then occasionally press SHIFT. Windows should be flickering while running.

	// Option to deactivate io.AddFocusEvent(false) handling.
	// - May facilitate interactions with a debugger when focus loss leads to clearing inputs data.
	// - Backends may have other side-effects on focus loss, so this will reduce side-effects but not necessary remove all of them.
	ConfigDebugIgnoreFocusLoss : bool, // = false          // Ignore io.AddFocusEvent(false), consequently not calling io.ClearInputKeys()/io.ClearInputMouse() in input processing.

	// Option to audit .ini data
	ConfigDebugIniSettings : bool, // = false          // Save .ini data with extra comments (particularly helpful for Docking, but makes saving slower)

	//------------------------------------------------------------------
	// Platform Identifiers
	// (the imgui_impl_xxxx backend files are setting those up for you)
	//------------------------------------------------------------------

	// Nowadays those would be stored in ImGuiPlatformIO but we are leaving them here for legacy reasons.
	// Optional: Platform/Renderer backend name (informational only! will be displayed in About Window) + User data for backend/wrappers to store their own stuff.
	BackendPlatformName : ^u8, // = NULL
	BackendRendererName : ^u8, // = NULL
	BackendPlatformUserData : rawptr, // = NULL           // User data for platform backend
	BackendRendererUserData : rawptr, // = NULL           // User data for renderer backend
	BackendLanguageUserData : rawptr,
	//------------------------------------------------------------------
	// Output - Updated by NewFrame() or EndFrame()/Render()
	// (when reading from the io.WantCaptureMouse, io.WantCaptureKeyboard flags to dispatch your inputs, it is
	//  generally easier and more correct to use their state BEFORE calling NewFrame(). See FAQ for details!)
	//------------------------------------------------------------------

	WantCaptureMouse : bool, // Set when Dear ImGui will use mouse inputs, in this case do not dispatch them to your main game/application (either way, always pass on mouse inputs to imgui). (e.g. unclicked mouse is hovering over an imgui window, widget is active, mouse was clicked over an imgui window, etc.).
	WantCaptureKeyboard : bool, // Set when Dear ImGui will use keyboard inputs, in this case do not dispatch them to your main game/application (either way, always pass keyboard inputs to imgui). (e.g. InputText active, or an imgui window is focused and navigation is enabled, etc.).
	WantTextInput : bool, // Mobile/console: when set, you may display an on-screen keyboard. This is set by Dear ImGui when it wants textual keyboard input to happen (e.g. when a InputText widget is active).
	WantSetMousePos : bool, // MousePos has been altered, backend should reposition mouse on next frame. Rarely used! Set only when io.ConfigNavMoveSetMousePos is enabled.
	WantSaveIniSettings : bool, // When manual .ini load/save is active (io.IniFilename == NULL), this will be set to notify your application that you can call SaveIniSettingsToMemory() and save yourself. Important: clear io.WantSaveIniSettings yourself after saving!
	NavActive : bool, // Keyboard/Gamepad navigation is currently allowed (will handle ImGuiKey_NavXXX events) = a window is focused and it doesn't use the ImGuiWindowFlags_NoNavInputs flag.
	NavVisible : bool, // Keyboard/Gamepad navigation highlight is visible and allowed (will handle ImGuiKey_NavXXX events).
	Framerate : f32, // Estimate of application framerate (rolling average over 60 frames, based on io.DeltaTime), in frame per second. Solely for convenience. Slow applications may not want to use a moving average or may want to reset underlying buffers occasionally.
	MetricsRenderVertices : i32, // Vertices output during last call to Render()
	MetricsRenderIndices : i32, // Indices output during last call to Render() = number of triangles * 3
	MetricsRenderWindows : i32, // Number of visible windows
	MetricsActiveWindows : i32, // Number of active windows
	MouseDelta : ImVec2, // Mouse delta. Note that this is zero if either current or previous position are invalid (-FLT_MAX,-FLT_MAX), so a disappearing/reappearing mouse won't have a huge delta.

	//------------------------------------------------------------------
	// [Internal] Dear ImGui will maintain those fields. Forward compatibility not guaranteed!
	//------------------------------------------------------------------

	Ctx : ^ImGuiContext, // Parent UI context (needs to be set explicitly by parent).

	// Main Input State
	// (this block used to be written by backend, since 1.87 it is best to NOT write to those directly, call the AddXXX functions above instead)
	// (reading from those variables is fair game, as they are extremely unlikely to be moving anywhere)
	MousePos : ImVec2, // Mouse position, in pixels. Set to ImVec2(-FLT_MAX, -FLT_MAX) if mouse is unavailable (on another screen, etc.)
	MouseDown : [5]bool, // Mouse buttons: 0=left, 1=right, 2=middle + extras (ImGuiMouseButton_COUNT == 5). Dear ImGui mostly uses left and right buttons. Other buttons allow us to track if the mouse is being used by your application + available to user as a convenience via IsMouse** API.
	MouseWheel : f32, // Mouse wheel Vertical: 1 unit scrolls about 5 lines text. >0 scrolls Up, <0 scrolls Down. Hold SHIFT to turn vertical scroll into horizontal scroll.
	MouseWheelH : f32, // Mouse wheel Horizontal. >0 scrolls Left, <0 scrolls Right. Most users don't have a mouse with a horizontal wheel, may not be filled by all backends.
	MouseSource : ImGuiMouseSource, // Mouse actual input peripheral (Mouse/TouchScreen/Pen).
	MouseHoveredViewport : ImGuiID, // (Optional) Modify using io.AddMouseViewportEvent(). With multi-viewports: viewport the OS mouse is hovering. If possible _IGNORING_ viewports with the ImGuiViewportFlags_NoInputs flag is much better (few backends can handle that). Set io.BackendFlags |= ImGuiBackendFlags_HasMouseHoveredViewport if you can provide this info. If you don't imgui will infer the value using the rectangles and last focused time of the viewports it knows about (ignoring other OS windows).
	KeyCtrl : bool, // Keyboard modifier down: Control
	KeyShift : bool, // Keyboard modifier down: Shift
	KeyAlt : bool, // Keyboard modifier down: Alt
	KeySuper : bool, // Keyboard modifier down: Cmd/Super/Windows

	// Other state maintained from data above + IO function calls
	KeyMods : ImGuiKeyChord, // Key mods flags (any of ImGuiMod_Ctrl/ImGuiMod_Shift/ImGuiMod_Alt/ImGuiMod_Super flags, same as io.KeyCtrl/KeyShift/KeyAlt/KeySuper but merged into flags. Read-only, updated by NewFrame()
	KeysData : [ImGuiKey.ImGuiKey_NamedKey_COUNT]ImGuiKeyData, // Key state for all known keys. Use IsKeyXXX() functions to access this.
	WantCaptureMouseUnlessPopupClose : bool, // Alternative to WantCaptureMouse: (WantCaptureMouse == true && WantCaptureMouseUnlessPopupClose == false) when a click over void is expected to close a popup.
	MousePosPrev : ImVec2, // Previous mouse position (note that MouseDelta is not necessary == MousePos-MousePosPrev, in case either position is invalid)
	MouseClickedPos : [5]ImVec2, // Position at time of clicking
	MouseClickedTime : [5]f64, // Time of last click (used to figure out double-click)
	MouseClicked : [5]bool, // Mouse button went from !Down to Down (same as MouseClickedCount[x] != 0)
	MouseDoubleClicked : [5]bool, // Has mouse button been double-clicked? (same as MouseClickedCount[x] == 2)
	MouseClickedCount : [5]ImU16, // == 0 (not clicked), == 1 (same as MouseClicked[]), == 2 (double-clicked), == 3 (triple-clicked) etc. when going from !Down to Down
	MouseClickedLastCount : [5]ImU16, // Count successive number of clicks. Stays valid after mouse release. Reset after another click is done.
	MouseReleased : [5]bool, // Mouse button went from Down to !Down
	MouseDownOwned : [5]bool, // Track if button was clicked inside a dear imgui window or over void blocked by a popup. We don't request mouse capture from the application if click started outside ImGui bounds.
	MouseDownOwnedUnlessPopupClose : [5]bool, // Track if button was clicked inside a dear imgui window.
	MouseWheelRequestAxisSwap : bool, // On a non-Mac system, holding SHIFT requests WheelY to perform the equivalent of a WheelX event. On a Mac system this is already enforced by the system.
	MouseCtrlLeftAsRightClick : bool, // (OSX) Set to true when the current click was a ctrl-click that spawned a simulated right click
	MouseDownDuration : [5]f32, // Duration the mouse button has been down (0.0f == just clicked)
	MouseDownDurationPrev : [5]f32, // Previous time the mouse button has been down
	MouseDragMaxDistanceAbs : [5]ImVec2, // Maximum distance, absolute, on each axis, of how much mouse has traveled from the clicking point
	MouseDragMaxDistanceSqr : [5]f32, // Squared maximum distance of how much mouse has traveled from the clicking point (used for moving thresholds)
	PenPressure : f32, // Touch/Pen pressure (0.0f to 1.0f, should be >0.0f only when MouseDown[0] == true). Helper storage currently unused by Dear ImGui.
	AppFocusLost : bool, // Only modify via AddFocusEvent()
	AppAcceptingEvents : bool, // Only modify via SetAppAcceptingEvents()
	InputQueueSurrogate : ImWchar16, // For AddInputCharacterUTF16()
	InputQueueCharacters : ImVector(ImWchar), // Queue of _characters_ input (obtained by platform backend). Fill using AddInputCharacter() helper.
}

// Main configuration and I/O between your application and ImGui (also see: ImGuiPlatformIO)
//-----------------------------------------------------------------------------
// [SECTION] Misc data structures (ImGuiInputTextCallbackData, ImGuiSizeCallbackData, ImGuiPayload)
//-----------------------------------------------------------------------------

// Shared state of InputText(), passed as an argument to your callback when a ImGuiInputTextFlags_Callback* flag is used.
// The callback function should return 0 by default.
// Callbacks (follow a flag name and see comments in ImGuiInputTextFlags_ declarations for more details)
// - ImGuiInputTextFlags_CallbackEdit:        Callback on buffer edit (note that InputText() already returns true on edit, the callback is useful mainly to manipulate the underlying buffer while focus is active)
// - ImGuiInputTextFlags_CallbackAlways:      Callback on each iteration
// - ImGuiInputTextFlags_CallbackCompletion:  Callback on pressing TAB
// - ImGuiInputTextFlags_CallbackHistory:     Callback on pressing Up/Down arrows
// - ImGuiInputTextFlags_CallbackCharFilter:  Callback on character inputs to replace or discard them. Modify 'EventChar' to replace or discard, or return 1 in callback to discard.
// - ImGuiInputTextFlags_CallbackResize:      Callback on buffer capacity changes request (beyond 'buf_size' parameter value), allowing the string to grow.
ImGuiInputTextCallbackData :: struct {
	Ctx : ^ImGuiContext, // Parent UI context
	EventFlag : ImGuiInputTextFlags, // One ImGuiInputTextFlags_Callback*    // Read-only
	Flags : ImGuiInputTextFlags, // What user passed to InputText()      // Read-only
	UserData : rawptr, // What user passed to InputText()      // Read-only

	// Arguments for the different callback events
	// - During Resize callback, Buf will be same as your input buffer.
	// - However, during Completion/History/Always callback, Buf always points to our own internal data (it is not the same as your buffer)! Changes to it will be reflected into your own buffer shortly after the callback.
	// - To modify the text buffer in a callback, prefer using the InsertChars() / DeleteChars() function. InsertChars() will take care of calling the resize callback if necessary.
	// - If you know your edits are not going to resize the underlying buffer allocation, you may modify the contents of 'Buf[]' directly. You need to update 'BufTextLen' accordingly (0 <= BufTextLen < BufSize) and set 'BufDirty'' to true so InputText can update its internal state.
	EventChar : ImWchar, // Character input                      // Read-write   // [CharFilter] Replace character with another one, or set to zero to drop. return 1 is equivalent to setting EventChar=0;
	EventKey : ImGuiKey, // Key pressed (Up/Down/TAB)            // Read-only    // [Completion,History]
	Buf : ^u8, // Text buffer                          // Read-write   // [Resize] Can replace pointer / [Completion,History,Always] Only write to pointed data, don't replace the actual pointer!
	BufTextLen : i32, // Text length (in bytes)               // Read-write   // [Resize,Completion,History,Always] Exclude zero-terminator storage. In C land: == strlen(some_text), in C++ land: string.length()
	BufSize : i32, // Buffer size (in bytes) = capacity+1  // Read-only    // [Resize,Completion,History,Always] Include zero-terminator storage. In C land == ARRAYSIZE(my_char_array), in C++ land: string.capacity()+1
	BufDirty : bool, // Set if you modify Buf/BufTextLen!    // Write        // [Completion,History,Always]
	CursorPos : i32, //                                      // Read-write   // [Completion,History,Always]
	SelectionStart : i32, //                                      // Read-write   // [Completion,History,Always] == to SelectionEnd when no selection)
	SelectionEnd : i32, }

ImGuiInputTextCallbackData_SelectAll :: proc(this : ^ImGuiInputTextCallbackData)
{
	this.SelectionStart = 0; this.SelectionEnd = this.BufTextLen
}

ImGuiInputTextCallbackData_ClearSelection :: proc(this : ^ImGuiInputTextCallbackData) { this.SelectionEnd = this.BufTextLen; this.SelectionStart = this.SelectionEnd }

ImGuiInputTextCallbackData_HasSelection :: proc(this : ^ImGuiInputTextCallbackData) -> bool { return this.SelectionStart != this.SelectionEnd }

// A selection request (stored in ImGuiMultiSelectIO)
// Resizing callback data to apply custom constraint. As enabled by SetNextWindowSizeConstraints(). Callback is called during the next Begin().
// NB: For basic min/max size constraint on each axis you don't need to use the callback! The SetNextWindowSizeConstraints() parameters are enough.
ImGuiSizeCallbackData :: struct {
	UserData : rawptr, // Read-only.   What user passed to SetNextWindowSizeConstraints(). Generally store an integer or float in here (need reinterpret_cast<>).
	Pos : ImVec2, // Read-only.   Window position, for reference.
	CurrentSize : ImVec2, // Read-only.   Current window size.
	DesiredSize : ImVec2, // Read-write.  Desired size, based on user's mouse position. Write to this field to restrain resizing.
}

// A Platform Window (always 1 unless multi-viewport are enabled. One per platform window to output to). In the future may represent Platform Monitor
// [ALPHA] Rarely used / very advanced uses only. Use with SetNextWindowClass() and DockSpace() functions.
// Important: the content of this class is still highly WIP and likely to change and be refactored
// before we stabilize Docking features. Please be mindful if using this.
// Provide hints:
// - To the platform backend via altered viewport flags (enable/disable OS decoration, OS task bar icons, etc.)
// - To the platform backend for OS level parent/child relationships of viewport.
// - To the docking system for various options and filtering.
ImGuiWindowClass :: struct {
	ClassId : ImGuiID, // User data. 0 = Default class (unclassed). Windows of different classes cannot be docked with each others.
	ParentViewportId : ImGuiID, // Hint for the platform backend. -1: use default. 0: request platform backend to not parent the platform. != 0: request platform backend to create a parent<>child relationship between the platform windows. Not conforming backends are free to e.g. parent every viewport to the main viewport or not.
	FocusRouteParentWindowId : ImGuiID, // ID of parent window for shortcut focus route evaluation, e.g. Shortcut() call from Parent Window will succeed when this window is focused.
	ViewportFlagsOverrideSet : ImGuiViewportFlags, // Viewport flags to set when a window of this class owns a viewport. This allows you to enforce OS decoration or task bar icon, override the defaults on a per-window basis.
	ViewportFlagsOverrideClear : ImGuiViewportFlags, // Viewport flags to clear when a window of this class owns a viewport. This allows you to enforce OS decoration or task bar icon, override the defaults on a per-window basis.
	TabItemFlagsOverrideSet : ImGuiTabItemFlags, // [EXPERIMENTAL] TabItem flags to set when a window of this class gets submitted into a dock node tab bar. May use with ImGuiTabItemFlags_Leading or ImGuiTabItemFlags_Trailing.
	DockNodeFlagsOverrideSet : ImGuiDockNodeFlags, // [EXPERIMENTAL] Dock node flags to set when a window of this class is hosted by a dock node (it doesn't have to be selected!)
	DockingAlwaysTabBar : bool, // Set to true to enforce single floating windows of this class always having their own docking node (equivalent of setting the global io.ConfigDockingAlwaysTabBar)
	DockingAllowUnclassed : bool, }

// Set to true to allow windows of this class to be docked/merged with an unclassed window. // FIXME-DOCK: Move to DockNodeFlags override?

ImGuiWindowClass_init :: proc(this : ^ImGuiWindowClass)
{
	memset(this, 0, size_of(this)); this.ParentViewportId = cast(ImGuiID) -1; this.DockingAllowUnclassed = true
}

// Helper for running a block of code not more than once a frame
// Data payload for Drag and Drop operations: AcceptDragDropPayload(), GetDragDropPayload()
ImGuiPayload :: struct {
	// Members
	Data : rawptr, // Data (copied and owned by dear imgui)
	DataSize : i32, // Data size

	// [Internal]
	SourceId : ImGuiID, // Source item id
	SourceParentId : ImGuiID, // Source parent id (if available)
	DataFrameCount : i32, // Data timestamp
	DataType : [32 + 1]u8, // Data type tag (short user-supplied string, 32 characters max)
	Preview : bool, // Set when AcceptDragDropPayload() was called and mouse has been hovering the target item (nb: handle overlapping drag targets)
	Delivery : bool, }

// Set when AcceptDragDropPayload() was called and mouse button is released over the target item.

ImGuiPayload_init :: proc(this : ^ImGuiPayload) { Clear() }

ImGuiPayload_Clear :: proc(this : ^ImGuiPayload)
{
	this.SourceParentId = 0; this.SourceId = this.SourceParentId; this.Data = nil; this.DataSize = 0; memset(this.DataType, 0, size_of(DataType)); this.DataFrameCount = -1; this.Delivery = false; this.Preview = this.Delivery
}

ImGuiPayload_IsDataType :: proc(this : ^ImGuiPayload, type : ^u8) -> bool { return this.DataFrameCount != -1 && strcmp(type, this.DataType) == 0 }

ImGuiPayload_IsPreview :: proc(this : ^ImGuiPayload) -> bool { return this.Preview }

ImGuiPayload_IsDelivery :: proc(this : ^ImGuiPayload) -> bool { return this.Delivery }

//-----------------------------------------------------------------------------
// [SECTION] Helpers (ImGuiOnceUponAFrame, ImGuiTextFilter, ImGuiTextBuffer, ImGuiStorage, ImGuiListClipper, Math Operators, ImColor)
//-----------------------------------------------------------------------------

// Helper: Unicode defines
IM_UNICODE_CODEPOINT_INVALID :: 0xFFFD// Invalid Unicode code point (standard value).
when IMGUI_USE_WCHAR32 { /* @gen ifdef */
IM_UNICODE_CODEPOINT_MAX :: 0x10FFFF// Maximum Unicode code point supported by this build.
} else { // preproc else
IM_UNICODE_CODEPOINT_MAX :: 0xFFFF// Maximum Unicode code point supported by this build.
} // preproc endif

// Structure to interact with a BeginMultiSelect()/EndMultiSelect() block
// Helper: Execute a block of code at maximum once a frame. Convenient if you want to quickly create a UI within deep-nested code that runs multiple times every frame.
// Usage: static ImGuiOnceUponAFrame oaf; if (oaf) ImGui::Text("This will be called only once per frame");
ImGuiOnceUponAFrame :: struct {
	RefFrame : i32,
}

ImGuiOnceUponAFrame_init :: proc(this : ^ImGuiOnceUponAFrame) { this.RefFrame = -1 }

// Helper to hold and append into a text buffer (~string builder)
// Helper: Parse and apply text filters. In format "aaaaa[,bbbb][,ccccc]"
ImGuiTextFilter :: struct {
	InputBuf : [256]u8,
	Filters : ImVector(ImGuiTextFilter_ImGuiTextRange),
	CountGrep : i32,
}

ImGuiTextFilter_Clear :: proc(this : ^ImGuiTextFilter)
{
	this.InputBuf[0] = 0; Build()
}

ImGuiTextFilter_IsActive :: proc(this : ^ImGuiTextFilter) -> bool { return !empty(&this.Filters) }

// [Internal]
ImGuiTextFilter_ImGuiTextRange :: struct {
	b : ^u8,
	e : ^u8,
}

ImGuiTextFilter_ImGuiTextRange_init_0 :: proc(this : ^ImGuiTextFilter_ImGuiTextRange) { this.e = nil; this.b = this.e }

ImGuiTextFilter_ImGuiTextRange_init_1 :: proc(this : ^ImGuiTextFilter_ImGuiTextRange, _b : ^u8, _e : ^u8)
{
	this.b = _b; this.e = _e
}

ImGuiTextFilter_ImGuiTextRange_empty :: proc(this : ^ImGuiTextFilter_ImGuiTextRange) -> bool { return this.b == this.e }

// Sorting specification for one column of a table
// Helper: Growable text buffer for logging/accumulating text
// (this could be called 'ImGuiTextBuilder' / 'ImGuiStringBuilder')
ImGuiTextBuffer :: struct {
	Buf : ImVector(u8),
}

ImGuiTextBuffer_EmptyString : [1]u8

ImGuiTextBuffer_init :: proc(this : ^ImGuiTextBuffer) { }

ImGuiTextBuffer_begin :: proc(this : ^ImGuiTextBuffer) -> ^u8 { return this.Buf.Data ? &front(&this.Buf) : EmptyString }

// Buf is zero-terminated, so end() will point on the zero-terminator
ImGuiTextBuffer_end :: proc(this : ^ImGuiTextBuffer) -> ^u8 { return this.Buf.Data ? &back(&this.Buf) : EmptyString }

ImGuiTextBuffer_size :: proc(this : ^ImGuiTextBuffer) -> i32 { return this.Buf.Size ? this.Buf.Size - 1 : 0 }

ImGuiTextBuffer_empty :: proc(this : ^ImGuiTextBuffer) -> bool { return this.Buf.Size <= 1 }

ImGuiTextBuffer_clear :: proc(this : ^ImGuiTextBuffer) { clear(&this.Buf) }

ImGuiTextBuffer_reserve :: proc(this : ^ImGuiTextBuffer, capacity : i32) { reserve(&this.Buf, capacity) }

ImGuiTextBuffer_c_str :: proc(this : ^ImGuiTextBuffer) -> ^u8 { return this.Buf.Data ? this.Buf.Data : EmptyString }

// Helper for key->value storage (container sorted by key)
// [Internal] Key+Value for ImGuiStorage
ImGuiStoragePair :: struct {
	key : ImGuiID,
	using _0 : struct #raw_union { val_i : i32, val_f : f32, val_p : rawptr, },
}

ImGuiStoragePair_init_0 :: proc(this : ^ImGuiStoragePair, _key : ImGuiID, _val : i32)
{
	this.key = _key; this.val_i = _val
}

ImGuiStoragePair_init_1 :: proc(this : ^ImGuiStoragePair, _key : ImGuiID, _val : f32)
{
	this.key = _key; this.val_f = _val
}

ImGuiStoragePair_init_2 :: proc(this : ^ImGuiStoragePair, _key : ImGuiID, _val : rawptr)
{
	this.key = _key; this.val_p = _val
}

// Callback data when using SetNextWindowSizeConstraints() (rare/advanced use)
// Helper: Key->Value storage
// Typically you don't have to worry about this since a storage is held within each Window.
// We use it to e.g. store collapse state for a tree (Int 0/1)
// This is optimized for efficient lookup (dichotomy into a contiguous buffer) and rare insertion (typically tied to user interactions aka max once a frame)
// You can use it as custom user storage for temporary values. Declare your own storage if, for example:
// - You want to manipulate the open/close state of a particular sub-tree in your interface (tree node uses Int 0/1 to store their state).
// - You want to store custom debug data easily without adding or editing structures in your code (probably not efficient, but convenient)
// Types are NOT stored, so it is up to you to make sure your Key don't collide with different types.
ImGuiStorage :: struct {
	// [Internal]
	Data : ImVector(ImGuiStoragePair),
}

// - Get***() functions find pair, never add/allocate. Pairs are sorted so a query is O(log N)
// - Set***() functions find pair, insertion on demand if missing.
// - Sorted insertion is costly, paid once. A typical frame shouldn't need to insert any new pair.
ImGuiStorage_Clear :: proc(this : ^ImGuiStorage) { clear(&this.Data) }

// Storage for ImGuiIO and IsKeyDown(), IsKeyPressed() etc functions.
// Helper: Manually clip large list of items.
// If you have lots evenly spaced items and you have random access to the list, you can perform coarse
// clipping based on visibility to only submit items that are in view.
// The clipper calculates the range of visible items and advance the cursor to compensate for the non-visible items we have skipped.
// (Dear ImGui already clip items based on their bounds but: it needs to first layout the item to do so, and generally
//  fetching/submitting your own data incurs additional cost. Coarse clipping using ImGuiListClipper allows you to easily
//  scale using lists with tens of thousands of items without a problem)
// Usage:
//   ImGuiListClipper clipper;
//   clipper.Begin(1000);         // We have 1000 elements, evenly spaced.
//   while (clipper.Step())
//       for (int i = clipper.DisplayStart; i < clipper.DisplayEnd; i++)
//           ImGui::Text("line number %d", i);
// Generally what happens is:
// - Clipper lets you process the first element (DisplayStart = 0, DisplayEnd = 1) regardless of it being visible or not.
// - User code submit that one element.
// - Clipper can measure the height of the first element
// - Clipper calculate the actual range of elements to display based on the current clipping rectangle, position the cursor before the first visible element.
// - User code submit visible elements.
// - The clipper also handles various subtleties related to keyboard/gamepad navigation, wrapping etc.
ImGuiListClipper :: struct {
	Ctx : ^ImGuiContext, // Parent UI context
	DisplayStart : i32, // First item to display, updated by each call to Step()
	DisplayEnd : i32, // End of items to display (exclusive)
	ItemsCount : i32, // [Internal] Number of items
	ItemsHeight : f32, // [Internal] Height of item after a first step and item submission can calculate it
	StartPosY : f32, // [Internal] Cursor position at the time of Begin() or after table frozen rows are all processed
	StartSeekOffsetY : f64, // [Internal] Account for frozen rows in a table and initial loss of precision in very large windows.
	TempData : rawptr,
}

// Call IncludeItemByIndex() or IncludeItemsByIndex() *BEFORE* first call to Step() if you need a range of items to not be clipped, regardless of their visibility.
// (Due to alignment / padding of certain items it is possible that an extra item may be included on either end of the display range).
ImGuiListClipper_IncludeItemByIndex :: #force_inline proc(this : ^ImGuiListClipper, item_index : i32) { IncludeItemsByIndex(item_index, item_index + 1) }

// Helpers macros to generate 32-bit encoded colors
// - User can declare their own format by #defining the 5 _SHIFT/_MASK macros in their imconfig file.
// - Any setting other than the default will need custom backend support. The only standard backend that supports anything else than the default is DirectX9.
when IMGUI_USE_BGRA_PACKED_COLOR {
IM_COL32_R_SHIFT :: 16
IM_COL32_G_SHIFT :: 8
IM_COL32_B_SHIFT :: 0
IM_COL32_A_SHIFT :: 24
IM_COL32_A_MASK :: 0xFF000000
} else { // preproc else
IM_COL32_R_SHIFT :: 0
IM_COL32_G_SHIFT :: 8
IM_COL32_B_SHIFT :: 16
IM_COL32_A_SHIFT :: 24
IM_COL32_A_MASK :: 0xFF000000
} // preproc endif
IM_COL32 :: #force_inline proc "contextless" (R : $T0, G : $T1, B : $T2, A : $T3) -> ImU32
{
	return (cast(ImU32)(A) << IM_COL32_A_SHIFT)|(cast(ImU32)(B) << IM_COL32_B_SHIFT)|(cast(ImU32)(G) << IM_COL32_G_SHIFT)|(cast(ImU32)(R) << IM_COL32_R_SHIFT)
}

IM_COL32_WHITE       : ImU32 : (255 << IM_COL32_R_SHIFT)|(255 << IM_COL32_G_SHIFT)|(255 << IM_COL32_B_SHIFT)|(255 << IM_COL32_A_SHIFT) // Opaque white = 0xFFFFFFFF
IM_COL32_BLACK       : ImU32 : (0   << IM_COL32_R_SHIFT)|(0   << IM_COL32_G_SHIFT)|(0   << IM_COL32_B_SHIFT)|(255 << IM_COL32_A_SHIFT) // Opaque black
IM_COL32_BLACK_TRANS : ImU32 : (0   << IM_COL32_R_SHIFT)|(0   << IM_COL32_G_SHIFT)|(0   << IM_COL32_B_SHIFT)|(0   << IM_COL32_A_SHIFT) // Transparent black = 0x00000000

// Helper to build glyph ranges from text/string data
// Helper: ImColor() implicitly converts colors to either ImU32 (packed 4x1 byte) or ImVec4 (4x1 float)
// Prefer using IM_COL32() macros if you want a guaranteed compile-time ImU32 for usage with ImDrawList API.
// **Avoid storing ImColor! Store either u32 of ImVec4. This is not a full-featured color class. MAY OBSOLETE.
// **None of the ImGui API are using ImColor directly but you can use it as a convenience to pass colors in either ImU32 or ImVec4 formats. Explicitly cast to ImU32 or ImVec4 if needed.
ImColor :: struct {
	Value : ImVec4,

}

ImColor_init_0 :: proc(this : ^ImColor) { }

ImColor_init_1 :: proc(this : ^ImColor, r : f32, g : f32, b : f32, a : f32 = 1.0)
{
	init(&this.Value, r, g, b, a)
}

ImColor_init_2 :: proc(this : ^ImColor, col : ^ImVec4)
{
	init(&this.Value, col)
}

ImColor_init_3 :: proc(this : ^ImColor, r : i32, g : i32, b : i32, a : i32 = 255)
{
	init(&this.Value, cast(f32) r * (1.0 / 255.0), cast(f32) g * (1.0 / 255.0), cast(f32) b * (1.0 / 255.0), cast(f32) a * (1.0 / 255.0))
}

ImColor_init_4 :: proc(this : ^ImColor, rgba : ImU32)
{
	init(&this.Value, cast(f32) ((rgba >> IM_COL32_R_SHIFT) & 0xFF) * (1.0 / 255.0), cast(f32) ((rgba >> IM_COL32_G_SHIFT) & 0xFF) * (1.0 / 255.0), cast(f32) ((rgba >> IM_COL32_B_SHIFT) & 0xFF) * (1.0 / 255.0), cast(f32) ((rgba >> IM_COL32_A_SHIFT) & 0xFF) * (1.0 / 255.0))
}

// FIXME-OBSOLETE: May need to obsolete/cleanup those helpers.
ImColor_SetHSV :: #force_inline proc(this : ^ImColor, h : f32, s : f32, v : f32, a : f32 = 1.0)
{
	ColorConvertHSVtoRGB(h, s, v, this.Value.x, this.Value.y, this.Value.z); this.Value.w = a
}

ImColor_HSV :: proc(this : ^ImColor, h : f32, s : f32, v : f32, a : f32 = 1.0) -> ImColor
{
	r : f32; g : f32; b : f32; ColorConvertHSVtoRGB(h, s, v, r, g, b); return ImColor(r, g, b, a)
}

//-----------------------------------------------------------------------------
// [SECTION] Multi-Select API flags and structures (ImGuiMultiSelectFlags, ImGuiSelectionRequestType, ImGuiSelectionRequest, ImGuiMultiSelectIO, ImGuiSelectionBasicStorage)
//-----------------------------------------------------------------------------

// Multi-selection system
// Documentation at: https://github.com/ocornut/imgui/wiki/Multi-Select
// - Refer to 'Demo->Widgets->Selection State & Multi-Select' for demos using this.
// - This system implements standard multi-selection idioms (CTRL+Mouse/Keyboard, SHIFT+Mouse/Keyboard, etc)
//   with support for clipper (skipping non-visible items), box-select and many other details.
// - Selectable(), Checkbox() are supported but custom widgets may use it as well.
// - TreeNode() is technically supported but... using this correctly is more complicated: you need some sort of linear/random access to your tree,
//   which is suited to advanced trees setups also implementing filters and clipper. We will work toward simplifying and demoing it.
// - In the spirit of Dear ImGui design, your code owns actual selection data.
//   This is designed to allow all kinds of selection storage you may use in your application e.g. set/map/hash.
// About ImGuiSelectionBasicStorage:
// - This is an optional helper to store a selection state and apply selection requests.
// - It is used by our demos and provided as a convenience to quickly implement multi-selection.
// Usage:
// - Identify submitted items with SetNextItemSelectionUserData(), most likely using an index into your current data-set.
// - Store and maintain actual selection data using persistent object identifiers.
// - Usage flow:
//     BEGIN - (1) Call BeginMultiSelect() and retrieve the ImGuiMultiSelectIO* result.
//           - (2) Honor request list (SetAll/SetRange requests) by updating your selection data. Same code as Step 6.
//           - (3) [If using clipper] You need to make sure RangeSrcItem is always submitted. Calculate its index and pass to clipper.IncludeItemByIndex(). If storing indices in ImGuiSelectionUserData, a simple clipper.IncludeItemByIndex(ms_io->RangeSrcItem) call will work.
//     LOOP  - (4) Submit your items with SetNextItemSelectionUserData() + Selectable()/TreeNode() calls.
//     END   - (5) Call EndMultiSelect() and retrieve the ImGuiMultiSelectIO* result.
//           - (6) Honor request list (SetAll/SetRange requests) by updating your selection data. Same code as Step 2.
//     If you submit all items (no clipper), Step 2 and 3 are optional and will be handled by each item themselves. It is fine to always honor those steps.
// About ImGuiSelectionUserData:
// - This can store an application-defined identifier (e.g. index or pointer) submitted via SetNextItemSelectionUserData().
// - In return we store them into RangeSrcItem/RangeFirstItem/RangeLastItem and other fields in ImGuiMultiSelectIO.
// - Most applications will store an object INDEX, hence the chosen name and type. Storing an index is natural, because
//   SetRange requests will give you two end-points and you will need to iterate/interpolate between them to update your selection.
// - However it is perfectly possible to store a POINTER or another IDENTIFIER inside ImGuiSelectionUserData.
//   Our system never assume that you identify items by indices, it never attempts to interpolate between two values.
// - If you enable ImGuiMultiSelectFlags_NoRangeSelect then it is guaranteed that you will never have to interpolate
//   between two ImGuiSelectionUserData, which may be a convenient way to use part of the feature with less code work.
// - As most users will want to store an index, for convenience and to reduce confusion we use ImS64 instead of void*,
//   being syntactically easier to downcast. Feel free to reinterpret_cast and store a pointer inside.

// Flags for BeginMultiSelect()
ImGuiMultiSelectFlags_ :: enum i32 {
	ImGuiMultiSelectFlags_None = 0,
	ImGuiMultiSelectFlags_SingleSelect = 1 << 0, // Disable selecting more than one item. This is available to allow single-selection code to share same code/logic if desired. It essentially disables the main purpose of BeginMultiSelect() tho!
	ImGuiMultiSelectFlags_NoSelectAll = 1 << 1, // Disable CTRL+A shortcut to select all.
	ImGuiMultiSelectFlags_NoRangeSelect = 1 << 2, // Disable Shift+selection mouse/keyboard support (useful for unordered 2D selection). With BoxSelect is also ensure contiguous SetRange requests are not combined into one. This allows not handling interpolation in SetRange requests.
	ImGuiMultiSelectFlags_NoAutoSelect = 1 << 3, // Disable selecting items when navigating (useful for e.g. supporting range-select in a list of checkboxes).
	ImGuiMultiSelectFlags_NoAutoClear = 1 << 4, // Disable clearing selection when navigating or selecting another one (generally used with ImGuiMultiSelectFlags_NoAutoSelect. useful for e.g. supporting range-select in a list of checkboxes).
	ImGuiMultiSelectFlags_NoAutoClearOnReselect = 1 << 5, // Disable clearing selection when clicking/selecting an already selected item.
	ImGuiMultiSelectFlags_BoxSelect1d = 1 << 6, // Enable box-selection with same width and same x pos items (e.g. full row Selectable()). Box-selection works better with little bit of spacing between items hit-box in order to be able to aim at empty space.
	ImGuiMultiSelectFlags_BoxSelect2d = 1 << 7, // Enable box-selection with varying width or varying x pos items support (e.g. different width labels, or 2D layout/grid). This is slower: alters clipping logic so that e.g. horizontal movements will update selection of normally clipped items.
	ImGuiMultiSelectFlags_BoxSelectNoScroll = 1 << 8, // Disable scrolling when box-selecting near edges of scope.
	ImGuiMultiSelectFlags_ClearOnEscape = 1 << 9, // Clear selection when pressing Escape while scope is focused.
	ImGuiMultiSelectFlags_ClearOnClickVoid = 1 << 10, // Clear selection when clicking on empty location within scope.
	ImGuiMultiSelectFlags_ScopeWindow = 1 << 11, // Scope for _BoxSelect and _ClearOnClickVoid is whole window (Default). Use if BeginMultiSelect() covers a whole window or used a single time in same window.
	ImGuiMultiSelectFlags_ScopeRect = 1 << 12, // Scope for _BoxSelect and _ClearOnClickVoid is rectangle encompassing BeginMultiSelect()/EndMultiSelect(). Use if BeginMultiSelect() is called multiple times in same window.
	ImGuiMultiSelectFlags_SelectOnClick = 1 << 13, // Apply selection on mouse down when clicking on unselected item. (Default)
	ImGuiMultiSelectFlags_SelectOnClickRelease = 1 << 14, // Apply selection on mouse release when clicking an unselected item. Allow dragging an unselected item without altering selection.
	//ImGuiMultiSelectFlags_RangeSelect2d       = 1 << 15,  // Shift+Selection uses 2d geometry instead of linear sequence, so possible to use Shift+up/down to select vertically in grid. Analogous to what BoxSelect does.
	ImGuiMultiSelectFlags_NavWrapX = 1 << 16, // [Temporary] Enable navigation wrapping on X axis. Provided as a convenience because we don't have a design for the general Nav API for this yet. When the more general feature be public we may obsolete this flag in favor of new one.
}

// Helper to manually clip large list of items
// Main IO structure returned by BeginMultiSelect()/EndMultiSelect().
// This mainly contains a list of selection requests.
// - Use 'Demo->Tools->Debug Log->Selection' to see requests as they happen.
// - Some fields are only useful if your list is dynamic and allows deletion (getting post-deletion focus/state right is shown in the demo)
// - Below: who reads/writes each fields? 'r'=read, 'w'=write, 'ms'=multi-select code, 'app'=application/user code.
ImGuiMultiSelectIO :: struct {
	//------------------------------------------// BeginMultiSelect / EndMultiSelect
	Requests : ImVector(ImGuiSelectionRequest), //  ms:w, app:r     /  ms:w  app:r   // Requests to apply to your selection data.
	RangeSrcItem : ImGuiSelectionUserData, //  ms:w  app:r     /                // (If using clipper) Begin: Source item (often the first selected item) must never be clipped: use clipper.IncludeItemByIndex() to ensure it is submitted.
	NavIdItem : ImGuiSelectionUserData, //  ms:w, app:r     /                // (If using deletion) Last known SetNextItemSelectionUserData() value for NavId (if part of submitted items).
	NavIdSelected : bool, //  ms:w, app:r     /        app:r   // (If using deletion) Last known selection state for NavId (if part of submitted items).
	RangeSrcReset : bool, //        app:w     /  ms:r          // (If using deletion) Set before EndMultiSelect() to reset ResetSrcItem (e.g. if deleted selection).
	ItemsCount : i32, //  ms:w, app:r     /        app:r   // 'int items_count' parameter to BeginMultiSelect() is copied here for convenience, allowing simpler calls to your ApplyRequests handler. Not used internally.
}

// Selection request type
ImGuiSelectionRequestType :: enum i32 {
	ImGuiSelectionRequestType_None = 0,
	ImGuiSelectionRequestType_SetAll, // Request app to clear selection (if Selected==false) or select all items (if Selected==true). We cannot set RangeFirstItem/RangeLastItem as its contents is entirely up to user (not necessarily an index)
	ImGuiSelectionRequestType_SetRange, // Request app to select/unselect [RangeFirstItem..RangeLastItem] items (inclusive) based on value of Selected. Only EndMultiSelect() request this, app code can read after BeginMultiSelect() and it will always be false.
}

//Optional helper to apply multi-selection requests to existing randomly accessible storage.
// Selection request item
ImGuiSelectionRequest :: struct {
	//------------------------------------------// BeginMultiSelect / EndMultiSelect
	Type : ImGuiSelectionRequestType, //  ms:w, app:r     /  ms:w, app:r   // Request type. You'll most often receive 1 Clear + 1 SetRange with a single-item range.
	Selected : bool, //  ms:w, app:r     /  ms:w, app:r   // Parameter for SetAll/SetRange requests (true = select, false = unselect)
	RangeDirection : ImS8, //                  /  ms:w  app:r   // Parameter for SetRange request: +1 when RangeFirstItem comes before RangeLastItem, -1 otherwise. Useful if you want to preserve selection order on a backward Shift+Click.
	RangeFirstItem : ImGuiSelectionUserData, //                  /  ms:w, app:r   // Parameter for SetRange request (this is generally == RangeSrcItem when shift selecting from top to bottom).
	RangeLastItem : ImGuiSelectionUserData, //                  /  ms:w, app:r   // Parameter for SetRange request (this is generally == RangeSrcItem when shift selecting from bottom to top). Inclusive!
}

// Multi-viewport support: user-provided bounds for each connected monitor/display. Used when positioning popups and tooltips to avoid them straddling monitors
// Optional helper to store multi-selection state + apply multi-selection requests.
// - Used by our demos and provided as a convenience to easily implement basic multi-selection.
// - Iterate selection with 'void* it = NULL; ImGuiID id; while (selection.GetNextSelectedItem(&it, &id)) { ... }'
//   Or you can check 'if (Contains(id)) { ... }' for each possible object if their number is not too high to iterate.
// - USING THIS IS NOT MANDATORY. This is only a helper and not a required API.
// To store a multi-selection, in your application you could:
// - Use this helper as a convenience. We use our simple key->value ImGuiStorage as a std::set<ImGuiID> replacement.
// - Use your own external storage: e.g. std::set<MyObjectId>, std::vector<MyObjectId>, interval trees, intrusively stored selection etc.
// In ImGuiSelectionBasicStorage we:
// - always use indices in the multi-selection API (passed to SetNextItemSelectionUserData(), retrieved in ImGuiMultiSelectIO)
// - use the AdapterIndexToStorageId() indirection layer to abstract how persistent selection data is derived from an index.
// - use decently optimized logic to allow queries and insertion of very large selection sets.
// - do not preserve selection order.
// Many combinations are possible depending on how you prefer to store your items and how you prefer to store your selection.
// Large applications are likely to eventually want to get rid of this indirection layer and do their own thing.
// See https://github.com/ocornut/imgui/wiki/Multi-Select for details and pseudo-code using this helper.
ImGuiSelectionBasicStorage :: struct {
	// Members
	Size : i32, //          // Number of selected items, maintained by this helper.
	PreserveOrder : bool, // = false  // GetNextSelectedItem() will return ordered selection (currently implemented by two additional sorts of selection. Could be improved)
	UserData : rawptr, // = NULL   // User data for use by adapter function        // e.g. selection.UserData = (void*)my_items;
	AdapterIndexToStorageId : proc(	_self : ^ImGuiSelectionBasicStorage, 	_idx : i32) -> ImGuiID, // e.g. selection.AdapterIndexToStorageId = [](ImGuiSelectionBasicStorage* self, int idx) { return ((MyItems**)self->UserData)[idx]->ID; };
	_SelectionOrder : i32, // [Internal] Increasing counter to store selection order
	_Storage : ImGuiStorage, }

// Convert index to item id based on provided adapter.
ImGuiSelectionBasicStorage_GetStorageIdFromIndex :: #force_inline proc(this : ^ImGuiSelectionBasicStorage, idx : i32) -> ImGuiID { return AdapterIndexToStorageId(this, idx) }

// Optional helper to store multi-selection state + apply multi-selection requests.
// Optional helper to apply multi-selection requests to existing randomly accessible storage.
// Convenient if you want to quickly wire multi-select API on e.g. an array of bool or items storing their own selection state.
ImGuiSelectionExternalStorage :: struct {
	// Members
	UserData : rawptr, // User data for use by adapter function                                // e.g. selection.UserData = (void*)my_items;
	AdapterSetItemSelected : proc(	_self : ^ImGuiSelectionExternalStorage, 	_idx : i32, 	_selected : bool), }

//-----------------------------------------------------------------------------
// [SECTION] Drawing API (ImDrawCmd, ImDrawIdx, ImDrawVert, ImDrawChannel, ImDrawListSplitter, ImDrawListFlags, ImDrawList, ImDrawData)
// Hold a series of drawing commands. The user provides a renderer for ImDrawData which essentially contains an array of ImDrawList.
//-----------------------------------------------------------------------------

// The maximum line width to bake anti-aliased textures for. Build atlas with ImFontAtlasFlags_NoBakedLines to disable baking.
//when ! defined ( IM_DRAWLIST_TEX_LINES_WIDTH_MAX ) {
IM_DRAWLIST_TEX_LINES_WIDTH_MAX :: (63)
//} // preproc endif

// ImDrawCallback: Draw callbacks for advanced uses [configurable type: override in imconfig.h]
// NB: You most likely do NOT need to use draw callbacks just to create your own widget or customized UI rendering,
// you can poke into the draw list for that! Draw callback may be useful for example to:
//  A) Change your GPU render state,
//  B) render a complex 3D scene inside a UI element without an intermediate texture/render target, etc.
// The expected behavior from your rendering function is 'if (cmd.UserCallback != NULL) { cmd.UserCallback(parent_list, cmd); } else { RenderTriangles() }'
// If you want to override the signature of ImDrawCallback, you can simply use e.g. '#define ImDrawCallback MyDrawCallback' (in imconfig.h) + update rendering backend accordingly.
//when ! defined ( ImDrawCallback ) {
ImDrawCallback :: proc(parent_list : ^ImDrawList, cmd : ^ImDrawCmd)
//} // preproc endif

// Special Draw callback value to request renderer backend to reset the graphics/render state.
// The renderer backend needs to handle this special value, otherwise it will crash trying to call a function at this address.
// This is useful, for example, if you submitted callbacks which you know have altered the render state and you want it to be restored.
// Render state is not reset by default because they are many perfectly useful way of altering render state (e.g. changing shader/blending settings before an Image call).
ImDrawCallback_ResetRenderState :: transmute(ImDrawCallback)transmute(rawptr)transmute(uint)int(-8)

// Temporary storage to output draw commands out of order, used by ImDrawListSplitter and ImDrawList::ChannelsSplit()
// Typically, 1 command = 1 GPU draw call (unless command is a callback)
// - VtxOffset: When 'io.BackendFlags & ImGuiBackendFlags_RendererHasVtxOffset' is enabled,
//   this fields allow us to render meshes larger than 64K vertices while keeping 16-bit indices.
//   Backends made for <1.71. will typically ignore the VtxOffset fields.
// - The ClipRect/TextureId/VtxOffset fields must be contiguous as we memcmp() them together (this is asserted for).
ImDrawCmd :: struct {
	ClipRect : ImVec4, // 4*4  // Clipping rectangle (x1, y1, x2, y2). Subtract ImDrawData->DisplayPos to get clipping rectangle in "viewport" coordinates
	TextureId : ImTextureID, // 4-8  // User-provided texture ID. Set by user in ImfontAtlas::SetTexID() for fonts or passed to Image*() functions. Ignore if never using images or multiple fonts atlas.
	VtxOffset : u32, // 4    // Start offset in vertex buffer. ImGuiBackendFlags_RendererHasVtxOffset: always 0, otherwise may be >0 to support meshes larger than 64K vertices with 16-bit indices.
	IdxOffset : u32, // 4    // Start offset in index buffer.
	ElemCount : u32, // 4    // Number of indices (multiple of 3) to be rendered as triangles. Vertices are stored in the callee ImDrawList's vtx_buffer[] array, indices in idx_buffer[].
	UserCallback : ImDrawCallback, // 4-8  // If != NULL, call the function instead of rendering the vertices. clip_rect and texture_id will be set normally.
	UserCallbackData : rawptr, // 4-8  // Callback user data (when UserCallback != NULL). If called AddCallback() with size == 0, this is a copy of the AddCallback() argument. If called AddCallback() with size > 0, this is pointing to a buffer where data is stored.
	UserCallbackDataSize : i32, // 4 // Size of callback user data when using storage, otherwise 0.
	UserCallbackDataOffset : i32, }

// 4 // [Internal] Offset of callback user data when using storage, otherwise -1.

// Also ensure our padding fields are zeroed
ImDrawCmd_init :: proc(this : ^ImDrawCmd) { memset(this, 0, size_of(this)) }

// Since 1.83: returns ImTextureID associated with this draw call. Warning: DO NOT assume this is always same as 'TextureId' (we will change this function for an upcoming feature)
ImDrawCmd_GetTexID :: #force_inline proc(this : ^ImDrawCmd) -> ImTextureID { return this.TextureId }

// Vertex layout
//when ! defined ( IMGUI_OVERRIDE_DRAWVERT_STRUCT_LAYOUT ) {
// Helper to split a draw list into different layers which can be drawn into out of order, then flattened back.
ImDrawVert :: struct {
	pos : ImVec2,
	uv : ImVec2,
	col : ImU32,
}
//} else { // preproc else
// You can override the vertex format layout by defining IMGUI_OVERRIDE_DRAWVERT_STRUCT_LAYOUT in imconfig.h
// The code expect ImVec2 pos (8 bytes), ImVec2 uv (8 bytes), ImU32 col (4 bytes), but you can re-order them or add other fields as needed to simplify integration in your engine.
// The type has to be described within the macro (you can either declare the struct or use a typedef). This is because ImVec2/ImU32 are likely not declared at the time you'd want to set your type up.
// NOTE: IMGUI DOESN'T CLEAR THE STRUCTURE AND DOESN'T CALL A CONSTRUCTOR SO ANY CUSTOM FIELD WILL BE UNINITIALIZED. IF YOU ADD EXTRA FIELDS (SUCH AS A 'Z' COORDINATES) YOU WILL NEED TO CLEAR THEM DURING RENDER OR TO IGNORE THEM.
//IMGUI_OVERRIDE_DRAWVERT_STRUCT_LAYOUT;
//} // preproc endif

// [Internal] For use by ImDrawList
ImDrawCmdHeader :: struct {
	ClipRect : ImVec4,
	TextureId : ImTextureID,
	VtxOffset : u32,
}

// 64-bit unsigned integer

// Forward declarations
// [Internal] For use by ImDrawListSplitter
ImDrawChannel :: struct {
	_CmdBuffer : ImVector(ImDrawCmd),
	_IdxBuffer : ImVector(ImDrawIdx),
}


// Data shared among multiple draw lists (typically owned by parent ImGui context, but you may create one yourself)
// Split/Merge functions are used to split the draw list into different layers which can be drawn into out of order.
// This is used by the Columns/Tables API, so items of each column can be batched together in a same draw call.
ImDrawListSplitter :: struct {
	_Current : i32, // Current channel number (0)
	_Count : i32, // Number of active channels (1+)
	_Channels : ImVector(ImDrawChannel), }

ImDrawListSplitter_deinit :: proc(this : ^ImDrawListSplitter)
{ClearFreeMemory()}

// Draw channels (not resized down so _Count might be < Channels.Size)

ImDrawListSplitter_init :: #force_inline proc(this : ^ImDrawListSplitter) { memset(this, 0, size_of(this)) }

// Do not clear Channels[] so our allocations are reused next frame
ImDrawListSplitter_Clear :: #force_inline proc(this : ^ImDrawListSplitter)
{
	this._Current = 0; this._Count = 1
}

// Flags for ImDrawList functions
// (Legacy: bit 0 must always correspond to ImDrawFlags_Closed to be backward compatible with old API using a bool. Bits 1..3 must be unused)
ImDrawFlags_ :: enum i32 {
	ImDrawFlags_None = 0,
	ImDrawFlags_Closed = 1 << 0, // PathStroke(), AddPolyline(): specify that shape should be closed (Important: this is always == 1 for legacy reason)
	ImDrawFlags_RoundCornersTopLeft = 1 << 4, // AddRect(), AddRectFilled(), PathRect(): enable rounding top-left corner only (when rounding > 0.0f, we default to all corners). Was 0x01.
	ImDrawFlags_RoundCornersTopRight = 1 << 5, // AddRect(), AddRectFilled(), PathRect(): enable rounding top-right corner only (when rounding > 0.0f, we default to all corners). Was 0x02.
	ImDrawFlags_RoundCornersBottomLeft = 1 << 6, // AddRect(), AddRectFilled(), PathRect(): enable rounding bottom-left corner only (when rounding > 0.0f, we default to all corners). Was 0x04.
	ImDrawFlags_RoundCornersBottomRight = 1 << 7, // AddRect(), AddRectFilled(), PathRect(): enable rounding bottom-right corner only (when rounding > 0.0f, we default to all corners). Wax 0x08.
	ImDrawFlags_RoundCornersNone = 1 << 8, // AddRect(), AddRectFilled(), PathRect(): disable rounding on all corners (when rounding > 0.0f). This is NOT zero, NOT an implicit flag!
	ImDrawFlags_RoundCornersTop = ImDrawFlags_RoundCornersTopLeft | ImDrawFlags_RoundCornersTopRight,
	ImDrawFlags_RoundCornersBottom = ImDrawFlags_RoundCornersBottomLeft | ImDrawFlags_RoundCornersBottomRight,
	ImDrawFlags_RoundCornersLeft = ImDrawFlags_RoundCornersBottomLeft | ImDrawFlags_RoundCornersTopLeft,
	ImDrawFlags_RoundCornersRight = ImDrawFlags_RoundCornersBottomRight | ImDrawFlags_RoundCornersTopRight,
	ImDrawFlags_RoundCornersAll = ImDrawFlags_RoundCornersTopLeft | ImDrawFlags_RoundCornersTopRight | ImDrawFlags_RoundCornersBottomLeft | ImDrawFlags_RoundCornersBottomRight,
	ImDrawFlags_RoundCornersDefault_ = ImDrawFlags_RoundCornersAll, // Default to ALL corners if none of the _RoundCornersXX flags are specified.
	ImDrawFlags_RoundCornersMask_ = ImDrawFlags_RoundCornersAll | ImDrawFlags_RoundCornersNone,
}

// Flags for ImDrawList instance. Those are set automatically by ImGui:: functions from ImGuiIO settings, and generally not manipulated directly.
// It is however possible to temporarily alter flags between calls to ImDrawList:: functions.
ImDrawListFlags_ :: enum i32 {
	ImDrawListFlags_None = 0,
	ImDrawListFlags_AntiAliasedLines = 1 << 0, // Enable anti-aliased lines/borders (*2 the number of triangles for 1.0f wide line or lines thin enough to be drawn using textures, otherwise *3 the number of triangles)
	ImDrawListFlags_AntiAliasedLinesUseTex = 1 << 1, // Enable anti-aliased lines/borders using textures when possible. Require backend to render with bilinear filtering (NOT point/nearest filtering).
	ImDrawListFlags_AntiAliasedFill = 1 << 2, // Enable anti-aliased edge around filled shapes (rounded rectangles, circles).
	ImDrawListFlags_AllowVtxOffset = 1 << 3, // Can emit 'VtxOffset > 0' to allow large meshes. Set when 'ImGuiBackendFlags_RendererHasVtxOffset' is enabled.
}

// All draw command lists required to render the frame + pos/size coordinates to use for the projection matrix.
// Draw command list
// This is the low-level list of polygons that ImGui:: functions are filling. At the end of the frame,
// all command lists are passed to your ImGuiIO::RenderDrawListFn function for rendering.
// Each dear imgui window contains its own ImDrawList. You can use ImGui::GetWindowDrawList() to
// access the current window draw list and draw custom primitives.
// You can interleave normal ImGui:: calls and adding primitives to the current draw list.
// In single viewport mode, top-left is == GetMainViewport()->Pos (generally 0,0), bottom-right is == GetMainViewport()->Pos+Size (generally io.DisplaySize).
// You are totally free to apply whatever transformation matrix you want to the data (depending on the use of the transformation you may want to apply it to ClipRect as well!)
// Important: Primitives are always added to the list and not culled (culling is done at higher-level by ImGui:: functions), if you use this API a lot consider coarse culling your drawn objects.
ImDrawList :: struct {
	// This is what you have to render
	CmdBuffer : ImVector(ImDrawCmd), // Draw commands. Typically 1 command = 1 GPU draw call, unless the command is a callback.
	IdxBuffer : ImVector(ImDrawIdx), // Index buffer. Each command consume ImDrawCmd::ElemCount of those
	VtxBuffer : ImVector(ImDrawVert), // Vertex buffer.
	Flags : ImDrawListFlags, // Flags, you may poke into these to adjust anti-aliasing settings per-primitive.

	// [Internal, used while building lists]
	_VtxCurrentIdx : u32, // [Internal] generally == VtxBuffer.Size unless we are past 64K vertices, in which case this gets reset to 0.
	_Data : ^ImDrawListSharedData, // Pointer to shared draw data (you can use ImGui::GetDrawListSharedData() to get the one from current ImGui context)
	_VtxWritePtr : ^ImDrawVert, // [Internal] point within VtxBuffer.Data after each add command (to avoid using the ImVector<> operators too much)
	_IdxWritePtr : ^ImDrawIdx, // [Internal] point within IdxBuffer.Data after each add command (to avoid using the ImVector<> operators too much)
	_Path : ImVector(ImVec2), // [Internal] current path building
	_CmdHeader : ImDrawCmdHeader, // [Internal] template of active commands. Fields should match those of CmdBuffer.back().
	_Splitter : ImDrawListSplitter, // [Internal] for channels api (note: prefer using your own persistent instance of ImDrawListSplitter!)
	_ClipRectStack : ImVector(ImVec4), // [Internal]
	_TextureIdStack : ImVector(ImTextureID), // [Internal]
	_CallbacksDataBuf : ImVector(ImU8), // [Internal]
	_FringeScale : f32, // [Internal] anti-alias fringe is scaled by this value, this helps to keep things sharp while zooming at vertex buffer content
	_OwnerName : ^u8, }

ImDrawList_GetClipRectMin :: #force_inline proc(this : ^ImDrawList) -> ImVec2
{
	cr : ^ImVec4 = back(&this._ClipRectStack); return ImVec2(cr.x, cr.y)
}

ImDrawList_GetClipRectMax :: #force_inline proc(this : ^ImDrawList) -> ImVec2
{
	cr : ^ImVec4 = back(&this._ClipRectStack); return ImVec2(cr.z, cr.w)
}

// Stateful path API, add points then finish with PathFillConvex() or PathStroke()
// - Important: filled shapes must always use clockwise winding order! The anti-aliasing fringe depends on it. Counter-clockwise shapes will have "inward" anti-aliasing.
//   so e.g. 'PathArcTo(center, radius, PI * -0.5f, PI)' is ok, whereas 'PathArcTo(center, radius, PI, PI * -0.5f)' won't have correct anti-aliasing when followed by PathFillConvex().
ImDrawList_PathClear :: #force_inline proc(this : ^ImDrawList) { this._Path.Size = 0 }

ImDrawList_PathLineTo :: #force_inline proc(this : ^ImDrawList, pos : ^ImVec2) { push_back(&this._Path, pos) }

ImDrawList_PathLineToMergeDuplicate :: #force_inline proc(this : ^ImDrawList, pos : ^ImVec2) { if this._Path.Size == 0 || memcmp(&this._Path.Data[this._Path.Size - 1], &pos, 8) != 0 { push_back(&this._Path, pos) } }

ImDrawList_PathFillConvex :: #force_inline proc(this : ^ImDrawList, col : ImU32)
{
	AddConvexPolyFilled(this._Path.Data, this._Path.Size, col); this._Path.Size = 0
}

ImDrawList_PathFillConcave :: #force_inline proc(this : ^ImDrawList, col : ImU32)
{
	AddConcavePolyFilled(this._Path.Data, this._Path.Size, col); this._Path.Size = 0
}

ImDrawList_PathStroke :: #force_inline proc(this : ^ImDrawList, col : ImU32, flags : ImDrawFlags = 0, thickness : f32 = 1.0)
{
	AddPolyline(this._Path.Data, this._Path.Size, col, flags, thickness); this._Path.Size = 0
}

// Advanced: Channels
// - Use to split render into layers. By switching channels to can render out-of-order (e.g. submit FG primitives before BG primitives)
// - Use to minimize draw calls (e.g. if going back-and-forth between multiple clipping rectangles, prefer to append into separate channels then merge at the end)
// - This API shouldn't have been in ImDrawList in the first place!
//   Prefer using your own persistent instance of ImDrawListSplitter as you can stack them.
//   Using the ImDrawList::ChannelsXXXX you cannot stack a split over another.
ImDrawList_ChannelsSplit :: #force_inline proc(this : ^ImDrawList, count : i32) { Split(&this._Splitter, this, count) }

ImDrawList_ChannelsMerge :: #force_inline proc(this : ^ImDrawList) { Merge(&this._Splitter, this) }

ImDrawList_ChannelsSetCurrent :: #force_inline proc(this : ^ImDrawList, n : i32) { SetCurrentChannel(&this._Splitter, this, n) }

ImDrawList_PrimWriteVtx :: #force_inline proc(this : ^ImDrawList, pos : ^ImVec2, uv : ^ImVec2, col : ImU32)
{
	this._VtxWritePtr.pos = pos; this._VtxWritePtr.uv = uv; this._VtxWritePtr.col = col; post_incr(&this._VtxWritePtr); post_incr(&this._VtxCurrentIdx)
}

ImDrawList_PrimWriteIdx :: #force_inline proc(this : ^ImDrawList, idx : ImDrawIdx)
{
	this._IdxWritePtr^ = idx; post_incr(&this._IdxWritePtr)
}

// Write vertex with unique index
ImDrawList_PrimVtx :: #force_inline proc(this : ^ImDrawList, pos : ^ImVec2, uv : ^ImVec2, col : ImU32)
{
	PrimWriteIdx(cast(ImDrawIdx) this._VtxCurrentIdx); PrimWriteVtx(pos, uv, col)
}

// A single draw command within a parent ImDrawList (generally maps to 1 GPU draw call, unless it is a callback)
// All draw data to render a Dear ImGui frame
// (NB: the style and the naming convention here is a little inconsistent, we currently preserve them for backward compatibility purpose,
// as this is one of the oldest structure exposed by the library! Basically, ImDrawList == CmdList)
ImDrawData :: struct {
	Valid : bool, // Only valid after Render() is called and before the next NewFrame() is called.
	CmdListsCount : i32, // Number of ImDrawList* to render
	TotalIdxCount : i32, // For convenience, sum of all ImDrawList's IdxBuffer.Size
	TotalVtxCount : i32, // For convenience, sum of all ImDrawList's VtxBuffer.Size
	CmdLists : ImVector(^ImDrawList), // Array of ImDrawList* to render. The ImDrawLists are owned by ImGuiContext and only pointed to from here.
	DisplayPos : ImVec2, // Top-left position of the viewport to render (== top-left of the orthogonal projection matrix to use) (== GetMainViewport()->Pos for the main viewport, == (0.0) in most single-viewport applications)
	DisplaySize : ImVec2, // Size of the viewport to render (== GetMainViewport()->Size for the main viewport, == io.DisplaySize in most single-viewport applications)
	FramebufferScale : ImVec2, // Amount of pixels for each unit of DisplaySize. Based on io.DisplayFramebufferScale. Generally (1,1) on normal display, (2,2) on OSX with Retina display.
	OwnerViewport : ^ImGuiViewport, }

// Viewport carrying the ImDrawData instance, might be of use to the renderer (generally not).

// Functions
ImDrawData_init :: proc(this : ^ImDrawData) { Clear() }

// Opaque interface to a font builder (stb_truetype or FreeType).
//-----------------------------------------------------------------------------
// [SECTION] Font API (ImFontConfig, ImFontGlyph, ImFontAtlasFlags, ImFontAtlas, ImFontGlyphRangesBuilder, ImFont)
//-----------------------------------------------------------------------------

ImFontConfig :: struct {
	FontData : rawptr, //          // TTF/OTF data
	FontDataSize : i32, //          // TTF/OTF data size
	FontDataOwnedByAtlas : bool, // true     // TTF/OTF data ownership taken by the container ImFontAtlas (will delete memory itself).
	FontNo : i32, // 0        // Index of font within TTF/OTF file
	SizePixels : f32, //          // Size in pixels for rasterizer (more or less maps to the resulting font height).
	OversampleH : i32, // 2        // Rasterize at higher quality for sub-pixel positioning. Note the difference between 2 and 3 is minimal. You can reduce this to 1 for large glyphs save memory. Read https://github.com/nothings/stb/blob/master/tests/oversample/README.md for details.
	OversampleV : i32, // 1        // Rasterize at higher quality for sub-pixel positioning. This is not really useful as we don't use sub-pixel positions on the Y axis.
	PixelSnapH : bool, // false    // Align every glyph AdvanceX to pixel boundaries. Useful e.g. if you are merging a non-pixel aligned font with the default font. If enabled, you can set OversampleH/V to 1.
	GlyphExtraSpacing : ImVec2, // 0, 0     // Extra spacing (in pixels) between glyphs when rendered: essentially add to glyph->AdvanceX. Only X axis is supported for now.
	GlyphOffset : ImVec2, // 0, 0     // Offset all glyphs from this font input.
	GlyphRanges : ^ImWchar, // NULL     // THE ARRAY DATA NEEDS TO PERSIST AS LONG AS THE FONT IS ALIVE. Pointer to a user-provided list of Unicode range (2 value per range, values are inclusive, zero-terminated list).
	GlyphMinAdvanceX : f32, // 0        // Minimum AdvanceX for glyphs, set Min to align font icons, set both Min/Max to enforce mono-space font
	GlyphMaxAdvanceX : f32, // FLT_MAX  // Maximum AdvanceX for glyphs
	MergeMode : bool, // false    // Merge into previous ImFont, so you can combine multiple inputs font into one ImFont (e.g. ASCII font + icons + Japanese glyphs). You may want to use GlyphOffset.y when merge font of different heights.
	FontBuilderFlags : u32, // 0        // Settings for custom font builder. THIS IS BUILDER IMPLEMENTATION DEPENDENT. Leave as zero if unsure.
	RasterizerMultiply : f32, // 1.0f     // Linearly brighten (>1.0f) or darken (<1.0f) font output. Brightening small fonts may be a good workaround to make them more readable. This is a silly thing we may remove in the future.
	RasterizerDensity : f32, // 1.0f     // DPI scale for rasterization, not altering other font metrics: make it easy to swap between e.g. a 100% and a 400% fonts for a zooming display. IMPORTANT: If you increase this it is expected that you increase font scale accordingly, otherwise quality may look lowered.
	EllipsisChar : ImWchar, // 0        // Explicitly specify unicode codepoint of ellipsis character. When fonts are being merged first specified ellipsis will be used.

	// [Internal]
	Name : [40]u8, // Name (strictly to ease debugging)
	DstFont : ^ImFont,
}

// Configuration data when adding a font or merging fonts
// Hold rendering data for one glyph.
// (Note: some language parsers may fail to convert the 31+1 bitfield members, in this case maybe drop store a single u32 or we can rework this)
ImFontGlyph :: struct {
	using _0 : bit_field u32 {
		Colored : u32 | 1, // Flag to indicate glyph is colored and should generally ignore tinting (make it usable with no shift on little-endian as this is used in loops)
		Visible : u32 | 1, // Flag to indicate glyph has no visible pixels (e.g. space). Allow early out when rendering.
		Codepoint : u32 | 30, // 0x0000..0x10FFFF
	},
	AdvanceX : f32, // Distance to next character (= data from font + ImFontConfig::GlyphExtraSpacing.x baked in)
	X0 : f32, Y0 : f32, X1 : f32, Y1 : f32, // Glyph corners
	U0 : f32, V0 : f32, U1 : f32, V1 : f32, // Texture coordinates
}

// A single font glyph (code point + coordinates within in ImFontAtlas + offset)
// Helper to build glyph ranges from text/string data. Feed your application strings/characters to it then call BuildRanges().
// This is essentially a tightly packed of vector of 64k booleans = 8KB storage.
ImFontGlyphRangesBuilder :: struct {
	UsedChars : ImVector(ImU32), }

// Store 1-bit per Unicode code point (0=unused, 1=used)

ImFontGlyphRangesBuilder_init :: proc(this : ^ImFontGlyphRangesBuilder) { Clear() }

ImFontGlyphRangesBuilder_Clear :: #force_inline proc(this : ^ImFontGlyphRangesBuilder)
{
	size_in_bytes : i32 = (IM_UNICODE_CODEPOINT_MAX + 1) / 8; resize(&this.UsedChars, size_in_bytes / cast(i32) size_of(ImU32)); memset(this.UsedChars.Data, 0, cast(uint) size_in_bytes)
}

// Get bit n in the array
ImFontGlyphRangesBuilder_GetBit :: #force_inline proc(this : ^ImFontGlyphRangesBuilder, n : uint) -> bool
{
	off : i32 = cast(i32) (n >> 5); mask : ImU32 = 1 << (n & 31); return (this.UsedChars[off] & mask) != 0
}

// Set bit n in the array
ImFontGlyphRangesBuilder_SetBit :: #force_inline proc(this : ^ImFontGlyphRangesBuilder, n : uint)
{
	off : i32 = cast(i32) (n >> 5); mask : ImU32 = 1 << (n & 31); this.UsedChars[off] |= mask
}

// Add character
ImFontGlyphRangesBuilder_AddChar :: #force_inline proc(this : ^ImFontGlyphRangesBuilder, c : ImWchar) { SetBit(c) }

// See ImFontAtlas::AddCustomRectXXX functions.
ImFontAtlasCustomRect :: struct {
	X : u16, Y : u16, // Output   // Packed position in Atlas

	// [Internal]
	Width : u16, Height : u16, // Input    // Desired rectangle dimension
	using _0 : bit_field u32 {
		GlyphID : u32 | 31, // Input    // For custom font glyphs only (ID < 0x110000)
		GlyphColored : u32 | 1, // Input  // For custom font glyphs only: glyph is colored, removed tinting.
	},
	GlyphAdvanceX : f32, // Input    // For custom font glyphs only: glyph xadvance
	GlyphOffset : ImVec2, // Input    // For custom font glyphs only: glyph display offset
	Font : ^ImFont, }

// Input    // For custom font glyphs only: target font
ImFontAtlasCustomRect_init :: proc(this : ^ImFontAtlasCustomRect)
{
	this.Y = 0xFFFF; this.X = this.Y; this.Height = 0; this.Width = this.Height; this.GlyphID = 0; this.GlyphColored = 0; this.GlyphAdvanceX = 0.0; this.GlyphOffset = ImVec2(0, 0); this.Font = nil
}

ImFontAtlasCustomRect_IsPacked :: proc(this : ^ImFontAtlasCustomRect) -> bool { return this.X != 0xFFFF }

// Flags for ImFontAtlas build
ImFontAtlasFlags_ :: enum i32 {
	ImFontAtlasFlags_None = 0,
	ImFontAtlasFlags_NoPowerOfTwoHeight = 1 << 0, // Don't round the height to next power of two
	ImFontAtlasFlags_NoMouseCursors = 1 << 1, // Don't build software mouse cursors into the atlas (save a little texture memory)
	ImFontAtlasFlags_NoBakedLines = 1 << 2, // Don't build thick line textures into the atlas (save a little texture memory, allow support for point/nearest filtering). The AntiAliasedLinesUseTex features uses them, otherwise they will be rendered using polygons (more expensive for CPU/GPU).
}

// Runtime data for a single font within a parent ImFontAtlas
// Load and rasterize multiple TTF/OTF fonts into a same texture. The font atlas will build a single texture holding:
//  - One or more fonts.
//  - Custom graphics data needed to render the shapes needed by Dear ImGui.
//  - Mouse cursor shapes for software cursor rendering (unless setting 'Flags |= ImFontAtlasFlags_NoMouseCursors' in the font atlas).
// It is the user-code responsibility to setup/build the atlas, then upload the pixel data into a texture accessible by your graphics api.
//  - Optionally, call any of the AddFont*** functions. If you don't call any, the default font embedded in the code will be loaded for you.
//  - Call GetTexDataAsAlpha8() or GetTexDataAsRGBA32() to build and retrieve pixels data.
//  - Upload the pixels data into a texture within your graphics system (see imgui_impl_xxxx.cpp examples)
//  - Call SetTexID(my_tex_id); and pass the pointer/identifier to your texture in a format natural to your graphics API.
//    This value will be passed back to you during rendering to identify the texture. Read FAQ entry about ImTextureID for more details.
// Common pitfalls:
// - If you pass a 'glyph_ranges' array to AddFont*** functions, you need to make sure that your array persist up until the
//   atlas is build (when calling GetTexData*** or Build()). We only copy the pointer, not the data.
// - Important: By default, AddFontFromMemoryTTF() takes ownership of the data. Even though we are not writing to it, we will free the pointer on destruction.
//   You can set font_cfg->FontDataOwnedByAtlas=false to keep ownership of your data and it won't be freed,
// - Even though many functions are suffixed with "TTF", OTF data is supported just as well.
// - This is an old API and it is currently awkward for those and various other reasons! We will address them in the future!
ImFontAtlas :: struct {
	//-------------------------------------------
	// Members
	//-------------------------------------------

	Flags : ImFontAtlasFlags, // Build flags (see ImFontAtlasFlags_)
	TexID : ImTextureID, // User data to refer to the texture once it has been uploaded to user's graphic systems. It is passed back to you during rendering via the ImDrawCmd structure.
	TexDesiredWidth : i32, // Texture width desired by user before Build(). Must be a power-of-two. If have many glyphs your graphics API have texture size restrictions you may want to increase texture width to decrease height.
	TexGlyphPadding : i32, // FIXME: Should be called "TexPackPadding". Padding between glyphs within texture in pixels. Defaults to 1. If your rendering method doesn't rely on bilinear filtering you may set this to 0 (will also need to set AntiAliasedLinesUseTex = false).
	Locked : bool, // Marked as Locked by ImGui::NewFrame() so attempt to modify the atlas will assert.
	UserData : rawptr, // Store your own atlas related user-data (if e.g. you have multiple font atlas).

	// [Internal]
	// NB: Access texture data via GetTexData*() calls! Which will setup a default font for you.
	TexReady : bool, // Set when texture was built matching current font input
	TexPixelsUseColors : bool, // Tell whether our texture data is known to use colors (rather than just alpha channel), in order to help backend select a format.
	TexPixelsAlpha8 : ^u8, // 1 component per pixel, each component is unsigned 8-bit. Total size = TexWidth * TexHeight
	TexPixelsRGBA32 : ^u32, // 4 component per pixel, each component is unsigned 8-bit. Total size = TexWidth * TexHeight * 4
	TexWidth : i32, // Texture width calculated during Build().
	TexHeight : i32, // Texture height calculated during Build().
	TexUvScale : ImVec2, // = (1.0f/TexWidth, 1.0f/TexHeight)
	TexUvWhitePixel : ImVec2, // Texture coordinates to a white pixel
	Fonts : ImVector(^ImFont), // Hold all the fonts returned by AddFont*. Fonts[0] is the default font upon calling ImGui::NewFrame(), use ImGui::PushFont()/PopFont() to change the current font.
	CustomRects : ImVector(ImFontAtlasCustomRect), // Rectangles for packing custom texture data into the atlas.
	ConfigData : ImVector(ImFontConfig), // Configuration data
	TexUvLines : [IM_DRAWLIST_TEX_LINES_WIDTH_MAX + 1]ImVec4, // UVs for baked anti-aliased lines

	// [Internal] Font builder
	FontBuilderIO : ^ImFontBuilderIO, // Opaque interface to a font builder (default to stb_truetype, can be changed to use FreeType by defining IMGUI_ENABLE_FREETYPE).
	FontBuilderFlags : u32, // Shared flags (for all fonts) for custom font builder. THIS IS BUILD IMPLEMENTATION DEPENDENT. Per-font override is also available in ImFontConfig.

	// [Internal] Packing data
	PackIdMouseCursors : i32, // Custom texture rectangle ID for white pixel and mouse cursors
	PackIdLines : i32, // Custom texture rectangle ID for baked anti-aliased lines

	// [Obsolete]
	//typedef ImFontAtlasCustomRect    CustomRect;         // OBSOLETED in 1.72+
	//typedef ImFontGlyphRangesBuilder GlyphRangesBuilder; // OBSOLETED in 1.67+
}

// Bit ambiguous: used to detect when user didn't build texture but effectively we should check TexID != 0 except that would be backend dependent...
ImFontAtlas_IsBuilt :: proc(this : ^ImFontAtlas) -> bool { return this.Fonts.Size > 0 && this.TexReady }

ImFontAtlas_SetTexID :: proc(this : ^ImFontAtlas, id : ImTextureID) { this.TexID = id }

ImFontAtlas_GetCustomRectByIndex :: proc(this : ^ImFontAtlas, index : i32) -> ^ImFontAtlasCustomRect
{
	IM_ASSERT(index >= 0); return &this.CustomRects[index]
}

// A single vertex (pos + uv + col = 20 bytes by default. Override layout with IMGUI_OVERRIDE_DRAWVERT_STRUCT_LAYOUT)
// Font runtime data and rendering
// ImFontAtlas automatically loads a default embedded font for you when you call GetTexDataAsAlpha8() or GetTexDataAsRGBA32().
ImFont :: struct {
	// [Internal] Members: Hot ~20/24 bytes (for CalcTextSize)
	IndexAdvanceX : ImVector(f32), // 12-16 // out //            // Sparse. Glyphs->AdvanceX in a directly indexable way (cache-friendly for CalcTextSize functions which only this info, and are often bottleneck in large UI).
	FallbackAdvanceX : f32, // 4     // out // = FallbackGlyph->AdvanceX
	FontSize : f32, // 4     // in  //            // Height of characters/line, set during loading (don't change after loading)

	// [Internal] Members: Hot ~28/40 bytes (for RenderText loop)
	IndexLookup : ImVector(ImWchar), // 12-16 // out //            // Sparse. Index glyphs by Unicode code-point.
	Glyphs : ImVector(ImFontGlyph), // 12-16 // out //            // All glyphs.
	FallbackGlyph : ^ImFontGlyph, // 4-8   // out // = FindGlyph(FontFallbackChar)

	// [Internal] Members: Cold ~32/40 bytes
	// Conceptually ConfigData[] is the list of font sources merged to create this font.
	ContainerAtlas : ^ImFontAtlas, // 4-8   // out //            // What we has been loaded into
	ConfigData : ^ImFontConfig, // 4-8   // in  //            // Pointer within ContainerAtlas->ConfigData to ConfigDataCount instances
	ConfigDataCount : i16, // 2     // in  // ~ 1        // Number of ImFontConfig involved in creating this font. Bigger than 1 when merging multiple font sources into one ImFont.
	EllipsisCharCount : i16, // 1     // out // 1 or 3
	EllipsisChar : ImWchar, // 2-4   // out // = '...'/'.'// Character used for ellipsis rendering.
	FallbackChar : ImWchar, // 2-4   // out // = FFFD/'?' // Character used if a glyph isn't found.
	EllipsisWidth : f32, // 4     // out               // Width
	EllipsisCharStep : f32, // 4     // out               // Step between characters when EllipsisCount > 0
	DirtyLookupTables : bool, // 1     // out //
	Scale : f32, // 4     // in  // = 1.f      // Base font scale, multiplied by the per-window font scale which you can adjust with SetWindowFontScale()
	Ascent : f32, Descent : f32, // 4+4   // out //            // Ascent: distance from top to bottom of e.g. 'A' [0..FontSize] (unscaled)
	MetricsTotalSurface : i32, // 4     // out //            // Total surface in pixels to get an idea of the font rasterization/texture cost (not exact, we approximate the cost of padding between glyphs)
	Used4kPagesMap : [(IM_UNICODE_CODEPOINT_MAX + 1) / 4096 / 8]ImU8, }

ImFont_GetCharAdvance :: proc(this : ^ImFont, c : ImWchar) -> f32 { return (cast(i32) c < this.IndexAdvanceX.Size) ? this.IndexAdvanceX[cast(i32) c] : this.FallbackAdvanceX }

ImFont_IsLoaded :: proc(this : ^ImFont) -> bool { return this.ContainerAtlas != nil }

ImFont_GetDebugName :: proc(this : ^ImFont) -> ^u8 { return this.ConfigData ? this.ConfigData.Name : "<unknown>" }

//-----------------------------------------------------------------------------
// [SECTION] Viewports
//-----------------------------------------------------------------------------

// Flags stored in ImGuiViewport::Flags, giving indications to the platform backends.
ImGuiViewportFlags_ :: enum i32 {
	ImGuiViewportFlags_None = 0,
	ImGuiViewportFlags_IsPlatformWindow = 1 << 0, // Represent a Platform Window
	ImGuiViewportFlags_IsPlatformMonitor = 1 << 1, // Represent a Platform Monitor (unused yet)
	ImGuiViewportFlags_OwnedByApp = 1 << 2, // Platform Window: Is created/managed by the user application? (rather than our backend)
	ImGuiViewportFlags_NoDecoration = 1 << 3, // Platform Window: Disable platform decorations: title bar, borders, etc. (generally set all windows, but if ImGuiConfigFlags_ViewportsDecoration is set we only set this on popups/tooltips)
	ImGuiViewportFlags_NoTaskBarIcon = 1 << 4, // Platform Window: Disable platform task bar icon (generally set on popups/tooltips, or all windows if ImGuiConfigFlags_ViewportsNoTaskBarIcon is set)
	ImGuiViewportFlags_NoFocusOnAppearing = 1 << 5, // Platform Window: Don't take focus when created.
	ImGuiViewportFlags_NoFocusOnClick = 1 << 6, // Platform Window: Don't take focus when clicked on.
	ImGuiViewportFlags_NoInputs = 1 << 7, // Platform Window: Make mouse pass through so we can drag this window while peaking behind it.
	ImGuiViewportFlags_NoRendererClear = 1 << 8, // Platform Window: Renderer doesn't need to clear the framebuffer ahead (because we will fill it entirely).
	ImGuiViewportFlags_NoAutoMerge = 1 << 9, // Platform Window: Avoid merging this window into another host window. This can only be set via ImGuiWindowClass viewport flags override (because we need to now ahead if we are going to create a viewport in the first place!).
	ImGuiViewportFlags_TopMost = 1 << 10, // Platform Window: Display on top (for tooltips only).
	ImGuiViewportFlags_CanHostOtherWindows = 1 << 11, // Viewport can host multiple imgui windows (secondary viewports are associated to a single window). // FIXME: In practice there's still probably code making the assumption that this is always and only on the MainViewport. Will fix once we add support for "no main viewport".

	// Output status flags (from Platform)
	ImGuiViewportFlags_IsMinimized = 1 << 12, // Platform Window: Window is minimized, can skip render. When minimized we tend to avoid using the viewport pos/size for clipping window or testing if they are contained in the viewport.
	ImGuiViewportFlags_IsFocused = 1 << 13, // Platform Window: Window is focused (last call to Platform_GetWindowFocus() returned true)
}

// Helper to parse and apply text filters (e.g. "aaaaa[,bbbbb][,ccccc]")
// - Currently represents the Platform Window created by the application which is hosting our Dear ImGui windows.
// - With multi-viewport enabled, we extend this concept to have multiple active viewports.
// - In the future we will extend this concept further to also represent Platform Monitor and support a "no main platform window" operation mode.
// - About Main Area vs Work Area:
//   - Main Area = entire viewport.
//   - Work Area = entire viewport minus sections used by main menu bars (for platform windows), or by task bar (for platform monitor).
//   - Windows are generally trying to stay within the Work Area of their host viewport.
ImGuiViewport :: struct {
	ID : ImGuiID, // Unique identifier for the viewport
	Flags : ImGuiViewportFlags, // See ImGuiViewportFlags_
	Pos : ImVec2, // Main Area: Position of the viewport (Dear ImGui coordinates are the same as OS desktop/native coordinates)
	Size : ImVec2, // Main Area: Size of the viewport.
	WorkPos : ImVec2, // Work Area: Position of the viewport minus task bars, menus bars, status bars (>= Pos)
	WorkSize : ImVec2, // Work Area: Size of the viewport minus task bars, menu bars, status bars (<= Size)
	DpiScale : f32, // 1.0f = 96 DPI = No extra scale.
	ParentViewportId : ImGuiID, // (Advanced) 0: no parent. Instruct the platform backend to setup a parent/child relationship between platform windows.
	DrawData : ^ImDrawData, // The ImDrawData corresponding to this viewport. Valid after Render() and until the next call to NewFrame().

	// Platform/Backend Dependent Data
	// Our design separate the Renderer and Platform backends to facilitate combining default backends with each others.
	// When our create your own backend for a custom engine, it is possible that both Renderer and Platform will be handled
	// by the same system and you may not need to use all the UserData/Handle fields.
	// The library never uses those fields, they are merely storage to facilitate backend implementation.
	RendererUserData : rawptr, // void* to hold custom data structure for the renderer (e.g. swap chain, framebuffers etc.). generally set by your Renderer_CreateWindow function.
	PlatformUserData : rawptr, // void* to hold custom data structure for the OS / platform (e.g. windowing info, render context). generally set by your Platform_CreateWindow function.
	PlatformHandle : rawptr, // void* to hold higher-level, platform window handle (e.g. HWND, GLFWWindow*, SDL_Window*), for FindViewportByPlatformHandle().
	PlatformHandleRaw : rawptr, // void* to hold lower-level, platform-native window handle (under Win32 this is expected to be a HWND, unused for other platforms), when using an abstraction layer like GLFW or SDL (where PlatformHandle would be a SDL_Window*)
	PlatformWindowCreated : bool, // Platform window has been created (Platform_CreateWindow() has been called). This is false during the first frame where a viewport is being created.
	PlatformRequestMove : bool, // Platform window requested move (e.g. window was moved by the OS / host window manager, authoritative position will be OS window position)
	PlatformRequestResize : bool, // Platform window requested resize (e.g. window was resized by the OS / host window manager, authoritative size will be OS window size)
	PlatformRequestClose : bool, }

ImGuiViewport_deinit :: proc(this : ^ImGuiViewport)
{IM_ASSERT(this.PlatformUserData == nil && this.RendererUserData == nil)}

// Platform window requested closure (e.g. window was moved by the OS / host window manager, e.g. pressing ALT-F4)

ImGuiViewport_init :: proc(this : ^ImGuiViewport) { memset(this, 0, size_of(this)) }

// Helpers
ImGuiViewport_GetCenter :: proc(this : ^ImGuiViewport) -> ImVec2 { return ImVec2(this.Pos.x + this.Size.x * 0.5, this.Pos.y + this.Size.y * 0.5) }

ImGuiViewport_GetWorkCenter :: proc(this : ^ImGuiViewport) -> ImVec2 { return ImVec2(this.WorkPos.x + this.WorkSize.x * 0.5, this.WorkPos.y + this.WorkSize.y * 0.5) }

// User data payload for drag and drop operations
//-----------------------------------------------------------------------------
// [SECTION] ImGuiPlatformIO + other Platform Dependent Interfaces (ImGuiPlatformMonitor, ImGuiPlatformImeData)
//-----------------------------------------------------------------------------

// [BETA] (Optional) Multi-Viewport Support!
// If you are new to Dear ImGui and trying to integrate it into your engine, you can probably ignore this for now.
//
// This feature allows you to seamlessly drag Dear ImGui windows outside of your application viewport.
// This is achieved by creating new Platform/OS windows on the fly, and rendering into them.
// Dear ImGui manages the viewport structures, and the backend create and maintain one Platform/OS window for each of those viewports.
//
// See Recap:   https://github.com/ocornut/imgui/wiki/Multi-Viewports
// See Glossary https://github.com/ocornut/imgui/wiki/Glossary for details about some of the terminology.
//
// About the coordinates system:
// - When multi-viewports are enabled, all Dear ImGui coordinates become absolute coordinates (same as OS coordinates!)
// - So e.g. ImGui::SetNextWindowPos(ImVec2(0,0)) will position a window relative to your primary monitor!
// - If you want to position windows relative to your main application viewport, use ImGui::GetMainViewport()->Pos as a base position.
//
// Steps to use multi-viewports in your application, when using a default backend from the examples/ folder:
// - Application:  Enable feature with 'io.ConfigFlags |= ImGuiConfigFlags_ViewportsEnable'.
// - Backend:      The backend initialization will setup all necessary ImGuiPlatformIO's functions and update monitors info every frame.
// - Application:  In your main loop, call ImGui::UpdatePlatformWindows(), ImGui::RenderPlatformWindowsDefault() after EndFrame() or Render().
// - Application:  Fix absolute coordinates used in ImGui::SetWindowPos() or ImGui::SetNextWindowPos() calls.
//
// Steps to use multi-viewports in your application, when using a custom backend:
// - Important:    THIS IS NOT EASY TO DO and comes with many subtleties not described here!
//                 It's also an experimental feature, so some of the requirements may evolve.
//                 Consider using default backends if you can. Either way, carefully follow and refer to examples/ backends for details.
// - Application:  Enable feature with 'io.ConfigFlags |= ImGuiConfigFlags_ViewportsEnable'.
// - Backend:      Hook ImGuiPlatformIO's Platform_* and Renderer_* callbacks (see below).
//                 Set 'io.BackendFlags |= ImGuiBackendFlags_PlatformHasViewports' and 'io.BackendFlags |= ImGuiBackendFlags_PlatformHasViewports'.
//                 Update ImGuiPlatformIO's Monitors list every frame.
//                 Update MousePos every frame, in absolute coordinates.
// - Application:  In your main loop, call ImGui::UpdatePlatformWindows(), ImGui::RenderPlatformWindowsDefault() after EndFrame() or Render().
//                 You may skip calling RenderPlatformWindowsDefault() if its API is not convenient for your needs. Read comments below.
// - Application:  Fix absolute coordinates used in ImGui::SetWindowPos() or ImGui::SetNextWindowPos() calls.
//
// About ImGui::RenderPlatformWindowsDefault():
// - This function is a mostly a _helper_ for the common-most cases, and to facilitate using default backends.
// - You can check its simple source code to understand what it does.
//   It basically iterates secondary viewports and call 4 functions that are setup in ImGuiPlatformIO, if available:
//     Platform_RenderWindow(), Renderer_RenderWindow(), Platform_SwapBuffers(), Renderer_SwapBuffers()
//   Those functions pointers exists only for the benefit of RenderPlatformWindowsDefault().
// - If you have very specific rendering needs (e.g. flipping multiple swap-chain simultaneously, unusual sync/threading issues, etc.),
//   you may be tempted to ignore RenderPlatformWindowsDefault() and write customized code to perform your renderingg.
//   You may decide to setup the platform_io's *RenderWindow and *SwapBuffers pointers and call your functions through those pointers,
//   or you may decide to never setup those pointers and call your code directly. They are a convenience, not an obligatory interface.
//-----------------------------------------------------------------------------

// Access via ImGui::GetPlatformIO()
ImGuiPlatformIO :: struct {
	//------------------------------------------------------------------
	// Interface with OS and Platform backend (basic)
	//------------------------------------------------------------------

	// Optional: Access OS clipboard
	// (default to use native Win32 clipboard on Windows, otherwise uses a private clipboard. Override to access OS clipboard on other architectures)
	Platform_GetClipboardTextFn : proc(	_ctx : ^ImGuiContext) -> ^u8,
	Platform_SetClipboardTextFn : proc(	_ctx : ^ImGuiContext, 	_text : ^u8),
	Platform_ClipboardUserData : rawptr,

	// Optional: Open link/folder/file in OS Shell
	// (default to use ShellExecuteA() on Windows, system() on Linux/Mac)
	Platform_OpenInShellFn : proc(	_ctx : ^ImGuiContext, 	_path : ^u8) -> bool,
	Platform_OpenInShellUserData : rawptr,

	// Optional: Notify OS Input Method Editor of the screen position of your cursor for text input position (e.g. when using Japanese/Chinese IME on Windows)
	// (default to use native imm32 api on Windows)
	Platform_SetImeDataFn : proc(	_ctx : ^ImGuiContext, 	_viewport : ^ImGuiViewport, 	_data : ^ImGuiPlatformImeData),
	Platform_ImeUserData : rawptr,
	//void      (*SetPlatformImeDataFn)(ImGuiViewport* viewport, ImGuiPlatformImeData* data); // [Renamed to platform_io.PlatformSetImeDataFn in 1.91.1]

	// Optional: Platform locale
	// [Experimental] Configure decimal point e.g. '.' or ',' useful for some languages (e.g. German), generally pulled from *localeconv()->decimal_point
	Platform_LocaleDecimalPoint : ImWchar, // '.'

	//------------------------------------------------------------------
	// Interface with Renderer Backend
	//------------------------------------------------------------------

	// Written by some backends during ImGui_ImplXXXX_RenderDrawData() call to point backend_specific ImGui_ImplXXXX_RenderState* structure.
	Renderer_RenderState : rawptr,

	//------------------------------------------------------------------
	// Input - Interface with OS/backends (Multi-Viewport support!)
	//------------------------------------------------------------------

	// For reference, the second column shows which function are generally calling the Platform Functions:
	//   N = ImGui::NewFrame()                        ~ beginning of the dear imgui frame: read info from platform/OS windows (latest size/position)
	//   F = ImGui::Begin(), ImGui::EndFrame()        ~ during the dear imgui frame
	//   U = ImGui::UpdatePlatformWindows()           ~ after the dear imgui frame: create and update all platform/OS windows
	//   R = ImGui::RenderPlatformWindowsDefault()    ~ render
	//   D = ImGui::DestroyPlatformWindows()          ~ shutdown
	// The general idea is that NewFrame() we will read the current Platform/OS state, and UpdatePlatformWindows() will write to it.

	// The handlers are designed so we can mix and match two imgui_impl_xxxx files, one Platform backend and one Renderer backend.
	// Custom engine backends will often provide both Platform and Renderer interfaces together and so may not need to use all functions.
	// Platform functions are typically called _before_ their Renderer counterpart, apart from Destroy which are called the other way.

	// Platform Backend functions (e.g. Win32, GLFW, SDL) ------------------- Called by -----
	Platform_CreateWindow : proc(	_vp : ^ImGuiViewport), // . . U . .  // Create a new platform window for the given viewport
	Platform_DestroyWindow : proc(	_vp : ^ImGuiViewport), // N . U . D  //
	Platform_ShowWindow : proc(	_vp : ^ImGuiViewport), // . . U . .  // Newly created windows are initially hidden so SetWindowPos/Size/Title can be called on them before showing the window
	Platform_SetWindowPos : proc(	_vp : ^ImGuiViewport, 	_pos : ImVec2), // . . U . .  // Set platform window position (given the upper-left corner of client area)
	Platform_GetWindowPos : proc(	_vp : ^ImGuiViewport) -> ImVec2, // N . . . .  //
	Platform_SetWindowSize : proc(	_vp : ^ImGuiViewport, 	_size : ImVec2), // . . U . .  // Set platform window client area size (ignoring OS decorations such as OS title bar etc.)
	Platform_GetWindowSize : proc(	_vp : ^ImGuiViewport) -> ImVec2, // N . . . .  // Get platform window client area size
	Platform_SetWindowFocus : proc(	_vp : ^ImGuiViewport), // N . . . .  // Move window to front and set input focus
	Platform_GetWindowFocus : proc(	_vp : ^ImGuiViewport) -> bool, // . . U . .  //
	Platform_GetWindowMinimized : proc(	_vp : ^ImGuiViewport) -> bool, // N . . . .  // Get platform window minimized state. When minimized, we generally won't attempt to get/set size and contents will be culled more easily
	Platform_SetWindowTitle : proc(	_vp : ^ImGuiViewport, 	_str : ^u8), // . . U . .  // Set platform window title (given an UTF-8 string)
	Platform_SetWindowAlpha : proc(	_vp : ^ImGuiViewport, 	_alpha : f32), // . . U . .  // (Optional) Setup global transparency (not per-pixel transparency)
	Platform_UpdateWindow : proc(	_vp : ^ImGuiViewport), // . . U . .  // (Optional) Called by UpdatePlatformWindows(). Optional hook to allow the platform backend from doing general book-keeping every frame.
	Platform_RenderWindow : proc(	_vp : ^ImGuiViewport, 	_render_arg : rawptr), // . . . R .  // (Optional) Main rendering (platform side! This is often unused, or just setting a "current" context for OpenGL bindings). 'render_arg' is the value passed to RenderPlatformWindowsDefault().
	Platform_SwapBuffers : proc(	_vp : ^ImGuiViewport, 	_render_arg : rawptr), // . . . R .  // (Optional) Call Present/SwapBuffers (platform side! This is often unused!). 'render_arg' is the value passed to RenderPlatformWindowsDefault().
	Platform_GetWindowDpiScale : proc(	_vp : ^ImGuiViewport) -> f32, // N . . . .  // (Optional) [BETA] FIXME-DPI: DPI handling: Return DPI scale for this viewport. 1.0f = 96 DPI.
	Platform_OnChangedViewport : proc(	_vp : ^ImGuiViewport), // . F . . .  // (Optional) [BETA] FIXME-DPI: DPI handling: Called during Begin() every time the viewport we are outputting into changes, so backend has a chance to swap fonts to adjust style.
	Platform_GetWindowWorkAreaInsets : proc(	_vp : ^ImGuiViewport) -> ImVec4, // N . . . .  // (Optional) [BETA] Get initial work area inset for the viewport (won't be covered by main menu bar, dockspace over viewport etc.). Default to (0,0),(0,0). 'safeAreaInsets' in iOS land, 'DisplayCutout' in Android land.
	Platform_CreateVkSurface : proc(	_vp : ^ImGuiViewport, 	_vk_inst : ImU64, 	_vk_allocators : rawptr, 	_out_vk_surface : ^ImU64) -> i32, // (Optional) For a Vulkan Renderer to call into Platform code (since the surface creation needs to tie them both).

	// Renderer Backend functions (e.g. DirectX, OpenGL, Vulkan) ------------ Called by -----
	Renderer_CreateWindow : proc(	_vp : ^ImGuiViewport), // . . U . .  // Create swap chain, frame buffers etc. (called after Platform_CreateWindow)
	Renderer_DestroyWindow : proc(	_vp : ^ImGuiViewport), // N . U . D  // Destroy swap chain, frame buffers etc. (called before Platform_DestroyWindow)
	Renderer_SetWindowSize : proc(	_vp : ^ImGuiViewport, 	_size : ImVec2), // . . U . .  // Resize swap chain, frame buffers etc. (called after Platform_SetWindowSize)
	Renderer_RenderWindow : proc(	_vp : ^ImGuiViewport, 	_render_arg : rawptr), // . . . R .  // (Optional) Clear framebuffer, setup render target, then render the viewport->DrawData. 'render_arg' is the value passed to RenderPlatformWindowsDefault().
	Renderer_SwapBuffers : proc(	_vp : ^ImGuiViewport, 	_render_arg : rawptr), // . . . R .  // (Optional) Call Present/SwapBuffers. 'render_arg' is the value passed to RenderPlatformWindowsDefault().

	// (Optional) Monitor list
	// - Updated by: app/backend. Update every frame to dynamically support changing monitor or DPI configuration.
	// - Used by: dear imgui to query DPI info, clamp popups/tooltips within same monitor and not have them straddle monitors.
	Monitors : ImVector(ImGuiPlatformMonitor),

	//------------------------------------------------------------------
	// Output - List of viewports to render into platform windows
	//------------------------------------------------------------------

	// Viewports list (the list is updated by calling ImGui::EndFrame or ImGui::Render)
	// (in the future we will attempt to organize this feature to remove the need for a "main viewport")
	Viewports : ImVector(^ImGuiViewport), // Main viewports, followed by all secondary viewports.
}

// Platform IME data for io.PlatformSetImeDataFn() function.
// (Optional) This is required when enabling multi-viewport. Represent the bounds of each connected monitor/display and their DPI.
// We use this information for multiple DPI support + clamping the position of popups and tooltips so they don't straddle multiple monitors.
ImGuiPlatformMonitor :: struct {
	MainPos : ImVec2, MainSize : ImVec2, // Coordinates of the area displayed on this monitor (Min = upper left, Max = bottom right)
	WorkPos : ImVec2, WorkSize : ImVec2, // Coordinates without task bars / side bars / menu bars. Used to avoid positioning popups/tooltips inside this region. If you don't have this info, please copy the value for MainPos/MainSize.
	DpiScale : f32, // 1.0f = 96 DPI
	PlatformHandle : rawptr, }

// Backend dependant data (e.g. HMONITOR, GLFWmonitor*, SDL Display Index, NSScreen*)
ImGuiPlatformMonitor_init :: proc(this : ^ImGuiPlatformMonitor)
{
	this.WorkSize = ImVec2(0, 0); this.WorkPos = this.WorkSize; this.MainSize = this.WorkPos; this.MainPos = this.MainSize; this.DpiScale = 1.0; this.PlatformHandle = nil
}

// Interface between platform/renderer backends and ImGui (e.g. Clipboard, IME, Multi-Viewport support). Extends ImGuiIO.
// (Optional) Support for IME (Input Method Editor) via the platform_io.Platform_SetImeDataFn() function.
ImGuiPlatformImeData :: struct {
	WantVisible : bool, // A widget wants the IME to be visible
	InputPos : ImVec2, // Position of the input cursor
	InputLineHeight : f32, }

// Line height

ImGuiPlatformImeData_init :: proc(this : ^ImGuiPlatformImeData) { memset(this, 0, size_of(this)) }


//-----------------------------------------------------------------------------

// dear imgui, v1.91.7 WIP
// (internal structures/api)

// You may use this file to debug, understand or extend Dear ImGui features but we don't provide any guarantee of forward compatibility.

/*

Index of this file:

// [SECTION] Header mess
// [SECTION] Forward declarations
// [SECTION] Context pointer
// [SECTION] STB libraries includes
// [SECTION] Macros
// [SECTION] Generic helpers
// [SECTION] ImDrawList support
// [SECTION] Data types support
// [SECTION] Widgets support: flags, enums, data structures
// [SECTION] Popup support
// [SECTION] Inputs support
// [SECTION] Clipper support
// [SECTION] Navigation support
// [SECTION] Typing-select support
// [SECTION] Columns support
// [SECTION] Box-select support
// [SECTION] Multi-select support
// [SECTION] Docking support
// [SECTION] Viewport support
// [SECTION] Settings support
// [SECTION] Localization support
// [SECTION] Error handling, State recovery support
// [SECTION] Metrics, Debug tools
// [SECTION] Generic context hooks
// [SECTION] ImGuiContext (main imgui context)
// [SECTION] ImGuiWindowTempData, ImGuiWindow
// [SECTION] Tab bar, Tab item support
// [SECTION] Table support
// [SECTION] ImGui internal API
// [SECTION] ImFontAtlas internal API
// [SECTION] Test Engine specific hooks (imgui_test_engine)

*/

//-----------------------------------------------------------------------------
// [SECTION] Header mess
//-----------------------------------------------------------------------------

// Enable SSE intrinsics if available
IMGUI_ENABLE_SSE :: has_target_feature("sse") && !IMGUI_DISABLE_SSE
IMGUI_ENABLE_SSE4_2 :: IMGUI_ENABLE_SSE && (has_target_feature("avx") || has_target_feature("sse4.2"))
// Emscripten has partial SSE 4.2 support where _mm_crc32_u32 is not available. See https://emscripten.org/docs/porting/simd.html#id11 and #8213
IMGUI_ENABLE_SSE4_2_CRC :: IMGUI_ENABLE_SSE4_2 && ! IMGUI_USE_LEGACY_CRC32_ADLER && ! (ODIN_OS == .JS)

// Enable stb_truetype by default unless FreeType is enabled.
// You can compile with both by defining both IMGUI_ENABLE_FREETYPE and IMGUI_ENABLE_STB_TRUETYPE together.
IMGUI_ENABLE_FREETYPE :: false 
IMGUI_ENABLE_STB_TRUETYPE :: true

// -> enum ImGuiLocKey              // Enum: a localization entry for translation.
ImGuiDataAuthority :: i32// -> enum ImGuiDataAuthority_      // Enum: for storing the source authority (dock node vs window) of a field
ImGuiLayoutType :: i32// -> enum ImGuiLayoutType_         // Enum: Horizontal or vertical

// Flags
ImGuiActivateFlags :: i32// -> enum ImGuiActivateFlags_      // Flags: for navigation/focus function (will be for ActivateItem() later)
ImGuiDebugLogFlags :: i32// -> enum ImGuiDebugLogFlags_      // Flags: for ShowDebugLogWindow(), g.DebugLogFlags
ImGuiFocusRequestFlags :: i32// -> enum ImGuiFocusRequestFlags_  // Flags: for FocusWindow()
ImGuiItemStatusFlags :: i32// -> enum ImGuiItemStatusFlags_    // Flags: for g.LastItemData.StatusFlags
ImGuiOldColumnFlags :: i32// -> enum ImGuiOldColumnFlags_     // Flags: for BeginColumns()
ImGuiLogFlags :: i32// -> enum ImGuiLogFlags_           // Flags: for LogBegin() text capturing function
ImGuiNavRenderCursorFlags :: i32// -> enum ImGuiNavRenderCursorFlags_//Flags: for RenderNavCursor()
ImGuiNavMoveFlags :: i32// -> enum ImGuiNavMoveFlags_       // Flags: for navigation requests
ImGuiNextItemDataFlags :: i32// -> enum ImGuiNextItemDataFlags_  // Flags: for SetNextItemXXX() functions
ImGuiNextWindowDataFlags :: i32// -> enum ImGuiNextWindowDataFlags_// Flags: for SetNextWindowXXX() functions
ImGuiScrollFlags :: i32// -> enum ImGuiScrollFlags_        // Flags: for ScrollToItem() and navigation requests
ImGuiSeparatorFlags :: i32// -> enum ImGuiSeparatorFlags_     // Flags: for SeparatorEx()
ImGuiTextFlags :: i32// -> enum ImGuiTextFlags_          // Flags: for TextEx()
ImGuiTooltipFlags :: i32// -> enum ImGuiTooltipFlags_       // Flags: for BeginTooltipEx()
ImGuiTypingSelectFlags :: i32// -> enum ImGuiTypingSelectFlags_  // Flags: for GetTypingSelectRequest()
ImGuiWindowRefreshFlags :: i32// -> enum ImGuiWindowRefreshFlags_ // Flags: for SetNextWindowRefreshPolicy()

//-----------------------------------------------------------------------------
// [SECTION] Macros
//-----------------------------------------------------------------------------

// Internal Drag and Drop payload types. String starting with '_' are reserved for Dear ImGui.
IMGUI_PAYLOAD_TYPE_WINDOW :: "_IMWINDOW"// Payload == ImGuiWindow*

// Debug Printing Into TTY
// (since IMGUI_VERSION_NUM >= 18729: IMGUI_DEBUG_LOG was reworked into IMGUI_DEBUG_PRINTF (and removed framecount from it). If you were using a #define IMGUI_DEBUG_LOG please rename)
//when ! defined ( IMGUI_DEBUG_PRINTF ) {
when !IMGUI_DISABLE_DEFAULT_FORMAT_FUNCTIONS  {
IMGUI_DEBUG_PRINTF :: #force_inline proc "contextless" (_FMT : $T0, args : ..[]any) //TODO @gen: Validate the parameters were not passed by reference.
{
	printf(_FMT,__VA_ARGS__)
}

} else { // preproc else
IMGUI_DEBUG_PRINTF :: #force_inline proc "contextless" (_FMT : $T0, args : ..[]any) //TODO @gen: Validate the parameters were not passed by reference.
{
	_ = _FMT; _ = args
}

} // preproc endif
//} // preproc endif

// Debug Logging for ShowDebugLogWindow(). This is designed for relatively rare events so please don't spam.
IMGUI_DEBUG_LOG_ERROR :: #force_inline proc "contextless" (args : ..[]any)
{
	g2 := GImGui;
	if g2.DebugLogFlags & .ImGuiDebugLogFlags_EventError { IMGUI_DEBUG_LOG(args) }
	else { g2.DebugLogSkippedErrors += 1 }
}

IMGUI_DEBUG_LOG_ACTIVEID :: #force_inline proc "contextless" (g : ^ImGuiContext, args : ..[]any)
{
	if g.DebugLogFlags & .ImGuiDebugLogFlags_EventActiveId { IMGUI_DEBUG_LOG(args) }
}

IMGUI_DEBUG_LOG_FOCUS :: #force_inline proc "contextless" (g : ^ImGuiContext, args : ..[]any)
{
	if g.DebugLogFlags & .ImGuiDebugLogFlags_EventFocus { IMGUI_DEBUG_LOG(args) }
}

IMGUI_DEBUG_LOG_POPUP :: #force_inline proc "contextless" (g : ^ImGuiContext, args : ..[]any)
{
	if g.DebugLogFlags & .ImGuiDebugLogFlags_EventPopup { IMGUI_DEBUG_LOG(args) }
}

IMGUI_DEBUG_LOG_NAV :: #force_inline proc "contextless" (g : ^ImGuiContext, args : ..[]any)
{
	if g.DebugLogFlags & .ImGuiDebugLogFlags_EventNav { IMGUI_DEBUG_LOG(args) }
}

IMGUI_DEBUG_LOG_SELECTION :: #force_inline proc "contextless" (g : ^ImGuiContext, args : ..[]any)
{
	if g.DebugLogFlags & .ImGuiDebugLogFlags_EventSelection { IMGUI_DEBUG_LOG(args) }
}

IMGUI_DEBUG_LOG_CLIPPER :: #force_inline proc "contextless" (g : ^ImGuiContext, args : ..[]any)
{
	if g.DebugLogFlags & .ImGuiDebugLogFlags_EventClipper { IMGUI_DEBUG_LOG(args) }
}

IMGUI_DEBUG_LOG_IO :: #force_inline proc "contextless" (g : ^ImGuiContext, args : ..[]any)
{
	if g.DebugLogFlags & .ImGuiDebugLogFlags_EventIO { IMGUI_DEBUG_LOG(args) }
}

IMGUI_DEBUG_LOG_FONT :: #force_inline proc "contextless" (g : ^ImGuiContext, args : ..[]any)
{
	if g.DebugLogFlags & .ImGuiDebugLogFlags_EventFont { IMGUI_DEBUG_LOG(args) }
}

IMGUI_DEBUG_LOG_INPUTROUTING :: #force_inline proc "contextless" (g : ^ImGuiContext, args : ..[]any)
{
	if g.DebugLogFlags & .ImGuiDebugLogFlags_EventInputRouting { IMGUI_DEBUG_LOG(args) }
}

IMGUI_DEBUG_LOG_DOCKING :: #force_inline proc "contextless" (g : ^ImGuiContext, args : ..[]any)
{
	if g.DebugLogFlags & .ImGuiDebugLogFlags_EventDocking { IMGUI_DEBUG_LOG(args) }
}

IMGUI_DEBUG_LOG_VIEWPORT :: #force_inline proc "contextless" (g : ^ImGuiContext, args : ..[]any)
{
	if g.DebugLogFlags & .ImGuiDebugLogFlags_EventViewport { IMGUI_DEBUG_LOG(args) }
}


// "Paranoid" Debug Asserts are meant to only be enabled during specific debugging/work, otherwise would slow down the code too much.
// We currently don't have many of those so the effect is currently negligible, but onward intent to add more aggressive ones in the code.
//#define IMGUI_DEBUG_PARANOID
when IMGUI_DEBUG_PARANOID {
IM_ASSERT_PARANOID :: #force_inline proc "contextless" (_EXPR : $T0, _e := #caller_expression(_EXPR))
{
	IM_ASSERT(_EXPR, _e)
}

} else { // preproc else
IM_ASSERT_PARANOID :: #force_inline proc "contextless" (_EXPR : $T0)
{
}

} // preproc endif

// Misc Macros
IM_PI :: 3.14159265358979323846
IM_NEWLINE :: "\n"
//when ! defined ( IM_TABSIZE ) { // Until we move this to runtime and/or add proper tab support, at least allow users to compile-time override
IM_TABSIZE :: (4)
//} // preproc endif
IM_MEMALIGN :: #force_inline proc "contextless" (_OFF : $T0, _ALIGN : $T1) //TODO @gen: Validate the parameters were not passed by reference.
{
	(((_OFF)+((_ALIGN)-1))&~((_ALIGN)-1))// Memory align e.g. IM_ALIGN(0,4)=0, IM_ALIGN(1,4)=4, IM_ALIGN(4,4)=4, IM_ALIGN(5,4)=8
}

IM_F32_TO_INT8_UNBOUND :: #force_inline proc "contextless" (_VAL : $T0) //TODO @gen: Validate the parameters were not passed by reference.
{
	((int)((_VAL)*255.0+((_VAL)>=0?0.5:-0.5)))// Unsaturated, for display purpose
}

IM_F32_TO_INT8_SAT :: #force_inline proc "contextless" (_VAL : $T0) //TODO @gen: Validate the parameters were not passed by reference.
{
	((int)(ImSaturate(_VAL)*255.0+0.5))// Saturated, always output 0..255
}

IM_TRUNC :: #force_inline proc "contextless" (_VAL : $T0) //TODO @gen: Validate the parameters were not passed by reference.
{
	((float)(int)(_VAL))// ImTrunc() is not inlined in MSVC debug builds
}

IM_ROUND :: #force_inline proc "contextless" (_VAL : $T0) //TODO @gen: Validate the parameters were not passed by reference.
{
	((float)(int)((_VAL)+0.5))//
}

// Debug Tools
// Use 'Metrics/Debugger->Tools->Item Picker' to break into the call-stack of a specific item.
// This will call IM_DEBUG_BREAK() which you may redefine yourself. See https://github.com/scottt/debugbreak for more reference.
//when ! defined ( IM_DEBUG_BREAK ) {
IM_DEBUG_BREAK :: #force_inline proc "contextless" ()
{
	intrinsics.debug_trap()
}
//} // preproc endif// #ifndef IM_DEBUG_BREAK

// Format specifiers, printing 64-bit hasn't been decently standardized...
// In a real application you should be using PRId64 and PRIu64 from <inttypes.h> (non-windows) and on Windows define them yourself.
when true { // TODO(Rennorb) @cleanup
IM_PRId64 :: "I64d"
IM_PRIu64 :: "I64u"
IM_PRIX64 :: "I64X"
} else { // preproc else
IM_PRId64 :: "lld"
IM_PRIu64 :: "llu"
IM_PRIX64 :: "llX"
} // preproc endif

// Helpers: Sorting
//when ! defined ( ImQsort ) {
ImQsort :: #force_inline proc(base : rawptr, count : uint, size_of_element : uint, compare_func : proc(_ : rawptr, _ : rawptr) -> i32) { if count > 1 { qsort(base, count, size_of_element, compare_func) } }
//} // preproc endif

// Helpers: Bit manipulation
ImIsPowerOfTwo_0 :: #force_inline proc(v : i32) -> bool { return v != 0 && (v & (v - 1)) == 0 }
// Helpers: Bit manipulation
ImIsPowerOfTwo_1 :: #force_inline proc(v : ImU64) -> bool { return v != 0 && (v & (v - 1)) == 0 }
ImUpperPowerOfTwo :: #force_inline proc(v : i32) -> i32
{
	post_decr(&v); v |= v >> 1; v |= v >> 2; v |= v >> 4; v |= v >> 8; v |= v >> 16; post_incr(&v); return v
}

// Find beginning-of-line

ImToUpper :: #force_inline proc(c : u8) -> u8 { return (c >= 'a' && c <= 'z') ? c & !32 : c }
ImCharIsBlankA :: #force_inline proc(c : u8) -> bool { return c == ' ' || c == '\t' }
ImCharIsBlankW :: #force_inline proc(c : u32) -> bool { return c == ' ' || c == '\t' || c == 0x3000 }
ImCharIsXdigitA :: #force_inline proc(c : u8) -> bool { return (c >= '0' && c <= '9') || (c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f') }


// return number of lines taken by text. trailing carriage return doesn't count as an extra line.

// Helpers: File System
when IMGUI_DISABLE_FILE_FUNCTIONS {
ImFileHandle :: rawptr
ImFileOpen :: #force_inline proc(_ : ^u8, _ : ^u8) -> ImFileHandle { return nil }
ImFileClose :: #force_inline proc(_ : ImFileHandle) -> bool { return false }
ImFileGetSize :: #force_inline proc(_ : ImFileHandle) -> ImU64 { return cast(ImU64) -1 }
ImFileRead :: #force_inline proc(_ : rawptr, _ : ImU64, _ : ImU64, _ : ImFileHandle) -> ImU64 { return 0 }
ImFileWrite :: #force_inline proc(_ : rawptr, _ : ImU64, _ : ImU64, _ : ImFileHandle) -> ImU64 { return 0 }
} // preproc endif
when ! IMGUI_DISABLE_DEFAULT_FILE_FUNCTIONS {
ImFileHandle :: os.Handle
}
IMGUI_DISABLE_TTY_FUNCTIONS :: IMGUI_DISABLE_DEFAULT_FILE_FUNCTIONS // Can't use stdout, fflush if we are not using default file functions
// Helpers: Maths

// - Wrapper for standard libs functions. (Note that imgui_demo.cpp does _not_ use them to keep the code easy to copy)
ImFabs :: math.abs
ImSqrt :: math.sqrt
ImFmod :: math.mod
ImCos :: math.cos
ImSin :: math.sin
ImAcos :: math.acos
ImAtan2 :: math.atan2
ImAtof :: #force_inline proc "contextless" (STR : $T0) -> f64 { f, ok := strconv.parse_f64(STR); return ok ? f : 0 }
ImCeil :: math.ceil
ImPow :: math.pow // DragBehaviorT/SliderBehaviorT uses ImPow with either float/double and need the precision
ImLog :: #force_inline proc(x : $F) -> F { return math.log(x, math.e) }// DragBehaviorT/SliderBehaviorT uses ImLog with either float/double and need the precision
ImAbs :: math.abs
ImSign :: math.sign // Sign operator - returns -1, 0 or 1 based on sign of argument
ImRsqrt :: #force_inline proc "contextless" (v : $V) -> V { return 1 / math.sqrt(v) }

// - ImMin/ImMax/ImClamp/ImLerp/ImSwap are used by widgets which support variety of types: signed/unsigned int/long long float/double
// (Exceptionally using templates here but we could also redefine them for those types)
ImMin :: proc{ math.min, ImMin_v2 }
ImMax :: proc{ math.max, ImMax_v2 }
ImClamp :: #force_inline proc($T : typeid, v : T, mn : T, mx : T) -> T { return (v < mn) ? mn : (v > mx) ? mx : v }
ImLerp :: #force_inline proc($T : typeid, a : T, b : T, t : f32) -> T { return cast(T) (a + (b - a) * cast(T) t) }
ImSwap :: #force_inline proc($T : typeid, a : ^T, b : ^T) { tmp : T = a; a = b; b = tmp }
ImAddClampOverflow :: #force_inline proc($T : typeid, a : T, b : T, mn : T, mx : T) -> T
{
	if b < 0 && (a < mn - b) { return mn }; if b > 0 && (a > mx - b) { return mx }; return a + b
}
ImSubClampOverflow :: #force_inline proc($T : typeid, a : T, b : T, mn : T, mx : T) -> T
{
	if b > 0 && (a < mn + b) { return mn }; if b < 0 && (a > mx + b) { return mx }; return a - b
}
// - ImMin/ImMax/ImClamp/ImLerp/ImSwap are used by widgets which support variety of types: signed/unsigned int/long long float/double
// (Exceptionally using templates here but we could also redefine them for those types)
// - Misc maths helpers
ImMin_v2 :: #force_inline proc(lhs : ^ImVec2, rhs : ^ImVec2) -> ImVec2 { return ImVec2(lhs.x < rhs.x ? lhs.x : rhs.x, lhs.y < rhs.y ? lhs.y : rhs.y) }
ImMax_v2 :: #force_inline proc(lhs : ^ImVec2, rhs : ^ImVec2) -> ImVec2 { return ImVec2(lhs.x >= rhs.x ? lhs.x : rhs.x, lhs.y >= rhs.y ? lhs.y : rhs.y) }
ImClamp_v2 :: #force_inline proc(v : ^ImVec2, mn : ^ImVec2, mx : ^ImVec2) -> ImVec2 { return ImVec2((v.x < mn.x) ? mn.x : (v.x > mx.x) ? mx.x : v.x, (v.y < mn.y) ? mn.y : (v.y > mx.y) ? mx.y : v.y) }
ImLerp_v2_f :: #force_inline proc(a : ^ImVec2, b : ^ImVec2, t : f32) -> ImVec2 { return ImVec2(a.x + (b.x - a.x) * t, a.y + (b.y - a.y) * t) }
ImLerp_v2_v2 :: #force_inline proc(a : ^ImVec2, b : ^ImVec2, t : ^ImVec2) -> ImVec2 { return ImVec2(a.x + (b.x - a.x) * t.x, a.y + (b.y - a.y) * t.y) }
ImLerp_v4 :: #force_inline proc(a : ^ImVec4, b : ^ImVec4, t : f32) -> ImVec4 { return ImVec4(a.x + (b.x - a.x) * t, a.y + (b.y - a.y) * t, a.z + (b.z - a.z) * t, a.w + (b.w - a.w) * t) }
ImSaturate :: #force_inline proc(f : f32) -> f32 { return (f < 0.0) ? 0.0 : (f > 1.0) ? 1.0 : f }
ImLengthSqr_v2 :: #force_inline proc(lhs : ^ImVec2) -> f32 { return (lhs.x * lhs.x) + (lhs.y * lhs.y) }
ImLengthSqr_v4 :: #force_inline proc(lhs : ^ImVec4) -> f32 { return (lhs.x * lhs.x) + (lhs.y * lhs.y) + (lhs.z * lhs.z) + (lhs.w * lhs.w) }
ImInvLength :: #force_inline proc(lhs : ^ImVec2, fail_value : f32) -> f32
{
	d : f32 = (lhs.x * lhs.x) + (lhs.y * lhs.y); if d > 0.0 { return ImRsqrt(d) }; return fail_value
}
ImTrunc :: #force_inline proc(f : f32) -> f32 { return cast(f32) cast(i32) (f) }
ImTrunc_v2 :: #force_inline proc(v : ^ImVec2) -> ImVec2 { return ImVec2(cast(f32) cast(i32) (v.x), cast(f32) cast(i32) (v.y)) }
ImFloor :: #force_inline proc(f : f32) -> f32 { return cast(f32) ((f >= 0 || cast(f32) cast(i32) f == f) ? cast(i32) f : cast(i32) f - 1) }// Decent replacement for floorf()
ImFloor_v2 :: #force_inline proc(v : ^ImVec2) -> ImVec2 { return ImVec2(ImFloor(v.x), ImFloor(v.y)) }
ImModPositive :: #force_inline proc(a : i32, b : i32) -> i32 { return (a + b) % b }
ImDot :: #force_inline proc(a : ^ImVec2, b : ^ImVec2) -> f32 { return a.x * b.x + a.y * b.y }
ImRotate :: #force_inline proc(v : ^ImVec2, cos_a : f32, sin_a : f32) -> ImVec2 { return ImVec2(v.x * cos_a - v.y * sin_a, v.x * sin_a + v.y * cos_a) }
ImLinearSweep :: #force_inline proc(current : f32, target : f32, speed : f32) -> f32
{
	if current < target { return ImMin(current + speed, target) }; if current > target { return ImMax(current - speed, target) }; return current
}
ImLinearRemapClamp :: #force_inline proc(s0 : f32, s1 : f32, d0 : f32, d1 : f32, x : f32) -> f32 { return ImSaturate((x - s0) / (s1 - s0)) * (d1 - d0) + d0 }
ImMul :: #force_inline proc(lhs : ^ImVec2, rhs : ^ImVec2) -> ImVec2 { return ImVec2(lhs.x * rhs.x, lhs.y * rhs.y) }
ImIsFloatAboveGuaranteedIntegerPrecision :: #force_inline proc(f : f32) -> bool { return f <= -16777216 || f >= 16777216 }
ImExponentialMovingAverage :: #force_inline proc(avg : f32, sample : f32, n : i32) -> f32
{
	avg -= avg / n; avg += sample / n; return avg
}


ImTriangleArea :: #force_inline proc(a : ^ImVec2, b : ^ImVec2, c : ^ImVec2) -> f32 { return ImFabs((a.x * (b.y - c.y)) + (b.x * (c.y - a.y)) + (c.x * (a.y - b.y))) * 0.5 }
ImTriangleIsClockwise :: #force_inline proc(a : ^ImVec2, b : ^ImVec2, c : ^ImVec2) -> bool { return ((b.x - a.x) * (c.y - b.y)) - ((c.x - b.x) * (b.y - a.y)) > 0.0 }

// Helper: ImVec1 (1D vector)
// (this odd construct is used to facilitate the transition between 1D and 2D, and the maintenance of some branches/patches)

ImVec1 :: struct {
	x : f32,
}

ImVec1_init_0 :: proc(this : ^ImVec1)
{
	this.x = 0.0
}

ImVec1_init_1 :: proc(this : ^ImVec1, _x : f32)
{
	this.x = _x
}

// Helper: ImVec2ih (2D vector, half-size integer, for long-term packed storage)
ImVec2ih :: struct {
	x : i16, y : i16,
}

ImVec2ih_init_0 :: proc(this : ^ImVec2ih)
{
	this.x = 0
	this.y = 0
}

ImVec2ih_init_1 :: proc(this : ^ImVec2ih, _x : i16, _y : i16)
{
	this.x = _x
	this.y = _y
}

ImVec2ih_init_2 :: proc(this : ^ImVec2ih, rhs : ^ImVec2)
{
	this.x = cast(i16) rhs.x
	this.y = cast(i16) rhs.y
}

// Store 1-bit per value
// Helper: ImRect (2D axis aligned bounding-box)
// NB: we can't rely on ImVec2 math operators being available here!
ImRect :: struct {
	Min : ImVec2, // Upper-left
	Max : ImVec2, }

// Lower-right

ImRect_init_0 :: proc(this : ^ImRect)
{
	init(&this.Min, 0.0, 0.0)
	init(&this.Max, 0.0, 0.0)
}

ImRect_init_1 :: proc(this : ^ImRect, min : ^ImVec2, max : ^ImVec2)
{
	init(&this.Min, min)
	init(&this.Max, max)
}

ImRect_init_2 :: proc(this : ^ImRect, v : ^ImVec4)
{
	init(&this.Min, v.x, v.y)
	init(&this.Max, v.z, v.w)
}

ImRect_init_3 :: proc(this : ^ImRect, x1 : f32, y1 : f32, x2 : f32, y2 : f32)
{
	init(&this.Min, x1, y1)
	init(&this.Max, x2, y2)
}

ImRect_GetCenter :: proc(this : ^ImRect) -> ImVec2 { return ImVec2((this.Min.x + this.Max.x) * 0.5, (this.Min.y + this.Max.y) * 0.5) }

ImRect_GetSize :: proc(this : ^ImRect) -> ImVec2 { return ImVec2(this.Max.x - this.Min.x, this.Max.y - this.Min.y) }

ImRect_GetWidth :: proc(this : ^ImRect) -> f32 { return this.Max.x - this.Min.x }

ImRect_GetHeight :: proc(this : ^ImRect) -> f32 { return this.Max.y - this.Min.y }

ImRect_GetArea :: proc(this : ^ImRect) -> f32 { return (this.Max.x - this.Min.x) * (this.Max.y - this.Min.y) }

// Top-left
ImRect_GetTL :: proc(this : ^ImRect) -> ImVec2 { return this.Min }

// Top-right
ImRect_GetTR :: proc(this : ^ImRect) -> ImVec2 { return ImVec2(this.Max.x, this.Min.y) }

// Bottom-left
ImRect_GetBL :: proc(this : ^ImRect) -> ImVec2 { return ImVec2(this.Min.x, this.Max.y) }

// Bottom-right
ImRect_GetBR :: proc(this : ^ImRect) -> ImVec2 { return this.Max }

ImRect_Contains_0 :: proc(this : ^ImRect, p : ^ImVec2) -> bool { return p.x >= this.Min.x && p.y >= this.Min.y && p.x < this.Max.x && p.y < this.Max.y }

ImRect_Contains_1 :: proc(this : ^ImRect, r : ^ImRect) -> bool { return r.Min.x >= this.Min.x && r.Min.y >= this.Min.y && r.Max.x <= this.Max.x && r.Max.y <= this.Max.y }

ImRect_ContainsWithPad :: proc(this : ^ImRect, p : ^ImVec2, pad : ^ImVec2) -> bool { return p.x >= this.Min.x - pad.x && p.y >= this.Min.y - pad.y && p.x < this.Max.x + pad.x && p.y < this.Max.y + pad.y }

ImRect_Overlaps :: proc(this : ^ImRect, r : ^ImRect) -> bool { return r.Min.y < this.Max.y && r.Max.y > this.Min.y && r.Min.x < this.Max.x && r.Max.x > this.Min.x }

ImRect_Add_0 :: proc(this : ^ImRect, p : ^ImVec2)
{
	if this.Min.x > p.x { this.Min.x = p.x }; if this.Min.y > p.y { this.Min.y = p.y }; if this.Max.x < p.x { this.Max.x = p.x }; if this.Max.y < p.y { this.Max.y = p.y }
}

ImRect_Add_1 :: proc(this : ^ImRect, r : ^ImRect)
{
	if this.Min.x > r.Min.x { this.Min.x = r.Min.x }; if this.Min.y > r.Min.y { this.Min.y = r.Min.y }; if this.Max.x < r.Max.x { this.Max.x = r.Max.x }; if this.Max.y < r.Max.y { this.Max.y = r.Max.y }
}

ImRect_Expand_0 :: proc(this : ^ImRect, amount : f32)
{
	this.Min.x -= amount; this.Min.y -= amount; this.Max.x += amount; this.Max.y += amount
}

ImRect_Expand_1 :: proc(this : ^ImRect, amount : ^ImVec2)
{
	this.Min.x -= amount.x; this.Min.y -= amount.y; this.Max.x += amount.x; this.Max.y += amount.y
}

ImRect_Translate :: proc(this : ^ImRect, d : ^ImVec2)
{
	this.Min.x += d.x; this.Min.y += d.y; this.Max.x += d.x; this.Max.y += d.y
}

ImRect_TranslateX :: proc(this : ^ImRect, dx : f32)
{
	this.Min.x += dx; this.Max.x += dx
}

ImRect_TranslateY :: proc(this : ^ImRect, dy : f32)
{
	this.Min.y += dy; this.Max.y += dy
}

// Simple version, may lead to an inverted rectangle, which is fine for Contains/Overlaps test but not for display.
ImRect_ClipWith :: proc(this : ^ImRect, r : ^ImRect)
{
	this.Min = ImMax(this.Min, r.Min); this.Max = ImMin(this.Max, r.Max)
}

// Full version, ensure both points are fully clipped.
ImRect_ClipWithFull :: proc(this : ^ImRect, r : ^ImRect)
{
	this.Min = ImClamp(this.Min, r.Min, r.Max); this.Max = ImClamp(this.Max, r.Min, r.Max)
}

ImRect_Floor :: proc(this : ^ImRect)
{
	this.Min.x = IM_TRUNC(this.Min.x); this.Min.y = IM_TRUNC(this.Min.y); this.Max.x = IM_TRUNC(this.Max.x); this.Max.y = IM_TRUNC(this.Max.y)
}

ImRect_IsInverted :: proc(this : ^ImRect) -> bool { return this.Min.x > this.Max.x || this.Min.y > this.Max.y }

ImRect_ToVec4 :: proc(this : ^ImRect) -> ImVec4 { return ImVec4(this.Min.x, this.Min.y, this.Max.x, this.Max.y) }

// Helper: ImBitArray
IM_BITARRAY_TESTBIT :: #force_inline proc "contextless" (_ARRAY : $T0, #any_int _N : u32) -> bool
{
	// Macro version of ImBitArrayTestBit(): ensure args have side-effect or are costly!
	return (_ARRAY[_N >> 5] & (1 << (_N & 31))) != 0
}

IM_BITARRAY_CLEARBIT :: #force_inline proc "contextless" (_ARRAY : $T0, #any_int _N : u32)
{
	// Macro version of ImBitArrayClearBit(): ensure args have side-effect or are costly!
	_ARRAY[_N >> 5] &= !(1 << (_N & 31))
}

ImBitArrayGetStorageSizeInBytes :: #force_inline proc(bitcount : i32) -> uint { return cast(uint) ((bitcount + 31) >> 5) << 2 }
ImBitArrayClearAllBits :: #force_inline proc(arr : ^ImU32, bitcount : i32) { memset(arr, 0, ImBitArrayGetStorageSizeInBytes(bitcount)) }
ImBitArrayTestBit :: #force_inline proc(arr : ^ImU32, n : i32) -> bool
{
	mask : ImU32 = cast(ImU32) 1 << (n & 31); return (arr[n >> 5] & mask) != 0
}
ImBitArrayClearBit :: #force_inline proc(arr : ^ImU32, n : i32)
{
	mask : ImU32 = cast(ImU32) 1 << (n & 31); arr[n >> 5] &= !mask
}
ImBitArraySetBit :: #force_inline proc(arr : ^ImU32, n : i32)
{
	mask : ImU32 = cast(ImU32) 1 << (n & 31); arr[n >> 5] |= mask
}
// Works on range [n..n2)
ImBitArraySetBitRange :: #force_inline proc(arr : ^ImU32, n : i32, n2 : i32)
{
	post_decr(&n2)
	for n <= n2 {
		a_mod : i32 = (n & 31)
		b_mod : i32 = (n2 > (n | 31) ? 31 : (n2 & 31)) + 1
		mask : ImU32 = cast(ImU32) ((cast(ImU64) 1 << b_mod) - 1) & !cast(ImU32) ((cast(ImU64) 1 << a_mod) - 1)
		arr[n >> 5] |= mask
		n = (n + 32) & !31
	}
}

ImBitArrayPtr :: ^ImU32// Name for use in structs

// Helper: ImBitArray class (wrapper over ImBitArray functions)
// Store 1-bit per value.
ImBitArray :: struct($BITCOUNT : i32, $OFFSET : i32 = 0) {
	Storage : [(BITCOUNT + 31) >> 5]ImU32,
}

ImBitArray_init :: proc(this : ^ImBitArray($BITCOUNT, $OFFSET)) { ClearAllBits() }

ImBitArray_ClearAllBits :: proc(this : ^ImBitArray($BITCOUNT, $OFFSET)) { memset(this.Storage, 0, size_of(Storage)) }

ImBitArray_SetAllBits :: proc(this : ^ImBitArray($BITCOUNT, $OFFSET)) { memset(this.Storage, 255, size_of(Storage)) }

ImBitArray_TestBit :: proc(this : ^ImBitArray($BITCOUNT, $OFFSET), n : i32) -> bool
{
	n += OFFSET; IM_ASSERT(n >= 0 && n < BITCOUNT); return IM_BITARRAY_TESTBIT(this.Storage, n)
}

ImBitArray_SetBit :: proc(this : ^ImBitArray($BITCOUNT, $OFFSET), n : i32)
{
	n += OFFSET; IM_ASSERT(n >= 0 && n < BITCOUNT); ImBitArraySetBit(this.Storage, n)
}

ImBitArray_ClearBit :: proc(this : ^ImBitArray($BITCOUNT, $OFFSET), n : i32)
{
	n += OFFSET; IM_ASSERT(n >= 0 && n < BITCOUNT); ImBitArrayClearBit(this.Storage, n)
}

// Works on range [n..n2)
ImBitArray_SetBitRange :: proc(this : ^ImBitArray($BITCOUNT, $OFFSET), n : i32, n2 : i32)
{
	n += OFFSET; n2 += OFFSET; IM_ASSERT(n >= 0 && n < BITCOUNT && n2 > n && n2 <= BITCOUNT); ImBitArraySetBitRange(this.Storage, n, n2)
}

//-----------------------------------------------------------------------------
// [SECTION] Forward declarations
//-----------------------------------------------------------------------------

// Helper: ImBitVector
// Store 1-bit per value.
ImBitVector :: struct {
	Storage : ImVector(ImU32),
}

ImBitVector_Create :: proc(this : ^ImBitVector, sz : i32)
{
	resize(&this.Storage, (sz + 31) >> 5); memset(this.Storage.Data, 0, cast(uint) this.Storage.Size * size_of(this.Storage.Data[0]))
}

ImBitVector_Clear :: proc(this : ^ImBitVector) { clear(&this.Storage) }

ImBitVector_TestBit :: proc(this : ^ImBitVector, n : i32) -> bool
{
	IM_ASSERT(n < (this.Storage.Size << 5)); return IM_BITARRAY_TESTBIT(this.Storage.Data, n)
}

ImBitVector_SetBit :: proc(this : ^ImBitVector, n : i32)
{
	IM_ASSERT(n < (this.Storage.Size << 5)); ImBitArraySetBit(this.Storage.Data, n)
}

ImBitVector_ClearBit :: proc(this : ^ImBitVector, n : i32)
{
	IM_ASSERT(n < (this.Storage.Size << 5)); ImBitArrayClearBit(this.Storage.Data, n)
}


// Helper: ImSpan<>
// Pointing to a span of data we don't own.
ImSpan :: struct($T : typeid) {
	Data : ^T,
	DataEnd : ^T,

}

// Constructors, destructor
ImSpan_init_0 :: #force_inline proc(this : ^ImSpan($T)) { this.DataEnd = nil; this.Data = this.DataEnd }

ImSpan_init_1 :: #force_inline proc(this : ^ImSpan($T), data : ^T, size : i32)
{
	this.Data = data; this.DataEnd = data + size
}

ImSpan_init_2 :: #force_inline proc(this : ^ImSpan($T), data : ^T, data_end : ^T)
{
	this.Data = data; this.DataEnd = data_end
}

ImSpan_set_0 :: #force_inline proc(this : ^ImSpan($T), data : ^T, size : i32)
{
	this.Data = data; this.DataEnd = data + size
}

ImSpan_set_1 :: #force_inline proc(this : ^ImSpan($T), data : ^T, data_end : ^T)
{
	this.Data = data; this.DataEnd = data_end
}

ImSpan_size :: #force_inline proc(this : ^ImSpan($T)) -> i32 { return cast(i32) cast(int) (this.DataEnd - this.Data) }

ImSpan_size_in_bytes :: #force_inline proc(this : ^ImSpan($T)) -> i32 { return cast(i32) cast(int) (this.DataEnd - this.Data) * cast(i32) size_of(T) }

ImSpan_begin_0 :: #force_inline proc(this : ^ImSpan($T)) -> ^T { return this.Data }

ImSpan_begin_1 :: #force_inline proc(this : ^ImSpan($T)) -> ^T { return this.Data }

ImSpan_end_0 :: #force_inline proc(this : ^ImSpan($T)) -> ^T { return this.DataEnd }

ImSpan_end_1 :: #force_inline proc(this : ^ImSpan($T)) -> ^T { return this.DataEnd }

// Utilities
ImSpan_index_from_ptr :: #force_inline proc(this : ^ImSpan($T), it : ^T) -> i32
{
	IM_ASSERT(it >= this.Data && it < this.DataEnd); off : int = it - this.Data; return cast(i32) off
}

// Helper: ImSpanAllocator<>
// Facilitate storing multiple chunks into a single large block (the "arena")
// - Usage: call Reserve() N times, allocate GetArenaSizeInBytes() worth, pass it to SetArenaBasePtr(), call GetSpan() N times to retrieve the aligned ranges.
ImSpanAllocator :: struct($CHUNKS : i32) {
	BasePtr : ^u8,
	CurrOff : i32,
	CurrIdx : i32,
	Offsets : [CHUNKS]i32,
	Sizes : [CHUNKS]i32,
}

ImSpanAllocator_init :: proc(this : ^ImSpanAllocator($CHUNKS)) { memset(this, 0, size_of(this)) }

ImSpanAllocator_Reserve :: #force_inline proc(this : ^ImSpanAllocator($CHUNKS), n : i32, sz : uint, a : i32 = 4)
{
	IM_ASSERT(n == this.CurrIdx && n < CHUNKS); this.CurrOff = IM_MEMALIGN(this.CurrOff, a); this.Offsets[n] = this.CurrOff; this.Sizes[n] = cast(i32) sz; post_incr(&this.CurrIdx); this.CurrOff += cast(i32) sz
}

ImSpanAllocator_GetArenaSizeInBytes :: #force_inline proc(this : ^ImSpanAllocator($CHUNKS)) -> i32 { return this.CurrOff }

ImSpanAllocator_SetArenaBasePtr :: #force_inline proc(this : ^ImSpanAllocator($CHUNKS), base_ptr : rawptr) { this.BasePtr = cast(^u8) base_ptr }

ImSpanAllocator_GetSpanPtrBegin :: #force_inline proc(this : ^ImSpanAllocator($CHUNKS), n : i32) -> rawptr
{
	IM_ASSERT(n >= 0 && n < CHUNKS && this.CurrIdx == CHUNKS); return cast(rawptr) (this.BasePtr + this.Offsets[n])
}

ImSpanAllocator_GetSpanPtrEnd :: #force_inline proc(this : ^ImSpanAllocator($CHUNKS), n : i32) -> rawptr
{
	IM_ASSERT(n >= 0 && n < CHUNKS && this.CurrIdx == CHUNKS); return cast(rawptr) (this.BasePtr + this.Offsets[n] + this.Sizes[n])
}

ImSpanAllocator_GetSpan :: #force_inline proc($T : typeid, this : ^ImSpanAllocator($CHUNKS), n : i32, span : ^ImSpan(T)) { set(span, cast(^T) GetSpanPtrBegin(n), cast(^T) GetSpanPtrEnd(n)) }

// Helper: ImPool<>
// Basic keyed storage for contiguous instances, slow/amortized insertion, O(1) indexable, O(Log N) queries by ID over a dense/hot buffer,
// Honor constructor/destructor. Add/remove invalidate all pointers. Indexes have the same lifetime as the associated object.
ImPoolIdx :: i32
ImPool :: struct($T : typeid) {
	Buf : ImVector(T), // Contiguous data
	Map : ImGuiStorage, // ID->Index
	FreeIdx : ImPoolIdx, // Next free idx to use
	AliveCount : ImPoolIdx,
}

ImPool_deinit :: proc(this : ^ImPool)
{Clear()}

// Number of active/alive items (for display purpose)

ImPool_init :: proc(this : ^ImPool($T)) { this.AliveCount = 0; this.FreeIdx = this.AliveCount }

ImPool_GetByKey :: proc(this : ^ImPool($T), key : ImGuiID) -> ^T
{
	idx : i32 = GetInt(&this.Map, key, -1); return (idx != -1) ? &this.Buf[idx] : nil
}

ImPool_GetByIndex :: proc(this : ^ImPool($T), n : ImPoolIdx) -> ^T { return &this.Buf[n] }

ImPool_GetIndex :: proc(this : ^ImPool($T), p : ^T) -> ImPoolIdx
{
	IM_ASSERT(p >= this.Buf.Data && p < this.Buf.Data + this.Buf.Size); return cast(ImPoolIdx) (p - this.Buf.Data)
}

ImPool_GetOrAddByKey :: proc(this : ^ImPool($T), key : ImGuiID) -> ^T
{
	p_idx : ^i32 = GetIntRef(&this.Map, key, -1); if p_idx^ != -1 { return &this.Buf[p_idx^] }; p_idx^ = this.FreeIdx; return Add()
}

ImPool_Contains :: proc(this : ^ImPool($T), p : ^T) -> bool { return (p >= this.Buf.Data && p < this.Buf.Data + this.Buf.Size) }

ImPool_Clear :: proc(this : ^ImPool($T))
{
	for n : i32 = 0; n < this.Map.Data.Size; post_incr(&n) {idx : i32 = this.Map.Data[n].val_i; if idx != -1 { deinit(&this.Buf[idx]) }	}; 

Clear(&this.Map); clear(&this.Buf); this.AliveCount = 0; this.FreeIdx = this.AliveCount
}

ImPool_Add :: proc(this : ^ImPool($T)) -> ^T
{
	idx : i32 = this.FreeIdx;
	if idx == this.Buf.Size {
		resize(&this.Buf, this.Buf.Size + 1); post_incr(&this.FreeIdx)
	}
	else {
		this.FreeIdx = (cast(^i32) &this.Buf[idx])^
	};
	T(); post_incr(&this.AliveCount); return &this.Buf[idx]
}

ImPool_Remove_0 :: proc(this : ^ImPool($T), key : ImGuiID, p : ^T) { Remove(key, GetIndex(p)) }

ImPool_Remove_1 :: proc(this : ^ImPool($T), key : ImGuiID, idx : ImPoolIdx)
{
	deinit(&this.Buf[idx]);
	(cast(^i32) &this.Buf[idx])^ = this.FreeIdx;
	this.FreeIdx = idx;
	SetInt(&this.Map, key, -1);
	post_decr(&this.AliveCount)
}

ImPool_Reserve :: proc(this : ^ImPool($T), capacity : i32)
{
	reserve(&this.Buf, capacity); reserve(&this.Map.Data, capacity)
}

// To iterate a ImPool: for (int n = 0; n < pool.GetMapSize(); n++) if (T* t = pool.TryGetMapData(n)) { ... }
// Can be avoided if you know .Remove() has never been called on the pool, or AliveCount == GetMapSize()
// Number of active/alive items in the pool (for display purpose)
ImPool_GetAliveCount :: proc(this : ^ImPool($T)) -> i32 { return this.AliveCount }

ImPool_GetBufSize :: proc(this : ^ImPool($T)) -> i32 { return this.Buf.Size }

// It is the map we need iterate to find valid items, since we don't have "alive" storage anywhere
ImPool_GetMapSize :: proc(this : ^ImPool($T)) -> i32 { return this.Map.Data.Size }

ImPool_TryGetMapData :: proc(this : ^ImPool($T), n : ImPoolIdx) -> ^T
{
	idx : i32 = this.Map.Data[n].val_i; if idx == -1 { return nil }; return GetByIndex(idx)
}

// Helper: ImChunkStream<>
// Build and iterate a contiguous stream of variable-sized structures.
// This is used by Settings to store persistent data while reducing allocation count.
// We store the chunk size first, and align the final size on 4 bytes boundaries.
// The tedious/zealous amount of casting is to avoid -Wcast-align warnings.
ImChunkStream :: struct($T : typeid) {
	Buf : ImVector(u8),
}

ImChunkStream_clear :: proc(this : ^ImChunkStream($T)) { clear(&this.Buf) }

ImChunkStream_empty :: proc(this : ^ImChunkStream($T)) -> bool { return this.Buf.Size == 0 }

ImChunkStream_size :: proc(this : ^ImChunkStream($T)) -> i32 { return this.Buf.Size }

ImChunkStream_alloc_chunk :: proc(this : ^ImChunkStream($T), sz : uint) -> ^T
{
	HDR_SZ : uint = 4; sz = IM_MEMALIGN(HDR_SZ + sz, 4); off : i32 = this.Buf.Size; resize(&this.Buf, off + cast(i32) sz); (cast(^i32) cast(rawptr) (this.Buf.Data + off))[0] = cast(i32) sz; return cast(^T) cast(rawptr) (this.Buf.Data + off + cast(i32) HDR_SZ)
}

ImChunkStream_begin :: proc(this : ^ImChunkStream($T)) -> ^T
{
	HDR_SZ : uint = 4; if !this.Buf.Data { return nil }; return cast(^T) cast(rawptr) (this.Buf.Data + HDR_SZ)
}

ImChunkStream_next_chunk :: proc(this : ^ImChunkStream($T), p : ^T) -> ^T
{
	HDR_SZ : uint = 4; IM_ASSERT(p >= begin() && p < end()); p = cast(^T) cast(rawptr) (cast(^u8) cast(rawptr) p + chunk_size(p)); if p == cast(^T) cast(rawptr) (cast(^u8) end() + HDR_SZ) { return cast(^T) 0 }; IM_ASSERT(p < end()); return p
}

ImChunkStream_chunk_size :: proc(this : ^ImChunkStream($T), p : ^T) -> i32 { return (cast(^i32) p)[-1] }

ImChunkStream_end :: proc(this : ^ImChunkStream($T)) -> ^T { return cast(^T) cast(rawptr) (this.Buf.Data + this.Buf.Size) }

ImChunkStream_offset_from_ptr :: proc(this : ^ImChunkStream($T), p : ^T) -> i32
{
	IM_ASSERT(p >= begin() && p < end()); off : int = cast(^u8) p - this.Buf.Data; return cast(i32) off
}

ImChunkStream_ptr_from_offset :: proc(this : ^ImChunkStream($T), off : i32) -> ^T
{
	IM_ASSERT(off >= 4 && off < this.Buf.Size); return cast(^T) cast(rawptr) (this.Buf.Data + off)
}

ImChunkStream_swap :: proc(this : ^ImChunkStream($T), rhs : ^ImChunkStream(T)) { swap(&rhs.Buf, this.Buf) }

// Helper: ImGuiTextIndex
// Maintain a line index for a text buffer. This is a strong candidate to be moved into the public API.
ImGuiTextIndex :: struct {
	LineOffsets : ImVector(i32),
	EndOffset : i32, }

// Because we don't own text buffer we need to maintain EndOffset (may bake in LineOffsets?)

ImGuiTextIndex_clear :: proc(this : ^ImGuiTextIndex)
{
	clear(&this.LineOffsets); this.EndOffset = 0
}

ImGuiTextIndex_size :: proc(this : ^ImGuiTextIndex) -> i32 { return this.LineOffsets.Size }

ImGuiTextIndex_get_line_begin :: proc(this : ^ImGuiTextIndex, base : ^u8, n : i32) -> ^u8 { return base + this.LineOffsets[n] }

ImGuiTextIndex_get_line_end :: proc(this : ^ImGuiTextIndex, base : ^u8, n : i32) -> ^u8 { return base + (n + 1 < this.LineOffsets.Size ? (this.LineOffsets[n + 1] - 1) : this.EndOffset) }

ImGuiTextIndex_init :: proc(this : ^ImGuiTextIndex) { this.EndOffset = 0 }

//-----------------------------------------------------------------------------
// [SECTION] ImDrawList support
//-----------------------------------------------------------------------------

// ImDrawList: Helper function to calculate a circle's segment count given its radius and a "maximum error" value.
// Estimation of number of circle segment based on error is derived using method described in https://stackoverflow.com/a/2244088/15194693
// Number of segments (N) is calculated using equation:
//   N = ceil ( pi / acos(1 - error / r) )     where r > 0, error <= r
// Our equation is significantly simpler that one in the post thanks for choosing segment that is
// perpendicular to X axis. Follow steps in the article from this starting condition and you will
// will get this result.
//
// Rendering circles with an odd number of segments, while mathematically correct will produce
// asymmetrical results on the raster grid. Therefore we're rounding N to next even number (7->8, 8->8, 9->10 etc.)
IM_ROUNDUP_TO_EVEN :: #force_inline proc "contextless" (_V : $T0) //TODO @gen: Validate the parameters were not passed by reference.
{
	((((_V)+1)/2)*2)
}

IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_MIN :: 4
IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_MAX :: 512
IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_CALC :: #force_inline proc "contextless" (_RAD : $T0, _MAXERROR : $T1) -> T1
{
	return ImClamp(IM_ROUNDUP_TO_EVEN(cast(int) ImCeil(IM_PI / ImAcos(1 - ImMin(_MAXERROR, _RAD) / _RAD))), IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_MIN, IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_MAX)
}


// Raw equation from IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_CALC rewritten for 'r' and 'error'.
IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_CALC_R :: #force_inline proc "contextless" (_N : $T0, _MAXERROR : $T1) -> T1
{
	return _MAXERROR / (1 - ImCos(IM_PI / ImMax(cast(f32)_N, IM_PI)))
}

IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_CALC_ERROR :: #force_inline proc "contextless" (_N : $T0, _RAD : $T1) -> T1
{
	return (1 - ImCos(IM_PI / ImMax(cast(f32)_N, IM_PI))) / _RAD
}


// ImDrawList: Lookup table size for adaptive arc drawing, cover full circle.
//when ! defined ( IM_DRAWLIST_ARCFAST_TABLE_SIZE ) {
IM_DRAWLIST_ARCFAST_TABLE_SIZE :: 48// Number of samples in lookup table.
//} // preproc endif
IM_DRAWLIST_ARCFAST_SAMPLE_MAX :: IM_DRAWLIST_ARCFAST_TABLE_SIZE// Sample index _PathArcToFastEx() for 360 angle.

// A single draw command list (generally one per window, conceptually you may see this as a dynamic "mesh" builder)
// Helper to build a ImDrawData instance
// Data shared between all ImDrawList instances
// Conceptually this could have been called e.g. ImDrawListSharedContext
// Typically one ImGui context would create and maintain one of this.
// You may want to create your own instance of you try to ImDrawList completely without ImGui. In that case, watch out for future changes to this structure.
ImDrawListSharedData :: struct {
	TexUvWhitePixel : ImVec2, // UV of white pixel in the atlas
	TexUvLines : ^ImVec4, // UV of anti-aliased lines in the atlas
	Font : ^ImFont, // Current/default font (optional, for simplified AddText overload)
	FontSize : f32, // Current/default font size (optional, for simplified AddText overload)
	FontScale : f32, // Current/default font scale (== FontSize / Font->FontSize)
	CurveTessellationTol : f32, // Tessellation tolerance when using PathBezierCurveTo()
	CircleSegmentMaxError : f32, // Number of circle segments to use per pixel of radius for AddCircle() etc
	ClipRectFullscreen : ImVec4, // Value for PushClipRectFullscreen()
	InitialFlags : ImDrawListFlags, // Initial flags at the beginning of the frame (it is possible to alter flags on a per-drawlist basis afterwards)
	TempBuffer : ImVector(ImVec2), // Temporary write buffer

	// Lookup tables
	ArcFastVtx : [IM_DRAWLIST_ARCFAST_TABLE_SIZE]ImVec2, // Sample points on the quarter of the circle.
	ArcFastRadiusCutoff : f32, // Cutoff radius after which arc drawing will fallback to slower PathArcTo()
	CircleSegmentCounts : [64]ImU8, }

// An axis-aligned rectangle (2 points)
ImDrawDataBuilder :: struct {
	Layers : [2]^ImVector(^ImDrawList), // Pointers to global layers for: regular, tooltip. LayersP[0] is owned by DrawData.
	LayerData1 : ImVector(^ImDrawList),
}

ImDrawDataBuilder_init :: proc(this : ^ImDrawDataBuilder) { memset(this, 0, size_of(this)) }

// Hook for extensions like ImGuiTestEngine
//-----------------------------------------------------------------------------
// [SECTION] Data types support
//-----------------------------------------------------------------------------

ImGuiDataVarInfo :: struct {
	Type : ImGuiDataType,
	Count : ImU32, // 1+
	Offset : ImU32, }

// Offset in parent structure
ImGuiDataVarInfo_GetVarPtr :: proc(this : ^ImGuiDataVarInfo, parent : rawptr) -> rawptr { return cast(rawptr) (cast(^u8) parent + this.Offset) }

ImGuiDataTypeStorage :: struct {
	Data : [8]ImU8, // Opaque storage to fit any data up to ImGuiDataType_COUNT
}

// Variable information (e.g. to access style variables from an enum)
// Type information associated to one ImGuiDataType. Retrieve with DataTypeGetInfo().
ImGuiDataTypeInfo :: struct {
	Size : uint, // Size in bytes
	Name : ^u8, // Short descriptive name for the type, for debugging
	PrintFmt : ^u8, // Default printf format for the type
	ScanFmt : ^u8, // Default scanf format for the type
}

// Extend ImGuiDataType_
ImGuiDataTypePrivate_ :: enum i32 {
	ImGuiDataType_Pointer = i32(ImGuiDataType_.ImGuiDataType_COUNT) + 1,
	ImGuiDataType_ID,
}

//-----------------------------------------------------------------------------
// [SECTION] Widgets support: flags, enums, data structures
//-----------------------------------------------------------------------------

// Extend ImGuiItemFlags
// - input: PushItemFlag() manipulates g.CurrentItemFlags, g.NextItemData.ItemFlags, ItemAdd() calls may add extra flags too.
// - output: stored in g.LastItemData.ItemFlags
ImGuiItemFlagsPrivate_ :: enum i32 {
	// Controlled by user
	ImGuiItemFlags_Disabled = 1 << 10, // false     // Disable interactions (DOES NOT affect visuals. DO NOT mix direct use of this with BeginDisabled(). See BeginDisabled()/EndDisabled() for full disable feature, and github #211).
	ImGuiItemFlags_ReadOnly = 1 << 11, // false     // [ALPHA] Allow hovering interactions but underlying value is not changed.
	ImGuiItemFlags_MixedValue = 1 << 12, // false     // [BETA] Represent a mixed/indeterminate value, generally multi-selection where values differ. Currently only supported by Checkbox() (later should support all sorts of widgets)
	ImGuiItemFlags_NoWindowHoverableCheck = 1 << 13, // false     // Disable hoverable check in ItemHoverable()
	ImGuiItemFlags_AllowOverlap = 1 << 14, // false     // Allow being overlapped by another widget. Not-hovered to Hovered transition deferred by a frame.
	ImGuiItemFlags_NoNavDisableMouseHover = 1 << 15, // false     // Nav keyboard/gamepad mode doesn't disable hover highlight (behave as if NavHighlightItemUnderNav==false).
	ImGuiItemFlags_NoMarkEdited = 1 << 16, // false     // Skip calling MarkItemEdited()

	// Controlled by widget code
	ImGuiItemFlags_Inputable = 1 << 20, // false     // [WIP] Auto-activate input mode when tab focused. Currently only used and supported by a few items before it becomes a generic feature.
	ImGuiItemFlags_HasSelectionUserData = 1 << 21, // false     // Set by SetNextItemSelectionUserData()
	ImGuiItemFlags_IsMultiSelect = 1 << 22, // false     // Set by SetNextItemSelectionUserData()

	ImGuiItemFlags_Default_ = i32(ImGuiItemFlags_.ImGuiItemFlags_AutoClosePopups), // Please don't change, use PushItemFlag() instead.

	// Obsolete
	//ImGuiItemFlags_SelectableDontClosePopup = !ImGuiItemFlags_AutoClosePopups, // Can't have a redirect as we inverted the behavior
}

when IMGUI_ENABLE_TEST_ENGINE {
// Status flags for an already submitted item
// - output: stored in g.LastItemData.StatusFlags
ImGuiItemStatusFlags_ :: enum i32 {
	ImGuiItemStatusFlags_None = 0,
	ImGuiItemStatusFlags_HoveredRect = 1 << 0, // Mouse position is within item rectangle (does NOT mean that the window is in correct z-order and can be hovered!, this is only one part of the most-common IsItemHovered test)
	ImGuiItemStatusFlags_HasDisplayRect = 1 << 1, // g.LastItemData.DisplayRect is valid
	ImGuiItemStatusFlags_Edited = 1 << 2, // Value exposed by item was edited in the current frame (should match the bool return value of most widgets)
	ImGuiItemStatusFlags_ToggledSelection = 1 << 3, // Set when Selectable(), TreeNode() reports toggling a selection. We can't report "Selected", only state changes, in order to easily handle clipping with less issues.
	ImGuiItemStatusFlags_ToggledOpen = 1 << 4, // Set when TreeNode() reports toggling their open state.
	ImGuiItemStatusFlags_HasDeactivated = 1 << 5, // Set if the widget/group is able to provide data for the ImGuiItemStatusFlags_Deactivated flag.
	ImGuiItemStatusFlags_Deactivated = 1 << 6, // Only valid if ImGuiItemStatusFlags_HasDeactivated is set.
	ImGuiItemStatusFlags_HoveredWindow = 1 << 7, // Override the HoveredWindow test to allow cross-window hover testing.
	ImGuiItemStatusFlags_Visible = 1 << 8, // [WIP] Set when item is overlapping the current clipping rectangle (Used internally. Please don't use yet: API/system will change as we refactor Itemadd()).
	ImGuiItemStatusFlags_HasClipRect = 1 << 9, // g.LastItemData.ClipRect is valid.
	ImGuiItemStatusFlags_HasShortcut = 1 << 10, // g.LastItemData.Shortcut valid. Set by SetNextItemShortcut() -> ItemAdd().

	// Additional status + semantic for ImGuiTestEngine
	ImGuiItemStatusFlags_Openable = 1 << 20, // Item is an openable (e.g. TreeNode)
	ImGuiItemStatusFlags_Opened = 1 << 21, // Opened status
	ImGuiItemStatusFlags_Checkable = 1 << 22, // Item is a checkable (e.g. CheckBox, MenuItem)
	ImGuiItemStatusFlags_Checked = 1 << 23, // Checked status
	ImGuiItemStatusFlags_Inputable = 1 << 24, // Item is a text-inputable (e.g. InputText, SliderXXX, DragXXX)
}
} else { // preproc else
// Status flags for an already submitted item
// - output: stored in g.LastItemData.StatusFlags
ImGuiItemStatusFlags_ :: enum i32 {
	ImGuiItemStatusFlags_None = 0,
	ImGuiItemStatusFlags_HoveredRect = 1 << 0, // Mouse position is within item rectangle (does NOT mean that the window is in correct z-order and can be hovered!, this is only one part of the most-common IsItemHovered test)
	ImGuiItemStatusFlags_HasDisplayRect = 1 << 1, // g.LastItemData.DisplayRect is valid
	ImGuiItemStatusFlags_Edited = 1 << 2, // Value exposed by item was edited in the current frame (should match the bool return value of most widgets)
	ImGuiItemStatusFlags_ToggledSelection = 1 << 3, // Set when Selectable(), TreeNode() reports toggling a selection. We can't report "Selected", only state changes, in order to easily handle clipping with less issues.
	ImGuiItemStatusFlags_ToggledOpen = 1 << 4, // Set when TreeNode() reports toggling their open state.
	ImGuiItemStatusFlags_HasDeactivated = 1 << 5, // Set if the widget/group is able to provide data for the ImGuiItemStatusFlags_Deactivated flag.
	ImGuiItemStatusFlags_Deactivated = 1 << 6, // Only valid if ImGuiItemStatusFlags_HasDeactivated is set.
	ImGuiItemStatusFlags_HoveredWindow = 1 << 7, // Override the HoveredWindow test to allow cross-window hover testing.
	ImGuiItemStatusFlags_Visible = 1 << 8, // [WIP] Set when item is overlapping the current clipping rectangle (Used internally. Please don't use yet: API/system will change as we refactor Itemadd()).
	ImGuiItemStatusFlags_HasClipRect = 1 << 9, // g.LastItemData.ClipRect is valid.
	ImGuiItemStatusFlags_HasShortcut = 1 << 10, // g.LastItemData.Shortcut valid. Set by SetNextItemShortcut() -> ItemAdd().
}
} // preproc endif

// Extend ImGuiHoveredFlags_
ImGuiHoveredFlagsPrivate_ :: enum i32 {
	ImGuiHoveredFlags_DelayMask_ = i32(ImGuiHoveredFlags_.ImGuiHoveredFlags_DelayNone | ImGuiHoveredFlags_.ImGuiHoveredFlags_DelayShort | ImGuiHoveredFlags_.ImGuiHoveredFlags_DelayNormal | ImGuiHoveredFlags_.ImGuiHoveredFlags_NoSharedDelay),
	ImGuiHoveredFlags_AllowedMaskForIsWindowHovered = i32(ImGuiHoveredFlags_.ImGuiHoveredFlags_ChildWindows | ImGuiHoveredFlags_.ImGuiHoveredFlags_RootWindow | ImGuiHoveredFlags_.ImGuiHoveredFlags_AnyWindow | ImGuiHoveredFlags_.ImGuiHoveredFlags_NoPopupHierarchy | ImGuiHoveredFlags_.ImGuiHoveredFlags_DockHierarchy | ImGuiHoveredFlags_.ImGuiHoveredFlags_AllowWhenBlockedByPopup | ImGuiHoveredFlags_.ImGuiHoveredFlags_AllowWhenBlockedByActiveItem | ImGuiHoveredFlags_.ImGuiHoveredFlags_ForTooltip | ImGuiHoveredFlags_.ImGuiHoveredFlags_Stationary),
	ImGuiHoveredFlags_AllowedMaskForIsItemHovered = i32(ImGuiHoveredFlags_.ImGuiHoveredFlags_AllowWhenBlockedByPopup | ImGuiHoveredFlags_.ImGuiHoveredFlags_AllowWhenBlockedByActiveItem | ImGuiHoveredFlags_.ImGuiHoveredFlags_AllowWhenOverlapped | ImGuiHoveredFlags_.ImGuiHoveredFlags_AllowWhenDisabled | ImGuiHoveredFlags_.ImGuiHoveredFlags_NoNavOverride | ImGuiHoveredFlags_.ImGuiHoveredFlags_ForTooltip | ImGuiHoveredFlags_.ImGuiHoveredFlags_Stationary) | i32(ImGuiHoveredFlags_DelayMask_),
}

// Extend ImGuiInputTextFlags_
ImGuiInputTextFlagsPrivate_ :: enum i32 {
	// [Internal]
	ImGuiInputTextFlags_Multiline = 1 << 26, // For internal use by InputTextMultiline()
	ImGuiInputTextFlags_MergedItem = 1 << 27, // For internal use by TempInputText(), will skip calling ItemAdd(). Require bounding-box to strictly match.
	ImGuiInputTextFlags_LocalizeDecimalPoint = 1 << 28, // For internal use by InputScalar() and TempInputScalar()
}

// Extend ImGuiButtonFlags_
ImGuiButtonFlagsPrivate_ :: enum i32 {
	ImGuiButtonFlags_PressedOnClick = 1 << 4, // return true on click (mouse down event)
	ImGuiButtonFlags_PressedOnClickRelease = 1 << 5, // [Default] return true on click + release on same item <-- this is what the majority of Button are using
	ImGuiButtonFlags_PressedOnClickReleaseAnywhere = 1 << 6, // return true on click + release even if the release event is not done while hovering the item
	ImGuiButtonFlags_PressedOnRelease = 1 << 7, // return true on release (default requires click+release)
	ImGuiButtonFlags_PressedOnDoubleClick = 1 << 8, // return true on double-click (default requires click+release)
	ImGuiButtonFlags_PressedOnDragDropHold = 1 << 9, // return true when held into while we are drag and dropping another item (used by e.g. tree nodes, collapsing headers)
	//ImGuiButtonFlags_Repeat               = 1 << 10,  // hold to repeat -> use ImGuiItemFlags_ButtonRepeat instead.
	ImGuiButtonFlags_FlattenChildren = 1 << 11, // allow interactions even if a child window is overlapping
	ImGuiButtonFlags_AllowOverlap = 1 << 12, // require previous frame HoveredId to either match id or be null before being usable.
	//ImGuiButtonFlags_DontClosePopups      = 1 << 13,  // disable automatically closing parent popup on press
	//ImGuiButtonFlags_Disabled             = 1 << 14,  // disable interactions -> use BeginDisabled() or ImGuiItemFlags_Disabled
	ImGuiButtonFlags_AlignTextBaseLine = 1 << 15, // vertically align button to match text baseline - ButtonEx() only // FIXME: Should be removed and handled by SmallButton(), not possible currently because of DC.CursorPosPrevLine
	ImGuiButtonFlags_NoKeyModsAllowed = 1 << 16, // disable mouse interaction if a key modifier is held
	ImGuiButtonFlags_NoHoldingActiveId = 1 << 17, // don't set ActiveId while holding the mouse (ImGuiButtonFlags_PressedOnClick only)
	ImGuiButtonFlags_NoNavFocus = 1 << 18, // don't override navigation focus when activated (FIXME: this is essentially used every time an item uses ImGuiItemFlags_NoNav, but because legacy specs don't requires LastItemData to be set ButtonBehavior(), we can't poll g.LastItemData.ItemFlags)
	ImGuiButtonFlags_NoHoveredOnFocus = 1 << 19, // don't report as hovered when nav focus is on this item
	ImGuiButtonFlags_NoSetKeyOwner = 1 << 20, // don't set key/input owner on the initial click (note: mouse buttons are keys! often, the key in question will be ImGuiKey_MouseLeft!)
	ImGuiButtonFlags_NoTestKeyOwner = 1 << 21, // don't test key/input owner when polling the key (note: mouse buttons are keys! often, the key in question will be ImGuiKey_MouseLeft!)
	ImGuiButtonFlags_PressedOnMask_ = ImGuiButtonFlags_PressedOnClick | ImGuiButtonFlags_PressedOnClickRelease | ImGuiButtonFlags_PressedOnClickReleaseAnywhere | ImGuiButtonFlags_PressedOnRelease | ImGuiButtonFlags_PressedOnDoubleClick | ImGuiButtonFlags_PressedOnDragDropHold,
	ImGuiButtonFlags_PressedOnDefault_ = ImGuiButtonFlags_PressedOnClickRelease,
}

// Extend ImGuiComboFlags_
ImGuiComboFlagsPrivate_ :: enum i32 {
	ImGuiComboFlags_CustomPreview = 1 << 20, // enable BeginComboPreview()
}

// Extend ImGuiSliderFlags_
ImGuiSliderFlagsPrivate_ :: enum i32 {
	ImGuiSliderFlags_Vertical = 1 << 20, // Should this slider be orientated vertically?
	ImGuiSliderFlags_ReadOnly = 1 << 21, // Consider using g.NextItemData.ItemFlags |= ImGuiItemFlags_ReadOnly instead.
}

// Extend ImGuiSelectableFlags_
ImGuiSelectableFlagsPrivate_ :: enum i32 {
	// NB: need to be in sync with last value of ImGuiSelectableFlags_
	ImGuiSelectableFlags_NoHoldingActiveID = 1 << 20,
	ImGuiSelectableFlags_SelectOnNav = 1 << 21, // (WIP) Auto-select when moved into. This is not exposed in public API as to handle multi-select and modifiers we will need user to explicitly control focus scope. May be replaced with a BeginSelection() API.
	ImGuiSelectableFlags_SelectOnClick = 1 << 22, // Override button behavior to react on Click (default is Click+Release)
	ImGuiSelectableFlags_SelectOnRelease = 1 << 23, // Override button behavior to react on Release (default is Click+Release)
	ImGuiSelectableFlags_SpanAvailWidth = 1 << 24, // Span all avail width even if we declared less for layout purpose. FIXME: We may be able to remove this (added in 6251d379, 2bcafc86 for menus)
	ImGuiSelectableFlags_SetNavIdOnHover = 1 << 25, // Set Nav/Focus ID on mouse hover (used by MenuItem)
	ImGuiSelectableFlags_NoPadWithHalfSpacing = 1 << 26, // Disable padding each side with ItemSpacing * 0.5f
	ImGuiSelectableFlags_NoSetKeyOwner = 1 << 27, // Don't set key/input owner on the initial click (note: mouse buttons are keys! often, the key in question will be ImGuiKey_MouseLeft!)
}

// Extend ImGuiTreeNodeFlags_
ImGuiTreeNodeFlagsPrivate_ :: enum i32 {
	ImGuiTreeNodeFlags_ClipLabelForTrailingButton = 1 << 28, // FIXME-WIP: Hard-coded for CollapsingHeader()
	ImGuiTreeNodeFlags_UpsideDownArrow = 1 << 29, // FIXME-WIP: Turn Down arrow into an Up arrow, for reversed trees (#6517)
	ImGuiTreeNodeFlags_OpenOnMask_ = i32(ImGuiTreeNodeFlags_.ImGuiTreeNodeFlags_OpenOnDoubleClick | ImGuiTreeNodeFlags_.ImGuiTreeNodeFlags_OpenOnArrow),
}

ImGuiSeparatorFlags_ :: enum i32 {
	ImGuiSeparatorFlags_None = 0,
	ImGuiSeparatorFlags_Horizontal = 1 << 0, // Axis default to current layout type, so generally Horizontal unless e.g. in a menu bar
	ImGuiSeparatorFlags_Vertical = 1 << 1,
	ImGuiSeparatorFlags_SpanAllColumns = 1 << 2, // Make separator cover all columns of a legacy Columns() set.
}

// Flags for FocusWindow(). This is not called ImGuiFocusFlags to avoid confusion with public-facing ImGuiFocusedFlags.
// FIXME: Once we finishing replacing more uses of GetTopMostPopupModal()+IsWindowWithinBeginStackOf()
// and FindBlockingModal() with this, we may want to change the flag to be opt-out instead of opt-in.
ImGuiFocusRequestFlags_ :: enum i32 {
	ImGuiFocusRequestFlags_None = 0,
	ImGuiFocusRequestFlags_RestoreFocusedChild = 1 << 0, // Find last focused child (if any) and focus it instead.
	ImGuiFocusRequestFlags_UnlessBelowModal = 1 << 1, // Do not set focus if the window is below a modal.
}

ImGuiTextFlags_ :: enum i32 {
	ImGuiTextFlags_None = 0,
	ImGuiTextFlags_NoWidthForLargeClippedText = 1 << 0,
}

ImGuiTooltipFlags_ :: enum i32 {
	ImGuiTooltipFlags_None = 0,
	ImGuiTooltipFlags_OverridePrevious = 1 << 1, // Clear/ignore previously submitted tooltip (defaults to append)
}

// FIXME: this is in development, not exposed/functional as a generic feature yet.
// Horizontal/Vertical enums are fixed to 0/1 so they may be used to index ImVec2
ImGuiLayoutType_ :: enum i32 {
	ImGuiLayoutType_Horizontal = 0,
	ImGuiLayoutType_Vertical = 1,
}

// Flags for LogBegin() text capturing function
ImGuiLogFlags_ :: enum i32 {
	ImGuiLogFlags_None = 0,

	ImGuiLogFlags_OutputTTY = 1 << 0,
	ImGuiLogFlags_OutputFile = 1 << 1,
	ImGuiLogFlags_OutputBuffer = 1 << 2,
	ImGuiLogFlags_OutputClipboard = 1 << 3,
	ImGuiLogFlags_OutputMask_ = ImGuiLogFlags_OutputTTY | ImGuiLogFlags_OutputFile | ImGuiLogFlags_OutputBuffer | ImGuiLogFlags_OutputClipboard,
}

// X/Y enums are fixed to 0/1 so they may be used to index ImVec2
ImGuiAxis :: enum i32 {
	ImGuiAxis_None = -1,
	ImGuiAxis_X = 0,
	ImGuiAxis_Y = 1,
}

ImGuiPlotType :: enum i32 {
	ImGuiPlotType_Lines,
	ImGuiPlotType_Histogram,
}

// Box-selection state (currently used by multi-selection, could potentially be used by others)
// Stacked color modifier, backup of modified data so we can restore it
ImGuiColorMod :: struct {
	Col : ImGuiCol,
	BackupValue : ImVec4,
}

// Storage for one type registered in the .ini file
// Stacked style modifier, backup of modified data so we can restore it. Data type inferred from the variable.
ImGuiStyleMod :: struct {
	VarIdx : ImGuiStyleVar,
	using _0 : struct #raw_union { BackupInt : [2]i32, BackupFloat : [2]f32, },
}

ImGuiStyleMod_init_0 :: proc(this : ^ImGuiStyleMod, idx : ImGuiStyleVar, v : i32)
{
	this.VarIdx = idx; this.BackupInt[0] = v
}

ImGuiStyleMod_init_1 :: proc(this : ^ImGuiStyleMod, idx : ImGuiStyleVar, v : f32)
{
	this.VarIdx = idx; this.BackupFloat[0] = v
}

ImGuiStyleMod_init_2 :: proc(this : ^ImGuiStyleMod, idx : ImGuiStyleVar, v : ImVec2)
{
	this.VarIdx = idx; this.BackupFloat[0] = v.x; this.BackupFloat[1] = v.y
}

// Storage data for BeginComboPreview()/EndComboPreview()
ImGuiComboPreviewData :: struct {
	PreviewRect : ImRect,
	BackupCursorPos : ImVec2,
	BackupCursorMaxPos : ImVec2,
	BackupCursorPosPrevLine : ImVec2,
	BackupPrevLineTextBaseOffset : f32,
	BackupLayout : ImGuiLayoutType,
}

ImGuiComboPreviewData_init :: proc(this : ^ImGuiComboPreviewData) { memset(this, 0, size_of(this)) }

// Storage of stack sizes for error handling and recovery
// Stacked storage data for BeginGroup()/EndGroup()
ImGuiGroupData :: struct {
	WindowID : ImGuiID,
	BackupCursorPos : ImVec2,
	BackupCursorMaxPos : ImVec2,
	BackupCursorPosPrevLine : ImVec2,
	BackupIndent : ImVec1,
	BackupGroupOffset : ImVec1,
	BackupCurrLineSize : ImVec2,
	BackupCurrLineTextBaseOffset : f32,
	BackupActiveIdIsAlive : ImGuiID,
	BackupActiveIdPreviousFrameIsAlive : bool,
	BackupHoveredIdIsAlive : bool,
	BackupIsSameLine : bool,
	EmitItem : bool,
}

// A localization entry.
// Simple column measurement, currently used for MenuItem() only.. This is very short-sighted/throw-away code and NOT a generic helper.
ImGuiMenuColumns :: struct {
	TotalWidth : ImU32,
	NextTotalWidth : ImU32,
	Spacing : ImU16,
	OffsetIcon : ImU16, // Always zero for now
	OffsetLabel : ImU16, // Offsets are locked in Update()
	OffsetShortcut : ImU16,
	OffsetMark : ImU16,
	Widths : [4]ImU16, }

// Width of:   Icon, Label, Shortcut, Mark  (accumulators for current frame)

ImGuiMenuColumns_init :: proc(this : ^ImGuiMenuColumns) { memset(this, 0, size_of(this)) }

// Internal temporary state for deactivating InputText() instances.
ImGuiInputTextDeactivatedState :: struct {
	ID : ImGuiID, // widget id owning the text state (which just got deactivated)
	TextA : ImVector(u8), }

// text buffer

ImGuiInputTextDeactivatedState_init :: proc(this : ^ImGuiInputTextDeactivatedState) { memset(this, 0, size_of(this)) }

ImGuiInputTextDeactivatedState_ClearFreeMemory :: proc(this : ^ImGuiInputTextDeactivatedState)
{
	this.ID = 0; clear(&this.TextA)
}

// Forward declare imstb_textedit.h structure + make its main configuration define accessible
//TODO @gen: there was a '#undef %!(MISSING ARGUMENT)' here, that cannot be emulated in odin. Make sure everything works as expected.
//TODO @gen: there was a '#undef %!(MISSING ARGUMENT)' here, that cannot be emulated in odin. Make sure everything works as expected.
IMSTB_TEXTEDIT_STRING :: ImGuiInputTextState
IMSTB_TEXTEDIT_CHARTYPE :: u8
IMSTB_TEXTEDIT_GETWIDTH_NEWLINE :: (-1.0)
IMSTB_TEXTEDIT_UNDOSTATECOUNT :: 99
IMSTB_TEXTEDIT_UNDOCHARCOUNT :: 999
ImStbTexteditState :: ImStb_STB_TexteditState

// Stacked storage data for BeginGroup()/EndGroup()
// Internal state of the currently focused/edited text input box
// For a given item ID, access with ImGui::GetInputTextState()
ImGuiInputTextState :: struct {
	Ctx : ^ImGuiContext, // parent UI context (needs to be set explicitly by parent).
	Stb : ^ImStbTexteditState, // State for stb_textedit.h
	Flags : ImGuiInputTextFlags, // copy of InputText() flags. may be used to check if e.g. ImGuiInputTextFlags_Password is set.
	ID : ImGuiID, // widget id owning the text state
	TextLen : i32, // UTF-8 length of the string in TextA (in bytes)
	TextSrc : ^u8, // == TextA.Data unless read-only, in which case == buf passed to InputText(). Field only set and valid _inside_ the call InputText() call.
	TextA : ImVector(u8), // main UTF8 buffer. TextA.Size is a buffer size! Should always be >= buf_size passed by user (and of course >= CurLenA + 1).
	TextToRevertTo : ImVector(u8), // value to revert to when pressing Escape = backup of end-user buffer at the time of focus (in UTF-8, unaltered)
	CallbackTextBackup : ImVector(u8), // temporary storage for callback to support automatic reconcile of undo-stack
	BufCapacity : i32, // end-user buffer capacity (include zero terminator)
	Scroll : ImVec2, // horizontal offset (managed manually) + vertical scrolling (pulled from child window's own Scroll.y)
	CursorAnim : f32, // timer for cursor blink, reset on every user action so the cursor reappears immediately
	CursorFollow : bool, // set when we want scrolling to follow the current cursor position (not always!)
	SelectedAllMouseLock : bool, // after a double-click to select all, we ignore further mouse drags to update selection
	Edited : bool, // edited this frame
	WantReloadUserBuf : bool, // force a reload of user buf so it may be modified externally. may be automatic in future version.
	ReloadSelectionStart : i32,
	ReloadSelectionEnd : i32,
}

ImGuiInputTextState_ClearText :: proc(this : ^ImGuiInputTextState)
{
	this.TextLen = 0; this.TextA[0] = 0; CursorClamp()
}

ImGuiInputTextState_ClearFreeMemory :: proc(this : ^ImGuiInputTextState)
{
	clear(&this.TextA); clear(&this.TextToRevertTo)
}

ImGuiWindowRefreshFlags_ :: enum i32 {
	ImGuiWindowRefreshFlags_None = 0,
	ImGuiWindowRefreshFlags_TryToAvoidRefresh = 1 << 0, // [EXPERIMENTAL] Try to keep existing contents, USER MUST NOT HONOR BEGIN() RETURNING FALSE AND NOT APPEND.
	ImGuiWindowRefreshFlags_RefreshOnHover = 1 << 1, // [EXPERIMENTAL] Always refresh on hover
	ImGuiWindowRefreshFlags_RefreshOnFocus = 1 << 2, // [EXPERIMENTAL] Always refresh on focus
	// Refresh policy/frequency, Load Balancing etc.
}

ImGuiNextWindowDataFlags_ :: enum i32 {
	ImGuiNextWindowDataFlags_None = 0,
	ImGuiNextWindowDataFlags_HasPos = 1 << 0,
	ImGuiNextWindowDataFlags_HasSize = 1 << 1,
	ImGuiNextWindowDataFlags_HasContentSize = 1 << 2,
	ImGuiNextWindowDataFlags_HasCollapsed = 1 << 3,
	ImGuiNextWindowDataFlags_HasSizeConstraint = 1 << 4,
	ImGuiNextWindowDataFlags_HasFocus = 1 << 5,
	ImGuiNextWindowDataFlags_HasBgAlpha = 1 << 6,
	ImGuiNextWindowDataFlags_HasScroll = 1 << 7,
	ImGuiNextWindowDataFlags_HasChildFlags = 1 << 8,
	ImGuiNextWindowDataFlags_HasRefreshPolicy = 1 << 9,
	ImGuiNextWindowDataFlags_HasViewport = 1 << 10,
	ImGuiNextWindowDataFlags_HasDock = 1 << 11,
	ImGuiNextWindowDataFlags_HasWindowClass = 1 << 12,
}

// Storage for ShowMetricsWindow() and DebugNodeXXX() functions
// Storage for SetNexWindow** functions
ImGuiNextWindowData :: struct {
	Flags : ImGuiNextWindowDataFlags,
	PosCond : ImGuiCond,
	SizeCond : ImGuiCond,
	CollapsedCond : ImGuiCond,
	DockCond : ImGuiCond,
	PosVal : ImVec2,
	PosPivotVal : ImVec2,
	SizeVal : ImVec2,
	ContentSizeVal : ImVec2,
	ScrollVal : ImVec2,
	ChildFlags : ImGuiChildFlags,
	PosUndock : bool,
	CollapsedVal : bool,
	SizeConstraintRect : ImRect,
	SizeCallback : ImGuiSizeCallback,
	SizeCallbackUserData : rawptr,
	BgAlphaVal : f32, // Override background alpha
	ViewportId : ImGuiID,
	DockId : ImGuiID,
	WindowClass : ImGuiWindowClass,
	MenuBarOffsetMinVal : ImVec2, // (Always on) This is not exposed publicly, so we don't clear it and it doesn't have a corresponding flag (could we? for consistency?)
	RefreshFlagsVal : ImGuiWindowRefreshFlags,
}

ImGuiNextWindowData_init :: proc(this : ^ImGuiNextWindowData) { memset(this, 0, size_of(this)) }

ImGuiNextWindowData_ClearFlags :: #force_inline proc(this : ^ImGuiNextWindowData) { this.Flags = ImGuiNextWindowDataFlags_.ImGuiNextWindowDataFlags_None }

ImGuiNextItemDataFlags_ :: enum i32 {
	ImGuiNextItemDataFlags_None = 0,
	ImGuiNextItemDataFlags_HasWidth = 1 << 0,
	ImGuiNextItemDataFlags_HasOpen = 1 << 1,
	ImGuiNextItemDataFlags_HasShortcut = 1 << 2,
	ImGuiNextItemDataFlags_HasRefVal = 1 << 3,
	ImGuiNextItemDataFlags_HasStorageID = 1 << 4,
}

// Storage for SetNextWindow** functions
ImGuiNextItemData :: struct {
	HasFlags : ImGuiNextItemDataFlags, // Called HasFlags instead of Flags to avoid mistaking this
	ItemFlags : ImGuiItemFlags, // Currently only tested/used for ImGuiItemFlags_AllowOverlap and ImGuiItemFlags_HasSelectionUserData.
	// Non-flags members are NOT cleared by ItemAdd() meaning they are still valid during NavProcessItem()
	FocusScopeId : ImGuiID, // Set by SetNextItemSelectionUserData()
	SelectionUserData : ImGuiSelectionUserData, // Set by SetNextItemSelectionUserData() (note that NULL/0 is a valid value, we use -1 == ImGuiSelectionUserData_Invalid to mark invalid values)
	Width : f32, // Set by SetNextItemWidth()
	Shortcut : ImGuiKeyChord, // Set by SetNextItemShortcut()
	ShortcutFlags : ImGuiInputFlags, // Set by SetNextItemShortcut()
	OpenVal : bool, // Set by SetNextItemOpen()
	OpenCond : ImU8, // Set by SetNextItemOpen()
	RefVal : ImGuiDataTypeStorage, // Not exposed yet, for ImGuiInputTextFlags_ParseEmptyAsRefVal
	StorageId : ImGuiID, }

// Set by SetNextItemStorageID()

ImGuiNextItemData_init :: proc(this : ^ImGuiNextItemData)
{
	memset(this, 0, size_of(this)); this.SelectionUserData = -1
}

// Also cleared manually by ItemAdd()!
ImGuiNextItemData_ClearFlags :: #force_inline proc(this : ^ImGuiNextItemData)
{
	this.HasFlags = ImGuiNextItemDataFlags_.ImGuiNextItemDataFlags_None; this.ItemFlags = ImGuiItemFlags_.ImGuiItemFlags_None
}

// Short term storage to backup text of a deactivating InputText() while another is stealing active id
// Status storage for the last submitted item
ImGuiLastItemData :: struct {
	ID : ImGuiID,
	ItemFlags : ImGuiItemFlags, // See ImGuiItemFlags_
	StatusFlags : ImGuiItemStatusFlags, // See ImGuiItemStatusFlags_
	Rect : ImRect, // Full rectangle
	NavRect : ImRect, // Navigation scoring rectangle (not displayed)
	// Rarely used fields are not explicitly cleared, only valid when the corresponding ImGuiItemStatusFlags ar set.
	DisplayRect : ImRect, // Display rectangle. ONLY VALID IF (StatusFlags & ImGuiItemStatusFlags_HasDisplayRect) is set.
	ClipRect : ImRect, // Clip rectangle at the time of submitting item. ONLY VALID IF (StatusFlags & ImGuiItemStatusFlags_HasClipRect) is set..
	Shortcut : ImGuiKeyChord, }

// Shortcut at the time of submitting item. ONLY VALID IF (StatusFlags & ImGuiItemStatusFlags_HasShortcut) is set..

ImGuiLastItemData_init :: proc(this : ^ImGuiLastItemData) { memset(this, 0, size_of(this)) }

// Storage for a column .ini settings
// Store data emitted by TreeNode() for usage by TreePop()
// - To implement ImGuiTreeNodeFlags_NavLeftJumpsBackHere: store the minimum amount of data
//   which we can't infer in TreePop(), to perform the equivalent of NavApplyItemToResult().
//   Only stored when the node is a potential candidate for landing on a Left arrow jump.
ImGuiTreeNodeStackData :: struct {
	ID : ImGuiID,
	TreeFlags : ImGuiTreeNodeFlags,
	ItemFlags : ImGuiItemFlags, // Used for nav landing
	NavRect : ImRect, // Used for nav landing
}

// Storage for a dock node in .ini file (we preserve those even if the associated dock node isn't active during the session)
// sizeof() = 20
ImGuiErrorRecoveryState :: struct {
	SizeOfWindowStack : i16,
	SizeOfIDStack : i16,
	SizeOfTreeStack : i16,
	SizeOfColorStack : i16,
	SizeOfStyleVarStack : i16,
	SizeOfFontStack : i16,
	SizeOfFocusScopeStack : i16,
	SizeOfGroupStack : i16,
	SizeOfItemFlagsStack : i16,
	SizeOfBeginPopupStack : i16,
	SizeOfDisabledStack : i16,
}

ImGuiErrorRecoveryState_init :: proc(this : ^ImGuiErrorRecoveryState) { memset(this, 0, size_of(this)) }

// Data saved for each window pushed into the stack
ImGuiWindowStackData :: struct {
	Window : ^ImGuiWindow,
	ParentLastItemDataBackup : ImGuiLastItemData,
	StackSizesInBegin : ImGuiErrorRecoveryState, // Store size of various stacks for asserting
	DisabledOverrideReenable : bool, // Non-child window override disabled flag
}

ImGuiShrinkWidthItem :: struct {
	Index : i32,
	Width : f32,
	InitialWidth : f32,
}

ImGuiPtrOrIndex :: struct {
	Ptr : rawptr, // Either field can be set, not both. e.g. Dock node tab bars are loose while BeginTabBar() ones are in a pool.
	Index : i32, }

// Usually index in a main pool.

ImGuiPtrOrIndex_init_0 :: proc(this : ^ImGuiPtrOrIndex, ptr : rawptr)
{
	this.Ptr = ptr; this.Index = -1
}

ImGuiPtrOrIndex_init_1 :: proc(this : ^ImGuiPtrOrIndex, index : i32)
{
	this.Ptr = nil; this.Index = index
}

//-----------------------------------------------------------------------------
// [SECTION] Popup support
//-----------------------------------------------------------------------------

ImGuiPopupPositionPolicy :: enum i32 {
	ImGuiPopupPositionPolicy_Default,
	ImGuiPopupPositionPolicy_ComboBox,
	ImGuiPopupPositionPolicy_Tooltip,
}

// Storage data for a columns set for legacy Columns() api
// Storage for popup stacks (g.OpenPopupStack and g.BeginPopupStack)
ImGuiPopupData :: struct {
	PopupId : ImGuiID, // Set on OpenPopup()
	Window : ^ImGuiWindow, // Resolved on BeginPopup() - may stay unresolved if user never calls OpenPopup()
	RestoreNavWindow : ^ImGuiWindow, // Set on OpenPopup(), a NavWindow that will be restored on popup close
	ParentNavLayer : i32, // Resolved on BeginPopup(). Actually a ImGuiNavLayer type (declared down below), initialized to -1 which is not part of an enum, but serves well-enough as "not any of layers" value
	OpenFrameCount : i32, // Set on OpenPopup()
	OpenParentId : ImGuiID, // Set on OpenPopup(), we need this to differentiate multiple menu sets from each others (e.g. inside menu bar vs loose menu items)
	OpenPopupPos : ImVec2, // Set on OpenPopup(), preferred popup position (typically == OpenMousePos when using mouse)
	OpenMousePos : ImVec2, }

// Set on OpenPopup(), copy of mouse position at the time of opening popup

ImGuiPopupData_init :: proc(this : ^ImGuiPopupData)
{
	memset(this, 0, size_of(this)); this.OpenFrameCount = -1; this.ParentNavLayer = this.OpenFrameCount
}

//-----------------------------------------------------------------------------
// [SECTION] Inputs support
//-----------------------------------------------------------------------------

// Bit array for named keys
ImBitArrayForNamedKeys :: ImBitArray(i32(ImGuiKey.ImGuiKey_NamedKey_COUNT), -i32(ImGuiKey.ImGuiKey_NamedKey_BEGIN))

// [Internal] Key ranges
ImGuiKey_LegacyNativeKey_BEGIN :: 0
ImGuiKey_LegacyNativeKey_END :: 512
ImGuiKey_Keyboard_BEGIN :: ImGuiKey.ImGuiKey_NamedKey_BEGIN
ImGuiKey_Keyboard_END   :: ImGuiKey.ImGuiKey_GamepadStart
ImGuiKey_Gamepad_BEGIN  :: ImGuiKey.ImGuiKey_GamepadStart
ImGuiKey_Gamepad_END    :: ImGuiKey(i32(ImGuiKey.ImGuiKey_GamepadRStickDown) + 1)
ImGuiKey_Mouse_BEGIN    :: ImGuiKey.ImGuiKey_MouseLeft
ImGuiKey_Mouse_END      :: ImGuiKey(i32(ImGuiKey.ImGuiKey_MouseWheelY) + 1)
ImGuiKey_Aliases_BEGIN  :: ImGuiKey_Mouse_BEGIN
ImGuiKey_Aliases_END    :: ImGuiKey_Mouse_END

// [Internal] Named shortcuts for Navigation
ImGuiKey_NavKeyboardTweakSlow :: ImGuiKey.ImGuiMod_Ctrl
ImGuiKey_NavKeyboardTweakFast :: ImGuiKey.ImGuiMod_Shift
ImGuiKey_NavGamepadTweakSlow  :: ImGuiKey.ImGuiKey_GamepadL1
ImGuiKey_NavGamepadTweakFast  :: ImGuiKey.ImGuiKey_GamepadR1
ImGuiKey_NavGamepadActivate   :: #force_inline proc "contextless" (g : ^ImGuiContext) -> ImGuiKey { return g.IO.ConfigNavSwapGamepadButtons ? ImGuiKey_GamepadFaceRight : ImGuiKey_GamepadFaceDown }
ImGuiKey_NavGamepadCancel     :: #force_inline proc "contextless" (g : ^ImGuiContext) -> ImGuiKey { return g.IO.ConfigNavSwapGamepadButtons ? ImGuiKey_GamepadFaceDown  : ImGuiKey_GamepadFaceRight }
ImGuiKey_NavGamepadMenu       :: ImGuiKey.ImGuiKey_GamepadFaceLeft
ImGuiKey_NavGamepadInput      :: ImGuiKey.ImGuiKey_GamepadFaceUp

ImGuiInputEventType :: enum i32 {
	ImGuiInputEventType_None = 0,
	ImGuiInputEventType_MousePos,
	ImGuiInputEventType_MouseWheel,
	ImGuiInputEventType_MouseButton,
	ImGuiInputEventType_MouseViewport,
	ImGuiInputEventType_Key,
	ImGuiInputEventType_Text,
	ImGuiInputEventType_Focus,
	ImGuiInputEventType_COUNT,
}

ImGuiInputSource :: enum i32 {
	ImGuiInputSource_None = 0,
	ImGuiInputEventType_Mouse, // Note: may be Mouse or TouchScreen or Pen. See io.MouseSource to distinguish them.
	ImGuiInputSource_Keyboard,
	ImGuiInputSource_Gamepad,
	ImGuiInputSource_COUNT,
}

// FIXME: Structures in the union below need to be declared as anonymous unions appears to be an extension?
// Using ImVec2() would fail on Clang 'union member 'MousePos' has a non-trivial default constructor'
ImGuiInputEventMousePos :: struct { PosX : f32, PosY : f32, MouseSource : ImGuiMouseSource, }
ImGuiInputEventMouseWheel :: struct { WheelX : f32, WheelY : f32, MouseSource : ImGuiMouseSource, }
ImGuiInputEventMouseButton :: struct { Button : i32, Down : bool, MouseSource : ImGuiMouseSource, }
ImGuiInputEventMouseViewport :: struct { HoveredViewportID : ImGuiID, }
ImGuiInputEventKey :: struct { Key : ImGuiKey, Down : bool, AnalogValue : f32, }
ImGuiInputEventText :: struct { Char : u32, }
ImGuiInputEventAppFocused :: struct { Focused : bool, }

ImGuiInputEvent :: struct {
	Type : ImGuiInputEventType,
	Source : ImGuiInputSource,
	EventId : ImU32, using _0 : struct #raw_union {
		MousePos : ImGuiInputEventMousePos, // if Type == ImGuiInputEventType_MousePos
		MouseWheel : ImGuiInputEventMouseWheel, // if Type == ImGuiInputEventType_MouseWheel
		MouseButton : ImGuiInputEventMouseButton, // if Type ==ImGuiInputEventType_MouseButton
		MouseViewport : ImGuiInputEventMouseViewport, // if Type == ImGuiInputEventType_MouseViewport
		Key : ImGuiInputEventKey, // if Type == ImGuiInputEventType_Key
		Text : ImGuiInputEventText, // if Type == ImGuiInputEventType_Text
		AppFocused : ImGuiInputEventAppFocused, // if Type == ImGuiInputEventType_Focus
	},
	AddedByTestEngine : bool,
}

ImGuiInputEvent_init :: proc(this : ^ImGuiInputEvent) { memset(this, 0, size_of(this)) }

// Input function taking an 'ImGuiID owner_id' argument defaults to (ImGuiKeyOwner_Any == 0) aka don't test ownership, which matches legacy behavior.
ImGuiKeyOwner_Any :: (ImGuiID(0))// Accept key that have an owner, UNLESS a call to SetKeyOwner() explicitly used ImGuiInputFlags_LockThisFrame or ImGuiInputFlags_LockUntilRelease.
ImGuiKeyOwner_NoOwner :: (transmute(ImGuiID)i32(-1))// Require key to have no owner.
//#define ImGuiKeyOwner_None ImGuiKeyOwner_NoOwner  // We previously called this 'ImGuiKeyOwner_None' but it was inconsistent with our pattern that _None values == 0 and quite dangerous. Also using _NoOwner makes the IsKeyPressed() calls more explicit.

ImGuiKeyRoutingIndex :: ImS16

// Routing table entry (sizeof() == 16 bytes)
ImGuiKeyRoutingData :: struct {
	NextEntryIndex : ImGuiKeyRoutingIndex,
	Mods : ImU16, // Technically we'd only need 4-bits but for simplify we store ImGuiMod_ values which need 16-bits.
	RoutingCurrScore : ImU8, // [DEBUG] For debug display
	RoutingNextScore : ImU8, // Lower is better (0: perfect score)
	RoutingCurr : ImGuiID,
	RoutingNext : ImGuiID,
}

ImGuiKeyRoutingData_init :: proc(this : ^ImGuiKeyRoutingData)
{
	this.NextEntryIndex = -1; this.Mods = 0; this.RoutingNextScore = 255; this.RoutingCurrScore = this.RoutingNextScore; this.RoutingNext = ImGuiKeyOwner_NoOwner; this.RoutingCurr = this.RoutingNext
}

// Routing table: maintain a desired owner for each possible key-chord (key + mods), and setup owner in NewFrame() when mods are matching.
// Stored in main context (1 instance)
ImGuiKeyRoutingTable :: struct {
	Index : [ImGuiKey.ImGuiKey_NamedKey_COUNT]ImGuiKeyRoutingIndex, // Index of first entry in Entries[]
	Entries : ImVector(ImGuiKeyRoutingData),
	EntriesNext : ImVector(ImGuiKeyRoutingData), }

// Double-buffer to avoid reallocation (could use a shared buffer)

ImGuiKeyRoutingTable_init :: proc(this : ^ImGuiKeyRoutingTable) { Clear() }

ImGuiKeyRoutingTable_Clear :: proc(this : ^ImGuiKeyRoutingTable)
{
	for n : i32 = 0; n < IM_ARRAYSIZE(this.Index); post_incr(&n) { this.Index[n] = -1 }; 

clear(&this.Entries); clear(&this.EntriesNext)
}

// This extends ImGuiKeyData but only for named keys (legacy keys don't support the new features)
// Stored in main context (1 per named key). In the future it might be merged into ImGuiKeyData.
ImGuiKeyOwnerData :: struct {
	OwnerCurr : ImGuiID,
	OwnerNext : ImGuiID,
	LockThisFrame : bool, // Reading this key requires explicit owner id (until end of frame). Set by ImGuiInputFlags_LockThisFrame.
	LockUntilRelease : bool, }

// Reading this key requires explicit owner id (until key is released). Set by ImGuiInputFlags_LockUntilRelease. When this is true LockThisFrame is always true as well.

ImGuiKeyOwnerData_init :: proc(this : ^ImGuiKeyOwnerData)
{
	this.OwnerNext = ImGuiKeyOwner_NoOwner; this.OwnerCurr = this.OwnerNext; this.LockUntilRelease = false; this.LockThisFrame = this.LockUntilRelease
}

// Extend ImGuiInputFlags_
// Flags for extended versions of IsKeyPressed(), IsMouseClicked(), Shortcut(), SetKeyOwner(), SetItemKeyOwner()
// Don't mistake with ImGuiInputTextFlags! (which is for ImGui::InputText() function)
ImGuiInputFlagsPrivate_ :: enum i32 {
	// Flags for IsKeyPressed(), IsKeyChordPressed(), IsMouseClicked(), Shortcut()
	// - Repeat mode: Repeat rate selection
	ImGuiInputFlags_RepeatRateDefault = 1 << 1, // Repeat rate: Regular (default)
	ImGuiInputFlags_RepeatRateNavMove = 1 << 2, // Repeat rate: Fast
	ImGuiInputFlags_RepeatRateNavTweak = 1 << 3, // Repeat rate: Faster
	// - Repeat mode: Specify when repeating key pressed can be interrupted.
	// - In theory ImGuiInputFlags_RepeatUntilOtherKeyPress may be a desirable default, but it would break too many behavior so everything is opt-in.
	ImGuiInputFlags_RepeatUntilRelease = 1 << 4, // Stop repeating when released (default for all functions except Shortcut). This only exists to allow overriding Shortcut() default behavior.
	ImGuiInputFlags_RepeatUntilKeyModsChange = 1 << 5, // Stop repeating when released OR if keyboard mods are changed (default for Shortcut)
	ImGuiInputFlags_RepeatUntilKeyModsChangeFromNone = 1 << 6, // Stop repeating when released OR if keyboard mods are leaving the None state. Allows going from Mod+Key to Key by releasing Mod.
	ImGuiInputFlags_RepeatUntilOtherKeyPress = 1 << 7, // Stop repeating when released OR if any other keyboard key is pressed during the repeat

	// Flags for SetKeyOwner(), SetItemKeyOwner()
	// - Locking key away from non-input aware code. Locking is useful to make input-owner-aware code steal keys from non-input-owner-aware code. If all code is input-owner-aware locking would never be necessary.
	ImGuiInputFlags_LockThisFrame = 1 << 20, // Further accesses to key data will require EXPLICIT owner ID (ImGuiKeyOwner_Any/0 will NOT accepted for polling). Cleared at end of frame.
	ImGuiInputFlags_LockUntilRelease = 1 << 21, // Further accesses to key data will require EXPLICIT owner ID (ImGuiKeyOwner_Any/0 will NOT accepted for polling). Cleared when the key is released or at end of each frame if key is released.

	// - Condition for SetItemKeyOwner()
	ImGuiInputFlags_CondHovered = 1 << 22, // Only set if item is hovered (default to both)
	ImGuiInputFlags_CondActive = 1 << 23, // Only set if item is active (default to both)
	ImGuiInputFlags_CondDefault_ = ImGuiInputFlags_CondHovered | ImGuiInputFlags_CondActive,

	// [Internal] Mask of which function support which flags
	ImGuiInputFlags_RepeatRateMask_ = ImGuiInputFlags_RepeatRateDefault | ImGuiInputFlags_RepeatRateNavMove | ImGuiInputFlags_RepeatRateNavTweak,
	ImGuiInputFlags_RepeatUntilMask_ = ImGuiInputFlags_RepeatUntilRelease | ImGuiInputFlags_RepeatUntilKeyModsChange | ImGuiInputFlags_RepeatUntilKeyModsChangeFromNone | ImGuiInputFlags_RepeatUntilOtherKeyPress,
	ImGuiInputFlags_RepeatMask_ = i32(ImGuiInputFlags_.ImGuiInputFlags_Repeat) | i32(ImGuiInputFlags_RepeatRateMask_ | ImGuiInputFlags_RepeatUntilMask_),
	ImGuiInputFlags_CondMask_ = ImGuiInputFlags_CondHovered | ImGuiInputFlags_CondActive,
	ImGuiInputFlags_RouteTypeMask_ = i32(ImGuiInputFlags_.ImGuiInputFlags_RouteActive | ImGuiInputFlags_.ImGuiInputFlags_RouteFocused | ImGuiInputFlags_.ImGuiInputFlags_RouteGlobal | ImGuiInputFlags_.ImGuiInputFlags_RouteAlways),
	ImGuiInputFlags_RouteOptionsMask_ = i32(ImGuiInputFlags_.ImGuiInputFlags_RouteOverFocused | ImGuiInputFlags_.ImGuiInputFlags_RouteOverActive | ImGuiInputFlags_.ImGuiInputFlags_RouteUnlessBgFocused | ImGuiInputFlags_.ImGuiInputFlags_RouteFromRootWindow),
	ImGuiInputFlags_SupportedByIsKeyPressed = ImGuiInputFlags_RepeatMask_,
	ImGuiInputFlags_SupportedByIsMouseClicked = i32(ImGuiInputFlags_.ImGuiInputFlags_Repeat),
	ImGuiInputFlags_SupportedByShortcut = ImGuiInputFlags_RepeatMask_ | ImGuiInputFlags_RouteTypeMask_ | ImGuiInputFlags_RouteOptionsMask_,
	ImGuiInputFlags_SupportedBySetNextItemShortcut = i32(ImGuiInputFlags_RepeatMask_ | ImGuiInputFlags_RouteTypeMask_ | ImGuiInputFlags_RouteOptionsMask_) | i32(ImGuiInputFlags_.ImGuiInputFlags_Tooltip),
	ImGuiInputFlags_SupportedBySetKeyOwner = ImGuiInputFlags_LockThisFrame | ImGuiInputFlags_LockUntilRelease,
	ImGuiInputFlags_SupportedBySetItemKeyOwner = ImGuiInputFlags_SupportedBySetKeyOwner | ImGuiInputFlags_CondMask_,
}

//-----------------------------------------------------------------------------
// [SECTION] Clipper support
//-----------------------------------------------------------------------------

// Note that Max is exclusive, so perhaps should be using a Begin/End convention.
ImGuiListClipperRange :: struct {
	Min : i32,
	Max : i32,
	PosToIndexConvert : bool, // Begin/End are absolute position (will be converted to indices later)
	PosToIndexOffsetMin : ImS8, // Add to Min after converting to indices
	PosToIndexOffsetMax : ImS8, }

// Add to Min after converting to indices

ImGuiListClipperRange_FromIndices :: proc(this : ^ImGuiListClipperRange, min : i32, max : i32) -> ImGuiListClipperRange
{
	r : ImGuiListClipperRange = {min, max, false, 0, 0}; return r
}

ImGuiListClipperRange_FromPositions :: proc(this : ^ImGuiListClipperRange, y1 : f32, y2 : f32, off_min : i32, off_max : i32) -> ImGuiListClipperRange
{
	r : ImGuiListClipperRange = {cast(i32) y1, cast(i32) y2, true, cast(ImS8) off_min, cast(ImS8) off_max}; return r
}

// Temporary clipper data, buffers shared/reused between instances
ImGuiListClipperData :: struct {
	ListClipper : ^ImGuiListClipper,
	LossynessOffset : f32,
	StepNo : i32,
	ItemsFrozen : i32,
	Ranges : ImVector(ImGuiListClipperRange),
}

ImGuiListClipperData_init :: proc(this : ^ImGuiListClipperData) { memset(this, 0, size_of(this)) }

ImGuiListClipperData_Reset :: proc(this : ^ImGuiListClipperData, clipper : ^ImGuiListClipper)
{
	this.ListClipper = clipper; this.ItemsFrozen = 0; this.StepNo = this.ItemsFrozen; resize(&this.Ranges, 0)
}

//-----------------------------------------------------------------------------
// [SECTION] Navigation support
//-----------------------------------------------------------------------------

ImGuiActivateFlags_ :: enum i32 {
	ImGuiActivateFlags_None = 0,
	ImGuiActivateFlags_PreferInput = 1 << 0, // Favor activation that requires keyboard text input (e.g. for Slider/Drag). Default for Enter key.
	ImGuiActivateFlags_PreferTweak = 1 << 1, // Favor activation for tweaking with arrows or gamepad (e.g. for Slider/Drag). Default for Space key and if keyboard is not used.
	ImGuiActivateFlags_TryToPreserveState = 1 << 2, // Request widget to preserve state if it can (e.g. InputText will try to preserve cursor/selection)
	ImGuiActivateFlags_FromTabbing = 1 << 3, // Activation requested by a tabbing request
	ImGuiActivateFlags_FromShortcut = 1 << 4, // Activation requested by an item shortcut via SetNextItemShortcut() function.
}

// Early work-in-progress API for ScrollToItem()
ImGuiScrollFlags_ :: enum i32 {
	ImGuiScrollFlags_None = 0,
	ImGuiScrollFlags_KeepVisibleEdgeX = 1 << 0, // If item is not visible: scroll as little as possible on X axis to bring item back into view [default for X axis]
	ImGuiScrollFlags_KeepVisibleEdgeY = 1 << 1, // If item is not visible: scroll as little as possible on Y axis to bring item back into view [default for Y axis for windows that are already visible]
	ImGuiScrollFlags_KeepVisibleCenterX = 1 << 2, // If item is not visible: scroll to make the item centered on X axis [rarely used]
	ImGuiScrollFlags_KeepVisibleCenterY = 1 << 3, // If item is not visible: scroll to make the item centered on Y axis
	ImGuiScrollFlags_AlwaysCenterX = 1 << 4, // Always center the result item on X axis [rarely used]
	ImGuiScrollFlags_AlwaysCenterY = 1 << 5, // Always center the result item on Y axis [default for Y axis for appearing window)
	ImGuiScrollFlags_NoScrollParent = 1 << 6, // Disable forwarding scrolling to parent window if required to keep item/rect visible (only scroll window the function was applied to).
	ImGuiScrollFlags_MaskX_ = ImGuiScrollFlags_KeepVisibleEdgeX | ImGuiScrollFlags_KeepVisibleCenterX | ImGuiScrollFlags_AlwaysCenterX,
	ImGuiScrollFlags_MaskY_ = ImGuiScrollFlags_KeepVisibleEdgeY | ImGuiScrollFlags_KeepVisibleCenterY | ImGuiScrollFlags_AlwaysCenterY,
}

ImGuiNavRenderCursorFlags_ :: enum i32 {
	ImGuiNavRenderCursorFlags_None = 0,
	ImGuiNavRenderCursorFlags_Compact = 1 << 1, // Compact highlight, no padding/distance from focused item
	ImGuiNavRenderCursorFlags_AlwaysDraw = 1 << 2, // Draw rectangular highlight if (g.NavId == id) even when g.NavCursorVisible == false, aka even when using the mouse.
	ImGuiNavRenderCursorFlags_NoRounding = 1 << 3,
}

ImGuiNavMoveFlags_ :: enum i32 {
	ImGuiNavMoveFlags_None = 0,
	ImGuiNavMoveFlags_LoopX = 1 << 0, // On failed request, restart from opposite side
	ImGuiNavMoveFlags_LoopY = 1 << 1,
	ImGuiNavMoveFlags_WrapX = 1 << 2, // On failed request, request from opposite side one line down (when NavDir==right) or one line up (when NavDir==left)
	ImGuiNavMoveFlags_WrapY = 1 << 3, // This is not super useful but provided for completeness
	ImGuiNavMoveFlags_WrapMask_ = ImGuiNavMoveFlags_LoopX | ImGuiNavMoveFlags_LoopY | ImGuiNavMoveFlags_WrapX | ImGuiNavMoveFlags_WrapY,
	ImGuiNavMoveFlags_AllowCurrentNavId = 1 << 4, // Allow scoring and considering the current NavId as a move target candidate. This is used when the move source is offset (e.g. pressing PageDown actually needs to send a Up move request, if we are pressing PageDown from the bottom-most item we need to stay in place)
	ImGuiNavMoveFlags_AlsoScoreVisibleSet = 1 << 5, // Store alternate result in NavMoveResultLocalVisible that only comprise elements that are already fully visible (used by PageUp/PageDown)
	ImGuiNavMoveFlags_ScrollToEdgeY = 1 << 6, // Force scrolling to min/max (used by Home/End) // FIXME-NAV: Aim to remove or reword, probably unnecessary
	ImGuiNavMoveFlags_Forwarded = 1 << 7,
	ImGuiNavMoveFlags_DebugNoResult = 1 << 8, // Dummy scoring for debug purpose, don't apply result
	ImGuiNavMoveFlags_FocusApi = 1 << 9, // Requests from focus API can land/focus/activate items even if they are marked with _NoTabStop (see NavProcessItemForTabbingRequest() for details)
	ImGuiNavMoveFlags_IsTabbing = 1 << 10, // == Focus + Activate if item is Inputable + DontChangeNavHighlight
	ImGuiNavMoveFlags_IsPageMove = 1 << 11, // Identify a PageDown/PageUp request.
	ImGuiNavMoveFlags_Activate = 1 << 12, // Activate/select target item.
	ImGuiNavMoveFlags_NoSelect = 1 << 13, // Don't trigger selection by not setting g.NavJustMovedTo
	ImGuiNavMoveFlags_NoSetNavCursorVisible = 1 << 14, // Do not alter the nav cursor visible state
	ImGuiNavMoveFlags_NoClearActiveId = 1 << 15, // (Experimental) Do not clear active id when applying move result
}

ImGuiNavLayer :: enum i32 {
	ImGuiNavLayer_Main = 0, // Main scrolling layer
	ImGuiNavLayer_Menu = 1, // Menu layer (access with Alt)
	ImGuiNavLayer_COUNT,
}

// Multi-selection temporary state (while traversing).
// Storage for navigation query/results
ImGuiNavItemData :: struct {
	Window : ^ImGuiWindow, // Init,Move    // Best candidate window (result->ItemWindow->RootWindowForNav == request->Window)
	ID : ImGuiID, // Init,Move    // Best candidate item ID
	FocusScopeId : ImGuiID, // Init,Move    // Best candidate focus scope ID
	RectRel : ImRect, // Init,Move    // Best candidate bounding box in window relative space
	ItemFlags : ImGuiItemFlags, // ????,Move    // Best candidate item flags
	DistBox : f32, //      Move    // Best candidate box distance to current NavId
	DistCenter : f32, //      Move    // Best candidate center distance to current NavId
	DistAxial : f32, //      Move    // Best candidate axial distance to current NavId
	SelectionUserData : ImGuiSelectionUserData, }

//I+Mov    // Best candidate SetNextItemSelectionUserData() value. Valid if (ItemFlags & ImGuiItemFlags_HasSelectionUserData)

ImGuiNavItemData_init :: proc(this : ^ImGuiNavItemData) { Clear() }

ImGuiNavItemData_Clear :: proc(this : ^ImGuiNavItemData)
{
	this.Window = nil; this.FocusScopeId = 0; this.ID = this.FocusScopeId; this.ItemFlags = 0; this.SelectionUserData = -1; this.DistAxial = FLT_MAX; this.DistCenter = this.DistAxial; this.DistBox = this.DistCenter
}

// Storage for PushFocusScope(), g.FocusScopeStack[], g.NavFocusRoute[]
ImGuiFocusScopeData :: struct {
	ID : ImGuiID,
	WindowID : ImGuiID,
}

//-----------------------------------------------------------------------------
// [SECTION] Typing-select support
//-----------------------------------------------------------------------------

// Flags for GetTypingSelectRequest()
ImGuiTypingSelectFlags_ :: enum i32 {
	ImGuiTypingSelectFlags_None = 0,
	ImGuiTypingSelectFlags_AllowBackspace = 1 << 0, // Backspace to delete character inputs. If using: ensure GetTypingSelectRequest() is not called more than once per frame (filter by e.g. focus state)
	ImGuiTypingSelectFlags_AllowSingleCharMode = 1 << 1, // Allow "single char" search mode which is activated when pressing the same character multiple times.
}

// Storage for GetTypingSelectRequest()
// Returned by GetTypingSelectRequest(), designed to eventually be public.
ImGuiTypingSelectRequest :: struct {
	Flags : ImGuiTypingSelectFlags, // Flags passed to GetTypingSelectRequest()
	SearchBufferLen : i32,
	SearchBuffer : ^u8, // Search buffer contents (use full string. unless SingleCharMode is set, in which case use SingleCharSize).
	SelectRequest : bool, // Set when buffer was modified this frame, requesting a selection.
	SingleCharMode : bool, // Notify when buffer contains same character repeated, to implement special mode. In this situation it preferred to not display any on-screen search indication.
	SingleCharSize : ImS8, // Length in bytes of first letter codepoint (1 for ascii, 2-4 for UTF-8). If (SearchBufferLen==RepeatCharSize) only 1 letter has been input.
}

// Temporary storage for TreeNode().
// Storage for GetTypingSelectRequest()
ImGuiTypingSelectState :: struct {
	Request : ImGuiTypingSelectRequest, // User-facing data
	SearchBuffer : [64]u8, // Search buffer: no need to make dynamic as this search is very transient.
	FocusScope : ImGuiID,
	LastRequestFrame : i32,
	LastRequestTime : f32,
	SingleCharModeLock : bool, }

// After a certain single char repeat count we lock into SingleCharMode. Two benefits: 1) buffer never fill, 2) we can provide an immediate SingleChar mode without timer elapsing.

ImGuiTypingSelectState_init :: proc(this : ^ImGuiTypingSelectState)
{
this.LastRequestFrame = 0
this.LastRequestTime = 0.0
this.SingleCharModeLock = false
memset(this, 0, size_of(this))
}

// We preserve remaining data for easier debugging
ImGuiTypingSelectState_Clear :: proc(this : ^ImGuiTypingSelectState)
{
	this.SearchBuffer[0] = 0; this.SingleCharModeLock = false
}

//-----------------------------------------------------------------------------
// [SECTION] Columns support
//-----------------------------------------------------------------------------

// Flags for internal's BeginColumns(). This is an obsolete API. Prefer using BeginTable() nowadays!
ImGuiOldColumnFlags_ :: enum i32 {
	ImGuiOldColumnFlags_None = 0,
	ImGuiOldColumnFlags_NoBorder = 1 << 0, // Disable column dividers
	ImGuiOldColumnFlags_NoResize = 1 << 1, // Disable resizing columns when clicking on the dividers
	ImGuiOldColumnFlags_NoPreserveWidths = 1 << 2, // Disable column width preservation when adjusting columns
	ImGuiOldColumnFlags_NoForceWithinWindow = 1 << 3, // Disable forcing columns to fit within window
	ImGuiOldColumnFlags_GrowParentContentsSize = 1 << 4, // Restore pre-1.51 behavior of extending the parent window contents size but _without affecting the columns width at all_. Will eventually remove.
}

// Storage for SetNextItem** functions
ImGuiOldColumnData :: struct {
	OffsetNorm : f32, // Column start offset, normalized 0.0 (far left) -> 1.0 (far right)
	OffsetNormBeforeResize : f32,
	Flags : ImGuiOldColumnFlags, // Not exposed
	ClipRect : ImRect,
}

ImGuiOldColumnData_init :: proc(this : ^ImGuiOldColumnData) { memset(this, 0, size_of(this)) }

// Storage data for a single column for legacy Columns() api
ImGuiOldColumns :: struct {
	ID : ImGuiID,
	Flags : ImGuiOldColumnFlags,
	IsFirstFrame : bool,
	IsBeingResized : bool,
	Current : i32,
	Count : i32,
	OffMinX : f32, OffMaxX : f32, // Offsets from HostWorkRect.Min.x
	LineMinY : f32, LineMaxY : f32,
	HostCursorPosY : f32, // Backup of CursorPos at the time of BeginColumns()
	HostCursorMaxPosX : f32, // Backup of CursorMaxPos at the time of BeginColumns()
	HostInitialClipRect : ImRect, // Backup of ClipRect at the time of BeginColumns()
	HostBackupClipRect : ImRect, // Backup of ClipRect during PushColumnsBackground()/PopColumnsBackground()
	HostBackupParentWorkRect : ImRect, //Backup of WorkRect at the time of BeginColumns()
	Columns : ImVector(ImGuiOldColumnData),
	Splitter : ImDrawListSplitter,
}

ImGuiOldColumns_init :: proc(this : ^ImGuiOldColumns) { memset(this, 0, size_of(this)) }

// Data shared between all ImDrawList instances
//-----------------------------------------------------------------------------
// [SECTION] Box-select support
//-----------------------------------------------------------------------------

ImGuiBoxSelectState :: struct {
	// Active box-selection data (persistent, 1 active at a time)
	ID : ImGuiID,
	IsActive : bool,
	IsStarting : bool,
	IsStartedFromVoid : bool, // Starting click was not from an item.
	IsStartedSetNavIdOnce : bool,
	RequestClear : bool,
	using _0 : bit_field u16 {
		KeyMods : ImGuiKeyChord | 16, // Latched key-mods for box-select logic.
	},
	StartPosRel : ImVec2, // Start position in window-contents relative space (to support scrolling)
	EndPosRel : ImVec2, // End position in window-contents relative space
	ScrollAccum : ImVec2, // Scrolling accumulator (to behave at high-frame spaces)
	Window : ^ImGuiWindow,

	// Temporary/Transient data
	UnclipMode : bool, // (Temp/Transient, here in hot area). Set/cleared by the BeginMultiSelect()/EndMultiSelect() owning active box-select.
	UnclipRect : ImRect, // Rectangle where ItemAdd() clipping may be temporarily disabled. Need support by multi-select supporting widgets.
	BoxSelectRectPrev : ImRect, // Selection rectangle in absolute coordinates (derived every frame from BoxSelectStartPosRel and MousePos)
	BoxSelectRectCurr : ImRect,
}

ImGuiBoxSelectState_init :: proc(this : ^ImGuiBoxSelectState) { memset(this, 0, size_of(this)) }

//-----------------------------------------------------------------------------
// [SECTION] Multi-select support
//-----------------------------------------------------------------------------

// We always assume that -1 is an invalid value (which works for indices and pointers)
ImGuiSelectionUserData_Invalid :: cast(ImGuiSelectionUserData)(-1)

// Multi-selection persistent state (for focused selection).
// Temporary storage for multi-select
ImGuiMultiSelectTempData :: struct {
	IO : ImGuiMultiSelectIO, // MUST BE FIRST FIELD. Requests are set and returned by BeginMultiSelect()/EndMultiSelect() + written to by user during the loop.
	Storage : ^ImGuiMultiSelectState,
	FocusScopeId : ImGuiID, // Copied from g.CurrentFocusScopeId (unless another selection scope was pushed manually)
	Flags : ImGuiMultiSelectFlags,
	ScopeRectMin : ImVec2,
	BackupCursorMaxPos : ImVec2,
	LastSubmittedItem : ImGuiSelectionUserData, // Copy of last submitted item data, used to merge output ranges.
	BoxSelectId : ImGuiID,
	KeyMods : ImGuiKeyChord,
	LoopRequestSetAll : ImS8, // -1: no operation, 0: clear all, 1: select all.
	IsEndIO : bool, // Set when switching IO from BeginMultiSelect() to EndMultiSelect() state.
	IsFocused : bool, // Set if currently focusing the selection scope (any item of the selection). May be used if you have custom shortcut associated to selection.
	IsKeyboardSetRange : bool, // Set by BeginMultiSelect() when using Shift+Navigation. Because scrolling may be affected we can't afford a frame of lag with Shift+Navigation.
	NavIdPassedBy : bool,
	RangeSrcPassedBy : bool, // Set by the item that matches RangeSrcItem.
	RangeDstPassedBy : bool, }

// Set by the item that matches NavJustMovedToId when IsSetRange is set.

ImGuiMultiSelectTempData_init :: proc(this : ^ImGuiMultiSelectTempData) { Clear() }

// Zero-clear except IO as we preserve IO.Requests[] buffer allocation.
ImGuiMultiSelectTempData_Clear :: proc(this : ^ImGuiMultiSelectTempData)
{
	io_sz : uint = size_of(IO); ClearIO(); memset(cast(rawptr) (&this.IO + 1), 0, size_of(this) - io_sz)
}

ImGuiMultiSelectTempData_ClearIO :: proc(this : ^ImGuiMultiSelectTempData)
{
	resize(&this.IO.Requests, 0); this.IO.NavIdItem = ImGuiSelectionUserData_Invalid; this.IO.RangeSrcItem = this.IO.NavIdItem; this.IO.RangeSrcReset = false; this.IO.NavIdSelected = this.IO.RangeSrcReset
}

// Simple column measurement, currently used for MenuItem() only
// Persistent storage for multi-select (as long as selection is alive)
ImGuiMultiSelectState :: struct {
	Window : ^ImGuiWindow,
	ID : ImGuiID,
	LastFrameActive : i32, // Last used frame-count, for GC.
	LastSelectionSize : i32, // Set by BeginMultiSelect() based on optional info provided by user. May be -1 if unknown.
	RangeSelected : ImS8, // -1 (don't have) or true/false
	NavIdSelected : ImS8, // -1 (don't have) or true/false
	RangeSrcItem : ImGuiSelectionUserData, //
	NavIdItem : ImGuiSelectionUserData, }

// SetNextItemSelectionUserData() value for NavId (if part of submitted items)

ImGuiMultiSelectState_init :: proc(this : ^ImGuiMultiSelectState)
{
	this.Window = nil; this.ID = 0; this.LastSelectionSize = 0; this.LastFrameActive = this.LastSelectionSize; this.NavIdSelected = -1; this.RangeSelected = this.NavIdSelected; this.NavIdItem = ImGuiSelectionUserData_Invalid; this.RangeSrcItem = this.NavIdItem
}

//-----------------------------------------------------------------------------
// [SECTION] Docking support
//-----------------------------------------------------------------------------

DOCKING_HOST_DRAW_CHANNEL_BG :: 0// Dock host: background fill
DOCKING_HOST_DRAW_CHANNEL_FG :: 1// Dock host: decorations and contents

when IMGUI_HAS_DOCK {

// Extend ImGuiDockNodeFlags_
ImGuiDockNodeFlagsPrivate_ :: enum i32 {
	// [Internal]
	ImGuiDockNodeFlags_DockSpace = 1 << 10, // Saved // A dockspace is a node that occupy space within an existing user window. Otherwise the node is floating and create its own window.
	ImGuiDockNodeFlags_CentralNode = 1 << 11, // Saved // The central node has 2 main properties: stay visible when empty, only use "remaining" spaces from its neighbor.
	ImGuiDockNodeFlags_NoTabBar = 1 << 12, // Saved // Tab bar is completely unavailable. No triangle in the corner to enable it back.
	ImGuiDockNodeFlags_HiddenTabBar = 1 << 13, // Saved // Tab bar is hidden, with a triangle in the corner to show it again (NB: actual tab-bar instance may be destroyed as this is only used for single-window tab bar)
	ImGuiDockNodeFlags_NoWindowMenuButton = 1 << 14, // Saved // Disable window/docking menu (that one that appears instead of the collapse button)
	ImGuiDockNodeFlags_NoCloseButton = 1 << 15, // Saved // Disable close button
	ImGuiDockNodeFlags_NoResizeX = 1 << 16, //       //
	ImGuiDockNodeFlags_NoResizeY = 1 << 17, //       //
	ImGuiDockNodeFlags_DockedWindowsInFocusRoute = 1 << 18, //       // Any docked window will be automatically be focus-route chained (window->ParentWindowForFocusRoute set to this) so Shortcut() in this window can run when any docked window is focused.

	// Disable docking/undocking actions in this dockspace or individual node (existing docked nodes will be preserved)
	// Those are not exposed in public because the desirable sharing/inheriting/copy-flag-on-split behaviors are quite difficult to design and understand.
	// The two public flags ImGuiDockNodeFlags_NoDockingOverCentralNode/ImGuiDockNodeFlags_NoDockingSplit don't have those issues.
	ImGuiDockNodeFlags_NoDockingSplitOther = 1 << 19, //       // Disable this node from splitting other windows/nodes.
	ImGuiDockNodeFlags_NoDockingOverMe = 1 << 20, //       // Disable other windows/nodes from being docked over this node.
	ImGuiDockNodeFlags_NoDockingOverOther = 1 << 21, //       // Disable this node from being docked over another window or non-empty node.
	ImGuiDockNodeFlags_NoDockingOverEmpty = 1 << 22, //       // Disable this node from being docked over an empty node (e.g. DockSpace with no other windows)
	ImGuiDockNodeFlags_NoDocking = i32(ImGuiDockNodeFlags_NoDockingOverMe | ImGuiDockNodeFlags_NoDockingOverOther | ImGuiDockNodeFlags_NoDockingOverEmpty) | i32(ImGuiDockNodeFlags_.ImGuiDockNodeFlags_NoDockingSplit) | i32(ImGuiDockNodeFlags_NoDockingSplitOther),

	// Masks
	ImGuiDockNodeFlags_SharedFlagsInheritMask_ = ~i32(0),
	ImGuiDockNodeFlags_NoResizeFlagsMask_ = cast(i32) ImGuiDockNodeFlags_.ImGuiDockNodeFlags_NoResize | i32(ImGuiDockNodeFlags_NoResizeX | ImGuiDockNodeFlags_NoResizeY),

	// When splitting, those local flags are moved to the inheriting child, never duplicated
	ImGuiDockNodeFlags_LocalFlagsTransferMask_ = cast(i32) ImGuiDockNodeFlags_.ImGuiDockNodeFlags_NoDockingSplit | i32(ImGuiDockNodeFlags_NoResizeFlagsMask_) | cast(i32) ImGuiDockNodeFlags_.ImGuiDockNodeFlags_AutoHideTabBar | i32(ImGuiDockNodeFlags_CentralNode | ImGuiDockNodeFlags_NoTabBar | ImGuiDockNodeFlags_HiddenTabBar | ImGuiDockNodeFlags_NoWindowMenuButton | ImGuiDockNodeFlags_NoCloseButton),
	ImGuiDockNodeFlags_SavedFlagsMask_ = ImGuiDockNodeFlags_NoResizeFlagsMask_ | ImGuiDockNodeFlags_DockSpace | ImGuiDockNodeFlags_CentralNode | ImGuiDockNodeFlags_NoTabBar | ImGuiDockNodeFlags_HiddenTabBar | ImGuiDockNodeFlags_NoWindowMenuButton | ImGuiDockNodeFlags_NoCloseButton,
}

// Store the source authority (dock node vs window) of a field
ImGuiDataAuthority_ :: enum i32 {
	ImGuiDataAuthority_Auto,
	ImGuiDataAuthority_DockNode,
	ImGuiDataAuthority_Window,
}

ImGuiDockNodeState :: enum i32 {
	ImGuiDockNodeState_Unknown,
	ImGuiDockNodeState_HostWindowHiddenBecauseSingleWindow,
	ImGuiDockNodeState_HostWindowHiddenBecauseWindowsAreResizing,
	ImGuiDockNodeState_HostWindowVisible,
}

// Docking system dock/undock queued request
// sizeof() 156~192
ImGuiDockNode :: struct {
	ID : ImGuiID,
	SharedFlags : ImGuiDockNodeFlags, // (Write) Flags shared by all nodes of a same dockspace hierarchy (inherited from the root node)
	LocalFlags : ImGuiDockNodeFlags, // (Write) Flags specific to this node
	LocalFlagsInWindows : ImGuiDockNodeFlags, // (Write) Flags specific to this node, applied from windows
	MergedFlags : ImGuiDockNodeFlags, // (Read)  Effective flags (== SharedFlags | LocalFlagsInNode | LocalFlagsInWindows)
	State : ImGuiDockNodeState,
	ParentNode : ^ImGuiDockNode,
	ChildNodes : [2]^ImGuiDockNode, // [Split node only] Child nodes (left/right or top/bottom). Consider switching to an array.
	Windows : ImVector(^ImGuiWindow), // Note: unordered list! Iterate TabBar->Tabs for user-order.
	TabBar : ^ImGuiTabBar,
	Pos : ImVec2, // Current position
	Size : ImVec2, // Current size
	SizeRef : ImVec2, // [Split node only] Last explicitly written-to size (overridden when using a splitter affecting the node), used to calculate Size.
	SplitAxis : ImGuiAxis, // [Split node only] Split axis (X or Y)
	WindowClass : ImGuiWindowClass, // [Root node only]
	LastBgColor : ImU32,

	HostWindow : ^ImGuiWindow,
	VisibleWindow : ^ImGuiWindow, // Generally point to window which is ID is == SelectedTabID, but when CTRL+Tabbing this can be a different window.
	CentralNode : ^ImGuiDockNode, // [Root node only] Pointer to central node.
	OnlyNodeWithWindows : ^ImGuiDockNode, // [Root node only] Set when there is a single visible node within the hierarchy.
	CountNodeWithWindows : i32, // [Root node only]
	LastFrameAlive : i32, // Last frame number the node was updated or kept alive explicitly with DockSpace() + ImGuiDockNodeFlags_KeepAliveOnly
	LastFrameActive : i32, // Last frame number the node was updated.
	LastFrameFocused : i32, // Last frame number the node was focused.
	LastFocusedNodeId : ImGuiID, // [Root node only] Which of our child docking node (any ancestor in the hierarchy) was last focused.
	SelectedTabId : ImGuiID, // [Leaf node only] Which of our tab/window is selected.
	WantCloseTabId : ImGuiID, // [Leaf node only] Set when closing a specific tab/window.
	RefViewportId : ImGuiID, // Reference viewport ID from visible window when HostWindow == NULL.
	using _0 : bit_field u32 {
		AuthorityForPos : ImGuiDataAuthority | 3,
		AuthorityForSize : ImGuiDataAuthority | 3,
		AuthorityForViewport : ImGuiDataAuthority | 3,
		IsVisible : bool | 1, // Set to false when the node is hidden (usually disabled as it has no active window)
		IsFocused : bool | 1,
		IsBgDrawnThisFrame : bool | 1,
		HasCloseButton : bool | 1, // Provide space for a close button (if any of the docked window has one). Note that button may be hidden on window without one.
		HasWindowMenuButton : bool | 1,
		HasCentralNodeChild : bool | 1,
		WantCloseAll : bool | 1, // Set when closing all tabs at once.
		WantLockSizeOnce : bool | 1,
		WantMouseMove : bool | 1, // After a node extraction we need to transition toward moving the newly created host window
		WantHiddenTabBarUpdate : bool | 1,
		WantHiddenTabBarToggle : bool | 1,
	},
}

ImGuiDockNode_IsRootNode :: proc(this : ^ImGuiDockNode) -> bool { return this.ParentNode == nil }

ImGuiDockNode_IsDockSpace :: proc(this : ^ImGuiDockNode) -> bool { return (this.MergedFlags & ImGuiDockNodeFlagsPrivate_.ImGuiDockNodeFlags_DockSpace) != 0 }

ImGuiDockNode_IsFloatingNode :: proc(this : ^ImGuiDockNode) -> bool { return this.ParentNode == nil && (this.MergedFlags & ImGuiDockNodeFlagsPrivate_.ImGuiDockNodeFlags_DockSpace) == 0 }

ImGuiDockNode_IsCentralNode :: proc(this : ^ImGuiDockNode) -> bool { return (this.MergedFlags & ImGuiDockNodeFlagsPrivate_.ImGuiDockNodeFlags_CentralNode) != 0 }

// Hidden tab bar can be shown back by clicking the small triangle
ImGuiDockNode_IsHiddenTabBar :: proc(this : ^ImGuiDockNode) -> bool { return (this.MergedFlags & ImGuiDockNodeFlagsPrivate_.ImGuiDockNodeFlags_HiddenTabBar) != 0 }

// Never show a tab bar
ImGuiDockNode_IsNoTabBar :: proc(this : ^ImGuiDockNode) -> bool { return (this.MergedFlags & ImGuiDockNodeFlagsPrivate_.ImGuiDockNodeFlags_NoTabBar) != 0 }

ImGuiDockNode_IsSplitNode :: proc(this : ^ImGuiDockNode) -> bool { return this.ChildNodes[0] != nil }

ImGuiDockNode_IsLeafNode :: proc(this : ^ImGuiDockNode) -> bool { return this.ChildNodes[0] == nil }

ImGuiDockNode_IsEmpty :: proc(this : ^ImGuiDockNode) -> bool { return this.ChildNodes[0] == nil && this.Windows.Size == 0 }

ImGuiDockNode_Rect :: proc(this : ^ImGuiDockNode) -> ImRect { return ImRect(this.Pos.x, this.Pos.y, this.Pos.x + this.Size.x, this.Pos.y + this.Size.y) }

ImGuiDockNode_SetLocalFlags :: proc(this : ^ImGuiDockNode, flags : ImGuiDockNodeFlags)
{
	this.LocalFlags = flags; UpdateMergedFlags()
}

ImGuiDockNode_UpdateMergedFlags :: proc(this : ^ImGuiDockNode) { this.MergedFlags = this.SharedFlags | this.LocalFlags | this.LocalFlagsInWindows }

// List of colors that are stored at the time of Begin() into Docked Windows.
// We currently store the packed colors in a simple array window->DockStyle.Colors[].
// A better solution may involve appending into a log of colors in ImGuiContext + store offsets into those arrays in ImGuiWindow,
// but it would be more complex as we'd need to double-buffer both as e.g. drop target may refer to window from last frame.
ImGuiWindowDockStyleCol :: enum i32 {
	ImGuiWindowDockStyleCol_Text,
	ImGuiWindowDockStyleCol_TabHovered,
	ImGuiWindowDockStyleCol_TabFocused,
	ImGuiWindowDockStyleCol_TabSelected,
	ImGuiWindowDockStyleCol_TabSelectedOverline,
	ImGuiWindowDockStyleCol_TabDimmed,
	ImGuiWindowDockStyleCol_TabDimmedSelected,
	ImGuiWindowDockStyleCol_TabDimmedSelectedOverline,
	ImGuiWindowDockStyleCol_COUNT,
}

// Storage for one window
// We don't store style.Alpha: dock_node->LastBgColor embeds it and otherwise it would only affect the docking tab, which intuitively I would say we don't want to.
ImGuiWindowDockStyle :: struct {
	Colors : [ImGuiWindowDockStyleCol.ImGuiWindowDockStyleCol_COUNT]ImU32,
}

// Type information associated to a ImGuiDataType enum
ImGuiDockContext :: struct {
	Nodes : ImGuiStorage, // Map ID -> ImGuiDockNode*: Active nodes
	Requests : ImVector(ImGuiDockRequest),
	NodesSettings : ImVector(ImGuiDockNodeSettings),
	WantFullRebuild : bool,
}

ImGuiDockContext_init :: proc(this : ^ImGuiDockContext) { memset(this, 0, size_of(this)) }

} // preproc endif// #ifdef IMGUI_HAS_DOCK

//-----------------------------------------------------------------------------
// [SECTION] Viewport support
//-----------------------------------------------------------------------------

// ImGuiViewport Private/Internals fields (cardinal sin: we are using inheritance!)
// Every instance of ImGuiViewport is in fact a ImGuiViewportP.
ImGuiViewportP :: struct {
	using __base_imguiviewport : ImGuiViewport,
	Window : ^ImGuiWindow, // Set when the viewport is owned by a window (and ImGuiViewportFlags_CanHostOtherWindows is NOT set)
	Idx : i32,
	LastFrameActive : i32, // Last frame number this viewport was activated by a window
	LastFocusedStampCount : i32, // Last stamp number from when a window hosted by this viewport was focused (by comparing this value between two viewport we have an implicit viewport z-order we use as fallback)
	LastNameHash : ImGuiID,
	LastPos : ImVec2,
	LastSize : ImVec2,
	Alpha : f32, // Window opacity (when dragging dockable windows/viewports we make them transparent)
	LastAlpha : f32,
	LastFocusedHadNavWindow : bool, // Instead of maintaining a LastFocusedWindow (which may harder to correctly maintain), we merely store weither NavWindow != NULL last time the viewport was focused.
	PlatformMonitor : i16,
	BgFgDrawListsLastFrame : [2]i32, // Last frame number the background (0) and foreground (1) draw lists were used
	BgFgDrawLists : [2]^ImDrawList, // Convenience background (0) and foreground (1) draw lists. We use them to draw software mouser cursor when io.MouseDrawCursor is set and to draw most debug overlays.
	DrawDataP : ImDrawData,
	DrawDataBuilder : ImDrawDataBuilder, // Temporary data while building final ImDrawData
	LastPlatformPos : ImVec2,
	LastPlatformSize : ImVec2,
	LastRendererSize : ImVec2,

	// Per-viewport work area
	// - Insets are >= 0.0f values, distance from viewport corners to work area.
	// - BeginMainMenuBar() and DockspaceOverViewport() tend to use work area to avoid stepping over existing contents.
	// - Generally 'safeAreaInsets' in iOS land, 'DisplayCutout' in Android land.
	WorkInsetMin : ImVec2, // Work Area inset locked for the frame. GetWorkRect() always fits within GetMainRect().
	WorkInsetMax : ImVec2, // "
	BuildWorkInsetMin : ImVec2, // Work Area inset accumulator for current frame, to become next frame's WorkInset
	BuildWorkInsetMax : ImVec2, }

ImGuiViewportP_deinit :: proc(this : ^ImGuiViewportP)
{
	if this.BgFgDrawLists[0] != nil { IM_DELETE(this.BgFgDrawLists[0]) }
	if this.BgFgDrawLists[1] != nil { IM_DELETE(this.BgFgDrawLists[1]) }
}

// Platform window requested closure (e.g. window was moved by the OS / host window manager, e.g. pressing ALT-F4)

// "

ImGuiViewportP_init :: proc(this : ^ImGuiViewportP)
{
	this.Window = nil; this.Idx = -1; this.LastFocusedStampCount = -1; this.BgFgDrawListsLastFrame[1] = this.LastFocusedStampCount; this.BgFgDrawListsLastFrame[0] = this.BgFgDrawListsLastFrame[1]; this.LastFrameActive = this.BgFgDrawListsLastFrame[0]; this.LastNameHash = 0; this.LastAlpha = 1.0; this.Alpha = this.LastAlpha; this.LastFocusedHadNavWindow = false; this.PlatformMonitor = -1; this.BgFgDrawLists[1] = nil; this.BgFgDrawLists[0] = this.BgFgDrawLists[1]; this.LastRendererSize = ImVec2(FLT_MAX, FLT_MAX); this.LastPlatformSize = this.LastRendererSize; this.LastPlatformPos = this.LastPlatformSize
}

ImGuiViewportP_ClearRequestFlags :: proc(this : ^ImGuiViewportP) { this.PlatformRequestResize = false; this.PlatformRequestMove = this.PlatformRequestResize; this.PlatformRequestClose = this.PlatformRequestMove }

// Calculate work rect pos/size given a set of offset (we have 1 pair of offset for rect locked from last frame data, and 1 pair for currently building rect)
ImGuiViewportP_CalcWorkRectPos :: proc(this : ^ImGuiViewportP, inset_min : ^ImVec2) -> ImVec2 { return ImVec2(this.Pos.x + inset_min.x, this.Pos.y + inset_min.y) }

ImGuiViewportP_CalcWorkRectSize :: proc(this : ^ImGuiViewportP, inset_min : ^ImVec2, inset_max : ^ImVec2) -> ImVec2 { return ImVec2(ImMax(0.0, this.Size.x - inset_min.x - inset_max.x), ImMax(0.0, this.Size.y - inset_min.y - inset_max.y)) }

// Update public fields
ImGuiViewportP_UpdateWorkRect :: proc(this : ^ImGuiViewportP)
{
	this.WorkPos = CalcWorkRectPos(this.WorkInsetMin); this.WorkSize = CalcWorkRectSize(this.WorkInsetMin, this.WorkInsetMax)
}

// Helpers to retrieve ImRect (we don't need to store BuildWorkRect as every access tend to change it, hence the code asymmetry)
ImGuiViewportP_GetMainRect :: proc(this : ^ImGuiViewportP) -> ImRect { return ImRect(this.Pos.x, this.Pos.y, this.Pos.x + this.Size.x, this.Pos.y + this.Size.y) }

ImGuiViewportP_GetWorkRect :: proc(this : ^ImGuiViewportP) -> ImRect { return ImRect(this.WorkPos.x, this.WorkPos.y, this.WorkPos.x + this.WorkSize.x, this.WorkPos.y + this.WorkSize.y) }

ImGuiViewportP_GetBuildWorkRect :: proc(this : ^ImGuiViewportP) -> ImRect
{
	pos : ImVec2 = CalcWorkRectPos(this.BuildWorkInsetMin); size : ImVec2 = CalcWorkRectSize(this.BuildWorkInsetMin, this.BuildWorkInsetMax); return ImRect(pos.x, pos.y, pos.x + size.x, pos.y + size.y)
}

// Temporary storage for one window (that's the data which in theory we could ditch at the end of the frame, in practice we currently keep it for each window)
//-----------------------------------------------------------------------------
// [SECTION] Settings support
//-----------------------------------------------------------------------------

// Windows data saved in imgui.ini file
// Because we never destroy or rename ImGuiWindowSettings, we can store the names in a separate buffer easily.
// (this is designed to be stored in a ImChunkStream buffer, with the variable-length Name following our structure)
ImGuiWindowSettings :: struct {
	ID : ImGuiID,
	Pos : ImVec2ih, // NB: Settings position are stored RELATIVE to the viewport! Whereas runtime ones are absolute positions.
	Size : ImVec2ih,
	ViewportPos : ImVec2ih,
	ViewportId : ImGuiID,
	DockId : ImGuiID, // ID of last known DockNode (even if the DockNode is invisible because it has only 1 active window), or 0 if none.
	ClassId : ImGuiID, // ID of window class if specified
	DockOrder : i16, // Order of the last time the window was visible within its DockNode. This is used to reorder windows that are reappearing on the same frame. Same value between windows that were active and windows that were none are possible.
	Collapsed : bool,
	IsChild : bool,
	WantApply : bool, // Set when loaded from .ini data (to enable merging/loading .ini data into an already running context)
	WantDelete : bool, }

// Set to invalidate/delete the settings entry

ImGuiWindowSettings_init :: proc(this : ^ImGuiWindowSettings)
{
	memset(this, 0, size_of(this)); this.DockOrder = -1
}

ImGuiWindowSettings_GetName :: proc(this : ^ImGuiWindowSettings) -> ^u8 { return cast(^u8) (this + 1) }

// Storage for current popup stack
ImGuiSettingsHandler :: struct {
	TypeName : ^u8, // Short description stored in .ini file. Disallowed characters: '[' ']'
	TypeHash : ImGuiID, // == ImHashStr(TypeName)
	ClearAllFn : proc(	_ctx : ^ImGuiContext, 	_handler : ^ImGuiSettingsHandler), // Clear all settings data
	ReadInitFn : proc(	_ctx : ^ImGuiContext, 	_handler : ^ImGuiSettingsHandler), // Read: Called before reading (in registration order)
	ReadOpenFn : proc(	_ctx : ^ImGuiContext, 	_handler : ^ImGuiSettingsHandler, 	_name : ^u8) -> rawptr, // Read: Called when entering into a new ini entry e.g. "[Window][Name]"
	ReadLineFn : proc(	_ctx : ^ImGuiContext, 	_handler : ^ImGuiSettingsHandler, 	_entry : rawptr, 	_line : ^u8), // Read: Called for every line of text within an ini entry
	ApplyAllFn : proc(	_ctx : ^ImGuiContext, 	_handler : ^ImGuiSettingsHandler), // Read: Called after reading (in registration order)
	WriteAllFn : proc(	_ctx : ^ImGuiContext, 	_handler : ^ImGuiSettingsHandler, 	_out_buf : ^ImGuiTextBuffer), // Write: Output every entries into 'out_buf'
	UserData : rawptr,
}

ImGuiSettingsHandler_init :: proc(this : ^ImGuiSettingsHandler) { memset(this, 0, size_of(this)) }

// Storage for a window .ini settings (we keep one of those even if the actual window wasn't instanced during this session)

// Enumerations
// Use your programming IDE "Go to definition" facility on the names of the center columns to find the actual flags/enum lists.
//-----------------------------------------------------------------------------
// [SECTION] Localization support
//-----------------------------------------------------------------------------

// This is experimental and not officially supported, it'll probably fall short of features, if/when it does we may backtrack.
ImGuiLocKey :: enum i32 {
	ImGuiLocKey_VersionStr,
	ImGuiLocKey_TableSizeOne,
	ImGuiLocKey_TableSizeAllFit,
	ImGuiLocKey_TableSizeAllDefault,
	ImGuiLocKey_TableResetOrder,
	ImGuiLocKey_WindowingMainMenuBar,
	ImGuiLocKey_WindowingPopup,
	ImGuiLocKey_WindowingUntitled,
	ImGuiLocKey_OpenLink_s,
	ImGuiLocKey_CopyLink,
	ImGuiLocKey_DockingHideTabBar,
	ImGuiLocKey_DockingHoldShiftToDock,
	ImGuiLocKey_DockingDragToUndockOrMoveNode,
	ImGuiLocKey_COUNT,
}

// Status storage for last submitted items
ImGuiLocEntry :: struct {
	Key : ImGuiLocKey,
	Text : cstring,
}

//-----------------------------------------------------------------------------
// [SECTION] Error handling, State recovery support
//-----------------------------------------------------------------------------

// Macros used by Recoverable Error handling
// - Only dispatch error if _EXPR: evaluate as assert (similar to an assert macro).
// - The message will always be a string literal, in order to increase likelihood of being display by an assert handler.
// - See 'Demo->Configuration->Error Handling' and ImGuiIO definitions for details on error handling.
// - Read https://github.com/ocornut/imgui/wiki/Error-Handling for details on error handling.
//when ! defined ( IM_ASSERT_USER_ERROR ) {
IM_ASSERT_USER_ERROR :: #force_inline proc "contextless" (_EXPR : $T0, _MSG : $T1)
{
	// Recoverable User Error
	if(!_EXPR && ImGui_ErrorLog(_MSG)) {
		IM_ASSERT(_EXPR && _MSG);
	}
}

//} // preproc endif

// The error callback is currently not public, as it is expected that only advanced users will rely on it.
ImGuiErrorCallback :: proc(ctx : ^ImGuiContext, user_data : rawptr, msg : ^u8)// Function signature for g.ErrorCallback

//-----------------------------------------------------------------------------
// [SECTION] Metrics, Debug Tools
//-----------------------------------------------------------------------------

// See IMGUI_DEBUG_LOG() and IMGUI_DEBUG_LOG_XXX() macros.
ImGuiDebugLogFlags_ :: enum i32 {
	// Event types
	ImGuiDebugLogFlags_None = 0,
	ImGuiDebugLogFlags_EventError = 1 << 0, // Error submitted by IM_ASSERT_USER_ERROR()
	ImGuiDebugLogFlags_EventActiveId = 1 << 1,
	ImGuiDebugLogFlags_EventFocus = 1 << 2,
	ImGuiDebugLogFlags_EventPopup = 1 << 3,
	ImGuiDebugLogFlags_EventNav = 1 << 4,
	ImGuiDebugLogFlags_EventClipper = 1 << 5,
	ImGuiDebugLogFlags_EventSelection = 1 << 6,
	ImGuiDebugLogFlags_EventIO = 1 << 7,
	ImGuiDebugLogFlags_EventFont = 1 << 8,
	ImGuiDebugLogFlags_EventInputRouting = 1 << 9,
	ImGuiDebugLogFlags_EventDocking = 1 << 10,
	ImGuiDebugLogFlags_EventViewport = 1 << 11,

	ImGuiDebugLogFlags_EventMask_ = ImGuiDebugLogFlags_EventError | ImGuiDebugLogFlags_EventActiveId | ImGuiDebugLogFlags_EventFocus | ImGuiDebugLogFlags_EventPopup | ImGuiDebugLogFlags_EventNav | ImGuiDebugLogFlags_EventClipper | ImGuiDebugLogFlags_EventSelection | ImGuiDebugLogFlags_EventIO | ImGuiDebugLogFlags_EventFont | ImGuiDebugLogFlags_EventInputRouting | ImGuiDebugLogFlags_EventDocking | ImGuiDebugLogFlags_EventViewport,
	ImGuiDebugLogFlags_OutputToTTY = 1 << 20, // Also send output to TTY
	ImGuiDebugLogFlags_OutputToTestEngine = 1 << 21, // Also send output to Test Engine
}

ImGuiDebugAllocEntry :: struct {
	FrameCount : i32,
	AllocCount : ImS16,
	FreeCount : ImS16,
}

ImGuiDebugAllocInfo :: struct {
	TotalAllocCount : i32, // Number of call to MemAlloc().
	TotalFreeCount : i32,
	LastEntriesIdx : ImS16, // Current index in buffer
	LastEntriesBuf : [6]ImGuiDebugAllocEntry, }

// Track last 6 frames that had allocations

ImGuiDebugAllocInfo_init :: proc(this : ^ImGuiDebugAllocInfo) { memset(this, 0, size_of(this)) }

// Result of a keyboard/gamepad directional navigation move query result
ImGuiMetricsConfig :: struct {
	ShowDebugLog : bool,
	ShowIDStackTool : bool,
	ShowWindowsRects : bool,
	ShowWindowsBeginOrder : bool,
	ShowTablesRects : bool,
	ShowDrawCmdMesh : bool,
	ShowDrawCmdBoundingBoxes : bool,
	ShowTextEncodingViewer : bool,
	ShowAtlasTintedWithTextColor : bool,
	ShowDockingNodes : bool,
	ShowWindowsRectsType : i32,
	ShowTablesRectsType : i32,
	HighlightMonitorIdx : i32,
	HighlightViewportID : ImGuiID,
}

ImGuiMetricsConfig_init :: proc(this : ^ImGuiMetricsConfig)
{
this.ShowDebugLog = false
this.ShowIDStackTool = false
this.ShowWindowsRects = false
this.ShowWindowsBeginOrder = false
this.ShowTablesRects = false
this.ShowDrawCmdMesh = true
this.ShowDrawCmdBoundingBoxes = true
this.ShowTextEncodingViewer = false
this.ShowAtlasTintedWithTextColor = false
this.ShowDockingNodes = false
this.ShowWindowsRectsType = -1
this.ShowTablesRectsType = -1
this.HighlightMonitorIdx = -1
this.HighlightViewportID = 0

}

ImGuiStackLevelInfo :: struct {
	ID : ImGuiID,
	QueryFrameCount : ImS8, // >= 1: Query in progress
	QuerySuccess : bool, // Obtained result from DebugHookIdInfo()
	using _0 : bit_field u8 {
		DataType : ImGuiDataType | 8,
	},
	Desc : [57]u8, }

// Arbitrarily sized buffer to hold a result (FIXME: could replace Results[] with a chunk stream?) FIXME: Now that we added CTRL+C this should be fixed.

ImGuiStackLevelInfo_init :: proc(this : ^ImGuiStackLevelInfo) { memset(this, 0, size_of(this)) }

// State for ID Stack tool queries
ImGuiIDStackTool :: struct {
	LastActiveFrame : i32,
	StackLevel : i32, // -1: query stack and resize Results, >= 0: individual stack level
	QueryId : ImGuiID, // ID to query details for
	Results : ImVector(ImGuiStackLevelInfo),
	CopyToClipboardOnCtrlC : bool,
	CopyToClipboardLastTime : f32,
}

ImGuiIDStackTool_init :: proc(this : ^ImGuiIDStackTool)
{
	memset(this, 0, size_of(this)); this.CopyToClipboardLastTime = -FLT_MAX
}

//-----------------------------------------------------------------------------
// [SECTION] Generic context hooks
//-----------------------------------------------------------------------------

ImGuiContextHookCallback :: proc(ctx : ^ImGuiContext, hook : ^ImGuiContextHook)
ImGuiContextHookType :: enum i32 { ImGuiContextHookType_NewFramePre, ImGuiContextHookType_NewFramePost, ImGuiContextHookType_EndFramePre, ImGuiContextHookType_EndFramePost, ImGuiContextHookType_RenderPre, ImGuiContextHookType_RenderPost, ImGuiContextHookType_Shutdown, ImGuiContextHookType_PendingRemoval_, }

// Main Dear ImGui context
ImGuiContextHook :: struct {
	HookId : ImGuiID, // A unique ID assigned by AddContextHook()
	Type : ImGuiContextHookType,
	Owner : ImGuiID,
	Callback : ImGuiContextHookCallback,
	UserData : rawptr,
}

ImGuiContextHook_init :: proc(this : ^ImGuiContextHook) { memset(this, 0, size_of(this)) }

// Helper functions to create a color that can be converted to either u32 or float4 (*OBSOLETE* please avoid using)
// Stacked color modifier, backup of modified data so we can restore it
//-----------------------------------------------------------------------------
// [SECTION] ImGuiContext (main Dear ImGui context)
//-----------------------------------------------------------------------------

ImGuiContext :: struct {
	Initialized : bool,
	FontAtlasOwnedByContext : bool, // IO.Fonts-> is owned by the ImGuiContext and will be destructed along with it.
	IO : ImGuiIO,
	PlatformIO : ImGuiPlatformIO,
	Style : ImGuiStyle,
	ConfigFlagsCurrFrame : ImGuiConfigFlags, // = g.IO.ConfigFlags at the time of NewFrame()
	ConfigFlagsLastFrame : ImGuiConfigFlags,
	Font : ^ImFont, // (Shortcut) == FontStack.empty() ? IO.Font : FontStack.back()
	FontSize : f32, // (Shortcut) == FontBaseSize * g.CurrentWindow->FontWindowScale == window->FontSize(). Text height for current window.
	FontBaseSize : f32, // (Shortcut) == IO.FontGlobalScale * Font->Scale * Font->FontSize. Base text height.
	FontScale : f32, // == FontSize / Font->FontSize
	CurrentDpiScale : f32, // Current window/viewport DpiScale == CurrentViewport->DpiScale
	DrawListSharedData : ImDrawListSharedData,
	Time : f64,
	FrameCount : i32,
	FrameCountEnded : i32,
	FrameCountPlatformEnded : i32,
	FrameCountRendered : i32,
	WithinEndChildID : ImGuiID, // Set within EndChild()
	WithinFrameScope : bool, // Set by NewFrame(), cleared by EndFrame()
	WithinFrameScopeWithImplicitWindow : bool, // Set by NewFrame(), cleared by EndFrame() when the implicit debug window has been pushed
	GcCompactAll : bool, // Request full GC
	TestEngineHookItems : bool, // Will call test engine hooks: ImGuiTestEngineHook_ItemAdd(), ImGuiTestEngineHook_ItemInfo(), ImGuiTestEngineHook_Log()
	TestEngine : rawptr, // Test engine user data
	ContextName : [16]u8, // Storage for a context name (to facilitate debugging multi-context setups)

	// Inputs
	InputEventsQueue : ImVector(ImGuiInputEvent), // Input events which will be trickled/written into IO structure.
	InputEventsTrail : ImVector(ImGuiInputEvent), // Past input events processed in NewFrame(). This is to allow domain-specific application to access e.g mouse/pen trail.
	InputEventsNextMouseSource : ImGuiMouseSource,
	InputEventsNextEventId : ImU32,

	// Windows state
	Windows : ImVector(^ImGuiWindow), // Windows, sorted in display order, back to front
	WindowsFocusOrder : ImVector(^ImGuiWindow), // Root windows, sorted in focus order, back to front.
	WindowsTempSortBuffer : ImVector(^ImGuiWindow), // Temporary buffer used in EndFrame() to reorder windows so parents are kept before their child
	CurrentWindowStack : ImVector(ImGuiWindowStackData),
	WindowsById : ImGuiStorage, // Map window's ImGuiID to ImGuiWindow*
	WindowsActiveCount : i32, // Number of unique windows submitted by frame
	WindowsHoverPadding : ImVec2, // Padding around resizable windows for which hovering on counts as hovering the window == ImMax(style.TouchExtraPadding, WINDOWS_HOVER_PADDING).
	DebugBreakInWindow : ImGuiID, // Set to break in Begin() call.
	CurrentWindow : ^ImGuiWindow, // Window being drawn into
	HoveredWindow : ^ImGuiWindow, // Window the mouse is hovering. Will typically catch mouse inputs.
	HoveredWindowUnderMovingWindow : ^ImGuiWindow, // Hovered window ignoring MovingWindow. Only set if MovingWindow is set.
	HoveredWindowBeforeClear : ^ImGuiWindow, // Window the mouse is hovering. Filled even with _NoMouse. This is currently useful for multi-context compositors.
	MovingWindow : ^ImGuiWindow, // Track the window we clicked on (in order to preserve focus). The actual window that is moved is generally MovingWindow->RootWindowDockTree.
	WheelingWindow : ^ImGuiWindow, // Track the window we started mouse-wheeling on. Until a timer elapse or mouse has moved, generally keep scrolling the same window even if during the course of scrolling the mouse ends up hovering a child window.
	WheelingWindowRefMousePos : ImVec2,
	WheelingWindowStartFrame : i32, // This may be set one frame before WheelingWindow is != NULL
	WheelingWindowScrolledFrame : i32,
	WheelingWindowReleaseTimer : f32,
	WheelingWindowWheelRemainder : ImVec2,
	WheelingAxisAvg : ImVec2,

	// Item/widgets state and tracking information
	DebugDrawIdConflicts : ImGuiID, // Set when we detect multiple items with the same identifier
	DebugHookIdInfo : ImGuiID, // Will call core hooks: DebugHookIdInfo() from GetID functions, used by ID Stack Tool [next HoveredId/ActiveId to not pull in an extra cache-line]
	HoveredId : ImGuiID, // Hovered widget, filled during the frame
	HoveredIdPreviousFrame : ImGuiID,
	HoveredIdPreviousFrameItemCount : i32, // Count numbers of items using the same ID as last frame's hovered id
	HoveredIdTimer : f32, // Measure contiguous hovering time
	HoveredIdNotActiveTimer : f32, // Measure contiguous hovering time where the item has not been active
	HoveredIdAllowOverlap : bool,
	HoveredIdIsDisabled : bool, // At least one widget passed the rect test, but has been discarded by disabled flag or popup inhibit. May be true even if HoveredId == 0.
	ItemUnclipByLog : bool, // Disable ItemAdd() clipping, essentially a memory-locality friendly copy of LogEnabled
	ActiveId : ImGuiID, // Active widget
	ActiveIdIsAlive : ImGuiID, // Active widget has been seen this frame (we can't use a bool as the ActiveId may change within the frame)
	ActiveIdTimer : f32,
	ActiveIdIsJustActivated : bool, // Set at the time of activation for one frame
	ActiveIdAllowOverlap : bool, // Active widget allows another widget to steal active id (generally for overlapping widgets, but not always)
	ActiveIdNoClearOnFocusLoss : bool, // Disable losing active id if the active id window gets unfocused.
	ActiveIdHasBeenPressedBefore : bool, // Track whether the active id led to a press (this is to allow changing between PressOnClick and PressOnRelease without pressing twice). Used by range_select branch.
	ActiveIdHasBeenEditedBefore : bool, // Was the value associated to the widget Edited over the course of the Active state.
	ActiveIdHasBeenEditedThisFrame : bool,
	ActiveIdFromShortcut : bool,
	using _0 : bit_field u8 {
		ActiveIdMouseButton : i32 | 8,
	},
	ActiveIdClickOffset : ImVec2, // Clicked offset from upper-left corner, if applicable (currently only set by ButtonBehavior)
	ActiveIdWindow : ^ImGuiWindow,
	ActiveIdSource : ImGuiInputSource, // Activating source: ImGuiInputEventType_Mouse OR ImGuiInputSource_Keyboard OR ImGuiInputSource_Gamepad
	ActiveIdPreviousFrame : ImGuiID,
	ActiveIdPreviousFrameIsAlive : bool,
	ActiveIdPreviousFrameHasBeenEditedBefore : bool,
	ActiveIdPreviousFrameWindow : ^ImGuiWindow,
	ActiveIdValueOnActivation : ImGuiDataTypeStorage, // Backup of initial value at the time of activation. ONLY SET BY SPECIFIC WIDGETS: DragXXX and SliderXXX.
	LastActiveId : ImGuiID, // Store the last non-zero ActiveId, useful for animation.
	LastActiveIdTimer : f32, // Store the last non-zero ActiveId timer since the beginning of activation, useful for animation.

	// Key/Input Ownership + Shortcut Routing system
	// - The idea is that instead of "eating" a given key, we can link to an owner.
	// - Input query can then read input by specifying ImGuiKeyOwner_Any (== 0), ImGuiKeyOwner_NoOwner (== -1) or a custom ID.
	// - Routing is requested ahead of time for a given chord (Key + Mods) and granted in NewFrame().
	LastKeyModsChangeTime : f64, // Record the last time key mods changed (affect repeat delay when using shortcut logic)
	LastKeyModsChangeFromNoneTime : f64, // Record the last time key mods changed away from being 0 (affect repeat delay when using shortcut logic)
	LastKeyboardKeyPressTime : f64, // Record the last time a keyboard key (ignore mouse/gamepad ones) was pressed.
	KeysMayBeCharInput : ImBitArrayForNamedKeys, // Lookup to tell if a key can emit char input, see IsKeyChordPotentiallyCharInput(). sizeof() = 20 bytes
	KeysOwnerData : [ImGuiKey.ImGuiKey_NamedKey_COUNT]ImGuiKeyOwnerData,
	KeysRoutingTable : ImGuiKeyRoutingTable,
	ActiveIdUsingNavDirMask : ImU32, // Active widget will want to read those nav move requests (e.g. can activate a button and move away from it)
	ActiveIdUsingAllKeyboardKeys : bool, // Active widget will want to read all keyboard keys inputs. (this is a shortcut for not taking ownership of 100+ keys, frequently used by drag operations)
	DebugBreakInShortcutRouting : ImGuiKeyChord, // Set to break in SetShortcutRouting()/Shortcut() calls.
	//ImU32                 ActiveIdUsingNavInputMask;          // [OBSOLETE] Since (IMGUI_VERSION_NUM >= 18804) : 'g.ActiveIdUsingNavInputMask |= (1 << ImGuiNavInput_Cancel);' becomes --> 'SetKeyOwner(ImGuiKey_Escape, g.ActiveId) and/or SetKeyOwner(ImGuiKey_NavGamepadCancel, g.ActiveId);'

	// Next window/item data
	CurrentFocusScopeId : ImGuiID, // Value for currently appending items == g.FocusScopeStack.back(). Not to be mistaken with g.NavFocusScopeId.
	CurrentItemFlags : ImGuiItemFlags, // Value for currently appending items == g.ItemFlagsStack.back()
	DebugLocateId : ImGuiID, // Storage for DebugLocateItemOnHover() feature: this is read by ItemAdd() so we keep it in a hot/cached location
	NextItemData : ImGuiNextItemData, // Storage for SetNextItem** functions
	LastItemData : ImGuiLastItemData, // Storage for last submitted item (setup by ItemAdd)
	NextWindowData : ImGuiNextWindowData, // Storage for SetNextWindow** functions
	DebugShowGroupRects : bool,

	// Shared stacks
	DebugFlashStyleColorIdx : ImGuiCol, // (Keep close to ColorStack to share cache line)
	ColorStack : ImVector(ImGuiColorMod), // Stack for PushStyleColor()/PopStyleColor() - inherited by Begin()
	StyleVarStack : ImVector(ImGuiStyleMod), // Stack for PushStyleVar()/PopStyleVar() - inherited by Begin()
	FontStack : ImVector(^ImFont), // Stack for PushFont()/PopFont() - inherited by Begin()
	FocusScopeStack : ImVector(ImGuiFocusScopeData), // Stack for PushFocusScope()/PopFocusScope() - inherited by BeginChild(), pushed into by Begin()
	ItemFlagsStack : ImVector(ImGuiItemFlags), // Stack for PushItemFlag()/PopItemFlag() - inherited by Begin()
	GroupStack : ImVector(ImGuiGroupData), // Stack for BeginGroup()/EndGroup() - not inherited by Begin()
	OpenPopupStack : ImVector(ImGuiPopupData), // Which popups are open (persistent)
	BeginPopupStack : ImVector(ImGuiPopupData), // Which level of BeginPopup() we are in (reset every frame)
	TreeNodeStack : ImVector(ImGuiTreeNodeStackData), // Stack for TreeNode()

	// Viewports
	Viewports : ImVector(^ImGuiViewportP), // Active viewports (always 1+, and generally 1 unless multi-viewports are enabled). Each viewports hold their copy of ImDrawData.
	CurrentViewport : ^ImGuiViewportP, // We track changes of viewport (happening in Begin) so we can call Platform_OnChangedViewport()
	MouseViewport : ^ImGuiViewportP,
	MouseLastHoveredViewport : ^ImGuiViewportP, // Last known viewport that was hovered by mouse (even if we are not hovering any viewport any more) + honoring the _NoInputs flag.
	PlatformLastFocusedViewportId : ImGuiID,
	FallbackMonitor : ImGuiPlatformMonitor, // Virtual monitor used as fallback if backend doesn't provide monitor information.
	PlatformMonitorsFullWorkRect : ImRect, // Bounding box of all platform monitors
	ViewportCreatedCount : i32, // Unique sequential creation counter (mostly for testing/debugging)
	PlatformWindowsCreatedCount : i32, // Unique sequential creation counter (mostly for testing/debugging)
	ViewportFocusedStampCount : i32, // Every time the front-most window changes, we stamp its viewport with an incrementing counter

	// Keyboard/Gamepad Navigation
	NavCursorVisible : bool, // Nav focus cursor/rectangle is visible? We hide it after a mouse click. We show it after a nav move.
	NavHighlightItemUnderNav : bool, // Disable mouse hovering highlight. Highlight navigation focused item instead of mouse hovered item.
	//bool                  NavDisableHighlight;                // Old name for !g.NavCursorVisible before 1.91.4 (2024/10/18). OPPOSITE VALUE (g.NavDisableHighlight == !g.NavCursorVisible)
	//bool                  NavDisableMouseHover;               // Old name for g.NavHighlightItemUnderNav before 1.91.1 (2024/10/18) this was called When user starts using keyboard/gamepad, we hide mouse hovering highlight until mouse is touched again.
	NavMousePosDirty : bool, // When set we will update mouse position if io.ConfigNavMoveSetMousePos is set (not enabled by default)
	NavIdIsAlive : bool, // Nav widget has been seen this frame ~~ NavRectRel is valid
	NavId : ImGuiID, // Focused item for navigation
	NavWindow : ^ImGuiWindow, // Focused window for navigation. Could be called 'FocusedWindow'
	NavFocusScopeId : ImGuiID, // Focused focus scope (e.g. selection code often wants to "clear other items" when landing on an item of the same scope)
	NavLayer : ImGuiNavLayer, // Focused layer (main scrolling layer, or menu/title bar layer)
	NavActivateId : ImGuiID, // ~~ (g.ActiveId == 0) && (IsKeyPressed(ImGuiKey_Space) || IsKeyDown(ImGuiKey_Enter) || IsKeyPressed(ImGuiKey_NavGamepadActivate)) ? NavId : 0, also set when calling ActivateItem()
	NavActivateDownId : ImGuiID, // ~~ IsKeyDown(ImGuiKey_Space) || IsKeyDown(ImGuiKey_Enter) || IsKeyDown(ImGuiKey_NavGamepadActivate) ? NavId : 0
	NavActivatePressedId : ImGuiID, // ~~ IsKeyPressed(ImGuiKey_Space) || IsKeyPressed(ImGuiKey_Enter) || IsKeyPressed(ImGuiKey_NavGamepadActivate) ? NavId : 0 (no repeat)
	NavActivateFlags : ImGuiActivateFlags,
	NavFocusRoute : ImVector(ImGuiFocusScopeData), // Reversed copy focus scope stack for NavId (should contains NavFocusScopeId). This essentially follow the window->ParentWindowForFocusRoute chain.
	NavHighlightActivatedId : ImGuiID,
	NavHighlightActivatedTimer : f32,
	NavNextActivateId : ImGuiID, // Set by ActivateItem(), queued until next frame.
	NavNextActivateFlags : ImGuiActivateFlags,
	NavInputSource : ImGuiInputSource, // Keyboard or Gamepad mode? THIS CAN ONLY BE ImGuiInputSource_Keyboard or ImGuiInputEventType_Mouse
	NavLastValidSelectionUserData : ImGuiSelectionUserData, // Last valid data passed to SetNextItemSelectionUser(), or -1. For current window. Not reset when focusing an item that doesn't have selection data.
	NavCursorHideFrames : ImS8,

	// Navigation: Init & Move Requests
	NavAnyRequest : bool, // ~~ NavMoveRequest || NavInitRequest this is to perform early out in ItemAdd()
	NavInitRequest : bool, // Init request for appearing window to select first item
	NavInitRequestFromMove : bool,
	NavInitResult : ImGuiNavItemData, // Init request result (first item of the window, or one for which SetItemDefaultFocus() was called)
	NavMoveSubmitted : bool, // Move request submitted, will process result on next NewFrame()
	NavMoveScoringItems : bool, // Move request submitted, still scoring incoming items
	NavMoveForwardToNextFrame : bool,
	NavMoveFlags : ImGuiNavMoveFlags,
	NavMoveScrollFlags : ImGuiScrollFlags,
	NavMoveKeyMods : ImGuiKeyChord,
	NavMoveDir : ImGuiDir, // Direction of the move request (left/right/up/down)
	NavMoveDirForDebug : ImGuiDir,
	NavMoveClipDir : ImGuiDir, // FIXME-NAV: Describe the purpose of this better. Might want to rename?
	NavScoringRect : ImRect, // Rectangle used for scoring, in screen space. Based of window->NavRectRel[], modified for directional navigation scoring.
	NavScoringNoClipRect : ImRect, // Some nav operations (such as PageUp/PageDown) enforce a region which clipper will attempt to always keep submitted
	NavScoringDebugCount : i32, // Metrics for debugging
	NavTabbingDir : i32, // Generally -1 or +1, 0 when tabbing without a nav id
	NavTabbingCounter : i32, // >0 when counting items for tabbing
	NavMoveResultLocal : ImGuiNavItemData, // Best move request candidate within NavWindow
	NavMoveResultLocalVisible : ImGuiNavItemData, // Best move request candidate within NavWindow that are mostly visible (when using ImGuiNavMoveFlags_AlsoScoreVisibleSet flag)
	NavMoveResultOther : ImGuiNavItemData, // Best move request candidate within NavWindow's flattened hierarchy (when using ImGuiWindowFlags_NavFlattened flag)
	NavTabbingResultFirst : ImGuiNavItemData, // First tabbing request candidate within NavWindow and flattened hierarchy

	// Navigation: record of last move request
	NavJustMovedFromFocusScopeId : ImGuiID, // Just navigated from this focus scope id (result of a successfully MoveRequest).
	NavJustMovedToId : ImGuiID, // Just navigated to this id (result of a successfully MoveRequest).
	NavJustMovedToFocusScopeId : ImGuiID, // Just navigated to this focus scope id (result of a successfully MoveRequest).
	NavJustMovedToKeyMods : ImGuiKeyChord,
	NavJustMovedToIsTabbing : bool, // Copy of ImGuiNavMoveFlags_IsTabbing. Maybe we should store whole flags.
	NavJustMovedToHasSelectionData : bool, // Copy of move result's ItemFlags & ImGuiItemFlags_HasSelectionUserData). Maybe we should just store ImGuiNavItemData.

	// Navigation: Windowing (CTRL+TAB for list, or Menu button + keys or directional pads to move/resize)
	ConfigNavWindowingKeyNext : ImGuiKeyChord, // = ImGuiMod_Ctrl | ImGuiKey_Tab (or ImGuiMod_Super | ImGuiKey_Tab on OS X). For reconfiguration (see #4828)
	ConfigNavWindowingKeyPrev : ImGuiKeyChord, // = ImGuiMod_Ctrl | ImGuiMod_Shift | ImGuiKey_Tab (or ImGuiMod_Super | ImGuiMod_Shift | ImGuiKey_Tab on OS X)
	NavWindowingTarget : ^ImGuiWindow, // Target window when doing CTRL+Tab (or Pad Menu + FocusPrev/Next), this window is temporarily displayed top-most!
	NavWindowingTargetAnim : ^ImGuiWindow, // Record of last valid NavWindowingTarget until DimBgRatio and NavWindowingHighlightAlpha becomes 0.0f, so the fade-out can stay on it.
	NavWindowingListWindow : ^ImGuiWindow, // Internal window actually listing the CTRL+Tab contents
	NavWindowingTimer : f32,
	NavWindowingHighlightAlpha : f32,
	NavWindowingToggleLayer : bool,
	NavWindowingToggleKey : ImGuiKey,
	NavWindowingAccumDeltaPos : ImVec2,
	NavWindowingAccumDeltaSize : ImVec2,

	// Render
	DimBgRatio : f32, // 0.0..1.0 animation when fading in a dimming background (for modal window and CTRL+TAB list)

	// Drag and Drop
	DragDropActive : bool,
	DragDropWithinSource : bool, // Set when within a BeginDragDropXXX/EndDragDropXXX block for a drag source.
	DragDropWithinTarget : bool, // Set when within a BeginDragDropXXX/EndDragDropXXX block for a drag target.
	DragDropSourceFlags : ImGuiDragDropFlags,
	DragDropSourceFrameCount : i32,
	DragDropMouseButton : i32,
	DragDropPayload : ImGuiPayload,
	DragDropTargetRect : ImRect, // Store rectangle of current target candidate (we favor small targets when overlapping)
	DragDropTargetClipRect : ImRect, // Store ClipRect at the time of item's drawing
	DragDropTargetId : ImGuiID,
	DragDropAcceptFlags : ImGuiDragDropFlags,
	DragDropAcceptIdCurrRectSurface : f32, // Target item surface (we resolve overlapping targets by prioritizing the smaller surface)
	DragDropAcceptIdCurr : ImGuiID, // Target item id (set at the time of accepting the payload)
	DragDropAcceptIdPrev : ImGuiID, // Target item id from previous frame (we need to store this to allow for overlapping drag and drop targets)
	DragDropAcceptFrameCount : i32, // Last time a target expressed a desire to accept the source
	DragDropHoldJustPressedId : ImGuiID, // Set when holding a payload just made ButtonBehavior() return a press.
	DragDropPayloadBufHeap : ImVector(u8), // We don't expose the ImVector<> directly, ImGuiPayload only holds pointer+size
	DragDropPayloadBufLocal : [16]u8, // Local buffer for small payloads

	// Clipper
	ClipperTempDataStacked : i32,
	ClipperTempData : ImVector(ImGuiListClipperData),

	// Tables
	CurrentTable : ^ImGuiTable,
	DebugBreakInTable : ImGuiID, // Set to break in BeginTable() call.
	TablesTempDataStacked : i32, // Temporary table data size (because we leave previous instances undestructed, we generally don't use TablesTempData.Size)
	TablesTempData : ImVector(ImGuiTableTempData), // Temporary table data (buffers reused/shared across instances, support nesting)
	Tables : ImPool(ImGuiTable), // Persistent table data
	TablesLastTimeActive : ImVector(f32), // Last used timestamp of each tables (SOA, for efficient GC)
	DrawChannelsTempMergeBuffer : ImVector(ImDrawChannel),

	// Tab bars
	CurrentTabBar : ^ImGuiTabBar,
	TabBars : ImPool(ImGuiTabBar),
	CurrentTabBarStack : ImVector(ImGuiPtrOrIndex),
	ShrinkWidthBuffer : ImVector(ImGuiShrinkWidthItem),

	// Multi-Select state
	BoxSelectState : ImGuiBoxSelectState,
	CurrentMultiSelect : ^ImGuiMultiSelectTempData,
	MultiSelectTempDataStacked : i32, // Temporary multi-select data size (because we leave previous instances undestructed, we generally don't use MultiSelectTempData.Size)
	MultiSelectTempData : ImVector(ImGuiMultiSelectTempData),
	MultiSelectStorage : ImPool(ImGuiMultiSelectState),

	// Hover Delay system
	HoverItemDelayId : ImGuiID,
	HoverItemDelayIdPreviousFrame : ImGuiID,
	HoverItemDelayTimer : f32, // Currently used by IsItemHovered()
	HoverItemDelayClearTimer : f32, // Currently used by IsItemHovered(): grace time before g.TooltipHoverTimer gets cleared.
	HoverItemUnlockedStationaryId : ImGuiID, // Mouse has once been stationary on this item. Only reset after departing the item.
	HoverWindowUnlockedStationaryId : ImGuiID, // Mouse has once been stationary on this window. Only reset after departing the window.

	// Mouse state
	MouseCursor : ImGuiMouseCursor,
	MouseStationaryTimer : f32, // Time the mouse has been stationary (with some loose heuristic)
	MouseLastValidPos : ImVec2,

	// Widget state
	InputTextState : ImGuiInputTextState,
	InputTextDeactivatedState : ImGuiInputTextDeactivatedState,
	InputTextPasswordFont : ImFont,
	TempInputId : ImGuiID, // Temporary text input when CTRL+clicking on a slider, etc.
	DataTypeZeroValue : ImGuiDataTypeStorage, // 0 for all data types
	BeginMenuDepth : i32,
	BeginComboDepth : i32,
	ColorEditOptions : ImGuiColorEditFlags, // Store user options for color edit widgets
	ColorEditCurrentID : ImGuiID, // Set temporarily while inside of the parent-most ColorEdit4/ColorPicker4 (because they call each others).
	ColorEditSavedID : ImGuiID, // ID we are saving/restoring HS for
	ColorEditSavedHue : f32, // Backup of last Hue associated to LastColor, so we can restore Hue in lossy RGB<>HSV round trips
	ColorEditSavedSat : f32, // Backup of last Saturation associated to LastColor, so we can restore Saturation in lossy RGB<>HSV round trips
	ColorEditSavedColor : ImU32, // RGB value with alpha set to 0.
	ColorPickerRef : ImVec4, // Initial/reference color at the time of opening the color picker.
	ComboPreviewData : ImGuiComboPreviewData,
	WindowResizeBorderExpectedRect : ImRect, // Expected border rect, switch to relative edit if moving
	WindowResizeRelativeMode : bool,
	ScrollbarSeekMode : i16, // 0: scroll to clicked location, -1/+1: prev/next page.
	ScrollbarClickDeltaToGrabCenter : f32, // When scrolling to mouse location: distance between mouse and center of grab box, normalized in parent space.
	SliderGrabClickOffset : f32,
	SliderCurrentAccum : f32, // Accumulated slider delta when using navigation controls.
	SliderCurrentAccumDirty : bool, // Has the accumulated slider delta changed since last time we tried to apply it?
	DragCurrentAccumDirty : bool,
	DragCurrentAccum : f32, // Accumulator for dragging modification. Always high-precision, not rounded by end-user precision settings
	DragSpeedDefaultRatio : f32, // If speed == 0.0f, uses (max-min) * DragSpeedDefaultRatio
	DisabledAlphaBackup : f32, // Backup for style.Alpha for BeginDisabled()
	DisabledStackSize : i16,
	TooltipOverrideCount : i16,
	TooltipPreviousWindow : ^ImGuiWindow, // Window of last tooltip submitted during the frame
	ClipboardHandlerData : ImVector(u8), // If no custom clipboard handler is defined
	MenusIdSubmittedThisFrame : ImVector(ImGuiID), // A list of menu IDs that were rendered at least once
	TypingSelectState : ImGuiTypingSelectState, // State for GetTypingSelectRequest()

	// Platform support
	PlatformImeData : ImGuiPlatformImeData, // Data updated by current frame
	PlatformImeDataPrev : ImGuiPlatformImeData, // Previous frame data. When changed we call the platform_io.Platform_SetImeDataFn() handler.
	PlatformImeViewport : ImGuiID,

	// Extensions
	// FIXME: We could provide an API to register one slot in an array held in ImGuiContext?
	DockContext : ImGuiDockContext,
	DockNodeWindowMenuHandler : proc(	_ctx : ^ImGuiContext, 	_node : ^ImGuiDockNode, 	_tab_bar : ^ImGuiTabBar),

	// Settings
	SettingsLoaded : bool,
	SettingsDirtyTimer : f32, // Save .ini Settings to memory when time reaches zero
	SettingsIniData : ImGuiTextBuffer, // In memory .ini settings
	SettingsHandlers : ImVector(ImGuiSettingsHandler), // List of .ini settings handlers
	SettingsWindows : ImChunkStream(ImGuiWindowSettings), // ImGuiWindow .ini settings entries
	SettingsTables : ImChunkStream(ImGuiTableSettings), // ImGuiTable .ini settings entries
	Hooks : ImVector(ImGuiContextHook), // Hooks for extensions (e.g. test engine)
	HookIdNext : ImGuiID, // Next available HookId

	// Localization
	LocalizationTable : [ImGuiLocKey.ImGuiLocKey_COUNT]^u8,

	// Capture/Logging
	LogEnabled : bool, // Currently capturing
	LogFlags : ImGuiLogFlags, // Capture flags/type
	LogWindow : ^ImGuiWindow,
	LogFile : ImFileHandle, // If != NULL log to stdout/ file
	LogBuffer : ImGuiTextBuffer, // Accumulation buffer when log to clipboard. This is pointer so our GImGui static constructor doesn't call heap allocators.
	LogNextPrefix : ^u8,
	LogNextSuffix : ^u8,
	LogLinePosY : f32,
	LogLineFirstItem : bool,
	LogDepthRef : i32,
	LogDepthToExpand : i32,
	LogDepthToExpandDefault : i32, // Default/stored value for LogDepthMaxExpand if not specified in the LogXXX function call.

	// Error Handling
	ErrorCallback : ImGuiErrorCallback, // = NULL. May be exposed in public API eventually.
	ErrorCallbackUserData : rawptr, // = NULL
	ErrorTooltipLockedPos : ImVec2,
	ErrorFirst : bool,
	ErrorCountCurrentFrame : i32, // [Internal] Number of errors submitted this frame.
	StackSizesInNewFrame : ImGuiErrorRecoveryState, // [Internal]
	StackSizesInBeginForCurrentWindow : ^ImGuiErrorRecoveryState, // [Internal]

	// Debug Tools
	// (some of the highly frequently used data are interleaved in other structures above: DebugBreakXXX fields, DebugHookIdInfo, DebugLocateId etc.)
	DebugDrawIdConflictsCount : i32, // Locked count (preserved when holding CTRL)
	DebugLogFlags : ImGuiDebugLogFlags,
	DebugLogBuf : ImGuiTextBuffer,
	DebugLogIndex : ImGuiTextIndex,
	DebugLogSkippedErrors : i32,
	DebugLogAutoDisableFlags : ImGuiDebugLogFlags,
	DebugLogAutoDisableFrames : ImU8,
	DebugLocateFrames : ImU8, // For DebugLocateItemOnHover(). This is used together with DebugLocateId which is in a hot/cached spot above.
	DebugBreakInLocateId : bool, // Debug break in ItemAdd() call for g.DebugLocateId.
	DebugBreakKeyChord : ImGuiKeyChord, // = ImGuiKey_Pause
	DebugBeginReturnValueCullDepth : ImS8, // Cycle between 0..9 then wrap around.
	DebugItemPickerActive : bool, // Item picker is active (started with DebugStartItemPicker())
	DebugItemPickerMouseButton : ImU8,
	DebugItemPickerBreakId : ImGuiID, // Will call IM_DEBUG_BREAK() when encountering this ID
	DebugFlashStyleColorTime : f32,
	DebugFlashStyleColorBackup : ImVec4,
	DebugMetricsConfig : ImGuiMetricsConfig,
	DebugIDStackTool : ImGuiIDStackTool,
	DebugAllocInfo : ImGuiDebugAllocInfo,
	DebugHoveredDockNode : ^ImGuiDockNode, // Hovered dock node.

	// Misc
	FramerateSecPerFrame : [60]f32, // Calculate estimate of framerate for user over the last 60 frames..
	FramerateSecPerFrameIdx : i32,
	FramerateSecPerFrameCount : i32,
	FramerateSecPerFrameAccum : f32,
	WantCaptureMouseNextFrame : i32, // Explicit capture override via SetNextFrameWantCaptureMouse()/SetNextFrameWantCaptureKeyboard(). Default to -1.
	WantCaptureKeyboardNextFrame : i32, // "
	WantTextInputNextFrame : i32,
	TempBuffer : ImVector(u8), // Temporary text buffer
	TempKeychordName : [64]u8,
}

// Storage for window-style data which needs to be stored for docking purpose
//-----------------------------------------------------------------------------
// [SECTION] ImGuiWindowTempData, ImGuiWindow
//-----------------------------------------------------------------------------

// Transient per-window data, reset at the beginning of the frame. This used to be called ImGuiDrawContext, hence the DC variable name in ImGuiWindow.
// (That's theory, in practice the delimitation between ImGuiWindow and ImGuiWindowTempData is quite tenuous and could be reconsidered..)
// (This doesn't need a constructor because we zero-clear it as part of ImGuiWindow and all frame-temporary data are setup on Begin)
ImGuiWindowTempData :: struct {
	// Layout
	CursorPos : ImVec2, // Current emitting position, in absolute coordinates.
	CursorPosPrevLine : ImVec2,
	CursorStartPos : ImVec2, // Initial position after Begin(), generally ~ window position + WindowPadding.
	CursorMaxPos : ImVec2, // Used to implicitly calculate ContentSize at the beginning of next frame, for scrolling range and auto-resize. Always growing during the frame.
	IdealMaxPos : ImVec2, // Used to implicitly calculate ContentSizeIdeal at the beginning of next frame, for auto-resize only. Always growing during the frame.
	CurrLineSize : ImVec2,
	PrevLineSize : ImVec2,
	CurrLineTextBaseOffset : f32, // Baseline offset (0.0f by default on a new line, generally == style.FramePadding.y when a framed item has been added).
	PrevLineTextBaseOffset : f32,
	IsSameLine : bool,
	IsSetPos : bool,
	Indent : ImVec1, // Indentation / start position from left of window (increased by TreePush/TreePop, etc.)
	ColumnsOffset : ImVec1, // Offset to the current column (if ColumnsCurrent > 0). FIXME: This and the above should be a stack to allow use cases like Tree->Column->Tree. Need revamp columns API.
	GroupOffset : ImVec1,
	CursorStartPosLossyness : ImVec2, // Record the loss of precision of CursorStartPos due to really large scrolling amount. This is used by clipper to compensate and fix the most common use case of large scroll area.

	// Keyboard/Gamepad navigation
	NavLayerCurrent : ImGuiNavLayer, // Current layer, 0..31 (we currently only use 0..1)
	NavLayersActiveMask : i16, // Which layers have been written to (result from previous frame)
	NavLayersActiveMaskNext : i16, // Which layers have been written to (accumulator for current frame)
	NavIsScrollPushableX : bool, // Set when current work location may be scrolled horizontally when moving left / right. This is generally always true UNLESS within a column.
	NavHideHighlightOneFrame : bool,
	NavWindowHasScrollY : bool, // Set per window when scrolling can be used (== ScrollMax.y > 0.0f)

	// Miscellaneous
	MenuBarAppending : bool, // FIXME: Remove this
	MenuBarOffset : ImVec2, // MenuBarOffset.x is sort of equivalent of a per-layer CursorPos.x, saved/restored as we switch to the menu bar. The only situation when MenuBarOffset.y is > 0 if when (SafeAreaPadding.y > FramePadding.y), often used on TVs.
	MenuColumns : ImGuiMenuColumns, // Simplified columns storage for menu items measurement
	TreeDepth : i32, // Current tree depth.
	TreeHasStackDataDepthMask : ImU32, // Store whether given depth has ImGuiTreeNodeStackData data. Could be turned into a ImU64 if necessary.
	ChildWindows : ImVector(^ImGuiWindow),
	StateStorage : ^ImGuiStorage, // Current persistent per-window storage (store e.g. tree node open/close state)
	CurrentColumns : ^ImGuiOldColumns, // Current columns set
	CurrentTableIdx : i32, // Current table index (into g.Tables)
	LayoutType : ImGuiLayoutType,
	ParentLayoutType : ImGuiLayoutType, // Layout type of parent window at the time of Begin()
	ModalDimBgColor : ImU32,

	// Local parameters stacks
	// We store the current settings outside of the vectors to increase memory locality (reduce cache misses). The vectors are rarely modified. Also it allows us to not heap allocate for short-lived windows which are not using those settings.
	ItemWidth : f32, // Current item width (>0.0: width in pixels, <0.0: align xx pixels to the right of window).
	TextWrapPos : f32, // Current text wrap pos.
	ItemWidthStack : ImVector(f32), // Store item widths to restore (attention: .back() is not == ItemWidth)
	TextWrapPosStack : ImVector(f32), // Store text wrap pos to restore (attention: .back() is not == TextWrapPos)
}

// Storage for GetTypingSelectRequest() (aimed to be public)
// Storage for one window
ImGuiWindow :: struct {
	Ctx : ^ImGuiContext, // Parent UI context (needs to be set explicitly by parent).
	Name : ^u8, // Window name, owned by the window.
	ID : ImGuiID, // == ImHashStr(Name)
	Flags : ImGuiWindowFlags, FlagsPreviousFrame : ImGuiWindowFlags, // See enum ImGuiWindowFlags_
	ChildFlags : ImGuiChildFlags, // Set when window is a child window. See enum ImGuiChildFlags_
	WindowClass : ImGuiWindowClass, // Advanced users only. Set with SetNextWindowClass()
	Viewport : ^ImGuiViewportP, // Always set in Begin(). Inactive windows may have a NULL value here if their viewport was discarded.
	ViewportId : ImGuiID, // We backup the viewport id (since the viewport may disappear or never be created if the window is inactive)
	ViewportPos : ImVec2, // We backup the viewport position (since the viewport may disappear or never be created if the window is inactive)
	ViewportAllowPlatformMonitorExtend : i32, // Reset to -1 every frame (index is guaranteed to be valid between NewFrame..EndFrame), only used in the Appearing frame of a tooltip/popup to enforce clamping to a given monitor
	Pos : ImVec2, // Position (always rounded-up to nearest pixel)
	Size : ImVec2, // Current size (==SizeFull or collapsed title bar size)
	SizeFull : ImVec2, // Size when non collapsed
	ContentSize : ImVec2, // Size of contents/scrollable client area (calculated from the extents reach of the cursor) from previous frame. Does not include window decoration or window padding.
	ContentSizeIdeal : ImVec2,
	ContentSizeExplicit : ImVec2, // Size of contents/scrollable client area explicitly request by the user via SetNextWindowContentSize().
	WindowPadding : ImVec2, // Window padding at the time of Begin().
	WindowRounding : f32, // Window rounding at the time of Begin(). May be clamped lower to avoid rendering artifacts with title bar, menu bar etc.
	WindowBorderSize : f32, // Window border size at the time of Begin().
	TitleBarHeight : f32, MenuBarHeight : f32, // Note that those used to be function before 2024/05/28. If you have old code calling TitleBarHeight() you can change it to TitleBarHeight.
	DecoOuterSizeX1 : f32, DecoOuterSizeY1 : f32, // Left/Up offsets. Sum of non-scrolling outer decorations (X1 generally == 0.0f. Y1 generally = TitleBarHeight + MenuBarHeight). Locked during Begin().
	DecoOuterSizeX2 : f32, DecoOuterSizeY2 : f32, // Right/Down offsets (X2 generally == ScrollbarSize.x, Y2 == ScrollbarSizes.y).
	DecoInnerSizeX1 : f32, DecoInnerSizeY1 : f32, // Applied AFTER/OVER InnerRect. Specialized for Tables as they use specialized form of clipping and frozen rows/columns are inside InnerRect (and not part of regular decoration sizes).
	NameBufLen : i32, // Size of buffer storing Name. May be larger than strlen(Name)!
	MoveId : ImGuiID, // == window->GetID("#MOVE")
	TabId : ImGuiID, // == window->GetID("#TAB")
	ChildId : ImGuiID, // ID of corresponding item in parent window (for navigation to return from child window to parent window)
	PopupId : ImGuiID, // ID in the popup stack when this window is used as a popup/menu (because we use generic Name/ID for recycling)
	Scroll : ImVec2,
	ScrollMax : ImVec2,
	ScrollTarget : ImVec2, // target scroll position. stored as cursor position with scrolling canceled out, so the highest point is always 0.0f. (FLT_MAX for no change)
	ScrollTargetCenterRatio : ImVec2, // 0.0f = scroll so that target position is at top, 0.5f = scroll so that target position is centered
	ScrollTargetEdgeSnapDist : ImVec2, // 0.0f = no snapping, >0.0f snapping threshold
	ScrollbarSizes : ImVec2, // Size taken by each scrollbars on their smaller axis. Pay attention! ScrollbarSizes.x == width of the vertical scrollbar, ScrollbarSizes.y = height of the horizontal scrollbar.
	ScrollbarX : bool, ScrollbarY : bool, // Are scrollbars visible?
	ViewportOwned : bool,
	Active : bool, // Set to true on Begin(), unless Collapsed
	WasActive : bool,
	WriteAccessed : bool, // Set to true when any widget access the current window
	Collapsed : bool, // Set when collapsing window to become only title-bar
	WantCollapseToggle : bool,
	SkipItems : bool, // Set when items can safely be all clipped (e.g. window not visible or collapsed)
	SkipRefresh : bool, // [EXPERIMENTAL] Reuse previous frame drawn contents, Begin() returns false.
	Appearing : bool, // Set during the frame where the window is appearing (or re-appearing)
	Hidden : bool, // Do not display (== HiddenFrames*** > 0)
	IsFallbackWindow : bool, // Set on the "Debug##Default" window.
	IsExplicitChild : bool, // Set when passed _ChildWindow, left to false by BeginDocked()
	HasCloseButton : bool, // Set when the window has a close button (p_open != NULL)
	ResizeBorderHovered : i8, // Current border being hovered for resize (-1: none, otherwise 0-3)
	ResizeBorderHeld : i8, // Current border being held for resize (-1: none, otherwise 0-3)
	BeginCount : i16, // Number of Begin() during the current frame (generally 0 or 1, 1+ if appending via multiple Begin/End pairs)
	BeginCountPreviousFrame : i16, // Number of Begin() during the previous frame
	BeginOrderWithinParent : i16, // Begin() order within immediate parent window, if we are a child window. Otherwise 0.
	BeginOrderWithinContext : i16, // Begin() order within entire imgui context. This is mostly used for debugging submission order related issues.
	FocusOrder : i16, // Order within WindowsFocusOrder[], altered when windows are focused.
	AutoFitFramesX : ImS8, AutoFitFramesY : ImS8,
	AutoFitOnlyGrows : bool,
	AutoPosLastDirection : ImGuiDir,
	HiddenFramesCanSkipItems : ImS8, // Hide the window for N frames
	HiddenFramesCannotSkipItems : ImS8, // Hide the window for N frames while allowing items to be submitted so we can measure their size
	HiddenFramesForRenderOnly : ImS8, // Hide the window until frame N at Render() time only
	DisableInputsFrames : ImS8, // Disable window interactions for N frames
	using _0 : bit_field u32 {
		SetWindowPosAllowFlags : ImGuiCond | 8, // store acceptable condition flags for SetNextWindowPos() use.
		SetWindowSizeAllowFlags : ImGuiCond | 8, // store acceptable condition flags for SetNextWindowSize() use.
		SetWindowCollapsedAllowFlags : ImGuiCond | 8, // store acceptable condition flags for SetNextWindowCollapsed() use.
		SetWindowDockAllowFlags : ImGuiCond | 8, // store acceptable condition flags for SetNextWindowDock() use.
	},
	SetWindowPosVal : ImVec2, // store window position when using a non-zero Pivot (position set needs to be processed when we know the window size)
	SetWindowPosPivot : ImVec2, // store window pivot for positioning. ImVec2(0, 0) when positioning from top-left corner; ImVec2(0.5f, 0.5f) for centering; ImVec2(1, 1) for bottom right.

	IDStack : ImVector(ImGuiID), // ID stack. ID are hashes seeded with the value at the top of the stack. (In theory this should be in the TempData structure)
	DC : ImGuiWindowTempData, // Temporary per-window data, reset at the beginning of the frame. This used to be called ImGuiDrawContext, hence the "DC" variable name.

	// The best way to understand what those rectangles are is to use the 'Metrics->Tools->Show Windows Rectangles' viewer.
	// The main 'OuterRect', omitted as a field, is window->Rect().
	OuterRectClipped : ImRect, // == Window->Rect() just after setup in Begin(). == window->Rect() for root window.
	InnerRect : ImRect, // Inner rectangle (omit title bar, menu bar, scroll bar)
	InnerClipRect : ImRect, // == InnerRect shrunk by WindowPadding*0.5f on each side, clipped within viewport or parent clip rect.
	WorkRect : ImRect, // Initially covers the whole scrolling region. Reduced by containers e.g columns/tables when active. Shrunk by WindowPadding*1.0f on each side. This is meant to replace ContentRegionRect over time (from 1.71+ onward).
	ParentWorkRect : ImRect, // Backup of WorkRect before entering a container such as columns/tables. Used by e.g. SpanAllColumns functions to easily access. Stacked containers are responsible for maintaining this. // FIXME-WORKRECT: Could be a stack?
	ClipRect : ImRect, // Current clipping/scissoring rectangle, evolve as we are using PushClipRect(), etc. == DrawList->clip_rect_stack.back().
	ContentRegionRect : ImRect, // FIXME: This is currently confusing/misleading. It is essentially WorkRect but not handling of scrolling. We currently rely on it as right/bottom aligned sizing operation need some size to rely on.
	HitTestHoleSize : ImVec2ih, // Define an optional rectangular hole where mouse will pass-through the window.
	HitTestHoleOffset : ImVec2ih,

	LastFrameActive : i32, // Last frame number the window was Active.
	LastFrameJustFocused : i32, // Last frame number the window was made Focused.
	LastTimeActive : f32, // Last timestamp the window was Active (using float as we don't need high precision there)
	ItemWidthDefault : f32,
	StateStorage : ImGuiStorage,
	ColumnsStorage : ImVector(ImGuiOldColumns),
	FontWindowScale : f32, // User scale multiplier per-window, via SetWindowFontScale()
	FontDpiScale : f32,
	SettingsOffset : i32, // Offset into SettingsWindows[] (offsets are always valid as we only grow the array from the back)

	DrawList : ^ImDrawList, // == &DrawListInst (for backward compatibility reason with code using imgui_internal.h we keep this a pointer)
	DrawListInst : ImDrawList,
	ParentWindow : ^ImGuiWindow, // If we are a child _or_ popup _or_ docked window, this is pointing to our parent. Otherwise NULL.
	ParentWindowInBeginStack : ^ImGuiWindow,
	RootWindow : ^ImGuiWindow, // Point to ourself or first ancestor that is not a child window. Doesn't cross through popups/dock nodes.
	RootWindowPopupTree : ^ImGuiWindow, // Point to ourself or first ancestor that is not a child window. Cross through popups parent<>child.
	RootWindowDockTree : ^ImGuiWindow, // Point to ourself or first ancestor that is not a child window. Cross through dock nodes.
	RootWindowForTitleBarHighlight : ^ImGuiWindow, // Point to ourself or first ancestor which will display TitleBgActive color when this window is active.
	RootWindowForNav : ^ImGuiWindow, // Point to ourself or first ancestor which doesn't have the NavFlattened flag.
	ParentWindowForFocusRoute : ^ImGuiWindow, // Set to manual link a window to its logical parent so that Shortcut() chain are honoerd (e.g. Tool linked to Document)

	NavLastChildNavWindow : ^ImGuiWindow, // When going to the menu bar, we remember the child window we came from. (This could probably be made implicit if we kept g.Windows sorted by last focused including child window.)
	NavLastIds : [ImGuiNavLayer.ImGuiNavLayer_COUNT]ImGuiID, // Last known NavId for this window, per layer (0/1)
	NavRectRel : [ImGuiNavLayer.ImGuiNavLayer_COUNT]ImRect, // Reference rectangle, in window relative space
	NavPreferredScoringPosRel : [ImGuiNavLayer.ImGuiNavLayer_COUNT]ImVec2, // Preferred X/Y position updated when moving on a given axis, reset to FLT_MAX.
	NavRootFocusScopeId : ImGuiID, // Focus Scope ID at the time of Begin()

	MemoryDrawListIdxCapacity : i32, // Backup of last idx/vtx count, so when waking up the window we can preallocate and avoid iterative alloc/copy
	MemoryDrawListVtxCapacity : i32,
	MemoryCompacted : bool, // Set when window extraneous data have been garbage collected

	// Docking
	using _1 : bit_field u8 {
		DockIsActive : bool | 1, // When docking artifacts are actually visible. When this is set, DockNode is guaranteed to be != NULL. ~~ (DockNode != NULL) && (DockNode->Windows.Size > 1).
		DockNodeIsVisible : bool | 1,
		DockTabIsVisible : bool | 1, // Is our window visible this frame? ~~ is the corresponding tab selected?
		DockTabWantClose : bool | 1,
	},
	DockOrder : i16, // Order of the last time the window was visible within its DockNode. This is used to reorder windows that are reappearing on the same frame. Same value between windows that were active and windows that were none are possible.
	DockStyle : ImGuiWindowDockStyle,
	DockNode : ^ImGuiDockNode, // Which node are we docked into. Important: Prefer testing DockIsActive in many cases as this will still be set when the dock node is hidden.
	DockNodeAsHost : ^ImGuiDockNode, // Which node are we owning (for parent windows)
	DockId : ImGuiID, // Backup of last valid DockNode->ID, so single window remember their dock node id even when they are not bound any more
	DockTabItemStatusFlags : ImGuiItemStatusFlags,
	DockTabItemRect : ImRect,
}

// We don't use g.FontSize because the window may be != g.CurrentWindow.
ImGuiWindow_Rect :: proc(this : ^ImGuiWindow) -> ImRect { return ImRect(this.Pos.x, this.Pos.y, this.Pos.x + this.Size.x, this.Pos.y + this.Size.y) }

ImGuiWindow_CalcFontSize :: proc(this : ^ImGuiWindow) -> f32
{
	g : ^ImGuiContext = this.Ctx; scale : f32 = g.FontBaseSize * this.FontWindowScale * this.FontDpiScale; if this.ParentWindow { scale *= this.ParentWindow.FontWindowScale }; return scale
}

ImGuiWindow_TitleBarRect :: proc(this : ^ImGuiWindow) -> ImRect { return ImRect(this.Pos, ImVec2(this.Pos.x + this.SizeFull.x, this.Pos.y + this.TitleBarHeight)) }

ImGuiWindow_MenuBarRect :: proc(this : ^ImGuiWindow) -> ImRect
{
	y1 : f32 = this.Pos.y + this.TitleBarHeight; return ImRect(this.Pos.x, y1, this.Pos.x + this.SizeFull.x, y1 + this.MenuBarHeight)
}

//-----------------------------------------------------------------------------
// [SECTION] Tab bar, Tab item support
//-----------------------------------------------------------------------------

// Extend ImGuiTabBarFlags_
ImGuiTabBarFlagsPrivate_ :: enum i32 {
	ImGuiTabBarFlags_DockNode = 1 << 20, // Part of a dock node [we don't use this in the master branch but it facilitate branch syncing to keep this around]
	ImGuiTabBarFlags_IsFocused = 1 << 21,
	ImGuiTabBarFlags_SaveSettings = 1 << 22, // FIXME: Settings are handled by the docking system, this only request the tab bar to mark settings dirty when reordering tabs
}

// Extend ImGuiTabItemFlags_
ImGuiTabItemFlagsPrivate_ :: enum i32 {
	ImGuiTabItemFlags_SectionMask_ = i32(ImGuiTabItemFlags_.ImGuiTabItemFlags_Leading | ImGuiTabItemFlags_.ImGuiTabItemFlags_Trailing),
	ImGuiTabItemFlags_NoCloseButton = 1 << 20, // Track whether p_open was set or not (we'll need this info on the next frame to recompute ContentWidth during layout)
	ImGuiTabItemFlags_Button = 1 << 21, // Used by TabItemButton, change the tab item behavior to mimic a button
	ImGuiTabItemFlags_Unsorted = 1 << 22, // [Docking] Trailing tabs with the _Unsorted flag will be sorted based on the DockOrder of their Window.
}

// Storage for a tab bar
// Storage for one active tab item (sizeof() 48 bytes)
ImGuiTabItem :: struct {
	ID : ImGuiID,
	Flags : ImGuiTabItemFlags,
	Window : ^ImGuiWindow, // When TabItem is part of a DockNode's TabBar, we hold on to a window.
	LastFrameVisible : i32,
	LastFrameSelected : i32, // This allows us to infer an ordered list of the last activated tabs with little maintenance
	Offset : f32, // Position relative to beginning of tab
	Width : f32, // Width currently displayed
	ContentWidth : f32, // Width of label, stored during BeginTabItem() call
	RequestedWidth : f32, // Width optionally requested by caller, -1.0f is unused
	NameOffset : ImS32, // When Window==NULL, offset to name within parent ImGuiTabBar::TabsNames
	BeginOrder : ImS16, // BeginTabItem() order, used to re-order tabs after toggling ImGuiTabBarFlags_Reorderable
	IndexDuringLayout : ImS16, // Index only used during TabBarLayout(). Tabs gets reordered so 'Tabs[n].IndexDuringLayout == n' but may mismatch during additions.
	WantClose : bool, }

// Marked as closed by SetTabItemClosed()

ImGuiTabItem_init :: proc(this : ^ImGuiTabItem)
{
	memset(this, 0, size_of(this)); this.LastFrameSelected = -1; this.LastFrameVisible = this.LastFrameSelected; this.RequestedWidth = -1.0; this.NameOffset = -1; this.IndexDuringLayout = -1; this.BeginOrder = this.IndexDuringLayout
}

// Stacked style modifier, backup of modified data so we can restore it
// Storage for a tab bar (sizeof() 160 bytes)
ImGuiTabBar :: struct {
	Window : ^ImGuiWindow,
	Tabs : ImVector(ImGuiTabItem),
	Flags : ImGuiTabBarFlags,
	ID : ImGuiID, // Zero for tab-bars used by docking
	SelectedTabId : ImGuiID, // Selected tab/window
	NextSelectedTabId : ImGuiID, // Next selected tab/window. Will also trigger a scrolling animation
	VisibleTabId : ImGuiID, // Can occasionally be != SelectedTabId (e.g. when previewing contents for CTRL+TAB preview)
	CurrFrameVisible : i32,
	PrevFrameVisible : i32,
	BarRect : ImRect,
	CurrTabsContentsHeight : f32,
	PrevTabsContentsHeight : f32, // Record the height of contents submitted below the tab bar
	WidthAllTabs : f32, // Actual width of all tabs (locked during layout)
	WidthAllTabsIdeal : f32, // Ideal width if all tabs were visible and not clipped
	ScrollingAnim : f32,
	ScrollingTarget : f32,
	ScrollingTargetDistToVisibility : f32,
	ScrollingSpeed : f32,
	ScrollingRectMinX : f32,
	ScrollingRectMaxX : f32,
	SeparatorMinX : f32,
	SeparatorMaxX : f32,
	ReorderRequestTabId : ImGuiID,
	ReorderRequestOffset : ImS16,
	BeginCount : ImS8,
	WantLayout : bool,
	VisibleTabWasSubmitted : bool,
	TabsAddedNew : bool, // Set to true when a new tab item or button has been added to the tab bar during last frame
	TabsActiveCount : ImS16, // Number of tabs submitted this frame.
	LastTabItemIdx : ImS16, // Index of last BeginTabItem() tab for use by EndTabItem()
	ItemSpacingY : f32,
	FramePadding : ImVec2, // style.FramePadding locked at the time of BeginTabBar()
	BackupCursorPos : ImVec2,
	TabsNames : ImGuiTextBuffer, }

//-----------------------------------------------------------------------------
// [SECTION] Table support
//-----------------------------------------------------------------------------

IM_COL32_DISABLE : ImU32 : (0 << IM_COL32_R_SHIFT)|(0 << IM_COL32_G_SHIFT)|(0 << IM_COL32_B_SHIFT)|(1 << IM_COL32_A_SHIFT) // Special sentinel code which cannot be used as a regular color.
IMGUI_TABLE_MAX_COLUMNS :: 512// May be further lifted

// Our current column maximum is 64 but we may raise that in the future.
ImGuiTableColumnIdx :: ImS16
ImGuiTableDrawChannelIdx :: ImU16

// Storage for TableAngledHeadersRow()
// [Internal] sizeof() ~ 112
// We use the terminology "Enabled" to refer to a column that is not Hidden by user/api.
// We use the terminology "Clipped" to refer to a column that is out of sight because of scrolling/clipping.
// This is in contrast with some user-facing api such as IsItemVisible() / IsRectVisible() which use "Visible" to mean "not clipped".
ImGuiTableColumn :: struct {
	Flags : ImGuiTableColumnFlags, // Flags after some patching (not directly same as provided by user). See ImGuiTableColumnFlags_
	WidthGiven : f32, // Final/actual width visible == (MaxX - MinX), locked in TableUpdateLayout(). May be > WidthRequest to honor minimum width, may be < WidthRequest to honor shrinking columns down in tight space.
	MinX : f32, // Absolute positions
	MaxX : f32,
	WidthRequest : f32, // Master width absolute value when !(Flags & _WidthStretch). When Stretch this is derived every frame from StretchWeight in TableUpdateLayout()
	WidthAuto : f32, // Automatic width
	WidthMax : f32, // Maximum width (FIXME: overwritten by each instance)
	StretchWeight : f32, // Master width weight when (Flags & _WidthStretch). Often around ~1.0f initially.
	InitStretchWeightOrWidth : f32, // Value passed to TableSetupColumn(). For Width it is a content width (_without padding_).
	ClipRect : ImRect, // Clipping rectangle for the column
	UserID : ImGuiID, // Optional, value passed to TableSetupColumn()
	WorkMinX : f32, // Contents region min ~(MinX + CellPaddingX + CellSpacingX1) == cursor start position when entering column
	WorkMaxX : f32, // Contents region max ~(MaxX - CellPaddingX - CellSpacingX2)
	ItemWidth : f32, // Current item width for the column, preserved across rows
	ContentMaxXFrozen : f32, // Contents maximum position for frozen rows (apart from headers), from which we can infer content width.
	ContentMaxXUnfrozen : f32,
	ContentMaxXHeadersUsed : f32, // Contents maximum position for headers rows (regardless of freezing). TableHeader() automatically softclip itself + report ideal desired size, to avoid creating extraneous draw calls
	ContentMaxXHeadersIdeal : f32,
	NameOffset : ImS16, // Offset into parent ColumnsNames[]
	DisplayOrder : ImGuiTableColumnIdx, // Index within Table's IndexToDisplayOrder[] (column may be reordered by users)
	IndexWithinEnabledSet : ImGuiTableColumnIdx, // Index within enabled/visible set (<= IndexToDisplayOrder)
	PrevEnabledColumn : ImGuiTableColumnIdx, // Index of prev enabled/visible column within Columns[], -1 if first enabled/visible column
	NextEnabledColumn : ImGuiTableColumnIdx, // Index of next enabled/visible column within Columns[], -1 if last enabled/visible column
	SortOrder : ImGuiTableColumnIdx, // Index of this column within sort specs, -1 if not sorting on this column, 0 for single-sort, may be >0 on multi-sort
	DrawChannelCurrent : ImGuiTableDrawChannelIdx, // Index within DrawSplitter.Channels[]
	DrawChannelFrozen : ImGuiTableDrawChannelIdx, // Draw channels for frozen rows (often headers)
	DrawChannelUnfrozen : ImGuiTableDrawChannelIdx, // Draw channels for unfrozen rows
	IsEnabled : bool, // IsUserEnabled && (Flags & ImGuiTableColumnFlags_Disabled) == 0
	IsUserEnabled : bool, // Is the column not marked Hidden by the user? (unrelated to being off view, e.g. clipped by scrolling).
	IsUserEnabledNextFrame : bool,
	IsVisibleX : bool, // Is actually in view (e.g. overlapping the host window clipping rectangle, not scrolled).
	IsVisibleY : bool,
	IsRequestOutput : bool, // Return value for TableSetColumnIndex() / TableNextColumn(): whether we request user to output contents or not.
	IsSkipItems : bool, // Do we want item submissions to this column to be completely ignored (no layout will happen).
	IsPreserveWidthAuto : bool,
	NavLayerCurrent : ImS8, // ImGuiNavLayer in 1 byte
	AutoFitQueue : ImU8, // Queue of 8 values for the next 8 frames to request auto-fit
	CannotSkipItemsQueue : ImU8, // Queue of 8 values for the next 8 frames to disable Clipped/SkipItem
	using _0 : bit_field u8 {
		SortDirection : ImU8 | 2, // ImGuiSortDirection_Ascending or ImGuiSortDirection_Descending
		SortDirectionsAvailCount : ImU8 | 2, // Number of available sort directions (0 to 3)
		SortDirectionsAvailMask : ImU8 | 4, // Mask of available sort directions (1-bit each)
	},
	SortDirectionsAvailList : ImU8, }

// Ordered list of available sort directions (2-bits each, total 8-bits)

ImGuiTableColumn_init :: proc(this : ^ImGuiTableColumn)
{
	memset(this, 0, size_of(this))
	this.WidthRequest = -1.0; this.StretchWeight = this.WidthRequest
	this.NameOffset = -1
	this.IndexWithinEnabledSet = -1; this.DisplayOrder = this.IndexWithinEnabledSet
	this.NextEnabledColumn = -1; this.PrevEnabledColumn = this.NextEnabledColumn
	this.SortOrder = -1
	this.SortDirection = ImGuiSortDirection.ImGuiSortDirection_None
	this.DrawChannelUnfrozen = cast(ImU8) -1; this.DrawChannelFrozen = this.DrawChannelUnfrozen; this.DrawChannelCurrent = this.DrawChannelFrozen
}

// Transient cell data stored per row.
// sizeof() ~ 6 bytes
ImGuiTableCellData :: struct {
	BgColor : ImU32, // Actual color
	Column : ImGuiTableColumnIdx, // Column number
}

// Storage for a table
// Parameters for TableAngledHeadersRowEx()
// This may end up being refactored for more general purpose.
// sizeof() ~ 12 bytes
ImGuiTableHeaderData :: struct {
	Index : ImGuiTableColumnIdx, // Column index
	TextColor : ImU32,
	BgColor0 : ImU32,
	BgColor1 : ImU32,
}

// Storage for one column of a table
// Per-instance data that needs preserving across frames (seemingly most others do not need to be preserved aside from debug needs. Does that means they could be moved to ImGuiTableTempData?)
// sizeof() ~ 24 bytes
ImGuiTableInstanceData :: struct {
	TableInstanceID : ImGuiID,
	LastOuterHeight : f32, // Outer height from last frame
	LastTopHeadersRowHeight : f32, // Height of first consecutive header rows from last frame (FIXME: this is used assuming consecutive headers are in same frozen set)
	LastFrozenHeight : f32, // Height of frozen section from last frame
	HoveredRowLast : i32, // Index of row which was hovered last frame.
	HoveredRowNext : i32, }

// Index of row hovered this frame, set after encountering it.

ImGuiTableInstanceData_init :: proc(this : ^ImGuiTableInstanceData)
{
	this.TableInstanceID = 0; this.LastFrozenHeight = 0.0; this.LastTopHeadersRowHeight = this.LastFrozenHeight; this.LastOuterHeight = this.LastTopHeadersRowHeight; this.HoveredRowNext = -1; this.HoveredRowLast = this.HoveredRowNext
}

// Storage for a tab item (within a tab bar)
// sizeof() ~ 592 bytes + heap allocs described in TableBeginInitMemory()
ImGuiTable :: struct {
	ID : ImGuiID,
	Flags : ImGuiTableFlags,
	RawData : rawptr, // Single allocation to hold Columns[], DisplayOrderToIndex[] and RowCellData[]
	TempData : ^ImGuiTableTempData, // Transient data while table is active. Point within g.CurrentTableStack[]
	Columns : ImSpan(ImGuiTableColumn), // Point within RawData[]
	DisplayOrderToIndex : ImSpan(ImGuiTableColumnIdx), // Point within RawData[]. Store display order of columns (when not reordered, the values are 0...Count-1)
	RowCellData : ImSpan(ImGuiTableCellData), // Point within RawData[]. Store cells background requests for current row.
	EnabledMaskByDisplayOrder : ImBitArrayPtr, // Column DisplayOrder -> IsEnabled map
	EnabledMaskByIndex : ImBitArrayPtr, // Column Index -> IsEnabled map (== not hidden by user/api) in a format adequate for iterating column without touching cold data
	VisibleMaskByIndex : ImBitArrayPtr, // Column Index -> IsVisibleX|IsVisibleY map (== not hidden by user/api && not hidden by scrolling/cliprect)
	SettingsLoadedFlags : ImGuiTableFlags, // Which data were loaded from the .ini file (e.g. when order is not altered we won't save order)
	SettingsOffset : i32, // Offset in g.SettingsTables
	LastFrameActive : i32,
	ColumnsCount : i32, // Number of columns declared in BeginTable()
	CurrentRow : i32,
	CurrentColumn : i32,
	InstanceCurrent : ImS16, // Count of BeginTable() calls with same ID in the same frame (generally 0). This is a little bit similar to BeginCount for a window, but multiple table with same ID look are multiple tables, they are just synched.
	InstanceInteracted : ImS16, // Mark which instance (generally 0) of the same ID is being interacted with
	RowPosY1 : f32,
	RowPosY2 : f32,
	RowMinHeight : f32, // Height submitted to TableNextRow()
	RowCellPaddingY : f32, // Top and bottom padding. Reloaded during row change.
	RowTextBaseline : f32,
	RowIndentOffsetX : f32,
	using _0 : bit_field u32 {
		RowFlags : ImGuiTableRowFlags | 16, // Current row flags, see ImGuiTableRowFlags_
		LastRowFlags : ImGuiTableRowFlags | 16,
	},
	RowBgColorCounter : i32, // Counter for alternating background colors (can be fast-forwarded by e.g clipper), not same as CurrentRow because header rows typically don't increase this.
	RowBgColor : [2]ImU32, // Background color override for current row.
	BorderColorStrong : ImU32,
	BorderColorLight : ImU32,
	BorderX1 : f32,
	BorderX2 : f32,
	HostIndentX : f32,
	MinColumnWidth : f32,
	OuterPaddingX : f32,
	CellPaddingX : f32, // Padding from each borders. Locked in BeginTable()/Layout.
	CellSpacingX1 : f32, // Spacing between non-bordered cells. Locked in BeginTable()/Layout.
	CellSpacingX2 : f32,
	InnerWidth : f32, // User value passed to BeginTable(), see comments at the top of BeginTable() for details.
	ColumnsGivenWidth : f32, // Sum of current column width
	ColumnsAutoFitWidth : f32, // Sum of ideal column width in order nothing to be clipped, used for auto-fitting and content width submission in outer window
	ColumnsStretchSumWeights : f32, // Sum of weight of all enabled stretching columns
	ResizedColumnNextWidth : f32,
	ResizeLockMinContentsX2 : f32, // Lock minimum contents width while resizing down in order to not create feedback loops. But we allow growing the table.
	RefScale : f32, // Reference scale to be able to rescale columns on font/dpi changes.
	AngledHeadersHeight : f32, // Set by TableAngledHeadersRow(), used in TableUpdateLayout()
	AngledHeadersSlope : f32, // Set by TableAngledHeadersRow(), used in TableUpdateLayout()
	OuterRect : ImRect, // Note: for non-scrolling table, OuterRect.Max.y is often FLT_MAX until EndTable(), unless a height has been specified in BeginTable().
	InnerRect : ImRect, // InnerRect but without decoration. As with OuterRect, for non-scrolling tables, InnerRect.Max.y is
	WorkRect : ImRect,
	InnerClipRect : ImRect,
	BgClipRect : ImRect, // We use this to cpu-clip cell background color fill, evolve during the frame as we cross frozen rows boundaries
	Bg0ClipRectForDrawCmd : ImRect, // Actual ImDrawCmd clip rect for BG0/1 channel. This tends to be == OuterWindow->ClipRect at BeginTable() because output in BG0/BG1 is cpu-clipped
	Bg2ClipRectForDrawCmd : ImRect, // Actual ImDrawCmd clip rect for BG2 channel. This tends to be a correct, tight-fit, because output to BG2 are done by widgets relying on regular ClipRect.
	HostClipRect : ImRect, // This is used to check if we can eventually merge our columns draw calls into the current draw call of the current window.
	HostBackupInnerClipRect : ImRect, // Backup of InnerWindow->ClipRect during PushTableBackground()/PopTableBackground()
	OuterWindow : ^ImGuiWindow, // Parent window for the table
	InnerWindow : ^ImGuiWindow, // Window holding the table data (== OuterWindow or a child window)
	ColumnsNames : ImGuiTextBuffer, // Contiguous buffer holding columns names
	DrawSplitter : ^ImDrawListSplitter, // Shortcut to TempData->DrawSplitter while in table. Isolate draw commands per columns to avoid switching clip rect constantly
	InstanceDataFirst : ImGuiTableInstanceData,
	InstanceDataExtra : ImVector(ImGuiTableInstanceData), // FIXME-OPT: Using a small-vector pattern would be good.
	SortSpecsSingle : ImGuiTableColumnSortSpecs,
	SortSpecsMulti : ImVector(ImGuiTableColumnSortSpecs), // FIXME-OPT: Using a small-vector pattern would be good.
	SortSpecs : ImGuiTableSortSpecs, // Public facing sorts specs, this is what we return in TableGetSortSpecs()
	SortSpecsCount : ImGuiTableColumnIdx,
	ColumnsEnabledCount : ImGuiTableColumnIdx, // Number of enabled columns (<= ColumnsCount)
	ColumnsEnabledFixedCount : ImGuiTableColumnIdx, // Number of enabled columns using fixed width (<= ColumnsCount)
	DeclColumnsCount : ImGuiTableColumnIdx, // Count calls to TableSetupColumn()
	AngledHeadersCount : ImGuiTableColumnIdx, // Count columns with angled headers
	HoveredColumnBody : ImGuiTableColumnIdx, // Index of column whose visible region is being hovered. Important: == ColumnsCount when hovering empty region after the right-most column!
	HoveredColumnBorder : ImGuiTableColumnIdx, // Index of column whose right-border is being hovered (for resizing).
	HighlightColumnHeader : ImGuiTableColumnIdx, // Index of column which should be highlighted.
	AutoFitSingleColumn : ImGuiTableColumnIdx, // Index of single column requesting auto-fit.
	ResizedColumn : ImGuiTableColumnIdx, // Index of column being resized. Reset when InstanceCurrent==0.
	LastResizedColumn : ImGuiTableColumnIdx, // Index of column being resized from previous frame.
	HeldHeaderColumn : ImGuiTableColumnIdx, // Index of column header being held.
	ReorderColumn : ImGuiTableColumnIdx, // Index of column being reordered. (not cleared)
	ReorderColumnDir : ImGuiTableColumnIdx, // -1 or +1
	LeftMostEnabledColumn : ImGuiTableColumnIdx, // Index of left-most non-hidden column.
	RightMostEnabledColumn : ImGuiTableColumnIdx, // Index of right-most non-hidden column.
	LeftMostStretchedColumn : ImGuiTableColumnIdx, // Index of left-most stretched column.
	RightMostStretchedColumn : ImGuiTableColumnIdx, // Index of right-most stretched column.
	ContextPopupColumn : ImGuiTableColumnIdx, // Column right-clicked on, of -1 if opening context menu from a neutral/empty spot
	FreezeRowsRequest : ImGuiTableColumnIdx, // Requested frozen rows count
	FreezeRowsCount : ImGuiTableColumnIdx, // Actual frozen row count (== FreezeRowsRequest, or == 0 when no scrolling offset)
	FreezeColumnsRequest : ImGuiTableColumnIdx, // Requested frozen columns count
	FreezeColumnsCount : ImGuiTableColumnIdx, // Actual frozen columns count (== FreezeColumnsRequest, or == 0 when no scrolling offset)
	RowCellDataCurrent : ImGuiTableColumnIdx, // Index of current RowCellData[] entry in current row
	DummyDrawChannel : ImGuiTableDrawChannelIdx, // Redirect non-visible columns here.
	Bg2DrawChannelCurrent : ImGuiTableDrawChannelIdx, // For Selectable() and other widgets drawing across columns after the freezing line. Index within DrawSplitter.Channels[]
	Bg2DrawChannelUnfrozen : ImGuiTableDrawChannelIdx,
	IsLayoutLocked : bool, // Set by TableUpdateLayout() which is called when beginning the first row.
	IsInsideRow : bool, // Set when inside TableBeginRow()/TableEndRow().
	IsInitializing : bool,
	IsSortSpecsDirty : bool,
	IsUsingHeaders : bool, // Set when the first row had the ImGuiTableRowFlags_Headers flag.
	IsContextPopupOpen : bool, // Set when default context menu is open (also see: ContextPopupColumn, InstanceInteracted).
	DisableDefaultContextMenu : bool, // Disable default context menu contents. You may submit your own using TableBeginContextMenuPopup()/EndPopup()
	IsSettingsRequestLoad : bool,
	IsSettingsDirty : bool, // Set when table settings have changed and needs to be reported into ImGuiTableSetttings data.
	IsDefaultDisplayOrder : bool, // Set when display order is unchanged from default (DisplayOrder contains 0...Count-1)
	IsResetAllRequest : bool,
	IsResetDisplayOrderRequest : bool,
	IsUnfrozenRows : bool, // Set when we got past the frozen row.
	IsDefaultSizingPolicy : bool, // Set if user didn't explicitly set a sizing policy in BeginTable()
	IsActiveIdAliveBeforeTable : bool,
	IsActiveIdInTable : bool,
	HasScrollbarYCurr : bool, // Whether ANY instance of this table had a vertical scrollbar during the current frame.
	HasScrollbarYPrev : bool, // Whether ANY instance of this table had a vertical scrollbar during the previous.
	MemoryCompacted : bool,
	HostSkipItems : bool, }

ImGuiTable_deinit :: proc(this : ^ImGuiTable)
{IM_FREE(this.RawData)}

// Backup of InnerWindow->SkipItem at the end of BeginTable(), because we will overwrite InnerWindow->SkipItem on a per-column basis

ImGuiTable_init :: proc(this : ^ImGuiTable)
{
	memset(this, 0, size_of(this)); this.LastFrameActive = -1
}

// Storage for one instance of a same table
// Transient data that are only needed between BeginTable() and EndTable(), those buffers are shared (1 per level of stacked table).
// - Accessing those requires chasing an extra pointer so for very frequently used data we leave them in the main table structure.
// - We also leave out of this structure data that tend to be particularly useful for debugging/metrics.
// FIXME-TABLE: more transient data could be stored in a stacked ImGuiTableTempData: e.g. SortSpecs.
// sizeof() ~ 136 bytes.
ImGuiTableTempData :: struct {
	TableIndex : i32, // Index in g.Tables.Buf[] pool
	LastTimeActive : f32, // Last timestamp this structure was used
	AngledHeadersExtraWidth : f32, // Used in EndTable()
	AngledHeadersRequests : ImVector(ImGuiTableHeaderData), // Used in TableAngledHeadersRow()

	UserOuterSize : ImVec2, // outer_size.x passed to BeginTable()
	DrawSplitter : ImDrawListSplitter,

	HostBackupWorkRect : ImRect, // Backup of InnerWindow->WorkRect at the end of BeginTable()
	HostBackupParentWorkRect : ImRect, // Backup of InnerWindow->ParentWorkRect at the end of BeginTable()
	HostBackupPrevLineSize : ImVec2, // Backup of InnerWindow->DC.PrevLineSize at the end of BeginTable()
	HostBackupCurrLineSize : ImVec2, // Backup of InnerWindow->DC.CurrLineSize at the end of BeginTable()
	HostBackupCursorMaxPos : ImVec2, // Backup of InnerWindow->DC.CursorMaxPos at the end of BeginTable()
	HostBackupColumnsOffset : ImVec1, // Backup of OuterWindow->DC.ColumnsOffset at the end of BeginTable()
	HostBackupItemWidth : f32, // Backup of OuterWindow->DC.ItemWidth at the end of BeginTable()
	HostBackupItemWidthStackSize : i32, }

//Backup of OuterWindow->DC.ItemWidthStack.Size at the end of BeginTable()

ImGuiTableTempData_init :: proc(this : ^ImGuiTableTempData)
{
	memset(this, 0, size_of(this)); this.LastTimeActive = -1.0
}

// sizeof() ~ 12
ImGuiTableColumnSettings :: struct {
	WidthOrWeight : f32,
	UserID : ImGuiID,
	Index : ImGuiTableColumnIdx,
	DisplayOrder : ImGuiTableColumnIdx,
	SortOrder : ImGuiTableColumnIdx,
	using _0 : bit_field u8 {
		SortDirection : ImU8 | 2,
		IsEnabled : ImU8 | 1, // "Visible" in ini file
		IsStretch : ImU8 | 1,
	},
}

ImGuiTableColumnSettings_init :: proc(this : ^ImGuiTableColumnSettings)
{
	this.WidthOrWeight = 0.0
	this.UserID = 0
	this.Index = -1
	this.SortOrder = -1; this.DisplayOrder = this.SortOrder
	this.SortDirection = ImGuiSortDirection.ImGuiSortDirection_None
	this.IsEnabled = 1
	this.IsStretch = 0
}

// Temporary storage for one table (one per table in the stack), shared between tables.
// This is designed to be stored in a single ImChunkStream (1 header followed by N ImGuiTableColumnSettings, etc.)
ImGuiTableSettings :: struct {
	ID : ImGuiID, // Set to 0 to invalidate/delete the setting
	SaveFlags : ImGuiTableFlags, // Indicate data we want to save using the Resizable/Reorderable/Sortable/Hideable flags (could be using its own flags..)
	RefScale : f32, // Reference scale to be able to rescale columns on font/dpi changes.
	ColumnsCount : ImGuiTableColumnIdx,
	ColumnsCountMax : ImGuiTableColumnIdx, // Maximum number of columns this settings instance can store, we can recycle a settings instance with lower number of columns but not higher
	WantApply : bool, }

// Set when loaded from .ini data (to enable merging/loading .ini data into an already running context)

ImGuiTableSettings_init :: proc(this : ^ImGuiTableSettings) { memset(this, 0, size_of(this)) }

ImGuiTableSettings_GetColumnSettings :: proc(this : ^ImGuiTableSettings) -> ^ImGuiTableColumnSettings { return cast(^ImGuiTableColumnSettings) (this + 1) }

//-----------------------------------------------------------------------------
// [SECTION] ImGui internal API
// No guarantee of forward compatibility here!
//-----------------------------------------------------------------------------

GetCurrentWindowRead :: #force_inline proc() -> ^ImGuiWindow
{
	g : ^ImGuiContext = GImGui; return g.CurrentWindow
}
GetCurrentWindow :: #force_inline proc() -> ^ImGuiWindow
{
	g : ^ImGuiContext = GImGui; g.CurrentWindow.WriteAccessed = true; return g.CurrentWindow
}
// You may also use SetNextWindowClass()'s FocusRouteParentWindowId field.
SetWindowParentWindowForFocusRoute :: #force_inline proc(window : ^ImGuiWindow, parent_window : ^ImGuiWindow) { window.ParentWindowForFocusRoute = parent_window }
WindowRectAbsToRel :: #force_inline proc(window : ^ImGuiWindow, r : ^ImRect) -> ImRect
{
	off : ImVec2 = window.DC.CursorStartPos; return ImRect(r.Min.x - off.x, r.Min.y - off.y, r.Max.x - off.x, r.Max.y - off.y)
}
WindowRectRelToAbs :: #force_inline proc(window : ^ImGuiWindow, r : ^ImRect) -> ImRect
{
	off : ImVec2 = window.DC.CursorStartPos; return ImRect(r.Min.x + off.x, r.Min.y + off.y, r.Max.x + off.x, r.Max.y + off.y)
}
WindowPosAbsToRel :: #force_inline proc(window : ^ImGuiWindow, p : ^ImVec2) -> ImVec2
{
	off : ImVec2 = window.DC.CursorStartPos; return ImVec2(p.x - off.x, p.y - off.y)
}
WindowPosRelToAbs :: #force_inline proc(window : ^ImGuiWindow, p : ^ImVec2) -> ImVec2
{
	off : ImVec2 = window.DC.CursorStartPos; return ImVec2(p.x + off.x, p.y + off.y)
}

GetDefaultFont :: #force_inline proc() -> ^ImFont
{
	g : ^ImGuiContext = GImGui; return g.IO.FontDefault ? g.IO.FontDefault : g.IO.Fonts.Fonts[0]
}
// get foreground draw list for the given viewport or viewport associated to the current window. this draw list will be the top-most rendered one. Useful to quickly draw shapes/text over dear imgui contents.
GetForegroundDrawList_w :: #force_inline proc(window : ^ImGuiWindow) -> ^ImDrawList { return GetForegroundDrawList(window.Viewport) }
LocalizeGetMsg :: #force_inline proc(key : ImGuiLocKey) -> ^u8
{
	g : ^ImGuiContext = GImGui^; msg : ^u8 = g.LocalizationTable[key]; return msg ? msg : "*Missing Text*"
}

//#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
ScrollToBringRectIntoView :: #force_inline proc(window : ^ImGuiWindow, rect : ^ImRect) { ScrollToRect(window, rect, ImGuiScrollFlags_.ImGuiScrollFlags_KeepVisibleEdgeY) }
//#endif

// Basic Accessors
GetItemStatusFlags :: #force_inline proc() -> ImGuiItemStatusFlags
{
	g : ^ImGuiContext = GImGui; return g.LastItemData.StatusFlags
}
GetItemFlags :: #force_inline proc() -> ImGuiItemFlags
{
	g : ^ImGuiContext = GImGui; return g.LastItemData.ItemFlags
}
GetActiveID :: #force_inline proc() -> ImGuiID
{
	g : ^ImGuiContext = GImGui; return g.ActiveId
}
GetFocusID :: #force_inline proc() -> ImGuiID
{
	g : ^ImGuiContext = GImGui; return g.NavId
}
// Basic Helpers for widget code
// FIXME: This is a misleading API since we expect CursorPos to be bb.Min.
ItemSize_0 :: #force_inline proc(bb : ^ImRect, text_baseline_y : f32 = -1.0) { ItemSize(GetSize(&bb), text_baseline_y) }
// Inputs
// FIXME: Eventually we should aim to move e.g. IsActiveIdUsingKey() into IsKeyXXX functions.
IsNamedKey :: #force_inline proc(key : ImGuiKey) -> bool { return key >= ImGuiKey.ImGuiKey_NamedKey_BEGIN && key < ImGuiKey.ImGuiKey_NamedKey_END }
IsNamedKeyOrMod :: #force_inline proc(key : ImGuiKey) -> bool { return (key >= ImGuiKey.ImGuiKey_NamedKey_BEGIN && key < ImGuiKey.ImGuiKey_NamedKey_END) || key == ImGuiKey.ImGuiMod_Ctrl || key == ImGuiKey.ImGuiMod_Shift || key == ImGuiKey.ImGuiMod_Alt || key == ImGuiKey.ImGuiMod_Super }
IsLegacyKey :: #force_inline proc(key : ImGuiKey) -> bool { return key >= ImGuiKey_LegacyNativeKey_BEGIN && key < ImGuiKey_LegacyNativeKey_END }
IsKeyboardKey :: #force_inline proc(key : ImGuiKey) -> bool { return key >= ImGuiKey_Keyboard_BEGIN && key < ImGuiKey_Keyboard_END }
IsGamepadKey :: #force_inline proc(key : ImGuiKey) -> bool { return key >= ImGuiKey_Gamepad_BEGIN && key < ImGuiKey_Gamepad_END }
IsMouseKey :: #force_inline proc(key : ImGuiKey) -> bool { return key >= ImGuiKey_Mouse_BEGIN && key < ImGuiKey_Mouse_END }
IsAliasKey :: #force_inline proc(key : ImGuiKey) -> bool { return key >= ImGuiKey_Aliases_BEGIN && key < ImGuiKey_Aliases_END }
IsLRModKey :: #force_inline proc(key : ImGuiKey) -> bool { return key >= ImGuiKey.ImGuiKey_LeftCtrl && key <= ImGuiKey.ImGuiKey_RightSuper }
ConvertSingleModFlagToKey :: #force_inline proc(key : ImGuiKey) -> ImGuiKey
{
	if key == ImGuiKey.ImGuiMod_Ctrl { return ImGuiKey.ImGuiKey_ReservedForModCtrl }
	if key == ImGuiKey.ImGuiMod_Shift { return ImGuiKey.ImGuiKey_ReservedForModShift }
	if key == ImGuiKey.ImGuiMod_Alt { return ImGuiKey.ImGuiKey_ReservedForModAlt }
	if key == ImGuiKey.ImGuiMod_Super { return ImGuiKey.ImGuiKey_ReservedForModSuper }
	return key
}

GetKeyData_k :: #force_inline proc(key : ImGuiKey) -> ^ImGuiKeyData
{
	g : ^ImGuiContext = GImGui; return GetKeyData(&g, key)
}
MouseButtonToKey :: #force_inline proc(button : ImGuiMouseButton) -> ImGuiKey
{
	IM_ASSERT(button >= 0 && button < ImGuiMouseButton_.ImGuiMouseButton_COUNT); return cast(ImGuiKey) (ImGuiKey.ImGuiKey_MouseLeft + button)
}
IsActiveIdUsingNavDir :: #force_inline proc(dir : ImGuiDir) -> bool
{
	g : ^ImGuiContext = GImGui; return (g.ActiveIdUsingNavDirMask & (1 << dir)) != 0
}

GetKeyOwnerData :: #force_inline proc(ctx : ^ImGuiContext, key : ImGuiKey) -> ^ImGuiKeyOwnerData
{
	if ImGuiMod_Mask_ : ^key; ImGuiMod_Mask_ { key = ConvertSingleModFlagToKey(key) }; IM_ASSERT(IsNamedKey(key)); return &ctx.KeysOwnerData[key - ImGuiKey.ImGuiKey_NamedKey_BEGIN]
}

DockNodeGetRootNode :: #force_inline proc(node : ^ImGuiDockNode) -> ^ImGuiDockNode
{
	for node.ParentNode { node = node.ParentNode }; return node
}
DockNodeIsInHierarchyOf :: #force_inline proc(node : ^ImGuiDockNode, parent : ^ImGuiDockNode) -> bool
{
	for node {if node == parent { return true }; node = node.ParentNode	}; return false
}
DockNodeGetDepth :: #force_inline proc(node : ^ImGuiDockNode) -> i32
{
	depth : i32 = 0; for node.ParentNode {node = node.ParentNode; post_incr(&depth)	}; return depth
}
DockNodeGetWindowMenuButtonId :: #force_inline proc(node : ^ImGuiDockNode) -> ImGuiID { return ImHashStr("#COLLAPSE", 0, node.ID) }
GetWindowDockNode :: #force_inline proc() -> ^ImGuiDockNode
{
	g : ^ImGuiContext = GImGui; return g.CurrentWindow.DockNode
}
DockBuilderGetCentralNode :: #force_inline proc(node_id : ImGuiID) -> ^ImGuiDockNode
{
	node : ^ImGuiDockNode = DockBuilderGetNode(node_id); if !node { return nil }; return DockNodeGetRootNode(node).CentralNode
}
// Focus scope we are outputting into, set by PushFocusScope()
GetCurrentFocusScope :: #force_inline proc() -> ImGuiID
{
	g : ^ImGuiContext = GImGui; return g.CurrentFocusScopeId
}

GetBoxSelectState :: #force_inline proc(id : ImGuiID) -> ^ImGuiBoxSelectState
{
	g : ^ImGuiContext = GImGui; return (id != 0 && g.BoxSelectState.ID == id && g.BoxSelectState.IsActive) ? &g.BoxSelectState : nil
}
GetMultiSelectState :: #force_inline proc(id : ImGuiID) -> ^ImGuiMultiSelectState
{
	g : ^ImGuiContext = GImGui; return GetByKey(&g.MultiSelectStorage, id)
}

// Tables: Internals
GetCurrentTable :: #force_inline proc() -> ^ImGuiTable
{
	g : ^ImGuiContext = GImGui; return g.CurrentTable
}
TableGetInstanceData :: #force_inline proc(table : ^ImGuiTable, instance_no : i32) -> ^ImGuiTableInstanceData
{
	if instance_no == 0 { return &table.InstanceDataFirst }; return &table.InstanceDataExtra[instance_no - 1]
}
TableGetInstanceID :: #force_inline proc(table : ^ImGuiTable, instance_no : i32) -> ImGuiID { return TableGetInstanceData(table, instance_no).TableInstanceID }
// Tab Bars
GetCurrentTabBar :: #force_inline proc() -> ^ImGuiTabBar
{
	g : ^ImGuiContext = GImGui; return g.CurrentTabBar
}
TabBarGetTabOrder :: #force_inline proc(tab_bar : ^ImGuiTabBar, tab : ^ImGuiTabItem) -> i32 { return index_from_ptr(&tab_bar.Tabs, tab) }

TempInputIsActive :: #force_inline proc(id : ImGuiID) -> bool
{
	g : ^ImGuiContext = GImGui; return (g.ActiveId == id && g.TempInputId == id)
}
// Get input text state if active
GetInputTextState :: #force_inline proc(id : ImGuiID) -> ^ImGuiInputTextState
{
	g : ^ImGuiContext = GImGui; return (id != 0 && g.InputTextState.ID == id) ? &g.InputTextState : nil
}


// Runtime data for multiple fonts, bake multiple fonts into a single texture, TTF/OTF font loader
// namespace ImGui


//-----------------------------------------------------------------------------
// [SECTION] ImFontAtlas internal API
//-----------------------------------------------------------------------------

// This structure is likely to evolve as we add support for incremental atlas updates.
// Conceptually this could be in ImGuiPlatformIO, but we are far from ready to make this public.
ImFontBuilderIO :: struct {
	FontBuilder_Build : proc(	_atlas : ^ImFontAtlas) -> bool,
}

//-----------------------------------------------------------------------------
// [SECTION] Test Engine specific hooks (imgui_test_engine)
//-----------------------------------------------------------------------------

when IMGUI_ENABLE_TEST_ENGINE {
// In IMGUI_VERSION_NUM >= 18934: changed IMGUI_TEST_ENGINE_ITEM_ADD(bb,id) to IMGUI_TEST_ENGINE_ITEM_ADD(id,bb,item_data);
IMGUI_TEST_ENGINE_ITEM_ADD :: #force_inline proc "contextless" (_ID : $T0, _BB : $T1, _ITEM_DATA : $T2) //TODO @gen: Validate the parameters were not passed by reference.
{
	if(g.TestEngineHookItems) { ImGuiTestEngineHook_ItemAdd(&g,_ID,_BB,_ITEM_DATA) } // Register item bounding box
}

IMGUI_TEST_ENGINE_ITEM_INFO :: #force_inline proc "contextless" (_ID : $T0, _LABEL : $T1, _FLAGS : $T2) //TODO @gen: Validate the parameters were not passed by reference.
{
	if(g.TestEngineHookItems) { ImGuiTestEngineHook_ItemInfo(&g,_ID,_LABEL,_FLAGS) } // Register item label and status flags (optional)
}

IMGUI_TEST_ENGINE_LOG :: #force_inline proc "contextless" (_FMT : $T0, args : ..[]any) //TODO @gen: Validate the parameters were not passed by reference.
{
	ImGuiTestEngineHook_Log(&g,_FMT,__VA_ARGS__)// Custom log entry from user land into test log
}

} else { // preproc else
IMGUI_TEST_ENGINE_ITEM_ADD :: #force_inline proc "contextless" (_BB : $T0, _ID : $T1)
{
	_ = _BB; _ = _ID
}

IMGUI_TEST_ENGINE_ITEM_INFO :: #force_inline proc "contextless" (_ID : $T0, _LABEL : $T1, _FLAGS : $T2) //TODO @gen: Validate the parameters were not passed by reference.
{
	_ = _ID ; _ = _LABEL ; _ = _FLAGS
}

} // preproc endif

//-----------------------------------------------------------------------------

// Debug options
IMGUI_DEBUG_NAV_SCORING :: 0// Display navigation scoring preview when hovering items. Hold CTRL to display for all candidates. CTRL+Arrow to change last direction.
IMGUI_DEBUG_NAV_RECTS :: 0// Display the reference navigation rectangle for each window

// When using CTRL+TAB (or Gamepad Square+L/R) we delay the visual a little in order to reduce visual noise doing a fast switch.
NAV_WINDOWING_HIGHLIGHT_DELAY : f32 = 0.20; // Time before the highlight and screen dimming starts fading in
NAV_WINDOWING_LIST_APPEAR_DELAY : f32 = 0.15; // Time before the window list starts to appear

NAV_ACTIVATE_HIGHLIGHT_TIMER : f32 = 0.10; // Time to highlight an item activated by a shortcut.

// Window resizing from edges (when io.ConfigWindowsResizeFromEdges = true and ImGuiBackendFlags_HasMouseCursors is set in io.BackendFlags by backend)
WINDOWS_HOVER_PADDING : f32 = 4.0; // Extend outside window for hovering/resizing (maxxed with TouchPadding) and inside windows for borders. Affect FindHoveredWindow().
WINDOWS_RESIZE_FROM_EDGES_FEEDBACK_TIMER : f32 = 0.04; // Reduce visual noise by only highlighting the border after a certain time.
WINDOWS_MOUSE_WHEEL_SCROLL_LOCK_TIMER : f32 = 0.70; // Lock scrolled window (so it doesn't pick child windows that are scrolling through) for a certain time, unless mouse moved.

// Tooltip offset
TOOLTIP_DEFAULT_OFFSET_MOUSE : ImVec2 = ImVec2{ 16 ,  10 }; // Multiplied by g.Style.MouseCursorScale
TOOLTIP_DEFAULT_OFFSET_TOUCH : ImVec2 = ImVec2{ 0  , -20 }; // Multiplied by g.Style.MouseCursorScale
TOOLTIP_DEFAULT_PIVOT_TOUCH  : ImVec2 = ImVec2{ 0.5, 1.0 }; // Multiplied by g.Style.MouseCursorScale

// Docking
DOCKING_TRANSPARENT_PAYLOAD_ALPHA : f32 = 0.50;

// Viewports
ImGui_IMGUI_VIEWPORT_DEFAULT_ID : ImGuiID = 0x11111111; //-----------------------------------------------------------------------------
// [SECTION] CONTEXT AND MEMORY ALLOCATORS
//-----------------------------------------------------------------------------

// DLL users:
// - Heaps and globals are not shared across DLL boundaries!
// - You will need to call SetCurrentContext() + SetAllocatorFunctions() for each static/DLL boundary you are calling from.
// - Same applies for hot-reloading mechanisms that are reliant on reloading DLL (note that many hot-reloading mechanisms work without DLL).
// - Using Dear ImGui via a shared library is not recommended, because of function call overhead and because we don't guarantee backward nor forward ABI compatibility.
// - Confused? In a debugger: add GImGui to your watch window and notice how its value changes depending on your current location (which DLL boundary you are in).

// Current context pointer. Implicitly used by all Dear ImGui functions. Always assumed to be != NULL.
// - ImGui::CreateContext() will automatically set this pointer if it is NULL.
//   Change to a different context by calling ImGui::SetCurrentContext().
// - Important: Dear ImGui functions are not thread-safe because of this pointer.
//   If you want thread-safety to allow N threads to access N different contexts:
//   - Change this variable to use thread local storage so each thread can refer to a different context, in your imconfig.h:
//         struct ImGuiContext;
//         extern thread_local ImGuiContext* MyImGuiTLS;
//         #define GImGui MyImGuiTLS
//     And then define MyImGuiTLS in one of your cpp files. Note that thread_local is a C++11 keyword, earlier C++ uses compiler-specific keyword.
//   - Future development aims to make this context pointer explicit to all calls. Also read https://github.com/ocornut/imgui/issues/586
//   - If you need a finite number of contexts, you may compile and use multiple instances of the ImGui code from a different namespace.
// - DLL users: read comments above.
GImGui : ^ImGuiContext = nil

// Memory Allocator functions. Use SetAllocatorFunctions() to change them.
// - You probably don't want to modify that mid-program, and if you use global/static e.g. ImVector<> instances you may need to keep them accessible during program destruction.
// - DLL users: read comments above.
when ! IMGUI_DISABLE_DEFAULT_ALLOCATORS {
MallocWrapper :: proc(size : uint, user_data : rawptr) -> rawptr
{
	IM_UNUSED(user_data); return malloc(size)
}
FreeWrapper :: proc(ptr : rawptr, user_data : rawptr)
{
	IM_UNUSED(user_data); free(ptr)
}
} else { // preproc else
MallocWrapper :: proc(size : uint, user_data : rawptr) -> rawptr
{
	IM_UNUSED(user_data); IM_UNUSED(size); IM_ASSERT(0); return nil
}
FreeWrapper :: proc(ptr : rawptr, user_data : rawptr)
{
	IM_UNUSED(user_data); IM_UNUSED(ptr); IM_ASSERT(0)
}
} // preproc endif
GImAllocatorAllocFunc : ImGuiMemAllocFunc = MallocWrapper
GImAllocatorFreeFunc : ImGuiMemFreeFunc = FreeWrapper
GImAllocatorUserData : rawptr = nil

// Default flags when using IsItemHovered(ImGuiHoveredFlags_ForTooltip) or BeginItemTooltip()/SetItemTooltip() while using keyboard/gamepad.

//-----------------------------------------------------------------------------
// [SECTION] USER FACING STRUCTURES (ImGuiStyle, ImGuiIO, ImGuiPlatformIO)
//-----------------------------------------------------------------------------

ImGuiStyle_init :: proc(this : ^ImGuiStyle)
{
	this.Alpha = 1.0; // Global alpha applies to everything in Dear ImGui.
	this.DisabledAlpha = 0.60; // Additional alpha multiplier applied by BeginDisabled(). Multiply over current value of Alpha.
	this.WindowPadding = ImVec2(8, 8); // Padding within a window
	this.WindowRounding = 0.0; // Radius of window corners rounding. Set to 0.0f to have rectangular windows. Large values tend to lead to variety of artifacts and are not recommended.
	this.WindowBorderSize = 1.0; // Thickness of border around windows. Generally set to 0.0f or 1.0f. Other values not well tested.
	this.WindowMinSize = ImVec2(32, 32); // Minimum window size
	this.WindowTitleAlign = ImVec2(0.0, 0.5); // Alignment for title bar text
	this.WindowMenuButtonPosition = ImGuiDir.ImGuiDir_Left; // Position of the collapsing/docking button in the title bar (left/right). Defaults to ImGuiDir_Left.
	this.ChildRounding = 0.0; // Radius of child window corners rounding. Set to 0.0f to have rectangular child windows
	this.ChildBorderSize = 1.0; // Thickness of border around child windows. Generally set to 0.0f or 1.0f. Other values not well tested.
	this.PopupRounding = 0.0; // Radius of popup window corners rounding. Set to 0.0f to have rectangular child windows
	this.PopupBorderSize = 1.0; // Thickness of border around popup or tooltip windows. Generally set to 0.0f or 1.0f. Other values not well tested.
	this.FramePadding = ImVec2(4, 3); // Padding within a framed rectangle (used by most widgets)
	this.FrameRounding = 0.0; // Radius of frame corners rounding. Set to 0.0f to have rectangular frames (used by most widgets).
	this.FrameBorderSize = 0.0; // Thickness of border around frames. Generally set to 0.0f or 1.0f. Other values not well tested.
	this.ItemSpacing = ImVec2(8, 4); // Horizontal and vertical spacing between widgets/lines
	this.ItemInnerSpacing = ImVec2(4, 4); // Horizontal and vertical spacing between within elements of a composed widget (e.g. a slider and its label)
	this.CellPadding = ImVec2(4, 2); // Padding within a table cell. Cellpadding.x is locked for entire table. CellPadding.y may be altered between different rows.
	this.TouchExtraPadding = ImVec2(0, 0); // Expand reactive bounding box for touch-based system where touch position is not accurate enough. Unfortunately we don't sort widgets so priority on overlap will always be given to the first widget. So don't grow this too much!
	this.IndentSpacing = 21.0; // Horizontal spacing when e.g. entering a tree node. Generally == (FontSize + FramePadding.x*2).
	this.ColumnsMinSpacing = 6.0; // Minimum horizontal spacing between two columns. Preferably > (FramePadding.x + 1).
	this.ScrollbarSize = 14.0; // Width of the vertical scrollbar, Height of the horizontal scrollbar
	this.ScrollbarRounding = 9.0; // Radius of grab corners rounding for scrollbar
	this.GrabMinSize = 12.0; // Minimum width/height of a grab box for slider/scrollbar
	this.GrabRounding = 0.0; // Radius of grabs corners rounding. Set to 0.0f to have rectangular slider grabs.
	this.LogSliderDeadzone = 4.0; // The size in pixels of the dead-zone around zero on logarithmic sliders that cross zero.
	this.TabRounding = 4.0; // Radius of upper corners of a tab. Set to 0.0f to have rectangular tabs.
	this.TabBorderSize = 0.0; // Thickness of border around tabs.
	this.TabMinWidthForCloseButton = 0.0; // Minimum width for close button to appear on an unselected tab when hovered. Set to 0.0f to always show when hovering, set to FLT_MAX to never show close button unless selected.
	this.TabBarBorderSize = 1.0; // Thickness of tab-bar separator, which takes on the tab active color to denote focus.
	this.TabBarOverlineSize = 2.0; // Thickness of tab-bar overline, which highlights the selected tab-bar.
	this.TableAngledHeadersAngle = 35.0 * (IM_PI / 180.0); // Angle of angled headers (supported values range from -50 degrees to +50 degrees).
	this.TableAngledHeadersTextAlign = ImVec2(0.5, 0.0); // Alignment of angled headers within the cell
	this.ColorButtonPosition = ImGuiDir.ImGuiDir_Right; // Side of the color button in the ColorEdit4 widget (left/right). Defaults to ImGuiDir_Right.
	this.ButtonTextAlign = ImVec2(0.5, 0.5); // Alignment of button text when button is larger than text.
	this.SelectableTextAlign = ImVec2(0.0, 0.0); // Alignment of selectable text. Defaults to (0.0f, 0.0f) (top-left aligned). It's generally important to keep this left-aligned if you want to lay multiple items on a same line.
	this.SeparatorTextBorderSize = 3.0; // Thickness of border in SeparatorText()
	this.SeparatorTextAlign = ImVec2(0.0, 0.5); // Alignment of text within the separator. Defaults to (0.0f, 0.5f) (left aligned, center).
	this.SeparatorTextPadding = ImVec2(20.0, 3.); // Horizontal offset of text from each edge of the separator + spacing on other axis. Generally small values. .y is recommended to be == FramePadding.y.
	this.DisplayWindowPadding = ImVec2(19, 19); // Window position are clamped to be visible within the display area or monitors by at least this amount. Only applies to regular windows.
	this.DisplaySafeAreaPadding = ImVec2(3, 3); // If you cannot see the edge of your screen (e.g. on a TV) increase the safe area padding. Covers popups/tooltips as well regular windows.
	this.DockingSeparatorSize = 2.0; // Thickness of resizing border between docked windows
	this.MouseCursorScale = 1.0; // Scale software rendered mouse cursor (when io.MouseDrawCursor is enabled). May be removed later.
	this.AntiAliasedLines = true; // Enable anti-aliased lines/borders. Disable if you are really tight on CPU/GPU.
	this.AntiAliasedLinesUseTex = true; // Enable anti-aliased lines/borders using textures where possible. Require backend to render with bilinear filtering (NOT point/nearest filtering).
	this.AntiAliasedFill = true; // Enable anti-aliased filled shapes (rounded rectangles, circles, etc.).
	this.CurveTessellationTol = 1.25; // Tessellation tolerance when using PathBezierCurveTo() without a specific number of segments. Decrease for highly tessellated curves (higher quality, more polygons), increase to reduce quality.
	this.CircleTessellationMaxError = 0.30; // Maximum error (in pixels) allowed when using AddCircle()/AddCircleFilled() or drawing rounded corner rectangles with no explicit segment count specified. Decrease for higher quality but more geometry.

	// Behaviors
	this.HoverStationaryDelay = 0.15; // Delay for IsItemHovered(ImGuiHoveredFlags_Stationary). Time required to consider mouse stationary.
	this.HoverDelayShort = 0.15; // Delay for IsItemHovered(ImGuiHoveredFlags_DelayShort). Usually used along with HoverStationaryDelay.
	this.HoverDelayNormal = 0.40; // Delay for IsItemHovered(ImGuiHoveredFlags_DelayNormal). "
	this.HoverFlagsForTooltipMouse = ImGuiHoveredFlags_.ImGuiHoveredFlags_Stationary | ImGuiHoveredFlags_.ImGuiHoveredFlags_DelayShort | ImGuiHoveredFlags_.ImGuiHoveredFlags_AllowWhenDisabled; // Default flags when using IsItemHovered(ImGuiHoveredFlags_ForTooltip) or BeginItemTooltip()/SetItemTooltip() while using mouse.
	this.HoverFlagsForTooltipNav = ImGuiHoveredFlags_.ImGuiHoveredFlags_NoSharedDelay | ImGuiHoveredFlags_.ImGuiHoveredFlags_DelayNormal | ImGuiHoveredFlags_.ImGuiHoveredFlags_AllowWhenDisabled; // Default flags when using IsItemHovered(ImGuiHoveredFlags_ForTooltip) or BeginItemTooltip()/SetItemTooltip() while using keyboard/gamepad.

	// Default theme
	StyleColorsDark(this)
}

// To scale your entire UI (e.g. if you want your app to use High DPI or generally be DPI aware) you may use this helper function. Scaling the fonts is done separately and is up to you.
// Important: This operation is lossy because we round all sizes to integer. If you need to change your scale multiples, call this over a freshly initialized ImGuiStyle structure rather than scaling multiple times.
ImGuiStyle_ScaleAllSizes :: proc(this : ^ImGuiStyle, scale_factor : f32)
{
	this.WindowPadding = ImTrunc(this.WindowPadding * scale_factor)
	this.WindowRounding = ImTrunc(this.WindowRounding * scale_factor)
	this.WindowMinSize = ImTrunc(this.WindowMinSize * scale_factor)
	this.ChildRounding = ImTrunc(this.ChildRounding * scale_factor)
	this.PopupRounding = ImTrunc(this.PopupRounding * scale_factor)
	this.FramePadding = ImTrunc(this.FramePadding * scale_factor)
	this.FrameRounding = ImTrunc(this.FrameRounding * scale_factor)
	this.ItemSpacing = ImTrunc(this.ItemSpacing * scale_factor)
	this.ItemInnerSpacing = ImTrunc(this.ItemInnerSpacing * scale_factor)
	this.CellPadding = ImTrunc(this.CellPadding * scale_factor)
	this.TouchExtraPadding = ImTrunc(this.TouchExtraPadding * scale_factor)
	this.IndentSpacing = ImTrunc(this.IndentSpacing * scale_factor)
	this.ColumnsMinSpacing = ImTrunc(this.ColumnsMinSpacing * scale_factor)
	this.ScrollbarSize = ImTrunc(this.ScrollbarSize * scale_factor)
	this.ScrollbarRounding = ImTrunc(this.ScrollbarRounding * scale_factor)
	this.GrabMinSize = ImTrunc(this.GrabMinSize * scale_factor)
	this.GrabRounding = ImTrunc(this.GrabRounding * scale_factor)
	this.LogSliderDeadzone = ImTrunc(this.LogSliderDeadzone * scale_factor)
	this.TabRounding = ImTrunc(this.TabRounding * scale_factor)
	this.TabMinWidthForCloseButton = (this.TabMinWidthForCloseButton != FLT_MAX) ? ImTrunc(this.TabMinWidthForCloseButton * scale_factor) : FLT_MAX
	this.TabBarOverlineSize = ImTrunc(this.TabBarOverlineSize * scale_factor)
	this.SeparatorTextPadding = ImTrunc(this.SeparatorTextPadding * scale_factor)
	this.DockingSeparatorSize = ImTrunc(this.DockingSeparatorSize * scale_factor)
	this.DisplayWindowPadding = ImTrunc(this.DisplayWindowPadding * scale_factor)
	this.DisplaySafeAreaPadding = ImTrunc(this.DisplaySafeAreaPadding * scale_factor)
	this.MouseCursorScale = ImTrunc(this.MouseCursorScale * scale_factor)
}

ImGuiIO_init :: proc(this : ^ImGuiIO)
{
	// Most fields are initialized with zero
	memset(this, 0, size_of(this))
	IM_STATIC_ASSERT(IM_ARRAYSIZE(this.ImGuiIO_MouseDown) == ImGuiMouseButton_.ImGuiMouseButton_COUNT && IM_ARRAYSIZE(this.ImGuiIO_MouseClicked) == ImGuiMouseButton_.ImGuiMouseButton_COUNT)

	// Settings
	this.ConfigFlags = ImGuiConfigFlags_.ImGuiConfigFlags_None
	this.BackendFlags = ImGuiBackendFlags_.ImGuiBackendFlags_None
	this.DisplaySize = ImVec2(-1.0, -1.0)
	this.DeltaTime = 1.0 / 60.0
	this.IniSavingRate = 5.0
	this.IniFilename = "imgui.ini"; // Important: "imgui.ini" is relative to current working dir, most apps will want to lock this to an absolute path (e.g. same path as executables).
	this.LogFilename = "imgui_log.txt"
	this.UserData = nil

	this.Fonts = nil
	this.FontGlobalScale = 1.0
	this.FontDefault = nil
	this.FontAllowUserScaling = false
	this.DisplayFramebufferScale = ImVec2(1.0, 1.0)

	// Keyboard/Gamepad Navigation options
	this.ConfigNavSwapGamepadButtons = false
	this.ConfigNavMoveSetMousePos = false
	this.ConfigNavCaptureKeyboard = true
	this.ConfigNavEscapeClearFocusItem = true
	this.ConfigNavEscapeClearFocusWindow = false
	this.ConfigNavCursorVisibleAuto = true
	this.ConfigNavCursorVisibleAlways = false

	// Docking options (when ImGuiConfigFlags_DockingEnable is set)
	this.ConfigDockingNoSplit = false
	this.ConfigDockingWithShift = false
	this.ConfigDockingAlwaysTabBar = false
	this.ConfigDockingTransparentPayload = false

	// Viewport options (when ImGuiConfigFlags_ViewportsEnable is set)
	this.ConfigViewportsNoAutoMerge = false
	this.ConfigViewportsNoTaskBarIcon = false
	this.ConfigViewportsNoDecoration = true
	this.ConfigViewportsNoDefaultParent = false

	// Miscellaneous options
	this.MouseDrawCursor = false
	when defined ( __APPLE__ ) {
	this.ConfigMacOSXBehaviors = true; // Set Mac OS X style defaults based on __APPLE__ compile time flag
	} else { // preproc else
	this.ConfigMacOSXBehaviors = false
	} // preproc endif
	this.ConfigInputTrickleEventQueue = true
	this.ConfigInputTextCursorBlink = true
	this.ConfigInputTextEnterKeepActive = false
	this.ConfigDragClickToInputText = false
	this.ConfigWindowsResizeFromEdges = true
	this.ConfigWindowsMoveFromTitleBarOnly = false
	this.ConfigWindowsCopyContentsWithCtrlC = false
	this.ConfigScrollbarScrollByPage = true
	this.ConfigMemoryCompactTimer = 60.0
	this.ConfigDebugIsDebuggerPresent = false
	this.ConfigDebugHighlightIdConflicts = true
	this.ConfigDebugBeginReturnValueOnce = false
	this.ConfigDebugBeginReturnValueLoop = false

	this.ConfigErrorRecovery = true
	this.ConfigErrorRecoveryEnableAssert = true
	this.ConfigErrorRecoveryEnableDebugLog = true
	this.ConfigErrorRecoveryEnableTooltip = true

	// Inputs Behaviors
	this.MouseDoubleClickTime = 0.30
	this.MouseDoubleClickMaxDist = 6.0
	this.MouseDragThreshold = 6.0
	this.KeyRepeatDelay = 0.275
	this.KeyRepeatRate = 0.050

	// Platform Functions
	// Note: Initialize() will setup default clipboard/ime handlers.
	this.BackendRendererName = nil; this.BackendPlatformName = this.BackendRendererName
	this.BackendLanguageUserData = nil; this.BackendRendererUserData = this.BackendLanguageUserData; this.BackendPlatformUserData = this.BackendRendererUserData

	// Input (NB: we already have memset zero the entire structure!)
	this.MousePos = ImVec2(-FLT_MAX, -FLT_MAX)
	this.MousePosPrev = ImVec2(-FLT_MAX, -FLT_MAX)
	this.MouseSource = ImGuiMouseSource.ImGuiMouseSource_Mouse
	for i : i32 = 0; i < IM_ARRAYSIZE(this.MouseDownDuration); post_incr(&i) { this.MouseDownDurationPrev[i] = -1.0; this.MouseDownDuration[i] = this.MouseDownDurationPrev[i] }

	for i : i32 = 0; i < IM_ARRAYSIZE(this.KeysData); post_incr(&i) { this.KeysData[i].DownDurationPrev = -1.0; this.KeysData[i].DownDuration = this.KeysData[i].DownDurationPrev }

	this.AppAcceptingEvents = true
}

// Queue a new character input
// Pass in translated ASCII characters for text input.
// - with glfw you can get those from the callback set in glfwSetCharCallback()
// - on Windows you can get those using ToAscii+keyboard state, or via the WM_CHAR message
// FIXME: Should in theory be called "AddCharacterEvent()" to be consistent with new API
ImGuiIO_AddInputCharacter :: proc(this : ^ImGuiIO, c : u32)
{
	IM_ASSERT(this.Ctx != nil)
	g : ^ImGuiContext = this.Ctx
	if c == 0 || !this.AppAcceptingEvents { return }

	e : ImGuiInputEvent
	e.Type = ImGuiInputEventType.ImGuiInputEventType_Text
	e.Source = ImGuiInputSource.ImGuiInputSource_Keyboard
	e.EventId = post_incr(&g.InputEventsNextEventId)
	e.Text.Char = c
	push_back(&g.InputEventsQueue, e)
}

// Queue a new character input from a UTF-16 character, it can be a surrogate
// UTF16 strings use surrogate pairs to encode codepoints >= 0x10000, so
// we should save the high surrogate.
ImGuiIO_AddInputCharacterUTF16 :: proc(this : ^ImGuiIO, c : ImWchar16)
{
	if (c == 0 && this.InputQueueSurrogate == 0) || !this.AppAcceptingEvents { return }

	if (c & 0xFC00) == 0xD800 {
		// High surrogate, must save
		if this.InputQueueSurrogate != 0 { AddInputCharacter(IM_UNICODE_CODEPOINT_INVALID) }
		this.InputQueueSurrogate = c
		return
	}

	cp : ImWchar = c
	if this.InputQueueSurrogate != 0 {
		if (c & 0xFC00) != 0xDC00 {
			// Invalid low surrogate
			AddInputCharacter(IM_UNICODE_CODEPOINT_INVALID)
		}
		else {
			when IM_UNICODE_CODEPOINT_MAX == 0xFFFF {
			cp = IM_UNICODE_CODEPOINT_INVALID; // Codepoint will not fit in ImWchar
			} else { // preproc else
			cp = cast(ImWchar) (((this.InputQueueSurrogate - 0xD800) << 10) + (c - 0xDC00) + 0x10000)
			} // preproc endif
		}

		this.InputQueueSurrogate = 0
	}
	AddInputCharacter(cast(u32) cp)
}

// Queue a new characters input from a UTF-8 string
ImGuiIO_AddInputCharactersUTF8 :: proc(this : ^ImGuiIO, utf8_chars : ^u8)
{
	if !this.AppAcceptingEvents { return }
	for utf8_chars^ != 0 {
		c : u32 = 0
		utf8_chars += ImTextCharFromUtf8(&c, utf8_chars, nil)
		AddInputCharacter(c)
	}
}

// Clear all incoming events.
// Clear all incoming events.
ImGuiIO_ClearEventsQueue :: proc(this : ^ImGuiIO)
{
	IM_ASSERT(this.Ctx != nil)
	g : ^ImGuiContext = this.Ctx
	clear(&g.InputEventsQueue)
}

// Clear current keyboard/gamepad state + current frame text input buffer. Equivalent to releasing all keys/buttons.
// Clear current keyboard/gamepad state + current frame text input buffer. Equivalent to releasing all keys/buttons.
ImGuiIO_ClearInputKeys :: proc(this : ^ImGuiIO)
{
	g : ^ImGuiContext = this.Ctx
	for key : i32 = ImGuiKey.ImGuiKey_NamedKey_BEGIN; key < ImGuiKey.ImGuiKey_NamedKey_END; post_incr(&key) {
		if IsMouseKey(cast(ImGuiKey) key) { continue }
		key_data : ^ImGuiKeyData = &g.IO.KeysData[key - ImGuiKey.ImGuiKey_NamedKey_BEGIN]
		key_data.Down = false
		key_data.DownDuration = -1.0
		key_data.DownDurationPrev = -1.0
	}

	this.KeySuper = false; this.KeyAlt = this.KeySuper; this.KeyShift = this.KeyAlt; this.KeyCtrl = this.KeyShift
	this.KeyMods = ImGuiKey.ImGuiMod_None
	resize(&this.InputQueueCharacters, 0); // Behavior of old ClearInputCharacters().
}

// Clear current mouse state.
ImGuiIO_ClearInputMouse :: proc(this : ^ImGuiIO)
{
	for key : ImGuiKey = ImGuiKey_Mouse_BEGIN; key < ImGuiKey_Mouse_END; key = cast(ImGuiKey) (key + 1) {
		key_data : ^ImGuiKeyData = &this.KeysData[key - ImGuiKey.ImGuiKey_NamedKey_BEGIN]
		key_data.Down = false
		key_data.DownDuration = -1.0
		key_data.DownDurationPrev = -1.0
	}

	this.MousePos = ImVec2(-FLT_MAX, -FLT_MAX)
	for n : i32 = 0; n < IM_ARRAYSIZE(this.MouseDown); post_incr(&n) {
		this.MouseDown[n] = false
		this.MouseDownDurationPrev[n] = -1.0; this.MouseDownDuration[n] = this.MouseDownDurationPrev[n]
	}

	this.MouseWheelH = 0.0; this.MouseWheel = this.MouseWheelH
}


FindLatestInputEvent :: proc(ctx : ^ImGuiContext, type : ImGuiInputEventType, arg : i32 = -1) -> ^ImGuiInputEvent
{
	g : ^ImGuiContext = ctx
	for n : i32 = g.InputEventsQueue.Size - 1; n >= 0; post_decr(&n) {
		e : ^ImGuiInputEvent = &g.InputEventsQueue[n]
		if e.Type != type { continue }
		if type == ImGuiInputEventType.ImGuiInputEventType_Key && e.Key.Key != arg { continue }
		if type == ImGuiInputEventType.ImGuiInputEventType_MouseButton && e.MouseButton.Button != arg { continue }
		return e
	}

	return nil
}

// Queue a new key down/up event for analog values (e.g. ImGuiKey_Gamepad_ values). Dead-zones should be handled by the backend.
// Queue a new key down/up event.
// - ImGuiKey key:       Translated key (as in, generally ImGuiKey_A matches the key end-user would use to emit an 'A' character)
// - bool down:          Is the key down? use false to signify a key release.
// - float analog_value: 0.0f..1.0f
// IMPORTANT: THIS FUNCTION AND OTHER "ADD" GRABS THE CONTEXT FROM OUR INSTANCE.
// WE NEED TO ENSURE THAT ALL FUNCTION CALLS ARE FULFILLING THIS, WHICH IS WHY GetKeyData() HAS AN EXPLICIT CONTEXT.
ImGuiIO_AddKeyAnalogEvent :: proc(this : ^ImGuiIO, key : ImGuiKey, down : bool, analog_value : f32)
{
	//if (e->Down) { IMGUI_DEBUG_LOG_IO("AddKeyEvent() Key='%s' %d, NativeKeycode = %d, NativeScancode = %d\n", ImGui::GetKeyName(e->Key), e->Down, e->NativeKeycode, e->NativeScancode); }
	IM_ASSERT(this.Ctx != nil)
	if key == ImGuiKey.ImGuiKey_None || !this.AppAcceptingEvents { return }
	g : ^ImGuiContext = this.Ctx
	IM_ASSERT(IsNamedKeyOrMod(key)); // Backend needs to pass a valid ImGuiKey_ constant. 0..511 values are legacy native key codes which are not accepted by this API.
	IM_ASSERT(IsAliasKey(key) == false); // Backend cannot submit ImGuiKey_MouseXXX values they are automatically inferred from AddMouseXXX() events.

	// MacOS: swap Cmd(Super) and Ctrl
	if g.IO.ConfigMacOSXBehaviors {
		if key == ImGuiKey.ImGuiMod_Super { key = ImGuiKey.ImGuiMod_Ctrl }
		else if key == ImGuiKey.ImGuiMod_Ctrl { key = ImGuiKey.ImGuiMod_Super }
		else if key == ImGuiKey.ImGuiKey_LeftSuper { key = ImGuiKey.ImGuiKey_LeftCtrl }
		else if key == ImGuiKey.ImGuiKey_RightSuper { key = ImGuiKey.ImGuiKey_RightCtrl }
		else if key == ImGuiKey.ImGuiKey_LeftCtrl { key = ImGuiKey.ImGuiKey_LeftSuper }
		else if key == ImGuiKey.ImGuiKey_RightCtrl { key = ImGuiKey.ImGuiKey_RightSuper }
	}

	// Filter duplicate (in particular: key mods and gamepad analog values are commonly spammed)
	latest_event : ^ImGuiInputEvent = FindLatestInputEvent(&g, ImGuiInputEventType.ImGuiInputEventType_Key, cast(i32) key)
	key_data : ^ImGuiKeyData = GetKeyData(&g, key)
	latest_key_down : bool = latest_event ? latest_event.Key.Down : key_data.Down
	latest_key_analog : f32 = latest_event ? latest_event.Key.AnalogValue : key_data.AnalogValue
	if latest_key_down == down && latest_key_analog == analog_value { return }

	// Add event
	e : ImGuiInputEvent
	e.Type = ImGuiInputEventType.ImGuiInputEventType_Key
	e.Source = IsGamepadKey(key) ? ImGuiInputSource.ImGuiInputSource_Gamepad : ImGuiInputSource.ImGuiInputSource_Keyboard
	e.EventId = post_incr(&g.InputEventsNextEventId)
	e.Key.Key = key
	e.Key.Down = down
	e.Key.AnalogValue = analog_value
	push_back(&g.InputEventsQueue, e)
}

// = NULL           // User data for non C++ programming language backend

//------------------------------------------------------------------
// Input - Call before calling NewFrame()
//------------------------------------------------------------------

// Input Functions
// Queue a new key down/up event. Key should be "translated" (as in, generally ImGuiKey_A matches the key end-user would use to emit an 'A' character)
ImGuiIO_AddKeyEvent :: proc(this : ^ImGuiIO, key : ImGuiKey, down : bool)
{
	if !this.AppAcceptingEvents { return }
	AddKeyAnalogEvent(key, down, down ? 1.0 : 0.0)
}

// [Optional] Specify index for legacy <1.87 IsKeyXXX() functions with native indices + specify native keycode, scancode.
// [Optional] Call after AddKeyEvent().
// Specify native keycode, scancode + Specify index for legacy <1.87 IsKeyXXX() functions with native indices.
// If you are writing a backend in 2022 or don't use IsKeyXXX() with native values that are not ImGuiKey values, you can avoid calling this.
ImGuiIO_SetKeyEventNativeData :: proc(this : ^ImGuiIO, key : ImGuiKey, native_keycode : i32, native_scancode : i32, native_legacy_index : i32)
{
	if key == ImGuiKey.ImGuiKey_None { return }
	IM_ASSERT(IsNamedKey(key)); // >= 512
	IM_ASSERT(native_legacy_index == -1 || IsLegacyKey(cast(ImGuiKey) native_legacy_index)); // >= 0 && <= 511
	IM_UNUSED(key); // Yet unused
	IM_UNUSED(native_keycode); // Yet unused
	IM_UNUSED(native_scancode); // Yet unused
	IM_UNUSED(native_legacy_index); // Yet unused
}

// Set master flag for accepting key/mouse/text events (default to true). Useful if you have native dialog boxes that are interrupting your application loop/refresh, and you want to disable events being queued while your app is frozen.
// Set master flag for accepting key/mouse/text events (default to true). Useful if you have native dialog boxes that are interrupting your application loop/refresh, and you want to disable events being queued while your app is frozen.
ImGuiIO_SetAppAcceptingEvents :: proc(this : ^ImGuiIO, accepting_events : bool)
{
	this.AppAcceptingEvents = accepting_events
}

// Queue a mouse position update. Use -FLT_MAX,-FLT_MAX to signify no mouse (e.g. app not focused and not hovered)
// Queue a mouse move event
ImGuiIO_AddMousePosEvent :: proc(this : ^ImGuiIO, x : f32, y : f32)
{
	IM_ASSERT(this.Ctx != nil)
	g : ^ImGuiContext = this.Ctx
	if !this.AppAcceptingEvents { return }

	// Apply same flooring as UpdateMouseInputs()
	pos : ImVec2; init(&pos, (x > -FLT_MAX) ? ImFloor(x) : x, (y > -FLT_MAX) ? ImFloor(y) : y)

	// Filter duplicate
	latest_event : ^ImGuiInputEvent = FindLatestInputEvent(&g, ImGuiInputEventType.ImGuiInputEventType_MousePos)
	latest_pos : ImVec2 = latest_event ? ImVec2(latest_event.MousePos.PosX, latest_event.MousePos.PosY) : g.IO.MousePos
	if latest_pos.x == pos.x && latest_pos.y == pos.y { return }

	e : ImGuiInputEvent
	e.Type = ImGuiInputEventType.ImGuiInputEventType_MousePos
	e.Source = ImGuiInputSource.ImGuiInputEventType_Mouse
	e.EventId = post_incr(&g.InputEventsNextEventId)
	e.MousePos.PosX = pos.x
	e.MousePos.PosY = pos.y
	e.MousePos.MouseSource = g.InputEventsNextMouseSource
	push_back(&g.InputEventsQueue, e)
}

// Queue a mouse button change
ImGuiIO_AddMouseButtonEvent :: proc(this : ^ImGuiIO, mouse_button : i32, down : bool)
{
	IM_ASSERT(this.Ctx != nil)
	g : ^ImGuiContext = this.Ctx
	IM_ASSERT(mouse_button >= 0 && mouse_button < ImGuiMouseButton_.ImGuiMouseButton_COUNT)
	if !this.AppAcceptingEvents { return }

	// On MacOS X: Convert Ctrl(Super)+Left click into Right-click: handle held button.
	if this.ConfigMacOSXBehaviors && mouse_button == 0 && this.MouseCtrlLeftAsRightClick {
		// Order of both statements matterns: this event will still release mouse button 1
		mouse_button = 1
		if !down { this.MouseCtrlLeftAsRightClick = false }
	}

	// Filter duplicate
	latest_event : ^ImGuiInputEvent = FindLatestInputEvent(&g, ImGuiInputEventType.ImGuiInputEventType_MouseButton, cast(i32) mouse_button)
	latest_button_down : bool = latest_event ? latest_event.MouseButton.Down : g.IO.MouseDown[mouse_button]
	if latest_button_down == down { return }

	// On MacOS X: Convert Ctrl(Super)+Left click into Right-click.
	// - Note that this is actual physical Ctrl which is ImGuiMod_Super for us.
	// - At this point we want from !down to down, so this is handling the initial press.
	if this.ConfigMacOSXBehaviors && mouse_button == 0 && down {
		latest_super_event : ^ImGuiInputEvent = FindLatestInputEvent(&g, ImGuiInputEventType.ImGuiInputEventType_Key, cast(i32) ImGuiKey.ImGuiMod_Super)
		if latest_super_event ? latest_super_event.Key.Down : g.IO.KeySuper {
			IMGUI_DEBUG_LOG_IO("[io] Super+Left Click aliased into Right Click\n")
			this.MouseCtrlLeftAsRightClick = true
			AddMouseButtonEvent(1, true); // This is just quicker to write that passing through, as we need to filter duplicate again.
			return
		}
	}

	e : ImGuiInputEvent
	e.Type = ImGuiInputEventType.ImGuiInputEventType_MouseButton
	e.Source = ImGuiInputSource.ImGuiInputEventType_Mouse
	e.EventId = post_incr(&g.InputEventsNextEventId)
	e.MouseButton.Button = mouse_button
	e.MouseButton.Down = down
	e.MouseButton.MouseSource = g.InputEventsNextMouseSource
	push_back(&g.InputEventsQueue, e)
}

// Queue a mouse wheel update. wheel_y<0: scroll down, wheel_y>0: scroll up, wheel_x<0: scroll right, wheel_x>0: scroll left.
// Queue a mouse wheel event (some mouse/API may only have a Y component)
ImGuiIO_AddMouseWheelEvent :: proc(this : ^ImGuiIO, wheel_x : f32, wheel_y : f32)
{
	IM_ASSERT(this.Ctx != nil)
	g : ^ImGuiContext = this.Ctx

	// Filter duplicate (unlike most events, wheel values are relative and easy to filter)
	if !this.AppAcceptingEvents || (wheel_x == 0.0 && wheel_y == 0.0) { return }

	e : ImGuiInputEvent
	e.Type = ImGuiInputEventType.ImGuiInputEventType_MouseWheel
	e.Source = ImGuiInputSource.ImGuiInputEventType_Mouse
	e.EventId = post_incr(&g.InputEventsNextEventId)
	e.MouseWheel.WheelX = wheel_x
	e.MouseWheel.WheelY = wheel_y
	e.MouseWheel.MouseSource = g.InputEventsNextMouseSource
	push_back(&g.InputEventsQueue, e)
}

// Queue a mouse source change (Mouse/TouchScreen/Pen)
// This is not a real event, the data is latched in order to be stored in actual Mouse events.
// This is so that duplicate events (e.g. Windows sending extraneous WM_MOUSEMOVE) gets filtered and are not leading to actual source changes.
ImGuiIO_AddMouseSourceEvent :: proc(this : ^ImGuiIO, source : ImGuiMouseSource)
{
	IM_ASSERT(this.Ctx != nil)
	g : ^ImGuiContext = this.Ctx
	g.InputEventsNextMouseSource = source
}

// Queue a mouse hovered viewport. Requires backend to set ImGuiBackendFlags_HasMouseHoveredViewport to call this (for multi-viewport support).
ImGuiIO_AddMouseViewportEvent :: proc(this : ^ImGuiIO, viewport_id : ImGuiID)
{
	IM_ASSERT(this.Ctx != nil)
	g : ^ImGuiContext = this.Ctx
	//IM_ASSERT(g.IO.BackendFlags & ImGuiBackendFlags_HasMouseHoveredViewport);
	if !this.AppAcceptingEvents { return }

	// Filter duplicate
	latest_event : ^ImGuiInputEvent = FindLatestInputEvent(&g, ImGuiInputEventType.ImGuiInputEventType_MouseViewport)
	latest_viewport_id : ImGuiID = latest_event ? latest_event.MouseViewport.HoveredViewportID : g.IO.MouseHoveredViewport
	if latest_viewport_id == viewport_id { return }

	e : ImGuiInputEvent
	e.Type = ImGuiInputEventType.ImGuiInputEventType_MouseViewport
	e.Source = ImGuiInputSource.ImGuiInputEventType_Mouse
	e.MouseViewport.HoveredViewportID = viewport_id
	push_back(&g.InputEventsQueue, e)
}

// Queue a gain/loss of focus for the application (generally based on OS/platform focus of your window)
ImGuiIO_AddFocusEvent :: proc(this : ^ImGuiIO, focused : bool)
{
	IM_ASSERT(this.Ctx != nil)
	g : ^ImGuiContext = this.Ctx

	// Filter duplicate
	latest_event : ^ImGuiInputEvent = FindLatestInputEvent(&g, ImGuiInputEventType.ImGuiInputEventType_Focus)
	latest_focused : bool = latest_event ? latest_event.AppFocused.Focused : !g.IO.AppFocusLost
	if latest_focused == focused || (this.ConfigDebugIgnoreFocusLoss && !focused) { return }

	e : ImGuiInputEvent
	e.Type = ImGuiInputEventType.ImGuiInputEventType_Focus
	e.EventId = post_incr(&g.InputEventsNextEventId)
	e.AppFocused.Focused = focused
	push_back(&g.InputEventsQueue, e)
}

ImGuiPlatformIO_init :: proc(this : ^ImGuiPlatformIO)
{
	// Most fields are initialized with zero
	memset(this, 0, size_of(this))
	this.Platform_LocaleDecimalPoint = '.'
}

//-----------------------------------------------------------------------------
// [SECTION] MISC HELPERS/UTILITIES (Geometry functions)
//-----------------------------------------------------------------------------

ImBezierCubicClosestPoint :: proc(p1 : ^ImVec2, p2 : ^ImVec2, p3 : ^ImVec2, p4 : ^ImVec2, p : ^ImVec2, num_segments : i32) -> ImVec2
{
	IM_ASSERT(num_segments > 0); // Use ImBezierCubicClosestPointCasteljau()
	p_last : ImVec2 = p1
	p_closest : ImVec2
	p_closest_dist2 : f32 = FLT_MAX
	t_step : f32 = 1.0 / cast(f32) num_segments
	for i_step : i32 = 1; i_step <= num_segments; post_incr(&i_step) {
		p_current : ImVec2 = ImBezierCubicCalc(p1, p2, p3, p4, t_step * i_step)
		p_line : ImVec2 = ImLineClosestPoint(p_last, p_current, p)
		dist2 : f32 = ImLengthSqr(p - p_line)
		if dist2 < p_closest_dist2 {
			p_closest = p_line
			p_closest_dist2 = dist2
		}
		p_last = p_current
	}

	return p_closest
}

// Closely mimics PathBezierToCasteljau() in imgui_draw.cpp
ImBezierCubicClosestPointCasteljauStep :: proc(p : ^ImVec2, p_closest : ^ImVec2, p_last : ^ImVec2, p_closest_dist2 : ^f32, x1 : f32, y1 : f32, x2 : f32, y2 : f32, x3 : f32, y3 : f32, x4 : f32, y4 : f32, tess_tol : f32, level : i32)
{
	dx : f32 = x4 - x1
	dy : f32 = y4 - y1
	d2 : f32 = ((x2 - x4) * dy - (y2 - y4) * dx)
	d3 : f32 = ((x3 - x4) * dy - (y3 - y4) * dx)
	d2 = (d2 >= 0) ? d2 : -d2
	d3 = (d3 >= 0) ? d3 : -d3
	if (d2 + d3) * (d2 + d3) < tess_tol * (dx * dx + dy * dy) {
		p_current : ImVec2; init(&p_current, x4, y4)
		p_line : ImVec2 = ImLineClosestPoint(p_last, p_current, p)
		dist2 : f32 = ImLengthSqr(p - p_line)
		if dist2 < p_closest_dist2 {
			p_closest = p_line
			p_closest_dist2 = dist2
		}
		p_last = p_current
	}
	else if level < 10 {
		x12 : f32 = (x1 + x2) * 0.5; y12 : f32 = (y1 + y2) * 0.5
		x23 : f32 = (x2 + x3) * 0.5; y23 : f32 = (y2 + y3) * 0.5
		x34 : f32 = (x3 + x4) * 0.5; y34 : f32 = (y3 + y4) * 0.5
		x123 : f32 = (x12 + x23) * 0.5; y123 : f32 = (y12 + y23) * 0.5
		x234 : f32 = (x23 + x34) * 0.5; y234 : f32 = (y23 + y34) * 0.5
		x1234 : f32 = (x123 + x234) * 0.5; y1234 : f32 = (y123 + y234) * 0.5
		ImBezierCubicClosestPointCasteljauStep(p, p_closest, p_last, p_closest_dist2, x1, y1, x12, y12, x123, y123, x1234, y1234, tess_tol, level + 1)
		ImBezierCubicClosestPointCasteljauStep(p, p_closest, p_last, p_closest_dist2, x1234, y1234, x234, y234, x34, y34, x4, y4, tess_tol, level + 1)
	}
}

// For curves with explicit number of segments
// tess_tol is generally the same value you would find in ImGui::GetStyle().CurveTessellationTol
// Because those ImXXX functions are lower-level than ImGui:: we cannot access this value automatically.
ImBezierCubicClosestPointCasteljau :: proc(p1 : ^ImVec2, p2 : ^ImVec2, p3 : ^ImVec2, p4 : ^ImVec2, p : ^ImVec2, tess_tol : f32) -> ImVec2
{
	IM_ASSERT(tess_tol > 0.0)
	p_last : ImVec2 = p1
	p_closest : ImVec2
	p_closest_dist2 : f32 = FLT_MAX
	ImBezierCubicClosestPointCasteljauStep(p, p_closest, p_last, p_closest_dist2, p1.x, p1.y, p2.x, p2.y, p3.x, p3.y, p4.x, p4.y, tess_tol, 0)
	return p_closest
}

ImLineClosestPoint :: proc(a : ^ImVec2, b : ^ImVec2, p : ^ImVec2) -> ImVec2
{
	ap : ImVec2 = p - a
	ab_dir : ImVec2 = b - a
	dot : f32 = ap.x * ab_dir.x + ap.y * ab_dir.y
	if dot < 0.0 { return a }
	ab_len_sqr : f32 = ab_dir.x * ab_dir.x + ab_dir.y * ab_dir.y
	if dot > ab_len_sqr { return b }
	return a + ab_dir * dot / ab_len_sqr
}

ImTriangleContainsPoint :: proc(a : ^ImVec2, b : ^ImVec2, c : ^ImVec2, p : ^ImVec2) -> bool
{
	b1 : bool = ((p.x - b.x) * (a.y - b.y) - (p.y - b.y) * (a.x - b.x)) < 0.0
	b2 : bool = ((p.x - c.x) * (b.y - c.y) - (p.y - c.y) * (b.x - c.x)) < 0.0
	b3 : bool = ((p.x - a.x) * (c.y - a.y) - (p.y - a.y) * (c.x - a.x)) < 0.0
	return ((b1 == b2) && (b2 == b3))
}

ImTriangleBarycentricCoords :: proc(a : ^ImVec2, b : ^ImVec2, c : ^ImVec2, p : ^ImVec2, out_u : ^f32, out_v : ^f32, out_w : ^f32)
{
	v0 : ImVec2 = b - a
	v1 : ImVec2 = c - a
	v2 : ImVec2 = p - a
	denom : f32 = v0.x * v1.y - v1.x * v0.y
	out_v = (v2.x * v1.y - v1.x * v2.y) / denom
	out_w = (v0.x * v2.y - v2.x * v0.y) / denom
	out_u = 1.0 - out_v - out_w
}

ImTriangleClosestPoint :: proc(a : ^ImVec2, b : ^ImVec2, c : ^ImVec2, p : ^ImVec2) -> ImVec2
{
	proj_ab : ImVec2 = ImLineClosestPoint(a, b, p)
	proj_bc : ImVec2 = ImLineClosestPoint(b, c, p)
	proj_ca : ImVec2 = ImLineClosestPoint(c, a, p)
	dist2_ab : f32 = ImLengthSqr(p - proj_ab)
	dist2_bc : f32 = ImLengthSqr(p - proj_bc)
	dist2_ca : f32 = ImLengthSqr(p - proj_ca)
	m : f32 = ImMin(dist2_ab, ImMin(dist2_bc, dist2_ca))
	if m == dist2_ab { return proj_ab }
	if m == dist2_bc { return proj_bc }
	return proj_ca
}

// Helpers: String
//-----------------------------------------------------------------------------
// [SECTION] MISC HELPERS/UTILITIES (String, Format, Hash functions)
//-----------------------------------------------------------------------------

// Consider using _stricmp/_strnicmp under Windows or strcasecmp/strncasecmp. We don't actually use either ImStricmp/ImStrnicmp in the codebase any more.
ImStricmp :: proc(str1 : ^u8, str2 : ^u8) -> i32
{
	d : i32
	for {
		d = ImToUpper(str2^) - ImToUpper(str1^)
		if !(d == 0 && str1^) { break }
		post_incr(&str1); post_incr(&str2)
	}

	return d
}

// Case insensitive compare.
ImStrnicmp :: proc(str1 : ^u8, str2 : ^u8, count : uint) -> i32
{
	d : i32 = 0
	for count > 0 {
		d = ImToUpper(str2^) - ImToUpper(str1^)
		if !(d == 0 && str1^) { break }
		post_incr(&str1); post_incr(&str2); post_decr(&count)
	}

	return d
}

// Case insensitive compare to a certain count.
ImStrncpy :: proc(dst : ^u8, src : ^u8, count : uint)
{
	if count < 1 { return }
	if count > 1 { strncpy(dst, src, count - 1) }
	dst[count - 1] = 0
}

// Copy to a certain count and always zero terminate (strncpy doesn't).
ImStrdup :: proc(str : ^u8) -> ^u8
{
	len : uint = strlen(str)
	buf : rawptr = IM_ALLOC(len + 1)
	return cast(^u8) memcpy(buf, cast(rawptr) str, len + 1)
}

// Duplicate a string.
ImStrdupcpy :: proc(dst : ^u8, p_dst_size : ^uint, src : ^u8) -> ^u8
{
	dst_buf_size : uint = p_dst_size ? p_dst_size^ : strlen(dst) + 1
	src_size : uint = strlen(src) + 1
	if dst_buf_size < src_size {
		IM_FREE(dst)
		dst = cast(^u8) IM_ALLOC(src_size)
		if p_dst_size { p_dst_size^ = src_size }
	}
	return cast(^u8) memcpy(dst, cast(rawptr) src, src_size)
}

// Copy in provided buffer, recreate buffer if needed.
ImStrchrRange :: proc(str : ^u8, str_end : ^u8, c : u8) -> ^u8
{
	p : ^u8 = cast(^u8) memchr(str, cast(i32) c, str_end - str)
	return p
}

// Find first non-blank character.
ImStrlenW :: proc(str : ^ImWchar) -> i32
{
	//return (int)wcslen((const wchar_t*)str);  // FIXME-OPT: Could use this when wchar_t are 16-bit
	n : i32 = 0
	for post_incr(&str)^ { post_incr(&n) }

	return n
}

// Find first occurrence of 'c' in string range.
// Find end-of-line. Return pointer will point to either first \n, either str_end.
ImStreolRange :: proc(str : ^u8, str_end : ^u8) -> ^u8
{
	p : ^u8 = cast(^u8) memchr(str, '\n', str_end - str)
	return p ? p : str_end
}

// Computer string length (ImWchar string)
// find beginning-of-line
ImStrbol :: proc(buf_mid_line : ^u8, buf_begin : ^u8) -> ^u8
{
	for buf_mid_line > buf_begin && buf_mid_line[-1] != '\n' { post_decr(&buf_mid_line) }

	return buf_mid_line
}

// End end-of-line
ImStristr :: proc(haystack : ^u8, haystack_end : ^u8, needle : ^u8, needle_end : ^u8) -> ^u8
{
	if !needle_end { needle_end = needle + strlen(needle) }

	un0 : u8 = cast(u8) ImToUpper(needle^)
	for (!haystack_end && haystack^) || (haystack_end && haystack < haystack_end) {
		if ImToUpper(haystack^) == un0 {
			b : ^u8 = needle + 1
			for a : ^u8 = haystack + 1; b < needle_end; a, b = a + 1, b + 1 { if ImToUpper(a^) != ImToUpper(b^) { break } }

			if b == needle_end { return haystack }
		}
		post_incr(&haystack)
	}

	return nil
}

// Find a substring in a string range.
// Trim str by offsetting contents when there's leading data + writing a \0 at the trailing position. We use this in situation where the cost is negligible.
ImStrTrimBlanks :: proc(buf : ^u8)
{
	p : ^u8 = buf
	for p[0] == ' ' || p[0] == '\t' { post_incr(&p) }

	p_start : ^u8 = p
	for p^ != 0 { post_incr(&p) }

	for p > p_start && (p[-1] == ' ' || p[-1] == '\t') { post_decr(&p) }

	if p_start != buf {
		// Copy memory if we had leading blanksmemmove(buf, p_start, p - p_start)
	}
	buf[p - p_start] = 0; // Zero terminate
}

// Remove leading and trailing blanks from a buffer.
ImStrSkipBlank :: proc(str : ^u8) -> ^u8
{
	for str[0] == ' ' || str[0] == '\t' { post_incr(&str) }

	return str
}

// A) MSVC version appears to return -1 on overflow, whereas glibc appears to return total count (which may be >= buf_size).
// Ideally we would test for only one of those limits at runtime depending on the behavior the vsnprintf(), but trying to deduct it at compile time sounds like a pandora can of worm.
// B) When buf==NULL vsnprintf() will return the output size.
when ! IMGUI_DISABLE_DEFAULT_FORMAT_FUNCTIONS {

// We support stb_sprintf which is much faster (see: https://github.com/nothings/stb/blob/master/stb_sprintf.h)
// You may set IMGUI_USE_STB_SPRINTF to use our default wrapper, or set IMGUI_DISABLE_DEFAULT_FORMAT_FUNCTIONS
// and setup the wrapper yourself. (FIXME-OPT: Some of our high-level operations such as ImGuiTextBuffer::appendfv() are
// designed using two-passes worst case, which probably could be improved using the stbsp_vsprintfcb() function.)
when IMGUI_USE_STB_SPRINTF {
STB_SPRINTF_IMPLEMENTATION :: true
//#include "stb_sprintf.h"
} // preproc endif// #ifdef IMGUI_USE_STB_SPRINTF

vsnprintf :: proc(s : ^u8, n : int, format : cstring, args : ..[]any)
{
	fmt.bprintf(slice.from_ptr(transmute(^byte)s, n), format, ..args)
}

// Helpers: Formatting
ImFormatString :: proc(buf : ^u8, buf_size : uint, fmt : ^u8, args : ..[]any) -> i32
{
	args : []any
	va_start(args, fmt)
	when defined ( IMGUI_USE_STB_SPRINTF ) {
	w : i32 = stbsp_vsnprintf(buf, cast(i32) buf_size, fmt, args)
	} else { // preproc else
	w : i32 = vsnprintf(buf, buf_size, fmt, args)
	} // preproc endif
	va_end(args)
	if buf == nil { return w }
	if w == -1 || w >= cast(i32) buf_size { w = cast(i32) buf_size - 1 }
	buf[w] = 0
	return w
}

ImFormatStringV :: proc(buf : ^u8, buf_size : uint, fmt : ^u8, args : []any) -> i32
{
	when defined ( IMGUI_USE_STB_SPRINTF ) {
	w : i32 = stbsp_vsnprintf(buf, cast(i32) buf_size, fmt, args)
	} else { // preproc else
	w : i32 = vsnprintf(buf, buf_size, fmt, args)
	} // preproc endif
	if buf == nil { return w }
	if w == -1 || w >= cast(i32) buf_size { w = cast(i32) buf_size - 1 }
	buf[w] = 0
	return w
}
} // preproc endif// #ifdef IMGUI_DISABLE_DEFAULT_FORMAT_FUNCTIONS

ImFormatStringToTempBuffer :: proc(out_buf : ^^u8, out_buf_end : ^^u8, fmt : ^u8, args : ..[]any)
{
	args : []any
	va_start(args, fmt)
	ImFormatStringToTempBufferV(out_buf, out_buf_end, fmt, args)
	va_end(args)
}

// FIXME: Should rework API toward allowing multiple in-flight temp buffers (easier and safer for caller)
// by making the caller acquire a temp buffer token, with either explicit or destructor release, e.g.
//  ImGuiTempBufferToken token;
//  ImFormatStringToTempBuffer(token, ...);
ImFormatStringToTempBufferV :: proc(out_buf : ^^u8, out_buf_end : ^^u8, fmt : ^u8, args : []any)
{
	g : ^ImGuiContext = GImGui
	if fmt[0] == '%' && fmt[1] == 's' && fmt[2] == 0 {
		buf : ^u8 = va_arg(args, ^u8); // Skip formatting when using "%s"
		if buf == nil { buf = "(null)" }
		out_buf^ = buf
		if out_buf_end { out_buf_end^ = buf + strlen(buf) }
	}
	else if fmt[0] == '%' && fmt[1] == '.' && fmt[2] == '*' && fmt[3] == 's' && fmt[4] == 0 {
		buf_len : i32 = va_arg(args, i32); // Skip formatting when using "%.*s"
		buf : ^u8 = va_arg(args, ^u8)
		if buf == nil {
			buf = "(null)"
			buf_len = ImMin(buf_len, 6)
		}
		out_buf^ = buf
		out_buf_end^ = buf + buf_len; // Disallow not passing 'out_buf_end' here. User is expected to use it.
	}
	else {
		buf_len : i32 = ImFormatStringV(g.TempBuffer.Data, g.TempBuffer.Size, fmt, args)
		out_buf^ = g.TempBuffer.Data
		if out_buf_end { out_buf_end^ = g.TempBuffer.Data + buf_len }
	}
}

when ! IMGUI_ENABLE_SSE4_2_CRC {
// CRC32 needs a 1KB lookup table (not cache friendly)
// Although the code to generate the table is simple and shorter than the table itself, using a const table allows us to easily:
// - avoid an unnecessary branch/memory tap, - keep the ImHashXXX functions usable by static constructors, - make it thread-safe.
GCrc32LookupTable : [256]ImU32 = {
	// Legacy CRC32-adler table used pre 1.91.6 (before 2024/11/27). Only use if you cannot afford invalidating old .ini data.
	0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA, 0x076DC419, 0x706AF48F, 0xE963A535, 0x9E6495A3, 0x0EDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988, 0x09B64C2B, 0x7EB17CBD, 0xE7B82D07, 0x90BF1D91,
	0x1DB71064, 0x6AB020F2, 0xF3B97148, 0x84BE41DE, 0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7, 0x136C9856, 0x646BA8C0, 0xFD62F97A, 0x8A65C9EC, 0x14015C4F, 0x63066CD9, 0xFA0F3D63, 0x8D080DF5,
	0x3B6E20C8, 0x4C69105E, 0xD56041E4, 0xA2677172, 0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B, 0x35B5A8FA, 0x42B2986C, 0xDBBBC9D6, 0xACBCF940, 0x32D86CE3, 0x45DF5C75, 0xDCD60DCF, 0xABD13D59,
	0x26D930AC, 0x51DE003A, 0xC8D75180, 0xBFD06116, 0x21B4F4B5, 0x56B3C423, 0xCFBA9599, 0xB8BDA50F, 0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924, 0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D,
	0x76DC4190, 0x01DB7106, 0x98D220BC, 0xEFD5102A, 0x71B18589, 0x06B6B51F, 0x9FBFE4A5, 0xE8B8D433, 0x7807C9A2, 0x0F00F934, 0x9609A88E, 0xE10E9818, 0x7F6A0DBB, 0x086D3D2D, 0x91646C97, 0xE6635C01,
	0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E, 0x6C0695ED, 0x1B01A57B, 0x8208F4C1, 0xF50FC457, 0x65B0D9C6, 0x12B7E950, 0x8BBEB8EA, 0xFCB9887C, 0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3, 0xFBD44C65,
	0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2, 0x4ADFA541, 0x3DD895D7, 0xA4D1C46D, 0xD3D6F4FB, 0x4369E96A, 0x346ED9FC, 0xAD678846, 0xDA60B8D0, 0x44042D73, 0x33031DE5, 0xAA0A4C5F, 0xDD0D7CC9,
	0x5005713C, 0x270241AA, 0xBE0B1010, 0xC90C2086, 0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F, 0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4, 0x59B33D17, 0x2EB40D81, 0xB7BD5C3B, 0xC0BA6CAD,
	0xEDB88320, 0x9ABFB3B6, 0x03B6E20C, 0x74B1D29A, 0xEAD54739, 0x9DD277AF, 0x04DB2615, 0x73DC1683, 0xE3630B12, 0x94643B84, 0x0D6D6A3E, 0x7A6A5AA8, 0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1,
	0xF00F9344, 0x8708A3D2, 0x1E01F268, 0x6906C2FE, 0xF762575D, 0x806567CB, 0x196C3671, 0x6E6B06E7, 0xFED41B76, 0x89D32BE0, 0x10DA7A5A, 0x67DD4ACC, 0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5,
	0xD6D6A3E8, 0xA1D1937E, 0x38D8C2C4, 0x4FDFF252, 0xD1BB67F1, 0xA6BC5767, 0x3FB506DD, 0x48B2364B, 0xD80D2BDA, 0xAF0A1B4C, 0x36034AF6, 0x41047A60, 0xDF60EFC3, 0xA867DF55, 0x316E8EEF, 0x4669BE79,
	0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236, 0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F, 0xC5BA3BBE, 0xB2BD0B28, 0x2BB45A92, 0x5CB36A04, 0xC2D7FFA7, 0xB5D0CF31, 0x2CD99E8B, 0x5BDEAE1D,
	0x9B64C2B0, 0xEC63F226, 0x756AA39C, 0x026D930A, 0x9C0906A9, 0xEB0E363F, 0x72076785, 0x05005713, 0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38, 0x92D28E9B, 0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21,
	0x86D3D2D4, 0xF1D4E242, 0x68DDB3F8, 0x1FDA836E, 0x81BE16CD, 0xF6B9265B, 0x6FB077E1, 0x18B74777, 0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C, 0x8F659EFF, 0xF862AE69, 0x616BFFD3, 0x166CCF45,
	0xA00AE278, 0xD70DD2EE, 0x4E048354, 0x3903B3C2, 0xA7672661, 0xD06016F7, 0x4969474D, 0x3E6E77DB, 0xAED16A4A, 0xD9D65ADC, 0x40DF0B66, 0x37D83BF0, 0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9,
	0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6, 0xBAD03605, 0xCDD70693, 0x54DE5729, 0x23D967BF, 0xB3667A2E, 0xC4614AB8, 0x5D681B02, 0x2A6F2B94, 0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B, 0x2D02EF8D,
	} when defined ( IMGUI_USE_LEGACY_CRC32_ADLER ) else { // preproc else
	// CRC32c table compatible with SSE 4.2 instructions
	0x00000000, 0xF26B8303, 0xE13B70F7, 0x1350F3F4, 0xC79A971F, 0x35F1141C, 0x26A1E7E8, 0xD4CA64EB, 0x8AD958CF, 0x78B2DBCC, 0x6BE22838, 0x9989AB3B, 0x4D43CFD0, 0xBF284CD3, 0xAC78BF27, 0x5E133C24,
	0x105EC76F, 0xE235446C, 0xF165B798, 0x030E349B, 0xD7C45070, 0x25AFD373, 0x36FF2087, 0xC494A384, 0x9A879FA0, 0x68EC1CA3, 0x7BBCEF57, 0x89D76C54, 0x5D1D08BF, 0xAF768BBC, 0xBC267848, 0x4E4DFB4B,
	0x20BD8EDE, 0xD2D60DDD, 0xC186FE29, 0x33ED7D2A, 0xE72719C1, 0x154C9AC2, 0x061C6936, 0xF477EA35, 0xAA64D611, 0x580F5512, 0x4B5FA6E6, 0xB93425E5, 0x6DFE410E, 0x9F95C20D, 0x8CC531F9, 0x7EAEB2FA,
	0x30E349B1, 0xC288CAB2, 0xD1D83946, 0x23B3BA45, 0xF779DEAE, 0x05125DAD, 0x1642AE59, 0xE4292D5A, 0xBA3A117E, 0x4851927D, 0x5B016189, 0xA96AE28A, 0x7DA08661, 0x8FCB0562, 0x9C9BF696, 0x6EF07595,
	0x417B1DBC, 0xB3109EBF, 0xA0406D4B, 0x522BEE48, 0x86E18AA3, 0x748A09A0, 0x67DAFA54, 0x95B17957, 0xCBA24573, 0x39C9C670, 0x2A993584, 0xD8F2B687, 0x0C38D26C, 0xFE53516F, 0xED03A29B, 0x1F682198,
	0x5125DAD3, 0xA34E59D0, 0xB01EAA24, 0x42752927, 0x96BF4DCC, 0x64D4CECF, 0x77843D3B, 0x85EFBE38, 0xDBFC821C, 0x2997011F, 0x3AC7F2EB, 0xC8AC71E8, 0x1C661503, 0xEE0D9600, 0xFD5D65F4, 0x0F36E6F7,
	0x61C69362, 0x93AD1061, 0x80FDE395, 0x72966096, 0xA65C047D, 0x5437877E, 0x4767748A, 0xB50CF789, 0xEB1FCBAD, 0x197448AE, 0x0A24BB5A, 0xF84F3859, 0x2C855CB2, 0xDEEEDFB1, 0xCDBE2C45, 0x3FD5AF46,
	0x7198540D, 0x83F3D70E, 0x90A324FA, 0x62C8A7F9, 0xB602C312, 0x44694011, 0x5739B3E5, 0xA55230E6, 0xFB410CC2, 0x092A8FC1, 0x1A7A7C35, 0xE811FF36, 0x3CDB9BDD, 0xCEB018DE, 0xDDE0EB2A, 0x2F8B6829,
	0x82F63B78, 0x709DB87B, 0x63CD4B8F, 0x91A6C88C, 0x456CAC67, 0xB7072F64, 0xA457DC90, 0x563C5F93, 0x082F63B7, 0xFA44E0B4, 0xE9141340, 0x1B7F9043, 0xCFB5F4A8, 0x3DDE77AB, 0x2E8E845F, 0xDCE5075C,
	0x92A8FC17, 0x60C37F14, 0x73938CE0, 0x81F80FE3, 0x55326B08, 0xA759E80B, 0xB4091BFF, 0x466298FC, 0x1871A4D8, 0xEA1A27DB, 0xF94AD42F, 0x0B21572C, 0xDFEB33C7, 0x2D80B0C4, 0x3ED04330, 0xCCBBC033,
	0xA24BB5A6, 0x502036A5, 0x4370C551, 0xB11B4652, 0x65D122B9, 0x97BAA1BA, 0x84EA524E, 0x7681D14D, 0x2892ED69, 0xDAF96E6A, 0xC9A99D9E, 0x3BC21E9D, 0xEF087A76, 0x1D63F975, 0x0E330A81, 0xFC588982,
	0xB21572C9, 0x407EF1CA, 0x532E023E, 0xA145813D, 0x758FE5D6, 0x87E466D5, 0x94B49521, 0x66DF1622, 0x38CC2A06, 0xCAA7A905, 0xD9F75AF1, 0x2B9CD9F2, 0xFF56BD19, 0x0D3D3E1A, 0x1E6DCDEE, 0xEC064EED,
	0xC38D26C4, 0x31E6A5C7, 0x22B65633, 0xD0DDD530, 0x0417B1DB, 0xF67C32D8, 0xE52CC12C, 0x1747422F, 0x49547E0B, 0xBB3FFD08, 0xA86F0EFC, 0x5A048DFF, 0x8ECEE914, 0x7CA56A17, 0x6FF599E3, 0x9D9E1AE0,
	0xD3D3E1AB, 0x21B862A8, 0x32E8915C, 0xC083125F, 0x144976B4, 0xE622F5B7, 0xF5720643, 0x07198540, 0x590AB964, 0xAB613A67, 0xB831C993, 0x4A5A4A90, 0x9E902E7B, 0x6CFBAD78, 0x7FAB5E8C, 0x8DC0DD8F,
	0xE330A81A, 0x115B2B19, 0x020BD8ED, 0xF0605BEE, 0x24AA3F05, 0xD6C1BC06, 0xC5914FF2, 0x37FACCF1, 0x69E9F0D5, 0x9B8273D6, 0x88D28022, 0x7AB90321, 0xAE7367CA, 0x5C18E4C9, 0x4F48173D, 0xBD23943E,
	0xF36E6F75, 0x0105EC76, 0x12551F82, 0xE03E9C81, 0x34F4F86A, 0xC69F7B69, 0xD5CF889D, 0x27A40B9E, 0x79B737BA, 0x8BDCB4B9, 0x988C474D, 0x6AE7C44E, 0xBE2DA0A5, 0x4C4623A6, 0x5F16D052, 0xAD7D5351,
	} // preproc endif
} // preproc endif

//-----------------------------------------------------------------------------
// [SECTION] Generic helpers
// Note that the ImXXX helpers functions are lower-level than ImGui functions.
// ImGui functions or the ImGui context are never called/used from other ImXXX functions.
//-----------------------------------------------------------------------------
// - Helpers: Hashing
// - Helpers: Sorting
// - Helpers: Bit manipulation
// - Helpers: String
// - Helpers: Formatting
// - Helpers: UTF-8 <> wchar conversions
// - Helpers: ImVec2/ImVec4 operators
// - Helpers: Maths
// - Helpers: Geometry
// - Helper: ImVec1
// - Helper: ImVec2ih
// - Helper: ImRect
// - Helper: ImBitArray
// - Helper: ImBitVector
// - Helper: ImSpan<>, ImSpanAllocator<>
// - Helper: ImPool<>
// - Helper: ImChunkStream<>
// - Helper: ImGuiTextIndex
// - Helper: ImGuiStorage
//-----------------------------------------------------------------------------

// Helpers: Hashing
// Known size hash
// It is ok to call ImHashData on a string with known length but the ### operator won't be supported.
// FIXME-OPT: Replace with e.g. FNV1a hash? CRC32 pretty much randomly access 1KB. Need to do proper measurements.
ImHashData :: proc(data_p : rawptr, data_size : uint, seed : ImGuiID) -> ImGuiID
{
	crc : ImU32 = !seed
	data : ^u8 = cast(^u8) data_p
	data_end : ^u8 = cast(^u8) data_p + data_size
	when ! defined ( IMGUI_ENABLE_SSE4_2_CRC ) {
	crc32_lut : ^ImU32 = GCrc32LookupTable
	for data < data_end { crc = (crc >> 8) ~ crc32_lut[(crc & 0xFF) ~ post_incr(&data)^] }

	return !crc
	} else { // preproc else
	for data + 4 <= data_end {
		crc = _mm_crc32_u32(crc, cast(^ImU32) data^)
		data += 4
	}

	for data < data_end { crc = _mm_crc32_u8(crc, post_incr(&data)^) }

	return !crc
	} // preproc endif
}

// Zero-terminated string hash, with support for ### to reset back to seed value
// We support a syntax of "label###id" where only "###id" is included in the hash, and only "label" gets displayed.
// Because this syntax is rarely used we are optimizing for the common case.
// - If we reach ### in the string we discard the hash so far and reset to the seed.
// - We don't do 'current += 2; continue;' after handling ### to keep the code smaller/faster (measured ~10% diff in Debug build)
// FIXME-OPT: Replace with e.g. FNV1a hash? CRC32 pretty much randomly access 1KB. Need to do proper measurements.
ImHashStr :: proc(data_p : ^u8, data_size : uint, seed : ImGuiID) -> ImGuiID
{
	seed = !seed
	crc : ImU32 = seed
	data : ^u8 = cast(^u8) data_p
	when ! defined ( IMGUI_ENABLE_SSE4_2_CRC ) {
	crc32_lut : ^ImU32 = GCrc32LookupTable
	} // preproc endif
	if data_size != 0 {
		for post_decr(&data_size) != 0 {
			c : u8 = post_incr(&data)^
			if c == '#' && data_size >= 2 && data[0] == '#' && data[1] == '#' { crc = seed }
			when ! defined ( IMGUI_ENABLE_SSE4_2_CRC ) {
			crc = (crc >> 8) ~ crc32_lut[(crc & 0xFF) ~ c]
			} else { // preproc else
			crc = _mm_crc32_u8(crc, c)
			} // preproc endif
		}
	}
	else {
		for {
			c : u8 = post_incr(&data)^
			if !(c) { break }

			if c == '#' && data[0] == '#' && data[1] == '#' { crc = seed }
			when ! defined ( IMGUI_ENABLE_SSE4_2_CRC ) {
			crc = (crc >> 8) ~ crc32_lut[(crc & 0xFF) ~ c]
			} else { // preproc else
			crc = _mm_crc32_u8(crc, c)
			} // preproc endif
		}
	}
	return !crc
}

//-----------------------------------------------------------------------------
// [SECTION] MISC HELPERS/UTILITIES (File functions)
//-----------------------------------------------------------------------------

// Default file functions
when ! IMGUI_DISABLE_DEFAULT_FILE_FUNCTIONS {

ImFileOpen :: proc(filename : ^u8, mode : ^u8) -> ImFileHandle
{
	when defined ( _WIN32 ) && ! defined ( IMGUI_DISABLE_WIN32_FUNCTIONS ) && ( defined ( __MINGW32__ ) || ( ! defined ( __CYGWIN__ ) && ! defined ( __GNUC__ ) ) ) {
	// We need a fopen() wrapper because MSVC/Windows fopen doesn't handle UTF-8 filenames.
	// Previously we used ImTextCountCharsFromUtf8/ImTextStrFromUtf8 here but we now need to support ImWchar16 and ImWchar32!
	filename_wsize : i32 = MultiByteToWideChar(CP_UTF8, 0, filename, -1, nil, 0)
	mode_wsize : i32 = MultiByteToWideChar(CP_UTF8, 0, mode, -1, nil, 0)

	// Use stack buffer if possible, otherwise heap buffer. Sizes include zero terminator.
	// We don't rely on current ImGuiContext as this is implied to be a helper function which doesn't depend on it (see #7314).
	local_temp_stack : [FILENAME_MAX]wchar_t
	local_temp_heap : ImVector(wchar_t)
	if filename_wsize + mode_wsize > IM_ARRAYSIZE(local_temp_stack) { resize(&local_temp_heap, filename_wsize + mode_wsize) }
	filename_wbuf : ^wchar_t = local_temp_heap.Data ? local_temp_heap.Data : local_temp_stack
	mode_wbuf : ^wchar_t = filename_wbuf + filename_wsize
	MultiByteToWideChar(CP_UTF8, 0, filename, -1, filename_wbuf, filename_wsize)
	MultiByteToWideChar(CP_UTF8, 0, mode, -1, mode_wbuf, mode_wsize)
	return _wfopen(filename_wbuf, mode_wbuf)
	} else { // preproc else
	return fopen(filename, mode)
	} // preproc endif
}

// We should in theory be using fseeko()/ftello() with off_t and _fseeki64()/_ftelli64() with __int64, waiting for the PR that does that in a very portable pre-C++11 zero-warnings way.
ImFileClose :: proc(f : ImFileHandle) -> bool { return fclose(f) == 0 }
ImFileGetSize :: proc(f : ImFileHandle) -> ImU64
{
	off : i32 = 0;
	sz : i32 = 0;
	off = ftell(f)
	if off != -1 {
		if !fseek(f, 0, SEEK_END) {
			sz = ftell(f)
			if sz != -1 {
				if !fseek(f, off, SEEK_SET) {
					return cast(ImU64) sz
				}
			}
		}
	}
	return cast(ImU64) -1
}
ImFileRead :: proc(data : rawptr, sz : ImU64, count : ImU64, f : ImFileHandle) -> ImU64 { return fread(data, cast(uint) sz, cast(uint) count, f) }
ImFileWrite :: proc(data : rawptr, sz : ImU64, count : ImU64, f : ImFileHandle) -> ImU64 { return fwrite(data, cast(uint) sz, cast(uint) count, f) }
} // preproc endif// #ifndef IMGUI_DISABLE_DEFAULT_FILE_FUNCTIONS

// Helper: Load file content into memory
// Memory allocated with IM_ALLOC(), must be freed by user using IM_FREE() == ImGui::MemFree()
// This can't really be used with "rt" because fseek size won't match read size.
ImFileLoadToMemory :: proc(filename : ^u8, mode : ^u8, out_file_size : ^uint, padding_bytes : i32) -> rawptr
{
	IM_ASSERT(filename && mode)
	if out_file_size { out_file_size^ = 0 }

	f : ImFileHandle = ImFileOpen(filename, mode)
	if f == nil { return nil }

	file_size : uint = cast(uint) ImFileGetSize(f)
	if file_size == cast(uint) -1 {
		ImFileClose(f)
		return nil
	}

	file_data : rawptr = IM_ALLOC(file_size + padding_bytes)
	if file_data == nil {
		ImFileClose(f)
		return nil
	}
	if ImFileRead(file_data, 1, file_size, f) != file_size {
		ImFileClose(f)
		IM_FREE(file_data)
		return nil
	}
	if padding_bytes > 0 { memset(cast(rawptr) ((cast(^u8) file_data) + file_size), 0, cast(uint) padding_bytes) }

	ImFileClose(f)
	if out_file_size { out_file_size^ = file_size }

	return file_data
}

// return output UTF-8 bytes count
//-----------------------------------------------------------------------------
// [SECTION] MISC HELPERS/UTILITIES (ImText* functions)
//-----------------------------------------------------------------------------



// Convert UTF-8 to 32-bit character, process single character input.
// A nearly-branchless UTF-8 decoder, based on work of Christopher Wellons (https://github.com/skeeto/branchless-utf8).
// We handle UTF-8 decoding error by skipping forward.
ImTextCharFromUtf8 :: proc(out_char : ^u32, in_text : ^u8, in_text_end : ^u8) -> i32
{
	lengths : [32]u8 = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 3, 3, 4, 0}
	masks : [^]i32 = {0x00, 0x7f, 0x1f, 0x0f, 0x07}
	mins : [^]uint32_t = {0x400000, 0, 0x80, 0x800, 0x10000}
	shiftc : [^]i32 = {0, 18, 12, 6, 0}
	shifte : [^]i32 = {0, 6, 4, 2, 0}
	len : i32 = lengths[cast(^u8) in_text^ >> 3]
	wanted : i32 = len + (len ? 0 : 1)

	if in_text_end == nil {
		// Max length, nulls will be taken into account.
		in_text_end = in_text + wanted
	}

	// Copy at most 'len' bytes, stop copying at 0 or past in_text_end. Branch predictor does a good job here,
	// so it is fast even with excessive branching.
	s : [4]u8
	s[0] = in_text + 0 < in_text_end ? in_text[0] : 0
	s[1] = in_text + 1 < in_text_end ? in_text[1] : 0
	s[2] = in_text + 2 < in_text_end ? in_text[2] : 0
	s[3] = in_text + 3 < in_text_end ? in_text[3] : 0

	// Assume a four-byte character and load four bytes. Unused bits are shifted out.
	out_char^ = cast(uint32_t) (s[0] & masks[len]) << 18
	out_char^ |= cast(uint32_t) (s[1] & 0x3f) << 12
	out_char^ |= cast(uint32_t) (s[2] & 0x3f) << 6
	out_char^ |= cast(uint32_t) (s[3] & 0x3f) << 0
	out_char^ >>= shiftc[len]

	// Accumulate the various error conditions.
	e : i32 = 0
	e = (out_char^ < mins[len]) << 6; // non-canonical encoding
	e |= ((out_char^ >> 11) == 0x1b) << 7; // surrogate half?
	e |= (out_char^ > IM_UNICODE_CODEPOINT_MAX) << 8; // out of range?
	e |= (s[1] & 0xc0) >> 2
	e |= (s[2] & 0xc0) >> 4
	e |= (s[3]) >> 6
	e ~= 0x2a; // top two bits of each tail byte correct?
	e >>= shifte[len]

	if e {
		// No bytes are consumed when *in_text == 0 || in_text == in_text_end.
		// One byte is consumed in case of invalid first byte of in_text.
		// All available bytes (at most `len` bytes) are consumed on incomplete/invalid second to last bytes.
		// Invalid or incomplete input may consume less bytes than wanted, therefore every byte has to be inspected in s.
		wanted = ImMin(wanted, !!s[0] + !!s[1] + !!s[2] + !!s[3])
		out_char^ = IM_UNICODE_CODEPOINT_INVALID
	}

	return wanted
}

// read one character. return input UTF-8 bytes count
ImTextStrFromUtf8 :: proc(buf : ^ImWchar, buf_size : i32, in_text : ^u8, in_text_end : ^u8, in_text_remaining : ^^u8) -> i32
{
	buf_out : ^ImWchar = buf
	buf_end : ^ImWchar = buf + buf_size
	for buf_out < buf_end - 1 && (!in_text_end || in_text < in_text_end) && in_text^ {
		c : u32
		in_text += ImTextCharFromUtf8(&c, in_text, in_text_end)
		post_incr(&buf_out)^ = cast(ImWchar) c
	}

	buf_out^ = 0
	if in_text_remaining { in_text_remaining^ = in_text }
	return cast(i32) (buf_out - buf)
}

// return input UTF-8 bytes count
ImTextCountCharsFromUtf8 :: proc(in_text : ^u8, in_text_end : ^u8) -> i32
{
	char_count : i32 = 0
	for (!in_text_end || in_text < in_text_end) && in_text^ {
		c : u32
		in_text += ImTextCharFromUtf8(&c, in_text, in_text_end)
		post_incr(&char_count)
	}

	return char_count
}

// Based on stb_to_utf8() from github.com/nothings/stb/
ImTextCharToUtf8_inline :: #force_inline proc(buf : ^u8, buf_size : i32, c : u32) -> i32
{
	if c < 0x80 {
		buf[0] = cast(u8) c
		return 1
	}
	if c < 0x800 {
		if buf_size < 2 { return 0 }
		buf[0] = cast(u8) (0xc0 + (c >> 6))
		buf[1] = cast(u8) (0x80 + (c & 0x3f))
		return 2
	}
	if c < 0x10000 {
		if buf_size < 3 { return 0 }
		buf[0] = cast(u8) (0xe0 + (c >> 12))
		buf[1] = cast(u8) (0x80 + ((c >> 6) & 0x3f))
		buf[2] = cast(u8) (0x80 + (cast(c) &0x3f))
		return 3
	}
	if c <= 0x10FFFF {
		if buf_size < 4 { return 0 }
		buf[0] = cast(u8) (0xf0 + (c >> 18))
		buf[1] = cast(u8) (0x80 + ((c >> 12) & 0x3f))
		buf[2] = cast(u8) (0x80 + ((c >> 6) & 0x3f))
		buf[3] = cast(u8) (0x80 + (cast(c) &0x3f))
		return 4
	}
	// Invalid code point, the max unicode is 0x10FFFF
	return 0
}

// Helpers: UTF-8 <> wchar conversions
ImTextCharToUtf8 :: proc(out_buf : [5]u8, c : u32) -> ^u8
{
	count : i32 = ImTextCharToUtf8_inline(out_buf, 5, c)
	out_buf[count] = 0
	return out_buf
}

// return number of UTF-8 code-points (NOT bytes count)
// Not optimal but we very rarely use this function.
ImTextCountUtf8BytesFromChar_0 :: proc(in_text : ^u8, in_text_end : ^u8) -> i32
{
	unused : u32 = 0
	return ImTextCharFromUtf8(&unused, in_text, in_text_end)
}

// return number of UTF-8 code-points (NOT bytes count)
// Not optimal but we very rarely use this function.
ImTextCountUtf8BytesFromChar_1 :: #force_inline proc(c : u32) -> i32
{
	if c < 0x80 { return 1 }
	if c < 0x800 { return 2 }
	if c < 0x10000 { return 3 }
	if c <= 0x10FFFF { return 4 }
	return 3
}

// return out_buf
ImTextStrToUtf8 :: proc(out_buf : ^u8, out_buf_size : i32, in_text : ^ImWchar, in_text_end : ^ImWchar) -> i32
{
	buf_p : ^u8 = out_buf
	buf_end : ^u8 = out_buf + out_buf_size
	for buf_p < buf_end - 1 && (!in_text_end || in_text < in_text_end) && in_text^ {
		c : u32 = cast(u32) (post_incr(&in_text)^)
		if c < 0x80 { post_incr(&buf_p)^ = cast(u8) c }
		else { buf_p += ImTextCharToUtf8_inline(buf_p, cast(i32) (buf_end - buf_p - 1), c) }
	}

	buf_p^ = 0
	return cast(i32) (buf_p - out_buf)
}

// return number of bytes to express one char in UTF-8
ImTextCountUtf8BytesFromStr :: proc(in_text : ^ImWchar, in_text_end : ^ImWchar) -> i32
{
	bytes_count : i32 = 0
	for (!in_text_end || in_text < in_text_end) && in_text^ {
		c : u32 = cast(u32) (post_incr(&in_text)^)
		if c < 0x80 { post_incr(&bytes_count) }
		else { bytes_count += ImTextCountUtf8BytesFromChar(c) }
	}

	return bytes_count
}

// return number of bytes to express string in UTF-8
ImTextFindPreviousUtf8Codepoint :: proc(in_text_start : ^u8, in_text_curr : ^u8) -> ^u8
{
	for in_text_curr > in_text_start {
		post_decr(&in_text_curr)
		if (in_text_curr^ & 0xC0) != 0x80 { return in_text_curr }
	}

	return in_text_start
}

// return previous UTF-8 code-point.
ImTextCountLines :: proc(in_text : ^u8, in_text_end : ^u8) -> i32
{
	if in_text_end == nil {
		// FIXME-OPT: Not optimal approach, discourage use for now.
		in_text_end = in_text + strlen(in_text)
	}
	count : i32 = 0
	for in_text < in_text_end {
		line_end : ^u8 = cast(^u8) memchr(in_text, '\n', in_text_end - in_text)
		in_text = line_end ? line_end + 1 : in_text_end
		post_incr(&count)
	}

	return count
}



// Helpers: Color Blending
//-----------------------------------------------------------------------------
// [SECTION] MISC HELPERS/UTILITIES (Color functions)
// Note: The Convert functions are early design which are not consistent with other API.
//-----------------------------------------------------------------------------

ImAlphaBlendColors :: proc(col_a : ImU32, col_b : ImU32) -> ImU32
{
	t : f32 = ((col_b >> IM_COL32_A_SHIFT) & 0xFF) / 255.
	r : i32 = ImLerp(cast(i32) (col_a >> IM_COL32_R_SHIFT) & 0xFF, cast(i32) (col_b >> IM_COL32_R_SHIFT) & 0xFF, t)
	g : i32 = ImLerp(cast(i32) (col_a >> IM_COL32_G_SHIFT) & 0xFF, cast(i32) (col_b >> IM_COL32_G_SHIFT) & 0xFF, t)
	b : i32 = ImLerp(cast(i32) (col_a >> IM_COL32_B_SHIFT) & 0xFF, cast(i32) (col_b >> IM_COL32_B_SHIFT) & 0xFF, t)
	return IM_COL32(r, g, b, 0xFF)
}

// Color Utilities
ColorConvertU32ToFloat4 :: proc(_in : ImU32) -> ImVec4
{
	s : f32 = 1.0 / 255.0
	return ImVec4(((_in >> IM_COL32_R_SHIFT) & 0xFF) * s, ((_in >> IM_COL32_G_SHIFT) & 0xFF) * s, ((_in >> IM_COL32_B_SHIFT) & 0xFF) * s, ((_in >> IM_COL32_A_SHIFT) & 0xFF) * s)
}

ColorConvertFloat4ToU32 :: proc(_in : ^ImVec4) -> ImU32
{
	out : ImU32
	out = (cast(ImU32) IM_F32_TO_INT8_SAT(_in.x)) << IM_COL32_R_SHIFT
	out |= (cast(ImU32) IM_F32_TO_INT8_SAT(_in.y)) << IM_COL32_G_SHIFT
	out |= (cast(ImU32) IM_F32_TO_INT8_SAT(_in.z)) << IM_COL32_B_SHIFT
	out |= (cast(ImU32) IM_F32_TO_INT8_SAT(_in.w)) << IM_COL32_A_SHIFT
	return out
}

// Convert rgb floats ([0-1],[0-1],[0-1]) to hsv floats ([0-1],[0-1],[0-1]), from Foley & van Dam p592
// Optimized http://lolengine.net/blog/2013/01/13/fast-rgb-to-hsv
ColorConvertRGBtoHSV :: proc(r : f32, g : f32, b : f32, out_h : ^f32, out_s : ^f32, out_v : ^f32)
{
	K : f32 = 0.
	if g < b {
		ImSwap(g, b)
		K = -1.
	}
	if r < g {
		ImSwap(r, g)
		K = -2. / 6. - K
	}

	chroma : f32 = r - (g < b ? g : b)
	out_h^ = ImFabs(K + (g - b) / (6. * chroma + 1e-20))
	out_s^ = chroma / (r + 1e-20)
	out_v^ = r
}

// Convert hsv floats ([0-1],[0-1],[0-1]) to rgb floats ([0-1],[0-1],[0-1]), from Foley & van Dam p593
// also http://en.wikipedia.org/wiki/HSL_and_HSV
ColorConvertHSVtoRGB :: proc(h : f32, s : f32, v : f32, out_r : ^f32, out_g : ^f32, out_b : ^f32)
{
	if s == 0.0 {
		// gray
		out_b = v; out_g = out_b; out_r = out_g
		return
	}

	h = ImFmod(h, 1.0) / (60.0 / 360.0)
	i : i32 = cast(i32) h
	f : f32 = h - cast(f32) i
	p : f32 = v * (1.0 - s)
	q : f32 = v * (1.0 - s * f)
	t : f32 = v * (1.0 - s * (1.0 - f))

	switch i {
		case 0:out_r = v; out_g = t; out_b = p; break

		case 1:out_r = q; out_g = v; out_b = p; break

		case 2:out_r = p; out_g = v; out_b = t; break

		case 3:out_r = p; out_g = q; out_b = v; break

		case 4:out_r = t; out_g = p; out_b = v; break

		case 5:; fallthrough
		case:out_r = v; out_g = p; out_b = q; break
	}
}

// Helper: ImGuiStorage
//-----------------------------------------------------------------------------
// [SECTION] ImGuiStorage
// Helper: Key->value storage
//-----------------------------------------------------------------------------

// std::lower_bound but without the bullshit
ImLowerBound :: proc(in_begin : ^ImGuiStoragePair, in_end : ^ImGuiStoragePair, key : ImGuiID) -> ^ImGuiStoragePair
{
	in_p : ^ImGuiStoragePair = in_begin
	for count : uint = cast(uint) (in_end - in_p); count > 0;  {
		count2 : uint = count >> 1
		mid : ^ImGuiStoragePair = in_p + count2
		if mid.key < key {
			in_p = pre_incr(&mid)
			count -= count2 + 1
		}
		else {
			count = count2
		}
	}

	return in_p
}


PairComparerByID :: proc(lhs : rawptr, rhs : rawptr) -> i32
{
	// We can't just do a subtraction because qsort uses signed integers and subtracting our ID doesn't play well with that.
	lhs_v : ImGuiID = (cast(^ImGuiStoragePair) lhs).key
	rhs_v : ImGuiID = (cast(^ImGuiStoragePair) rhs).key
	return (lhs_v > rhs_v ? +1 : lhs_v < rhs_v ? -1 : 0)
}

// Advanced: for quicker full rebuild of a storage (instead of an incremental one), you may add all your contents and then sort once.
// For quicker full rebuild of a storage (instead of an incremental one), you may add all your contents and then sort once.
ImGuiStorage_BuildSortByKey :: proc(this : ^ImGuiStorage)
{
	ImQsort(this.Data.Data, cast(uint) this.Data.Size, size_of(ImGuiStoragePair), PairComparerByID)
}

ImGuiStorage_GetInt :: proc(this : ^ImGuiStorage, key : ImGuiID, default_val : i32) -> i32
{
	it : ^ImGuiStoragePair = ImLowerBound(transmute(^ImGuiStoragePair) this.Data.Data, transmute(^ImGuiStoragePair) this.Data.Data + this.Data.Size, key)
	if it == this.Data.Data + this.Data.Size || it.key != key { return default_val }
	return it.val_i
}

ImGuiStorage_GetBool :: proc(this : ^ImGuiStorage, key : ImGuiID, default_val : bool) -> bool
{
	return GetInt(key, default_val ? 1 : 0) != 0
}

ImGuiStorage_GetFloat :: proc(this : ^ImGuiStorage, key : ImGuiID, default_val : f32) -> f32
{
	it : ^ImGuiStoragePair = ImLowerBound(transmute(^ImGuiStoragePair) this.Data.Data, transmute(^ImGuiStoragePair) this.Data.Data + this.Data.Size, key)
	if it == this.Data.Data + this.Data.Size || it.key != key { return default_val }
	return it.val_f
}

// default_val is NULL
ImGuiStorage_GetVoidPtr :: proc(this : ^ImGuiStorage, key : ImGuiID) -> rawptr
{
	it : ^ImGuiStoragePair = ImLowerBound(transmute(^ImGuiStoragePair) this.Data.Data, transmute(^ImGuiStoragePair) this.Data.Data + this.Data.Size, key)
	if it == this.Data.Data + this.Data.Size || it.key != key { return nil }
	return it.val_p
}

// - Get***Ref() functions finds pair, insert on demand if missing, return pointer. Useful if you intend to do Get+Set.
// - References are only valid until a new value is added to the storage. Calling a Set***() function or a Get***Ref() function invalidates the pointer.
// - A typical use case where this is convenient for quick hacking (e.g. add storage during a live Edit&Continue session if you can't modify existing struct)
//      float* pvar = ImGui::GetFloatRef(key); ImGui::SliderFloat("var", pvar, 0, 100.0f); some_var += *pvar;
// References are only valid until a new value is added to the storage. Calling a Set***() function or a Get***Ref() function invalidates the pointer.
ImGuiStorage_GetIntRef :: proc(this : ^ImGuiStorage, key : ImGuiID, default_val : i32) -> ^i32
{
	it : ^ImGuiStoragePair = ImLowerBound(this.Data.Data, this.Data.Data + this.Data.Size, key)
	if it == this.Data.Data + this.Data.Size || it.key != key { it = insert(&this.Data, it, ImGuiStoragePair(key, default_val)) }
	return &it.val_i
}

ImGuiStorage_GetBoolRef :: proc(this : ^ImGuiStorage, key : ImGuiID, default_val : bool) -> ^bool
{
	return cast(^bool) GetIntRef(key, default_val ? 1 : 0)
}

ImGuiStorage_GetFloatRef :: proc(this : ^ImGuiStorage, key : ImGuiID, default_val : f32) -> ^f32
{
	it : ^ImGuiStoragePair = ImLowerBound(this.Data.Data, this.Data.Data + this.Data.Size, key)
	if it == this.Data.Data + this.Data.Size || it.key != key { it = insert(&this.Data, it, ImGuiStoragePair(key, default_val)) }
	return &it.val_f
}

ImGuiStorage_GetVoidPtrRef :: proc(this : ^ImGuiStorage, key : ImGuiID, default_val : rawptr) -> ^rawptr
{
	it : ^ImGuiStoragePair = ImLowerBound(this.Data.Data, this.Data.Data + this.Data.Size, key)
	if it == this.Data.Data + this.Data.Size || it.key != key { it = insert(&this.Data, it, ImGuiStoragePair(key, default_val)) }
	return &it.val_p
}

// FIXME-OPT: Need a way to reuse the result of lower_bound when doing GetInt()/SetInt() - not too bad because it only happens on explicit interaction (maximum one a frame)
ImGuiStorage_SetInt :: proc(this : ^ImGuiStorage, key : ImGuiID, val : i32)
{
	it : ^ImGuiStoragePair = ImLowerBound(this.Data.Data, this.Data.Data + this.Data.Size, key)
	if it == this.Data.Data + this.Data.Size || it.key != key { insert(&this.Data, it, ImGuiStoragePair(key, val)) }
	else { it.val_i = val }
}

ImGuiStorage_SetBool :: proc(this : ^ImGuiStorage, key : ImGuiID, val : bool)
{
	SetInt(key, val ? 1 : 0)
}

ImGuiStorage_SetFloat :: proc(this : ^ImGuiStorage, key : ImGuiID, val : f32)
{
	it : ^ImGuiStoragePair = ImLowerBound(this.Data.Data, this.Data.Data + this.Data.Size, key)
	if it == this.Data.Data + this.Data.Size || it.key != key { insert(&this.Data, it, ImGuiStoragePair(key, val)) }
	else { it.val_f = val }
}

ImGuiStorage_SetVoidPtr :: proc(this : ^ImGuiStorage, key : ImGuiID, val : rawptr)
{
	it : ^ImGuiStoragePair = ImLowerBound(this.Data.Data, this.Data.Data + this.Data.Size, key)
	if it == this.Data.Data + this.Data.Size || it.key != key { insert(&this.Data, it, ImGuiStoragePair(key, val)) }
	else { it.val_p = val }
}

// Obsolete: use on your own storage if you know only integer are being stored (open/close all tree nodes)
ImGuiStorage_SetAllInt :: proc(this : ^ImGuiStorage, v : i32)
{
	for i : i32 = 0; i < this.Data.Size; post_incr(&i) { this.Data[i].val_i = v }
}


//-V1077//-----------------------------------------------------------------------------
// [SECTION] ImGuiTextFilter
//-----------------------------------------------------------------------------

// Helper: Parse and apply text filters. In format "aaaaa[,bbbb][,ccccc]"
ImGuiTextFilter_init :: proc(this : ^ImGuiTextFilter, default_filter : ^u8)
{
	this.InputBuf[0] = 0
	this.CountGrep = 0
	if default_filter {
		ImStrncpy(this.InputBuf, default_filter, IM_ARRAYSIZE(this.InputBuf))
		Build()
	}
}

// Helper calling InputText+Build
ImGuiTextFilter_Draw :: proc(this : ^ImGuiTextFilter, label : ^u8, width : f32) -> bool
{
	if width != 0.0 { SetNextItemWidth(width) }
	value_changed : bool = InputText(label, this.InputBuf, IM_ARRAYSIZE(this.InputBuf))
	if value_changed { Build() }
	return value_changed
}

ImGuiTextFilter_ImGuiTextRange_split :: proc(this : ^ImGuiTextFilter_ImGuiTextRange, separator : u8, out : ^ImVector(ImGuiTextFilter_ImGuiTextRange))
{
	resize(out, 0)
	wb : ^u8 = this.b
	we : ^u8 = wb
	for we < this.e {
		if we^ == separator {
			push_back(out, ImGuiTextRange(wb, we))
			wb = we + 1
		}
		post_incr(&we)
	}

	if wb != we { push_back(out, ImGuiTextRange(wb, we)) }
}

ImGuiTextFilter_Build :: proc(this : ^ImGuiTextFilter)
{
	resize(&this.Filters, 0)
	input_range : ImGuiTextFilter_ImGuiTextRange; init(&input_range, this.InputBuf, this.InputBuf + strlen(this.InputBuf))
	split(&input_range, ',', &this.Filters)

	this.CountGrep = 0
	for f in this.Filters {
		for f.b < f.e && ImCharIsBlankA(f.b[0]) { post_incr(&f.b) }

		for f.e > f.b && ImCharIsBlankA(f.e[-1]) { post_decr(&f.e) }

		if empty(&f) { continue }
		if f.b[0] != '-' { this.CountGrep += 1 }
	}
}

ImGuiTextFilter_PassFilter :: proc(this : ^ImGuiTextFilter, text : ^u8, text_end : ^u8) -> bool
{
	if this.Filters.Size == 0 { return true }

	if text == nil { text_end = ""; text = text_end }

	for f in this.Filters {
		if f.b == f.e { continue }
		if f.b[0] == '-' {
			// Subtract
			if ImStristr(text, text_end, f.b + 1, f.e) != nil { return false }
		}
		else {
			// Grep
			if ImStristr(text, text_end, f.b, f.e) != nil { return true }
		}
	}

	// Implicit * grep
	if this.CountGrep == 0 { return true }

	return false
}

//-----------------------------------------------------------------------------
// [SECTION] ImGuiTextBuffer, ImGuiTextIndex
//-----------------------------------------------------------------------------


//char ImGuiTextBuffer::EmptyString[1] = { 0 };

ImGuiTextBuffer_append :: proc(this : ^ImGuiTextBuffer, str : ^u8, str_end : ^u8)
{
	len : i32 = str_end ? cast(i32) (str_end - str) : cast(i32) strlen(str)

	// Add zero-terminator the first time
	write_off : i32 = (this.Buf.Size != 0) ? this.Buf.Size : 1
	needed_sz : i32 = write_off + len
	if write_off + len >= this.Buf.Capacity {
		new_capacity : i32 = this.Buf.Capacity * 2
		reserve(&this.Buf, needed_sz > new_capacity ? needed_sz : new_capacity)
	}

	resize(&this.Buf, needed_sz)
	memcpy(&this.Buf[write_off - 1], str, cast(uint) len)
	this.Buf[write_off - 1 + len] = 0
}

ImGuiTextBuffer_appendf :: proc(this : ^ImGuiTextBuffer, fmt : ^u8, args : ..[]any)
{
	args : []any
	va_start(args, fmt)
	appendfv(fmt, args)
	va_end(args)
}

// Helper: Text buffer for logging/accumulating text
ImGuiTextBuffer_appendfv :: proc(this : ^ImGuiTextBuffer, fmt : ^u8, args : []any)
{
	args_copy := args

	len : i32 = ImFormatStringV(nil, 0, fmt, args); // FIXME-OPT: could do a first pass write attempt, likely successful on first pass.
	if len <= 0 {
		va_end(args_copy)
		return
	}

	// Add zero-terminator the first time
	write_off : i32 = (this.Buf.Size != 0) ? this.Buf.Size : 1
	needed_sz : i32 = write_off + len
	if write_off + len >= this.Buf.Capacity {
		new_capacity : i32 = this.Buf.Capacity * 2
		reserve(&this.Buf, needed_sz > new_capacity ? needed_sz : new_capacity)
	}

	resize(&this.Buf, needed_sz)
	ImFormatStringV(&this.Buf[write_off - 1], cast(uint) len + 1, fmt, args_copy)
	va_end(args_copy)
}

ImGuiTextIndex_append :: proc(this : ^ImGuiTextIndex, base : ^u8, old_size : i32, new_size : i32)
{
	IM_ASSERT(old_size >= 0 && new_size >= old_size && new_size >= this.EndOffset)
	if old_size == new_size { return }
	if this.EndOffset == 0 || base[this.EndOffset - 1] == '\n' { push_back(&this.LineOffsets, this.EndOffset) }
	base_end : ^u8 = base + new_size
	p : ^u8 = base + old_size
	for {
		p = cast(^u8) memchr(p, '\n', base_end - p)
		if p == 0 { break }
		if pre_incr(&p) < base_end {
			// Don't push a trailing offset on last \n
			push_back(&this.LineOffsets, cast(i32) cast(intptr_t) (p - base))
		}
	}

	this.EndOffset = ImMax(this.EndOffset, new_size)
}

//-----------------------------------------------------------------------------
// [SECTION] ImGuiListClipper
//-----------------------------------------------------------------------------

// FIXME-TABLE: This prevents us from using ImGuiListClipper _inside_ a table cell.
// The problem we have is that without a Begin/End scheme for rows using the clipper is ambiguous.
GetSkipItemForListClipping :: proc() -> bool
{
	g : ^ImGuiContext = GImGui^
	return (g.CurrentTable ? g.CurrentTable.HostSkipItems : g.CurrentWindow.SkipItems)
}

ImGuiListClipper_SortAndFuseRanges :: proc(ranges : ^ImVector(ImGuiListClipperRange), offset : i32 = 0)
{
	if ranges.Size - offset <= 1 { return }

	// Helper to order ranges and fuse them together if possible (bubble sort is fine as we are only sorting 2-3 entries)
	for sort_end : i32 = ranges.Size - offset - 1; sort_end > 0; pre_decr(&sort_end) { for i : i32 = offset; i < sort_end + offset; pre_incr(&i) { if ranges[i].Min > ranges[i + 1].Min { ImSwap(ranges[i], ranges[i + 1]) } } }

	// Now fuse ranges together as much as possible.
	for i : i32 = 1 + offset; i < ranges.Size; post_incr(&i) {
		IM_ASSERT(!ranges[i].PosToIndexConvert && !ranges[i - 1].PosToIndexConvert)
		if ranges[i - 1].Max < ranges[i].Min { continue }
		ranges[i - 1].Min = ImMin(ranges[i - 1].Min, ranges[i].Min)
		ranges[i - 1].Max = ImMax(ranges[i - 1].Max, ranges[i].Max)
		erase(&ranges, ranges.Data + i)
		post_decr(&i)
	}
}

ImGuiListClipper_SeekCursorAndSetupPrevLine :: proc(pos_y : f32, line_height : f32)
{
	// Set cursor position and a few other things so that SetScrollHereY() and Columns() can work when seeking cursor.
	// FIXME: It is problematic that we have to do that here, because custom/equivalent end-user code would stumble on the same issue.
	// The clipper should probably have a final step to display the last item in a regular manner, maybe with an opt-out flag for data sets which may have costly seek?
	g : ^ImGuiContext = GImGui^
	window : ^ImGuiWindow = g.CurrentWindow
	off_y : f32 = pos_y - window.DC.CursorPos.y
	window.DC.CursorPos.y = pos_y
	window.DC.CursorMaxPos.y = ImMax(window.DC.CursorMaxPos.y, pos_y - g.Style.ItemSpacing.y)
	window.DC.CursorPosPrevLine.y = window.DC.CursorPos.y - line_height; // Setting those fields so that SetScrollHereY() can properly function after the end of our clipper usage.
	window.DC.PrevLineSize.y = (line_height - g.Style.ItemSpacing.y); // If we end up needing more accurate data (to e.g. use SameLine) we may as well make the clipper have a fourth step to let user process and display the last item in their list.
	if columns : ^ImGuiOldColumns = window.DC.CurrentColumns; columns {
		// Setting this so that cell Y position are set properly
		columns.LineMinY = window.DC.CursorPos.y
	}
	if table : ^ImGuiTable = g.CurrentTable; table {
		if table.IsInsideRow { TableEndRow(table) }
		table.RowPosY2 = window.DC.CursorPos.y
		row_increase : i32 = cast(i32) ((off_y / line_height) + 0.5)
		//table->CurrentRow += row_increase; // Can't do without fixing TableEndRow()
		table.RowBgColorCounter += row_increase
	}
}

// [Internal] Internal data

// items_count: Use INT_MAX if you don't know how many items you have (in which case the cursor won't be advanced in the final step, and you can call SeekCursorForItem() manually if you need)
// items_height: Use -1.0f to be calculated automatically on first step. Otherwise pass in the distance between your items, typically GetTextLineHeightWithSpacing() or GetFrameHeightWithSpacing().
ImGuiListClipper_init :: proc(this : ^ImGuiListClipper)
{
	memset(this, 0, size_of(this))
}

ImGuiListClipper_deinit :: proc(this : ^ImGuiListClipper)
{
	End()
}

ImGuiListClipper_Begin :: proc(this : ^ImGuiListClipper, items_count : i32, items_height : f32)
{
	if this.Ctx == nil { this.Ctx = GetCurrentContext() }

	g : ^ImGuiContext = this.Ctx^
	window : ^ImGuiWindow = g.CurrentWindow
	IMGUI_DEBUG_LOG_CLIPPER("Clipper: Begin(%d,%.2f) in '%s'\n", items_count, items_height, window.Name)

	if table : ^ImGuiTable = g.CurrentTable; table { if table.IsInsideRow { TableEndRow(table) } }

	this.StartPosY = window.DC.CursorPos.y
	this.ItemsHeight = items_height
	this.ItemsCount = items_count
	this.DisplayStart = -1
	this.DisplayEnd = 0

	// Acquire temporary buffer
	if pre_incr(&g.ClipperTempDataStacked) > g.ClipperTempData.Size { resize(&g.ClipperTempData, g.ClipperTempDataStacked, ImGuiListClipperData()) }
	data : ^ImGuiListClipperData = &g.ClipperTempData[g.ClipperTempDataStacked - 1]
	Reset(data, this)
	data.LossynessOffset = window.DC.CursorStartPosLossyness.y
	this.TempData = data
	this.StartSeekOffsetY = data.LossynessOffset
}

// Automatically called on the last call of Step() that returns false.
ImGuiListClipper_End :: proc(this : ^ImGuiListClipper)
{
	if data : ^ImGuiListClipperData = cast(^ImGuiListClipperData) this.TempData; data {
		// In theory here we should assert that we are already at the right position, but it seems saner to just seek at the end and not assert/crash the user.
		g : ^ImGuiContext = this.Ctx^
		IMGUI_DEBUG_LOG_CLIPPER("Clipper: End() in '%s'\n", g.CurrentWindow.Name)
		if this.ItemsCount >= 0 && this.ItemsCount < INT_MAX && this.DisplayStart >= 0 { SeekCursorForItem(this.ItemsCount) }

		// Restore temporary buffer and fix back pointers which may be invalidated when nesting
		IM_ASSERT(data.ListClipper == this)
		data.StepNo = data.Ranges.Size
		if pre_decr(&g.ClipperTempDataStacked) > 0 {
			data = &g.ClipperTempData[g.ClipperTempDataStacked - 1]
			data.ListClipper.TempData = data
		}
		this.TempData = nil
	}
	this.ItemsCount = -1
}

// item_end is exclusive e.g. use (42, 42+1) to make item 42 never clipped.
ImGuiListClipper_IncludeItemsByIndex :: proc(this : ^ImGuiListClipper, item_begin : i32, item_end : i32)
{
	data : ^ImGuiListClipperData = cast(^ImGuiListClipperData) this.TempData
	IM_ASSERT(this.DisplayStart < 0); // Only allowed after Begin() and if there has not been a specified range yet.
	IM_ASSERT(item_begin <= item_end)
	if item_begin < item_end { push_back(&data.Ranges, FromIndices(item_begin, item_end)) }
}

// Seek cursor toward given item. This is automatically called while stepping.
// - The only reason to call this is: you can use ImGuiListClipper::Begin(INT_MAX) if you don't know item count ahead of time.
// - In this case, after all steps are done, you'll want to call SeekCursorForItem(item_count).
// This is already called while stepping.
// The ONLY reason you may want to call this is if you passed INT_MAX to ImGuiListClipper::Begin() because you couldn't step item count beforehand.
ImGuiListClipper_SeekCursorForItem :: proc(this : ^ImGuiListClipper, item_n : i32)
{
	// - Perform the add and multiply with double to allow seeking through larger ranges.
	// - StartPosY starts from ItemsFrozen, by adding SeekOffsetY we generally cancel that out (SeekOffsetY == LossynessOffset - ItemsFrozen * ItemsHeight).
	// - The reason we store SeekOffsetY instead of inferring it, is because we want to allow user to perform Seek after the last step, where ImGuiListClipperData is already done.
	pos_y : f32 = cast(f32) (cast(f64) this.StartPosY + this.StartSeekOffsetY + cast(f64) item_n * this.ItemsHeight)
	ImGuiListClipper_SeekCursorAndSetupPrevLine(pos_y, this.ItemsHeight)
}

ImGuiListClipper_StepInternal :: proc(clipper : ^ImGuiListClipper) -> bool
{
	g : ^ImGuiContext = clipper.Ctx^
	window : ^ImGuiWindow = g.CurrentWindow
	data : ^ImGuiListClipperData = cast(^ImGuiListClipperData) clipper.TempData
	IM_ASSERT(data != nil && "Called ImGuiListClipper::Step() too many times, or before ImGuiListClipper::Begin() ?")

	table : ^ImGuiTable = g.CurrentTable
	if table && table.IsInsideRow { TableEndRow(table) }

	// No items
	if clipper.ItemsCount == 0 || GetSkipItemForListClipping() { return false }

	// While we are in frozen row state, keep displaying items one by one, unclipped
	// FIXME: Could be stored as a table-agnostic state.
	if data.StepNo == 0 && table != nil && !table.IsUnfrozenRows {
		clipper.DisplayStart = data.ItemsFrozen
		clipper.DisplayEnd = ImMin(data.ItemsFrozen + 1, clipper.ItemsCount)
		if clipper.DisplayStart < clipper.DisplayEnd { post_incr(&data.ItemsFrozen) }
		return true
	}

	// Step 0: Let you process the first element (regardless of it being visible or not, so we can measure the element height)
	calc_clipping : bool = false
	if data.StepNo == 0 {
		clipper.StartPosY = window.DC.CursorPos.y
		if clipper.ItemsHeight <= 0.0 {
			// Submit the first item (or range) so we can measure its height (generally the first range is 0..1)
			push_front(&data.Ranges, FromIndices(data.ItemsFrozen, data.ItemsFrozen + 1))
			clipper.DisplayStart = ImMax(data.Ranges[0].Min, data.ItemsFrozen)
			clipper.DisplayEnd = ImMin(data.Ranges[0].Max, clipper.ItemsCount)
			data.StepNo = 1
			return true
		}
		calc_clipping = true; // If on the first step with known item height, calculate clipping.
	}

	// Step 1: Let the clipper infer height from first range
	if clipper.ItemsHeight <= 0.0 {
		IM_ASSERT(data.StepNo == 1)
		if table { IM_ASSERT(table.RowPosY1 == clipper.StartPosY && table.RowPosY2 == window.DC.CursorPos.y) }

		clipper.ItemsHeight = (window.DC.CursorPos.y - clipper.StartPosY) / cast(f32) (clipper.DisplayEnd - clipper.DisplayStart)
		affected_by_floating_point_precision : bool = ImIsFloatAboveGuaranteedIntegerPrecision(clipper.StartPosY) || ImIsFloatAboveGuaranteedIntegerPrecision(window.DC.CursorPos.y)
		if affected_by_floating_point_precision {
			// FIXME: Technically wouldn't allow multi-line entries.
			clipper.ItemsHeight = window.DC.PrevLineSize.y + g.Style.ItemSpacing.y
		}
		if clipper.ItemsHeight == 0.0 && clipper.ItemsCount == INT_MAX {
			// Accept that no item have been submitted if in indeterminate mode.return false
		}
		IM_ASSERT(clipper.ItemsHeight > 0.0 && "Unable to calculate item height! First item hasn't moved the cursor vertically!")
		calc_clipping = true; // If item height had to be calculated, calculate clipping afterwards.
	}

	// Step 0 or 1: Calculate the actual ranges of visible elements.
	already_submitted : i32 = clipper.DisplayEnd
	if calc_clipping {
		// Record seek offset, this is so ImGuiListClipper::Seek() can be called after ImGuiListClipperData is done
		clipper.StartSeekOffsetY = cast(f64) data.LossynessOffset - data.ItemsFrozen * cast(f64) clipper.ItemsHeight

		if g.LogEnabled {
			// If logging is active, do not perform any clipping
			push_back(&data.Ranges, FromIndices(0, clipper.ItemsCount))
		}
		else {
			// Add range selected to be included for navigation
			is_nav_request : bool = (g.NavMoveScoringItems && g.NavWindow && g.NavWindow.RootWindowForNav == window.RootWindowForNav)
			if is_nav_request { push_back(&data.Ranges, FromPositions(g.NavScoringNoClipRect.Min.y, g.NavScoringNoClipRect.Max.y, 0, 0)) }
			if is_nav_request && (g.NavMoveFlags & ImGuiNavMoveFlags_.ImGuiNavMoveFlags_IsTabbing) && g.NavTabbingDir == -1 { push_back(&data.Ranges, FromIndices(clipper.ItemsCount - 1, clipper.ItemsCount)) }

			// Add focused/active item
			nav_rect_abs : ImRect = WindowRectRelToAbs(window, window.NavRectRel[0])
			if g.NavId != 0 && window.NavLastIds[0] == g.NavId { push_back(&data.Ranges, FromPositions(nav_rect_abs.Min.y, nav_rect_abs.Max.y, 0, 0)) }

			// Add visible range
			min_y : f32 = window.ClipRect.Min.y
			max_y : f32 = window.ClipRect.Max.y

			// Add box selection range
			bs : ^ImGuiBoxSelectState = &g.BoxSelectState
			if bs.IsActive && bs.Window == window {
				// FIXME: Selectable() use of half-ItemSpacing isn't consistent in matter of layout, as ItemAdd(bb) stray above ItemSize()'s CursorPos.
				// RangeSelect's BoxSelect relies on comparing overlap of previous and current rectangle and is sensitive to that.
				// As a workaround we currently half ItemSpacing worth on each side.
				min_y -= g.Style.ItemSpacing.y
				max_y += g.Style.ItemSpacing.y

				// Box-select on 2D area requires different clipping.
				if bs.UnclipMode { push_back(&data.Ranges, FromPositions(bs.UnclipRect.Min.y, bs.UnclipRect.Max.y, 0, 0)) }
			}

			off_min : i32 = (is_nav_request && g.NavMoveClipDir == ImGuiDir.ImGuiDir_Up) ? -1 : 0
			off_max : i32 = (is_nav_request && g.NavMoveClipDir == ImGuiDir.ImGuiDir_Down) ? 1 : 0
			push_back(&data.Ranges, FromPositions(min_y, max_y, off_min, off_max))
		}

		// Convert position ranges to item index ranges
		// - Very important: when a starting position is after our maximum item, we set Min to (ItemsCount - 1). This allows us to handle most forms of wrapping.
		// - Due to how Selectable extra padding they tend to be "unaligned" with exact unit in the item list,
		//   which with the flooring/ceiling tend to lead to 2 items instead of one being submitted.
		for range in data.Ranges { if range.PosToIndexConvert {
	m1 : i32 = cast(i32) ((cast(f64) range.Min - window.DC.CursorPos.y - data.LossynessOffset) / clipper.ItemsHeight)
	m2 : i32 = cast(i32) (((cast(f64) range.Max - window.DC.CursorPos.y - data.LossynessOffset) / clipper.ItemsHeight) + 0.999999)
	range.Min = ImClamp(already_submitted + m1 + range.PosToIndexOffsetMin, already_submitted, clipper.ItemsCount - 1)
	range.Max = ImClamp(already_submitted + m2 + range.PosToIndexOffsetMax, range.Min + 1, clipper.ItemsCount)
	range.PosToIndexConvert = false
} }

		ImGuiListClipper_SortAndFuseRanges(data.Ranges, data.StepNo)
	}

	// Step 0+ (if item height is given in advance) or 1+: Display the next range in line.
	for data.StepNo < data.Ranges.Size {
		clipper.DisplayStart = ImMax(data.Ranges[data.StepNo].Min, already_submitted)
		clipper.DisplayEnd = ImMin(data.Ranges[data.StepNo].Max, clipper.ItemsCount)
		if clipper.DisplayStart > already_submitted {
			//-V1051SeekCursorForItem(clipper, clipper.DisplayStart)
		}
		post_incr(&data.StepNo)
		if clipper.DisplayStart == clipper.DisplayEnd && data.StepNo < data.Ranges.Size { continue }
		return true
	}

	// After the last step: Let the clipper validate that we have reached the expected Y position (corresponding to element DisplayEnd),
	// Advance the cursor to the end of the list and then returns 'false' to end the loop.
	if clipper.ItemsCount < INT_MAX { SeekCursorForItem(clipper, clipper.ItemsCount) }

	return false
}

// Call until it returns false. The DisplayStart/DisplayEnd fields will be set and you can process/draw those items.
ImGuiListClipper_Step :: proc(this : ^ImGuiListClipper) -> bool
{
	g : ^ImGuiContext = this.Ctx^
	need_items_height : bool = (this.ItemsHeight <= 0.0)
	ret : bool = ImGuiListClipper_StepInternal(this)
	if ret && (this.DisplayStart == this.DisplayEnd) { ret = false }
	if g.CurrentTable && g.CurrentTable.IsUnfrozenRows == false { IMGUI_DEBUG_LOG_CLIPPER("Clipper: Step(): inside frozen table row.\n") }
	if need_items_height && this.ItemsHeight > 0.0 { IMGUI_DEBUG_LOG_CLIPPER("Clipper: Step(): computed ItemsHeight: %.2f.\n", this.ItemsHeight) }
	if ret {
		IMGUI_DEBUG_LOG_CLIPPER("Clipper: Step(): display %d to %d.\n", this.DisplayStart, this.DisplayEnd)
	}
	else {
		IMGUI_DEBUG_LOG_CLIPPER("Clipper: Step(): End.\n")
		End()
	}
	return ret
}

// access the Style structure (colors, sizes). Always use PushStyleColor(), PushStyleVar() to modify style mid-frame!
//-----------------------------------------------------------------------------
// [SECTION] STYLING
//-----------------------------------------------------------------------------

GetStyle :: proc() -> ^ImGuiStyle
{
	IM_ASSERT(GImGui != nil && "No current context. Did you call ImGui::CreateContext() and ImGui::SetCurrentContext() ?")
	return GImGui.Style
}

// retrieve given style color with style alpha applied and optional extra alpha multiplier, packed as a 32-bit value suitable for ImDrawList
// retrieve given color with style alpha applied, packed as a 32-bit value suitable for ImDrawList
GetColorU32_0 :: proc(idx : ImGuiCol, alpha_mul : f32) -> ImU32
{
	style : ^ImGuiStyle = GImGui.Style
	c : ImVec4 = style.Colors[idx]
	c.w *= style.Alpha * alpha_mul
	return ColorConvertFloat4ToU32(c)
}

// retrieve given style color with style alpha applied and optional extra alpha multiplier, packed as a 32-bit value suitable for ImDrawList
// retrieve given color with style alpha applied, packed as a 32-bit value suitable for ImDrawList
GetColorU32_1 :: proc(col : ^ImVec4) -> ImU32
{
	style : ^ImGuiStyle = GImGui.Style
	c : ImVec4 = col
	c.w *= style.Alpha
	return ColorConvertFloat4ToU32(c)
}

// retrieve style color as stored in ImGuiStyle structure. use to feed back into PushStyleColor(), otherwise use GetColorU32() to get style color with style alpha baked in.
GetStyleColorVec4 :: proc(idx : ImGuiCol) -> ^ImVec4
{
	style : ^ImGuiStyle = GImGui.Style
	return style.Colors[idx]
}

// retrieve given style color with style alpha applied and optional extra alpha multiplier, packed as a 32-bit value suitable for ImDrawList
// retrieve given color with style alpha applied, packed as a 32-bit value suitable for ImDrawList
GetColorU32_2 :: proc(col : ImU32, alpha_mul : f32) -> ImU32
{
	style : ^ImGuiStyle = GImGui.Style
	alpha_mul *= style.Alpha
	if alpha_mul >= 1.0 { return col }
	a : ImU32 = (col & IM_COL32_A_MASK) >> IM_COL32_A_SHIFT
	a = cast(ImU32) (a * alpha_mul); // We don't need to clamp 0..255 because alpha is in 0..1 range.
	return (col & !IM_COL32_A_MASK) | (a << IM_COL32_A_SHIFT)
}

// modify a style color. always use this if you modify the style after NewFrame().
// FIXME: This may incur a round-trip (if the end user got their data from a float4) but eventually we aim to store the in-flight colors as ImU32
PushStyleColor_0 :: proc(idx : ImGuiCol, col : ImU32)
{
	g : ^ImGuiContext = GImGui^
	backup : ImGuiColorMod
	backup.Col = idx
	backup.BackupValue = g.Style.Colors[idx]
	push_back(&g.ColorStack, backup)
	if g.DebugFlashStyleColorIdx != idx { g.Style.Colors[idx] = ColorConvertU32ToFloat4(col) }
}

// modify a style color. always use this if you modify the style after NewFrame().
PushStyleColor_1 :: proc(idx : ImGuiCol, col : ^ImVec4)
{
	g : ^ImGuiContext = GImGui^
	backup : ImGuiColorMod
	backup.Col = idx
	backup.BackupValue = g.Style.Colors[idx]
	push_back(&g.ColorStack, backup)
	if g.DebugFlashStyleColorIdx != idx { g.Style.Colors[idx] = col }
}

PopStyleColor :: proc(count : i32)
{
	g : ^ImGuiContext = GImGui^
	if g.ColorStack.Size < count {
		IM_ASSERT_USER_ERROR(0, "Calling PopStyleColor() too many times!")
		count = g.ColorStack.Size
	}
	for count > 0 {
		backup : ^ImGuiColorMod = back(&g.ColorStack)
		g.Style.Colors[backup.Col] = backup.BackupValue
		pop_back(&g.ColorStack)
		post_decr(&count)
	}
}

GWindowDockStyleColors : [ImGuiWindowDockStyleCol.ImGuiWindowDockStyleCol_COUNT]ImGuiCol_ = {
	ImGuiCol_.ImGuiCol_Text, ImGuiCol_.ImGuiCol_TabHovered, ImGuiCol_.ImGuiCol_Tab, ImGuiCol_.ImGuiCol_TabSelected, ImGuiCol_.ImGuiCol_TabSelectedOverline, ImGuiCol_.ImGuiCol_TabDimmed, ImGuiCol_.ImGuiCol_TabDimmedSelected, ImGuiCol_.ImGuiCol_TabDimmedSelectedOverline,
}

GStyleVarInfo := [?]ImGuiDataVarInfo{
	{ImGuiDataType_.ImGuiDataType_Float, 1, cast(ImU32) offset_of(ImGuiStyle, Alpha)}, // ImGuiStyleVar_Alpha
	{ImGuiDataType_.ImGuiDataType_Float, 1, cast(ImU32) offset_of(ImGuiStyle, DisabledAlpha)}, // ImGuiStyleVar_DisabledAlpha
	{ImGuiDataType_.ImGuiDataType_Float, 2, cast(ImU32) offset_of(ImGuiStyle, WindowPadding)}, // ImGuiStyleVar_WindowPadding
	{ImGuiDataType_.ImGuiDataType_Float, 1, cast(ImU32) offset_of(ImGuiStyle, WindowRounding)}, // ImGuiStyleVar_WindowRounding
	{ImGuiDataType_.ImGuiDataType_Float, 1, cast(ImU32) offset_of(ImGuiStyle, WindowBorderSize)}, // ImGuiStyleVar_WindowBorderSize
	{ImGuiDataType_.ImGuiDataType_Float, 2, cast(ImU32) offset_of(ImGuiStyle, WindowMinSize)}, // ImGuiStyleVar_WindowMinSize
	{ImGuiDataType_.ImGuiDataType_Float, 2, cast(ImU32) offset_of(ImGuiStyle, WindowTitleAlign)}, // ImGuiStyleVar_WindowTitleAlign
	{ImGuiDataType_.ImGuiDataType_Float, 1, cast(ImU32) offset_of(ImGuiStyle, ChildRounding)}, // ImGuiStyleVar_ChildRounding
	{ImGuiDataType_.ImGuiDataType_Float, 1, cast(ImU32) offset_of(ImGuiStyle, ChildBorderSize)}, // ImGuiStyleVar_ChildBorderSize
	{ImGuiDataType_.ImGuiDataType_Float, 1, cast(ImU32) offset_of(ImGuiStyle, PopupRounding)}, // ImGuiStyleVar_PopupRounding
	{ImGuiDataType_.ImGuiDataType_Float, 1, cast(ImU32) offset_of(ImGuiStyle, PopupBorderSize)}, // ImGuiStyleVar_PopupBorderSize
	{ImGuiDataType_.ImGuiDataType_Float, 2, cast(ImU32) offset_of(ImGuiStyle, FramePadding)}, // ImGuiStyleVar_FramePadding
	{ImGuiDataType_.ImGuiDataType_Float, 1, cast(ImU32) offset_of(ImGuiStyle, FrameRounding)}, // ImGuiStyleVar_FrameRounding
	{ImGuiDataType_.ImGuiDataType_Float, 1, cast(ImU32) offset_of(ImGuiStyle, FrameBorderSize)}, // ImGuiStyleVar_FrameBorderSize
	{ImGuiDataType_.ImGuiDataType_Float, 2, cast(ImU32) offset_of(ImGuiStyle, ItemSpacing)}, // ImGuiStyleVar_ItemSpacing
	{ImGuiDataType_.ImGuiDataType_Float, 2, cast(ImU32) offset_of(ImGuiStyle, ItemInnerSpacing)}, // ImGuiStyleVar_ItemInnerSpacing
	{ImGuiDataType_.ImGuiDataType_Float, 1, cast(ImU32) offset_of(ImGuiStyle, IndentSpacing)}, // ImGuiStyleVar_IndentSpacing
	{ImGuiDataType_.ImGuiDataType_Float, 2, cast(ImU32) offset_of(ImGuiStyle, CellPadding)}, // ImGuiStyleVar_CellPadding
	{ImGuiDataType_.ImGuiDataType_Float, 1, cast(ImU32) offset_of(ImGuiStyle, ScrollbarSize)}, // ImGuiStyleVar_ScrollbarSize
	{ImGuiDataType_.ImGuiDataType_Float, 1, cast(ImU32) offset_of(ImGuiStyle, ScrollbarRounding)}, // ImGuiStyleVar_ScrollbarRounding
	{ImGuiDataType_.ImGuiDataType_Float, 1, cast(ImU32) offset_of(ImGuiStyle, GrabMinSize)}, // ImGuiStyleVar_GrabMinSize
	{ImGuiDataType_.ImGuiDataType_Float, 1, cast(ImU32) offset_of(ImGuiStyle, GrabRounding)}, // ImGuiStyleVar_GrabRounding
	{ImGuiDataType_.ImGuiDataType_Float, 1, cast(ImU32) offset_of(ImGuiStyle, TabRounding)}, // ImGuiStyleVar_TabRounding
	{ImGuiDataType_.ImGuiDataType_Float, 1, cast(ImU32) offset_of(ImGuiStyle, TabBorderSize)}, // ImGuiStyleVar_TabBorderSize
	{ImGuiDataType_.ImGuiDataType_Float, 1, cast(ImU32) offset_of(ImGuiStyle, TabBarBorderSize)}, // ImGuiStyleVar_TabBarBorderSize
	{ImGuiDataType_.ImGuiDataType_Float, 1, cast(ImU32) offset_of(ImGuiStyle, TabBarOverlineSize)}, // ImGuiStyleVar_TabBarOverlineSize
	{ImGuiDataType_.ImGuiDataType_Float, 1, cast(ImU32) offset_of(ImGuiStyle, TableAngledHeadersAngle)}, // ImGuiStyleVar_TableAngledHeadersAngle
	{ImGuiDataType_.ImGuiDataType_Float, 2, cast(ImU32) offset_of(ImGuiStyle, TableAngledHeadersTextAlign)}, // ImGuiStyleVar_TableAngledHeadersTextAlign
	{ImGuiDataType_.ImGuiDataType_Float, 2, cast(ImU32) offset_of(ImGuiStyle, ButtonTextAlign)}, // ImGuiStyleVar_ButtonTextAlign
	{ImGuiDataType_.ImGuiDataType_Float, 2, cast(ImU32) offset_of(ImGuiStyle, SelectableTextAlign)}, // ImGuiStyleVar_SelectableTextAlign
	{ImGuiDataType_.ImGuiDataType_Float, 1, cast(ImU32) offset_of(ImGuiStyle, SeparatorTextBorderSize)}, // ImGuiStyleVar_SeparatorTextBorderSize
	{ImGuiDataType_.ImGuiDataType_Float, 2, cast(ImU32) offset_of(ImGuiStyle, SeparatorTextAlign)}, // ImGuiStyleVar_SeparatorTextAlign
	{ImGuiDataType_.ImGuiDataType_Float, 2, cast(ImU32) offset_of(ImGuiStyle, SeparatorTextPadding)}, // ImGuiStyleVar_SeparatorTextPadding
	{ImGuiDataType_.ImGuiDataType_Float, 1, cast(ImU32) offset_of(ImGuiStyle, DockingSeparatorSize)}, // ImGuiStyleVar_DockingSeparatorSize
}

// Parameter stacks (shared)
GetStyleVarInfo :: proc(idx : ImGuiStyleVar) -> ^ImGuiDataVarInfo
{
	IM_ASSERT(idx >= 0 && idx < ImGuiStyleVar_.ImGuiStyleVar_COUNT)
	IM_STATIC_ASSERT(IM_ARRAYSIZE(GStyleVarInfo) == ImGuiStyleVar_.ImGuiStyleVar_COUNT)
	return &GStyleVarInfo[idx]
}

// modify a style float variable. always use this if you modify the style after NewFrame()!
// modify a style ImVec2 variable. "
PushStyleVar_f :: proc(idx : ImGuiStyleVar, val : f32)
{
	g : ^ImGuiContext = GImGui^
	var_info : ^ImGuiDataVarInfo = GetStyleVarInfo(idx)
	if var_info.Type != ImGuiDataType_.ImGuiDataType_Float || var_info.Count != 1 {
		IM_ASSERT_USER_ERROR(0, "Calling PushStyleVar() variant with wrong type!")
		return
	}
	pvar : ^f32 = cast(^f32) GetVarPtr(var_info, &g.Style)
	push_back(&g.StyleVarStack, ImGuiStyleMod(idx, pvar^))
	pvar^ = val
}

// modify X component of a style ImVec2 variable. "
PushStyleVarX :: proc(idx : ImGuiStyleVar, val_x : f32)
{
	g : ^ImGuiContext = GImGui^
	var_info : ^ImGuiDataVarInfo = GetStyleVarInfo(idx)
	if var_info.Type != ImGuiDataType_.ImGuiDataType_Float || var_info.Count != 2 {
		IM_ASSERT_USER_ERROR(0, "Calling PushStyleVar() variant with wrong type!")
		return
	}
	pvar : ^ImVec2 = cast(^ImVec2) GetVarPtr(var_info, &g.Style)
	push_back(&g.StyleVarStack, ImGuiStyleMod(idx, pvar^))
	pvar.x = val_x
}

// modify Y component of a style ImVec2 variable. "
PushStyleVarY :: proc(idx : ImGuiStyleVar, val_y : f32)
{
	g : ^ImGuiContext = GImGui^
	var_info : ^ImGuiDataVarInfo = GetStyleVarInfo(idx)
	if var_info.Type != ImGuiDataType_.ImGuiDataType_Float || var_info.Count != 2 {
		IM_ASSERT_USER_ERROR(0, "Calling PushStyleVar() variant with wrong type!")
		return
	}
	pvar : ^ImVec2 = cast(^ImVec2) GetVarPtr(var_info, &g.Style)
	push_back(&g.StyleVarStack, ImGuiStyleMod(idx, pvar^))
	pvar.y = val_y
}

// modify a style float variable. always use this if you modify the style after NewFrame()!
// modify a style ImVec2 variable. "
PushStyleVar_v2 :: proc(idx : ImGuiStyleVar, val : ^ImVec2)
{
	g : ^ImGuiContext = GImGui^
	var_info : ^ImGuiDataVarInfo = GetStyleVarInfo(idx)
	if var_info.Type != ImGuiDataType_.ImGuiDataType_Float || var_info.Count != 2 {
		IM_ASSERT_USER_ERROR(0, "Calling PushStyleVar() variant with wrong type!")
		return
	}
	pvar : ^ImVec2 = cast(^ImVec2) GetVarPtr(var_info, &g.Style)
	push_back(&g.StyleVarStack, ImGuiStyleMod(idx, pvar^))
	pvar^ = val
}

PopStyleVar :: proc(count : i32)
{
	g : ^ImGuiContext = GImGui^
	if g.StyleVarStack.Size < count {
		IM_ASSERT_USER_ERROR(0, "Calling PopStyleVar() too many times!")
		count = g.StyleVarStack.Size
	}
	for count > 0 {
		// We avoid a generic memcpy(data, &backup.Backup.., GDataTypeSize[info->Type] * info->Count), the overhead in Debug is not worth it.
		backup : ^ImGuiStyleMod = back(&g.StyleVarStack)
		info : ^ImGuiDataVarInfo = GetStyleVarInfo(backup.VarIdx)
		data : rawptr = GetVarPtr(info, &g.Style)
		if info.Type == ImGuiDataType_.ImGuiDataType_Float && info.Count == 1 { (cast(^f32) data)[0] = backup.BackupFloat[0] }
		else if info.Type == ImGuiDataType_.ImGuiDataType_Float && info.Count == 2 {(cast(^f32) data)[0] = backup.BackupFloat[0]; (cast(^f32) data)[1] = backup.BackupFloat[1]
		}
		pop_back(&g.StyleVarStack)
		post_decr(&count)
	}
}

// get a string corresponding to the enum value (for display, saving, etc.).
GetStyleColorName :: proc(idx : ImGuiCol) -> ^u8
{
	// Create switch-case from enum with regexp: ImGuiCol_{.*}, --> case ImGuiCol_\1: return "\1";
	switch idx {
		case ImGuiCol_.ImGuiCol_Text:return "Text"
			fallthrough
		case ImGuiCol_.ImGuiCol_TextDisabled:return "TextDisabled"
			fallthrough
		case ImGuiCol_.ImGuiCol_WindowBg:return "WindowBg"
			fallthrough
		case ImGuiCol_.ImGuiCol_ChildBg:return "ChildBg"
			fallthrough
		case ImGuiCol_.ImGuiCol_PopupBg:return "PopupBg"
			fallthrough
		case ImGuiCol_.ImGuiCol_Border:return "Border"
			fallthrough
		case ImGuiCol_.ImGuiCol_BorderShadow:return "BorderShadow"
			fallthrough
		case ImGuiCol_.ImGuiCol_FrameBg:return "FrameBg"
			fallthrough
		case ImGuiCol_.ImGuiCol_FrameBgHovered:return "FrameBgHovered"
			fallthrough
		case ImGuiCol_.ImGuiCol_FrameBgActive:return "FrameBgActive"
			fallthrough
		case ImGuiCol_.ImGuiCol_TitleBg:return "TitleBg"
			fallthrough
		case ImGuiCol_.ImGuiCol_TitleBgActive:return "TitleBgActive"
			fallthrough
		case ImGuiCol_.ImGuiCol_TitleBgCollapsed:return "TitleBgCollapsed"
			fallthrough
		case ImGuiCol_.ImGuiCol_MenuBarBg:return "MenuBarBg"
			fallthrough
		case ImGuiCol_.ImGuiCol_ScrollbarBg:return "ScrollbarBg"
			fallthrough
		case ImGuiCol_.ImGuiCol_ScrollbarGrab:return "ScrollbarGrab"
			fallthrough
		case ImGuiCol_.ImGuiCol_ScrollbarGrabHovered:return "ScrollbarGrabHovered"
			fallthrough
		case ImGuiCol_.ImGuiCol_ScrollbarGrabActive:return "ScrollbarGrabActive"
			fallthrough
		case ImGuiCol_.ImGuiCol_CheckMark:return "CheckMark"
			fallthrough
		case ImGuiCol_.ImGuiCol_SliderGrab:return "SliderGrab"
			fallthrough
		case ImGuiCol_.ImGuiCol_SliderGrabActive:return "SliderGrabActive"
			fallthrough
		case ImGuiCol_.ImGuiCol_Button:return "Button"
			fallthrough
		case ImGuiCol_.ImGuiCol_ButtonHovered:return "ButtonHovered"
			fallthrough
		case ImGuiCol_.ImGuiCol_ButtonActive:return "ButtonActive"
			fallthrough
		case ImGuiCol_.ImGuiCol_Header:return "Header"
			fallthrough
		case ImGuiCol_.ImGuiCol_HeaderHovered:return "HeaderHovered"
			fallthrough
		case ImGuiCol_.ImGuiCol_HeaderActive:return "HeaderActive"
			fallthrough
		case ImGuiCol_.ImGuiCol_Separator:return "Separator"
			fallthrough
		case ImGuiCol_.ImGuiCol_SeparatorHovered:return "SeparatorHovered"
			fallthrough
		case ImGuiCol_.ImGuiCol_SeparatorActive:return "SeparatorActive"
			fallthrough
		case ImGuiCol_.ImGuiCol_ResizeGrip:return "ResizeGrip"
			fallthrough
		case ImGuiCol_.ImGuiCol_ResizeGripHovered:return "ResizeGripHovered"
			fallthrough
		case ImGuiCol_.ImGuiCol_ResizeGripActive:return "ResizeGripActive"
			fallthrough
		case ImGuiCol_.ImGuiCol_TabHovered:return "TabHovered"
			fallthrough
		case ImGuiCol_.ImGuiCol_Tab:return "Tab"
			fallthrough
		case ImGuiCol_.ImGuiCol_TabSelected:return "TabSelected"
			fallthrough
		case ImGuiCol_.ImGuiCol_TabSelectedOverline:return "TabSelectedOverline"
			fallthrough
		case ImGuiCol_.ImGuiCol_TabDimmed:return "TabDimmed"
			fallthrough
		case ImGuiCol_.ImGuiCol_TabDimmedSelected:return "TabDimmedSelected"
			fallthrough
		case ImGuiCol_.ImGuiCol_TabDimmedSelectedOverline:return "TabDimmedSelectedOverline"
			fallthrough
		case ImGuiCol_.ImGuiCol_DockingPreview:return "DockingPreview"
			fallthrough
		case ImGuiCol_.ImGuiCol_DockingEmptyBg:return "DockingEmptyBg"
			fallthrough
		case ImGuiCol_.ImGuiCol_PlotLines:return "PlotLines"
			fallthrough
		case ImGuiCol_.ImGuiCol_PlotLinesHovered:return "PlotLinesHovered"
			fallthrough
		case ImGuiCol_.ImGuiCol_PlotHistogram:return "PlotHistogram"
			fallthrough
		case ImGuiCol_.ImGuiCol_PlotHistogramHovered:return "PlotHistogramHovered"
			fallthrough
		case ImGuiCol_.ImGuiCol_TableHeaderBg:return "TableHeaderBg"
			fallthrough
		case ImGuiCol_.ImGuiCol_TableBorderStrong:return "TableBorderStrong"
			fallthrough
		case ImGuiCol_.ImGuiCol_TableBorderLight:return "TableBorderLight"
			fallthrough
		case ImGuiCol_.ImGuiCol_TableRowBg:return "TableRowBg"
			fallthrough
		case ImGuiCol_.ImGuiCol_TableRowBgAlt:return "TableRowBgAlt"
			fallthrough
		case ImGuiCol_.ImGuiCol_TextLink:return "TextLink"
			fallthrough
		case ImGuiCol_.ImGuiCol_TextSelectedBg:return "TextSelectedBg"
			fallthrough
		case ImGuiCol_.ImGuiCol_DragDropTarget:return "DragDropTarget"
			fallthrough
		case ImGuiCol_.ImGuiCol_NavCursor:return "NavCursor"
			fallthrough
		case ImGuiCol_.ImGuiCol_NavWindowingHighlight:return "NavWindowingHighlight"
			fallthrough
		case ImGuiCol_.ImGuiCol_NavWindowingDimBg:return "NavWindowingDimBg"
			fallthrough
		case ImGuiCol_.ImGuiCol_ModalWindowDimBg:return "ModalWindowDimBg"
	}
	IM_ASSERT(0)
	return "Unknown"
}

// Find the optional ## from which we stop displaying text.
//-----------------------------------------------------------------------------
// [SECTION] RENDER HELPERS
// Some of those (internal) functions are currently quite a legacy mess - their signature and behavior will change,
// we need a nicer separation between low-level functions and high-level functions relying on the ImGui context.
// Also see imgui_draw.cpp for some more which have been reworked to not rely on ImGui:: context.
//-----------------------------------------------------------------------------

FindRenderedTextEnd :: proc(text : ^u8, text_end : ^u8) -> ^u8
{
	text_display_end : ^u8 = text
	if !text_end { text_end = cast(^u8) -1 }

	for text_display_end < text_end && text_display_end^ != 0 && (text_display_end[0] != '#' || text_display_end[1] != '#') {
		post_incr(&text_display_end)
	}

	return text_display_end
}

// Render helpers
// AVOID USING OUTSIDE OF IMGUI.CPP! NOT FOR PUBLIC CONSUMPTION. THOSE FUNCTIONS ARE A MESS. THEIR SIGNATURE AND BEHAVIOR WILL CHANGE, THEY NEED TO BE REFACTORED INTO SOMETHING DECENT.
// NB: All position are in absolute pixels coordinates (we are never using window coordinates internally)
// Internal ImGui functions to render text
// RenderText***() functions calls ImDrawList::AddText() calls ImBitmapFont::RenderText()
RenderText :: proc(pos : ImVec2, text : ^u8, text_end : ^u8, hide_text_after_hash : bool)
{
	g : ^ImGuiContext = GImGui^
	window : ^ImGuiWindow = g.CurrentWindow

	// Hide anything after a '##' string
	text_display_end : ^u8
	if hide_text_after_hash {
		text_display_end = FindRenderedTextEnd(text, text_end)
	}
	else {
		if !text_end {
			// FIXME-OPT
			text_end = text + strlen(text)
		}
		text_display_end = text_end
	}

	if text != text_display_end {
		AddText(window.DrawList, g.Font, g.FontSize, pos, GetColorU32(ImGuiCol_.ImGuiCol_Text), text, text_display_end)
		if g.LogEnabled { LogRenderedText(&pos, text, text_display_end) }
	}
}

RenderTextWrapped :: proc(pos : ImVec2, text : ^u8, text_end : ^u8, wrap_width : f32)
{
	g : ^ImGuiContext = GImGui^
	window : ^ImGuiWindow = g.CurrentWindow

	if !text_end {
		// FIXME-OPT
		text_end = text + strlen(text)
	}

	if text != text_end {
		AddText(window.DrawList, g.Font, g.FontSize, pos, GetColorU32(ImGuiCol_.ImGuiCol_Text), text, text_end, wrap_width)
		if g.LogEnabled { LogRenderedText(&pos, text, text_end) }
	}
}

// Default clip_rect uses (pos_min,pos_max)
// Handle clipping on CPU immediately (vs typically let the GPU clip the triangles that are overlapping the clipping rectangle edges)
// FIXME-OPT: Since we have or calculate text_size we could coarse clip whole block immediately, especally for text above draw_list->DrawList.
// Effectively as this is called from widget doing their own coarse clipping it's not very valuable presently. Next time function will take
// better advantage of the render function taking size into account for coarse clipping.
RenderTextClippedEx :: proc(draw_list : ^ImDrawList, pos_min : ^ImVec2, pos_max : ^ImVec2, text : ^u8, text_display_end : ^u8, text_size_if_known : ^ImVec2, align : ^ImVec2, clip_rect : ^ImRect)
{
	// Perform CPU side clipping for single clipped element to avoid using scissor state
	pos : ImVec2 = pos_min
	text_size : ImVec2 = text_size_if_known ? text_size_if_known^ : CalcTextSize(text, text_display_end, false, 0.0)

	clip_min : ^ImVec2 = clip_rect ? &clip_rect.Min : &pos_min
	clip_max : ^ImVec2 = clip_rect ? &clip_rect.Max : &pos_max
	need_clipping : bool = (pos.x + text_size.x >= clip_max.x) || (pos.y + text_size.y >= clip_max.y)
	if clip_rect {
		// If we had no explicit clipping rectangle then pos==clip_minneed_clipping |= (pos.x < clip_min.x) || (pos.y < clip_min.y)
	}

	// Align whole block. We should defer that to the better rendering function when we'll have support for individual line alignment.
	if align.x > 0.0 { pos.x = ImMax(pos.x, pos.x + (pos_max.x - pos.x - text_size.x) * align.x) }
	if align.y > 0.0 { pos.y = ImMax(pos.y, pos.y + (pos_max.y - pos.y - text_size.y) * align.y) }

	// Render
	if need_clipping {
		fine_clip_rect : ImVec4; init(&fine_clip_rect, clip_min.x, clip_min.y, clip_max.x, clip_max.y)
		AddText(draw_list, nil, 0.0, pos, GetColorU32(ImGuiCol_.ImGuiCol_Text), text, text_display_end, 0.0, &fine_clip_rect)
	}
	else {
		AddText(draw_list, nil, 0.0, pos, GetColorU32(ImGuiCol_.ImGuiCol_Text), text, text_display_end, 0.0, nil)
	}
}

RenderTextClipped :: proc(pos_min : ^ImVec2, pos_max : ^ImVec2, text : ^u8, text_end : ^u8, text_size_if_known : ^ImVec2, align : ^ImVec2, clip_rect : ^ImRect)
{
	// Hide anything after a '##' string
	text_display_end : ^u8 = FindRenderedTextEnd(text, text_end)
	text_len : i32 = cast(i32) (text_display_end - text)
	if text_len == 0 { return }

	g : ^ImGuiContext = GImGui^
	window : ^ImGuiWindow = g.CurrentWindow
	RenderTextClippedEx(window.DrawList, pos_min, pos_max, text, text_display_end, text_size_if_known, align, clip_rect)
	if g.LogEnabled { LogRenderedText(&pos_min, text, text_display_end) }
}

// Another overly complex function until we reorganize everything into a nice all-in-one helper.
// This is made more complex because we have dissociated the layout rectangle (pos_min..pos_max) which define _where_ the ellipsis is, from actual clipping of text and limit of the ellipsis display.
// This is because in the context of tabs we selectively hide part of the text when the Close Button appears, but we don't want the ellipsis to move.
RenderTextEllipsis :: proc(draw_list : ^ImDrawList, pos_min : ^ImVec2, pos_max : ^ImVec2, clip_max_x : f32, ellipsis_max_x : f32, text : ^u8, text_end_full : ^u8, text_size_if_known : ^ImVec2)
{
	g : ^ImGuiContext = GImGui^
	if text_end_full == nil { text_end_full = FindRenderedTextEnd(text) }
	text_size : ImVec2 = text_size_if_known ? text_size_if_known^ : CalcTextSize(text, text_end_full, false, 0.0)

	//draw_list->AddLine(ImVec2(pos_max.x, pos_min.y - 4), ImVec2(pos_max.x, pos_max.y + 4), IM_COL32(0, 0, 255, 255));
	//draw_list->AddLine(ImVec2(ellipsis_max_x, pos_min.y-2), ImVec2(ellipsis_max_x, pos_max.y+2), IM_COL32(0, 255, 0, 255));
	//draw_list->AddLine(ImVec2(clip_max_x, pos_min.y), ImVec2(clip_max_x, pos_max.y), IM_COL32(255, 0, 0, 255));
	// FIXME: We could technically remove (last_glyph->AdvanceX - last_glyph->X1) from text_size.x here and save a few pixels.
	if text_size.x > pos_max.x - pos_min.x {
		// Hello wo...
		// |       |   |
		// min   max   ellipsis_max
		//          <-> this is generally some padding value

		font : ^ImFont = draw_list._Data.Font
		font_size : f32 = draw_list._Data.FontSize
		font_scale : f32 = draw_list._Data.FontScale
		text_end_ellipsis : ^u8 = nil
		ellipsis_width : f32 = font.EllipsisWidth * font_scale

		// We can now claim the space between pos_max.x and ellipsis_max.x
		text_avail_width : f32 = ImMax((ImMax(pos_max.x, ellipsis_max_x) - ellipsis_width) - pos_min.x, 1.0)
		text_size_clipped_x : f32 = CalcTextSizeA(font, font_size, text_avail_width, 0.0, text, text_end_full, &text_end_ellipsis).x
		if text == text_end_ellipsis && text_end_ellipsis < text_end_full {
			// Always display at least 1 character if there's no room for character + ellipsis
			text_end_ellipsis = text + ImTextCountUtf8BytesFromChar(text, text_end_full)
			text_size_clipped_x = CalcTextSizeA(font, font_size, FLT_MAX, 0.0, text, text_end_ellipsis).x
		}
		for text_end_ellipsis > text && ImCharIsBlankA(text_end_ellipsis[-1]) {
			// Trim trailing space before ellipsis (FIXME: Supporting non-ascii blanks would be nice, for this we need a function to backtrack in UTF-8 text)
			post_decr(&text_end_ellipsis)
			text_size_clipped_x -= CalcTextSizeA(font, font_size, FLT_MAX, 0.0, text_end_ellipsis, text_end_ellipsis + 1).x; // Ascii blanks are always 1 byte
		}

		// Render text, render ellipsis
		RenderTextClippedEx(draw_list, pos_min, ImVec2(clip_max_x, pos_max.y), text, text_end_ellipsis, &text_size, ImVec2(0.0, 0.0))
		ellipsis_pos : ImVec2 = ImTrunc(ImVec2(pos_min.x + text_size_clipped_x, pos_min.y))
		if ellipsis_pos.x + ellipsis_width <= ellipsis_max_x { for i : i32 = 0; i < font.EllipsisCharCount; i, ellipsis_pos.x = i + 1, ellipsis_pos.x + font.EllipsisCharStep * font_scale { RenderChar(font, draw_list, font_size, ellipsis_pos, GetColorU32(ImGuiCol_.ImGuiCol_Text), font.EllipsisChar) } }
	}
	else {
		RenderTextClippedEx(draw_list, pos_min, ImVec2(clip_max_x, pos_max.y), text, text_end_full, &text_size, ImVec2(0.0, 0.0))
	}

	if g.LogEnabled { LogRenderedText(&pos_min, text, text_end_full) }
}

// Render a rectangle shaped with optional rounding and borders
RenderFrame :: proc(p_min : ImVec2, p_max : ImVec2, fill_col : ImU32, borders : bool, rounding : f32)
{
	g : ^ImGuiContext = GImGui^
	window : ^ImGuiWindow = g.CurrentWindow
	AddRectFilled(window.DrawList, p_min, p_max, fill_col, rounding)
	border_size : f32 = g.Style.FrameBorderSize
	if borders && border_size > 0.0 {
		AddRect(window.DrawList, p_min + ImVec2(1, 1), p_max + ImVec2(1, 1), GetColorU32(ImGuiCol_.ImGuiCol_BorderShadow), rounding, 0, border_size)
		AddRect(window.DrawList, p_min, p_max, GetColorU32(ImGuiCol_.ImGuiCol_Border), rounding, 0, border_size)
	}
}

RenderFrameBorder :: proc(p_min : ImVec2, p_max : ImVec2, rounding : f32)
{
	g : ^ImGuiContext = GImGui^
	window : ^ImGuiWindow = g.CurrentWindow
	border_size : f32 = g.Style.FrameBorderSize
	if border_size > 0.0 {
		AddRect(window.DrawList, p_min + ImVec2(1, 1), p_max + ImVec2(1, 1), GetColorU32(ImGuiCol_.ImGuiCol_BorderShadow), rounding, 0, border_size)
		AddRect(window.DrawList, p_min, p_max, GetColorU32(ImGuiCol_.ImGuiCol_Border), rounding, 0, border_size)
	}
}

// Navigation highlight
RenderNavCursor :: proc(bb : ^ImRect, id : ImGuiID, flags : ImGuiNavRenderCursorFlags)
{
	g : ^ImGuiContext = GImGui^
	if id != g.NavId { return }
	if !g.NavCursorVisible && !(flags & ImGuiNavRenderCursorFlags_.ImGuiNavRenderCursorFlags_AlwaysDraw) { return }
	if id == g.LastItemData.ID && (g.LastItemData.ItemFlags & ImGuiItemFlags_.ImGuiItemFlags_NoNav) { return }
	window : ^ImGuiWindow = g.CurrentWindow
	if window.DC.NavHideHighlightOneFrame { return }

	rounding : f32 = (flags & ImGuiNavRenderCursorFlags_.ImGuiNavRenderCursorFlags_NoRounding) ? 0.0 : g.Style.FrameRounding
	display_rect : ImRect = bb
	ClipWith(&display_rect, window.ClipRect)
	thickness : f32 = 2.0
	if ImGuiNavRenderCursorFlags_Compact : ^flags; ImGuiNavRenderCursorFlags_Compact {
		AddRect(window.DrawList, display_rect.Min, display_rect.Max, GetColorU32(ImGuiCol_.ImGuiCol_NavCursor), rounding, 0, thickness)
	}
	else {
		distance : f32 = 3.0 + thickness * 0.5
		Expand(&display_rect, ImVec2(distance, distance))
		fully_visible : bool = Contains(&window.ClipRect, display_rect)
		if !fully_visible { PushClipRect(window.DrawList, display_rect.Min, display_rect.Max) }
		AddRect(window.DrawList, display_rect.Min, display_rect.Max, GetColorU32(ImGuiCol_.ImGuiCol_NavCursor), rounding, 0, thickness)
		if !fully_visible { PopClipRect(window.DrawList) }
	}
}

RenderMouseCursor :: proc(base_pos : ImVec2, base_scale : f32, mouse_cursor : ImGuiMouseCursor, col_fill : ImU32, col_border : ImU32, col_shadow : ImU32)
{
	g : ^ImGuiContext = GImGui^
	if mouse_cursor <= ImGuiMouseCursor_.ImGuiMouseCursor_None || mouse_cursor >= ImGuiMouseCursor_.ImGuiMouseCursor_COUNT {
		// We intentionally accept out of bound values.mouse_cursor = ImGuiMouseCursor_.ImGuiMouseCursor_Arrow
	}
	font_atlas : ^ImFontAtlas = g.DrawListSharedData.Font.ContainerAtlas
	for viewport in g.Viewports {
		// We scale cursor with current viewport/monitor, however Windows 10 for its own hardware cursor seems to be using a different scale factor.
		offset : ImVec2; size : ImVec2; uv : [4]ImVec2
		if !GetMouseCursorTexData(font_atlas, mouse_cursor, &offset, &size, &uv[0], &uv[2]) { continue }
		pos : ImVec2 = base_pos - offset
		scale : f32 = base_scale * viewport.DpiScale
		if !Overlaps(&GetMainRect(viewport), ImRect(pos, pos + ImVec2(size.x + 2, size.y + 2) * scale)) { continue }
		draw_list : ^ImDrawList = GetForegroundDrawList(viewport)
		tex_id : ImTextureID = font_atlas.TexID
		PushTextureID(draw_list, tex_id)
		AddImage(draw_list, tex_id, pos + ImVec2(1, 0) * scale, pos + (ImVec2(1, 0) + size) * scale, uv[2], uv[3], col_shadow)
		AddImage(draw_list, tex_id, pos + ImVec2(2, 0) * scale, pos + (ImVec2(2, 0) + size) * scale, uv[2], uv[3], col_shadow)
		AddImage(draw_list, tex_id, pos, pos + size * scale, uv[2], uv[3], col_border)
		AddImage(draw_list, tex_id, pos, pos + size * scale, uv[0], uv[1], col_fill)
		PopTextureID(draw_list)
	}
}

//-----------------------------------------------------------------------------
// [SECTION] INITIALIZATION, SHUTDOWN
//-----------------------------------------------------------------------------

// Internal state access - if you want to share Dear ImGui state between modules (e.g. DLL) or allocate it yourself
// Note that we still point to some static data and members (such as GFontAtlas), so the state instance you end up using will point to the static data within its module
GetCurrentContext :: proc() -> ^ImGuiContext
{
	return GImGui
}

SetCurrentContext :: proc(ctx : ^ImGuiContext)
{
	when defined ( IMGUI_SET_CURRENT_CONTEXT_FUNC ) {
	IMGUI_SET_CURRENT_CONTEXT_FUNC(ctx); // For custom thread-based hackery you may want to have control over this.
	} else { // preproc else
	GImGui = ctx
	} // preproc endif
}

// Memory Allocators
// - Those functions are not reliant on the current context.
// - DLL users: heaps and globals are not shared across DLL boundaries! You will need to call SetCurrentContext() + SetAllocatorFunctions()
//   for each static/DLL boundary you are calling from. Read "Context and Memory Allocators" section of imgui.cpp for more details.
SetAllocatorFunctions :: proc(alloc_func : ImGuiMemAllocFunc, free_func : ImGuiMemFreeFunc, user_data : rawptr)
{
	GImAllocatorAllocFunc = alloc_func
	GImAllocatorFreeFunc = free_func
	GImAllocatorUserData = user_data
}

// This is provided to facilitate copying allocators from one static/DLL boundary to another (e.g. retrieve default allocator of your executable address space)
GetAllocatorFunctions :: proc(p_alloc_func : ^ImGuiMemAllocFunc, p_free_func : ^ImGuiMemFreeFunc, p_user_data : ^rawptr)
{
	p_alloc_func^ = GImAllocatorAllocFunc
	p_free_func^ = GImAllocatorFreeFunc
	p_user_data^ = GImAllocatorUserData
}

// Context creation and access
// - Each context create its own ImFontAtlas by default. You may instance one yourself and pass it to CreateContext() to share a font atlas between contexts.
// - DLL users: heaps and globals are not shared across DLL boundaries! You will need to call SetCurrentContext() + SetAllocatorFunctions()
//   for each static/DLL boundary you are calling from. Read "Context and Memory Allocators" section of imgui.cpp for details.
CreateContext :: proc(shared_font_atlas : ^ImFontAtlas) -> ^ImGuiContext
{
	prev_ctx : ^ImGuiContext = GetCurrentContext()
	ctx : ^ImGuiContext = IM_NEW(ImGuiContext)(shared_font_atlas)
	SetCurrentContext(ctx)
	Initialize()
	if prev_ctx != nil {
		// Restore previous context if any, else keep new one.
		SetCurrentContext(prev_ctx)
	}
	return ctx
}

// NULL = destroy current context
DestroyContext :: proc(ctx : ^ImGuiContext)
{
	prev_ctx : ^ImGuiContext = GetCurrentContext()
	if ctx == nil {
		//-V1051ctx = prev_ctx
	}
	SetCurrentContext(ctx)
	Shutdown()
	SetCurrentContext((prev_ctx != ctx) ? prev_ctx : nil)
	IM_DELETE(ctx)
}

// IMPORTANT: interactive elements requires a fixed ###xxx suffix, it must be same in ALL languages to allow for automation.
GLocalizationEntriesEnUS := [?]ImGuiLocEntry{
	{ImGuiLocKey.ImGuiLocKey_VersionStr, ")"},
	{ImGuiLocKey.ImGuiLocKey_TableSizeOne, "Size column to fit###SizeOne"},
	{ImGuiLocKey.ImGuiLocKey_TableSizeAllFit, "Size all columns to fit###SizeAll"},
	{ImGuiLocKey.ImGuiLocKey_TableSizeAllDefault, "Size all columns to default###SizeAll"},
	{ImGuiLocKey.ImGuiLocKey_TableResetOrder, "Reset order###ResetOrder"},
	{ImGuiLocKey.ImGuiLocKey_WindowingMainMenuBar, "(Main menu bar)"},
	{ImGuiLocKey.ImGuiLocKey_WindowingPopup, "(Popup)"},
	{ImGuiLocKey.ImGuiLocKey_WindowingUntitled, "(Untitled)"},
	{ImGuiLocKey.ImGuiLocKey_OpenLink_s, "Open '%s'"},
	{ImGuiLocKey.ImGuiLocKey_CopyLink, "Copy Link###CopyLink"},
	{ImGuiLocKey.ImGuiLocKey_DockingHideTabBar, "Hide tab bar###HideTabBar"},
	{ImGuiLocKey.ImGuiLocKey_DockingHoldShiftToDock, "Hold SHIFT to enable Docking window."},
	{ImGuiLocKey.ImGuiLocKey_DockingDragToUndockOrMoveNode, "Click and drag to move or undock whole node."},
}

ImGuiContext_init :: proc(this : ^ImGuiContext, shared_font_atlas : ^ImFontAtlas)
{
	this.IO.Ctx = this
	this.InputTextState.Ctx = this

	this.Initialized = false
	this.ConfigFlagsLastFrame = ImGuiConfigFlags_.ImGuiConfigFlags_None; this.ConfigFlagsCurrFrame = this.ConfigFlagsLastFrame
	this.FontAtlasOwnedByContext = shared_font_atlas ? false : true
	this.Font = nil
	this.CurrentDpiScale = 0.0; this.FontScale = this.CurrentDpiScale; this.FontBaseSize = this.FontScale; this.FontSize = this.FontBaseSize
	this.IO.Fonts = shared_font_atlas ? shared_font_atlas : IM_NEW(ImFontAtlas)()
	this.Time = 0.0
	this.FrameCount = 0
	this.FrameCountRendered = -1; this.FrameCountPlatformEnded = this.FrameCountRendered; this.FrameCountEnded = this.FrameCountPlatformEnded
	this.WithinEndChildID = 0
	this.WithinFrameScopeWithImplicitWindow = false; this.WithinFrameScope = this.WithinFrameScopeWithImplicitWindow
	this.GcCompactAll = false
	this.TestEngineHookItems = false
	this.TestEngine = nil
	memset(this.ContextName, 0, size_of(ContextName))

	this.InputEventsNextMouseSource = ImGuiMouseSource.ImGuiMouseSource_Mouse
	this.InputEventsNextEventId = 1

	this.WindowsActiveCount = 0
	this.CurrentWindow = nil
	this.HoveredWindow = nil
	this.HoveredWindowUnderMovingWindow = nil
	this.HoveredWindowBeforeClear = nil
	this.MovingWindow = nil
	this.WheelingWindow = nil
	this.WheelingWindowScrolledFrame = -1; this.WheelingWindowStartFrame = this.WheelingWindowScrolledFrame
	this.WheelingWindowReleaseTimer = 0.0

	this.DebugDrawIdConflicts = 0
	this.DebugHookIdInfo = 0
	this.HoveredIdPreviousFrame = 0; this.HoveredId = this.HoveredIdPreviousFrame
	this.HoveredIdPreviousFrameItemCount = 0
	this.HoveredIdAllowOverlap = false
	this.HoveredIdIsDisabled = false
	this.HoveredIdNotActiveTimer = 0.0; this.HoveredIdTimer = this.HoveredIdNotActiveTimer
	this.ItemUnclipByLog = false
	this.ActiveId = 0
	this.ActiveIdIsAlive = 0
	this.ActiveIdTimer = 0.0
	this.ActiveIdIsJustActivated = false
	this.ActiveIdAllowOverlap = false
	this.ActiveIdNoClearOnFocusLoss = false
	this.ActiveIdHasBeenPressedBefore = false
	this.ActiveIdHasBeenEditedBefore = false
	this.ActiveIdHasBeenEditedThisFrame = false
	this.ActiveIdFromShortcut = false
	this.ActiveIdClickOffset = ImVec2(-1, -1)
	this.ActiveIdWindow = nil
	this.ActiveIdSource = ImGuiInputSource.ImGuiInputSource_None
	this.ActiveIdMouseButton = -1
	this.ActiveIdPreviousFrame = 0
	this.ActiveIdPreviousFrameIsAlive = false
	this.ActiveIdPreviousFrameHasBeenEditedBefore = false
	this.ActiveIdPreviousFrameWindow = nil
	memset(&this.ActiveIdValueOnActivation, 0, size_of(ActiveIdValueOnActivation))
	this.LastActiveId = 0
	this.LastActiveIdTimer = 0.0

	this.LastKeyModsChangeFromNoneTime = -1.0; this.LastKeyModsChangeTime = this.LastKeyModsChangeFromNoneTime; this.LastKeyboardKeyPressTime = this.LastKeyModsChangeTime

	this.ActiveIdUsingNavDirMask = 0x00
	this.ActiveIdUsingAllKeyboardKeys = false

	this.CurrentFocusScopeId = 0
	this.CurrentItemFlags = ImGuiItemFlags_.ImGuiItemFlags_None
	this.DebugShowGroupRects = false

	this.CurrentViewport = nil
	this.MouseLastHoveredViewport = nil; this.MouseViewport = this.MouseLastHoveredViewport
	this.PlatformLastFocusedViewportId = 0
	this.PlatformWindowsCreatedCount = 0; this.ViewportCreatedCount = this.PlatformWindowsCreatedCount
	this.ViewportFocusedStampCount = 0

	this.NavCursorVisible = false
	this.NavHighlightItemUnderNav = false
	this.NavMousePosDirty = false
	this.NavIdIsAlive = false
	this.NavId = 0
	this.NavWindow = nil
	this.NavActivatePressedId = 0; this.NavActivateDownId = this.NavActivatePressedId; this.NavActivateId = this.NavActivateDownId; this.NavFocusScopeId = this.NavActivateId
	this.NavLayer = ImGuiNavLayer.ImGuiNavLayer_Main
	this.NavNextActivateId = 0
	this.NavNextActivateFlags = ImGuiActivateFlags_.ImGuiActivateFlags_None; this.NavActivateFlags = this.NavNextActivateFlags
	this.NavHighlightActivatedId = 0
	this.NavHighlightActivatedTimer = 0.0
	this.NavInputSource = ImGuiInputSource.ImGuiInputSource_Keyboard
	this.NavLastValidSelectionUserData = ImGuiSelectionUserData_Invalid
	this.NavCursorHideFrames = 0

	this.NavAnyRequest = false
	this.NavInitRequest = false
	this.NavInitRequestFromMove = false
	this.NavMoveSubmitted = false
	this.NavMoveScoringItems = false
	this.NavMoveForwardToNextFrame = false
	this.NavMoveFlags = ImGuiNavMoveFlags_.ImGuiNavMoveFlags_None
	this.NavMoveScrollFlags = ImGuiScrollFlags_.ImGuiScrollFlags_None
	this.NavMoveKeyMods = ImGuiKey.ImGuiMod_None
	this.NavMoveClipDir = ImGuiDir.ImGuiDir_None; this.NavMoveDirForDebug = this.NavMoveClipDir; this.NavMoveDir = this.NavMoveDirForDebug
	this.NavScoringDebugCount = 0
	this.NavTabbingDir = 0
	this.NavTabbingCounter = 0

	this.NavJustMovedToFocusScopeId = 0; this.NavJustMovedToId = this.NavJustMovedToFocusScopeId; this.NavJustMovedFromFocusScopeId = this.NavJustMovedToId
	this.NavJustMovedToKeyMods = ImGuiKey.ImGuiMod_None
	this.NavJustMovedToIsTabbing = false
	this.NavJustMovedToHasSelectionData = false

	// All platforms use Ctrl+Tab but Ctrl<>Super are swapped on Mac...
	// FIXME: Because this value is stored, it annoyingly interfere with toggling io.ConfigMacOSXBehaviors updating this..
	this.ConfigNavWindowingKeyNext = this.IO.ConfigMacOSXBehaviors ? (ImGuiKey.ImGuiMod_Super | ImGuiKey.ImGuiKey_Tab) : (ImGuiKey.ImGuiMod_Ctrl | ImGuiKey.ImGuiKey_Tab)
	this.ConfigNavWindowingKeyPrev = this.IO.ConfigMacOSXBehaviors ? (ImGuiKey.ImGuiMod_Super | ImGuiKey.ImGuiMod_Shift | ImGuiKey.ImGuiKey_Tab) : (ImGuiKey.ImGuiMod_Ctrl | ImGuiKey.ImGuiMod_Shift | ImGuiKey.ImGuiKey_Tab)
	this.NavWindowingListWindow = nil; this.NavWindowingTargetAnim = this.NavWindowingListWindow; this.NavWindowingTarget = this.NavWindowingTargetAnim
	this.NavWindowingHighlightAlpha = 0.0; this.NavWindowingTimer = this.NavWindowingHighlightAlpha
	this.NavWindowingToggleLayer = false
	this.NavWindowingToggleKey = ImGuiKey.ImGuiKey_None

	this.DimBgRatio = 0.0

	this.DragDropWithinTarget = false; this.DragDropWithinSource = this.DragDropWithinTarget; this.DragDropActive = this.DragDropWithinSource
	this.DragDropSourceFlags = ImGuiDragDropFlags_.ImGuiDragDropFlags_None
	this.DragDropSourceFrameCount = -1
	this.DragDropMouseButton = -1
	this.DragDropTargetId = 0
	this.DragDropAcceptFlags = ImGuiDragDropFlags_.ImGuiDragDropFlags_None
	this.DragDropAcceptIdCurrRectSurface = 0.0
	this.DragDropAcceptIdCurr = 0; this.DragDropAcceptIdPrev = this.DragDropAcceptIdCurr
	this.DragDropAcceptFrameCount = -1
	this.DragDropHoldJustPressedId = 0
	memset(this.DragDropPayloadBufLocal, 0, size_of(DragDropPayloadBufLocal))

	this.ClipperTempDataStacked = 0

	this.CurrentTable = nil
	this.TablesTempDataStacked = 0
	this.CurrentTabBar = nil
	this.CurrentMultiSelect = nil
	this.MultiSelectTempDataStacked = 0

	this.HoverWindowUnlockedStationaryId = 0; this.HoverItemUnlockedStationaryId = this.HoverWindowUnlockedStationaryId; this.HoverItemDelayIdPreviousFrame = this.HoverItemUnlockedStationaryId; this.HoverItemDelayId = this.HoverItemDelayIdPreviousFrame
	this.HoverItemDelayClearTimer = 0.0; this.HoverItemDelayTimer = this.HoverItemDelayClearTimer

	this.MouseCursor = ImGuiMouseCursor_.ImGuiMouseCursor_Arrow
	this.MouseStationaryTimer = 0.0

	this.TempInputId = 0
	memset(&this.DataTypeZeroValue, 0, size_of(DataTypeZeroValue))
	this.BeginComboDepth = 0; this.BeginMenuDepth = this.BeginComboDepth
	this.ColorEditOptions = ImGuiColorEditFlags_.ImGuiColorEditFlags_DefaultOptions_
	this.ColorEditSavedID = 0; this.ColorEditCurrentID = this.ColorEditSavedID
	this.ColorEditSavedSat = 0.0; this.ColorEditSavedHue = this.ColorEditSavedSat
	this.ColorEditSavedColor = 0
	this.WindowResizeRelativeMode = false
	this.ScrollbarSeekMode = 0
	this.ScrollbarClickDeltaToGrabCenter = 0.0
	this.SliderGrabClickOffset = 0.0
	this.SliderCurrentAccum = 0.0
	this.SliderCurrentAccumDirty = false
	this.DragCurrentAccumDirty = false
	this.DragCurrentAccum = 0.0
	this.DragSpeedDefaultRatio = 1.0 / 100.0
	this.DisabledAlphaBackup = 0.0
	this.DisabledStackSize = 0
	this.TooltipOverrideCount = 0
	this.TooltipPreviousWindow = nil

	this.PlatformImeData.InputPos = ImVec2(0.0, 0.0)
	this.PlatformImeDataPrev.InputPos = ImVec2(-1.0, -1.0); // Different to ensure initial submission
	this.PlatformImeViewport = 0

	this.DockNodeWindowMenuHandler = nil

	this.SettingsLoaded = false
	this.SettingsDirtyTimer = 0.0
	this.HookIdNext = 0

	memset(this.LocalizationTable, 0, size_of(LocalizationTable))

	this.LogEnabled = false
	this.LogFlags = ImGuiLogFlags_.ImGuiLogFlags_None
	this.LogWindow = nil
	this.LogNextSuffix = nil; this.LogNextPrefix = this.LogNextSuffix
	this.LogFile = nil
	this.LogLinePosY = FLT_MAX
	this.LogLineFirstItem = false
	this.LogDepthRef = 0
	this.LogDepthToExpandDefault = 2; this.LogDepthToExpand = this.LogDepthToExpandDefault

	this.ErrorCallback = nil
	this.ErrorCallbackUserData = nil
	this.ErrorFirst = true
	this.ErrorCountCurrentFrame = 0
	this.StackSizesInBeginForCurrentWindow = nil

	this.DebugDrawIdConflictsCount = 0
	this.DebugLogFlags = ImGuiDebugLogFlags_.ImGuiDebugLogFlags_EventError | ImGuiDebugLogFlags_.ImGuiDebugLogFlags_OutputToTTY
	this.DebugLocateId = 0
	this.DebugLogSkippedErrors = 0
	this.DebugLogAutoDisableFlags = ImGuiDebugLogFlags_.ImGuiDebugLogFlags_None
	this.DebugLogAutoDisableFrames = 0
	this.DebugLocateFrames = 0
	this.DebugBeginReturnValueCullDepth = -1
	this.DebugItemPickerActive = false
	this.DebugItemPickerMouseButton = ImGuiMouseButton_.ImGuiMouseButton_Left
	this.DebugItemPickerBreakId = 0
	this.DebugFlashStyleColorTime = 0.0
	this.DebugFlashStyleColorIdx = ImGuiCol_.ImGuiCol_COUNT
	this.DebugHoveredDockNode = nil

	// Same as DebugBreakClearData(). Those fields are scattered in their respective subsystem to stay in hot-data locations
	this.DebugBreakInWindow = 0
	this.DebugBreakInTable = 0
	this.DebugBreakInLocateId = false
	this.DebugBreakKeyChord = ImGuiKey.ImGuiKey_Pause
	this.DebugBreakInShortcutRouting = ImGuiKey.ImGuiKey_None

	memset(this.FramerateSecPerFrame, 0, size_of(FramerateSecPerFrame))
	this.FramerateSecPerFrameCount = 0; this.FramerateSecPerFrameIdx = this.FramerateSecPerFrameCount
	this.FramerateSecPerFrameAccum = 0.0
	this.WantTextInputNextFrame = -1; this.WantCaptureKeyboardNextFrame = this.WantTextInputNextFrame; this.WantCaptureMouseNextFrame = this.WantCaptureKeyboardNextFrame
	memset(this.TempKeychordName, 0, size_of(TempKeychordName))
}

// Init
Initialize :: proc()
{
	g : ^ImGuiContext = GImGui^
	IM_ASSERT(!g.Initialized && !g.SettingsLoaded)

	// Add .ini handle for ImGuiWindow and ImGuiTable types
	{
	ini_handler : ImGuiSettingsHandler
	ini_handler.TypeName = "Window"
	ini_handler.TypeHash = ImHashStr("Window")
	ini_handler.ClearAllFn = WindowSettingsHandler_ClearAll
	ini_handler.ReadOpenFn = WindowSettingsHandler_ReadOpen
	ini_handler.ReadLineFn = WindowSettingsHandler_ReadLine
	ini_handler.ApplyAllFn = WindowSettingsHandler_ApplyAll
	ini_handler.WriteAllFn = WindowSettingsHandler_WriteAll
	AddSettingsHandler(&ini_handler)
	}
	TableSettingsAddSettingsHandler()

	// Setup default localization table
	LocalizeRegisterEntries(GLocalizationEntriesEnUS, IM_ARRAYSIZE(GLocalizationEntriesEnUS))

	// Setup default ImGuiPlatformIO clipboard/IME handlers.
	g.PlatformIO.Platform_GetClipboardTextFn = Platform_GetClipboardTextFn_DefaultImpl; // Platform dependent default implementations
	g.PlatformIO.Platform_SetClipboardTextFn = Platform_SetClipboardTextFn_DefaultImpl
	g.PlatformIO.Platform_OpenInShellFn = Platform_OpenInShellFn_DefaultImpl
	g.PlatformIO.Platform_SetImeDataFn = Platform_SetImeDataFn_DefaultImpl

	// Create default viewport
	viewport : ^ImGuiViewportP = IM_NEW(this.ImGuiViewportP)()
	viewport.ID = IMGUI_VIEWPORT_DEFAULT_ID
	viewport.Idx = 0
	viewport.PlatformWindowCreated = true
	viewport.Flags = ImGuiViewportFlags_.ImGuiViewportFlags_OwnedByApp
	push_back(&g.Viewports, viewport)
	resize(&g.TempBuffer, 1024 * 3 + 1, 0)
	post_incr(&g.ViewportCreatedCount)
	push_back(&g.PlatformIO.Viewports, g.Viewports[0])

	// Build KeysMayBeCharInput[] lookup table (1 bool per named key)
	for key : ImGuiKey = ImGuiKey.ImGuiKey_NamedKey_BEGIN; key < ImGuiKey.ImGuiKey_NamedKey_END; key = cast(ImGuiKey) (key + 1) { if (key >= ImGuiKey.ImGuiKey_0 && key <= ImGuiKey.ImGuiKey_9) || (key >= ImGuiKey.ImGuiKey_A && key <= ImGuiKey.ImGuiKey_Z) || (key >= ImGuiKey.ImGuiKey_Keypad0 && key <= ImGuiKey.ImGuiKey_Keypad9) || key == ImGuiKey.ImGuiKey_Tab || key == ImGuiKey.ImGuiKey_Space || key == ImGuiKey.ImGuiKey_Apostrophe || key == ImGuiKey.ImGuiKey_Comma || key == ImGuiKey.ImGuiKey_Minus || key == ImGuiKey.ImGuiKey_Period || key == ImGuiKey.ImGuiKey_Slash || key == ImGuiKey.ImGuiKey_Semicolon || key == ImGuiKey.ImGuiKey_Equal || key == ImGuiKey.ImGuiKey_LeftBracket || key == ImGuiKey.ImGuiKey_RightBracket || key == ImGuiKey.ImGuiKey_GraveAccent || key == ImGuiKey.ImGuiKey_KeypadDecimal || key == ImGuiKey.ImGuiKey_KeypadDivide || key == ImGuiKey.ImGuiKey_KeypadMultiply || key == ImGuiKey.ImGuiKey_KeypadSubtract || key == ImGuiKey.ImGuiKey_KeypadAdd || key == ImGuiKey.ImGuiKey_KeypadEqual { SetBit(&g.KeysMayBeCharInput, key) } }

	when defined ( IMGUI_HAS_DOCK ) {
	// Initialize Docking
	DockContextInitialize(&g)
	} // preproc endif

	g.Initialized = true
}

// Since 1.60 this is a _private_ function. You can call DestroyContext() to destroy the context created by CreateContext().
// This function is merely here to free heap allocations.
Shutdown :: proc()
{
	g : ^ImGuiContext = GImGui^
	IM_ASSERT_USER_ERROR(g.IO.BackendPlatformUserData == nil, "Forgot to shutdown Platform backend?")
	IM_ASSERT_USER_ERROR(g.IO.BackendRendererUserData == nil, "Forgot to shutdown Renderer backend?")

	// The fonts atlas can be used prior to calling NewFrame(), so we clear it even if g.Initialized is FALSE (which would happen if we never called NewFrame)
	if g.IO.Fonts && g.FontAtlasOwnedByContext {
		g.IO.Fonts.Locked = false
		IM_DELETE(g.IO.Fonts)
	}
	g.IO.Fonts = nil
	clear(&g.DrawListSharedData.TempBuffer)

	// Cleanup of other data are conditional on actually having initialized Dear ImGui.
	if !g.Initialized { return }

	// Save settings (unless we haven't attempted to load them: CreateContext/DestroyContext without a call to NewFrame shouldn't save an empty file)
	if g.SettingsLoaded && g.IO.IniFilename != nil { SaveIniSettingsToDisk(g.IO.IniFilename) }

	// Destroy platform windows
	DestroyPlatformWindows()

	// Shutdown extensions
	DockContextShutdown(&g)

	CallContextHooks(&g, ImGuiContextHookType.ImGuiContextHookType_Shutdown)

	// Clear everything else
	clear_delete(&g.Windows)
	clear(&g.WindowsFocusOrder)
	clear(&g.WindowsTempSortBuffer)
	g.CurrentWindow = nil
	clear(&g.CurrentWindowStack)
	Clear(&g.WindowsById)
	g.NavWindow = nil
	g.HoveredWindowUnderMovingWindow = nil; g.HoveredWindow = g.HoveredWindowUnderMovingWindow
	g.ActiveIdPreviousFrameWindow = nil; g.ActiveIdWindow = g.ActiveIdPreviousFrameWindow
	g.MovingWindow = nil

	Clear(&g.KeysRoutingTable)

	clear(&g.ColorStack)
	clear(&g.StyleVarStack)
	clear(&g.FontStack)
	clear(&g.OpenPopupStack)
	clear(&g.BeginPopupStack)
	clear(&g.TreeNodeStack)

	g.MouseLastHoveredViewport = nil; g.MouseViewport = g.MouseLastHoveredViewport; g.CurrentViewport = g.MouseViewport
	clear_delete(&g.Viewports)

	Clear(&g.TabBars)
	clear(&g.CurrentTabBarStack)
	clear(&g.ShrinkWidthBuffer)

	clear_destruct(&g.ClipperTempData)

	Clear(&g.Tables)
	clear_destruct(&g.TablesTempData)
	clear(&g.DrawChannelsTempMergeBuffer)

	Clear(&g.MultiSelectStorage)
	clear_destruct(&g.MultiSelectTempData)

	clear(&g.ClipboardHandlerData)
	clear(&g.MenusIdSubmittedThisFrame)
	ClearFreeMemory(&g.InputTextState)
	ClearFreeMemory(&g.InputTextDeactivatedState)

	clear(&g.SettingsWindows)
	clear(&g.SettingsHandlers)

	if g.LogFile {
		when ! defined ( IMGUI_DISABLE_TTY_FUNCTIONS ) {
		if g.LogFile != stdout {} // preproc endifImFileClose(g.LogFile)
		}
		g.LogFile = nil
	}
	clear(&g.LogBuffer)
	clear(&g.DebugLogBuf)
	clear(&g.DebugLogIndex)

	g.Initialized = false
}

// Generic context hooks
// No specific ordering/dependency support, will see as needed
AddContextHook :: proc(ctx : ^ImGuiContext, hook : ^ImGuiContextHook) -> ImGuiID
{
	g : ^ImGuiContext = ctx^
	IM_ASSERT(hook.Callback != nil && hook.HookId == 0 && hook.Type != ImGuiContextHookType.ImGuiContextHookType_PendingRemoval_)
	push_back(&g.Hooks, hook^)
	back(&g.Hooks).HookId = pre_incr(&g.HookIdNext)
	return g.HookIdNext
}

// Deferred removal, avoiding issue with changing vector while iterating it
RemoveContextHook :: proc(ctx : ^ImGuiContext, hook_id : ImGuiID)
{
	g : ^ImGuiContext = ctx^
	IM_ASSERT(hook_id != 0)
	for hook in g.Hooks { if hook.HookId == hook_id { hook.Type = ImGuiContextHookType.ImGuiContextHookType_PendingRemoval_ } }
}

// Call context hooks (used by e.g. test engine)
// We assume a small number of hooks so all stored in same array
CallContextHooks :: proc(ctx : ^ImGuiContext, hook_type : ImGuiContextHookType)
{
	g : ^ImGuiContext = ctx^
	for hook in g.Hooks { if hook.Type == hook_type { Callback(&hook, &g, &hook) } }
}

//-----------------------------------------------------------------------------
// [SECTION] MAIN CODE (most of the code! lots of stuff, needs tidying up!)
//-----------------------------------------------------------------------------

// ImGuiWindow is mostly a dumb struct. It merely has a constructor and a few helper methods
ImGuiWindow_init :: proc(this : ^ImGuiWindow, ctx : ^ImGuiContext, name : ^u8)
{
	init(&this.DrawListInst, nil)
	memset(this, 0, size_of(this))
	this.Ctx = ctx
	this.Name = ImStrdup(name)
	this.NameBufLen = cast(i32) strlen(name) + 1
	this.ID = ImHashStr(name)
	push_back(&this.IDStack, this.ID)
	this.ViewportAllowPlatformMonitorExtend = -1
	this.ViewportPos = ImVec2(FLT_MAX, FLT_MAX)
	this.MoveId = GetID("#MOVE")
	this.TabId = GetID("#TAB")
	this.ScrollTarget = ImVec2(FLT_MAX, FLT_MAX)
	this.ScrollTargetCenterRatio = ImVec2(0.5, 0.5)
	this.AutoFitFramesY = -1; this.AutoFitFramesX = this.AutoFitFramesY
	this.AutoPosLastDirection = ImGuiDir.ImGuiDir_None
	this.SetWindowDockAllowFlags = 0; this.SetWindowCollapsedAllowFlags = this.SetWindowDockAllowFlags; this.SetWindowSizeAllowFlags = this.SetWindowCollapsedAllowFlags; this.SetWindowPosAllowFlags = this.SetWindowSizeAllowFlags
	this.SetWindowPosPivot = ImVec2(FLT_MAX, FLT_MAX); this.SetWindowPosVal = this.SetWindowPosPivot
	this.LastFrameActive = -1
	this.LastFrameJustFocused = -1
	this.LastTimeActive = -1.0
	this.FontDpiScale = 1.0; this.FontWindowScale = this.FontDpiScale
	this.SettingsOffset = -1
	this.DockOrder = -1
	this.DrawList = &this.DrawListInst
	this.DrawList._OwnerName = this.Name
	this.DrawList._Data = &this.Ctx.DrawListSharedData
	this.NavPreferredScoringPosRel[1] = ImVec2(FLT_MAX, FLT_MAX); this.NavPreferredScoringPosRel[0] = this.NavPreferredScoringPosRel[1]
	ImGuiWindowClass()
}

ImGuiWindow_deinit :: proc(this : ^ImGuiWindow)
{
	IM_ASSERT(this.DrawList == &this.DrawListInst)
	IM_DELETE(this.Name)
	clear_destruct(&this.ColumnsStorage)
}

// For use with io.ConfigDockingTransparentPayload. Apply to Viewport _or_ WindowBg in host viewport.

//-------------------------------------------------------------------------
// [SECTION] FORWARD DECLARATIONS
//-------------------------------------------------------------------------

SetCurrentWindow :: proc(window : ^ImGuiWindow)
{
	g : ^ImGuiContext = GImGui^
	g.CurrentWindow = window
	g.StackSizesInBeginForCurrentWindow = g.CurrentWindow ? &back(&g.CurrentWindowStack).StackSizesInBegin : nil
	g.CurrentTable = window && window.DC.CurrentTableIdx != -1 ? GetByIndex(&g.Tables, window.DC.CurrentTableIdx) : nil
	if window {
		g.DrawListSharedData.FontSize = CalcFontSize(window); g.FontSize = g.DrawListSharedData.FontSize
		g.DrawListSharedData.FontScale = g.FontSize / g.Font.FontSize; g.FontScale = g.DrawListSharedData.FontScale
		NavUpdateCurrentWindowIsScrollPushableX()
	}
}

// Garbage collection
GcCompactTransientMiscBuffers :: proc()
{
	g : ^ImGuiContext = GImGui^
	clear(&g.ItemFlagsStack)
	clear(&g.GroupStack)
	g.MultiSelectTempDataStacked = 0
	clear_destruct(&g.MultiSelectTempData)
	TableGcCompactSettings()
}

// Free up/compact internal window buffers, we can use this when a window becomes unused.
// Not freed:
// - ImGuiWindow, ImGuiWindowSettings, Name, StateStorage, ColumnsStorage (may hold useful data)
// This should have no noticeable visual effect. When the window reappear however, expect new allocation/buffer growth/copy cost.
GcCompactTransientWindowBuffers :: proc(window : ^ImGuiWindow)
{
	window.MemoryCompacted = true
	window.MemoryDrawListIdxCapacity = window.DrawList.IdxBuffer.Capacity
	window.MemoryDrawListVtxCapacity = window.DrawList.VtxBuffer.Capacity
	clear(&window.IDStack)
	_ClearFreeMemory(window.DrawList)
	clear(&window.DC.ChildWindows)
	clear(&window.DC.ItemWidthStack)
	clear(&window.DC.TextWrapPosStack)
}

GcAwakeTransientWindowBuffers :: proc(window : ^ImGuiWindow)
{
	// We stored capacity of the ImDrawList buffer to reduce growth-caused allocation/copy when awakening.
	// The other buffers tends to amortize much faster.
	window.MemoryCompacted = false
	reserve(&window.DrawList.IdxBuffer, window.MemoryDrawListIdxCapacity)
	reserve(&window.DrawList.VtxBuffer, window.MemoryDrawListVtxCapacity)
	window.MemoryDrawListVtxCapacity = 0; window.MemoryDrawListIdxCapacity = window.MemoryDrawListVtxCapacity
}

SetActiveID :: proc(id : ImGuiID, window : ^ImGuiWindow)
{
	g : ^ImGuiContext = GImGui^

	// Clear previous active id
	if g.ActiveId != 0 {
		// While most behaved code would make an effort to not steal active id during window move/drag operations,
		// we at least need to be resilient to it. Canceling the move is rather aggressive and users of 'master' branch
		// may prefer the weird ill-defined half working situation ('docking' did assert), so may need to rework that.
		if g.MovingWindow != nil && g.ActiveId == g.MovingWindow.MoveId {
			IMGUI_DEBUG_LOG_ACTIVEID("SetActiveID() cancel MovingWindow\n")
			g.MovingWindow = nil
		}

		// This could be written in a more general way (e.g associate a hook to ActiveId),
		// but since this is currently quite an exception we'll leave it as is.
		// One common scenario leading to this is: pressing Key ->NavMoveRequestApplyResult() -> ClearActiveID()
		if g.InputTextState.ID == g.ActiveId { InputTextDeactivateHook(g.ActiveId) }
	}

	// Set active id
	g.ActiveIdIsJustActivated = (g.ActiveId != id)
	if g.ActiveIdIsJustActivated {
		IMGUI_DEBUG_LOG_ACTIVEID("SetActiveID() old:0x%08X (window \"%s\") -> new:0x%08X (window \"%s\")\n", g.ActiveId, g.ActiveIdWindow ? g.ActiveIdWindow.Name : "", id, window ? window.Name : "")
		g.ActiveIdTimer = 0.0
		g.ActiveIdHasBeenPressedBefore = false
		g.ActiveIdHasBeenEditedBefore = false
		g.ActiveIdMouseButton = -1
		if id != 0 {
			g.LastActiveId = id
			g.LastActiveIdTimer = 0.0
		}
	}
	g.ActiveId = id
	g.ActiveIdAllowOverlap = false
	g.ActiveIdNoClearOnFocusLoss = false
	g.ActiveIdWindow = window
	g.ActiveIdHasBeenEditedThisFrame = false
	g.ActiveIdFromShortcut = false
	if id {
		g.ActiveIdIsAlive = id
		g.ActiveIdSource = (g.NavActivateId == id || g.NavJustMovedToId == id) ? g.NavInputSource : ImGuiInputSource.ImGuiInputEventType_Mouse
		IM_ASSERT(g.ActiveIdSource != ImGuiInputSource.ImGuiInputSource_None)
	}

	// Clear declaration of inputs claimed by the widget
	// (Please note that this is WIP and not all keys/inputs are thoroughly declared by all widgets yet)
	g.ActiveIdUsingNavDirMask = 0x00
	g.ActiveIdUsingAllKeyboardKeys = false
}

ClearActiveID :: proc()
{
	SetActiveID(0, nil); // g.ActiveId = 0;
}

SetHoveredID :: proc(id : ImGuiID)
{
	g : ^ImGuiContext = GImGui^
	g.HoveredId = id
	g.HoveredIdAllowOverlap = false
	if id != 0 && g.HoveredIdPreviousFrame != id { g.HoveredIdNotActiveTimer = 0.0; g.HoveredIdTimer = g.HoveredIdNotActiveTimer }
}

GetHoveredID :: proc() -> ImGuiID
{
	g : ^ImGuiContext = GImGui^
	return g.HoveredId ? g.HoveredId : g.HoveredIdPreviousFrame
}

// Mark data associated to given item as "edited", used by IsItemDeactivatedAfterEdit() function.
MarkItemEdited :: proc(id : ImGuiID)
{
	// This marking is to be able to provide info for IsItemDeactivatedAfterEdit().
	// ActiveId might have been released by the time we call this (as in the typical press/release button behavior) but still need to fill the data.
	g : ^ImGuiContext = GImGui^
	if g.LastItemData.ItemFlags & ImGuiItemFlagsPrivate_.ImGuiItemFlags_NoMarkEdited { return }
	if g.ActiveId == id || g.ActiveId == 0 {
		g.ActiveIdHasBeenEditedThisFrame = true
		g.ActiveIdHasBeenEditedBefore = true
	}

	// We accept a MarkItemEdited() on drag and drop targets (see https://github.com/ocornut/imgui/issues/1875#issuecomment-978243343)
	// We accept 'ActiveIdPreviousFrame == id' for InputText() returning an edit after it has been taken ActiveId away (#4714)
	IM_ASSERT(g.DragDropActive || g.ActiveId == id || g.ActiveId == 0 || g.ActiveIdPreviousFrame == id || (g.CurrentMultiSelect != nil && g.BoxSelectState.IsActive))

	//IM_ASSERT(g.CurrentWindow->DC.LastItemId == id);
	g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_.ImGuiItemStatusFlags_Edited
}

IsWindowContentHoverable :: proc(window : ^ImGuiWindow, flags : ImGuiHoveredFlags) -> bool
{
	// An active popup disable hovering on other windows (apart from its own children)
	// FIXME-OPT: This could be cached/stored within the window.
	g : ^ImGuiContext = GImGui^
	if g.NavWindow { if focused_root_window : ^ImGuiWindow = g.NavWindow.RootWindowDockTree; focused_root_window { if focused_root_window.WasActive && focused_root_window != window.RootWindowDockTree {
	// For the purpose of those flags we differentiate "standard popup" from "modal popup"
	// NB: The 'else' is important because Modal windows are also Popups.
	want_inhibit : bool = false
	if focused_root_window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_Modal { want_inhibit = true }
	else if (focused_root_window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_Popup) && !(flags & ImGuiHoveredFlags_.ImGuiHoveredFlags_AllowWhenBlockedByPopup) { want_inhibit = true }

	// Inhibit hover unless the window is within the stack of our modal/popup
	if want_inhibit { if !IsWindowWithinBeginStackOf(window.RootWindow, focused_root_window) { return false } }
} } }

	// Filter by viewport
	if window.Viewport != g.MouseViewport { if g.MovingWindow == nil || window.RootWindowDockTree != g.MovingWindow.RootWindowDockTree { return false } }

	return true
}

CalcDelayFromHoveredFlags :: #force_inline proc(flags : ImGuiHoveredFlags) -> f32
{
	g : ^ImGuiContext = GImGui^
	if ImGuiHoveredFlags_DelayNormal : ^flags; ImGuiHoveredFlags_DelayNormal { return g.Style.HoverDelayNormal }
	if ImGuiHoveredFlags_DelayShort : ^flags; ImGuiHoveredFlags_DelayShort { return g.Style.HoverDelayShort }
	return 0.0
}

ApplyHoverFlagsForTooltip :: proc(user_flags : ImGuiHoveredFlags, shared_flags : ImGuiHoveredFlags) -> ImGuiHoveredFlags
{
	// Allow instance flags to override shared flags
	if user_flags & (ImGuiHoveredFlags_.ImGuiHoveredFlags_DelayNone | ImGuiHoveredFlags_.ImGuiHoveredFlags_DelayShort | ImGuiHoveredFlags_.ImGuiHoveredFlags_DelayNormal) { shared_flags &= !(ImGuiHoveredFlags_.ImGuiHoveredFlags_DelayNone | ImGuiHoveredFlags_.ImGuiHoveredFlags_DelayShort | ImGuiHoveredFlags_.ImGuiHoveredFlags_DelayNormal) }
	return user_flags | shared_flags
}

// Item/Widgets Utilities and Query Functions
// - Most of the functions are referring to the previous Item that has been submitted.
// - See Demo Window under "Widgets->Querying Status" for an interactive visualization of most of those functions.
// is the last item hovered? (and usable, aka not blocked by a popup, etc.). See ImGuiHoveredFlags for more options.
// This is roughly matching the behavior of internal-facing ItemHoverable()
// - we allow hovering to be true when ActiveId==window->MoveID, so that clicking on non-interactive items such as a Text() item still returns true with IsItemHovered()
// - this should work even for non-interactive items that have no ID, so we cannot use LastItemId
IsItemHovered :: proc(flags : ImGuiHoveredFlags) -> bool
{
	g : ^ImGuiContext = GImGui^
	window : ^ImGuiWindow = g.CurrentWindow
	IM_ASSERT_USER_ERROR((flags & !ImGuiHoveredFlagsPrivate_.ImGuiHoveredFlags_AllowedMaskForIsItemHovered) == 0, "Invalid flags for IsItemHovered()!")

	if g.NavHighlightItemUnderNav && g.NavCursorVisible && !(flags & ImGuiHoveredFlags_.ImGuiHoveredFlags_NoNavOverride) {
		if !IsItemFocused() { return false }
		if (g.LastItemData.ItemFlags & ImGuiItemFlagsPrivate_.ImGuiItemFlags_Disabled) && !(flags & ImGuiHoveredFlags_.ImGuiHoveredFlags_AllowWhenDisabled) { return false }

		if ImGuiHoveredFlags_ForTooltip : ^flags; ImGuiHoveredFlags_ForTooltip { flags = ApplyHoverFlagsForTooltip(flags, g.Style.HoverFlagsForTooltipNav) }
	}
	else {
		// Test for bounding box overlap, as updated as ItemAdd()
		status_flags : ImGuiItemStatusFlags = g.LastItemData.StatusFlags
		if !(status_flags & ImGuiItemStatusFlags_.ImGuiItemStatusFlags_HoveredRect) { return false }

		if ImGuiHoveredFlags_ForTooltip : ^flags; ImGuiHoveredFlags_ForTooltip { flags = ApplyHoverFlagsForTooltip(flags, g.Style.HoverFlagsForTooltipMouse) }

		// Done with rectangle culling so we can perform heavier checks now
		// Test if we are hovering the right window (our window could be behind another window)
		// [2021/03/02] Reworked / reverted the revert, finally. Note we want e.g. BeginGroup/ItemAdd/EndGroup to work as well. (#3851)
		// [2017/10/16] Reverted commit 344d48be3 and testing RootWindow instead. I believe it is correct to NOT test for RootWindow but this leaves us unable
		// to use IsItemHovered() after EndChild() itself. Until a solution is found I believe reverting to the test from 2017/09/27 is safe since this was
		// the test that has been running for a long while.
		if g.HoveredWindow != window && (status_flags & ImGuiItemStatusFlags_.ImGuiItemStatusFlags_HoveredWindow) == 0 { if (flags & ImGuiHoveredFlags_.ImGuiHoveredFlags_AllowWhenOverlappedByWindow) == 0 { return false } }

		// Test if another item is active (e.g. being dragged)
		id : ImGuiID = g.LastItemData.ID
		if (flags & ImGuiHoveredFlags_.ImGuiHoveredFlags_AllowWhenBlockedByActiveItem) == 0 { if g.ActiveId != 0 && g.ActiveId != id && !g.ActiveIdAllowOverlap { if g.ActiveId != window.MoveId && g.ActiveId != window.TabId { return false } } }

		// Test if interactions on this window are blocked by an active popup or modal.
		// The ImGuiHoveredFlags_AllowWhenBlockedByPopup flag will be tested here.
		if !IsWindowContentHoverable(window, flags) && !(g.LastItemData.ItemFlags & ImGuiItemFlagsPrivate_.ImGuiItemFlags_NoWindowHoverableCheck) { return false }

		// Test if the item is disabled
		if (g.LastItemData.ItemFlags & ImGuiItemFlagsPrivate_.ImGuiItemFlags_Disabled) && !(flags & ImGuiHoveredFlags_.ImGuiHoveredFlags_AllowWhenDisabled) { return false }

		// Special handling for calling after Begin() which represent the title bar or tab.
		// When the window is skipped/collapsed (SkipItems==true) that last item (always ->MoveId submitted by Begin)
		// will never be overwritten so we need to detect the case.
		if id == window.MoveId && window.WriteAccessed { return false }

		// Test if using AllowOverlap and overlapped
		if (g.LastItemData.ItemFlags & ImGuiItemFlagsPrivate_.ImGuiItemFlags_AllowOverlap) && id != 0 { if (flags & ImGuiHoveredFlags_.ImGuiHoveredFlags_AllowWhenOverlappedByItem) == 0 { if g.HoveredIdPreviousFrame != g.LastItemData.ID { return false } } }
	}

	// Handle hover delay
	// (some ideas: https://www.nngroup.com/articles/timing-exposing-content)
	delay : f32 = CalcDelayFromHoveredFlags(flags)
	if delay > 0.0 || (flags & ImGuiHoveredFlags_.ImGuiHoveredFlags_Stationary) {
		hover_delay_id : ImGuiID = (g.LastItemData.ID != 0) ? g.LastItemData.ID : GetIDFromPos(window, g.LastItemData.Rect.Min)
		if (flags & ImGuiHoveredFlags_.ImGuiHoveredFlags_NoSharedDelay) && (g.HoverItemDelayIdPreviousFrame != hover_delay_id) { g.HoverItemDelayTimer = 0.0 }
		g.HoverItemDelayId = hover_delay_id

		// When changing hovered item we requires a bit of stationary delay before activating hover timer,
		// but once unlocked on a given item we also moving.
		//if (g.HoverDelayTimer >= delay && (g.HoverDelayTimer - g.IO.DeltaTime < delay || g.MouseStationaryTimer - g.IO.DeltaTime < g.Style.HoverStationaryDelay)) { IMGUI_DEBUG_LOG("HoverDelayTimer = %f/%f, MouseStationaryTimer = %f\n", g.HoverDelayTimer, delay, g.MouseStationaryTimer); }
		if (flags & ImGuiHoveredFlags_.ImGuiHoveredFlags_Stationary) != 0 && g.HoverItemUnlockedStationaryId != hover_delay_id { return false }

		if g.HoverItemDelayTimer < delay { return false }
	}

	return true
}

// Internal facing ItemHoverable() used when submitting widgets. Differs slightly from IsItemHovered().
// (this does not rely on LastItemData it can be called from a ButtonBehavior() call not following an ItemAdd() call)
// FIXME-LEGACY: the 'ImGuiItemFlags item_flags' parameter was added on 2023-06-28.
// If you used this in your legacy/custom widgets code:
// - Commonly: if your ItemHoverable() call comes after an ItemAdd() call: pass 'item_flags = g.LastItemData.ItemFlags'.
// - Rare: otherwise you may pass 'item_flags = 0' (ImGuiItemFlags_None) unless you want to benefit from special behavior handled by ItemHoverable.
ItemHoverable :: proc(bb : ^ImRect, id : ImGuiID, item_flags : ImGuiItemFlags) -> bool
{
	g : ^ImGuiContext = GImGui^
	window : ^ImGuiWindow = g.CurrentWindow

	// Detect ID conflicts
	when ! defined ( IMGUI_DISABLE_DEBUG_TOOLS ) {
	if id != 0 && g.HoveredIdPreviousFrame == id && (item_flags & ImGuiItemFlags_.ImGuiItemFlags_AllowDuplicateId) == 0 {
		post_incr(&g.HoveredIdPreviousFrameItemCount)
		if g.DebugDrawIdConflicts == id { AddRect(window.DrawList, bb.Min - ImVec2(1, 1), bb.Max + ImVec2(1, 1), IM_COL32(255, 0, 0, 255), 0.0, ImDrawFlags_.ImDrawFlags_None, 2.0) }
	}
	} // preproc endif

	if g.HoveredWindow != window { return false }
	if !IsMouseHoveringRect(bb.Min, bb.Max) { return false }

	if g.HoveredId != 0 && g.HoveredId != id && !g.HoveredIdAllowOverlap { return false }
	if g.ActiveId != 0 && g.ActiveId != id && !g.ActiveIdAllowOverlap { if !g.ActiveIdFromShortcut { return false } }

	// Done with rectangle culling so we can perform heavier checks now.
	if !(item_flags & ImGuiItemFlagsPrivate_.ImGuiItemFlags_NoWindowHoverableCheck) && !IsWindowContentHoverable(window, ImGuiHoveredFlags_.ImGuiHoveredFlags_None) {
		g.HoveredIdIsDisabled = true
		return false
	}

	// We exceptionally allow this function to be called with id==0 to allow using it for easy high-level
	// hover test in widgets code. We could also decide to split this function is two.
	if id != 0 {
		// Drag source doesn't report as hovered
		if g.DragDropActive && g.DragDropPayload.SourceId == id && !(g.DragDropSourceFlags & ImGuiDragDropFlags_.ImGuiDragDropFlags_SourceNoDisableHover) { return false }

		SetHoveredID(id)

		// AllowOverlap mode (rarely used) requires previous frame HoveredId to be null or to match.
		// This allows using patterns where a later submitted widget overlaps a previous one. Generally perceived as a front-to-back hit-test.
		if ImGuiItemFlags_AllowOverlap : ^item_flags; ImGuiItemFlags_AllowOverlap {
			g.HoveredIdAllowOverlap = true
			if g.HoveredIdPreviousFrame != id { return false }
		}

		// Display shortcut (only works with mouse)
		// (ImGuiItemStatusFlags_HasShortcut in LastItemData denotes we want a tooltip)
		if id == g.LastItemData.ID && (g.LastItemData.StatusFlags & ImGuiItemStatusFlags_.ImGuiItemStatusFlags_HasShortcut) && g.ActiveId != id { if IsItemHovered(ImGuiHoveredFlags_.ImGuiHoveredFlags_ForTooltip | ImGuiHoveredFlags_.ImGuiHoveredFlags_DelayNormal) { SetTooltip("%s", GetKeyChordName(g.LastItemData.Shortcut)) } }
	}

	// When disabled we'll return false but still set HoveredId
	if ImGuiItemFlags_Disabled : ^item_flags; ImGuiItemFlags_Disabled {
		// Release active id if turning disabled
		if g.ActiveId == id && id != 0 { ClearActiveID() }
		g.HoveredIdIsDisabled = true
		return false
	}

	when ! defined ( IMGUI_DISABLE_DEBUG_TOOLS ) {
	if id != 0 {
		// [DEBUG] Item Picker tool!
		// We perform the check here because reaching is path is rare (1~ time a frame),
		// making the cost of this tool near-zero! We could get better call-stack and support picking non-hovered
		// items if we performed the test in ItemAdd(), but that would incur a bigger runtime cost.
		if g.DebugItemPickerActive && g.HoveredIdPreviousFrame == id { AddRect(GetForegroundDrawList(), bb.Min, bb.Max, IM_COL32(255, 255, 0, 255)) }
		if g.DebugItemPickerBreakId == id { IM_DEBUG_BREAK() }
	}
	} // preproc endif

	if g.NavHighlightItemUnderNav && (item_flags & ImGuiItemFlagsPrivate_.ImGuiItemFlags_NoNavDisableMouseHover) == 0 { return false }

	return true
}

// FIXME: This is inlined/duplicated in ItemAdd()
// FIXME: The id != 0 path is not used by our codebase, may get rid of it?
IsClippedEx :: proc(bb : ^ImRect, id : ImGuiID) -> bool
{
	g : ^ImGuiContext = GImGui^
	window : ^ImGuiWindow = g.CurrentWindow
	if !Overlaps(&bb, window.ClipRect) { if id == 0 || (id != g.ActiveId && id != g.ActiveIdPreviousFrame && id != g.NavId && id != g.NavActivateId) { if !g.ItemUnclipByLog { return true } } }
	return false
}

// This is also inlined in ItemAdd()
// Note: if ImGuiItemStatusFlags_HasDisplayRect is set, user needs to set g.LastItemData.DisplayRect.
SetLastItemData :: proc(item_id : ImGuiID, in_flags : ImGuiItemFlags, item_flags : ImGuiItemStatusFlags, item_rect : ^ImRect)
{
	g : ^ImGuiContext = GImGui^
	g.LastItemData.ID = item_id
	g.LastItemData.ItemFlags = in_flags
	g.LastItemData.StatusFlags = item_flags
	g.LastItemData.NavRect = item_rect; g.LastItemData.Rect = g.LastItemData.NavRect
}

CalcWrapWidthForPos :: proc(pos : ^ImVec2, wrap_pos_x : f32) -> f32
{
	if wrap_pos_x < 0.0 { return 0.0 }

	g : ^ImGuiContext = GImGui^
	window : ^ImGuiWindow = g.CurrentWindow
	if wrap_pos_x == 0.0 {
		// We could decide to setup a default wrapping max point for auto-resizing windows,
		// or have auto-wrap (with unspecified wrapping pos) behave as a ContentSize extending function?
		//if (window->Hidden && (window->Flags & ImGuiWindowFlags_AlwaysAutoResize))
		//    wrap_pos_x = ImMax(window->WorkRect.Min.x + g.FontSize * 10.0f, window->WorkRect.Max.x);
		//else
		wrap_pos_x = window.WorkRect.Max.x
	}
	else if wrap_pos_x > 0.0 {
		wrap_pos_x += window.Pos.x - window.Scroll.x; // wrap_pos_x is provided is window local space
	}

	return ImMax(wrap_pos_x - pos.x, 1.0)
}

// IM_ALLOC() == ImGui::MemAlloc()
MemAlloc :: proc(size : uint) -> rawptr
{
	ptr : rawptr = GImAllocatorAllocFunc(size, GImAllocatorUserData)
	when ! defined ( IMGUI_DISABLE_DEBUG_TOOLS ) {
		if ctx : ^ImGuiContext = GImGui; ctx { 
			DebugAllocHook(&ctx.DebugAllocInfo, ctx.FrameCount, ptr, size)
		}
	} // preproc endif
	return ptr
}

// IM_FREE() == ImGui::MemFree()
MemFree :: proc(ptr : rawptr)
{
	when ! defined ( IMGUI_DISABLE_DEBUG_TOOLS ) {
	if ptr != nil { 
		if ctx : ^ImGuiContext = GImGui; ctx {
			DebugAllocHook(&ctx.DebugAllocInfo, ctx.FrameCount, ptr, cast(uint) -1)
		}
	}
	} // preproc endif
	return GImAllocatorFreeFunc(ptr, GImAllocatorUserData)
}

// Debug Tools
// size >= 0 : alloc, size = -1 : free
// We record the number of allocation in recent frames, as a way to audit/sanitize our guiding principles of "no allocations on idle/repeating frames"
DebugAllocHook :: proc(info : ^ImGuiDebugAllocInfo, frame_count : i32, ptr : rawptr, size : uint)
{
	entry : ^ImGuiDebugAllocEntry = &info.LastEntriesBuf[info.LastEntriesIdx]
	IM_UNUSED(ptr)
	if entry.FrameCount != frame_count {
		info.LastEntriesIdx = (info.LastEntriesIdx + 1) % IM_ARRAYSIZE(info.LastEntriesBuf)
		entry = &info.LastEntriesBuf[info.LastEntriesIdx]
		entry.FrameCount = frame_count
		entry.FreeCount = 0; entry.AllocCount = entry.FreeCount
	}
	if size != cast(uint) -1 {
		//printf("[%05d] MemAlloc(%d) -> 0x%p\n", frame_count, (int)size, ptr);
		post_incr(&entry.AllocCount)
		post_incr(&info.TotalAllocCount)
	}
	else {
		//printf("[%05d] MemFree(0x%p)\n", frame_count, ptr);
		post_incr(&entry.FreeCount)
		post_incr(&info.TotalFreeCount)
	}
}

// Clipboard Utilities
// - Also see the LogToClipboard() function to capture GUI into clipboard, or easily output text data to the clipboard.
GetClipboardText :: proc() -> ^u8
{
	g : ^ImGuiContext = GImGui^
	return g.PlatformIO.Platform_GetClipboardTextFn ? Platform_GetClipboardTextFn(&g.PlatformIO, &g) : ""
}

SetClipboardText :: proc(text : ^u8)
{
	g : ^ImGuiContext = GImGui^
	if g.PlatformIO.Platform_SetClipboardTextFn != nil { Platform_SetClipboardTextFn(&g.PlatformIO, &g, text) }
}

// get the compiled version string e.g. "1.80 WIP" (essentially the value for IMGUI_VERSION from the compiled version of imgui.cpp)
GetVersion :: proc() -> ^u8
{
	return IMGUI_VERSION
}

// Main
// access the ImGuiIO structure (mouse/keyboard/gamepad inputs, time, various configuration options/flags)
GetIO :: proc() -> ^ImGuiIO
{
	IM_ASSERT(GImGui != nil && "No current context. Did you call ImGui::CreateContext() and ImGui::SetCurrentContext() ?")
	return GImGui.IO
}

// Windows
// We should always have a CurrentWindow in the stack (there is an implicit "Debug" window)
// If this ever crashes because g.CurrentWindow is NULL, it means that either:
// - ImGui::NewFrame() has never been called, which is illegal.
// - You are calling ImGui functions after ImGui::EndFrame()/ImGui::Render() and before the next ImGui::NewFrame(), which is also illegal.
// This variant exists to facilitate backends experimenting with multi-threaded parallel context. (#8069, #6293, #5856)
GetIOEx :: proc(ctx : ^ImGuiContext) -> ^ImGuiIO
{
	IM_ASSERT(ctx != nil)
	return ctx.IO
}

// access the ImGuiPlatformIO structure (mostly hooks/functions to connect to platform/renderer and OS Clipboard, IME etc.)
GetPlatformIO :: proc() -> ^ImGuiPlatformIO
{
	IM_ASSERT(GImGui != nil && "No current context. Did you call ImGui::CreateContext() and ImGui::SetCurrentContext()?")
	return GImGui.PlatformIO
}

// This variant exists to facilitate backends experimenting with multi-threaded parallel context. (#8069, #6293, #5856)
GetPlatformIOEx :: proc(ctx : ^ImGuiContext) -> ^ImGuiPlatformIO
{
	IM_ASSERT(ctx != nil)
	return ctx.PlatformIO
}

// valid after Render() and until the next call to NewFrame(). this is what you have to render.
// Pass this to your backend rendering function! Valid after Render() and until the next call to NewFrame()
GetDrawData :: proc() -> ^ImDrawData
{
	g : ^ImGuiContext = GImGui^
	viewport : ^ImGuiViewportP = g.Viewports[0]
	return viewport.DrawDataP.Valid ? &viewport.DrawDataP : nil
}

// get global imgui time. incremented by io.DeltaTime every frame.
GetTime :: proc() -> f64
{
	return GImGui.Time
}

// get global imgui frame count. incremented by 1 every frame.
GetFrameCount :: proc() -> i32
{
	return GImGui.FrameCount
}

GetViewportBgFgDrawList :: proc(viewport : ^ImGuiViewportP, drawlist_no : uint, drawlist_name : ^u8) -> ^ImDrawList
{
	// Create the draw list on demand, because they are not frequently used for all viewports
	g : ^ImGuiContext = GImGui^
	IM_ASSERT(drawlist_no < IM_ARRAYSIZE(viewport.BgFgDrawLists))
	draw_list : ^ImDrawList = viewport.BgFgDrawLists[drawlist_no]
	if draw_list == nil {
		draw_list = IM_NEW(ImDrawList)(&g.DrawListSharedData)
		draw_list._OwnerName = drawlist_name
		viewport.BgFgDrawLists[drawlist_no] = draw_list
	}

	// Our ImDrawList system requires that there is always a command
	if viewport.BgFgDrawListsLastFrame[drawlist_no] != g.FrameCount {
		_ResetForNewFrame(draw_list)
		PushTextureID(draw_list, g.IO.Fonts.TexID)
		PushClipRect(draw_list, viewport.Pos, viewport.Pos + viewport.Size, false)
		viewport.BgFgDrawListsLastFrame[drawlist_no] = g.FrameCount
	}
	return draw_list
}

// Background/Foreground Draw Lists
// get background draw list for the given viewport or viewport associated to the current window. this draw list will be the first rendering one. Useful to quickly draw shapes/text behind dear imgui contents.
GetBackgroundDrawList :: proc(viewport : ^ImGuiViewport) -> ^ImDrawList
{
	if viewport == nil { viewport = GImGui.CurrentWindow.Viewport }
	return GetViewportBgFgDrawList(cast(^ImGuiViewportP) viewport, 0, "##Background")
}

// get foreground draw list for the given viewport or viewport associated to the current window. this draw list will be the top-most rendered one. Useful to quickly draw shapes/text over dear imgui contents.
GetForegroundDrawList_vp :: proc(viewport : ^ImGuiViewport) -> ^ImDrawList
{
	if viewport == nil { viewport = GImGui.CurrentWindow.Viewport }
	return GetViewportBgFgDrawList(cast(^ImGuiViewportP) viewport, 1, "##Foreground")
}

// you may use this when creating your own ImDrawList instances.
GetDrawListSharedData :: proc() -> ^ImDrawListSharedData
{
	return &GImGui.DrawListSharedData
}

StartMouseMovingWindow :: proc(window : ^ImGuiWindow)
{
	// Set ActiveId even if the _NoMove flag is set. Without it, dragging away from a window with _NoMove would activate hover on other windows.
	// We _also_ call this when clicking in a window empty space when io.ConfigWindowsMoveFromTitleBarOnly is set, but clear g.MovingWindow afterward.
	// This is because we want ActiveId to be set even when the window is not permitted to move.
	g : ^ImGuiContext = GImGui^
	FocusWindow(window)
	SetActiveID(window.MoveId, window)
	if g.IO.ConfigNavCursorVisibleAuto { g.NavCursorVisible = false }
	g.ActiveIdClickOffset = g.IO.MouseClickedPos[0] - window.RootWindowDockTree.Pos
	g.ActiveIdNoClearOnFocusLoss = true
	SetActiveIdUsingAllKeyboardKeys()

	can_move_window : bool = true
	if (window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoMove) || (window.RootWindowDockTree.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoMove) { can_move_window = false }
	if node : ^ImGuiDockNode = window.DockNodeAsHost; node { if node.VisibleWindow && (node.VisibleWindow.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoMove) { can_move_window = false } }
	if can_move_window { g.MovingWindow = window }
}

// We use 'undock == false' when dragging from title bar to allow moving groups of floating nodes without undocking them.
StartMouseMovingWindowOrNode :: proc(window : ^ImGuiWindow, node : ^ImGuiDockNode, undock : bool)
{
	g : ^ImGuiContext = GImGui^
	can_undock_node : bool = false
	if undock && node != nil && node.VisibleWindow && (node.VisibleWindow.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoMove) == 0 && (node.MergedFlags & ImGuiDockNodeFlags_.ImGuiDockNodeFlags_NoUndocking) == 0 {
		// Can undock if:
		// - part of a hierarchy with more than one visible node (if only one is visible, we'll just move the root window)
		// - part of a dockspace node hierarchy: so we can undock the last single visible node too. Undocking from a fixed/central node will create a new node and copy windows.
		root_node : ^ImGuiDockNode = DockNodeGetRootNode(node)
		if root_node.OnlyNodeWithWindows != node || root_node.CentralNode != nil {
			// -V1051 PVS-Studio thinks node should be root_node and is wrong about that.can_undock_node = true
		}
	}

	clicked : bool = IsMouseClicked(0)
	dragging : bool = IsMouseDragging(0)
	if can_undock_node && dragging {
		// Will lead to DockNodeStartMouseMovingWindow() -> StartMouseMovingWindow() being called next frame
		DockContextQueueUndockNode(&g, node)
	}
	else if !can_undock_node && (clicked || dragging) && g.MovingWindow != window { StartMouseMovingWindow(window) }
}

// Handle mouse moving window
// Note: moving window with the navigation keys (Square + d-pad / CTRL+TAB + Arrows) are processed in NavUpdateWindowing()
// FIXME: We don't have strong guarantee that g.MovingWindow stay synched with g.ActiveId == g.MovingWindow->MoveId.
// This is currently enforced by the fact that BeginDragDropSource() is setting all g.ActiveIdUsingXXXX flags to inhibit navigation inputs,
// but if we should more thoroughly test cases where g.ActiveId or g.MovingWindow gets changed and not the other.
UpdateMouseMovingWindowNewFrame :: proc()
{
	g : ^ImGuiContext = GImGui^
	if g.MovingWindow != nil {
		// We actually want to move the root window. g.MovingWindow == window we clicked on (could be a child window).
		// We track it to preserve Focus and so that generally ActiveIdWindow == MovingWindow and ActiveId == MovingWindow->MoveId for consistency.
		KeepAliveID(g.ActiveId)
		IM_ASSERT(g.MovingWindow && g.MovingWindow.RootWindowDockTree)
		moving_window : ^ImGuiWindow = g.MovingWindow.RootWindowDockTree

		// When a window stop being submitted while being dragged, it may will its viewport until next Begin()
		window_disappared : bool = (!moving_window.WasActive && !moving_window.Active)
		if g.IO.MouseDown[0] && IsMousePosValid(&g.IO.MousePos) && !window_disappared {
			pos : ImVec2 = g.IO.MousePos - g.ActiveIdClickOffset
			if moving_window.Pos.x != pos.x || moving_window.Pos.y != pos.y {
				SetWindowPos(moving_window, pos, ImGuiCond_.ImGuiCond_Always)
				if moving_window.Viewport && moving_window.ViewportOwned {
					// Synchronize viewport immediately because some overlays may relies on clipping rectangle before we Begin() into the window.
					moving_window.Viewport.Pos = pos
					UpdateWorkRect(moving_window.Viewport)
				}
			}
			FocusWindow(g.MovingWindow)
		}
		else {
			if !window_disappared {
				// Try to merge the window back into the main viewport.
				// This works because MouseViewport should be != MovingWindow->Viewport on release (as per code in UpdateViewports)
				if g.ConfigFlagsCurrFrame & ImGuiConfigFlags_.ImGuiConfigFlags_ViewportsEnable { UpdateTryMergeWindowIntoHostViewport(moving_window, g.MouseViewport) }

				// Restore the mouse viewport so that we don't hover the viewport _under_ the moved window during the frame we released the mouse button.
				if moving_window.Viewport && !IsDragDropPayloadBeingAccepted() { g.MouseViewport = moving_window.Viewport }

				// Clear the NoInput window flag set by the Viewport system
				if moving_window.Viewport { moving_window.Viewport.Flags &= !ImGuiViewportFlags_.ImGuiViewportFlags_NoInputs }
			}

			g.MovingWindow = nil
			ClearActiveID()
		}
	}
	else {
		// When clicking/dragging from a window that has the _NoMove flag, we still set the ActiveId in order to prevent hovering others.
		if g.ActiveIdWindow && g.ActiveIdWindow.MoveId == g.ActiveId {
			KeepAliveID(g.ActiveId)
			if !g.IO.MouseDown[0] { ClearActiveID() }
		}
	}
}

// Initiate focusing and moving window when clicking on empty space or title bar.
// Initiate focusing window when clicking on a disabled item.
// Handle left-click and right-click focus.
UpdateMouseMovingWindowEndFrame :: proc()
{
	g : ^ImGuiContext = GImGui^
	if g.ActiveId != 0 || (g.HoveredId != 0 && !g.HoveredIdIsDisabled) { return }

	// Unless we just made a window/popup appear
	if g.NavWindow && g.NavWindow.Appearing { return }

	// Click on empty space to focus window and start moving
	// (after we're done with all our widgets, so e.g. clicking on docking tab-bar which have set HoveredId already and not get us here!)
	if g.IO.MouseClicked[0] {
		// Handle the edge case of a popup being closed while clicking in its empty space.
		// If we try to focus it, FocusWindow() > ClosePopupsOverWindow() will accidentally close any parent popups because they are not linked together any more.
		root_window : ^ImGuiWindow = g.HoveredWindow ? g.HoveredWindow.RootWindow : nil
		is_closed_popup : bool = root_window && (root_window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_Popup) && !IsPopupOpen(root_window.PopupId, ImGuiPopupFlags_.ImGuiPopupFlags_AnyPopupLevel)

		if root_window != nil && !is_closed_popup {
			StartMouseMovingWindow(g.HoveredWindow); //-V595

			// Cancel moving if clicked outside of title bar
			if g.IO.ConfigWindowsMoveFromTitleBarOnly { if !(root_window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoTitleBar) || root_window.DockIsActive { if !Contains(&TitleBarRect(root_window), g.IO.MouseClickedPos[0]) { g.MovingWindow = nil } } }

			// Cancel moving if clicked over an item which was disabled or inhibited by popups
			// (when g.HoveredIdIsDisabled == true && g.HoveredId == 0 we are inhibited by popups, when g.HoveredIdIsDisabled == true && g.HoveredId != 0 we are over a disabled item)0 already)
			if g.HoveredIdIsDisabled { g.MovingWindow = nil }
		}
		else if root_window == nil && g.NavWindow != nil {
			// Clicking on void disable focus
			FocusWindow(nil, ImGuiFocusRequestFlags_.ImGuiFocusRequestFlags_UnlessBelowModal)
		}
	}

	// With right mouse button we close popups without changing focus based on where the mouse is aimed
	// Instead, focus will be restored to the window under the bottom-most closed popup.
	// (The left mouse button path calls FocusWindow on the hovered window, which will lead NewFrame->ClosePopupsOverWindow to trigger)
	if g.IO.MouseClicked[1] && g.HoveredId == 0 {
		// Find the top-most window between HoveredWindow and the top-most Modal Window.
		// This is where we can trim the popup stack.
		modal : ^ImGuiWindow = GetTopMostPopupModal()
		hovered_window_above_modal : bool = g.HoveredWindow && (modal == nil || IsWindowAbove(g.HoveredWindow, modal))
		ClosePopupsOverWindow(hovered_window_above_modal ? g.HoveredWindow : modal, true)
	}
}

// This is called during NewFrame()->UpdateViewportsNewFrame() only.
// Need to keep in sync with SetWindowPos()
TranslateWindow :: proc(window : ^ImGuiWindow, delta : ^ImVec2)
{
	window.Pos += delta
	Translate(&window.ClipRect, delta)
	Translate(&window.OuterRectClipped, delta)
	Translate(&window.InnerRect, delta)
	window.DC.CursorPos += delta
	window.DC.CursorStartPos += delta
	window.DC.CursorMaxPos += delta
	window.DC.IdealMaxPos += delta
}

ScaleWindow :: proc(window : ^ImGuiWindow, scale : f32)
{
	origin : ImVec2 = window.Viewport.Pos
	window.Pos = ImFloor((window.Pos - origin) * scale + origin)
	window.Size = ImTrunc(window.Size * scale)
	window.SizeFull = ImTrunc(window.SizeFull * scale)
	window.ContentSize = ImTrunc(window.ContentSize * scale)
}

IsWindowActiveAndVisible :: proc(window : ^ImGuiWindow) -> bool
{
	return (window.Active) && (!window.Hidden)
}

// The reason this is exposed in imgui_internal.h is: on touch-based system that don't have hovering, we want to dispatch inputs to the right target (imgui vs imgui+app)
UpdateHoveredWindowAndCaptureFlags :: proc()
{
	g : ^ImGuiContext = GImGui^
	io : ^ImGuiIO = g.IO

	// FIXME-DPI: This storage was added on 2021/03/31 for test engine, but if we want to multiply WINDOWS_HOVER_PADDING
	// by DpiScale, we need to make this window-agnostic anyhow, maybe need storing inside ImGuiWindow.
	g.WindowsHoverPadding = ImMax(g.Style.TouchExtraPadding, ImVec2(WINDOWS_HOVER_PADDING, WINDOWS_HOVER_PADDING))

	// Find the window hovered by mouse:
	// - Child windows can extend beyond the limit of their parent so we need to derive HoveredRootWindow from HoveredWindow.
	// - When moving a window we can skip the search, which also conveniently bypasses the fact that window->WindowRectClipped is lagging as this point of the frame.
	// - We also support the moved window toggling the NoInputs flag after moving has started in order to be able to detect windows below it, which is useful for e.g. docking mechanisms.
	clear_hovered_windows : bool = false
	FindHoveredWindowEx(g.IO.MousePos, false, &g.HoveredWindow, &g.HoveredWindowUnderMovingWindow)
	IM_ASSERT(g.HoveredWindow == nil || g.HoveredWindow == g.MovingWindow || g.HoveredWindow.Viewport == g.MouseViewport)
	g.HoveredWindowBeforeClear = g.HoveredWindow

	// Modal windows prevents mouse from hovering behind them.
	modal_window : ^ImGuiWindow = GetTopMostPopupModal()
	if modal_window && g.HoveredWindow && !IsWindowWithinBeginStackOf(g.HoveredWindow.RootWindow, modal_window) {
		// FIXME-MERGE: RootWindowDockTree ?clear_hovered_windows = true
	}

	// Disabled mouse hovering (we don't currently clear MousePos, we could)
	if io.ConfigFlags & ImGuiConfigFlags_.ImGuiConfigFlags_NoMouse { clear_hovered_windows = true }

	// We track click ownership. When clicked outside of a window the click is owned by the application and
	// won't report hovering nor request capture even while dragging over our windows afterward.
	has_open_popup : bool = (g.OpenPopupStack.Size > 0)
	has_open_modal : bool = (modal_window != nil)
	mouse_earliest_down : i32 = -1
	mouse_any_down : bool = false
	for i : i32 = 0; i < IM_ARRAYSIZE(io.MouseDown); post_incr(&i) {
		if io.MouseClicked[i] {
			io.MouseDownOwned[i] = (g.HoveredWindow != nil) || has_open_popup
			io.MouseDownOwnedUnlessPopupClose[i] = (g.HoveredWindow != nil) || has_open_modal
		}
		mouse_any_down |= io.MouseDown[i]
		if io.MouseDown[i] || io.MouseReleased[i] {
			// Increase release frame for our evaluation of earliest button (#1392)if mouse_earliest_down == -1 || io.MouseClickedTime[i] < io.MouseClickedTime[mouse_earliest_down] { mouse_earliest_down = i }
		}
	}

	mouse_avail : bool = (mouse_earliest_down == -1) || io.MouseDownOwned[mouse_earliest_down]
	mouse_avail_unless_popup_close : bool = (mouse_earliest_down == -1) || io.MouseDownOwnedUnlessPopupClose[mouse_earliest_down]

	// If mouse was first clicked outside of ImGui bounds we also cancel out hovering.
	// FIXME: For patterns of drag and drop across OS windows, we may need to rework/remove this test (first committed 311c0ca9 on 2015/02)
	mouse_dragging_extern_payload : bool = g.DragDropActive && (g.DragDropSourceFlags & ImGuiDragDropFlags_.ImGuiDragDropFlags_SourceExtern) != 0
	if !mouse_avail && !mouse_dragging_extern_payload { clear_hovered_windows = true }

	if clear_hovered_windows { g.HoveredWindowUnderMovingWindow = nil; g.HoveredWindow = g.HoveredWindowUnderMovingWindow }

	// Update io.WantCaptureMouse for the user application (true = dispatch mouse info to Dear ImGui only, false = dispatch mouse to Dear ImGui + underlying app)
	// Update io.WantCaptureMouseAllowPopupClose (experimental) to give a chance for app to react to popup closure with a drag
	if g.WantCaptureMouseNextFrame != -1 {
		io.WantCaptureMouseUnlessPopupClose = (g.WantCaptureMouseNextFrame != 0); io.WantCaptureMouse = io.WantCaptureMouseUnlessPopupClose
	}
	else {
		io.WantCaptureMouse = (mouse_avail && (g.HoveredWindow != nil || mouse_any_down)) || has_open_popup
		io.WantCaptureMouseUnlessPopupClose = (mouse_avail_unless_popup_close && (g.HoveredWindow != nil || mouse_any_down)) || has_open_modal
	}

	// Update io.WantCaptureKeyboard for the user application (true = dispatch keyboard info to Dear ImGui only, false = dispatch keyboard info to Dear ImGui + underlying app)
	io.WantCaptureKeyboard = false
	if (io.ConfigFlags & ImGuiConfigFlags_.ImGuiConfigFlags_NoKeyboard) == 0 {
		if (g.ActiveId != 0) || (modal_window != nil) { io.WantCaptureKeyboard = true }
		else if io.NavActive && (io.ConfigFlags & ImGuiConfigFlags_.ImGuiConfigFlags_NavEnableKeyboard) && io.ConfigNavCaptureKeyboard { io.WantCaptureKeyboard = true }
	}
	if g.WantCaptureKeyboardNextFrame != -1 {
		// Manual overrideio.WantCaptureKeyboard = (g.WantCaptureKeyboardNextFrame != 0)
	}

	// Update io.WantTextInput flag, this is to allow systems without a keyboard (e.g. mobile, hand-held) to show a software keyboard if possible
	io.WantTextInput = (g.WantTextInputNextFrame != -1) ? (g.WantTextInputNextFrame != 0) : false
}

// Called once a frame. Followed by SetCurrentFont() which sets up the remaining data.
SetupDrawListSharedData :: proc()
{
	g : ^ImGuiContext = GImGui^
	virtual_space : ImRect; init(&virtual_space, FLT_MAX, FLT_MAX, -FLT_MAX, -FLT_MAX)
	for viewport in g.Viewports { Add(&virtual_space, GetMainRect(viewport)) }

	g.DrawListSharedData.ClipRectFullscreen = ToVec4(&virtual_space)
	g.DrawListSharedData.CurveTessellationTol = g.Style.CurveTessellationTol
	SetCircleTessellationMaxError(&g.DrawListSharedData, g.Style.CircleTessellationMaxError)
	g.DrawListSharedData.InitialFlags = ImDrawListFlags_.ImDrawListFlags_None
	if g.Style.AntiAliasedLines { g.DrawListSharedData.InitialFlags |= ImDrawListFlags_.ImDrawListFlags_AntiAliasedLines }
	if g.Style.AntiAliasedLinesUseTex && !(g.IO.Fonts.Flags & ImFontAtlasFlags_.ImFontAtlasFlags_NoBakedLines) { g.DrawListSharedData.InitialFlags |= ImDrawListFlags_.ImDrawListFlags_AntiAliasedLinesUseTex }
	if g.Style.AntiAliasedFill { g.DrawListSharedData.InitialFlags |= ImDrawListFlags_.ImDrawListFlags_AntiAliasedFill }
	if g.IO.BackendFlags & ImGuiBackendFlags_.ImGuiBackendFlags_RendererHasVtxOffset { g.DrawListSharedData.InitialFlags |= ImDrawListFlags_.ImDrawListFlags_AllowVtxOffset }
}

// start a new Dear ImGui frame, you can submit any command from this point until Render()/EndFrame().
NewFrame :: proc()
{
	IM_ASSERT(GImGui != nil && "No current context. Did you call ImGui::CreateContext() and ImGui::SetCurrentContext() ?")
	g : ^ImGuiContext = GImGui^

	// Remove pending delete hooks before frame start.
	// This deferred removal avoid issues of removal while iterating the hook vector
	for n : i32 = g.Hooks.Size - 1; n >= 0; post_decr(&n) { if g.Hooks[n].Type == ImGuiContextHookType.ImGuiContextHookType_PendingRemoval_ { erase(&g.Hooks, &g.Hooks[n]) } }

	CallContextHooks(&g, ImGuiContextHookType.ImGuiContextHookType_NewFramePre)

	// Check and assert for various common IO and Configuration mistakes
	g.ConfigFlagsLastFrame = g.ConfigFlagsCurrFrame
	ErrorCheckNewFrameSanityChecks()
	g.ConfigFlagsCurrFrame = g.IO.ConfigFlags

	// Load settings on first frame, save settings when modified (after a delay)
	UpdateSettings()

	g.Time += g.IO.DeltaTime
	g.WithinFrameScope = true
	g.FrameCount += 1
	g.TooltipOverrideCount = 0
	g.WindowsActiveCount = 0
	resize(&g.MenusIdSubmittedThisFrame, 0)

	// Calculate frame-rate for the user, as a purely luxurious feature
	g.FramerateSecPerFrameAccum += g.IO.DeltaTime - g.FramerateSecPerFrame[g.FramerateSecPerFrameIdx]
	g.FramerateSecPerFrame[g.FramerateSecPerFrameIdx] = g.IO.DeltaTime
	g.FramerateSecPerFrameIdx = (g.FramerateSecPerFrameIdx + 1) % IM_ARRAYSIZE(g.FramerateSecPerFrame)
	g.FramerateSecPerFrameCount = ImMin(g.FramerateSecPerFrameCount + 1, IM_ARRAYSIZE(g.FramerateSecPerFrame))
	g.IO.Framerate = (g.FramerateSecPerFrameAccum > 0.0) ? (1.0 / (g.FramerateSecPerFrameAccum / cast(f32) g.FramerateSecPerFrameCount)) : FLT_MAX

	// Process input queue (trickle as many events as possible), turn events into writes to IO structure
	resize(&g.InputEventsTrail, 0)
	UpdateInputEvents(g.IO.ConfigInputTrickleEventQueue)

	// Update viewports (after processing input queue, so io.MouseHoveredViewport is set)
	UpdateViewportsNewFrame()

	// Setup current font and draw list shared data
	// FIXME-VIEWPORT: the concept of a single ClipRectFullscreen is not ideal!
	g.IO.Fonts.Locked = true
	SetupDrawListSharedData()
	SetCurrentFont(GetDefaultFont())
	IM_ASSERT(IsLoaded(g.Font))

	// Mark rendering data as invalid to prevent user who may have a handle on it to use it.
	for viewport in g.Viewports {
		viewport.DrawData = nil
		viewport.DrawDataP.Valid = false
	}

	// Drag and drop keep the source ID alive so even if the source disappear our state is consistent
	if g.DragDropActive && g.DragDropPayload.SourceId == g.ActiveId { KeepAliveID(g.DragDropPayload.SourceId) }

	// [DEBUG]
	if !g.IO.ConfigDebugHighlightIdConflicts || !g.IO.KeyCtrl {
		// Count is locked while holding CTRLg.DebugDrawIdConflicts = 0
	}
	if g.IO.ConfigDebugHighlightIdConflicts && g.HoveredIdPreviousFrameItemCount > 1 { g.DebugDrawIdConflicts = g.HoveredIdPreviousFrame }

	// Update HoveredId data
	if !g.HoveredIdPreviousFrame { g.HoveredIdTimer = 0.0 }
	if !g.HoveredIdPreviousFrame || (g.HoveredId && g.ActiveId == g.HoveredId) { g.HoveredIdNotActiveTimer = 0.0 }
	if g.HoveredId { g.HoveredIdTimer += g.IO.DeltaTime }
	if g.HoveredId && g.ActiveId != g.HoveredId { g.HoveredIdNotActiveTimer += g.IO.DeltaTime }
	g.HoveredIdPreviousFrame = g.HoveredId
	g.HoveredIdPreviousFrameItemCount = 0
	g.HoveredId = 0
	g.HoveredIdAllowOverlap = false
	g.HoveredIdIsDisabled = false

	// Clear ActiveID if the item is not alive anymore.
	// In 1.87, the common most call to KeepAliveID() was moved from GetID() to ItemAdd().
	// As a result, custom widget using ButtonBehavior() _without_ ItemAdd() need to call KeepAliveID() themselves.
	if g.ActiveId != 0 && g.ActiveIdIsAlive != g.ActiveId && g.ActiveIdPreviousFrame == g.ActiveId {
		IMGUI_DEBUG_LOG_ACTIVEID("NewFrame(): ClearActiveID() because it isn't marked alive anymore!\n")
		ClearActiveID()
	}

	// Update ActiveId data (clear reference to active widget if the widget isn't alive anymore)
	if g.ActiveId { g.ActiveIdTimer += g.IO.DeltaTime }
	g.LastActiveIdTimer += g.IO.DeltaTime
	g.ActiveIdPreviousFrame = g.ActiveId
	g.ActiveIdPreviousFrameWindow = g.ActiveIdWindow
	g.ActiveIdPreviousFrameHasBeenEditedBefore = g.ActiveIdHasBeenEditedBefore
	g.ActiveIdIsAlive = 0
	g.ActiveIdHasBeenEditedThisFrame = false
	g.ActiveIdPreviousFrameIsAlive = false
	g.ActiveIdIsJustActivated = false
	if g.TempInputId != 0 && g.ActiveId != g.TempInputId { g.TempInputId = 0 }
	if g.ActiveId == 0 {
		g.ActiveIdUsingNavDirMask = 0x00
		g.ActiveIdUsingAllKeyboardKeys = false
	}

	// Record when we have been stationary as this state is preserved while over same item.
	// FIXME: The way this is expressed means user cannot alter HoverStationaryDelay during the frame to use varying values.
	// To allow this we should store HoverItemMaxStationaryTime+ID and perform the >= check in IsItemHovered() function.
	if g.HoverItemDelayId != 0 && g.MouseStationaryTimer >= g.Style.HoverStationaryDelay { g.HoverItemUnlockedStationaryId = g.HoverItemDelayId }
	else if g.HoverItemDelayId == 0 { g.HoverItemUnlockedStationaryId = 0 }
	if g.HoveredWindow != nil && g.MouseStationaryTimer >= g.Style.HoverStationaryDelay { g.HoverWindowUnlockedStationaryId = g.HoveredWindow.ID }
	else if g.HoveredWindow == nil { g.HoverWindowUnlockedStationaryId = 0 }

	// Update hover delay for IsItemHovered() with delays and tooltips
	g.HoverItemDelayIdPreviousFrame = g.HoverItemDelayId
	if g.HoverItemDelayId != 0 {
		g.HoverItemDelayTimer += g.IO.DeltaTime
		g.HoverItemDelayClearTimer = 0.0
		g.HoverItemDelayId = 0
	}
	else if g.HoverItemDelayTimer > 0.0 {
		// This gives a little bit of leeway before clearing the hover timer, allowing mouse to cross gaps
		// We could expose 0.25f as style.HoverClearDelay but I am not sure of the logic yet, this is particularly subtle.
		g.HoverItemDelayClearTimer += g.IO.DeltaTime
		if g.HoverItemDelayClearTimer >= ImMax(0.25, g.IO.DeltaTime * 2.0) {
			// ~7 frames at 30 Hz + allow for low framerate
			// May want a decaying timer, in which case need to clamp at max first, based on max of caller last requested timer.
			g.HoverItemDelayClearTimer = 0.0; g.HoverItemDelayTimer = g.HoverItemDelayClearTimer
		}
	}

	// Drag and drop
	g.DragDropAcceptIdPrev = g.DragDropAcceptIdCurr
	g.DragDropAcceptIdCurr = 0
	g.DragDropAcceptIdCurrRectSurface = FLT_MAX
	g.DragDropWithinSource = false
	g.DragDropWithinTarget = false
	g.DragDropHoldJustPressedId = 0
	g.TooltipPreviousWindow = nil

	// Close popups on focus lost (currently wip/opt-in)
	//if (g.IO.AppFocusLost)
	//    ClosePopupsExceptModals();

	// Update keyboard input state
	UpdateKeyboardInputs()

	//IM_ASSERT(g.IO.KeyCtrl == IsKeyDown(ImGuiKey_LeftCtrl) || IsKeyDown(ImGuiKey_RightCtrl));
	//IM_ASSERT(g.IO.KeyShift == IsKeyDown(ImGuiKey_LeftShift) || IsKeyDown(ImGuiKey_RightShift));
	//IM_ASSERT(g.IO.KeyAlt == IsKeyDown(ImGuiKey_LeftAlt) || IsKeyDown(ImGuiKey_RightAlt));
	//IM_ASSERT(g.IO.KeySuper == IsKeyDown(ImGuiKey_LeftSuper) || IsKeyDown(ImGuiKey_RightSuper));

	// Update keyboard/gamepad navigation
	NavUpdate()

	// Update mouse input state
	UpdateMouseInputs()

	// Undocking
	// (needs to be before UpdateMouseMovingWindowNewFrame so the window is already offset and following the mouse on the detaching frame)
	DockContextNewFrameUpdateUndocking(&g)

	// Mark all windows as not visible and compact unused memory.
	IM_ASSERT(g.WindowsFocusOrder.Size <= g.Windows.Size)
	memory_compact_start_time : f32 = (g.GcCompactAll || g.IO.ConfigMemoryCompactTimer < 0.0) ? FLT_MAX : cast(f32) g.Time - g.IO.ConfigMemoryCompactTimer
	for window in g.Windows {
		window.WasActive = window.Active
		window.Active = false
		window.WriteAccessed = false
		window.BeginCountPreviousFrame = window.BeginCount
		window.BeginCount = 0

		// Garbage collect transient buffers of recently unused windows
		if !window.WasActive && !window.MemoryCompacted && window.LastTimeActive < memory_compact_start_time { GcCompactTransientWindowBuffers(window) }
	}

	// Find hovered window
	// (needs to be before UpdateMouseMovingWindowNewFrame so we fill g.HoveredWindowUnderMovingWindow on the mouse release frame)
	// (currently needs to be done after the WasActive=Active loop and FindHoveredWindowEx uses ->Active)
	UpdateHoveredWindowAndCaptureFlags()

	// Handle user moving window with mouse (at the beginning of the frame to avoid input lag or sheering)
	UpdateMouseMovingWindowNewFrame()

	// Background darkening/whitening
	if GetTopMostPopupModal() != nil || (g.NavWindowingTarget != nil && g.NavWindowingHighlightAlpha > 0.0) { g.DimBgRatio = ImMin(g.DimBgRatio + g.IO.DeltaTime * 6.0, 1.0) }
	else { g.DimBgRatio = ImMax(g.DimBgRatio - g.IO.DeltaTime * 10.0, 0.0) }

	g.MouseCursor = ImGuiMouseCursor_.ImGuiMouseCursor_Arrow
	g.WantTextInputNextFrame = -1; g.WantCaptureKeyboardNextFrame = g.WantTextInputNextFrame; g.WantCaptureMouseNextFrame = g.WantCaptureKeyboardNextFrame

	// Platform IME data: reset for the frame
	g.PlatformImeDataPrev = g.PlatformImeData
	g.PlatformImeData.WantVisible = false

	// Mouse wheel scrolling, scale
	UpdateMouseWheel()

	// Garbage collect transient buffers of recently unused tables
	for i : i32 = 0; i < g.TablesLastTimeActive.Size; post_incr(&i) { if g.TablesLastTimeActive[i] >= 0.0 && g.TablesLastTimeActive[i] < memory_compact_start_time { TableGcCompactTransientBuffers(GetByIndex(&g.Tables, i)) } }

	for table_temp_data in g.TablesTempData { if table_temp_data.LastTimeActive >= 0.0 && table_temp_data.LastTimeActive < memory_compact_start_time { TableGcCompactTransientBuffers(&table_temp_data) } }

	if g.GcCompactAll { GcCompactTransientMiscBuffers() }
	g.GcCompactAll = false

	// Closing the focused window restore focus to the first active root window in descending z-order
	if g.NavWindow && !g.NavWindow.WasActive { FocusTopMostWindowUnderOne(nil, nil, nil, ImGuiFocusRequestFlags_.ImGuiFocusRequestFlags_RestoreFocusedChild) }

	// No window should be open at the beginning of the frame.
	// But in order to allow the user to call NewFrame() multiple times without calling Render(), we are doing an explicit clear.
	resize(&g.CurrentWindowStack, 0)
	resize(&g.BeginPopupStack, 0)
	resize(&g.ItemFlagsStack, 0)
	push_back(&g.ItemFlagsStack, ImGuiItemFlags_.ImGuiItemFlags_AutoClosePopups); // Default flags
	g.CurrentItemFlags = back(&g.ItemFlagsStack)
	resize(&g.GroupStack, 0)

	// Docking
	DockContextNewFrameUpdateDocking(&g)

	// [DEBUG] Update debug features
	when ! defined ( IMGUI_DISABLE_DEBUG_TOOLS ) {
	UpdateDebugToolItemPicker()
	UpdateDebugToolStackQueries()
	UpdateDebugToolFlashStyleColor()
	if g.DebugLocateFrames > 0 && pre_decr(&g.DebugLocateFrames) == 0 {
		g.DebugLocateId = 0
		g.DebugBreakInLocateId = false
	}
	if g.DebugLogAutoDisableFrames > 0 && pre_decr(&g.DebugLogAutoDisableFrames) == 0 {
		DebugLog("(Debug Log: Auto-disabled some ImGuiDebugLogFlags after 2 frames)\n")
		g.DebugLogFlags &= !g.DebugLogAutoDisableFlags
		g.DebugLogAutoDisableFlags = ImGuiDebugLogFlags_.ImGuiDebugLogFlags_None
	}
	} // preproc endif

	// Create implicit/fallback window - which we will only render it if the user has added something to it.
	// We don't use "Debug" to avoid colliding with user trying to create a "Debug" window with custom flags.
	// This fallback is particularly important as it prevents ImGui:: calls from crashing.
	g.WithinFrameScopeWithImplicitWindow = true
	SetNextWindowSize(ImVec2(400, 400), ImGuiCond_.ImGuiCond_FirstUseEver)
	Begin("Debug##Default")
	IM_ASSERT(g.CurrentWindow.IsFallbackWindow == true)

	// Store stack sizes
	g.ErrorCountCurrentFrame = 0
	ErrorRecoveryStoreState(&g.StackSizesInNewFrame)

	// [DEBUG] When io.ConfigDebugBeginReturnValue is set, we make Begin()/BeginChild() return false at different level of the window-stack,
	// allowing to validate correct Begin/End behavior in user code.
	when ! defined ( IMGUI_DISABLE_DEBUG_TOOLS ) {
	if g.IO.ConfigDebugBeginReturnValueLoop { g.DebugBeginReturnValueCullDepth = (g.DebugBeginReturnValueCullDepth == -1) ? 0 : ((g.DebugBeginReturnValueCullDepth + ((g.FrameCount % 4) == 0 ? 1 : 0)) % 10) }
	else { g.DebugBeginReturnValueCullDepth = -1 }
	} // preproc endif

	CallContextHooks(&g, ImGuiContextHookType.ImGuiContextHookType_NewFramePost)
}

// FIXME: Add a more explicit sort order in the window structure.
ChildWindowComparer :: proc(lhs : rawptr, rhs : rawptr) -> i32
{
	a : ^ImGuiWindow = cast(^^ImGuiWindow) lhs^
	b : ^ImGuiWindow = cast(^^ImGuiWindow) rhs^
	if d : i32 = (a.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_Popup) - (b.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_Popup); d { return d }
	if d : i32 = (a.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_Tooltip) - (b.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_Tooltip); d { return d }
	return (a.BeginOrderWithinParent - b.BeginOrderWithinParent)
}

AddWindowToSortBuffer :: proc(out_sorted_windows : ^ImVector(^ImGuiWindow), window : ^ImGuiWindow)
{
	push_back(out_sorted_windows, window)
	if window.Active {
		count : i32 = window.DC.ChildWindows.Size
		ImQsort(window.DC.ChildWindows.Data, cast(uint) count, size_of(^ImGuiWindow), ChildWindowComparer)
		for i : i32 = 0; i < count; post_incr(&i) {
			child : ^ImGuiWindow = window.DC.ChildWindows[i]
			if child.Active { AddWindowToSortBuffer(out_sorted_windows, child) }
		}
	}
}

AddWindowToDrawData :: proc(window : ^ImGuiWindow, layer : i32)
{
	g : ^ImGuiContext = GImGui^
	viewport : ^ImGuiViewportP = window.Viewport
	IM_ASSERT(viewport != nil)
	post_incr(&g.IO.MetricsRenderWindows)
	if window.DrawList._Splitter._Count > 1 {
		// Merge if user forgot to merge back. Also required in Docking branch for ImGuiWindowFlags_DockNodeHost windows.
		ChannelsMerge(window.DrawList)
	}
	AddDrawListToDrawDataEx(&viewport.DrawDataP, viewport.DrawDataBuilder.Layers[layer], window.DrawList)
	for child in window.DC.ChildWindows { if IsWindowActiveAndVisible(child) {
	// Clipped children may have been marked not activeAddWindowToDrawData(child, layer)
} }
}

GetWindowDisplayLayer :: #force_inline proc(window : ^ImGuiWindow) -> i32
{
	return (window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_Tooltip) ? 1 : 0
}

// Layer is locked for the root window, however child windows may use a different viewport (e.g. extruding menu)
AddRootWindowToDrawData :: #force_inline proc(window : ^ImGuiWindow)
{
	AddWindowToDrawData(window, GetWindowDisplayLayer(window))
}

FlattenDrawDataIntoSingleLayer :: proc(builder : ^ImDrawDataBuilder)
{
	n : i32 = builder.Layers[0].Size
	full_size : i32 = n
	for i : i32 = 1; i < IM_ARRAYSIZE(builder.Layers); post_incr(&i) { full_size += builder.Layers[i].Size }

	resize(builder.Layers[0], full_size)
	for layer_n : i32 = 1; layer_n < IM_ARRAYSIZE(builder.Layers); post_incr(&layer_n) {
		layer : ^ImVector(^ImDrawList) = builder.Layers[layer_n]
		if empty(layer) { continue }
		memcpy(builder.Layers[0].Data + n, layer.Data, layer.Size * size_of(^ImDrawList))
		n += layer.Size
		resize(layer, 0)
	}
}

InitViewportDrawData :: proc(viewport : ^ImGuiViewportP)
{
	io : ^ImGuiIO = GetIO()
	draw_data : ^ImDrawData = &viewport.DrawDataP

	viewport.DrawData = draw_data; // Make publicly accessible
	viewport.DrawDataBuilder.Layers[0] = &draw_data.CmdLists
	viewport.DrawDataBuilder.Layers[1] = &viewport.DrawDataBuilder.LayerData1
	resize(viewport.DrawDataBuilder.Layers[0], 0)
	resize(viewport.DrawDataBuilder.Layers[1], 0)

	// When minimized, we report draw_data->DisplaySize as zero to be consistent with non-viewport mode,
	// and to allow applications/backends to easily skip rendering.
	// FIXME: Note that we however do NOT attempt to report "zero drawlist / vertices" into the ImDrawData structure.
	// This is because the work has been done already, and its wasted! We should fix that and add optimizations for
	// it earlier in the pipeline, rather than pretend to hide the data at the end of the pipeline.
	is_minimized : bool = (viewport.Flags & ImGuiViewportFlags_.ImGuiViewportFlags_IsMinimized) != 0

	draw_data.Valid = true
	draw_data.CmdListsCount = 0
	draw_data.TotalIdxCount = 0; draw_data.TotalVtxCount = draw_data.TotalIdxCount
	draw_data.DisplayPos = viewport.Pos
	draw_data.DisplaySize = is_minimized ? ImVec2(0.0, 0.0) : viewport.Size
	draw_data.FramebufferScale = io.DisplayFramebufferScale; // FIXME-VIEWPORT: This may vary on a per-monitor/viewport basis?
	draw_data.OwnerViewport = viewport
}

// Clipping
// - Mouse hovering is affected by ImGui::PushClipRect() calls, unlike direct calls to ImDrawList::PushClipRect() which are render only.
// Push a clipping rectangle for both ImGui logic (hit-testing etc.) and low-level ImDrawList rendering.
// - When using this function it is sane to ensure that float are perfectly rounded to integer values,
//   so that e.g. (int)(max.x-min.x) in user's render produce correct result.
// - If the code here changes, may need to update code of functions like NextColumn() and PushColumnClipRect():
//   some frequently called functions which to modify both channels and clipping simultaneously tend to use the
//   more specialized SetWindowClipRectBeforeSetChannel() to avoid extraneous updates of underlying ImDrawCmds.
// - This is analoguous to PushFont()/PopFont() in the sense that are a mixing a global stack and a window stack,
//   which in the case of ClipRect is not so problematic but tends to be more restrictive for fonts.
PushClipRect :: proc(clip_rect_min : ^ImVec2, clip_rect_max : ^ImVec2, intersect_with_current_clip_rect : bool)
{
	window : ^ImGuiWindow = GetCurrentWindow()
	PushClipRect(window.DrawList, clip_rect_min, clip_rect_max, intersect_with_current_clip_rect)
	window.ClipRect = back(&window.DrawList._ClipRectStack)
}

PopClipRect :: proc()
{
	window : ^ImGuiWindow = GetCurrentWindow()
	PopClipRect(window.DrawList)
	window.ClipRect = back(&window.DrawList._ClipRectStack)
}

FindFrontMostVisibleChildWindow :: proc(window : ^ImGuiWindow) -> ^ImGuiWindow
{
	for n : i32 = window.DC.ChildWindows.Size - 1; n >= 0; post_decr(&n) { if IsWindowActiveAndVisible(window.DC.ChildWindows[n]) { return FindFrontMostVisibleChildWindow(window.DC.ChildWindows[n]) } }

	return window
}

RenderDimmedBackgroundBehindWindow :: proc(window : ^ImGuiWindow, col : ImU32)
{
	if (col & IM_COL32_A_MASK) == 0 { return }

	viewport : ^ImGuiViewportP = window.Viewport
	viewport_rect : ImRect = GetMainRect(viewport)

	// Draw behind window by moving the draw command at the FRONT of the draw list
	{
	// Draw list have been trimmed already, hence the explicit recreation of a draw command if missing.
	// FIXME: This is creating complication, might be simpler if we could inject a drawlist in drawdata at a given position and not attempt to manipulate ImDrawCmd order.
	draw_list : ^ImDrawList = window.RootWindowDockTree.DrawList
	ChannelsMerge(draw_list)
	if draw_list.CmdBuffer.Size == 0 { AddDrawCmd(draw_list) }
	PushClipRect(draw_list, viewport_rect.Min - ImVec2(1, 1), viewport_rect.Max + ImVec2(1, 1), false); // FIXME: Need to stricty ensure ImDrawCmd are not merged (ElemCount==6 checks below will verify that)
	AddRectFilled(draw_list, viewport_rect.Min, viewport_rect.Max, col)
	cmd : ImDrawCmd = back(&draw_list.CmdBuffer)
	IM_ASSERT(cmd.ElemCount == 6)
	pop_back(&draw_list.CmdBuffer)
	push_front(&draw_list.CmdBuffer, cmd)
	AddDrawCmd(draw_list); // We need to create a command as CmdBuffer.back().IdxOffset won't be correct if we append to same command.
	PopClipRect(draw_list)
	}

	// Draw over sibling docking nodes in a same docking tree
	if window.RootWindow.DockIsActive {
		draw_list : ^ImDrawList = FindFrontMostVisibleChildWindow(window.RootWindowDockTree).DrawList
		ChannelsMerge(draw_list)
		if draw_list.CmdBuffer.Size == 0 { AddDrawCmd(draw_list) }
		PushClipRect(draw_list, viewport_rect.Min, viewport_rect.Max, false)
		RenderRectFilledWithHole(draw_list, Rect(window.RootWindowDockTree), Rect(window.RootWindow), col, 0.0); // window->RootWindowDockTree->WindowRounding);
		PopClipRect(draw_list)
	}
}

FindBottomMostVisibleWindowWithinBeginStack :: proc(parent_window : ^ImGuiWindow) -> ^ImGuiWindow
{
	g : ^ImGuiContext = GImGui^
	bottom_most_visible_window : ^ImGuiWindow = parent_window
	for i : i32 = FindWindowDisplayIndex(parent_window); i >= 0; post_decr(&i) {
		window : ^ImGuiWindow = g.Windows[i]
		if window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_ChildWindow { continue }
		if !IsWindowWithinBeginStackOf(window, parent_window) { break }
		if IsWindowActiveAndVisible(window) && GetWindowDisplayLayer(window) <= GetWindowDisplayLayer(parent_window) { bottom_most_visible_window = window }
	}

	return bottom_most_visible_window
}

// Important: AddWindowToDrawData() has not been called yet, meaning DockNodeHost windows needs a DrawList->ChannelsMerge() before usage.
// We call ChannelsMerge() lazily here at it is faster that doing a full iteration of g.Windows[] prior to calling RenderDimmedBackgrounds().
RenderDimmedBackgrounds :: proc()
{
	g : ^ImGuiContext = GImGui^
	modal_window : ^ImGuiWindow = GetTopMostAndVisiblePopupModal()
	if g.DimBgRatio <= 0.0 && g.NavWindowingHighlightAlpha <= 0.0 { return }
	dim_bg_for_modal : bool = (modal_window != nil)
	dim_bg_for_window_list : bool = (g.NavWindowingTargetAnim != nil && g.NavWindowingTargetAnim.Active)
	if !dim_bg_for_modal && !dim_bg_for_window_list { return }

	viewports_already_dimmed : [2]^ImGuiViewport = {nil, nil}
	if dim_bg_for_modal {
		// Draw dimming behind modal or a begin stack child, whichever comes first in draw order.
		dim_behind_window : ^ImGuiWindow = FindBottomMostVisibleWindowWithinBeginStack(modal_window)
		RenderDimmedBackgroundBehindWindow(dim_behind_window, GetColorU32(modal_window.DC.ModalDimBgColor, g.DimBgRatio))
		viewports_already_dimmed[0] = modal_window.Viewport
	}
	else if dim_bg_for_window_list {
		// Draw dimming behind CTRL+Tab target window and behind CTRL+Tab UI window
		RenderDimmedBackgroundBehindWindow(g.NavWindowingTargetAnim, GetColorU32(ImGuiCol_.ImGuiCol_NavWindowingDimBg, g.DimBgRatio))
		if g.NavWindowingListWindow != nil && g.NavWindowingListWindow.Viewport && g.NavWindowingListWindow.Viewport != g.NavWindowingTargetAnim.Viewport { RenderDimmedBackgroundBehindWindow(g.NavWindowingListWindow, GetColorU32(ImGuiCol_.ImGuiCol_NavWindowingDimBg, g.DimBgRatio)) }
		viewports_already_dimmed[0] = g.NavWindowingTargetAnim.Viewport
		viewports_already_dimmed[1] = g.NavWindowingListWindow ? g.NavWindowingListWindow.Viewport : nil

		// Draw border around CTRL+Tab target window
		window : ^ImGuiWindow = g.NavWindowingTargetAnim
		viewport : ^ImGuiViewport = window.Viewport
		distance : f32 = g.FontSize
		bb : ImRect = Rect(window)
		Expand(&bb, distance)
		if GetWidth(&bb) >= viewport.Size.x && GetHeight(&bb) >= viewport.Size.y {
			// If a window fits the entire viewport, adjust its highlight inward
			Expand(&bb, -distance - 1.0)
		}
		ChannelsMerge(window.DrawList)
		if window.DrawList.CmdBuffer.Size == 0 { AddDrawCmd(window.DrawList) }
		PushClipRect(window.DrawList, viewport.Pos, viewport.Pos + viewport.Size)
		AddRect(window.DrawList, bb.Min, bb.Max, GetColorU32(ImGuiCol_.ImGuiCol_NavWindowingHighlight, g.NavWindowingHighlightAlpha), window.WindowRounding, 0, 3.0)
		PopClipRect(window.DrawList)
	}

	// Draw dimming background on _other_ viewports than the ones our windows are in
	for viewport in g.Viewports {
		if viewport == viewports_already_dimmed[0] || viewport == viewports_already_dimmed[1] { continue }
		if modal_window && viewport.Window && IsWindowAbove(viewport.Window, modal_window) { continue }
		draw_list : ^ImDrawList = GetForegroundDrawList(viewport)
		dim_bg_col : ImU32 = GetColorU32(dim_bg_for_modal ? ImGuiCol_.ImGuiCol_ModalWindowDimBg : ImGuiCol_.ImGuiCol_NavWindowingDimBg, g.DimBgRatio)
		AddRectFilled(draw_list, viewport.Pos, viewport.Pos + viewport.Size, dim_bg_col)
	}
}

// ends the Dear ImGui frame. automatically called by Render(). If you don't need to render data (skipping rendering) you may call EndFrame() without Render()... but you'll have wasted CPU already! If you don't need to render, better to not create any windows and not call NewFrame() at all!
// This is normally called by Render(). You may want to call it directly if you want to avoid calling Render() but the gain will be very minimal.
EndFrame :: proc()
{
	g : ^ImGuiContext = GImGui^
	IM_ASSERT(g.Initialized)

	// Don't process EndFrame() multiple times.
	if g.FrameCountEnded == g.FrameCount { return }
	IM_ASSERT(g.WithinFrameScope && "Forgot to call ImGui::NewFrame()?")

	CallContextHooks(&g, ImGuiContextHookType.ImGuiContextHookType_EndFramePre)

	// [EXPERIMENTAL] Recover from errors
	if g.IO.ConfigErrorRecovery { ErrorRecoveryTryToRecoverState(&g.StackSizesInNewFrame) }
	ErrorCheckEndFrameSanityChecks()
	ErrorCheckEndFrameFinalizeErrorTooltip()

	// Notify Platform/OS when our Input Method Editor cursor has moved (e.g. CJK inputs using Microsoft IME)
	ime_data : ^ImGuiPlatformImeData = &g.PlatformImeData
	if g.PlatformIO.Platform_SetImeDataFn != nil && memcmp(ime_data, &g.PlatformImeDataPrev, size_of(ImGuiPlatformImeData)) != 0 {
		viewport : ^ImGuiViewport = FindViewportByID(g.PlatformImeViewport)
		IMGUI_DEBUG_LOG_IO("[io] Calling Platform_SetImeDataFn(): WantVisible: %d, InputPos (%.2f,%.2f)\n", ime_data.WantVisible, ime_data.InputPos.x, ime_data.InputPos.y)
		if viewport == nil { viewport = GetMainViewport() }
		Platform_SetImeDataFn(&g.PlatformIO, &g, viewport, ime_data)
	}

	// Hide implicit/fallback "Debug" window if it hasn't been used
	g.WithinFrameScopeWithImplicitWindow = false
	if g.CurrentWindow && !g.CurrentWindow.WriteAccessed { g.CurrentWindow.Active = false }
	End()

	// Update navigation: CTRL+Tab, wrap-around requests
	NavEndFrame()

	// Update docking
	DockContextEndFrame(&g)

	SetCurrentViewport(nil, nil)

	// Drag and Drop: Elapse payload (if delivered, or if source stops being submitted)
	if g.DragDropActive {
		is_delivered : bool = g.DragDropPayload.Delivery
		is_elapsed : bool = (g.DragDropSourceFrameCount + 1 < g.FrameCount) && ((g.DragDropSourceFlags & ImGuiDragDropFlags_.ImGuiDragDropFlags_PayloadAutoExpire) || g.DragDropMouseButton == -1 || !IsMouseDown(g.DragDropMouseButton))
		if is_delivered || is_elapsed { ClearDragDrop() }
	}

	// Drag and Drop: Fallback for missing source tooltip. This is not ideal but better than nothing.
	// If you want to handle source item disappearing: instead of submitting your description tooltip
	// in the BeginDragDropSource() block of the dragged item, you can submit them from a safe single spot
	// (e.g. end of your item loop, or before EndFrame) by reading payload data.
	// In the typical case, the contents of drag tooltip should be possible to infer solely from payload data.
	if g.DragDropActive && g.DragDropSourceFrameCount + 1 < g.FrameCount && !(g.DragDropSourceFlags & ImGuiDragDropFlags_.ImGuiDragDropFlags_SourceNoPreviewTooltip) {
		g.DragDropWithinSource = true
		SetTooltip("...")
		g.DragDropWithinSource = false
	}

	// End frame
	g.WithinFrameScope = false
	g.FrameCountEnded = g.FrameCount

	// Initiate moving window + handle left-click and right-click focus
	UpdateMouseMovingWindowEndFrame()

	// Update user-facing viewport list (g.Viewports -> g.PlatformIO.Viewports after filtering out some)
	UpdateViewportsEndFrame()

	// Sort the window list so that all child windows are after their parent
	// We cannot do that on FocusWindow() because children may not exist yet
	resize(&g.WindowsTempSortBuffer, 0)
	reserve(&g.WindowsTempSortBuffer, g.Windows.Size)
	for window in g.Windows {
		if window.Active && (window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_ChildWindow) {
			// if a child is active its parent will add itcontinue
		}
		AddWindowToSortBuffer(&g.WindowsTempSortBuffer, window)
	}

	// This usually assert if there is a mismatch between the ImGuiWindowFlags_ChildWindow / ParentWindow values and DC.ChildWindows[] in parents, aka we've done something wrong.
	IM_ASSERT(g.Windows.Size == g.WindowsTempSortBuffer.Size)
	swap(&g.Windows, g.WindowsTempSortBuffer)
	g.IO.MetricsActiveWindows = g.WindowsActiveCount

	// Unlock font atlas
	g.IO.Fonts.Locked = false

	// Clear Input data for next frame
	g.IO.MousePosPrev = g.IO.MousePos
	g.IO.AppFocusLost = false
	g.IO.MouseWheelH = 0.0; g.IO.MouseWheel = g.IO.MouseWheelH
	resize(&g.IO.InputQueueCharacters, 0)

	CallContextHooks(&g, ImGuiContextHookType.ImGuiContextHookType_EndFramePost)
}

// ends the Dear ImGui frame, finalize the draw data. You can then get call GetDrawData().
// Prepare the data for rendering so you can call GetDrawData()
// (As with anything within the ImGui:: namspace this doesn't touch your GPU or graphics API at all:
// it is the role of the ImGui_ImplXXXX_RenderDrawData() function provided by the renderer backend)
Render :: proc()
{
	g : ^ImGuiContext = GImGui^
	IM_ASSERT(g.Initialized)

	if g.FrameCountEnded != g.FrameCount { EndFrame() }
	if g.FrameCountRendered == g.FrameCount { return }
	g.FrameCountRendered = g.FrameCount

	g.IO.MetricsRenderWindows = 0
	CallContextHooks(&g, ImGuiContextHookType.ImGuiContextHookType_RenderPre)

	// Add background ImDrawList (for each active viewport)
	for viewport in g.Viewports {
		InitViewportDrawData(viewport)
		if viewport.BgFgDrawLists[0] != nil { AddDrawListToDrawDataEx(&viewport.DrawDataP, viewport.DrawDataBuilder.Layers[0], GetBackgroundDrawList(viewport)) }
	}

	// Draw modal/window whitening backgrounds
	RenderDimmedBackgrounds()

	// Add ImDrawList to render
	windows_to_render_top_most : [2]^ImGuiWindow
	windows_to_render_top_most[0] = (g.NavWindowingTarget && !(g.NavWindowingTarget.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoBringToFrontOnFocus)) ? g.NavWindowingTarget.RootWindowDockTree : nil
	windows_to_render_top_most[1] = (g.NavWindowingTarget ? g.NavWindowingListWindow : nil)
	for window in g.Windows {
		if IsWindowActiveAndVisible(window) && (window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_ChildWindow) == 0 && window != windows_to_render_top_most[0] && window != windows_to_render_top_most[1] { AddRootWindowToDrawData(window) }
	}

	for n : i32 = 0; n < IM_ARRAYSIZE(windows_to_render_top_most); post_incr(&n) { if windows_to_render_top_most[n] && IsWindowActiveAndVisible(windows_to_render_top_most[n]) {
	// NavWindowingTarget is always temporarily displayed as the top-most windowAddRootWindowToDrawData(windows_to_render_top_most[n])
} }

	// Draw software mouse cursor if requested by io.MouseDrawCursor flag
	if g.IO.MouseDrawCursor && g.MouseCursor != ImGuiMouseCursor_.ImGuiMouseCursor_None { RenderMouseCursor(g.IO.MousePos, g.Style.MouseCursorScale, g.MouseCursor, IM_COL32_WHITE, IM_COL32_BLACK, IM_COL32(0, 0, 0, 48)) }

	// Setup ImDrawData structures for end-user
	g.IO.MetricsRenderIndices = 0; g.IO.MetricsRenderVertices = g.IO.MetricsRenderIndices
	for viewport in g.Viewports {
		FlattenDrawDataIntoSingleLayer(&viewport.DrawDataBuilder)

		// Add foreground ImDrawList (for each active viewport)
		if viewport.BgFgDrawLists[1] != nil { AddDrawListToDrawDataEx(&viewport.DrawDataP, viewport.DrawDataBuilder.Layers[0], GetForegroundDrawList(viewport)) }

		// We call _PopUnusedDrawCmd() last thing, as RenderDimmedBackgrounds() rely on a valid command being there (especially in docking branch).
		draw_data : ^ImDrawData = &viewport.DrawDataP
		IM_ASSERT(draw_data.CmdLists.Size == draw_data.CmdListsCount)
		for draw_list in draw_data.CmdLists { _PopUnusedDrawCmd(draw_list) }

		g.IO.MetricsRenderVertices += draw_data.TotalVtxCount
		g.IO.MetricsRenderIndices += draw_data.TotalIdxCount
	}

	CallContextHooks(&g, ImGuiContextHookType.ImGuiContextHookType_RenderPost)
}

// Text Utilities
// Calculate text size. Text can be multi-line. Optionally ignore text after a ## marker.
// CalcTextSize("") should return ImVec2(0.0f, g.FontSize)
CalcTextSize :: proc(text : ^u8, text_end : ^u8, hide_text_after_double_hash : bool, wrap_width : f32) -> ImVec2
{
	g : ^ImGuiContext = GImGui^

	text_display_end : ^u8
	if hide_text_after_double_hash {
		// Hide anything after a '##' string
		text_display_end = FindRenderedTextEnd(text, text_end)
	}
	else { text_display_end = text_end }

	font : ^ImFont = g.Font
	font_size : f32 = g.FontSize
	if text == text_display_end { return ImVec2(0.0, font_size) }
	text_size : ImVec2 = CalcTextSizeA(font, font_size, FLT_MAX, wrap_width, text, text_display_end, nil)

	// Round
	// FIXME: This has been here since Dec 2015 (7b0bf230) but down the line we want this out.
	// FIXME: Investigate using ceilf or e.g.
	// - https://git.musl-libc.org/cgit/musl/tree/src/math/ceilf.c
	// - https://embarkstudios.github.io/rust-gpu/api/src/libm/math/ceilf.rs.html
	text_size.x = IM_TRUNC(text_size.x + 0.99999)

	return text_size
}

// Find window given position, search front-to-back
// - Typically write output back to g.HoveredWindow and g.HoveredWindowUnderMovingWindow.
// - FIXME: Note that we have an inconsequential lag here: OuterRectClipped is updated in Begin(), so windows moved programmatically
//   with SetWindowPos() and not SetNextWindowPos() will have that rectangle lagging by a frame at the time FindHoveredWindow() is
//   called, aka before the next Begin(). Moving window isn't affected.
// - The 'find_first_and_in_any_viewport = true' mode is only used by TestEngine. It is simpler to maintain here.
FindHoveredWindowEx :: proc(pos : ^ImVec2, find_first_and_in_any_viewport : bool, out_hovered_window : ^^ImGuiWindow, out_hovered_window_under_moving_window : ^^ImGuiWindow)
{
	g : ^ImGuiContext = GImGui^
	hovered_window : ^ImGuiWindow = nil
	hovered_window_under_moving_window : ^ImGuiWindow = nil

	// Special handling for the window being moved: Ignore the mouse viewport check (because it may reset/lose its viewport during the undocking frame)
	backup_moving_window_viewport : ^ImGuiViewportP = nil
	if find_first_and_in_any_viewport == false && g.MovingWindow {
		backup_moving_window_viewport = g.MovingWindow.Viewport
		g.MovingWindow.Viewport = g.MouseViewport
		if !(g.MovingWindow.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoMouseInputs) { hovered_window = g.MovingWindow }
	}

	padding_regular : ImVec2 = g.Style.TouchExtraPadding
	padding_for_resize : ImVec2 = g.IO.ConfigWindowsResizeFromEdges ? g.WindowsHoverPadding : padding_regular
	for i : i32 = g.Windows.Size - 1; i >= 0; post_decr(&i) {
		window : ^ImGuiWindow = g.Windows[i]
		if !window.WasActive || window.Hidden { continue }
		if window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoMouseInputs { continue }
		IM_ASSERT(window.Viewport)
		if window.Viewport != g.MouseViewport { continue }

		// Using the clipped AABB, a child window will typically be clipped by its parent (not always)
		hit_padding : ImVec2 = (window.Flags & (ImGuiWindowFlags_.ImGuiWindowFlags_NoResize | ImGuiWindowFlags_.ImGuiWindowFlags_AlwaysAutoResize)) ? padding_regular : padding_for_resize
		if !ContainsWithPad(&window.OuterRectClipped, pos, hit_padding) { continue }

		// Support for one rectangular hole in any given window
		// FIXME: Consider generalizing hit-testing override (with more generic data, callback, etc.) (#1512)
		if window.HitTestHoleSize.x != 0 {
			hole_pos : ImVec2; init(&hole_pos, window.Pos.x + cast(f32) window.HitTestHoleOffset.x, window.Pos.y + cast(f32) window.HitTestHoleOffset.y)
			hole_size : ImVec2; init(&hole_size, cast(f32) window.HitTestHoleSize.x, cast(f32) window.HitTestHoleSize.y)
			if Contains(&ImRect(hole_pos, hole_pos + hole_size), pos) { continue }
		}

		if find_first_and_in_any_viewport {
			hovered_window = window
			break
		}
		else {
			if hovered_window == nil { hovered_window = window }
			if hovered_window_under_moving_window == nil && (!g.MovingWindow || window.RootWindowDockTree != g.MovingWindow.RootWindowDockTree) { hovered_window_under_moving_window = window }
			if hovered_window && hovered_window_under_moving_window { break }
		}
	}

	out_hovered_window^ = hovered_window
	if out_hovered_window_under_moving_window != nil { out_hovered_window_under_moving_window^ = hovered_window_under_moving_window }
	if find_first_and_in_any_viewport == false && g.MovingWindow { g.MovingWindow.Viewport = backup_moving_window_viewport }
}

// is the last item active? (e.g. button being held, text field being edited. This will continuously return true while holding mouse button on an item. Items that don't interact will always return false)
IsItemActive :: proc() -> bool
{
	g : ^ImGuiContext = GImGui^
	if g.ActiveId { return g.ActiveId == g.LastItemData.ID }
	return false
}

// was the last item just made active (item was previously inactive).
IsItemActivated :: proc() -> bool
{
	g : ^ImGuiContext = GImGui^
	if g.ActiveId { if g.ActiveId == g.LastItemData.ID && g.ActiveIdPreviousFrame != g.LastItemData.ID { return true } }
	return false
}

// was the last item just made inactive (item was previously active). Useful for Undo/Redo patterns with widgets that require continuous editing.
IsItemDeactivated :: proc() -> bool
{
	g : ^ImGuiContext = GImGui^
	if g.LastItemData.StatusFlags & ImGuiItemStatusFlags_.ImGuiItemStatusFlags_HasDeactivated { return (g.LastItemData.StatusFlags & ImGuiItemStatusFlags_.ImGuiItemStatusFlags_Deactivated) != 0 }
	return (g.ActiveIdPreviousFrame == g.LastItemData.ID && g.ActiveIdPreviousFrame != 0 && g.ActiveId != g.LastItemData.ID)
}

// was the last item just made inactive and made a value change when it was active? (e.g. Slider/Drag moved). Useful for Undo/Redo patterns with widgets that require continuous editing. Note that you may get false positives (some widgets such as Combo()/ListBox()/Selectable() will return true even when clicking an already selected item).
IsItemDeactivatedAfterEdit :: proc() -> bool
{
	g : ^ImGuiContext = GImGui^
	return IsItemDeactivated() && (g.ActiveIdPreviousFrameHasBeenEditedBefore || (g.ActiveId == 0 && g.ActiveIdHasBeenEditedBefore))
}

// is the last item focused for keyboard/gamepad navigation?
// == (GetItemID() == GetFocusID() && GetFocusID() != 0)
IsItemFocused :: proc() -> bool
{
	g : ^ImGuiContext = GImGui^
	if g.NavId != g.LastItemData.ID || g.NavId == 0 { return false }

	// Special handling for the dummy item after Begin() which represent the title bar or tab.
	// When the window is collapsed (SkipItems==true) that last item will never be overwritten so we need to detect the case.
	window : ^ImGuiWindow = g.CurrentWindow
	if g.LastItemData.ID == window.ID && window.WriteAccessed { return false }

	return true
}

// is the last item hovered and mouse clicked on? (**)  == IsMouseClicked(mouse_button) && IsItemHovered()Important. (**) this is NOT equivalent to the behavior of e.g. Button(). Read comments in function definition.
// Important: this can be useful but it is NOT equivalent to the behavior of e.g.Button()!
// Most widgets have specific reactions based on mouse-up/down state, mouse position etc.
IsItemClicked :: proc(mouse_button : ImGuiMouseButton) -> bool
{
	return IsMouseClicked(mouse_button) && IsItemHovered(ImGuiHoveredFlags_.ImGuiHoveredFlags_None)
}

// was the last item open state toggled? set by TreeNode().
IsItemToggledOpen :: proc() -> bool
{
	g : ^ImGuiContext = GImGui^
	return (g.LastItemData.StatusFlags & ImGuiItemStatusFlags_.ImGuiItemStatusFlags_ToggledOpen) ? true : false
}

// Was the last item selection state toggled? Useful if you need the per-item information _before_ reaching EndMultiSelect(). We only returns toggle _event_ in order to handle clipping correctly.
// Call after a Selectable() or TreeNode() involved in multi-selection.
// Useful if you need the per-item information before reaching EndMultiSelect(), e.g. for rendering purpose.
// This is only meant to be called inside a BeginMultiSelect()/EndMultiSelect() block.
// (Outside of multi-select, it would be misleading/ambiguous to report this signal, as widgets
// return e.g. a pressed event and user code is in charge of altering selection in ways we cannot predict.)
IsItemToggledSelection :: proc() -> bool
{
	g : ^ImGuiContext = GImGui^
	IM_ASSERT(g.CurrentMultiSelect != nil); // Can only be used inside a BeginMultiSelect()/EndMultiSelect()
	return (g.LastItemData.StatusFlags & ImGuiItemStatusFlags_.ImGuiItemStatusFlags_ToggledSelection) ? true : false
}

// is any item hovered?
// IMPORTANT: If you are trying to check whether your mouse should be dispatched to Dear ImGui or to your underlying app,
// you should not use this function! Use the 'io.WantCaptureMouse' boolean for that!
// Refer to FAQ entry "How can I tell whether to dispatch mouse/keyboard to Dear ImGui or my application?" for details.
IsAnyItemHovered :: proc() -> bool
{
	g : ^ImGuiContext = GImGui^
	return g.HoveredId != 0 || g.HoveredIdPreviousFrame != 0
}

// is any item active?
IsAnyItemActive :: proc() -> bool
{
	g : ^ImGuiContext = GImGui^
	return g.ActiveId != 0
}

// is any item focused?
IsAnyItemFocused :: proc() -> bool
{
	g : ^ImGuiContext = GImGui^
	return g.NavId != 0 && g.NavCursorVisible
}

// is the last item visible? (items may be out of sight because of clipping/scrolling)
IsItemVisible :: proc() -> bool
{
	g : ^ImGuiContext = GImGui^
	return (g.LastItemData.StatusFlags & ImGuiItemStatusFlags_.ImGuiItemStatusFlags_Visible) != 0
}

// did the last item modify its underlying value this frame? or was pressed? This is generally the same as the "bool" return value of many widgets.
IsItemEdited :: proc() -> bool
{
	g : ^ImGuiContext = GImGui^
	return (g.LastItemData.StatusFlags & ImGuiItemStatusFlags_.ImGuiItemStatusFlags_Edited) != 0
}

// Overlapping mode
// allow next item to be overlapped by a subsequent item. Useful with invisible buttons, selectable, treenode covering an area where subsequent items may need to be added. Note that both Selectable() and TreeNode() have dedicated flags doing this.
// Allow next item to be overlapped by subsequent items.
// This works by requiring HoveredId to match for two subsequent frames,
// so if a following items overwrite it our interactions will naturally be disabled.
SetNextItemAllowOverlap :: proc()
{
	g : ^ImGuiContext = GImGui^
	g.NextItemData.ItemFlags |= ImGuiItemFlagsPrivate_.ImGuiItemFlags_AllowOverlap
}

// This is a shortcut for not taking ownership of 100+ keys, frequently used by drag operations.
// FIXME: It might be undesirable that this will likely disable KeyOwner-aware shortcuts systems. Consider a more fine-tuned version if needed?
SetActiveIdUsingAllKeyboardKeys :: proc()
{
	g : ^ImGuiContext = GImGui^
	IM_ASSERT(g.ActiveId != 0)
	g.ActiveIdUsingNavDirMask = (1 << ImGuiDir.ImGuiDir_COUNT) - 1
	g.ActiveIdUsingAllKeyboardKeys = true
	NavMoveRequestCancel()
}

// get ID of last item (~~ often same ImGui::GetID(label) beforehand)
GetItemID :: proc() -> ImGuiID
{
	g : ^ImGuiContext = GImGui^
	return g.LastItemData.ID
}

// get upper-left bounding rectangle of the last item (screen space)
GetItemRectMin :: proc() -> ImVec2
{
	g : ^ImGuiContext = GImGui^
	return g.LastItemData.Rect.Min
}

// get lower-right bounding rectangle of the last item (screen space)
GetItemRectMax :: proc() -> ImVec2
{
	g : ^ImGuiContext = GImGui^
	return g.LastItemData.Rect.Max
}

// get size of last item
GetItemRectSize :: proc() -> ImVec2
{
	g : ^ImGuiContext = GImGui^
	return GetSize(&g.LastItemData.Rect)
}

// Child Windows
// - Use child windows to begin into a self-contained independent scrolling/clipping regions within a host window. Child windows can embed their own child.
// - Before 1.90 (November 2023), the "ImGuiChildFlags child_flags = 0" parameter was "bool border = false".
//   This API is backward compatible with old code, as we guarantee that ImGuiChildFlags_Borders == true.
//   Consider updating your old code:
//      BeginChild("Name", size, false)   -> Begin("Name", size, 0); or Begin("Name", size, ImGuiChildFlags_None);
//      BeginChild("Name", size, true)    -> Begin("Name", size, ImGuiChildFlags_Borders);
// - Manual sizing (each axis can use a different setting e.g. ImVec2(0.0f, 400.0f)):
//     == 0.0f: use remaining parent window size for this axis.
//      > 0.0f: use specified size for this axis.
//      < 0.0f: right/bottom-align to specified distance from available content boundaries.
// - Specifying ImGuiChildFlags_AutoResizeX or ImGuiChildFlags_AutoResizeY makes the sizing automatic based on child contents.
//   Combining both ImGuiChildFlags_AutoResizeX _and_ ImGuiChildFlags_AutoResizeY defeats purpose of a scrolling region and is NOT recommended.
// - BeginChild() returns false to indicate the window is collapsed or fully clipped, so you may early out and omit submitting
//   anything to the window. Always call a matching EndChild() for each BeginChild() call, regardless of its return value.
//   [Important: due to legacy reason, Begin/End and BeginChild/EndChild are inconsistent with all other functions
//    such as BeginMenu/EndMenu, BeginPopup/EndPopup, etc. where the EndXXX call should only be called if the corresponding
//    BeginXXX function returned true. Begin and BeginChild are the only odd ones out. Will be fixed in a future update.]
// Prior to v1.90 2023/10/16, the BeginChild() function took a 'bool border = false' parameter instead of 'ImGuiChildFlags child_flags = 0'.
// ImGuiChildFlags_Borders is defined as always == 1 in order to allow old code passing 'true'. Read comments in imgui.h for details!
BeginChild_0 :: proc(str_id : ^u8, size_arg : ^ImVec2, child_flags : ImGuiChildFlags, window_flags : ImGuiWindowFlags) -> bool
{
	id : ImGuiID = GetID(GetCurrentWindow(), str_id)
	return BeginChildEx(str_id, id, size_arg, child_flags, window_flags)
}

// Child Windows
// - Use child windows to begin into a self-contained independent scrolling/clipping regions within a host window. Child windows can embed their own child.
// - Before 1.90 (November 2023), the "ImGuiChildFlags child_flags = 0" parameter was "bool border = false".
//   This API is backward compatible with old code, as we guarantee that ImGuiChildFlags_Borders == true.
//   Consider updating your old code:
//      BeginChild("Name", size, false)   -> Begin("Name", size, 0); or Begin("Name", size, ImGuiChildFlags_None);
//      BeginChild("Name", size, true)    -> Begin("Name", size, ImGuiChildFlags_Borders);
// - Manual sizing (each axis can use a different setting e.g. ImVec2(0.0f, 400.0f)):
//     == 0.0f: use remaining parent window size for this axis.
//      > 0.0f: use specified size for this axis.
//      < 0.0f: right/bottom-align to specified distance from available content boundaries.
// - Specifying ImGuiChildFlags_AutoResizeX or ImGuiChildFlags_AutoResizeY makes the sizing automatic based on child contents.
//   Combining both ImGuiChildFlags_AutoResizeX _and_ ImGuiChildFlags_AutoResizeY defeats purpose of a scrolling region and is NOT recommended.
// - BeginChild() returns false to indicate the window is collapsed or fully clipped, so you may early out and omit submitting
//   anything to the window. Always call a matching EndChild() for each BeginChild() call, regardless of its return value.
//   [Important: due to legacy reason, Begin/End and BeginChild/EndChild are inconsistent with all other functions
//    such as BeginMenu/EndMenu, BeginPopup/EndPopup, etc. where the EndXXX call should only be called if the corresponding
//    BeginXXX function returned true. Begin and BeginChild are the only odd ones out. Will be fixed in a future update.]
BeginChild_1 :: proc(id : ImGuiID, size_arg : ^ImVec2, child_flags : ImGuiChildFlags, window_flags : ImGuiWindowFlags) -> bool
{
	return BeginChildEx(nil, id, size_arg, child_flags, window_flags)
}

// Childs
BeginChildEx :: proc(name : ^u8, id : ImGuiID, size_arg : ^ImVec2, child_flags : ImGuiChildFlags, window_flags : ImGuiWindowFlags) -> bool
{
	g : ^ImGuiContext = GImGui^
	parent_window : ^ImGuiWindow = g.CurrentWindow
	IM_ASSERT(id != 0)

	// Sanity check as it is likely that some user will accidentally pass ImGuiWindowFlags into the ImGuiChildFlags argument.
	ImGuiChildFlags_SupportedMask_ : ImGuiChildFlags = ImGuiChildFlags_.ImGuiChildFlags_Borders | ImGuiChildFlags_.ImGuiChildFlags_AlwaysUseWindowPadding | ImGuiChildFlags_.ImGuiChildFlags_ResizeX | ImGuiChildFlags_.ImGuiChildFlags_ResizeY | ImGuiChildFlags_.ImGuiChildFlags_AutoResizeX | ImGuiChildFlags_.ImGuiChildFlags_AutoResizeY | ImGuiChildFlags_.ImGuiChildFlags_AlwaysAutoResize | ImGuiChildFlags_.ImGuiChildFlags_FrameStyle | ImGuiChildFlags_.ImGuiChildFlags_NavFlattened
	IM_UNUSED(ImGuiChildFlags_SupportedMask_)
	IM_ASSERT((child_flags & !ImGuiChildFlags_SupportedMask_) == 0 && "Illegal ImGuiChildFlags value. Did you pass ImGuiWindowFlags values instead of ImGuiChildFlags?")
	IM_ASSERT((window_flags & ImGuiWindowFlags_.ImGuiWindowFlags_AlwaysAutoResize) == 0 && "Cannot specify ImGuiWindowFlags_AlwaysAutoResize for BeginChild(). Use ImGuiChildFlags_AlwaysAutoResize!")
	if ImGuiChildFlags_AlwaysAutoResize : ^child_flags; ImGuiChildFlags_AlwaysAutoResize {
		IM_ASSERT((child_flags & (ImGuiChildFlags_.ImGuiChildFlags_ResizeX | ImGuiChildFlags_.ImGuiChildFlags_ResizeY)) == 0 && "Cannot use ImGuiChildFlags_ResizeX or ImGuiChildFlags_ResizeY with ImGuiChildFlags_AlwaysAutoResize!")
		IM_ASSERT((child_flags & (ImGuiChildFlags_.ImGuiChildFlags_AutoResizeX | ImGuiChildFlags_.ImGuiChildFlags_AutoResizeY)) != 0 && "Must use ImGuiChildFlags_AutoResizeX or ImGuiChildFlags_AutoResizeY with ImGuiChildFlags_AlwaysAutoResize!")
	}

	if ImGuiChildFlags_AutoResizeX : ^child_flags; ImGuiChildFlags_AutoResizeX { child_flags &= !ImGuiChildFlags_.ImGuiChildFlags_ResizeX }
	if ImGuiChildFlags_AutoResizeY : ^child_flags; ImGuiChildFlags_AutoResizeY { child_flags &= !ImGuiChildFlags_.ImGuiChildFlags_ResizeY }

	// Set window flags
	window_flags |= ImGuiWindowFlags_.ImGuiWindowFlags_ChildWindow | ImGuiWindowFlags_.ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_.ImGuiWindowFlags_NoDocking
	window_flags |= (parent_window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoMove); // Inherit the NoMove flag
	if child_flags & (ImGuiChildFlags_.ImGuiChildFlags_AutoResizeX | ImGuiChildFlags_.ImGuiChildFlags_AutoResizeY | ImGuiChildFlags_.ImGuiChildFlags_AlwaysAutoResize) { window_flags |= ImGuiWindowFlags_.ImGuiWindowFlags_AlwaysAutoResize }
	if (child_flags & (ImGuiChildFlags_.ImGuiChildFlags_ResizeX | ImGuiChildFlags_.ImGuiChildFlags_ResizeY)) == 0 { window_flags |= ImGuiWindowFlags_.ImGuiWindowFlags_NoResize | ImGuiWindowFlags_.ImGuiWindowFlags_NoSavedSettings }

	// Special framed style
	if ImGuiChildFlags_FrameStyle : ^child_flags; ImGuiChildFlags_FrameStyle {
		PushStyleColor(ImGuiCol_.ImGuiCol_ChildBg, g.Style.Colors[ImGuiCol_.ImGuiCol_FrameBg])
		PushStyleVar(ImGuiStyleVar_.ImGuiStyleVar_ChildRounding, g.Style.FrameRounding)
		PushStyleVar(ImGuiStyleVar_.ImGuiStyleVar_ChildBorderSize, g.Style.FrameBorderSize)
		PushStyleVar(ImGuiStyleVar_.ImGuiStyleVar_WindowPadding, g.Style.FramePadding)
		child_flags |= ImGuiChildFlags_.ImGuiChildFlags_Borders | ImGuiChildFlags_.ImGuiChildFlags_AlwaysUseWindowPadding
		window_flags |= ImGuiWindowFlags_.ImGuiWindowFlags_NoMove
	}

	// Forward size
	// Important: Begin() has special processing to switch condition to ImGuiCond_FirstUseEver for a given axis when ImGuiChildFlags_ResizeXXX is set.
	// (the alternative would to store conditional flags per axis, which is possible but more code)
	size_avail : ImVec2 = GetContentRegionAvail()
	size_default : ImVec2; init(&size_default, (child_flags & ImGuiChildFlags_.ImGuiChildFlags_AutoResizeX) ? 0.0 : size_avail.x, (child_flags & ImGuiChildFlags_.ImGuiChildFlags_AutoResizeY) ? 0.0 : size_avail.y)
	size : ImVec2 = CalcItemSize(size_arg, size_default.x, size_default.y)

	// A SetNextWindowSize() call always has priority (#8020)
	// (since the code in Begin() never supported SizeVal==0.0f aka auto-resize via SetNextWindowSize() call, we don't support it here for now)
	// FIXME: We only support ImGuiCond_Always in this path. Supporting other paths would requires to obtain window pointer.
	if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_.ImGuiNextWindowDataFlags_HasSize) != 0 && (g.NextWindowData.SizeCond & ImGuiCond_.ImGuiCond_Always) != 0 {
		if g.NextWindowData.SizeVal.x > 0.0 {
			size.x = g.NextWindowData.SizeVal.x
			child_flags &= !ImGuiChildFlags_.ImGuiChildFlags_ResizeX
		}
		if g.NextWindowData.SizeVal.y > 0.0 {
			size.y = g.NextWindowData.SizeVal.y
			child_flags &= !ImGuiChildFlags_.ImGuiChildFlags_ResizeY
		}
	}
	SetNextWindowSize(size)

	// Forward child flags (we allow prior settings to merge but it'll only work for adding flags)
	if g.NextWindowData.Flags & ImGuiNextWindowDataFlags_.ImGuiNextWindowDataFlags_HasChildFlags { g.NextWindowData.ChildFlags |= child_flags }
	else { g.NextWindowData.ChildFlags = child_flags }
	g.NextWindowData.Flags |= ImGuiNextWindowDataFlags_.ImGuiNextWindowDataFlags_HasChildFlags

	// Build up name. If you need to append to a same child from multiple location in the ID stack, use BeginChild(ImGuiID id) with a stable value.
	// FIXME: 2023/11/14: commented out shorted version. We had an issue with multiple ### in child window path names, which the trailing hash helped workaround.
	// e.g. "ParentName###ParentIdentifier/ChildName###ChildIdentifier" would get hashed incorrectly by ImHashStr(), trailing _%08X somehow fixes it.
	temp_window_name : ^u8
	/*if (name && parent_window->IDStack.back() == parent_window->ID)
        ImFormatStringToTempBuffer(&temp_window_name, NULL, "%s/%s", parent_window->Name, name); // May omit ID if in root of ID stack
    else*/
	if name { ImFormatStringToTempBuffer(&temp_window_name, nil, "%s/%s_%08X", parent_window.Name, name, id) }
	else { ImFormatStringToTempBuffer(&temp_window_name, nil, "%s/%08X", parent_window.Name, id) }

	// Set style
	backup_border_size : f32 = g.Style.ChildBorderSize
	if (child_flags & ImGuiChildFlags_.ImGuiChildFlags_Borders) == 0 { g.Style.ChildBorderSize = 0.0 }

	// Begin into window
	ret : bool = Begin(temp_window_name, nil, window_flags)

	// Restore style
	g.Style.ChildBorderSize = backup_border_size
	if ImGuiChildFlags_FrameStyle : ^child_flags; ImGuiChildFlags_FrameStyle {
		PopStyleVar(3)
		PopStyleColor()
	}

	child_window : ^ImGuiWindow = g.CurrentWindow
	child_window.ChildId = id

	// Set the cursor to handle case where the user called SetNextWindowPos()+BeginChild() manually.
	// While this is not really documented/defined, it seems that the expected thing to do.
	if child_window.BeginCount == 1 { parent_window.DC.CursorPos = child_window.Pos }

	// Process navigation-in immediately so NavInit can run on first frame
	// Can enter a child if (A) it has navigable items or (B) it can be scrolled.
	temp_id_for_activation : ImGuiID = ImHashStr("##Child", 0, id)
	if g.ActiveId == temp_id_for_activation { ClearActiveID() }
	if g.NavActivateId == id && !(child_flags & ImGuiChildFlags_.ImGuiChildFlags_NavFlattened) && (child_window.DC.NavLayersActiveMask != 0 || child_window.DC.NavWindowHasScrollY) {
		FocusWindow(child_window)
		NavInitWindow(child_window, false)
		SetActiveID(temp_id_for_activation, child_window); // Steal ActiveId with another arbitrary id so that key-press won't activate child item
		g.ActiveIdSource = g.NavInputSource
	}
	return ret
}

EndChild :: proc()
{
	g : ^ImGuiContext = GImGui^
	child_window : ^ImGuiWindow = g.CurrentWindow

	backup_within_end_child_id : ImGuiID = g.WithinEndChildID
	IM_ASSERT(child_window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_ChildWindow); // Mismatched BeginChild()/EndChild() calls

	g.WithinEndChildID = child_window.ID
	child_size : ImVec2 = child_window.Size
	End()
	if child_window.BeginCount == 1 {
		parent_window : ^ImGuiWindow = g.CurrentWindow
		bb : ImRect; init(&bb, parent_window.DC.CursorPos, parent_window.DC.CursorPos + child_size)
		ItemSize(child_size)
		nav_flattened : bool = (child_window.ChildFlags & ImGuiChildFlags_.ImGuiChildFlags_NavFlattened) != 0
		if (child_window.DC.NavLayersActiveMask != 0 || child_window.DC.NavWindowHasScrollY) && !nav_flattened {
			ItemAdd(bb, child_window.ChildId)
			RenderNavCursor(bb, child_window.ChildId)

			// When browsing a window that has no activable items (scroll only) we keep a highlight on the child (pass g.NavId to trick into always displaying)
			if child_window.DC.NavLayersActiveMask == 0 && child_window == g.NavWindow { RenderNavCursor(ImRect(bb.Min - ImVec2(2, 2), bb.Max + ImVec2(2, 2)), g.NavId, ImGuiNavRenderCursorFlags_.ImGuiNavRenderCursorFlags_Compact) }
		}
		else {
			// Not navigable into
			// - This is a bit of a fringe use case, mostly useful for undecorated, non-scrolling contents childs, or empty childs.
			// - We could later decide to not apply this path if ImGuiChildFlags_FrameStyle or ImGuiChildFlags_Borders is set.
			ItemAdd(bb, child_window.ChildId, nil, ImGuiItemFlags_.ImGuiItemFlags_NoNav)

			// But when flattened we directly reach items, adjust active layer mask accordingly
			if nav_flattened { parent_window.DC.NavLayersActiveMaskNext |= child_window.DC.NavLayersActiveMaskNext }
		}
		if g.HoveredWindow == child_window { g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_.ImGuiItemStatusFlags_HoveredWindow }
	}
	g.WithinEndChildID = backup_within_end_child_id
	g.LogLinePosY = -FLT_MAX; // To enforce a carriage return
}

SetWindowConditionAllowFlags :: proc(window : ^ImGuiWindow, flags : ImGuiCond, enabled : bool)
{
	window.SetWindowPosAllowFlags = enabled ? (window.SetWindowPosAllowFlags | flags) : (window.SetWindowPosAllowFlags & !flags)
	window.SetWindowSizeAllowFlags = enabled ? (window.SetWindowSizeAllowFlags | flags) : (window.SetWindowSizeAllowFlags & !flags)
	window.SetWindowCollapsedAllowFlags = enabled ? (window.SetWindowCollapsedAllowFlags | flags) : (window.SetWindowCollapsedAllowFlags & !flags)
	window.SetWindowDockAllowFlags = enabled ? (window.SetWindowDockAllowFlags | flags) : (window.SetWindowDockAllowFlags & !flags)
}

FindWindowByID :: proc(id : ImGuiID) -> ^ImGuiWindow
{
	g : ^ImGuiContext = GImGui^
	return cast(^ImGuiWindow) GetVoidPtr(&g.WindowsById, id)
}

FindWindowByName :: proc(name : ^u8) -> ^ImGuiWindow
{
	id : ImGuiID = ImHashStr(name)
	return FindWindowByID(id)
}

ApplyWindowSettings :: proc(window : ^ImGuiWindow, settings : ^ImGuiWindowSettings)
{
	main_viewport : ^ImGuiViewport = GetMainViewport()
	window.ViewportPos = main_viewport.Pos
	if settings.ViewportId {
		window.ViewportId = settings.ViewportId
		window.ViewportPos = ImVec2(settings.ViewportPos.x, settings.ViewportPos.y)
	}
	window.Pos = ImTrunc(ImVec2(settings.Pos.x + window.ViewportPos.x, settings.Pos.y + window.ViewportPos.y))
	if settings.Size.x > 0 && settings.Size.y > 0 { window.SizeFull = ImTrunc(ImVec2(settings.Size.x, settings.Size.y)); window.Size = window.SizeFull }
	window.Collapsed = settings.Collapsed
	window.DockId = settings.DockId
	window.DockOrder = settings.DockOrder
}

InitOrLoadWindowSettings :: proc(window : ^ImGuiWindow, settings : ^ImGuiWindowSettings)
{
	// Initial window state with e.g. default/arbitrary window position
	// Use SetNextWindowPos() with the appropriate condition flag to change the initial position of a window.
	main_viewport : ^ImGuiViewport = GetMainViewport()
	window.Pos = main_viewport.Pos + ImVec2(60, 60)
	window.SizeFull = ImVec2(0, 0); window.Size = window.SizeFull
	window.ViewportPos = main_viewport.Pos
	window.SetWindowDockAllowFlags = ImGuiCond_.ImGuiCond_Always | ImGuiCond_.ImGuiCond_Once | ImGuiCond_.ImGuiCond_FirstUseEver | ImGuiCond_.ImGuiCond_Appearing; window.SetWindowCollapsedAllowFlags = window.SetWindowDockAllowFlags; window.SetWindowSizeAllowFlags = window.SetWindowCollapsedAllowFlags; window.SetWindowPosAllowFlags = window.SetWindowSizeAllowFlags

	if settings != nil {
		SetWindowConditionAllowFlags(window, ImGuiCond_.ImGuiCond_FirstUseEver, false)
		ApplyWindowSettings(window, settings)
	}
	window.DC.IdealMaxPos = window.Pos; window.DC.CursorMaxPos = window.DC.IdealMaxPos; window.DC.CursorStartPos = window.DC.CursorMaxPos; // So first call to CalcWindowContentSizes() doesn't return crazy values

	if (window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_AlwaysAutoResize) != 0 {
		window.AutoFitFramesY = 2; window.AutoFitFramesX = window.AutoFitFramesY
		window.AutoFitOnlyGrows = false
	}
	else {
		if window.Size.x <= 0.0 { window.AutoFitFramesX = 2 }
		if window.Size.y <= 0.0 { window.AutoFitFramesY = 2 }
		window.AutoFitOnlyGrows = (window.AutoFitFramesX > 0) || (window.AutoFitFramesY > 0)
	}
}

CreateNewWindow :: proc(name : ^u8, flags : ImGuiWindowFlags) -> ^ImGuiWindow
{
	// Create window the first time
	//IMGUI_DEBUG_LOG("CreateNewWindow '%s', flags = 0x%08X\n", name, flags);
	g : ^ImGuiContext = GImGui^
	window : ^ImGuiWindow = IM_NEW(ImGuiWindow)(&g, name)
	window.Flags = flags
	SetVoidPtr(&g.WindowsById, window.ID, window)

	settings : ^ImGuiWindowSettings = nil
	if !(flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoSavedSettings) {
		settings = FindWindowSettingsByWindow(window)
		if settings != nil {
			window.SettingsOffset = offset_from_ptr(&g.SettingsWindows, settings)
		}
	}

	InitOrLoadWindowSettings(window, settings)

	if ImGuiWindowFlags_NoBringToFrontOnFocus : ^flags; ImGuiWindowFlags_NoBringToFrontOnFocus {
		// Quite slow but rare and only once
		push_front(&g.Windows, window)
	}
	else { push_back(&g.Windows, window) }

	return window
}

GetWindowForTitleDisplay :: proc(window : ^ImGuiWindow) -> ^ImGuiWindow
{
	return window.DockNodeAsHost ? window.DockNodeAsHost.VisibleWindow : window
}

GetWindowForTitleAndMenuHeight :: proc(window : ^ImGuiWindow) -> ^ImGuiWindow
{
	return (window.DockNodeAsHost && window.DockNodeAsHost.VisibleWindow) ? window.DockNodeAsHost.VisibleWindow : window
}

CalcWindowMinSize :: #force_inline proc(window : ^ImGuiWindow) -> ImVec2
{
	// We give windows non-zero minimum size to facilitate understanding problematic cases (e.g. empty popups)
	// FIXME: Essentially we want to restrict manual resizing to WindowMinSize+Decoration, and allow api resizing to be smaller.
	// Perhaps should tend further a neater test for this.
	g : ^ImGuiContext = GImGui^
	size_min : ImVec2
	if (window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_ChildWindow) && !(window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_Popup) {
		size_min.x = (window.ChildFlags & ImGuiChildFlags_.ImGuiChildFlags_ResizeX) ? g.Style.WindowMinSize.x : 4.0
		size_min.y = (window.ChildFlags & ImGuiChildFlags_.ImGuiChildFlags_ResizeY) ? g.Style.WindowMinSize.y : 4.0
	}
	else {
		size_min.x = ((window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_AlwaysAutoResize) == 0) ? g.Style.WindowMinSize.x : 4.0
		size_min.y = ((window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_AlwaysAutoResize) == 0) ? g.Style.WindowMinSize.y : 4.0
	}

	// Reduce artifacts with very small windows
	window_for_height : ^ImGuiWindow = GetWindowForTitleAndMenuHeight(window)
	size_min.y = ImMax(size_min.y, window_for_height.TitleBarHeight + window_for_height.MenuBarHeight + ImMax(0.0, g.Style.WindowRounding - 1.0))
	return size_min
}

CalcWindowSizeAfterConstraint :: proc(window : ^ImGuiWindow, size_desired : ^ImVec2) -> ImVec2
{
	g : ^ImGuiContext = GImGui^
	new_size : ImVec2 = size_desired
	if g.NextWindowData.Flags & ImGuiNextWindowDataFlags_.ImGuiNextWindowDataFlags_HasSizeConstraint {
		// See comments in SetNextWindowSizeConstraints() for details about setting size_min an size_max.
		cr : ImRect = g.NextWindowData.SizeConstraintRect
		new_size.x = (cr.Min.x >= 0 && cr.Max.x >= 0) ? ImClamp(new_size.x, cr.Min.x, cr.Max.x) : window.SizeFull.x
		new_size.y = (cr.Min.y >= 0 && cr.Max.y >= 0) ? ImClamp(new_size.y, cr.Min.y, cr.Max.y) : window.SizeFull.y
		if g.NextWindowData.SizeCallback {
			data : ImGuiSizeCallbackData
			data.UserData = g.NextWindowData.SizeCallbackUserData
			data.Pos = window.Pos
			data.CurrentSize = window.SizeFull
			data.DesiredSize = new_size
			SizeCallback(&g.NextWindowData, &data)
			new_size = data.DesiredSize
		}
		new_size.x = IM_TRUNC(new_size.x)
		new_size.y = IM_TRUNC(new_size.y)
	}

	// Minimum size
	size_min : ImVec2 = CalcWindowMinSize(window)
	return ImMax(new_size, size_min)
}

CalcWindowContentSizes :: proc(window : ^ImGuiWindow, content_size_current : ^ImVec2, content_size_ideal : ^ImVec2)
{
	preserve_old_content_sizes : bool = false
	if window.Collapsed && window.AutoFitFramesX <= 0 && window.AutoFitFramesY <= 0 { preserve_old_content_sizes = true }
	else if window.Hidden && window.HiddenFramesCannotSkipItems == 0 && window.HiddenFramesCanSkipItems > 0 { preserve_old_content_sizes = true }
	if preserve_old_content_sizes {
		content_size_current^ = window.ContentSize
		content_size_ideal^ = window.ContentSizeIdeal
		return
	}

	content_size_current.x = (window.ContentSizeExplicit.x != 0.0) ? window.ContentSizeExplicit.x : IM_TRUNC(window.DC.CursorMaxPos.x - window.DC.CursorStartPos.x)
	content_size_current.y = (window.ContentSizeExplicit.y != 0.0) ? window.ContentSizeExplicit.y : IM_TRUNC(window.DC.CursorMaxPos.y - window.DC.CursorStartPos.y)
	content_size_ideal.x = (window.ContentSizeExplicit.x != 0.0) ? window.ContentSizeExplicit.x : IM_TRUNC(ImMax(window.DC.CursorMaxPos.x, window.DC.IdealMaxPos.x) - window.DC.CursorStartPos.x)
	content_size_ideal.y = (window.ContentSizeExplicit.y != 0.0) ? window.ContentSizeExplicit.y : IM_TRUNC(ImMax(window.DC.CursorMaxPos.y, window.DC.IdealMaxPos.y) - window.DC.CursorStartPos.y)
}

CalcWindowAutoFitSize :: proc(window : ^ImGuiWindow, size_contents : ^ImVec2) -> ImVec2
{
	g : ^ImGuiContext = GImGui^
	style : ^ImGuiStyle = g.Style
	decoration_w_without_scrollbars : f32 = window.DecoOuterSizeX1 + window.DecoOuterSizeX2 - window.ScrollbarSizes.x
	decoration_h_without_scrollbars : f32 = window.DecoOuterSizeY1 + window.DecoOuterSizeY2 - window.ScrollbarSizes.y
	size_pad : ImVec2 = window.WindowPadding * 2.0
	size_desired : ImVec2 = size_contents + size_pad + ImVec2(decoration_w_without_scrollbars, decoration_h_without_scrollbars)
	if window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_Tooltip {
		// Tooltip always resize
		return size_desired
	}
	else {
		// Maximum window size is determined by the viewport size or monitor size
		size_min : ImVec2 = CalcWindowMinSize(window)
		size_max : ImVec2 = ImVec2(FLT_MAX, FLT_MAX)

		// Child windows are layed within their parent (unless they are also popups/menus) and thus have no restriction
		if (window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_ChildWindow) == 0 || (window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_Popup) != 0 {
			if !window.ViewportOwned { size_max = GetMainViewport().WorkSize - style.DisplaySafeAreaPadding * 2.0 }
			monitor_idx : i32 = window.ViewportAllowPlatformMonitorExtend
			if monitor_idx >= 0 && monitor_idx < g.PlatformIO.Monitors.Size { size_max = g.PlatformIO.Monitors[monitor_idx].WorkSize - style.DisplaySafeAreaPadding * 2.0 }
		}

		size_auto_fit : ImVec2 = ImClamp(size_desired, size_min, ImMax(size_min, size_max))

		// FIXME: CalcWindowAutoFitSize() doesn't take into account that only one axis may be auto-fit when calculating scrollbars,
		// we may need to compute/store three variants of size_auto_fit, for x/y/xy.
		// Here we implement a workaround for child windows only, but a full solution would apply to normal windows as well:
		if (window.ChildFlags & ImGuiChildFlags_.ImGuiChildFlags_ResizeX) && !(window.ChildFlags & ImGuiChildFlags_.ImGuiChildFlags_ResizeY) { size_auto_fit.y = window.SizeFull.y }
		else if !(window.ChildFlags & ImGuiChildFlags_.ImGuiChildFlags_ResizeX) && (window.ChildFlags & ImGuiChildFlags_.ImGuiChildFlags_ResizeY) { size_auto_fit.x = window.SizeFull.x }

		// When the window cannot fit all contents (either because of constraints, either because screen is too small),
		// we are growing the size on the other axis to compensate for expected scrollbar. FIXME: Might turn bigger than ViewportSize-WindowPadding.
		size_auto_fit_after_constraint : ImVec2 = CalcWindowSizeAfterConstraint(window, size_auto_fit)
		will_have_scrollbar_x : bool = (size_auto_fit_after_constraint.x - size_pad.x - decoration_w_without_scrollbars < size_contents.x && !(window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoScrollbar) && (window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_HorizontalScrollbar)) || (window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_AlwaysHorizontalScrollbar)
		will_have_scrollbar_y : bool = (size_auto_fit_after_constraint.y - size_pad.y - decoration_h_without_scrollbars < size_contents.y && !(window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoScrollbar)) || (window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_AlwaysVerticalScrollbar)
		if will_have_scrollbar_x { size_auto_fit.y += style.ScrollbarSize }
		if will_have_scrollbar_y { size_auto_fit.x += style.ScrollbarSize }
		return size_auto_fit
	}
}

CalcWindowNextAutoFitSize :: proc(window : ^ImGuiWindow) -> ImVec2
{
	size_contents_current : ImVec2
	size_contents_ideal : ImVec2
	CalcWindowContentSizes(window, &size_contents_current, &size_contents_ideal)
	size_auto_fit : ImVec2 = CalcWindowAutoFitSize(window, size_contents_ideal)
	size_final : ImVec2 = CalcWindowSizeAfterConstraint(window, size_auto_fit)
	return size_final
}

GetWindowBgColorIdx :: proc(window : ^ImGuiWindow) -> ImGuiCol
{
	if window.Flags & (ImGuiWindowFlags_.ImGuiWindowFlags_Tooltip | ImGuiWindowFlags_.ImGuiWindowFlags_Popup) { return ImGuiCol_.ImGuiCol_PopupBg }
	if (window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_ChildWindow) && !window.DockIsActive { return ImGuiCol_.ImGuiCol_ChildBg }
	return ImGuiCol_.ImGuiCol_WindowBg
}

CalcResizePosSizeFromAnyCorner :: proc(window : ^ImGuiWindow, corner_target : ^ImVec2, corner_norm : ^ImVec2, out_pos : ^ImVec2, out_size : ^ImVec2)
{
	pos_min : ImVec2 = ImLerp(corner_target, window.Pos, corner_norm); // Expected window upper-left
	pos_max : ImVec2 = ImLerp(window.Pos + window.Size, corner_target, corner_norm); // Expected window lower-right
	size_expected : ImVec2 = pos_max - pos_min
	size_constrained : ImVec2 = CalcWindowSizeAfterConstraint(window, size_expected)
	out_pos^ = pos_min
	if corner_norm.x == 0.0 { out_pos.x -= (size_constrained.x - size_expected.x) }
	if corner_norm.y == 0.0 { out_pos.y -= (size_constrained.y - size_expected.y) }
	out_size^ = size_constrained
}

// Data for resizing from resize grip / corner
ImGuiResizeGripDef :: struct {
	CornerPosN : ImVec2,
	InnerDir : ImVec2,
	AngleMin12 : i32, AngleMax12 : i32,
}
resize_grip_def : [4]ImGuiResizeGripDef = {
	{ImVec2{1, 1}, ImVec2{-1, -1}, 0, 3}, // Lower-right
	{ImVec2{0, 1}, ImVec2{+1, -1}, 3, 6}, // Lower-left
	{ImVec2{0, 0}, ImVec2{+1, +1}, 6, 9}, // Upper-left (Unused)
	{ImVec2{1, 0}, ImVec2{-1, +1}, 9, 12}, // Upper-right (Unused)
}

// Data for resizing from borders
ImGuiResizeBorderDef :: struct {
	InnerDir : ImVec2, // Normal toward inside
	SegmentN1 : ImVec2, SegmentN2 : ImVec2, // End positions, normalized (0,0: upper left)
	OuterAngle : f32, // Angle toward outside
}
resize_border_def : [4]ImGuiResizeBorderDef = {
	{ImVec2{+1, 0}, ImVec2{0, 1}, ImVec2{0, 0}, IM_PI * 1.00}, // Left
	{ImVec2{-1, 0}, ImVec2{1, 0}, ImVec2{1, 1}, IM_PI * 0.00}, // Right
	{ImVec2{0, +1}, ImVec2{0, 0}, ImVec2{1, 0}, IM_PI * 1.50}, // Up
	{ImVec2{0, -1}, ImVec2{1, 1}, ImVec2{0, 1}, IM_PI * 0.50}, // Down
}

GetResizeBorderRect :: proc(window : ^ImGuiWindow, border_n : i32, perp_padding : f32, thickness : f32) -> ImRect
{
	rect : ImRect = Rect(window)
	if thickness == 0.0 { rect.Max -= ImVec2(1, 1) }
	if border_n == ImGuiDir.ImGuiDir_Left { return ImRect(rect.Min.x - thickness, rect.Min.y + perp_padding, rect.Min.x + thickness, rect.Max.y - perp_padding) }
	if border_n == ImGuiDir.ImGuiDir_Right { return ImRect(rect.Max.x - thickness, rect.Min.y + perp_padding, rect.Max.x + thickness, rect.Max.y - perp_padding) }
	if border_n == ImGuiDir.ImGuiDir_Up { return ImRect(rect.Min.x + perp_padding, rect.Min.y - thickness, rect.Max.x - perp_padding, rect.Min.y + thickness) }
	if border_n == ImGuiDir.ImGuiDir_Down { return ImRect(rect.Min.x + perp_padding, rect.Max.y - thickness, rect.Max.x - perp_padding, rect.Max.y + thickness) }
	IM_ASSERT(0)
	return ImRect()
}

// 0..3: corners
// 0..3: corners (Lower-right, Lower-left, Unused, Unused)
GetWindowResizeCornerID :: proc(window : ^ImGuiWindow, n : i32) -> ImGuiID
{
	IM_ASSERT(n >= 0 && n < 4)
	id : ImGuiID = window.DockIsActive ? window.DockNode.HostWindow.ID : window.ID
	id = ImHashStr("#RESIZE", 0, id)
	id = ImHashData(&n, size_of(i32), id)
	return id
}

// Borders (Left, Right, Up, Down)
GetWindowResizeBorderID :: proc(window : ^ImGuiWindow, dir : ImGuiDir) -> ImGuiID
{
	IM_ASSERT(dir >= 0 && dir < 4)
	n : i32 = cast(i32) dir + 4
	id : ImGuiID = window.DockIsActive ? window.DockNode.HostWindow.ID : window.ID
	id = ImHashStr("#RESIZE", 0, id)
	id = ImHashData(&n, size_of(i32), id)
	return id
}

// Handle resize for: Resize Grips, Borders, Gamepad
// Return true when using auto-fit (double-click on resize grip)
UpdateWindowManualResize :: proc(window : ^ImGuiWindow, size_auto_fit : ^ImVec2, border_hovered : ^i32, border_held : ^i32, resize_grip_count : i32, resize_grip_col : [4]ImU32, visibility_rect : ^ImRect) -> i32
{
	g : ^ImGuiContext = GImGui^
	flags : ImGuiWindowFlags = window.Flags

	if (flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoResize) || (flags & ImGuiWindowFlags_.ImGuiWindowFlags_AlwaysAutoResize) || window.AutoFitFramesX > 0 || window.AutoFitFramesY > 0 { return false }
	if window.WasActive == false {
		// Early out to avoid running this code for e.g. a hidden implicit/fallback Debug window.return false
	}

	ret_auto_fit_mask : i32 = 0x00
	grip_draw_size : f32 = IM_TRUNC(ImMax(g.FontSize * 1.35, window.WindowRounding + 1.0 + g.FontSize * 0.2))
	grip_hover_inner_size : f32 = (resize_grip_count > 0) ? IM_TRUNC(grip_draw_size * 0.75) : 0.0
	grip_hover_outer_size : f32 = g.IO.ConfigWindowsResizeFromEdges ? WINDOWS_HOVER_PADDING : 0.0

	clamp_rect : ImRect = visibility_rect
	window_move_from_title_bar : bool = g.IO.ConfigWindowsMoveFromTitleBarOnly && !(window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoTitleBar)
	if window_move_from_title_bar { clamp_rect.Min.y -= window.TitleBarHeight }

	pos_target : ImVec2; init(&pos_target, FLT_MAX, FLT_MAX)
	size_target : ImVec2; init(&size_target, FLT_MAX, FLT_MAX)

	// Clip mouse interaction rectangles within the viewport rectangle (in practice the narrowing is going to happen most of the time).
	// - Not narrowing would mostly benefit the situation where OS windows _without_ decoration have a threshold for hovering when outside their limits.
	//   This is however not the case with current backends under Win32, but a custom borderless window implementation would benefit from it.
	// - When decoration are enabled we typically benefit from that distance, but then our resize elements would be conflicting with OS resize elements, so we also narrow.
	// - Note that we are unable to tell if the platform setup allows hovering with a distance threshold (on Win32, decorated window have such threshold).
	// We only clip interaction so we overwrite window->ClipRect, cannot call PushClipRect() yet as DrawList is not yet setup.
	clip_with_viewport_rect : bool = !(g.IO.BackendFlags & ImGuiBackendFlags_.ImGuiBackendFlags_HasMouseHoveredViewport) || (g.IO.MouseHoveredViewport != window.ViewportId) || !(window.Viewport.Flags & ImGuiViewportFlags_.ImGuiViewportFlags_NoDecoration)
	if clip_with_viewport_rect { window.ClipRect = GetMainRect(window.Viewport) }

	// Resize grips and borders are on layer 1
	window.DC.NavLayerCurrent = ImGuiNavLayer.ImGuiNavLayer_Menu

	// Manual resize grips
	PushID("#RESIZE")
	for resize_grip_n : i32 = 0; resize_grip_n < resize_grip_count; post_incr(&resize_grip_n) {
		def : ^ImGuiResizeGripDef = resize_grip_def[resize_grip_n]
		corner : ImVec2 = ImLerp(window.Pos, window.Pos + window.Size, def.CornerPosN)

		// Using the FlattenChilds button flag we make the resize button accessible even if we are hovering over a child window
		hovered : bool; held : bool
		resize_rect : ImRect; init(&resize_rect, corner - def.InnerDir * grip_hover_outer_size, corner + def.InnerDir * grip_hover_inner_size)
		if resize_rect.Min.x > resize_rect.Max.x { ImSwap(resize_rect.Min.x, resize_rect.Max.x) }
		if resize_rect.Min.y > resize_rect.Max.y { ImSwap(resize_rect.Min.y, resize_rect.Max.y) }
		resize_grip_id : ImGuiID = GetID(window, resize_grip_n); // == GetWindowResizeCornerID()
		ItemAdd(resize_rect, resize_grip_id, nil, ImGuiItemFlags_.ImGuiItemFlags_NoNav)
		ButtonBehavior(resize_rect, resize_grip_id, &hovered, &held, ImGuiButtonFlagsPrivate_.ImGuiButtonFlags_FlattenChildren | ImGuiButtonFlagsPrivate_.ImGuiButtonFlags_NoNavFocus)
		//GetForegroundDrawList(window)->AddRect(resize_rect.Min, resize_rect.Max, IM_COL32(255, 255, 0, 255));
		if hovered || held { SetMouseCursor((resize_grip_n & 1) ? ImGuiMouseCursor_.ImGuiMouseCursor_ResizeNESW : ImGuiMouseCursor_.ImGuiMouseCursor_ResizeNWSE) }

		if held && g.IO.MouseDoubleClicked[0] {
			// Auto-fit when double-clicking
			size_target = CalcWindowSizeAfterConstraint(window, size_auto_fit)
			ret_auto_fit_mask = 0x03; // Both axises
			ClearActiveID()
		}
		else if held {
			// Resize from any of the four corners
			// We don't use an incremental MouseDelta but rather compute an absolute target size based on mouse position
			clamp_min : ImVec2 = ImVec2(def.CornerPosN.x == 1.0 ? clamp_rect.Min.x : -FLT_MAX, (def.CornerPosN.y == 1.0 || (def.CornerPosN.y == 0.0 && window_move_from_title_bar)) ? clamp_rect.Min.y : -FLT_MAX)
			clamp_max : ImVec2 = ImVec2(def.CornerPosN.x == 0.0 ? clamp_rect.Max.x : +FLT_MAX, def.CornerPosN.y == 0.0 ? clamp_rect.Max.y : +FLT_MAX)
			corner_target : ImVec2 = g.IO.MousePos - g.ActiveIdClickOffset + ImLerp(def.InnerDir * grip_hover_outer_size, def.InnerDir * -grip_hover_inner_size, def.CornerPosN); // Corner of the window corresponding to our corner grip
			corner_target = ImClamp(corner_target, clamp_min, clamp_max)
			CalcResizePosSizeFromAnyCorner(window, corner_target, def.CornerPosN, &pos_target, &size_target)
		}

		// Only lower-left grip is visible before hovering/activating
		if resize_grip_n == 0 || held || hovered { resize_grip_col[resize_grip_n] = GetColorU32(held ? ImGuiCol_.ImGuiCol_ResizeGripActive : hovered ? ImGuiCol_.ImGuiCol_ResizeGripHovered : ImGuiCol_.ImGuiCol_ResizeGrip) }
	}

	resize_border_mask : i32 = 0x00
	if window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_ChildWindow { resize_border_mask |= ((window.ChildFlags & ImGuiChildFlags_.ImGuiChildFlags_ResizeX) ? 0x02 : 0) | ((window.ChildFlags & ImGuiChildFlags_.ImGuiChildFlags_ResizeY) ? 0x08 : 0) }
	else { resize_border_mask = g.IO.ConfigWindowsResizeFromEdges ? 0x0F : 0x00 }
	for border_n : i32 = 0; border_n < 4; post_incr(&border_n) {
		if (resize_border_mask & (1 << border_n)) == 0 { continue }
		def : ^ImGuiResizeBorderDef = resize_border_def[border_n]
		axis : ImGuiAxis = (border_n == ImGuiDir.ImGuiDir_Left || border_n == ImGuiDir.ImGuiDir_Right) ? ImGuiAxis.ImGuiAxis_X : ImGuiAxis.ImGuiAxis_Y

		hovered : bool; held : bool
		border_rect : ImRect = GetResizeBorderRect(window, border_n, grip_hover_inner_size, WINDOWS_HOVER_PADDING)
		border_id : ImGuiID = GetID(window, border_n + 4); // == GetWindowResizeBorderID()
		ItemAdd(border_rect, border_id, nil, ImGuiItemFlags_.ImGuiItemFlags_NoNav)
		ButtonBehavior(border_rect, border_id, &hovered, &held, ImGuiButtonFlagsPrivate_.ImGuiButtonFlags_FlattenChildren | ImGuiButtonFlagsPrivate_.ImGuiButtonFlags_NoNavFocus)
		//GetForegroundDrawList(window)->AddRect(border_rect.Min, border_rect.Max, IM_COL32(255, 255, 0, 255));
		if hovered && g.HoveredIdTimer <= WINDOWS_RESIZE_FROM_EDGES_FEEDBACK_TIMER { hovered = false }
		if hovered || held { SetMouseCursor((axis == ImGuiAxis.ImGuiAxis_X) ? ImGuiMouseCursor_.ImGuiMouseCursor_ResizeEW : ImGuiMouseCursor_.ImGuiMouseCursor_ResizeNS) }
		if held && g.IO.MouseDoubleClicked[0] {
			// Double-clicking bottom or right border auto-fit on this axis
			// FIXME: CalcWindowAutoFitSize() doesn't take into account that only one side may be auto-fit when calculating scrollbars.
			// FIXME: Support top and right borders: rework CalcResizePosSizeFromAnyCorner() to be reusable in both cases.
			if border_n == 1 || border_n == 3 {
				// Right and bottom border
				size_target[axis] = CalcWindowSizeAfterConstraint(window, size_auto_fit)[axis]
				ret_auto_fit_mask |= (1 << axis)
				held = false; hovered = held; // So border doesn't show highlighted at new position
			}
			ClearActiveID()
		}
		else if held {
			// Switch to relative resizing mode when border geometry moved (e.g. resizing a child altering parent scroll), in order to avoid resizing feedback loop.
			// Currently only using relative mode on resizable child windows, as the problem to solve is more likely noticeable for them, but could apply for all windows eventually.
			// FIXME: May want to generalize this idiom at lower-level, so more widgets can use it!
			just_scrolled_manually_while_resizing : bool = (g.WheelingWindow != nil && g.WheelingWindowScrolledFrame == g.FrameCount && IsWindowChildOf(window, g.WheelingWindow, false, true))
			if g.ActiveIdIsJustActivated || just_scrolled_manually_while_resizing {
				g.WindowResizeBorderExpectedRect = border_rect
				g.WindowResizeRelativeMode = false
			}
			if (window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_ChildWindow) && memcmp(&g.WindowResizeBorderExpectedRect, &border_rect, size_of(ImRect)) != 0 { g.WindowResizeRelativeMode = true }

			border_curr : ImVec2 = (window.Pos + ImMin(def.SegmentN1, def.SegmentN2) * window.Size)
			border_target_rel_mode_for_axis : f32 = border_curr[axis] + g.IO.MouseDelta[axis]
			border_target_abs_mode_for_axis : f32 = g.IO.MousePos[axis] - g.ActiveIdClickOffset[axis] + WINDOWS_HOVER_PADDING; // Match ButtonBehavior() padding above.

			// Use absolute mode position
			border_target : ImVec2 = window.Pos
			border_target[axis] = border_target_abs_mode_for_axis

			// Use relative mode target for child window, ignore resize when moving back toward the ideal absolute position.
			ignore_resize : bool = false
			if g.WindowResizeRelativeMode {
				//GetForegroundDrawList()->AddText(GetMainViewport()->WorkPos, IM_COL32_WHITE, "Relative Mode");
				border_target[axis] = border_target_rel_mode_for_axis
				if g.IO.MouseDelta[axis] == 0.0 || (g.IO.MouseDelta[axis] > 0.0) == (border_target_rel_mode_for_axis > border_target_abs_mode_for_axis) { ignore_resize = true }
			}

			// Clamp, apply
			clamp_min : ImVec2; init(&clamp_min, border_n == ImGuiDir.ImGuiDir_Right ? clamp_rect.Min.x : -FLT_MAX, border_n == ImGuiDir.ImGuiDir_Down || (border_n == ImGuiDir.ImGuiDir_Up && window_move_from_title_bar) ? clamp_rect.Min.y : -FLT_MAX)
			clamp_max : ImVec2; init(&clamp_max, border_n == ImGuiDir.ImGuiDir_Left ? clamp_rect.Max.x : +FLT_MAX, border_n == ImGuiDir.ImGuiDir_Up ? clamp_rect.Max.y : +FLT_MAX)
			border_target = ImClamp(border_target, clamp_min, clamp_max)
			if ImGuiWindowFlags_ChildWindow : ^flags; ImGuiWindowFlags_ChildWindow {
				// Clamp resizing of childs within parent
				parent_window : ^ImGuiWindow = window.ParentWindow
				parent_flags : ImGuiWindowFlags = parent_window.Flags
				border_limit_rect : ImRect = parent_window.InnerRect
				Expand(&border_limit_rect, ImVec2(-ImMax(parent_window.WindowPadding.x, parent_window.WindowBorderSize), -ImMax(parent_window.WindowPadding.y, parent_window.WindowBorderSize)))
				if (axis == ImGuiAxis.ImGuiAxis_X) && ((parent_flags & (ImGuiWindowFlags_.ImGuiWindowFlags_HorizontalScrollbar | ImGuiWindowFlags_.ImGuiWindowFlags_AlwaysHorizontalScrollbar)) == 0 || (parent_flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoScrollbar)) { border_target.x = ImClamp(border_target.x, border_limit_rect.Min.x, border_limit_rect.Max.x) }
				if (axis == ImGuiAxis.ImGuiAxis_Y) && (parent_flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoScrollbar) { border_target.y = ImClamp(border_target.y, border_limit_rect.Min.y, border_limit_rect.Max.y) }
			}
			if !ignore_resize { CalcResizePosSizeFromAnyCorner(window, border_target, ImMin(def.SegmentN1, def.SegmentN2), &pos_target, &size_target) }
		}
		if hovered { border_hovered^ = border_n }
		if held { border_held^ = border_n }
	}

	PopID()

	// Restore nav layer
	window.DC.NavLayerCurrent = ImGuiNavLayer.ImGuiNavLayer_Main

	// Navigation resize (keyboard/gamepad)
	// FIXME: This cannot be moved to NavUpdateWindowing() because CalcWindowSizeAfterConstraint() need to callback into user.
	// Not even sure the callback works here.
	if g.NavWindowingTarget && g.NavWindowingTarget.RootWindowDockTree == window {
		nav_resize_dir : ImVec2
		if g.NavInputSource == ImGuiInputSource.ImGuiInputSource_Keyboard && g.IO.KeyShift { nav_resize_dir = GetKeyMagnitude2d(ImGuiKey.ImGuiKey_LeftArrow, ImGuiKey.ImGuiKey_RightArrow, ImGuiKey.ImGuiKey_UpArrow, ImGuiKey.ImGuiKey_DownArrow) }
		if g.NavInputSource == ImGuiInputSource.ImGuiInputSource_Gamepad { nav_resize_dir = GetKeyMagnitude2d(ImGuiKey.ImGuiKey_GamepadDpadLeft, ImGuiKey.ImGuiKey_GamepadDpadRight, ImGuiKey.ImGuiKey_GamepadDpadUp, ImGuiKey.ImGuiKey_GamepadDpadDown) }
		if nav_resize_dir.x != 0.0 || nav_resize_dir.y != 0.0 {
			NAV_RESIZE_SPEED : f32 = 600.0
			resize_step : f32 = NAV_RESIZE_SPEED * g.IO.DeltaTime * ImMin(g.IO.DisplayFramebufferScale.x, g.IO.DisplayFramebufferScale.y)
			g.NavWindowingAccumDeltaSize += nav_resize_dir * resize_step
			g.NavWindowingAccumDeltaSize = ImMax(g.NavWindowingAccumDeltaSize, clamp_rect.Min - window.Pos - window.Size); // We need Pos+Size >= clmap_rect.Min, so Size >= clmap_rect.Min - Pos, so size_delta >= clmap_rect.Min - window->Pos - window->Size
			g.NavWindowingToggleLayer = false
			g.NavHighlightItemUnderNav = true
			resize_grip_col[0] = GetColorU32(ImGuiCol_.ImGuiCol_ResizeGripActive)
			accum_floored : ImVec2 = ImTrunc(g.NavWindowingAccumDeltaSize)
			if accum_floored.x != 0.0 || accum_floored.y != 0.0 {
				// FIXME-NAV: Should store and accumulate into a separate size buffer to handle sizing constraints properly, right now a constraint will make us stuck.
				size_target = CalcWindowSizeAfterConstraint(window, window.SizeFull + accum_floored)
				g.NavWindowingAccumDeltaSize -= accum_floored
			}
		}
	}

	// Apply back modified position/size to window
	curr_pos : ImVec2 = window.Pos
	curr_size : ImVec2 = window.SizeFull
	if size_target.x != FLT_MAX && (window.Size.x != size_target.x || window.SizeFull.x != size_target.x) { window.SizeFull.x = size_target.x; window.Size.x = window.SizeFull.x }
	if size_target.y != FLT_MAX && (window.Size.y != size_target.y || window.SizeFull.y != size_target.y) { window.SizeFull.y = size_target.y; window.Size.y = window.SizeFull.y }
	if pos_target.x != FLT_MAX && window.Pos.x != ImTrunc(pos_target.x) { window.Pos.x = ImTrunc(pos_target.x) }
	if pos_target.y != FLT_MAX && window.Pos.y != ImTrunc(pos_target.y) { window.Pos.y = ImTrunc(pos_target.y) }
	if curr_pos.x != window.Pos.x || curr_pos.y != window.Pos.y || curr_size.x != window.SizeFull.x || curr_size.y != window.SizeFull.y { MarkIniSettingsDirty(window) }

	// Recalculate next expected border expected coordinates
	if border_held^ != -1 { g.WindowResizeBorderExpectedRect = GetResizeBorderRect(window, border_held^, grip_hover_inner_size, WINDOWS_HOVER_PADDING) }

	return ret_auto_fit_mask
}

ClampWindowPos :: #force_inline proc(window : ^ImGuiWindow, visibility_rect : ^ImRect)
{
	g : ^ImGuiContext = GImGui^
	size_for_clamping : ImVec2 = window.Size
	if g.IO.ConfigWindowsMoveFromTitleBarOnly && window.DockNodeAsHost {
		// Not using window->TitleBarHeight() as DockNodeAsHost will report 0.0f here.
		size_for_clamping.y = GetFrameHeight()
	}
	else if g.IO.ConfigWindowsMoveFromTitleBarOnly && !(window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoTitleBar) { size_for_clamping.y = window.TitleBarHeight }
	window.Pos = ImClamp(window.Pos, visibility_rect.Min - size_for_clamping, visibility_rect.Max)
}

RenderWindowOuterSingleBorder :: proc(window : ^ImGuiWindow, border_n : i32, border_col : ImU32, border_size : f32)
{
	def : ^ImGuiResizeBorderDef = resize_border_def[border_n]
	rounding : f32 = window.WindowRounding
	border_r : ImRect = GetResizeBorderRect(window, border_n, rounding, 0.0)
	PathArcTo(window.DrawList, ImLerp(border_r.Min, border_r.Max, def.SegmentN1) + ImVec2(0.5, 0.5) + def.InnerDir * rounding, rounding, def.OuterAngle - IM_PI * 0.25, def.OuterAngle)
	PathArcTo(window.DrawList, ImLerp(border_r.Min, border_r.Max, def.SegmentN2) + ImVec2(0.5, 0.5) + def.InnerDir * rounding, rounding, def.OuterAngle, def.OuterAngle + IM_PI * 0.25)
	PathStroke(window.DrawList, border_col, ImDrawFlags_.ImDrawFlags_None, border_size)
}

RenderWindowOuterBorders :: proc(window : ^ImGuiWindow)
{
	g : ^ImGuiContext = GImGui^
	border_size : f32 = window.WindowBorderSize
	border_col : ImU32 = GetColorU32(ImGuiCol_.ImGuiCol_Border)
	if border_size > 0.0 && (window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoBackground) == 0 { AddRect(window.DrawList, window.Pos, window.Pos + window.Size, border_col, window.WindowRounding, 0, window.WindowBorderSize) }
	else if border_size > 0.0 {
		if window.ChildFlags & ImGuiChildFlags_.ImGuiChildFlags_ResizeX {
			// Similar code as 'resize_border_mask' computation in UpdateWindowManualResize() but we specifically only always draw explicit child resize border.RenderWindowOuterSingleBorder(window, 1, border_col, border_size)
		}
		if window.ChildFlags & ImGuiChildFlags_.ImGuiChildFlags_ResizeY { RenderWindowOuterSingleBorder(window, 3, border_col, border_size) }
	}
	if window.ResizeBorderHovered != -1 || window.ResizeBorderHeld != -1 {
		border_n : i32 = (window.ResizeBorderHeld != -1) ? window.ResizeBorderHeld : window.ResizeBorderHovered
		border_col_resizing : ImU32 = GetColorU32((window.ResizeBorderHeld != -1) ? ImGuiCol_.ImGuiCol_SeparatorActive : ImGuiCol_.ImGuiCol_SeparatorHovered)
		RenderWindowOuterSingleBorder(window, border_n, border_col_resizing, ImMax(2.0, window.WindowBorderSize)); // Thicker than usual
	}
	if g.Style.FrameBorderSize > 0 && !(window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoTitleBar) && !window.DockIsActive {
		y : f32 = window.Pos.y + window.TitleBarHeight - 1
		AddLine(window.DrawList, ImVec2(window.Pos.x + border_size, y), ImVec2(window.Pos.x + window.Size.x - border_size, y), border_col, g.Style.FrameBorderSize)
	}
}

// Draw background and borders
// Draw and handle scrollbars
RenderWindowDecorations :: proc(window : ^ImGuiWindow, title_bar_rect : ^ImRect, title_bar_is_highlight : bool, handle_borders_and_resize_grips : bool, resize_grip_count : i32, resize_grip_col : [4]ImU32, resize_grip_draw_size : f32)
{
	g : ^ImGuiContext = GImGui^
	style : ^ImGuiStyle = g.Style
	flags : ImGuiWindowFlags = window.Flags

	// Ensure that Scrollbar() doesn't read last frame's SkipItems
	IM_ASSERT(window.BeginCount == 0)
	window.SkipItems = false
	window.DC.NavLayerCurrent = ImGuiNavLayer.ImGuiNavLayer_Menu

	// Draw window + handle manual resize
	// As we highlight the title bar when want_focus is set, multiple reappearing windows will have their title bar highlighted on their reappearing frame.
	window_rounding : f32 = window.WindowRounding
	window_border_size : f32 = window.WindowBorderSize
	if window.Collapsed {
		// Title bar only
		backup_border_size : f32 = style.FrameBorderSize
		g.Style.FrameBorderSize = window.WindowBorderSize
		title_bar_col : ImU32 = GetColorU32((title_bar_is_highlight && g.NavCursorVisible) ? ImGuiCol_.ImGuiCol_TitleBgActive : ImGuiCol_.ImGuiCol_TitleBgCollapsed)
		if window.ViewportOwned {
			// No alpha (we don't support is_docking_transparent_payload here because simpler and less meaningful, but could with a bit of code shuffle/reuse)
			title_bar_col |= IM_COL32_A_MASK
		}
		RenderFrame(title_bar_rect.Min, title_bar_rect.Max, title_bar_col, true, window_rounding)
		g.Style.FrameBorderSize = backup_border_size
	}
	else {
		// Window background
		if !(flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoBackground) {
			is_docking_transparent_payload : bool = false
			if g.DragDropActive && (g.FrameCount - g.DragDropAcceptFrameCount) <= 1 && g.IO.ConfigDockingTransparentPayload { if IsDataType(&g.DragDropPayload, IMGUI_PAYLOAD_TYPE_WINDOW) && cast(^^ImGuiWindow) g.DragDropPayload.Data^ == window { is_docking_transparent_payload = true } }

			bg_col : ImU32 = GetColorU32(GetWindowBgColorIdx(window))
			if window.ViewportOwned {
				bg_col |= IM_COL32_A_MASK; // No alpha
				if is_docking_transparent_payload { window.Viewport.Alpha *= DOCKING_TRANSPARENT_PAYLOAD_ALPHA }
			}
			else {
				// Adjust alpha. For docking
				override_alpha : bool = false
				alpha : f32 = 1.0
				if g.NextWindowData.Flags & ImGuiNextWindowDataFlags_.ImGuiNextWindowDataFlags_HasBgAlpha {
					alpha = g.NextWindowData.BgAlphaVal
					override_alpha = true
				}
				if is_docking_transparent_payload {
					alpha *= DOCKING_TRANSPARENT_PAYLOAD_ALPHA; // FIXME-DOCK: Should that be an override?
					override_alpha = true
				}
				if override_alpha { bg_col = (bg_col & !IM_COL32_A_MASK) | (IM_F32_TO_INT8_SAT(alpha) << IM_COL32_A_SHIFT) }
			}

			// Render, for docked windows and host windows we ensure bg goes before decorations
			if window.DockIsActive { window.DockNode.LastBgColor = bg_col }
			bg_draw_list : ^ImDrawList = window.DockIsActive ? window.DockNode.HostWindow.DrawList : window.DrawList
			if window.DockIsActive || (flags & ImGuiWindowFlags_.ImGuiWindowFlags_DockNodeHost) { ChannelsSetCurrent(bg_draw_list, DOCKING_HOST_DRAW_CHANNEL_BG) }
			AddRectFilled(bg_draw_list, window.Pos + ImVec2(0, window.TitleBarHeight), window.Pos + window.Size, bg_col, window_rounding, (flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoTitleBar) ? 0 : ImDrawFlags_.ImDrawFlags_RoundCornersBottom)
			if window.DockIsActive || (flags & ImGuiWindowFlags_.ImGuiWindowFlags_DockNodeHost) { ChannelsSetCurrent(bg_draw_list, DOCKING_HOST_DRAW_CHANNEL_FG) }
		}
		if window.DockIsActive { window.DockNode.IsBgDrawnThisFrame = true }

		// Title bar
		// (when docked, DockNode are drawing their own title bar. Individual windows however do NOT set the _NoTitleBar flag,
		// in order for their pos/size to be matching their undocking state.)
		if !(flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoTitleBar) && !window.DockIsActive {
			title_bar_col : ImU32 = GetColorU32(title_bar_is_highlight ? ImGuiCol_.ImGuiCol_TitleBgActive : ImGuiCol_.ImGuiCol_TitleBg)
			if window.ViewportOwned {
				// No alpha
				title_bar_col |= IM_COL32_A_MASK
			}
			AddRectFilled(window.DrawList, title_bar_rect.Min, title_bar_rect.Max, title_bar_col, window_rounding, ImDrawFlags_.ImDrawFlags_RoundCornersTop)
		}

		// Menu bar
		if ImGuiWindowFlags_MenuBar : ^flags; ImGuiWindowFlags_MenuBar {
			menu_bar_rect : ImRect = MenuBarRect(window)
			ClipWith(&menu_bar_rect, Rect(window)); // Soft clipping, in particular child window don't have minimum size covering the menu bar so this is useful for them.
			AddRectFilled(window.DrawList, menu_bar_rect.Min + ImVec2(window_border_size, 0), menu_bar_rect.Max - ImVec2(window_border_size, 0), GetColorU32(ImGuiCol_.ImGuiCol_MenuBarBg), (flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoTitleBar) ? window_rounding : 0.0, ImDrawFlags_.ImDrawFlags_RoundCornersTop)
			if style.FrameBorderSize > 0.0 && menu_bar_rect.Max.y < window.Pos.y + window.Size.y { AddLine(window.DrawList, GetBL(&menu_bar_rect), GetBR(&menu_bar_rect), GetColorU32(ImGuiCol_.ImGuiCol_Border), style.FrameBorderSize) }
		}

		// Docking: Unhide tab bar (small triangle in the corner), drag from small triangle to quickly undock
		node : ^ImGuiDockNode = window.DockNode
		if window.DockIsActive && IsHiddenTabBar(node) && !IsNoTabBar(node) {
			unhide_sz_draw : f32 = ImTrunc(g.FontSize * 0.70)
			unhide_sz_hit : f32 = ImTrunc(g.FontSize * 0.55)
			p : ImVec2 = node.Pos
			r : ImRect; init(&r, p, p + ImVec2(unhide_sz_hit, unhide_sz_hit))
			unhide_id : ImGuiID = GetID(window, "#UNHIDE")
			KeepAliveID(unhide_id)
			hovered : bool; held : bool
			if ButtonBehavior(r, unhide_id, &hovered, &held, ImGuiButtonFlagsPrivate_.ImGuiButtonFlags_FlattenChildren) { node.WantHiddenTabBarToggle = true }
			else if held && IsMouseDragging(0) {
				// Undock from tab-bar triangle = same as window/collapse menu button
				StartMouseMovingWindowOrNode(window, node, true)
			}

			// FIXME-DOCK: Ideally we'd use ImGuiCol_TitleBgActive/ImGuiCol_TitleBg here, but neither is guaranteed to be visible enough at this sort of size..
			col : ImU32 = GetColorU32(((held && hovered) || (node.IsFocused && !hovered)) ? ImGuiCol_.ImGuiCol_ButtonActive : hovered ? ImGuiCol_.ImGuiCol_ButtonHovered : ImGuiCol_.ImGuiCol_Button)
			AddTriangleFilled(window.DrawList, p, p + ImVec2(unhide_sz_draw, 0.0), p + ImVec2(0.0, unhide_sz_draw), col)
		}

		// Scrollbars
		if window.ScrollbarX { Scrollbar(ImGuiAxis.ImGuiAxis_X) }
		if window.ScrollbarY { Scrollbar(ImGuiAxis.ImGuiAxis_Y) }

		// Render resize grips (after their input handling so we don't have a frame of latency)
		if handle_borders_and_resize_grips && !(flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoResize) {
			for resize_grip_n : i32 = 0; resize_grip_n < resize_grip_count; post_incr(&resize_grip_n) {
				col : ImU32 = resize_grip_col[resize_grip_n]
				if (col & IM_COL32_A_MASK) == 0 { continue }
				grip : ^ImGuiResizeGripDef = resize_grip_def[resize_grip_n]
				corner : ImVec2 = ImLerp(window.Pos, window.Pos + window.Size, grip.CornerPosN)
				PathLineTo(window.DrawList, corner + grip.InnerDir * ((resize_grip_n & 1) ? ImVec2(window_border_size, resize_grip_draw_size) : ImVec2(resize_grip_draw_size, window_border_size)))
				PathLineTo(window.DrawList, corner + grip.InnerDir * ((resize_grip_n & 1) ? ImVec2(resize_grip_draw_size, window_border_size) : ImVec2(window_border_size, resize_grip_draw_size)))
				PathArcToFast(window.DrawList, ImVec2(corner.x + grip.InnerDir.x * (window_rounding + window_border_size), corner.y + grip.InnerDir.y * (window_rounding + window_border_size)), window_rounding, grip.AngleMin12, grip.AngleMax12)
				PathFillConvex(window.DrawList, col)
			}
		}

		// Borders (for dock node host they will be rendered over after the tab bar)
		if handle_borders_and_resize_grips && !window.DockNodeAsHost { RenderWindowOuterBorders(window) }
	}
	window.DC.NavLayerCurrent = ImGuiNavLayer.ImGuiNavLayer_Main
}

// When inside a dock node, this is handled in DockNodeCalcTabBarLayout() instead.
// Render title text, collapse button, close button
RenderWindowTitleBarContents :: proc(window : ^ImGuiWindow, title_bar_rect : ^ImRect, name : ^u8, p_open : ^bool)
{
	g : ^ImGuiContext = GImGui^
	style : ^ImGuiStyle = g.Style
	flags : ImGuiWindowFlags = window.Flags

	has_close_button : bool = (p_open != nil)
	has_collapse_button : bool = !(flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoCollapse) && (style.WindowMenuButtonPosition != ImGuiDir.ImGuiDir_None)

	// Close & Collapse button are on the Menu NavLayer and don't default focus (unless there's nothing else on that layer)
	// FIXME-NAV: Might want (or not?) to set the equivalent of ImGuiButtonFlags_NoNavFocus so that mouse clicks on standard title bar items don't necessarily set nav/keyboard ref?
	item_flags_backup : ImGuiItemFlags = g.CurrentItemFlags
	g.CurrentItemFlags |= ImGuiItemFlags_.ImGuiItemFlags_NoNavDefaultFocus
	window.DC.NavLayerCurrent = ImGuiNavLayer.ImGuiNavLayer_Menu

	// Layout buttons
	// FIXME: Would be nice to generalize the subtleties expressed here into reusable code.
	pad_l : f32 = style.FramePadding.x
	pad_r : f32 = style.FramePadding.x
	button_sz : f32 = g.FontSize
	close_button_pos : ImVec2
	collapse_button_pos : ImVec2
	if has_close_button {
		close_button_pos = ImVec2(title_bar_rect.Max.x - pad_r - button_sz, title_bar_rect.Min.y + style.FramePadding.y)
		pad_r += button_sz + style.ItemInnerSpacing.x
	}
	if has_collapse_button && style.WindowMenuButtonPosition == ImGuiDir.ImGuiDir_Right {
		collapse_button_pos = ImVec2(title_bar_rect.Max.x - pad_r - button_sz, title_bar_rect.Min.y + style.FramePadding.y)
		pad_r += button_sz + style.ItemInnerSpacing.x
	}
	if has_collapse_button && style.WindowMenuButtonPosition == ImGuiDir.ImGuiDir_Left {
		collapse_button_pos = ImVec2(title_bar_rect.Min.x + pad_l, title_bar_rect.Min.y + style.FramePadding.y)
		pad_l += button_sz + style.ItemInnerSpacing.x
	}

	// Collapse button (submitting first so it gets priority when choosing a navigation init fallback)
	if has_collapse_button { if CollapseButton(GetID(window, "#COLLAPSE"), collapse_button_pos, nil) {
	// Defer actual collapsing to next frame as we are too far in the Begin() function
	window.WantCollapseToggle = true
} }

	// Close button
	if has_close_button { if CloseButton(GetID(window, "#CLOSE"), close_button_pos) { p_open^ = false } }

	window.DC.NavLayerCurrent = ImGuiNavLayer.ImGuiNavLayer_Main
	g.CurrentItemFlags = item_flags_backup

	// Title bar text (with: horizontal alignment, avoiding collapse/close button, optional "unsaved document" marker)
	// FIXME: Refactor text alignment facilities along with RenderText helpers, this is WAY too much messy code..
	marker_size_x : f32 = (flags & ImGuiWindowFlags_.ImGuiWindowFlags_UnsavedDocument) ? button_sz * 0.80 : 0.0
	text_size : ImVec2 = CalcTextSize(name, nil, true) + ImVec2(marker_size_x, 0.0)

	// As a nice touch we try to ensure that centered title text doesn't get affected by visibility of Close/Collapse button,
	// while uncentered title text will still reach edges correctly.
	if pad_l > style.FramePadding.x { pad_l += g.Style.ItemInnerSpacing.x }
	if pad_r > style.FramePadding.x { pad_r += g.Style.ItemInnerSpacing.x }
	if style.WindowTitleAlign.x > 0.0 && style.WindowTitleAlign.x < 1.0 {
		centerness : f32 = ImSaturate(1.0 - ImFabs(style.WindowTitleAlign.x - 0.5) * 2.0); // 0.0f on either edges, 1.0f on center
		pad_extend : f32 = ImMin(ImMax(pad_l, pad_r), GetWidth(&title_bar_rect) - pad_l - pad_r - text_size.x)
		pad_l = ImMax(pad_l, pad_extend * centerness)
		pad_r = ImMax(pad_r, pad_extend * centerness)
	}

	layout_r : ImRect; init(&layout_r, title_bar_rect.Min.x + pad_l, title_bar_rect.Min.y, title_bar_rect.Max.x - pad_r, title_bar_rect.Max.y)
	clip_r : ImRect; init(&clip_r, layout_r.Min.x, layout_r.Min.y, ImMin(layout_r.Max.x + g.Style.ItemInnerSpacing.x, title_bar_rect.Max.x), layout_r.Max.y)
	if ImGuiWindowFlags_UnsavedDocument : ^flags; ImGuiWindowFlags_UnsavedDocument {
		marker_pos : ImVec2
		marker_pos.x = ImClamp(layout_r.Min.x + (GetWidth(&layout_r) - text_size.x) * style.WindowTitleAlign.x + text_size.x, layout_r.Min.x, layout_r.Max.x)
		marker_pos.y = (layout_r.Min.y + layout_r.Max.y) * 0.5
		if marker_pos.x > layout_r.Min.x {
			RenderBullet(window.DrawList, marker_pos, GetColorU32(ImGuiCol_.ImGuiCol_Text))
			clip_r.Max.x = ImMin(clip_r.Max.x, marker_pos.x - cast(i32) (marker_size_x * 0.5))
		}
	}
	//if (g.IO.KeyShift) window->DrawList->AddRect(layout_r.Min, layout_r.Max, IM_COL32(255, 128, 0, 255)); // [DEBUG]
	//if (g.IO.KeyCtrl) window->DrawList->AddRect(clip_r.Min, clip_r.Max, IM_COL32(255, 128, 0, 255)); // [DEBUG]
	RenderTextClipped(layout_r.Min, layout_r.Max, name, nil, &text_size, style.WindowTitleAlign, &clip_r)
}

UpdateWindowParentAndRootLinks :: proc(window : ^ImGuiWindow, flags : ImGuiWindowFlags, parent_window : ^ImGuiWindow)
{
	window.ParentWindow = parent_window
	window.RootWindowForNav = window; window.RootWindowForTitleBarHighlight = window.RootWindowForNav; window.RootWindowDockTree = window.RootWindowForTitleBarHighlight; window.RootWindowPopupTree = window.RootWindowDockTree; window.RootWindow = window.RootWindowPopupTree
	if parent_window && (flags & ImGuiWindowFlags_.ImGuiWindowFlags_ChildWindow) && !(flags & ImGuiWindowFlags_.ImGuiWindowFlags_Tooltip) {
		window.RootWindowDockTree = parent_window.RootWindowDockTree
		if !window.DockIsActive && !(parent_window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_DockNodeHost) { window.RootWindow = parent_window.RootWindow }
	}
	if parent_window && (flags & ImGuiWindowFlags_.ImGuiWindowFlags_Popup) { window.RootWindowPopupTree = parent_window.RootWindowPopupTree }
	if parent_window && !(flags & ImGuiWindowFlags_.ImGuiWindowFlags_Modal) && (flags & (ImGuiWindowFlags_.ImGuiWindowFlags_ChildWindow | ImGuiWindowFlags_.ImGuiWindowFlags_Popup)) {
		// FIXME: simply use _NoTitleBar ?window.RootWindowForTitleBarHighlight = parent_window.RootWindowForTitleBarHighlight
	}
	for window.RootWindowForNav.ChildFlags & ImGuiChildFlags_.ImGuiChildFlags_NavFlattened {
		IM_ASSERT(window.RootWindowForNav.ParentWindow != nil)
		window.RootWindowForNav = window.RootWindowForNav.ParentWindow
	}
}

// [EXPERIMENTAL] Called by Begin(). NextWindowData is valid at this point.
// This is designed as a toy/test-bed for
UpdateWindowSkipRefresh :: proc(window : ^ImGuiWindow)
{
	g : ^ImGuiContext = GImGui^
	window.SkipRefresh = false
	if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_.ImGuiNextWindowDataFlags_HasRefreshPolicy) == 0 { return }
	if g.NextWindowData.RefreshFlagsVal & ImGuiWindowRefreshFlags_.ImGuiWindowRefreshFlags_TryToAvoidRefresh {
		// FIXME-IDLE: Tests for e.g. mouse clicks or keyboard while focused.
		if window.Appearing {
			// If currently appearingreturn
		}
		if window.Hidden {
			// If was hidden (previous frame)return
		}
		if (g.NextWindowData.RefreshFlagsVal & ImGuiWindowRefreshFlags_.ImGuiWindowRefreshFlags_RefreshOnHover) && g.HoveredWindow { if window.RootWindow == g.HoveredWindow.RootWindow || IsWindowWithinBeginStackOf(g.HoveredWindow.RootWindow, window) { return } }
		if (g.NextWindowData.RefreshFlagsVal & ImGuiWindowRefreshFlags_.ImGuiWindowRefreshFlags_RefreshOnFocus) && g.NavWindow { if window.RootWindow == g.NavWindow.RootWindow || IsWindowWithinBeginStackOf(g.NavWindow.RootWindow, window) { return } }
		window.DrawList = nil
		window.SkipRefresh = true
	}
}

SetWindowActiveForSkipRefresh :: proc(window : ^ImGuiWindow)
{
	window.Active = true
	for child in window.DC.ChildWindows { if !child.Hidden {
	child.SkipRefresh = true; child.Active = child.SkipRefresh
	SetWindowActiveForSkipRefresh(child)
} }
}

// Windows
// - Begin() = push window to the stack and start appending to it. End() = pop window from the stack.
// - Passing 'bool* p_open != NULL' shows a window-closing widget in the upper-right corner of the window,
//   which clicking will set the boolean to false when clicked.
// - You may append multiple times to the same window during the same frame by calling Begin()/End() pairs multiple times.
//   Some information such as 'flags' or 'p_open' will only be considered by the first call to Begin().
// - Begin() return false to indicate the window is collapsed or fully clipped, so you may early out and omit submitting
//   anything to the window. Always call a matching End() for each Begin() call, regardless of its return value!
//   [Important: due to legacy reason, Begin/End and BeginChild/EndChild are inconsistent with all other functions
//    such as BeginMenu/EndMenu, BeginPopup/EndPopup, etc. where the EndXXX call should only be called if the corresponding
//    BeginXXX function returned true. Begin and BeginChild are the only odd ones out. Will be fixed in a future update.]
// - Note that the bottom of window stack always contains a window called "Debug".
// Push a new Dear ImGui window to add widgets to.
// - A default window called "Debug" is automatically stacked at the beginning of every frame so you can use widgets without explicitly calling a Begin/End pair.
// - Begin/End can be called multiple times during the frame with the same window name to append content.
// - The window name is used as a unique identifier to preserve window information across frames (and save rudimentary information to the .ini file).
//   You can use the "##" or "###" markers to use the same label with different id, or same id with different label. See documentation at the top of this file.
// - Return false when window is collapsed, so you can early out in your code. You always need to call ImGui::End() even if false is returned.
// - Passing 'bool* p_open' displays a Close button on the upper-right corner of the window, the pointed value will be set to false when the button is pressed.
Begin :: proc(name : ^u8, p_open : ^bool, flags : ImGuiWindowFlags) -> bool
{
	g : ^ImGuiContext = GImGui^
	style : ^ImGuiStyle = g.Style
	IM_ASSERT(name != nil && name[0] != 0); // Window name required
	IM_ASSERT(g.WithinFrameScope); // Forgot to call ImGui::NewFrame()
	IM_ASSERT(g.FrameCountEnded != g.FrameCount); // Called ImGui::Render() or ImGui::EndFrame() and haven't called ImGui::NewFrame() again yet

	// Find or create
	window : ^ImGuiWindow = FindWindowByName(name)
	window_just_created : bool = (window == nil)
	if window_just_created { window = CreateNewWindow(name, flags) }

	// [DEBUG] Debug break requested by user
	if g.DebugBreakInWindow == window.ID { IM_DEBUG_BREAK() }

	// Automatically disable manual moving/resizing when NoInputs is set
	if (flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoInputs) == ImGuiWindowFlags_.ImGuiWindowFlags_NoInputs { flags |= ImGuiWindowFlags_.ImGuiWindowFlags_NoMove | ImGuiWindowFlags_.ImGuiWindowFlags_NoResize }

	current_frame : i32 = g.FrameCount
	first_begin_of_the_frame : bool = (window.LastFrameActive != current_frame)
	window.IsFallbackWindow = (g.CurrentWindowStack.Size == 0 && g.WithinFrameScopeWithImplicitWindow)

	// Update the Appearing flag (note: the BeginDocked() path may also set this to true later)
	window_just_activated_by_user : bool = (window.LastFrameActive < current_frame - 1); // Not using !WasActive because the implicit "Debug" window would always toggle off->on
	if ImGuiWindowFlags_Popup : ^flags; ImGuiWindowFlags_Popup {
		popup_ref : ^ImGuiPopupData = g.OpenPopupStack[g.BeginPopupStack.Size]
		window_just_activated_by_user |= (window.PopupId != popup_ref.PopupId); // We recycle popups so treat window as activated if popup id changed
		window_just_activated_by_user |= (window != popup_ref.Window)
	}

	// Update Flags, LastFrameActive, BeginOrderXXX fields
	window_was_appearing : bool = window.Appearing
	if first_begin_of_the_frame {
		UpdateWindowInFocusOrderList(window, window_just_created, flags)
		window.Appearing = window_just_activated_by_user
		if window.Appearing { SetWindowConditionAllowFlags(window, ImGuiCond_.ImGuiCond_Appearing, true) }
		window.FlagsPreviousFrame = window.Flags
		window.Flags = cast(ImGuiWindowFlags) flags
		window.ChildFlags = (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_.ImGuiNextWindowDataFlags_HasChildFlags) ? g.NextWindowData.ChildFlags : 0
		window.LastFrameActive = current_frame
		window.LastTimeActive = cast(f32) g.Time
		window.BeginOrderWithinParent = 0
		window.BeginOrderWithinContext = cast(i16) (post_incr(&g.WindowsActiveCount))
	}
	else {
		flags = window.Flags
	}

	// Docking
	// (NB: during the frame dock nodes are created, it is possible that (window->DockIsActive == false) even though (window->DockNode->Windows.Size > 1)
	IM_ASSERT(window.DockNode == nil || window.DockNodeAsHost == nil); // Cannot be both
	if g.NextWindowData.Flags & ImGuiNextWindowDataFlags_.ImGuiNextWindowDataFlags_HasDock { SetWindowDock(window, g.NextWindowData.DockId, g.NextWindowData.DockCond) }
	if first_begin_of_the_frame {
		has_dock_node : bool = (window.DockId != 0 || window.DockNode != nil)
		new_auto_dock_node : bool = !has_dock_node && GetWindowAlwaysWantOwnTabBar(window)
		dock_node_was_visible : bool = window.DockNodeIsVisible
		dock_tab_was_visible : bool = window.DockTabIsVisible
		if has_dock_node || new_auto_dock_node {
			BeginDocked(window, p_open)
			flags = window.Flags
			if window.DockIsActive {
				IM_ASSERT(window.DockNode != nil)
				g.NextWindowData.Flags &= !ImGuiNextWindowDataFlags_.ImGuiNextWindowDataFlags_HasSizeConstraint; // Docking currently override constraints
			}

			// Amend the Appearing flag
			if window.DockTabIsVisible && !dock_tab_was_visible && dock_node_was_visible && !window.Appearing && !window_was_appearing {
				window.Appearing = true
				SetWindowConditionAllowFlags(window, ImGuiCond_.ImGuiCond_Appearing, true)
			}
		}
		else {
			window.DockTabIsVisible = false; window.DockNodeIsVisible = window.DockTabIsVisible; window.DockIsActive = window.DockNodeIsVisible
		}
	}

	// Parent window is latched only on the first call to Begin() of the frame, so further append-calls can be done from a different window stack
	parent_window_in_stack : ^ImGuiWindow = (window.DockIsActive && window.DockNode.HostWindow) ? window.DockNode.HostWindow : empty(&g.CurrentWindowStack) ? nil : back(&g.CurrentWindowStack).Window
	parent_window : ^ImGuiWindow = first_begin_of_the_frame ? ((flags & (ImGuiWindowFlags_.ImGuiWindowFlags_ChildWindow | ImGuiWindowFlags_.ImGuiWindowFlags_Popup)) ? parent_window_in_stack : nil) : window.ParentWindow
	IM_ASSERT(parent_window != nil || !(flags & ImGuiWindowFlags_.ImGuiWindowFlags_ChildWindow))

	// We allow window memory to be compacted so recreate the base stack when needed.
	if window.IDStack.Size == 0 { push_back(&window.IDStack, window.ID) }

	// Add to stack
	g.CurrentWindow = window
	resize(&g.CurrentWindowStack, g.CurrentWindowStack.Size + 1)
	window_stack_data : ^ImGuiWindowStackData = back(&g.CurrentWindowStack)
	window_stack_data.Window = window
	window_stack_data.ParentLastItemDataBackup = g.LastItemData
	window_stack_data.DisabledOverrideReenable = (flags & ImGuiWindowFlags_.ImGuiWindowFlags_Tooltip) && (g.CurrentItemFlags & ImGuiItemFlagsPrivate_.ImGuiItemFlags_Disabled)
	ErrorRecoveryStoreState(&window_stack_data.StackSizesInBegin)
	g.StackSizesInBeginForCurrentWindow = &window_stack_data.StackSizesInBegin
	if ImGuiWindowFlags_ChildMenu : ^flags; ImGuiWindowFlags_ChildMenu { post_incr(&g.BeginMenuDepth) }

	// Update ->RootWindow and others pointers (before any possible call to FocusWindow)
	if first_begin_of_the_frame {
		UpdateWindowParentAndRootLinks(window, flags, parent_window)
		window.ParentWindowInBeginStack = parent_window_in_stack

		// Focus route
		// There's little point to expose a flag to set this: because the interesting cases won't be using parent_window_in_stack,
		// Use for e.g. linking a tool window in a standalone viewport to a document window, regardless of their Begin() stack parenting. (#6798)
		window.ParentWindowForFocusRoute = (window.RootWindow != window) ? parent_window_in_stack : nil
		if window.ParentWindowForFocusRoute == nil && window.DockNode != nil { if window.DockNode.MergedFlags & ImGuiDockNodeFlagsPrivate_.ImGuiDockNodeFlags_DockedWindowsInFocusRoute { window.ParentWindowForFocusRoute = window.DockNode.HostWindow } }

		// Override with SetNextWindowClass() field or direct call to SetWindowParentWindowForFocusRoute()
		if window.WindowClass.FocusRouteParentWindowId != 0 {
			window.ParentWindowForFocusRoute = FindWindowByID(window.WindowClass.FocusRouteParentWindowId)
			IM_ASSERT(window.ParentWindowForFocusRoute != 0); // Invalid value for FocusRouteParentWindowId.
		}
	}

	// Add to focus scope stack
	PushFocusScope((window.ChildFlags & ImGuiChildFlags_.ImGuiChildFlags_NavFlattened) ? g.CurrentFocusScopeId : window.ID)
	window.NavRootFocusScopeId = g.CurrentFocusScopeId

	// Add to popup stacks: update OpenPopupStack[] data, push to BeginPopupStack[]
	if ImGuiWindowFlags_Popup : ^flags; ImGuiWindowFlags_Popup {
		popup_ref : ^ImGuiPopupData = g.OpenPopupStack[g.BeginPopupStack.Size]
		popup_ref.Window = window
		popup_ref.ParentNavLayer = parent_window_in_stack.DC.NavLayerCurrent
		push_back(&g.BeginPopupStack, popup_ref)
		window.PopupId = popup_ref.PopupId
	}

	// Process SetNextWindow***() calls
	// (FIXME: Consider splitting the HasXXX flags into X/Y components
	window_pos_set_by_api : bool = false
	window_size_x_set_by_api : bool = false; window_size_y_set_by_api : bool = false
	if g.NextWindowData.Flags & ImGuiNextWindowDataFlags_.ImGuiNextWindowDataFlags_HasPos {
		window_pos_set_by_api = (window.SetWindowPosAllowFlags & g.NextWindowData.PosCond) != 0
		if window_pos_set_by_api && ImLengthSqr(g.NextWindowData.PosPivotVal) > 0.00001 {
			// May be processed on the next frame if this is our first frame and we are measuring size
			// FIXME: Look into removing the branch so everything can go through this same code path for consistency.
			window.SetWindowPosVal = g.NextWindowData.PosVal
			window.SetWindowPosPivot = g.NextWindowData.PosPivotVal
			window.SetWindowPosAllowFlags &= !(ImGuiCond_.ImGuiCond_Once | ImGuiCond_.ImGuiCond_FirstUseEver | ImGuiCond_.ImGuiCond_Appearing)
		}
		else {
			SetWindowPos(window, g.NextWindowData.PosVal, g.NextWindowData.PosCond)
		}
	}
	if g.NextWindowData.Flags & ImGuiNextWindowDataFlags_.ImGuiNextWindowDataFlags_HasSize {
		window_size_x_set_by_api = (window.SetWindowSizeAllowFlags & g.NextWindowData.SizeCond) != 0 && (g.NextWindowData.SizeVal.x > 0.0)
		window_size_y_set_by_api = (window.SetWindowSizeAllowFlags & g.NextWindowData.SizeCond) != 0 && (g.NextWindowData.SizeVal.y > 0.0)
		if (window.ChildFlags & ImGuiChildFlags_.ImGuiChildFlags_ResizeX) && (window.SetWindowSizeAllowFlags & ImGuiCond_.ImGuiCond_FirstUseEver) == 0 {
			// Axis-specific conditions for BeginChild()g.NextWindowData.SizeVal.x = window.SizeFull.x
		}
		if (window.ChildFlags & ImGuiChildFlags_.ImGuiChildFlags_ResizeY) && (window.SetWindowSizeAllowFlags & ImGuiCond_.ImGuiCond_FirstUseEver) == 0 { g.NextWindowData.SizeVal.y = window.SizeFull.y }
		SetWindowSize(window, g.NextWindowData.SizeVal, g.NextWindowData.SizeCond)
	}
	if g.NextWindowData.Flags & ImGuiNextWindowDataFlags_.ImGuiNextWindowDataFlags_HasScroll {
		if g.NextWindowData.ScrollVal.x >= 0.0 {
			window.ScrollTarget.x = g.NextWindowData.ScrollVal.x
			window.ScrollTargetCenterRatio.x = 0.0
		}
		if g.NextWindowData.ScrollVal.y >= 0.0 {
			window.ScrollTarget.y = g.NextWindowData.ScrollVal.y
			window.ScrollTargetCenterRatio.y = 0.0
		}
	}
	if g.NextWindowData.Flags & ImGuiNextWindowDataFlags_.ImGuiNextWindowDataFlags_HasContentSize { window.ContentSizeExplicit = g.NextWindowData.ContentSizeVal }
	else if first_begin_of_the_frame { window.ContentSizeExplicit = ImVec2(0.0, 0.0) }
	if g.NextWindowData.Flags & ImGuiNextWindowDataFlags_.ImGuiNextWindowDataFlags_HasWindowClass { window.WindowClass = g.NextWindowData.WindowClass }
	if g.NextWindowData.Flags & ImGuiNextWindowDataFlags_.ImGuiNextWindowDataFlags_HasCollapsed { SetWindowCollapsed(window, g.NextWindowData.CollapsedVal, g.NextWindowData.CollapsedCond) }
	if g.NextWindowData.Flags & ImGuiNextWindowDataFlags_.ImGuiNextWindowDataFlags_HasFocus { FocusWindow(window) }
	if window.Appearing { SetWindowConditionAllowFlags(window, ImGuiCond_.ImGuiCond_Appearing, false) }

	// [EXPERIMENTAL] Skip Refresh mode
	UpdateWindowSkipRefresh(window)

	// Nested root windows (typically tooltips) override disabled state
	if window_stack_data.DisabledOverrideReenable && window.RootWindow == window { BeginDisabledOverrideReenable() }

	// We intentionally set g.CurrentWindow to NULL to prevent usage until when the viewport is set, then will call SetCurrentWindow()
	g.CurrentWindow = nil

	// When reusing window again multiple times a frame, just append content (don't need to setup again)
	if first_begin_of_the_frame && !window.SkipRefresh {
		// Initialize
		window_is_child_tooltip : bool = (flags & ImGuiWindowFlags_.ImGuiWindowFlags_ChildWindow) && (flags & ImGuiWindowFlags_.ImGuiWindowFlags_Tooltip); // FIXME-WIP: Undocumented behavior of Child+Tooltip for pinned tooltip (#1345)
		window_just_appearing_after_hidden_for_resize : bool = (window.HiddenFramesCannotSkipItems > 0)
		window.Active = true
		window.HasCloseButton = (p_open != nil)
		window.ClipRect = ImVec4(-FLT_MAX, -FLT_MAX, +FLT_MAX, +FLT_MAX)
		resize(&window.IDStack, 1)
		_ResetForNewFrame(window.DrawList)
		window.DC.CurrentTableIdx = -1
		if ImGuiWindowFlags_DockNodeHost : ^flags; ImGuiWindowFlags_DockNodeHost {
			ChannelsSplit(window.DrawList, 2)
			ChannelsSetCurrent(window.DrawList, DOCKING_HOST_DRAW_CHANNEL_FG); // Render decorations on channel 1 as we will render the backgrounds manually later
		}

		// Restore buffer capacity when woken from a compacted state, to avoid
		if window.MemoryCompacted { GcAwakeTransientWindowBuffers(window) }

		// Update stored window name when it changes (which can _only_ happen with the "###" operator, so the ID would stay unchanged).
		// The title bar always display the 'name' parameter, so we only update the string storage if it needs to be visible to the end-user elsewhere.
		window_title_visible_elsewhere : bool = false
		if (window.Viewport && window.Viewport.Window == window) || (window.DockIsActive) { window_title_visible_elsewhere = true }
		else if g.NavWindowingListWindow != nil && (window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoNavFocus) == 0 {
			// Window titles visible when using CTRL+TABwindow_title_visible_elsewhere = true
		}
		if window_title_visible_elsewhere && !window_just_created && strcmp(name, window.Name) != 0 {
			buf_len : uint = cast(uint) window.NameBufLen
			window.Name = ImStrdupcpy(window.Name, &buf_len, name)
			window.NameBufLen = cast(i32) buf_len
		}

		// UPDATE CONTENTS SIZE, UPDATE HIDDEN STATUS

		// Update contents size from last frame for auto-fitting (or use explicit size)
		CalcWindowContentSizes(window, &window.ContentSize, &window.ContentSizeIdeal)

		// FIXME: These flags are decremented before they are used. This means that in order to have these fields produce their intended behaviors
		// for one frame we must set them to at least 2, which is counter-intuitive. HiddenFramesCannotSkipItems is a more complicated case because
		// it has a single usage before this code block and may be set below before it is finally checked.
		if window.HiddenFramesCanSkipItems > 0 { post_decr(&window.HiddenFramesCanSkipItems) }
		if window.HiddenFramesCannotSkipItems > 0 { post_decr(&window.HiddenFramesCannotSkipItems) }
		if window.HiddenFramesForRenderOnly > 0 { post_decr(&window.HiddenFramesForRenderOnly) }

		// Hide new windows for one frame until they calculate their size
		if window_just_created && (!window_size_x_set_by_api || !window_size_y_set_by_api) { window.HiddenFramesCannotSkipItems = 1 }

		// Hide popup/tooltip window when re-opening while we measure size (because we recycle the windows)
		// We reset Size/ContentSize for reappearing popups/tooltips early in this function, so further code won't be tempted to use the old size.
		if window_just_activated_by_user && (flags & (ImGuiWindowFlags_.ImGuiWindowFlags_Popup | ImGuiWindowFlags_.ImGuiWindowFlags_Tooltip)) != 0 {
			window.HiddenFramesCannotSkipItems = 1
			if ImGuiWindowFlags_AlwaysAutoResize : ^flags; ImGuiWindowFlags_AlwaysAutoResize {
				if !window_size_x_set_by_api { window.SizeFull.x = 0.; window.Size.x = window.SizeFull.x }
				if !window_size_y_set_by_api { window.SizeFull.y = 0.; window.Size.y = window.SizeFull.y }
				window.ContentSizeIdeal = ImVec2(0., 0.); window.ContentSize = window.ContentSizeIdeal
			}
		}

		// SELECT VIEWPORT
		// We need to do this before using any style/font sizes, as viewport with a different DPI may affect font sizes.

		WindowSelectViewport(window)
		SetCurrentViewport(window, window.Viewport)
		window.FontDpiScale = (g.IO.ConfigFlags & ImGuiConfigFlags_.ImGuiConfigFlags_DpiEnableScaleFonts) ? window.Viewport.DpiScale : 1.0
		SetCurrentWindow(window)
		flags = window.Flags

		// LOCK BORDER SIZE AND PADDING FOR THE FRAME (so that altering them doesn't cause inconsistencies)
		// We read Style data after the call to UpdateSelectWindowViewport() which might be swapping the style.

		if !window.DockIsActive && (flags & ImGuiWindowFlags_.ImGuiWindowFlags_ChildWindow) { window.WindowBorderSize = style.ChildBorderSize }
		else { window.WindowBorderSize = ((flags & (ImGuiWindowFlags_.ImGuiWindowFlags_Popup | ImGuiWindowFlags_.ImGuiWindowFlags_Tooltip)) && !(flags & ImGuiWindowFlags_.ImGuiWindowFlags_Modal)) ? style.PopupBorderSize : style.WindowBorderSize }
		window.WindowPadding = style.WindowPadding
		if !window.DockIsActive && (flags & ImGuiWindowFlags_.ImGuiWindowFlags_ChildWindow) && !(flags & ImGuiWindowFlags_.ImGuiWindowFlags_Popup) && !(window.ChildFlags & ImGuiChildFlags_.ImGuiChildFlags_AlwaysUseWindowPadding) && window.WindowBorderSize == 0.0 { window.WindowPadding = ImVec2(0.0, (flags & ImGuiWindowFlags_.ImGuiWindowFlags_MenuBar) ? style.WindowPadding.y : 0.0) }

		// Lock menu offset so size calculation can use it as menu-bar windows need a minimum size.
		window.DC.MenuBarOffset.x = ImMax(ImMax(window.WindowPadding.x, style.ItemSpacing.x), g.NextWindowData.MenuBarOffsetMinVal.x)
		window.DC.MenuBarOffset.y = g.NextWindowData.MenuBarOffsetMinVal.y
		window.TitleBarHeight = (flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoTitleBar) ? 0.0 : g.FontSize + g.Style.FramePadding.y * 2.0
		window.MenuBarHeight = (flags & ImGuiWindowFlags_.ImGuiWindowFlags_MenuBar) ? window.DC.MenuBarOffset.y + g.FontSize + g.Style.FramePadding.y * 2.0 : 0.0

		// Depending on condition we use previous or current window size to compare against contents size to decide if a scrollbar should be visible.
		// Those flags will be altered further down in the function depending on more conditions.
		use_current_size_for_scrollbar_x : bool = window_just_created
		use_current_size_for_scrollbar_y : bool = window_just_created
		if window_size_x_set_by_api && window.ContentSizeExplicit.x != 0.0 { use_current_size_for_scrollbar_x = true }
		if window_size_y_set_by_api && window.ContentSizeExplicit.y != 0.0 {
			// #7252use_current_size_for_scrollbar_y = true
		}

		// Collapse window by double-clicking on title bar
		// At this point we don't have a clipping rectangle setup yet, so we can use the title bar area for hit detection and drawing
		if !(flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoTitleBar) && !(flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoCollapse) && !window.DockIsActive {
			// We don't use a regular button+id to test for double-click on title bar (mostly due to legacy reason, could be fixed),
			// so verify that we don't have items over the title bar.
			title_bar_rect : ImRect = TitleBarRect(window)
			if g.HoveredWindow == window && g.HoveredId == 0 && g.HoveredIdPreviousFrame == 0 && g.ActiveId == 0 && IsMouseHoveringRect(title_bar_rect.Min, title_bar_rect.Max) { if g.IO.MouseClickedCount[0] == 2 && GetKeyOwner(ImGuiKey.ImGuiKey_MouseLeft) == ImGuiKeyOwner_NoOwner { window.WantCollapseToggle = true } }
			if window.WantCollapseToggle {
				window.Collapsed = !window.Collapsed
				if !window.Collapsed { use_current_size_for_scrollbar_y = true }
				MarkIniSettingsDirty(window)
			}
		}
		else {
			window.Collapsed = false
		}
		window.WantCollapseToggle = false

		// SIZE

		// Outer Decoration Sizes
		// (we need to clear ScrollbarSize immediately as CalcWindowAutoFitSize() needs it and can be called from other locations).
		scrollbar_sizes_from_last_frame : ImVec2 = window.ScrollbarSizes
		window.DecoOuterSizeX1 = 0.0
		window.DecoOuterSizeX2 = 0.0
		window.DecoOuterSizeY1 = window.TitleBarHeight + window.MenuBarHeight
		window.DecoOuterSizeY2 = 0.0
		window.ScrollbarSizes = ImVec2(0.0, 0.0)

		// Calculate auto-fit size, handle automatic resize
		size_auto_fit : ImVec2 = CalcWindowAutoFitSize(window, window.ContentSizeIdeal)
		if (flags & ImGuiWindowFlags_.ImGuiWindowFlags_AlwaysAutoResize) && !window.Collapsed {
			// Using SetNextWindowSize() overrides ImGuiWindowFlags_AlwaysAutoResize, so it can be used on tooltips/popups, etc.
			if !window_size_x_set_by_api {
				window.SizeFull.x = size_auto_fit.x
				use_current_size_for_scrollbar_x = true
			}
			if !window_size_y_set_by_api {
				window.SizeFull.y = size_auto_fit.y
				use_current_size_for_scrollbar_y = true
			}
		}
		else if window.AutoFitFramesX > 0 || window.AutoFitFramesY > 0 {
			// Auto-fit may only grow window during the first few frames
			// We still process initial auto-fit on collapsed windows to get a window width, but otherwise don't honor ImGuiWindowFlags_AlwaysAutoResize when collapsed.
			if !window_size_x_set_by_api && window.AutoFitFramesX > 0 {
				window.SizeFull.x = window.AutoFitOnlyGrows ? ImMax(window.SizeFull.x, size_auto_fit.x) : size_auto_fit.x
				use_current_size_for_scrollbar_x = true
			}
			if !window_size_y_set_by_api && window.AutoFitFramesY > 0 {
				window.SizeFull.y = window.AutoFitOnlyGrows ? ImMax(window.SizeFull.y, size_auto_fit.y) : size_auto_fit.y
				use_current_size_for_scrollbar_y = true
			}
			if !window.Collapsed { MarkIniSettingsDirty(window) }
		}

		// Apply minimum/maximum window size constraints and final size
		window.SizeFull = CalcWindowSizeAfterConstraint(window, window.SizeFull)
		window.Size = window.Collapsed && !(flags & ImGuiWindowFlags_.ImGuiWindowFlags_ChildWindow) ? GetSize(&TitleBarRect(window)) : window.SizeFull

		// POSITION

		// Popup latch its initial position, will position itself when it appears next frame
		if window_just_activated_by_user {
			window.AutoPosLastDirection = ImGuiDir.ImGuiDir_None
			if (flags & ImGuiWindowFlags_.ImGuiWindowFlags_Popup) != 0 && !(flags & ImGuiWindowFlags_.ImGuiWindowFlags_Modal) && !window_pos_set_by_api {
				// FIXME: BeginPopup() could use SetNextWindowPos()window.Pos = back(&g.BeginPopupStack).OpenPopupPos
			}
		}

		// Position child window
		if ImGuiWindowFlags_ChildWindow : ^flags; ImGuiWindowFlags_ChildWindow {
			IM_ASSERT(parent_window && parent_window.Active)
			window.BeginOrderWithinParent = cast(i16) parent_window.DC.ChildWindows.Size
			push_back(&parent_window.DC.ChildWindows, window)
			if !(flags & ImGuiWindowFlags_.ImGuiWindowFlags_Popup) && !window_pos_set_by_api && !window_is_child_tooltip { window.Pos = parent_window.DC.CursorPos }
		}

		window_pos_with_pivot : bool = (window.SetWindowPosVal.x != FLT_MAX && window.HiddenFramesCannotSkipItems == 0)
		if window_pos_with_pivot {
			// Position given a pivot (e.g. for centering)
			SetWindowPos(window, window.SetWindowPosVal - window.Size * window.SetWindowPosPivot, 0)
		}
		else if (flags & ImGuiWindowFlags_.ImGuiWindowFlags_ChildMenu) != 0 { window.Pos = FindBestWindowPosForPopup(window) }
		else if (flags & ImGuiWindowFlags_.ImGuiWindowFlags_Popup) != 0 && !window_pos_set_by_api && window_just_appearing_after_hidden_for_resize { window.Pos = FindBestWindowPosForPopup(window) }
		else if (flags & ImGuiWindowFlags_.ImGuiWindowFlags_Tooltip) != 0 && !window_pos_set_by_api && !window_is_child_tooltip { window.Pos = FindBestWindowPosForPopup(window) }

		// Late create viewport if we don't fit within our current host viewport.
		if window.ViewportAllowPlatformMonitorExtend >= 0 && !window.ViewportOwned && !(window.Viewport.Flags & ImGuiViewportFlags_.ImGuiViewportFlags_IsMinimized) { if !Contains(&GetMainRect(window.Viewport), Rect(window)) {
	// This is based on the assumption that the DPI will be known ahead (same as the DPI of the selection done in UpdateSelectWindowViewport)
	//ImGuiViewport* old_viewport = window->Viewport;
	window.Viewport = AddUpdateViewport(window, window.ID, window.Pos, window.Size, ImGuiViewportFlags_.ImGuiViewportFlags_NoFocusOnAppearing)

	// FIXME-DPI
	//IM_ASSERT(old_viewport->DpiScale == window->Viewport->DpiScale); // FIXME-DPI: Something went wrong
	SetCurrentViewport(window, window.Viewport)
	window.FontDpiScale = (g.IO.ConfigFlags & ImGuiConfigFlags_.ImGuiConfigFlags_DpiEnableScaleFonts) ? window.Viewport.DpiScale : 1.0
	SetCurrentWindow(window)
} }

		if window.ViewportOwned { WindowSyncOwnedViewport(window, parent_window_in_stack) }

		// Calculate the range of allowed position for that window (to be movable and visible past safe area padding)
		// When clamping to stay visible, we will enforce that window->Pos stays inside of visibility_rect.
		viewport_rect : ImRect; init(&viewport_rect, GetMainRect(window.Viewport))
		viewport_work_rect : ImRect; init(&viewport_work_rect, GetWorkRect(window.Viewport))
		visibility_padding : ImVec2 = ImMax(style.DisplayWindowPadding, style.DisplaySafeAreaPadding)
		visibility_rect : ImRect; init(&visibility_rect, viewport_work_rect.Min + visibility_padding, viewport_work_rect.Max - visibility_padding)

		// Clamp position/size so window stays visible within its viewport or monitor
		// Ignore zero-sized display explicitly to avoid losing positions if a window manager reports zero-sized window when initializing or minimizing.
		// FIXME: Similar to code in GetWindowAllowedExtentRect()
		if !window_pos_set_by_api && !(flags & ImGuiWindowFlags_.ImGuiWindowFlags_ChildWindow) {
			if !window.ViewportOwned && GetWidth(&viewport_rect) > 0 && GetHeight(&viewport_rect) > 0.0 {
				ClampWindowPos(window, visibility_rect)
			}
			else if window.ViewportOwned && g.PlatformIO.Monitors.Size > 0 {
				if g.MovingWindow != nil && window.RootWindowDockTree == g.MovingWindow.RootWindowDockTree {
					// While moving windows we allow them to straddle monitors (#7299, #3071)
					visibility_rect = g.PlatformMonitorsFullWorkRect
				}
				else {
					// When not moving ensure visible in its monitor
					// Lost windows (e.g. a monitor disconnected) will naturally moved to the fallback/dummy monitor aka the main viewport.
					monitor : ^ImGuiPlatformMonitor = GetViewportPlatformMonitor(window.Viewport)
					visibility_rect = ImRect(monitor.WorkPos, monitor.WorkPos + monitor.WorkSize)
				}
				Expand(&visibility_rect, -visibility_padding)
				ClampWindowPos(window, visibility_rect)
			}
		}
		window.Pos = ImTrunc(window.Pos)

		// Lock window rounding for the frame (so that altering them doesn't cause inconsistencies)
		// Large values tend to lead to variety of artifacts and are not recommended.
		if window.ViewportOwned || window.DockIsActive { window.WindowRounding = 0.0 }
		else { window.WindowRounding = (flags & ImGuiWindowFlags_.ImGuiWindowFlags_ChildWindow) ? style.ChildRounding : ((flags & ImGuiWindowFlags_.ImGuiWindowFlags_Popup) && !(flags & ImGuiWindowFlags_.ImGuiWindowFlags_Modal)) ? style.PopupRounding : style.WindowRounding }

		// For windows with title bar or menu bar, we clamp to FrameHeight(FontSize + FramePadding.y * 2.0f) to completely hide artifacts.
		//if ((window->Flags & ImGuiWindowFlags_MenuBar) || !(window->Flags & ImGuiWindowFlags_NoTitleBar))
		//    window->WindowRounding = ImMin(window->WindowRounding, g.FontSize + style.FramePadding.y * 2.0f);

		// Apply window focus (new and reactivated windows are moved to front)
		want_focus : bool = false
		if window_just_activated_by_user && !(flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoFocusOnAppearing) {
			if ImGuiWindowFlags_Popup : ^flags; ImGuiWindowFlags_Popup { want_focus = true }
			else if (window.DockIsActive || (flags & ImGuiWindowFlags_.ImGuiWindowFlags_ChildWindow) == 0) && !(flags & ImGuiWindowFlags_.ImGuiWindowFlags_Tooltip) { want_focus = true }
		}

		// [Test Engine] Register whole window in the item system (before submitting further decorations)
		when defined ( IMGUI_ENABLE_TEST_ENGINE ) {
		if g.TestEngineHookItems {
			IM_ASSERT(window.IDStack.Size == 1)
			window.IDStack.Size = 0; // As window->IDStack[0] == window->ID here, make sure TestEngine doesn't erroneously see window as parent of itself.
			window.DC.NavLayerCurrent = ImGuiNavLayer.ImGuiNavLayer_Menu
			IMGUI_TEST_ENGINE_ITEM_ADD(window.ID, Rect(window), nil)
			IMGUI_TEST_ENGINE_ITEM_INFO(window.ID, window.Name, (g.HoveredWindow == window) ? ImGuiItemStatusFlags_.ImGuiItemStatusFlags_HoveredRect : 0)
			window.IDStack.Size = 1
			window.DC.NavLayerCurrent = ImGuiNavLayer.ImGuiNavLayer_Main

		}
		} // preproc endif

		// Decide if we are going to handle borders and resize grips
		handle_borders_and_resize_grips : bool = (window.DockNodeAsHost || !window.DockIsActive)

		// Handle manual resize: Resize Grips, Borders, Gamepad
		border_hovered : i32 = -1; border_held : i32 = -1
		resize_grip_col : [4]ImU32 = {}
		resize_grip_count : i32 = ((flags & ImGuiWindowFlags_.ImGuiWindowFlags_ChildWindow) && !(flags & ImGuiWindowFlags_.ImGuiWindowFlags_Popup)) ? 0 : g.IO.ConfigWindowsResizeFromEdges ? 2 : 1; // Allow resize from lower-left if we have the mouse cursor feedback for it.
		resize_grip_draw_size : f32 = IM_TRUNC(ImMax(g.FontSize * 1.10, window.WindowRounding + 1.0 + g.FontSize * 0.2))
		if handle_borders_and_resize_grips && !window.Collapsed { if auto_fit_mask : i32 = UpdateWindowManualResize(window, size_auto_fit, &border_hovered, &border_held, resize_grip_count, &resize_grip_col[0], visibility_rect); auto_fit_mask {
	if auto_fit_mask & (1 << ImGuiAxis.ImGuiAxis_X) { use_current_size_for_scrollbar_x = true }
	if auto_fit_mask & (1 << ImGuiAxis.ImGuiAxis_Y) { use_current_size_for_scrollbar_y = true }
} }
		window.ResizeBorderHovered = cast(i8) border_hovered
		window.ResizeBorderHeld = cast(i8) border_held

		// Synchronize window --> viewport again and one last time (clamping and manual resize may have affected either)
		if window.ViewportOwned {
			if !window.Viewport.PlatformRequestMove { window.Viewport.Pos = window.Pos }
			if !window.Viewport.PlatformRequestResize { window.Viewport.Size = window.Size }
			UpdateWorkRect(window.Viewport)
			viewport_rect = GetMainRect(window.Viewport)
		}

		// Save last known viewport position within the window itself (so it can be saved in .ini file and restored)
		window.ViewportPos = window.Viewport.Pos

		// SCROLLBAR VISIBILITY

		// Update scrollbar visibility (based on the Size that was effective during last frame or the auto-resized Size).
		if !window.Collapsed {
			// When reading the current size we need to read it after size constraints have been applied.
			// Intentionally use previous frame values for InnerRect and ScrollbarSizes.
			// And when we use window->DecorationUp here it doesn't have ScrollbarSizes.y applied yet.
			avail_size_from_current_frame : ImVec2 = ImVec2(window.SizeFull.x, window.SizeFull.y - (window.DecoOuterSizeY1 + window.DecoOuterSizeY2))
			avail_size_from_last_frame : ImVec2 = GetSize(&window.InnerRect) + scrollbar_sizes_from_last_frame
			needed_size_from_last_frame : ImVec2 = window_just_created ? ImVec2(0, 0) : window.ContentSize + window.WindowPadding * 2.0
			size_x_for_scrollbars : f32 = use_current_size_for_scrollbar_x ? avail_size_from_current_frame.x : avail_size_from_last_frame.x
			size_y_for_scrollbars : f32 = use_current_size_for_scrollbar_y ? avail_size_from_current_frame.y : avail_size_from_last_frame.y
			//bool scrollbar_y_from_last_frame = window->ScrollbarY; // FIXME: May want to use that in the ScrollbarX expression? How many pros vs cons?
			window.ScrollbarY = (flags & ImGuiWindowFlags_.ImGuiWindowFlags_AlwaysVerticalScrollbar) || ((needed_size_from_last_frame.y > size_y_for_scrollbars) && !(flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoScrollbar))
			window.ScrollbarX = (flags & ImGuiWindowFlags_.ImGuiWindowFlags_AlwaysHorizontalScrollbar) || ((needed_size_from_last_frame.x > size_x_for_scrollbars - (window.ScrollbarY ? style.ScrollbarSize : 0.0)) && !(flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoScrollbar) && (flags & ImGuiWindowFlags_.ImGuiWindowFlags_HorizontalScrollbar))
			if window.ScrollbarX && !window.ScrollbarY { window.ScrollbarY = (needed_size_from_last_frame.y > size_y_for_scrollbars - style.ScrollbarSize) && !(flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoScrollbar) }
			window.ScrollbarSizes = ImVec2(window.ScrollbarY ? style.ScrollbarSize : 0.0, window.ScrollbarX ? style.ScrollbarSize : 0.0)

			// Amend the partially filled window->DecorationXXX values.
			window.DecoOuterSizeX2 += window.ScrollbarSizes.x
			window.DecoOuterSizeY2 += window.ScrollbarSizes.y
		}

		// UPDATE RECTANGLES (1- THOSE NOT AFFECTED BY SCROLLING)
		// Update various regions. Variables they depend on should be set above in this function.
		// We set this up after processing the resize grip so that our rectangles doesn't lag by a frame.

		// Outer rectangle
		// Not affected by window border size. Used by:
		// - FindHoveredWindow() (w/ extra padding when border resize is enabled)
		// - Begin() initial clipping rect for drawing window background and borders.
		// - Begin() clipping whole child
		host_rect : ImRect = ((flags & ImGuiWindowFlags_.ImGuiWindowFlags_ChildWindow) && !(flags & ImGuiWindowFlags_.ImGuiWindowFlags_Popup) && !window_is_child_tooltip) ? parent_window.ClipRect : viewport_rect
		outer_rect : ImRect = Rect(window)
		title_bar_rect : ImRect = TitleBarRect(window)
		window.OuterRectClipped = outer_rect
		if window.DockIsActive { window.OuterRectClipped.Min.y += window.TitleBarHeight }
		ClipWith(&window.OuterRectClipped, host_rect)

		// Inner rectangle
		// Not affected by window border size. Used by:
		// - InnerClipRect
		// - ScrollToRectEx()
		// - NavUpdatePageUpPageDown()
		// - Scrollbar()
		window.InnerRect.Min.x = window.Pos.x + window.DecoOuterSizeX1
		window.InnerRect.Min.y = window.Pos.y + window.DecoOuterSizeY1
		window.InnerRect.Max.x = window.Pos.x + window.Size.x - window.DecoOuterSizeX2
		window.InnerRect.Max.y = window.Pos.y + window.Size.y - window.DecoOuterSizeY2

		// Inner clipping rectangle.
		// - Extend a outside of normal work region up to borders.
		// - This is to allow e.g. Selectable or CollapsingHeader or some separators to cover that space.
		// - It also makes clipped items be more noticeable.
		// - And is consistent on both axis (prior to 2024/05/03 ClipRect used WindowPadding.x * 0.5f on left and right edge), see #3312
		// - Force round operator last to ensure that e.g. (int)(max.x-min.x) in user's render code produce correct result.
		// Note that if our window is collapsed we will end up with an inverted (~null) clipping rectangle which is the correct behavior.
		// Affected by window/frame border size. Used by:
		// - Begin() initial clip rect
		top_border_size : f32 = (((flags & ImGuiWindowFlags_.ImGuiWindowFlags_MenuBar) || !(flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoTitleBar)) ? style.FrameBorderSize : window.WindowBorderSize)

		// Try to match the fact that our border is drawn centered over the window rectangle, rather than inner.
		// This is why we do a *0.5f here. We don't currently even technically support large values for WindowBorderSize,
		// see e.g #7887 #7888, but may do after we move the window border to become an inner border (and then we can remove the 0.5f here).
		window.InnerClipRect.Min.x = ImFloor(0.5 + window.InnerRect.Min.x + window.WindowBorderSize * 0.5)
		window.InnerClipRect.Min.y = ImFloor(0.5 + window.InnerRect.Min.y + top_border_size * 0.5)
		window.InnerClipRect.Max.x = ImFloor(window.InnerRect.Max.x - window.WindowBorderSize * 0.5)
		window.InnerClipRect.Max.y = ImFloor(window.InnerRect.Max.y - window.WindowBorderSize * 0.5)
		ClipWithFull(&window.InnerClipRect, host_rect)

		// Default item width. Make it proportional to window size if window manually resizes
		if window.Size.x > 0.0 && !(flags & ImGuiWindowFlags_.ImGuiWindowFlags_Tooltip) && !(flags & ImGuiWindowFlags_.ImGuiWindowFlags_AlwaysAutoResize) { window.ItemWidthDefault = ImTrunc(window.Size.x * 0.65) }
		else { window.ItemWidthDefault = ImTrunc(g.FontSize * 16.0) }

		// SCROLLING

		// Lock down maximum scrolling
		// The value of ScrollMax are ahead from ScrollbarX/ScrollbarY which is intentionally using InnerRect from previous rect in order to accommodate
		// for right/bottom aligned items without creating a scrollbar.
		window.ScrollMax.x = ImMax(0.0, window.ContentSize.x + window.WindowPadding.x * 2.0 - GetWidth(&window.InnerRect))
		window.ScrollMax.y = ImMax(0.0, window.ContentSize.y + window.WindowPadding.y * 2.0 - GetHeight(&window.InnerRect))

		// Apply scrolling
		window.Scroll = CalcNextScrollFromScrollTargetAndClamp(window)
		window.ScrollTarget = ImVec2(FLT_MAX, FLT_MAX)
		window.DecoInnerSizeY1 = 0.0; window.DecoInnerSizeX1 = window.DecoInnerSizeY1

		// DRAWING

		// Setup draw list and outer clipping rectangle
		IM_ASSERT(window.DrawList.CmdBuffer.Size == 1 && window.DrawList.CmdBuffer[0].ElemCount == 0)
		PushTextureID(window.DrawList, g.Font.ContainerAtlas.TexID)
		PushClipRect(host_rect.Min, host_rect.Max, false)

		// Child windows can render their decoration (bg color, border, scrollbars, etc.) within their parent to save a draw call (since 1.71)
		// When using overlapping child windows, this will break the assumption that child z-order is mapped to submission order.
		// FIXME: User code may rely on explicit sorting of overlapping child window and would need to disable this somehow. Please get in contact if you are affected (github #4493)
		is_undocked_or_docked_visible : bool = !window.DockIsActive || window.DockTabIsVisible
		if is_undocked_or_docked_visible {
			render_decorations_in_parent : bool = false
			if (flags & ImGuiWindowFlags_.ImGuiWindowFlags_ChildWindow) && !(flags & ImGuiWindowFlags_.ImGuiWindowFlags_Popup) && !window_is_child_tooltip {
				// - We test overlap with the previous child window only (testing all would end up being O(log N) not a good investment here)
				// - We disable this when the parent window has zero vertices, which is a common pattern leading to laying out multiple overlapping childs
				previous_child : ^ImGuiWindow = parent_window.DC.ChildWindows.Size >= 2 ? parent_window.DC.ChildWindows[parent_window.DC.ChildWindows.Size - 2] : nil
				previous_child_overlapping : bool = previous_child ? Overlaps(&Rect(previous_child), Rect(window)) : false
				parent_is_empty : bool = (parent_window.DrawList.VtxBuffer.Size == 0)
				if back(&window.DrawList.CmdBuffer).ElemCount == 0 && !parent_is_empty && !previous_child_overlapping { render_decorations_in_parent = true }
			}
			if render_decorations_in_parent { window.DrawList = parent_window.DrawList }

			// Handle title bar, scrollbar, resize grips and resize borders
			window_to_highlight : ^ImGuiWindow = g.NavWindowingTarget ? g.NavWindowingTarget : g.NavWindow
			title_bar_is_highlight : bool = want_focus || (window_to_highlight && (window.RootWindowForTitleBarHighlight == window_to_highlight.RootWindowForTitleBarHighlight || (window.DockNode && window.DockNode == window_to_highlight.DockNode)))
			RenderWindowDecorations(window, title_bar_rect, title_bar_is_highlight, handle_borders_and_resize_grips, resize_grip_count, resize_grip_col, resize_grip_draw_size)

			if render_decorations_in_parent { window.DrawList = &window.DrawListInst }
		}

		// UPDATE RECTANGLES (2- THOSE AFFECTED BY SCROLLING)

		// Work rectangle.
		// Affected by window padding and border size. Used by:
		// - Columns() for right-most edge
		// - TreeNode(), CollapsingHeader() for right-most edge
		// - BeginTabBar() for right-most edge
		allow_scrollbar_x : bool = !(flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoScrollbar) && (flags & ImGuiWindowFlags_.ImGuiWindowFlags_HorizontalScrollbar)
		allow_scrollbar_y : bool = !(flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoScrollbar)
		work_rect_size_x : f32 = (window.ContentSizeExplicit.x != 0.0 ? window.ContentSizeExplicit.x : ImMax(allow_scrollbar_x ? window.ContentSize.x : 0.0, window.Size.x - window.WindowPadding.x * 2.0 - (window.DecoOuterSizeX1 + window.DecoOuterSizeX2)))
		work_rect_size_y : f32 = (window.ContentSizeExplicit.y != 0.0 ? window.ContentSizeExplicit.y : ImMax(allow_scrollbar_y ? window.ContentSize.y : 0.0, window.Size.y - window.WindowPadding.y * 2.0 - (window.DecoOuterSizeY1 + window.DecoOuterSizeY2)))
		window.WorkRect.Min.x = ImTrunc(window.InnerRect.Min.x - window.Scroll.x + ImMax(window.WindowPadding.x, window.WindowBorderSize))
		window.WorkRect.Min.y = ImTrunc(window.InnerRect.Min.y - window.Scroll.y + ImMax(window.WindowPadding.y, window.WindowBorderSize))
		window.WorkRect.Max.x = window.WorkRect.Min.x + work_rect_size_x
		window.WorkRect.Max.y = window.WorkRect.Min.y + work_rect_size_y
		window.ParentWorkRect = window.WorkRect

		// [LEGACY] Content Region
		// FIXME-OBSOLETE: window->ContentRegionRect.Max is currently very misleading / partly faulty, but some BeginChild() patterns relies on it.
		// Unless explicit content size is specified by user, this currently represent the region leading to no scrolling.
		// Used by:
		// - Mouse wheel scrolling + many other things
		window.ContentRegionRect.Min.x = window.Pos.x - window.Scroll.x + window.WindowPadding.x + window.DecoOuterSizeX1
		window.ContentRegionRect.Min.y = window.Pos.y - window.Scroll.y + window.WindowPadding.y + window.DecoOuterSizeY1
		window.ContentRegionRect.Max.x = window.ContentRegionRect.Min.x + (window.ContentSizeExplicit.x != 0.0 ? window.ContentSizeExplicit.x : (window.Size.x - window.WindowPadding.x * 2.0 - (window.DecoOuterSizeX1 + window.DecoOuterSizeX2)))
		window.ContentRegionRect.Max.y = window.ContentRegionRect.Min.y + (window.ContentSizeExplicit.y != 0.0 ? window.ContentSizeExplicit.y : (window.Size.y - window.WindowPadding.y * 2.0 - (window.DecoOuterSizeY1 + window.DecoOuterSizeY2)))

		// Setup drawing context
		// (NB: That term "drawing context / DC" lost its meaning a long time ago. Initially was meant to hold transient data only. Nowadays difference between window-> and window->DC-> is dubious.)
		window.DC.Indent.x = window.DecoOuterSizeX1 + window.WindowPadding.x - window.Scroll.x
		window.DC.GroupOffset.x = 0.0
		window.DC.ColumnsOffset.x = 0.0

		// Record the loss of precision of CursorStartPos which can happen due to really large scrolling amount.
		// This is used by clipper to compensate and fix the most common use case of large scroll area. Easy and cheap, next best thing compared to switching everything to double or ImU64.
		start_pos_highp_x : f64 = cast(f64) window.Pos.x + window.WindowPadding.x - cast(f64) window.Scroll.x + window.DecoOuterSizeX1 + window.DC.ColumnsOffset.x
		start_pos_highp_y : f64 = cast(f64) window.Pos.y + window.WindowPadding.y - cast(f64) window.Scroll.y + window.DecoOuterSizeY1
		window.DC.CursorStartPos = ImVec2(cast(f32) start_pos_highp_x, cast(f32) start_pos_highp_y)
		window.DC.CursorStartPosLossyness = ImVec2(cast(f32) (start_pos_highp_x - window.DC.CursorStartPos.x), cast(f32) (start_pos_highp_y - window.DC.CursorStartPos.y))
		window.DC.CursorPos = window.DC.CursorStartPos
		window.DC.CursorPosPrevLine = window.DC.CursorPos
		window.DC.CursorMaxPos = window.DC.CursorStartPos
		window.DC.IdealMaxPos = window.DC.CursorStartPos
		window.DC.PrevLineSize = ImVec2(0.0, 0.0); window.DC.CurrLineSize = window.DC.PrevLineSize
		window.DC.PrevLineTextBaseOffset = 0.0; window.DC.CurrLineTextBaseOffset = window.DC.PrevLineTextBaseOffset
		window.DC.IsSetPos = false; window.DC.IsSameLine = window.DC.IsSetPos

		window.DC.NavLayerCurrent = ImGuiNavLayer.ImGuiNavLayer_Main
		window.DC.NavLayersActiveMask = window.DC.NavLayersActiveMaskNext
		window.DC.NavLayersActiveMaskNext = 0x00
		window.DC.NavIsScrollPushableX = true
		window.DC.NavHideHighlightOneFrame = false
		window.DC.NavWindowHasScrollY = (window.ScrollMax.y > 0.0)

		window.DC.MenuBarAppending = false
		Update(&window.DC.MenuColumns, style.ItemSpacing.x, window_just_activated_by_user)
		window.DC.TreeDepth = 0
		window.DC.TreeHasStackDataDepthMask = 0x00
		resize(&window.DC.ChildWindows, 0)
		window.DC.StateStorage = &window.StateStorage
		window.DC.CurrentColumns = nil
		window.DC.LayoutType = ImGuiLayoutType_.ImGuiLayoutType_Vertical
		window.DC.ParentLayoutType = parent_window ? parent_window.DC.LayoutType : ImGuiLayoutType_.ImGuiLayoutType_Vertical

		window.DC.ItemWidth = window.ItemWidthDefault
		window.DC.TextWrapPos = -1.0; // disabled
		resize(&window.DC.ItemWidthStack, 0)
		resize(&window.DC.TextWrapPosStack, 0)
		if ImGuiWindowFlags_Modal : ^flags; ImGuiWindowFlags_Modal { window.DC.ModalDimBgColor = ColorConvertFloat4ToU32(GetStyleColorVec4(ImGuiCol_.ImGuiCol_ModalWindowDimBg)) }

		if window.AutoFitFramesX > 0 { post_decr(&window.AutoFitFramesX) }
		if window.AutoFitFramesY > 0 { post_decr(&window.AutoFitFramesY) }

		// Clear SetNextWindowXXX data (can aim to move this higher in the function)
		ClearFlags(&g.NextWindowData)

		// Apply focus (we need to call FocusWindow() AFTER setting DC.CursorStartPos so our initial navigation reference rectangle can start around there)
		// We ImGuiFocusRequestFlags_UnlessBelowModal to:
		// - Avoid focusing a window that is created outside of a modal. This will prevent active modal from being closed.
		// - Position window behind the modal that is not a begin-parent of this window.
		if want_focus { FocusWindow(window, ImGuiFocusRequestFlags_.ImGuiFocusRequestFlags_UnlessBelowModal) }
		if want_focus && window == g.NavWindow {
			// <-- this is in the way for us to be able to defer and sort reappearing FocusWindow() calls
			NavInitWindow(window, false)
		}

		// Close requested by platform window (apply to all windows in this viewport)
		if p_open != nil && window.Viewport.PlatformRequestClose && window.Viewport != GetMainViewport() {
			IMGUI_DEBUG_LOG_VIEWPORT("[viewport] Window '%s' closed by PlatformRequestClose\n", window.Name)
			p_open^ = false
			g.NavWindowingToggleLayer = false; // Assume user mapped PlatformRequestClose on ALT-F4 so we disable ALT for menu toggle. False positive not an issue. // FIXME-NAV: Try removing.
		}

		// Pressing CTRL+C copy window content into the clipboard
		// [EXPERIMENTAL] Breaks on nested Begin/End pairs. We need to work that out and add better logging scope.
		// [EXPERIMENTAL] Text outputs has many issues.
		if g.IO.ConfigWindowsCopyContentsWithCtrlC { if g.NavWindow && g.NavWindow.RootWindow == window && g.ActiveId == 0 && Shortcut(ImGuiKey.ImGuiMod_Ctrl | ImGuiKey.ImGuiKey_C) { LogToClipboard(0) } }

		// Title bar
		if !(flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoTitleBar) && !window.DockIsActive { RenderWindowTitleBarContents(window, ImRect(title_bar_rect.Min.x + window.WindowBorderSize, title_bar_rect.Min.y, title_bar_rect.Max.x - window.WindowBorderSize, title_bar_rect.Max.y), name, p_open) }
		else if !(flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoTitleBar) && window.DockIsActive { LogText("%.*s\n", cast(i32) (FindRenderedTextEnd(window.Name) - window.Name), window.Name) }

		// Clear hit test shape every frame
		window.HitTestHoleSize.y = 0; window.HitTestHoleSize.x = window.HitTestHoleSize.y

		if ImGuiWindowFlags_Tooltip : ^flags; ImGuiWindowFlags_Tooltip { g.TooltipPreviousWindow = window }

		if g.IO.ConfigFlags & ImGuiConfigFlags_.ImGuiConfigFlags_DockingEnable {
			// Docking: Dragging a dockable window (or any of its child) turns it into a drag and drop source.
			// We need to do this _before_ we overwrite window->DC.LastItemId below because BeginDockableDragDropSource() also overwrites it.
			if g.MovingWindow == window && (window.RootWindowDockTree.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoDocking) == 0 { BeginDockableDragDropSource(window) }

			// Docking: Any dockable window can act as a target. For dock node hosts we call BeginDockableDragDropTarget() in DockNodeUpdate() instead.
			if g.DragDropActive && !(flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoDocking) { if g.MovingWindow == nil || g.MovingWindow.RootWindowDockTree != window { if (window == window.RootWindowDockTree) && !(window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_DockNodeHost) { BeginDockableDragDropTarget(window) } } }
		}

		// We fill last item data based on Title Bar/Tab, in order for IsItemHovered() and IsItemActive() to be usable after Begin().
		// This is useful to allow creating context menus on title bar only, etc.
		SetLastItemDataForWindow(window, title_bar_rect)

		// [DEBUG]
		when ! defined ( IMGUI_DISABLE_DEBUG_TOOLS ) {
		if g.DebugLocateId != 0 && (window.ID == g.DebugLocateId || window.MoveId == g.DebugLocateId) { DebugLocateItemResolveWithLastItem() }
		} // preproc endif

		// [Test Engine] Register title bar / tab with MoveId.
		when defined ( IMGUI_ENABLE_TEST_ENGINE ) {
		if !(window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoTitleBar) {
			window.DC.NavLayerCurrent = ImGuiNavLayer.ImGuiNavLayer_Menu
			IMGUI_TEST_ENGINE_ITEM_ADD(g.LastItemData.ID, g.LastItemData.Rect, &g.LastItemData)
			window.DC.NavLayerCurrent = ImGuiNavLayer.ImGuiNavLayer_Main
		}
		} // preproc endif
	}
	else {
		// Skip refresh always mark active
		if window.SkipRefresh { SetWindowActiveForSkipRefresh(window) }

		// Append
		SetCurrentViewport(window, window.Viewport)
		SetCurrentWindow(window)
		ClearFlags(&g.NextWindowData)
		SetLastItemDataForWindow(window, TitleBarRect(window))
	}

	if !(flags & ImGuiWindowFlags_.ImGuiWindowFlags_DockNodeHost) && !window.SkipRefresh { PushClipRect(window.InnerClipRect.Min, window.InnerClipRect.Max, true) }

	// Clear 'accessed' flag last thing (After PushClipRect which will set the flag. We want the flag to stay false when the default "Debug" window is unused)
	window.WriteAccessed = false
	post_incr(&window.BeginCount)

	// Update visibility
	if first_begin_of_the_frame && !window.SkipRefresh {
		// When we are about to select this tab (which will only be visible on the _next frame_), flag it with a non-zero HiddenFramesCannotSkipItems.
		// This will have the important effect of actually returning true in Begin() and not setting SkipItems, allowing an earlier submission of the window contents.
		// This is analogous to regular windows being hidden from one frame.
		// It is especially important as e.g. nested TabBars would otherwise generate flicker in the form of one empty frame, or focus requests won't be processed.
		if window.DockIsActive && !window.DockTabIsVisible {
			if window.LastFrameJustFocused == g.FrameCount { window.HiddenFramesCannotSkipItems = 1 }
			else { window.HiddenFramesCanSkipItems = 1 }
		}

		if (flags & ImGuiWindowFlags_.ImGuiWindowFlags_ChildWindow) && !(flags & ImGuiWindowFlags_.ImGuiWindowFlags_ChildMenu) {
			// Child window can be out of sight and have "negative" clip windows.
			// Mark them as collapsed so commands are skipped earlier (we can't manually collapse them because they have no title bar).
			IM_ASSERT((flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoTitleBar) != 0 || window.DockIsActive)
			nav_request : bool = (window.ChildFlags & ImGuiChildFlags_.ImGuiChildFlags_NavFlattened) && (g.NavAnyRequest && g.NavWindow && g.NavWindow.RootWindowForNav == window.RootWindowForNav)
			if !g.LogEnabled && !nav_request { if window.OuterRectClipped.Min.x >= window.OuterRectClipped.Max.x || window.OuterRectClipped.Min.y >= window.OuterRectClipped.Max.y {
	if window.AutoFitFramesX > 0 || window.AutoFitFramesY > 0 { window.HiddenFramesCannotSkipItems = 1 }
	else { window.HiddenFramesCanSkipItems = 1 }
} }

			// Hide along with parent or if parent is collapsed
			if parent_window && (parent_window.Collapsed || parent_window.HiddenFramesCanSkipItems > 0) { window.HiddenFramesCanSkipItems = 1 }
			if parent_window && (parent_window.Collapsed || parent_window.HiddenFramesCannotSkipItems > 0) { window.HiddenFramesCannotSkipItems = 1 }
		}

		// Don't render if style alpha is 0.0 at the time of Begin(). This is arbitrary and inconsistent but has been there for a long while (may remove at some point)
		if style.Alpha <= 0.0 { window.HiddenFramesCanSkipItems = 1 }

		// Update the Hidden flag
		hidden_regular : bool = (window.HiddenFramesCanSkipItems > 0) || (window.HiddenFramesCannotSkipItems > 0)
		window.Hidden = hidden_regular || (window.HiddenFramesForRenderOnly > 0)

		// Disable inputs for requested number of frames
		if window.DisableInputsFrames > 0 {
			post_decr(&window.DisableInputsFrames)
			window.Flags |= ImGuiWindowFlags_.ImGuiWindowFlags_NoInputs
		}

		// Update the SkipItems flag, used to early out of all items functions (no layout required)
		skip_items : bool = false
		if window.Collapsed || !window.Active || hidden_regular { if window.AutoFitFramesX <= 0 && window.AutoFitFramesY <= 0 && window.HiddenFramesCannotSkipItems <= 0 { skip_items = true } }
		window.SkipItems = skip_items

		// Restore NavLayersActiveMaskNext to previous value when not visible, so a CTRL+Tab back can use a safe value.
		if window.SkipItems { window.DC.NavLayersActiveMaskNext = window.DC.NavLayersActiveMask }

		// Sanity check: there are two spots which can set Appearing = true
		// - when 'window_just_activated_by_user' is set -> HiddenFramesCannotSkipItems is set -> SkipItems always false
		// - in BeginDocked() path when DockNodeIsVisible == DockTabIsVisible == true -> hidden _should_ be all zero // FIXME: Not formally proven, hence the assert.
		if window.SkipItems && !window.Appearing {
			// Please report on GitHub if this triggers: https://github.com/ocornut/imgui/issues/4177
			IM_ASSERT(window.Appearing == false)
		}
	}
	else if first_begin_of_the_frame {
		// Skip refresh mode
		window.SkipItems = true
	}

	// [DEBUG] io.ConfigDebugBeginReturnValue override return value to test Begin/End and BeginChild/EndChild behaviors.
	// (The implicit fallback window is NOT automatically ended allowing it to always be able to receive commands without crashing)
	when ! defined ( IMGUI_DISABLE_DEBUG_TOOLS ) {
	if !window.IsFallbackWindow { if (g.IO.ConfigDebugBeginReturnValueOnce && window_just_created) || (g.IO.ConfigDebugBeginReturnValueLoop && g.DebugBeginReturnValueCullDepth == g.CurrentWindowStack.Size) {
	if window.AutoFitFramesX > 0 { post_incr(&window.AutoFitFramesX) }
	if window.AutoFitFramesY > 0 { post_incr(&window.AutoFitFramesY) }
	return false
} }
	} // preproc endif

	return !window.SkipItems
}

SetLastItemDataForWindow :: proc(window : ^ImGuiWindow, rect : ^ImRect)
{
	g : ^ImGuiContext = GImGui^
	if window.DockIsActive { SetLastItemData(window.MoveId, g.CurrentItemFlags, window.DockTabItemStatusFlags, window.DockTabItemRect) }
	else { SetLastItemData(window.MoveId, g.CurrentItemFlags, IsMouseHoveringRect(rect.Min, rect.Max, false) ? ImGuiItemStatusFlags_.ImGuiItemStatusFlags_HoveredRect : 0, rect) }
}

End :: proc()
{
	g : ^ImGuiContext = GImGui^
	window : ^ImGuiWindow = g.CurrentWindow

	// Error checking: verify that user hasn't called End() too many times!
	if g.CurrentWindowStack.Size <= 1 && g.WithinFrameScopeWithImplicitWindow {
		IM_ASSERT_USER_ERROR(g.CurrentWindowStack.Size > 1, "Calling End() too many times!")
		return
	}
	window_stack_data : ^ImGuiWindowStackData = back(&g.CurrentWindowStack)

	// Error checking: verify that user doesn't directly call End() on a child window.
	if (window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_ChildWindow) && !(window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_DockNodeHost) && !window.DockIsActive { IM_ASSERT_USER_ERROR(g.WithinEndChildID == window.ID, "Must call EndChild() and not End()!") }

	// Close anything that is open
	if window.DC.CurrentColumns { EndColumns() }
	if !(window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_DockNodeHost) && !window.SkipRefresh {
		// Pop inner window clip rectanglePopClipRect()
	}
	PopFocusScope()
	if window_stack_data.DisabledOverrideReenable && window.RootWindow == window { EndDisabledOverrideReenable() }

	if window.SkipRefresh {
		IM_ASSERT(window.DrawList == nil)
		window.DrawList = &window.DrawListInst
	}

	// Stop logging
	if g.LogWindow == window {
		// FIXME: add more options for scope of loggingLogFinish()
	}

	if window.DC.IsSetPos { ErrorCheckUsingSetCursorPosToExtendParentBoundaries() }

	// Docking: report contents sizes to parent to allow for auto-resize
	if window.DockNode && window.DockTabIsVisible { if host_window : ^ImGuiWindow = window.DockNode.HostWindow; host_window {
	// FIXME-DOCKhost_window.DC.CursorMaxPos = window.DC.CursorMaxPos + window.WindowPadding - host_window.WindowPadding
} }

	// Pop from window stack
	g.LastItemData = window_stack_data.ParentLastItemDataBackup
	if window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_ChildMenu { post_decr(&g.BeginMenuDepth) }
	if window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_Popup { pop_back(&g.BeginPopupStack) }

	// Error handling, state recovery
	if g.IO.ConfigErrorRecovery { ErrorRecoveryTryToRecoverWindowState(&window_stack_data.StackSizesInBegin) }

	pop_back(&g.CurrentWindowStack)
	SetCurrentWindow(g.CurrentWindowStack.Size == 0 ? nil : back(&g.CurrentWindowStack).Window)
	if g.CurrentWindow { SetCurrentViewport(g.CurrentWindow, g.CurrentWindow.Viewport) }
}

// Fonts, drawing
// Important: this alone doesn't alter current ImDrawList state. This is called by PushFont/PopFont only.
SetCurrentFont :: proc(font : ^ImFont)
{
	g : ^ImGuiContext = GImGui^
	IM_ASSERT(font && IsLoaded(font)); // Font Atlas not created. Did you call io.Fonts->GetTexDataAsRGBA32 / GetTexDataAsAlpha8 ?
	IM_ASSERT(font.Scale > 0.0)
	g.Font = font
	g.FontBaseSize = ImMax(1.0, g.IO.FontGlobalScale * g.Font.FontSize * g.Font.Scale)
	g.FontSize = g.CurrentWindow ? CalcFontSize(g.CurrentWindow) : 0.0
	g.FontScale = g.FontSize / g.Font.FontSize

	atlas : ^ImFontAtlas = g.Font.ContainerAtlas
	g.DrawListSharedData.TexUvWhitePixel = atlas.TexUvWhitePixel
	g.DrawListSharedData.TexUvLines = atlas.TexUvLines
	g.DrawListSharedData.Font = g.Font
	g.DrawListSharedData.FontSize = g.FontSize
	g.DrawListSharedData.FontScale = g.FontScale
}

// Parameters stacks (shared)
// use NULL as a shortcut to push default font
// Use ImDrawList::_SetTextureID(), making our shared g.FontStack[] authorative against window-local ImDrawList.
// - Whereas ImDrawList::PushTextureID()/PopTextureID() is not to be used across Begin() calls.
// - Note that we don't propagate current texture id when e.g. Begin()-ing into a new window, we never really did...
//   - Some code paths never really fully worked with multiple atlas textures.
//   - The right-ish solution may be to remove _SetTextureID() and make AddText/RenderText lazily call PushTextureID()/PopTextureID()
//     the same way AddImage() does, but then all other primitives would also need to? I don't think we should tackle this problem
//     because we have a concrete need and a test bed for multiple atlas textures.
PushFont :: proc(font : ^ImFont)
{
	g : ^ImGuiContext = GImGui^
	if font == nil { font = GetDefaultFont() }
	push_back(&g.FontStack, font)
	SetCurrentFont(font)
	_SetTextureID(g.CurrentWindow.DrawList, font.ContainerAtlas.TexID)
}

PopFont :: proc()
{
	g : ^ImGuiContext = GImGui^
	if g.FontStack.Size <= 0 {
		IM_ASSERT_USER_ERROR(0, "Calling PopFont() too many times!")
		return
	}
	pop_back(&g.FontStack)
	font : ^ImFont = g.FontStack.Size == 0 ? GetDefaultFont() : back(&g.FontStack)
	SetCurrentFont(font)
	_SetTextureID(g.CurrentWindow.DrawList, font.ContainerAtlas.TexID)
}

// modify specified shared item flag, e.g. PushItemFlag(ImGuiItemFlags_NoTabStop, true)
PushItemFlag :: proc(option : ImGuiItemFlags, enabled : bool)
{
	g : ^ImGuiContext = GImGui^
	item_flags : ImGuiItemFlags = g.CurrentItemFlags
	IM_ASSERT(item_flags == back(&g.ItemFlagsStack))
	if enabled { item_flags |= option }
	else { item_flags &= !option }
	g.CurrentItemFlags = item_flags
	push_back(&g.ItemFlagsStack, item_flags)
}

PopItemFlag :: proc()
{
	g : ^ImGuiContext = GImGui^
	if g.ItemFlagsStack.Size <= 1 {
		IM_ASSERT_USER_ERROR(0, "Calling PopItemFlag() too many times!")
		return
	}
	pop_back(&g.ItemFlagsStack)
	g.CurrentItemFlags = back(&g.ItemFlagsStack)
}

// Disabling [BETA API]
// - Disable all user interactions and dim items visuals (applying style.DisabledAlpha over current colors)
// - Those can be nested but it cannot be used to enable an already disabled section (a single BeginDisabled(true) in the stack is enough to keep everything disabled)
// - Tooltips windows by exception are opted out of disabling.
// - BeginDisabled(false)/EndDisabled() essentially does nothing but is provided to facilitate use of boolean expressions (as a micro-optimization: if you have tens of thousands of BeginDisabled(false)/EndDisabled() pairs, you might want to reformulate your code to avoid making those calls)
// BeginDisabled()/EndDisabled()
// - Those can be nested but it cannot be used to enable an already disabled section (a single BeginDisabled(true) in the stack is enough to keep everything disabled)
// - Visually this is currently altering alpha, but it is expected that in a future styling system this would work differently.
// - Feedback welcome at https://github.com/ocornut/imgui/issues/211
// - BeginDisabled(false)/EndDisabled() essentially does nothing but is provided to facilitate use of boolean expressions.
//   (as a micro-optimization: if you have tens of thousands of BeginDisabled(false)/EndDisabled() pairs, you might want to reformulate your code to avoid making those calls)
// - Note: mixing up BeginDisabled() and PushItemFlag(ImGuiItemFlags_Disabled) is currently NOT SUPPORTED.
BeginDisabled :: proc(disabled : bool)
{
	g : ^ImGuiContext = GImGui^
	was_disabled : bool = (g.CurrentItemFlags & ImGuiItemFlagsPrivate_.ImGuiItemFlags_Disabled) != 0
	if !was_disabled && disabled {
		g.DisabledAlphaBackup = g.Style.Alpha
		g.Style.Alpha *= g.Style.DisabledAlpha; // PushStyleVar(ImGuiStyleVar_Alpha, g.Style.Alpha * g.Style.DisabledAlpha);
	}
	if was_disabled || disabled { g.CurrentItemFlags |= ImGuiItemFlagsPrivate_.ImGuiItemFlags_Disabled }
	push_back(&g.ItemFlagsStack, g.CurrentItemFlags); // FIXME-OPT: can we simply skip this and use DisabledStackSize?
	post_incr(&g.DisabledStackSize)
}

EndDisabled :: proc()
{
	g : ^ImGuiContext = GImGui^
	if g.DisabledStackSize <= 0 {
		IM_ASSERT_USER_ERROR(0, "Calling EndDisabled() too many times!")
		return
	}
	post_decr(&g.DisabledStackSize)
	was_disabled : bool = (g.CurrentItemFlags & ImGuiItemFlagsPrivate_.ImGuiItemFlags_Disabled) != 0
	//PopItemFlag();
	pop_back(&g.ItemFlagsStack)
	g.CurrentItemFlags = back(&g.ItemFlagsStack)
	if was_disabled && (g.CurrentItemFlags & ImGuiItemFlagsPrivate_.ImGuiItemFlags_Disabled) == 0 {
		//PopStyleVar();
		g.Style.Alpha = g.DisabledAlphaBackup
	}
}

// Could have been called BeginDisabledDisable() but it didn't want to be award nominated for most awkward function name.
// Ideally we would use a shared e.g. BeginDisabled()->BeginDisabledEx() but earlier needs to be optimal.
// The whole code for this is awkward, will reevaluate if we find a way to implement SetNextItemDisabled().
BeginDisabledOverrideReenable :: proc()
{
	g : ^ImGuiContext = GImGui^
	IM_ASSERT(g.CurrentItemFlags & ImGuiItemFlagsPrivate_.ImGuiItemFlags_Disabled)
	g.Style.Alpha = g.DisabledAlphaBackup
	g.CurrentItemFlags &= !ImGuiItemFlagsPrivate_.ImGuiItemFlags_Disabled
	push_back(&g.ItemFlagsStack, g.CurrentItemFlags)
	post_incr(&g.DisabledStackSize)
}

EndDisabledOverrideReenable :: proc()
{
	g : ^ImGuiContext = GImGui^
	post_decr(&g.DisabledStackSize)
	IM_ASSERT(g.DisabledStackSize > 0)
	pop_back(&g.ItemFlagsStack)
	g.CurrentItemFlags = back(&g.ItemFlagsStack)
	g.Style.Alpha = g.DisabledAlphaBackup * g.Style.DisabledAlpha
}

// push word-wrapping position for Text*() commands. < 0.0f: no wrapping; 0.0f: wrap to end of window (or column); > 0.0f: wrap at 'wrap_pos_x' position in window local space
PushTextWrapPos :: proc(wrap_pos_x : f32)
{
	g : ^ImGuiContext = GImGui^
	window : ^ImGuiWindow = g.CurrentWindow
	push_back(&window.DC.TextWrapPosStack, window.DC.TextWrapPos)
	window.DC.TextWrapPos = wrap_pos_x
}

PopTextWrapPos :: proc()
{
	g : ^ImGuiContext = GImGui^
	window : ^ImGuiWindow = g.CurrentWindow
	if window.DC.TextWrapPosStack.Size <= 0 {
		IM_ASSERT_USER_ERROR(0, "Calling PopTextWrapPos() too many times!")
		return
	}
	window.DC.TextWrapPos = back(&window.DC.TextWrapPosStack)
	pop_back(&window.DC.TextWrapPosStack)
}

GetCombinedRootWindow :: proc(window : ^ImGuiWindow, popup_hierarchy : bool, dock_hierarchy : bool) -> ^ImGuiWindow
{
	last_window : ^ImGuiWindow = nil
	for last_window != window {
		last_window = window
		window = window.RootWindow
		if popup_hierarchy { window = window.RootWindowPopupTree }
		if dock_hierarchy { window = window.RootWindowDockTree }
	}

	return window
}

IsWindowChildOf :: proc(window : ^ImGuiWindow, potential_parent : ^ImGuiWindow, popup_hierarchy : bool, dock_hierarchy : bool) -> bool
{
	window_root : ^ImGuiWindow = GetCombinedRootWindow(window, popup_hierarchy, dock_hierarchy)
	if window_root == potential_parent { return true }
	for window != nil {
		if window == potential_parent { return true }
		if window == window_root {
			// end of chainreturn false
		}
		window = window.ParentWindow
	}

	return false
}

IsWindowWithinBeginStackOf :: proc(window : ^ImGuiWindow, potential_parent : ^ImGuiWindow) -> bool
{
	if window.RootWindow == potential_parent { return true }
	for window != nil {
		if window == potential_parent { return true }
		window = window.ParentWindowInBeginStack
	}

	return false
}

IsWindowAbove :: proc(potential_above : ^ImGuiWindow, potential_below : ^ImGuiWindow) -> bool
{
	g : ^ImGuiContext = GImGui^

	// It would be saner to ensure that display layer is always reflected in the g.Windows[] order, which would likely requires altering all manipulations of that array
	display_layer_delta : i32 = GetWindowDisplayLayer(potential_above) - GetWindowDisplayLayer(potential_below)
	if display_layer_delta != 0 { return display_layer_delta > 0 }

	for i : i32 = g.Windows.Size - 1; i >= 0; post_decr(&i) {
		candidate_window : ^ImGuiWindow = g.Windows[i]
		if candidate_window == potential_above { return true }
		if candidate_window == potential_below { return false }
	}

	return false
}

// is current window hovered and hoverable (e.g. not blocked by a popup/modal)? See ImGuiHoveredFlags_ for options. IMPORTANT: If you are trying to check whether your mouse should be dispatched to Dear ImGui or to your underlying app, you should not use this function! Use the 'io.WantCaptureMouse' boolean for that! Refer to FAQ entry "How can I tell whether to dispatch mouse/keyboard to Dear ImGui or my application?" for details.
// Is current window hovered and hoverable (e.g. not blocked by a popup/modal)? See ImGuiHoveredFlags_ for options.
// IMPORTANT: If you are trying to check whether your mouse should be dispatched to Dear ImGui or to your underlying app,
// you should not use this function! Use the 'io.WantCaptureMouse' boolean for that!
// Refer to FAQ entry "How can I tell whether to dispatch mouse/keyboard to Dear ImGui or my application?" for details.
IsWindowHovered :: proc(flags : ImGuiHoveredFlags) -> bool
{
	g : ^ImGuiContext = GImGui^
	IM_ASSERT_USER_ERROR((flags & !ImGuiHoveredFlagsPrivate_.ImGuiHoveredFlags_AllowedMaskForIsWindowHovered) == 0, "Invalid flags for IsWindowHovered()!")

	ref_window : ^ImGuiWindow = g.HoveredWindow
	cur_window : ^ImGuiWindow = g.CurrentWindow
	if ref_window == nil { return false }

	if (flags & ImGuiHoveredFlags_.ImGuiHoveredFlags_AnyWindow) == 0 {
		IM_ASSERT(cur_window); // Not inside a Begin()/End()
		popup_hierarchy : bool = (flags & ImGuiHoveredFlags_.ImGuiHoveredFlags_NoPopupHierarchy) == 0
		dock_hierarchy : bool = (flags & ImGuiHoveredFlags_.ImGuiHoveredFlags_DockHierarchy) != 0
		if ImGuiHoveredFlags_RootWindow : ^flags; ImGuiHoveredFlags_RootWindow { cur_window = GetCombinedRootWindow(cur_window, popup_hierarchy, dock_hierarchy) }

		result : bool
		if ImGuiHoveredFlags_ChildWindows : ^flags; ImGuiHoveredFlags_ChildWindows { result = IsWindowChildOf(ref_window, cur_window, popup_hierarchy, dock_hierarchy) }
		else { result = (ref_window == cur_window) }
		if !result { return false }
	}

	if !IsWindowContentHoverable(ref_window, flags) { return false }
	if !(flags & ImGuiHoveredFlags_.ImGuiHoveredFlags_AllowWhenBlockedByActiveItem) { if g.ActiveId != 0 && !g.ActiveIdAllowOverlap && g.ActiveId != ref_window.MoveId { return false } }

	// When changing hovered window we requires a bit of stationary delay before activating hover timer.
	// FIXME: We don't support delay other than stationary one for now, other delay would need a way
	// to fulfill the possibility that multiple IsWindowHovered() with varying flag could return true
	// for different windows of the hierarchy. Possibly need a Hash(Current+Flags) ==> (Timer) cache.
	// We can implement this for _Stationary because the data is linked to HoveredWindow rather than CurrentWindow.
	if ImGuiHoveredFlags_ForTooltip : ^flags; ImGuiHoveredFlags_ForTooltip { flags = ApplyHoverFlagsForTooltip(flags, g.Style.HoverFlagsForTooltipMouse) }
	if (flags & ImGuiHoveredFlags_.ImGuiHoveredFlags_Stationary) != 0 && g.HoverWindowUnlockedStationaryId != ref_window.ID { return false }

	return true
}

GetWindowDockID :: proc() -> ImGuiID
{
	g : ^ImGuiContext = GImGui^
	return g.CurrentWindow.DockId
}

// is current window docked into another window?
IsWindowDocked :: proc() -> bool
{
	g : ^ImGuiContext = GImGui^
	return g.CurrentWindow.DockIsActive
}

// get current window width (IT IS UNLIKELY YOU EVER NEED TO USE THIS). Shortcut for GetWindowSize().x.
GetWindowWidth :: proc() -> f32
{
	window : ^ImGuiWindow = GImGui.CurrentWindow
	return window.Size.x
}

// get current window height (IT IS UNLIKELY YOU EVER NEED TO USE THIS). Shortcut for GetWindowSize().y.
GetWindowHeight :: proc() -> f32
{
	window : ^ImGuiWindow = GImGui.CurrentWindow
	return window.Size.y
}

// get current window position in screen space (IT IS UNLIKELY YOU EVER NEED TO USE THIS. Consider always using GetCursorScreenPos() and GetContentRegionAvail() instead)
GetWindowPos :: proc() -> ImVec2
{
	g : ^ImGuiContext = GImGui^
	window : ^ImGuiWindow = g.CurrentWindow
	return window.Pos
}

// (not recommended) set current window position - call within Begin()/End(). prefer using SetNextWindowPos(), as this may incur tearing and side-effects.
// set named window position.
SetWindowPos_0 :: proc(window : ^ImGuiWindow, pos : ^ImVec2, cond : ImGuiCond)
{
	// Test condition (NB: bit 0 is always true) and clear flags for next time
	if cond && (window.SetWindowPosAllowFlags & cond) == 0 { return }

	IM_ASSERT(cond == 0 || ImIsPowerOfTwo(cond)); // Make sure the user doesn't attempt to combine multiple condition flags.
	window.SetWindowPosAllowFlags &= !(ImGuiCond_.ImGuiCond_Once | ImGuiCond_.ImGuiCond_FirstUseEver | ImGuiCond_.ImGuiCond_Appearing)
	window.SetWindowPosVal = ImVec2(FLT_MAX, FLT_MAX)

	// Set
	old_pos : ImVec2 = window.Pos
	window.Pos = ImTrunc(pos)
	offset : ImVec2 = window.Pos - old_pos
	if offset.x == 0.0 && offset.y == 0.0 { return }
	MarkIniSettingsDirty(window)
	// FIXME: share code with TranslateWindow(), need to confirm whether the 3 rect modified by TranslateWindow() are desirable here.
	window.DC.CursorPos += offset; // As we happen to move the window while it is being appended to (which is a bad idea - will smear) let's at least offset the cursor
	window.DC.CursorMaxPos += offset; // And more importantly we need to offset CursorMaxPos/CursorStartPos this so ContentSize calculation doesn't get affected.
	window.DC.IdealMaxPos += offset
	window.DC.CursorStartPos += offset
}

// (not recommended) set current window position - call within Begin()/End(). prefer using SetNextWindowPos(), as this may incur tearing and side-effects.
// set named window position.
SetWindowPos_1 :: proc(pos : ^ImVec2, cond : ImGuiCond)
{
	window : ^ImGuiWindow = GetCurrentWindowRead()
	SetWindowPos(window, pos, cond)
}

// (not recommended) set current window position - call within Begin()/End(). prefer using SetNextWindowPos(), as this may incur tearing and side-effects.
// set named window position.
SetWindowPos_2 :: proc(name : ^u8, pos : ^ImVec2, cond : ImGuiCond)
{
	if window : ^ImGuiWindow = FindWindowByName(name); window { SetWindowPos(window, pos, cond) }
}

// get current window size (IT IS UNLIKELY YOU EVER NEED TO USE THIS. Consider always using GetCursorScreenPos() and GetContentRegionAvail() instead)
GetWindowSize :: proc() -> ImVec2
{
	window : ^ImGuiWindow = GetCurrentWindowRead()
	return window.Size
}

// (not recommended) set current window size - call within Begin()/End(). set to ImVec2(0, 0) to force an auto-fit. prefer using SetNextWindowSize(), as this may incur tearing and minor side-effects.
// set named window size. set axis to 0.0f to force an auto-fit on this axis.
SetWindowSize_0 :: proc(window : ^ImGuiWindow, size : ^ImVec2, cond : ImGuiCond)
{
	// Test condition (NB: bit 0 is always true) and clear flags for next time
	if cond && (window.SetWindowSizeAllowFlags & cond) == 0 { return }

	IM_ASSERT(cond == 0 || ImIsPowerOfTwo(cond)); // Make sure the user doesn't attempt to combine multiple condition flags.
	window.SetWindowSizeAllowFlags &= !(ImGuiCond_.ImGuiCond_Once | ImGuiCond_.ImGuiCond_FirstUseEver | ImGuiCond_.ImGuiCond_Appearing)

	// Enable auto-fit (not done in BeginChild() path unless appearing or combined with ImGuiChildFlags_AlwaysAutoResize)
	if (window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_ChildWindow) == 0 || window.Appearing || (window.ChildFlags & ImGuiChildFlags_.ImGuiChildFlags_AlwaysAutoResize) != 0 { window.AutoFitFramesX = (size.x <= 0.0) ? 2 : 0 }
	if (window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_ChildWindow) == 0 || window.Appearing || (window.ChildFlags & ImGuiChildFlags_.ImGuiChildFlags_AlwaysAutoResize) != 0 { window.AutoFitFramesY = (size.y <= 0.0) ? 2 : 0 }

	// Set
	old_size : ImVec2 = window.SizeFull
	if size.x <= 0.0 { window.AutoFitOnlyGrows = false }
	else { window.SizeFull.x = IM_TRUNC(size.x) }
	if size.y <= 0.0 { window.AutoFitOnlyGrows = false }
	else { window.SizeFull.y = IM_TRUNC(size.y) }
	if old_size.x != window.SizeFull.x || old_size.y != window.SizeFull.y { MarkIniSettingsDirty(window) }
}

// (not recommended) set current window size - call within Begin()/End(). set to ImVec2(0, 0) to force an auto-fit. prefer using SetNextWindowSize(), as this may incur tearing and minor side-effects.
// set named window size. set axis to 0.0f to force an auto-fit on this axis.
SetWindowSize_1 :: proc(size : ^ImVec2, cond : ImGuiCond)
{
	SetWindowSize(GImGui.CurrentWindow, size, cond)
}

// (not recommended) set current window size - call within Begin()/End(). set to ImVec2(0, 0) to force an auto-fit. prefer using SetNextWindowSize(), as this may incur tearing and minor side-effects.
// set named window size. set axis to 0.0f to force an auto-fit on this axis.
SetWindowSize_2 :: proc(name : ^u8, size : ^ImVec2, cond : ImGuiCond)
{
	if window : ^ImGuiWindow = FindWindowByName(name); window { SetWindowSize(window, size, cond) }
}

// (not recommended) set current window collapsed state. prefer using SetNextWindowCollapsed().
// set named window collapsed state
SetWindowCollapsed_0 :: proc(window : ^ImGuiWindow, collapsed : bool, cond : ImGuiCond)
{
	// Test condition (NB: bit 0 is always true) and clear flags for next time
	if cond && (window.SetWindowCollapsedAllowFlags & cond) == 0 { return }
	window.SetWindowCollapsedAllowFlags &= !(ImGuiCond_.ImGuiCond_Once | ImGuiCond_.ImGuiCond_FirstUseEver | ImGuiCond_.ImGuiCond_Appearing)

	// Set
	window.Collapsed = collapsed
}

SetWindowHitTestHole :: proc(window : ^ImGuiWindow, pos : ^ImVec2, size : ^ImVec2)
{
	IM_ASSERT(window.HitTestHoleSize.x == 0); // We don't support multiple holes/hit test filters
	window.HitTestHoleSize = ImVec2ih(size)
	window.HitTestHoleOffset = ImVec2ih(pos - window.Pos)
}

SetWindowHiddenAndSkipItemsForCurrentFrame :: proc(window : ^ImGuiWindow)
{
	window.SkipItems = true; window.Hidden = window.SkipItems
	window.HiddenFramesCanSkipItems = 1
}

// (not recommended) set current window collapsed state. prefer using SetNextWindowCollapsed().
// set named window collapsed state
SetWindowCollapsed_1 :: proc(collapsed : bool, cond : ImGuiCond)
{
	SetWindowCollapsed(GImGui.CurrentWindow, collapsed, cond)
}

IsWindowCollapsed :: proc() -> bool
{
	window : ^ImGuiWindow = GetCurrentWindowRead()
	return window.Collapsed
}

// Windows Utilities
// - 'current window' = the window we are appending into while inside a Begin()/End() block. 'next window' = next window we will Begin() into.
IsWindowAppearing :: proc() -> bool
{
	window : ^ImGuiWindow = GetCurrentWindowRead()
	return window.Appearing
}

// (not recommended) set current window collapsed state. prefer using SetNextWindowCollapsed().
// set named window collapsed state
SetWindowCollapsed_2 :: proc(name : ^u8, collapsed : bool, cond : ImGuiCond)
{
	if window : ^ImGuiWindow = FindWindowByName(name); window { SetWindowCollapsed(window, collapsed, cond) }
}

// Window manipulation
// - Prefer using SetNextXXX functions (before Begin) rather that SetXXX functions (after Begin).
// set next window position. call before Begin(). use pivot=(0.5f,0.5f) to center on given point, etc.
SetNextWindowPos :: proc(pos : ^ImVec2, cond : ImGuiCond, pivot : ^ImVec2)
{
	g : ^ImGuiContext = GImGui^
	IM_ASSERT(cond == 0 || ImIsPowerOfTwo(cond)); // Make sure the user doesn't attempt to combine multiple condition flags.
	g.NextWindowData.Flags |= ImGuiNextWindowDataFlags_.ImGuiNextWindowDataFlags_HasPos
	g.NextWindowData.PosVal = pos
	g.NextWindowData.PosPivotVal = pivot
	g.NextWindowData.PosCond = cond ? cond : ImGuiCond_.ImGuiCond_Always
	g.NextWindowData.PosUndock = true
}

// set next window size. set axis to 0.0f to force an auto-fit on this axis. call before Begin()
SetNextWindowSize :: proc(size : ^ImVec2, cond : ImGuiCond)
{
	g : ^ImGuiContext = GImGui^
	IM_ASSERT(cond == 0 || ImIsPowerOfTwo(cond)); // Make sure the user doesn't attempt to combine multiple condition flags.
	g.NextWindowData.Flags |= ImGuiNextWindowDataFlags_.ImGuiNextWindowDataFlags_HasSize
	g.NextWindowData.SizeVal = size
	g.NextWindowData.SizeCond = cond ? cond : ImGuiCond_.ImGuiCond_Always
}

// set next window size limits. use 0.0f or FLT_MAX if you don't want limits. Use -1 for both min and max of same axis to preserve current size (which itself is a constraint). Use callback to apply non-trivial programmatic constraints.
// For each axis:
// - Use 0.0f as min or FLT_MAX as max if you don't want limits, e.g. size_min = (500.0f, 0.0f), size_max = (FLT_MAX, FLT_MAX) sets a minimum width.
// - Use -1 for both min and max of same axis to preserve current size which itself is a constraint.
// - See "Demo->Examples->Constrained-resizing window" for examples.
SetNextWindowSizeConstraints :: proc(size_min : ^ImVec2, size_max : ^ImVec2, custom_callback : ImGuiSizeCallback, custom_callback_user_data : rawptr)
{
	g : ^ImGuiContext = GImGui^
	g.NextWindowData.Flags |= ImGuiNextWindowDataFlags_.ImGuiNextWindowDataFlags_HasSizeConstraint
	g.NextWindowData.SizeConstraintRect = ImRect(size_min, size_max)
	g.NextWindowData.SizeCallback = custom_callback
	g.NextWindowData.SizeCallbackUserData = custom_callback_user_data
}

// set next window content size (~ scrollable client area, which enforce the range of scrollbars). Not including window decorations (title bar, menu bar, etc.) nor WindowPadding. set an axis to 0.0f to leave it automatic. call before Begin()
// Content size = inner scrollable rectangle, padded with WindowPadding.
// SetNextWindowContentSize(ImVec2(100,100) + ImGuiWindowFlags_AlwaysAutoResize will always allow submitting a 100x100 item.
SetNextWindowContentSize :: proc(size : ^ImVec2)
{
	g : ^ImGuiContext = GImGui^
	g.NextWindowData.Flags |= ImGuiNextWindowDataFlags_.ImGuiNextWindowDataFlags_HasContentSize
	g.NextWindowData.ContentSizeVal = ImTrunc(size)
}

// set next window scrolling value (use < 0.0f to not affect a given axis).
SetNextWindowScroll :: proc(scroll : ^ImVec2)
{
	g : ^ImGuiContext = GImGui^
	g.NextWindowData.Flags |= ImGuiNextWindowDataFlags_.ImGuiNextWindowDataFlags_HasScroll
	g.NextWindowData.ScrollVal = scroll
}

// set next window collapsed state. call before Begin()
SetNextWindowCollapsed :: proc(collapsed : bool, cond : ImGuiCond)
{
	g : ^ImGuiContext = GImGui^
	IM_ASSERT(cond == 0 || ImIsPowerOfTwo(cond)); // Make sure the user doesn't attempt to combine multiple condition flags.
	g.NextWindowData.Flags |= ImGuiNextWindowDataFlags_.ImGuiNextWindowDataFlags_HasCollapsed
	g.NextWindowData.CollapsedVal = collapsed
	g.NextWindowData.CollapsedCond = cond ? cond : ImGuiCond_.ImGuiCond_Always
}

// set next window background color alpha. helper to easily override the Alpha component of ImGuiCol_WindowBg/ChildBg/PopupBg. you may also use ImGuiWindowFlags_NoBackground.
SetNextWindowBgAlpha :: proc(alpha : f32)
{
	g : ^ImGuiContext = GImGui^
	g.NextWindowData.Flags |= ImGuiNextWindowDataFlags_.ImGuiNextWindowDataFlags_HasBgAlpha
	g.NextWindowData.BgAlphaVal = alpha
}

// set next window viewport
SetNextWindowViewport :: proc(id : ImGuiID)
{
	g : ^ImGuiContext = GImGui^
	g.NextWindowData.Flags |= ImGuiNextWindowDataFlags_.ImGuiNextWindowDataFlags_HasViewport
	g.NextWindowData.ViewportId = id
}

// set next window dock id
SetNextWindowDockID :: proc(id : ImGuiID, cond : ImGuiCond)
{
	g : ^ImGuiContext = GImGui^
	g.NextWindowData.Flags |= ImGuiNextWindowDataFlags_.ImGuiNextWindowDataFlags_HasDock
	g.NextWindowData.DockCond = cond ? cond : ImGuiCond_.ImGuiCond_Always
	g.NextWindowData.DockId = id
}

// set next window class (control docking compatibility + provide hints to platform backend via custom viewport flags and platform parent/child relationship)
SetNextWindowClass :: proc(window_class : ^ImGuiWindowClass)
{
	g : ^ImGuiContext = GImGui^
	IM_ASSERT((window_class.ViewportFlagsOverrideSet & window_class.ViewportFlagsOverrideClear) == 0); // Cannot set both set and clear for the same bit
	g.NextWindowData.Flags |= ImGuiNextWindowDataFlags_.ImGuiNextWindowDataFlags_HasWindowClass
	g.NextWindowData.WindowClass = window_class^
}

// Windows: Idle, Refresh Policies [EXPERIMENTAL]
// This is experimental and meant to be a toy for exploring a future/wider range of features.
SetNextWindowRefreshPolicy :: proc(flags : ImGuiWindowRefreshFlags)
{
	g : ^ImGuiContext = GImGui^
	g.NextWindowData.Flags |= ImGuiNextWindowDataFlags_.ImGuiNextWindowDataFlags_HasRefreshPolicy
	g.NextWindowData.RefreshFlagsVal = flags
}

// get draw list associated to the current window, to append your own drawing primitives
GetWindowDrawList :: proc() -> ^ImDrawList
{
	window : ^ImGuiWindow = GetCurrentWindow()
	return window.DrawList
}

// get DPI scale currently associated to the current window's viewport.
GetWindowDpiScale :: proc() -> f32
{
	g : ^ImGuiContext = GImGui^
	return g.CurrentDpiScale
}

// get viewport currently associated to the current window.
GetWindowViewport :: proc() -> ^ImGuiViewport
{
	g : ^ImGuiContext = GImGui^
	IM_ASSERT(g.CurrentViewport != nil && g.CurrentViewport == g.CurrentWindow.Viewport)
	return g.CurrentViewport
}

// Style read access
// - Use the ShowStyleEditor() function to interactively see/edit the colors.
// get current font
GetFont :: proc() -> ^ImFont
{
	return GImGui.Font
}

// get current font size (= height in pixels) of current font with current scale applied
GetFontSize :: proc() -> f32
{
	return GImGui.FontSize
}

// get UV coordinate for a white pixel, useful to draw custom shapes via the ImDrawList API
GetFontTexUvWhitePixel :: proc() -> ImVec2
{
	return GImGui.DrawListSharedData.TexUvWhitePixel
}

// [OBSOLETE] set font scale. Adjust IO.FontGlobalScale if you want to scale all windows. This is an old API! For correct scaling, prefer to reload font + rebuild ImFontAtlas + call style.ScaleAllSizes().
SetWindowFontScale :: proc(scale : f32)
{
	IM_ASSERT(scale > 0.0)
	g : ^ImGuiContext = GImGui^
	window : ^ImGuiWindow = GetCurrentWindow()
	window.FontWindowScale = scale
	g.DrawListSharedData.FontSize = CalcFontSize(window); g.FontSize = g.DrawListSharedData.FontSize
	g.DrawListSharedData.FontScale = g.FontSize / g.Font.FontSize; g.FontScale = g.DrawListSharedData.FontScale
}

// [EXPERIMENTAL] Focus Scope
// This is generally used to identify a unique input location (for e.g. a selection set)
// There is one per window (automatically set in Begin), but:
// - Selection patterns generally need to react (e.g. clear a selection) when landing on one item of the set.
//   So in order to identify a set multiple lists in same window may each need a focus scope.
//   If you imagine an hypothetical BeginSelectionGroup()/EndSelectionGroup() api, it would likely call PushFocusScope()/EndFocusScope()
// - Shortcut routing also use focus scope as a default location identifier if an owner is not provided.
// We don't use the ID Stack for this as it is common to want them separate.
PushFocusScope :: proc(id : ImGuiID)
{
	g : ^ImGuiContext = GImGui^
	data : ImGuiFocusScopeData
	data.ID = id
	data.WindowID = g.CurrentWindow.ID
	push_back(&g.FocusScopeStack, data)
	g.CurrentFocusScopeId = id
}

PopFocusScope :: proc()
{
	g : ^ImGuiContext = GImGui^
	if g.FocusScopeStack.Size <= g.StackSizesInBeginForCurrentWindow.SizeOfFocusScopeStack {
		IM_ASSERT_USER_ERROR(0, "Calling PopFocusScope() too many times!")
		return
	}
	pop_back(&g.FocusScopeStack)
	g.CurrentFocusScopeId = g.FocusScopeStack.Size ? back(&g.FocusScopeStack).ID : 0
}

SetNavFocusScope :: proc(focus_scope_id : ImGuiID)
{
	g : ^ImGuiContext = GImGui^
	g.NavFocusScopeId = focus_scope_id
	resize(&g.NavFocusRoute, 0); // Invalidate
	if focus_scope_id == 0 { return }
	IM_ASSERT(g.NavWindow != nil)

	// Store current path (in reverse order)
	if focus_scope_id == g.CurrentFocusScopeId {
		// Top of focus stack contains local focus scopes inside current window
		for n : i32 = g.FocusScopeStack.Size - 1; n >= 0 && g.FocusScopeStack.Data[n].WindowID == g.CurrentWindow.ID; post_decr(&n) { push_back(&g.NavFocusRoute, g.FocusScopeStack.Data[n]) }
	}
	else if focus_scope_id == g.NavWindow.NavRootFocusScopeId { push_back(&g.NavFocusRoute, {focus_scope_id, g.NavWindow.ID}) }
	else { return }

	// Then follow on manually set ParentWindowForFocusRoute field (#6798)
	for window : ^ImGuiWindow = g.NavWindow.ParentWindowForFocusRoute; window != nil; window = window.ParentWindowForFocusRoute { push_back(&g.NavFocusRoute, {window.NavRootFocusScopeId, window.ID}) }

	IM_ASSERT(g.NavFocusRoute.Size < 100); // Maximum depth is technically 251 as per CalcRoutingScore(): 254 - 3
}

// Focus/Activation
// This should be part of a larger set of API: FocusItem(offset = -1), FocusItemByID(id), ActivateItem(offset = -1), ActivateItemByID(id) etc. which are
// much harder to design and implement than expected. I have a couple of private branches on this matter but it's not simple. For now implementing the easy ones.
// Focus last item (no selection/activation).
// Focus = move navigation cursor, set scrolling, set focus window.
FocusItem :: proc()
{
	g : ^ImGuiContext = GImGui^
	window : ^ImGuiWindow = g.CurrentWindow
	IMGUI_DEBUG_LOG_FOCUS("FocusItem(0x%08x) in window \"%s\"\n", g.LastItemData.ID, window.Name)
	if g.DragDropActive || g.MovingWindow != nil {
		// FIXME: Opt-in flags for this?
		IMGUI_DEBUG_LOG_FOCUS("FocusItem() ignored while DragDropActive!\n")
		return
	}

	move_flags : ImGuiNavMoveFlags = ImGuiNavMoveFlags_.ImGuiNavMoveFlags_IsTabbing | ImGuiNavMoveFlags_.ImGuiNavMoveFlags_FocusApi | ImGuiNavMoveFlags_.ImGuiNavMoveFlags_NoSetNavCursorVisible | ImGuiNavMoveFlags_.ImGuiNavMoveFlags_NoSelect
	scroll_flags : ImGuiScrollFlags = window.Appearing ? ImGuiScrollFlags_.ImGuiScrollFlags_KeepVisibleEdgeX | ImGuiScrollFlags_.ImGuiScrollFlags_AlwaysCenterY : ImGuiScrollFlags_.ImGuiScrollFlags_KeepVisibleEdgeX | ImGuiScrollFlags_.ImGuiScrollFlags_KeepVisibleEdgeY
	SetNavWindow(window)
	NavMoveRequestSubmit(ImGuiDir.ImGuiDir_None, ImGuiDir.ImGuiDir_Up, move_flags, scroll_flags)
	NavMoveRequestResolveWithLastItem(&g.NavMoveResultLocal)
}

// Activate an item by ID (button, checkbox, tree node etc.). Activation is queued and processed on the next frame when the item is encountered again.
ActivateItemByID :: proc(id : ImGuiID)
{
	g : ^ImGuiContext = GImGui^
	g.NavNextActivateId = id
	g.NavNextActivateFlags = ImGuiActivateFlags_.ImGuiActivateFlags_None
}

// focus keyboard on the next widget. Use positive 'offset' to access sub components of a multiple component widget. Use -1 to access previous widget.
// Note: this will likely be called ActivateItem() once we rework our Focus/Activation system!
// But ActivateItem() should function without altering scroll/focus?
SetKeyboardFocusHere :: proc(offset : i32)
{
	g : ^ImGuiContext = GImGui^
	window : ^ImGuiWindow = g.CurrentWindow
	IM_ASSERT(offset >= -1); // -1 is allowed but not below
	IMGUI_DEBUG_LOG_FOCUS("SetKeyboardFocusHere(%d) in window \"%s\"\n", offset, window.Name)

	// It makes sense in the vast majority of cases to never interrupt a drag and drop.
	// When we refactor this function into ActivateItem() we may want to make this an option.
	// MovingWindow is protected from most user inputs using SetActiveIdUsingNavAndKeys(), but
	// is also automatically dropped in the event g.ActiveId is stolen.
	if g.DragDropActive || g.MovingWindow != nil {
		IMGUI_DEBUG_LOG_FOCUS("SetKeyboardFocusHere() ignored while DragDropActive!\n")
		return
	}

	SetNavWindow(window)

	move_flags : ImGuiNavMoveFlags = ImGuiNavMoveFlags_.ImGuiNavMoveFlags_IsTabbing | ImGuiNavMoveFlags_.ImGuiNavMoveFlags_Activate | ImGuiNavMoveFlags_.ImGuiNavMoveFlags_FocusApi | ImGuiNavMoveFlags_.ImGuiNavMoveFlags_NoSetNavCursorVisible
	scroll_flags : ImGuiScrollFlags = window.Appearing ? ImGuiScrollFlags_.ImGuiScrollFlags_KeepVisibleEdgeX | ImGuiScrollFlags_.ImGuiScrollFlags_AlwaysCenterY : ImGuiScrollFlags_.ImGuiScrollFlags_KeepVisibleEdgeX | ImGuiScrollFlags_.ImGuiScrollFlags_KeepVisibleEdgeY
	NavMoveRequestSubmit(ImGuiDir.ImGuiDir_None, offset < 0 ? ImGuiDir.ImGuiDir_Up : ImGuiDir.ImGuiDir_Down, move_flags, scroll_flags); // FIXME-NAV: Once we refactor tabbing, add LegacyApi flag to not activate non-inputable.
	if offset == -1 {
		NavMoveRequestResolveWithLastItem(&g.NavMoveResultLocal)
	}
	else {
		g.NavTabbingDir = 1
		g.NavTabbingCounter = offset + 1
	}
}

// Focus, Activation
// make last item the default focused item of of a newly appearing window.
SetItemDefaultFocus :: proc()
{
	g : ^ImGuiContext = GImGui^
	window : ^ImGuiWindow = g.CurrentWindow
	if !window.Appearing { return }
	if g.NavWindow != window.RootWindowForNav || (!g.NavInitRequest && g.NavInitResult.ID == 0) || g.NavLayer != window.DC.NavLayerCurrent { return }

	g.NavInitRequest = false
	NavApplyItemToResult(&g.NavInitResult)
	NavUpdateAnyRequestFlag()

	// Scroll could be done in NavInitRequestApplyResult() via an opt-in flag (we however don't want regular init requests to scroll)
	if !Contains(&window.ClipRect, g.LastItemData.Rect) { ScrollToRectEx(window, g.LastItemData.Rect, ImGuiScrollFlags_.ImGuiScrollFlags_None) }
}

// replace current window storage with our own (if you want to manipulate it yourself, typically clear subsection of it)
SetStateStorage :: proc(tree : ^ImGuiStorage)
{
	window : ^ImGuiWindow = GImGui.CurrentWindow
	window.DC.StateStorage = tree ? tree : &window.StateStorage
}

GetStateStorage :: proc() -> ^ImGuiStorage
{
	window : ^ImGuiWindow = GImGui.CurrentWindow
	return window.DC.StateStorage
}

// Miscellaneous Utilities
// test if rectangle (of given size, starting from cursor position) is visible / not clipped.
// test if rectangle (in screen space) is visible / not clipped. to perform coarse clipping on user's side.
IsRectVisible_0 :: proc(size : ^ImVec2) -> bool
{
	window : ^ImGuiWindow = GImGui.CurrentWindow
	return Overlaps(&window.ClipRect, ImRect(window.DC.CursorPos, window.DC.CursorPos + size))
}

// Miscellaneous Utilities
// test if rectangle (of given size, starting from cursor position) is visible / not clipped.
// test if rectangle (in screen space) is visible / not clipped. to perform coarse clipping on user's side.
IsRectVisible_1 :: proc(rect_min : ^ImVec2, rect_max : ^ImVec2) -> bool
{
	window : ^ImGuiWindow = GImGui.CurrentWindow
	return Overlaps(&window.ClipRect, ImRect(rect_min, rect_max))
}

//-----------------------------------------------------------------------------
// [SECTION] ID STACK
//-----------------------------------------------------------------------------

// This is one of the very rare legacy case where we use ImGuiWindow methods,
// it should ideally be flattened at some point but it's been used a lots by widgets.

ImGuiWindow_GetID_0 :: proc(this : ^ImGuiWindow, str : ^u8, str_end : ^u8) -> ImGuiID
{
	seed : ImGuiID = back(&this.IDStack)
	id : ImGuiID = ImHashStr(str, str_end ? (str_end - str) : 0, seed)
	when ! IMGUI_DISABLE_DEBUG_TOOLS { // @gen ifndef
	g : ^ImGuiContext = this.Ctx^
	if g.DebugHookIdInfo == id { DebugHookIdInfo(id, ImGuiDataType_.ImGuiDataType_String, str, str_end) }
	} // preproc endif
	return id
}

ImGuiWindow_GetID_1 :: proc(this : ^ImGuiWindow, ptr : rawptr) -> ImGuiID
{
	seed : ImGuiID = back(&this.IDStack)
	id : ImGuiID = ImHashData(&ptr, size_of(rawptr), seed)
	when ! IMGUI_DISABLE_DEBUG_TOOLS { // @gen ifndef
	g : ^ImGuiContext = this.Ctx^
	if g.DebugHookIdInfo == id { DebugHookIdInfo(id, ImGuiDataTypePrivate_.ImGuiDataType_Pointer, ptr, nil) }
	} // preproc endif
	return id
}

ImGuiWindow_GetID_2 :: proc(this : ^ImGuiWindow, n : i32) -> ImGuiID
{
	seed : ImGuiID = back(&this.IDStack)
	id : ImGuiID = ImHashData(&n, size_of(n), seed)
	when ! IMGUI_DISABLE_DEBUG_TOOLS { // @gen ifndef
	g : ^ImGuiContext = this.Ctx^
	if g.DebugHookIdInfo == id { DebugHookIdInfo(id, ImGuiDataType_.ImGuiDataType_S32, cast(rawptr) cast(intptr_t) n, nil) }
	} // preproc endif
	return id
}

// This is only used in rare/specific situations to manufacture an ID out of nowhere.
// FIXME: Consider instead storing last non-zero ID + count of successive zero-ID, and combine those?
ImGuiWindow_GetIDFromPos :: proc(this : ^ImGuiWindow, p_abs : ^ImVec2) -> ImGuiID
{
	seed : ImGuiID = back(&this.IDStack)
	p_rel : ImVec2 = WindowPosAbsToRel(this, p_abs)
	id : ImGuiID = ImHashData(&p_rel, size_of(p_rel), seed)
	return id
}

// "
ImGuiWindow_GetIDFromRectangle :: proc(this : ^ImGuiWindow, r_abs : ^ImRect) -> ImGuiID
{
	seed : ImGuiID = back(&this.IDStack)
	r_rel : ImRect = WindowRectAbsToRel(this, r_abs)
	id : ImGuiID = ImHashData(&r_rel, size_of(r_rel), seed)
	return id
}

// ID stack/scopes
// Read the FAQ (docs/FAQ.md or http://dearimgui.com/faq) for more details about how ID are handled in dear imgui.
// - Those questions are answered and impacted by understanding of the ID stack system:
//   - "Q: Why is my widget not reacting when I click on it?"
//   - "Q: How can I have widgets with an empty label?"
//   - "Q: How can I have multiple widgets with the same label?"
// - Short version: ID are hashes of the entire ID stack. If you are creating widgets in a loop you most likely
//   want to push a unique identifier (e.g. object pointer, loop index) to uniquely differentiate them.
// - You can also use the "Label##foobar" syntax within widget label to distinguish them from each others.
// - In this header file we use the "label"/"name" terminology to denote a string that will be displayed + used as an ID,
//   whereas "str_id" denote a string that is only used as an ID and not normally displayed.
// push string into the ID stack (will hash string).
// push string into the ID stack (will hash string).
// push pointer into the ID stack (will hash pointer).
// push integer into the ID stack (will hash integer).
PushID_0 :: proc(str_id : ^u8)
{
	g : ^ImGuiContext = GImGui^
	window : ^ImGuiWindow = g.CurrentWindow
	id : ImGuiID = GetID(window, str_id)
	push_back(&window.IDStack, id)
}

// ID stack/scopes
// Read the FAQ (docs/FAQ.md or http://dearimgui.com/faq) for more details about how ID are handled in dear imgui.
// - Those questions are answered and impacted by understanding of the ID stack system:
//   - "Q: Why is my widget not reacting when I click on it?"
//   - "Q: How can I have widgets with an empty label?"
//   - "Q: How can I have multiple widgets with the same label?"
// - Short version: ID are hashes of the entire ID stack. If you are creating widgets in a loop you most likely
//   want to push a unique identifier (e.g. object pointer, loop index) to uniquely differentiate them.
// - You can also use the "Label##foobar" syntax within widget label to distinguish them from each others.
// - In this header file we use the "label"/"name" terminology to denote a string that will be displayed + used as an ID,
//   whereas "str_id" denote a string that is only used as an ID and not normally displayed.
// push string into the ID stack (will hash string).
// push string into the ID stack (will hash string).
// push pointer into the ID stack (will hash pointer).
// push integer into the ID stack (will hash integer).
PushID_1 :: proc(str_id_begin : ^u8, str_id_end : ^u8)
{
	g : ^ImGuiContext = GImGui^
	window : ^ImGuiWindow = g.CurrentWindow
	id : ImGuiID = GetID(window, str_id_begin, str_id_end)
	push_back(&window.IDStack, id)
}

// ID stack/scopes
// Read the FAQ (docs/FAQ.md or http://dearimgui.com/faq) for more details about how ID are handled in dear imgui.
// - Those questions are answered and impacted by understanding of the ID stack system:
//   - "Q: Why is my widget not reacting when I click on it?"
//   - "Q: How can I have widgets with an empty label?"
//   - "Q: How can I have multiple widgets with the same label?"
// - Short version: ID are hashes of the entire ID stack. If you are creating widgets in a loop you most likely
//   want to push a unique identifier (e.g. object pointer, loop index) to uniquely differentiate them.
// - You can also use the "Label##foobar" syntax within widget label to distinguish them from each others.
// - In this header file we use the "label"/"name" terminology to denote a string that will be displayed + used as an ID,
//   whereas "str_id" denote a string that is only used as an ID and not normally displayed.
// push string into the ID stack (will hash string).
// push string into the ID stack (will hash string).
// push pointer into the ID stack (will hash pointer).
// push integer into the ID stack (will hash integer).
PushID_2 :: proc(ptr_id : rawptr)
{
	g : ^ImGuiContext = GImGui^
	window : ^ImGuiWindow = g.CurrentWindow
	id : ImGuiID = GetID(window, ptr_id)
	push_back(&window.IDStack, id)
}

// ID stack/scopes
// Read the FAQ (docs/FAQ.md or http://dearimgui.com/faq) for more details about how ID are handled in dear imgui.
// - Those questions are answered and impacted by understanding of the ID stack system:
//   - "Q: Why is my widget not reacting when I click on it?"
//   - "Q: How can I have widgets with an empty label?"
//   - "Q: How can I have multiple widgets with the same label?"
// - Short version: ID are hashes of the entire ID stack. If you are creating widgets in a loop you most likely
//   want to push a unique identifier (e.g. object pointer, loop index) to uniquely differentiate them.
// - You can also use the "Label##foobar" syntax within widget label to distinguish them from each others.
// - In this header file we use the "label"/"name" terminology to denote a string that will be displayed + used as an ID,
//   whereas "str_id" denote a string that is only used as an ID and not normally displayed.
// push string into the ID stack (will hash string).
// push string into the ID stack (will hash string).
// push pointer into the ID stack (will hash pointer).
// push integer into the ID stack (will hash integer).
PushID_3 :: proc(int_id : i32)
{
	g : ^ImGuiContext = GImGui^
	window : ^ImGuiWindow = g.CurrentWindow
	id : ImGuiID = GetID(window, int_id)
	push_back(&window.IDStack, id)
}

// Push given value as-is at the top of the ID stack (whereas PushID combines old and new hashes)
// Push a given id value ignoring the ID stack as a seed.
PushOverrideID :: proc(id : ImGuiID)
{
	g : ^ImGuiContext = GImGui^
	window : ^ImGuiWindow = g.CurrentWindow
	when ! IMGUI_DISABLE_DEBUG_TOOLS { // @gen ifndef
	if g.DebugHookIdInfo == id { DebugHookIdInfo(id, ImGuiDataTypePrivate_.ImGuiDataType_ID, nil, nil) }
	} // preproc endif
	push_back(&window.IDStack, id)
}

// Helper to avoid a common series of PushOverrideID -> GetID() -> PopID() call
// (note that when using this pattern, ID Stack Tool will tend to not display the intermediate stack level.
//  for that to work we would need to do PushOverrideID() -> ItemAdd() -> PopID() which would alter widget code a little more)
GetIDWithSeed_0 :: proc(str : ^u8, str_end : ^u8, seed : ImGuiID) -> ImGuiID
{
	id : ImGuiID = ImHashStr(str, str_end ? (str_end - str) : 0, seed)
	when ! IMGUI_DISABLE_DEBUG_TOOLS { // @gen ifndef
	g : ^ImGuiContext = GImGui^
	if g.DebugHookIdInfo == id { DebugHookIdInfo(id, ImGuiDataType_.ImGuiDataType_String, str, str_end) }
	} // preproc endif
	return id
}

GetIDWithSeed_1 :: proc(n : i32, seed : ImGuiID) -> ImGuiID
{
	id : ImGuiID = ImHashData(&n, size_of(n), seed)
	when ! IMGUI_DISABLE_DEBUG_TOOLS { // @gen ifndef
	g : ^ImGuiContext = GImGui^
	if g.DebugHookIdInfo == id { DebugHookIdInfo(id, ImGuiDataType_.ImGuiDataType_S32, cast(rawptr) cast(intptr_t) n, nil) }
	} // preproc endif
	return id
}

// pop from the ID stack.
PopID :: proc()
{
	window : ^ImGuiWindow = GImGui.CurrentWindow
	if window.IDStack.Size <= 1 {
		IM_ASSERT_USER_ERROR(0, "Calling PopID() too many times!")
		return
	}
	pop_back(&window.IDStack)
}

// calculate unique ID (hash of whole ID stack + given parameter). e.g. if you want to query into ImGuiStorage yourself
GetID_0 :: proc(str_id : ^u8) -> ImGuiID
{
	window : ^ImGuiWindow = GImGui.CurrentWindow
	return GetID(window, str_id)
}

// calculate unique ID (hash of whole ID stack + given parameter). e.g. if you want to query into ImGuiStorage yourself
GetID_1 :: proc(str_id_begin : ^u8, str_id_end : ^u8) -> ImGuiID
{
	window : ^ImGuiWindow = GImGui.CurrentWindow
	return GetID(window, str_id_begin, str_id_end)
}

// calculate unique ID (hash of whole ID stack + given parameter). e.g. if you want to query into ImGuiStorage yourself
GetID_2 :: proc(ptr_id : rawptr) -> ImGuiID
{
	window : ^ImGuiWindow = GImGui.CurrentWindow
	return GetID(window, ptr_id)
}

// calculate unique ID (hash of whole ID stack + given parameter). e.g. if you want to query into ImGuiStorage yourself
GetID_3 :: proc(int_id : i32) -> ImGuiID
{
	window : ^ImGuiWindow = GImGui.CurrentWindow
	return GetID(window, int_id)
}


//-----------------------------------------------------------------------------
// [SECTION] INPUTS
//-----------------------------------------------------------------------------
// - GetModForLRModKey() [Internal]
// - FixupKeyChord() [Internal]
// - GetKeyData() [Internal]
// - GetKeyIndex() [Internal]
// - GetKeyName()
// - GetKeyChordName() [Internal]
// - CalcTypematicRepeatAmount() [Internal]
// - GetTypematicRepeatRate() [Internal]
// - GetKeyPressedAmount() [Internal]
// - GetKeyMagnitude2d() [Internal]
//-----------------------------------------------------------------------------
// - UpdateKeyRoutingTable() [Internal]
// - GetRoutingIdFromOwnerId() [Internal]
// - GetShortcutRoutingData() [Internal]
// - CalcRoutingScore() [Internal]
// - SetShortcutRouting() [Internal]
// - TestShortcutRouting() [Internal]
//-----------------------------------------------------------------------------
// - IsKeyDown()
// - IsKeyPressed()
// - IsKeyReleased()
//-----------------------------------------------------------------------------
// - IsMouseDown()
// - IsMouseClicked()
// - IsMouseReleased()
// - IsMouseDoubleClicked()
// - GetMouseClickedCount()
// - IsMouseHoveringRect() [Internal]
// - IsMouseDragPastThreshold() [Internal]
// - IsMouseDragging()
// - GetMousePos()
// - SetMousePos() [Internal]
// - GetMousePosOnOpeningCurrentPopup()
// - IsMousePosValid()
// - IsAnyMouseDown()
// - GetMouseDragDelta()
// - ResetMouseDragDelta()
// - GetMouseCursor()
// - SetMouseCursor()
//-----------------------------------------------------------------------------
// - UpdateAliasKey()
// - GetMergedModsFromKeys()
// - UpdateKeyboardInputs()
// - UpdateMouseInputs()
//-----------------------------------------------------------------------------
// - LockWheelingWindow [Internal]
// - FindBestWheelingWindow [Internal]
// - UpdateMouseWheel() [Internal]
//-----------------------------------------------------------------------------
// - SetNextFrameWantCaptureKeyboard()
// - SetNextFrameWantCaptureMouse()
//-----------------------------------------------------------------------------
// - GetInputSourceName() [Internal]
// - DebugPrintInputEvent() [Internal]
// - UpdateInputEvents() [Internal]
//-----------------------------------------------------------------------------
// - GetKeyOwner() [Internal]
// - TestKeyOwner() [Internal]
// - SetKeyOwner() [Internal]
// - SetItemKeyOwner() [Internal]
// - Shortcut() [Internal]
//-----------------------------------------------------------------------------

GetModForLRModKey :: proc(key : ImGuiKey) -> ImGuiKeyChord
{
	if key == ImGuiKey.ImGuiKey_LeftCtrl || key == ImGuiKey.ImGuiKey_RightCtrl { return ImGuiKey.ImGuiMod_Ctrl }
	if key == ImGuiKey.ImGuiKey_LeftShift || key == ImGuiKey.ImGuiKey_RightShift { return ImGuiKey.ImGuiMod_Shift }
	if key == ImGuiKey.ImGuiKey_LeftAlt || key == ImGuiKey.ImGuiKey_RightAlt { return ImGuiKey.ImGuiMod_Alt }
	if key == ImGuiKey.ImGuiKey_LeftSuper || key == ImGuiKey.ImGuiKey_RightSuper { return ImGuiKey.ImGuiMod_Super }
	return ImGuiKey.ImGuiMod_None
}

FixupKeyChord :: proc(key_chord : ImGuiKeyChord) -> ImGuiKeyChord
{
	// Add ImGuiMod_XXXX when a corresponding ImGuiKey_LeftXXX/ImGuiKey_RightXXX is specified.
	key : ImGuiKey = cast(ImGuiKey) (key_chord & !ImGuiKey.ImGuiMod_Mask_)
	if IsLRModKey(key) { key_chord |= GetModForLRModKey(key) }
	return key_chord
}

GetKeyData :: proc(ctx : ^ImGuiContext, key : ImGuiKey) -> ^ImGuiKeyData
{
	g : ^ImGuiContext = ctx^

	// Special storage location for mods
	if ImGuiMod_Mask_ : ^key; ImGuiMod_Mask_ { key = ConvertSingleModFlagToKey(key) }

	IM_ASSERT(IsNamedKey(key) && "Support for user key indices was dropped in favor of ImGuiKey. Please update backend & user code.")
	return &g.IO.KeysData[key - ImGuiKey.ImGuiKey_NamedKey_BEGIN]
}

// Those names a provided for debugging purpose and are not meant to be saved persistently not compared.
GKeyNames := [?]cstring {
	"Tab", "LeftArrow", "RightArrow", "UpArrow", "DownArrow", "PageUp", "PageDown",
	"Home", "End", "Insert", "Delete", "Backspace", "Space", "Enter", "Escape",
	"LeftCtrl", "LeftShift", "LeftAlt", "LeftSuper", "RightCtrl", "RightShift", "RightAlt", "RightSuper", "Menu",
	"0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "A", "B", "C", "D", "E", "F", "G", "H",
	"I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z",
	"F1", "F2", "F3", "F4", "F5", "F6", "F7", "F8", "F9", "F10", "F11", "F12",
	"F13", "F14", "F15", "F16", "F17", "F18", "F19", "F20", "F21", "F22", "F23", "F24",
	"Apostrophe", "Comma", "Minus", "Period", "Slash", "Semicolon", "Equal", "LeftBracket",
	"Backslash", "RightBracket", "GraveAccent", "CapsLock", "ScrollLock", "NumLock", "PrintScreen",
	"Pause", "Keypad0", "Keypad1", "Keypad2", "Keypad3", "Keypad4", "Keypad5", "Keypad6",
	"Keypad7", "Keypad8", "Keypad9", "KeypadDecimal", "KeypadDivide", "KeypadMultiply",
	"KeypadSubtract", "KeypadAdd", "KeypadEnter", "KeypadEqual",
	"AppBack", "AppForward",
	"GamepadStart", "GamepadBack",
	"GamepadFaceLeft", "GamepadFaceRight", "GamepadFaceUp", "GamepadFaceDown",
	"GamepadDpadLeft", "GamepadDpadRight", "GamepadDpadUp", "GamepadDpadDown",
	"GamepadL1", "GamepadR1", "GamepadL2", "GamepadR2", "GamepadL3", "GamepadR3",
	"GamepadLStickLeft", "GamepadLStickRight", "GamepadLStickUp", "GamepadLStickDown",
	"GamepadRStickLeft", "GamepadRStickRight", "GamepadRStickUp", "GamepadRStickDown",
	"MouseLeft", "MouseRight", "MouseMiddle", "MouseX1", "MouseX2", "MouseWheelX", "MouseWheelY",
	"ModCtrl", "ModShift", "ModAlt", "ModSuper", // ReservedForModXXX are showing the ModXXX names.
}
#assert(int(ImGuiKey.ImGuiKey_NamedKey_COUNT) == len(GKeyNames))

// [DEBUG] returns English name of the key. Those names a provided for debugging purpose and are not meant to be saved persistently not compared.
GetKeyName :: proc(key : ImGuiKey) -> ^u8
{
	if key == ImGuiKey.ImGuiKey_None { return "None" }
	IM_ASSERT(IsNamedKeyOrMod(key) && "Support for user key indices was dropped in favor of ImGuiKey. Please update backend and user code.")
	if ImGuiMod_Mask_ : ^key; ImGuiMod_Mask_ { key = ConvertSingleModFlagToKey(key) }
	if !IsNamedKey(key) { return "Unknown" }

	return GKeyNames[key - ImGuiKey.ImGuiKey_NamedKey_BEGIN]
}

// Return untranslated names: on macOS, Cmd key will show as Ctrl, Ctrl key will show as super.
// Lifetime of return value: valid until next call to same function.
GetKeyChordName :: proc(key_chord : ImGuiKeyChord) -> ^u8
{
	g : ^ImGuiContext = GImGui^

	key : ImGuiKey = cast(ImGuiKey) (key_chord & !ImGuiKey.ImGuiMod_Mask_)
	if IsLRModKey(key) {
		// Return "Ctrl+LeftShift" instead of "Ctrl+Shift+LeftShift"
		key_chord &= !GetModForLRModKey(key)
	}
	ImFormatString(g.TempKeychordName, IM_ARRAYSIZE(g.TempKeychordName), "%s%s%s%s%s", (key_chord & ImGuiKey.ImGuiMod_Ctrl) ? "Ctrl+" : "", (key_chord & ImGuiKey.ImGuiMod_Shift) ? "Shift+" : "", (key_chord & ImGuiKey.ImGuiMod_Alt) ? "Alt+" : "", (key_chord & ImGuiKey.ImGuiMod_Super) ? "Super+" : "", (key != ImGuiKey.ImGuiKey_None || key_chord == ImGuiKey.ImGuiKey_None) ? GetKeyName(key) : "")
	len : uint
	if key == ImGuiKey.ImGuiKey_None && key_chord != 0 {
		len = strlen(g.TempKeychordName)
		if len != 0 {
			// Remove trailing '+'
			g.TempKeychordName[len - 1] = 0
		}
	}
	return g.TempKeychordName
}

// t0 = previous time (e.g.: g.Time - g.IO.DeltaTime)
// t1 = current time (e.g.: g.Time)
// An event is triggered at:
//  t = 0.0f     t = repeat_delay,    t = repeat_delay + repeat_rate*N
CalcTypematicRepeatAmount :: proc(t0 : f32, t1 : f32, repeat_delay : f32, repeat_rate : f32) -> i32
{
	if t1 == 0.0 { return 1 }
	if t0 >= t1 { return 0 }
	if repeat_rate <= 0.0 { return (t0 < repeat_delay) && (t1 >= repeat_delay) }
	count_t0 : i32 = (t0 < repeat_delay) ? -1 : cast(i32) ((t0 - repeat_delay) / repeat_rate)
	count_t1 : i32 = (t1 < repeat_delay) ? -1 : cast(i32) ((t1 - repeat_delay) / repeat_rate)
	count : i32 = count_t1 - count_t0
	return count
}

GetTypematicRepeatRate :: proc(flags : ImGuiInputFlags, repeat_delay : ^f32, repeat_rate : ^f32)
{
	g : ^ImGuiContext = GImGui^
	switch flags & ImGuiInputFlagsPrivate_.ImGuiInputFlags_RepeatRateMask_ {
		case ImGuiInputFlagsPrivate_.ImGuiInputFlags_RepeatRateNavMove:repeat_delay^ = g.IO.KeyRepeatDelay * 0.72; repeat_rate^ = g.IO.KeyRepeatRate * 0.80; return
			fallthrough
		case ImGuiInputFlagsPrivate_.ImGuiInputFlags_RepeatRateNavTweak:repeat_delay^ = g.IO.KeyRepeatDelay * 0.72; repeat_rate^ = g.IO.KeyRepeatRate * 0.30; return
			fallthrough
		case ImGuiInputFlagsPrivate_.ImGuiInputFlags_RepeatRateDefault:; fallthrough
		case:repeat_delay^ = g.IO.KeyRepeatDelay * 1.00; repeat_rate^ = g.IO.KeyRepeatRate * 1.00; return
	}
}

// uses provided repeat rate/delay. return a count, most often 0 or 1 but might be >1 if RepeatRate is small enough that DeltaTime > RepeatRate
// Return value representing the number of presses in the last time period, for the given repeat rate
// (most often returns 0 or 1. The result is generally only >1 when RepeatRate is smaller than DeltaTime, aka large DeltaTime or fast RepeatRate)
GetKeyPressedAmount :: proc(key : ImGuiKey, repeat_delay : f32, repeat_rate : f32) -> i32
{
	g : ^ImGuiContext = GImGui^
	key_data : ^ImGuiKeyData = GetKeyData(key)
	if !key_data.Down {
		// In theory this should already be encoded as (DownDuration < 0.0f), but testing this facilitates eating mechanism (until we finish work on key ownership)return 0
	}
	t : f32 = key_data.DownDuration
	return CalcTypematicRepeatAmount(t - g.IO.DeltaTime, t, repeat_delay, repeat_rate)
}

// Return 2D vector representing the combination of four cardinal direction, with analog value support (for e.g. ImGuiKey_GamepadLStick* values).
GetKeyMagnitude2d :: proc(key_left : ImGuiKey, key_right : ImGuiKey, key_up : ImGuiKey, key_down : ImGuiKey) -> ImVec2
{
	return ImVec2(GetKeyData(key_right).AnalogValue - GetKeyData(key_left).AnalogValue, GetKeyData(key_down).AnalogValue - GetKeyData(key_up).AnalogValue)
}

// Rewrite routing data buffers to strip old entries + sort by key to make queries not touch scattered data.
//   Entries   D,A,B,B,A,C,B     --> A,A,B,B,B,C,D
//   Index     A:1 B:2 C:5 D:0   --> A:0 B:2 C:5 D:6
// See 'Metrics->Key Owners & Shortcut Routing' to visualize the result of that operation.
UpdateKeyRoutingTable :: proc(rt : ^ImGuiKeyRoutingTable)
{
	g : ^ImGuiContext = GImGui^
	resize(&rt.EntriesNext, 0)
	for key : ImGuiKey = ImGuiKey.ImGuiKey_NamedKey_BEGIN; key < ImGuiKey.ImGuiKey_NamedKey_END; key = cast(ImGuiKey) (key + 1) {
		new_routing_start_idx : i32 = rt.EntriesNext.Size
		routing_entry : ^ImGuiKeyRoutingData
		for old_routing_idx : i32 = rt.Index[key - ImGuiKey.ImGuiKey_NamedKey_BEGIN]; old_routing_idx != -1; old_routing_idx = routing_entry.NextEntryIndex {
			routing_entry = &rt.Entries[old_routing_idx]
			routing_entry.RoutingCurrScore = routing_entry.RoutingNextScore
			routing_entry.RoutingCurr = routing_entry.RoutingNext; // Update entry
			routing_entry.RoutingNext = ImGuiKeyOwner_NoOwner
			routing_entry.RoutingNextScore = 255
			if routing_entry.RoutingCurr == ImGuiKeyOwner_NoOwner { continue }
			push_back(&rt.EntriesNext, routing_entry^); // Write alive ones into new buffer

			// Apply routing to owner if there's no owner already (RoutingCurr == None at this point)
			// This is the result of previous frame's SetShortcutRouting() call.
			if routing_entry.Mods == g.IO.KeyMods {
				owner_data : ^ImGuiKeyOwnerData = GetKeyOwnerData(&g, key)
				if owner_data.OwnerCurr == ImGuiKeyOwner_NoOwner {
					owner_data.OwnerCurr = routing_entry.RoutingCurr
					//IMGUI_DEBUG_LOG("SetKeyOwner(%s, owner_id=0x%08X) via Routing\n", GetKeyName(key), routing_entry->RoutingCurr);
				}
			}
		}

		// Rewrite linked-list
		rt.Index[key - ImGuiKey.ImGuiKey_NamedKey_BEGIN] = cast(ImGuiKeyRoutingIndex) (new_routing_start_idx < rt.EntriesNext.Size ? new_routing_start_idx : -1)
		for n : i32 = new_routing_start_idx; n < rt.EntriesNext.Size; post_incr(&n) { rt.EntriesNext[n].NextEntryIndex = cast(ImGuiKeyRoutingIndex) ((n + 1 < rt.EntriesNext.Size) ? n + 1 : -1) }
	}

	swap(&rt.Entries, rt.EntriesNext); // Swap new and old indexes
}

// owner_id may be None/Any, but routing_id needs to be always be set, so we default to GetCurrentFocusScope().
GetRoutingIdFromOwnerId :: #force_inline proc(owner_id : ImGuiID) -> ImGuiID
{
	g : ^ImGuiContext = GImGui^
	return (owner_id != ImGuiKeyOwner_NoOwner && owner_id != ImGuiKeyOwner_Any) ? owner_id : g.CurrentFocusScopeId
}

GetShortcutRoutingData :: proc(key_chord : ImGuiKeyChord) -> ^ImGuiKeyRoutingData
{
	// Majority of shortcuts will be Key + any number of Mods
	// We accept _Single_ mod with ImGuiKey_None.
	//  - Shortcut(ImGuiKey_S | ImGuiMod_Ctrl);                    // Legal
	//  - Shortcut(ImGuiKey_S | ImGuiMod_Ctrl | ImGuiMod_Shift);   // Legal
	//  - Shortcut(ImGuiMod_Ctrl);                                 // Legal
	//  - Shortcut(ImGuiMod_Ctrl | ImGuiMod_Shift);                // Not legal
	g : ^ImGuiContext = GImGui^
	rt : ^ImGuiKeyRoutingTable = &g.KeysRoutingTable
	routing_data : ^ImGuiKeyRoutingData
	key : ImGuiKey = cast(ImGuiKey) (key_chord & !ImGuiKey.ImGuiMod_Mask_)
	mods : ImGuiKey = cast(ImGuiKey) (key_chord & ImGuiKey.ImGuiMod_Mask_)
	if key == ImGuiKey.ImGuiKey_None { key = ConvertSingleModFlagToKey(mods) }
	IM_ASSERT(IsNamedKey(key))

	// Get (in the majority of case, the linked list will have one element so this should be 2 reads.
	// Subsequent elements will be contiguous in memory as list is sorted/rebuilt in NewFrame).
	for idx : ImGuiKeyRoutingIndex = rt.Index[key - ImGuiKey.ImGuiKey_NamedKey_BEGIN]; idx != -1; idx = routing_data.NextEntryIndex {
		routing_data = &rt.Entries[idx]
		if routing_data.Mods == mods { return routing_data }
	}

	// Add to linked-list
	routing_data_idx : ImGuiKeyRoutingIndex = cast(ImGuiKeyRoutingIndex) rt.Entries.Size
	push_back(&rt.Entries, ImGuiKeyRoutingData())
	routing_data = &rt.Entries[routing_data_idx]
	routing_data.Mods = cast(ImU16) mods
	routing_data.NextEntryIndex = rt.Index[key - ImGuiKey.ImGuiKey_NamedKey_BEGIN]; // Setup linked list
	rt.Index[key - ImGuiKey.ImGuiKey_NamedKey_BEGIN] = routing_data_idx
	return routing_data
}

// Current score encoding (lower is highest priority):
//  -   0: ImGuiInputFlags_RouteGlobal | ImGuiInputFlags_RouteOverActive
//  -   1: ImGuiInputFlags_ActiveItem or ImGuiInputFlags_RouteFocused (if item active)
//  -   2: ImGuiInputFlags_RouteGlobal | ImGuiInputFlags_RouteOverFocused
//  -  3+: ImGuiInputFlags_RouteFocused (if window in focus-stack)
//  - 254: ImGuiInputFlags_RouteGlobal
//  - 255: never route
// 'flags' should include an explicit routing policy
CalcRoutingScore :: proc(focus_scope_id : ImGuiID, owner_id : ImGuiID, flags : ImGuiInputFlags) -> i32
{
	g : ^ImGuiContext = GImGui^
	if ImGuiInputFlags_RouteFocused : ^flags; ImGuiInputFlags_RouteFocused {
		// ActiveID gets top priority
		// (we don't check g.ActiveIdUsingAllKeys here. Routing is applied but if input ownership is tested later it may discard it)
		if owner_id != 0 && g.ActiveId == owner_id { return 1 }

		// Score based on distance to focused window (lower is better)
		// Assuming both windows are submitting a routing request,
		// - When Window....... is focused -> Window scores 3 (best), Window/ChildB scores 255 (no match)
		// - When Window/ChildB is focused -> Window scores 4,        Window/ChildB scores 3 (best)
		// Assuming only WindowA is submitting a routing request,
		// - When Window/ChildB is focused -> Window scores 4 (best), Window/ChildB doesn't have a score.
		// This essentially follow the window->ParentWindowForFocusRoute chain.
		if focus_scope_id == 0 { return 255 }
		for index_in_focus_path : i32 = 0; index_in_focus_path < g.NavFocusRoute.Size; post_incr(&index_in_focus_path) { if g.NavFocusRoute.Data[index_in_focus_path].ID == focus_scope_id { return 3 + index_in_focus_path } }

		return 255
	}
	else if ImGuiInputFlags_RouteActive : ^flags; ImGuiInputFlags_RouteActive {
		if owner_id != 0 && g.ActiveId == owner_id { return 1 }
		return 255
	}
	else if ImGuiInputFlags_RouteGlobal : ^flags; ImGuiInputFlags_RouteGlobal {
		if ImGuiInputFlags_RouteOverActive : ^flags; ImGuiInputFlags_RouteOverActive { return 0 }
		if ImGuiInputFlags_RouteOverFocused : ^flags; ImGuiInputFlags_RouteOverFocused { return 2 }
		return 254
	}
	IM_ASSERT(0)
	return 0
}

// - We need this to filter some Shortcut() routes when an item e.g. an InputText() is active
//   e.g. ImGuiKey_G won't be considered a shortcut when item is active, but ImGuiMod|ImGuiKey_G can be.
// - This is also used by UpdateInputEvents() to avoid trickling in the most common case of e.g. pressing ImGuiKey_G also emitting a G character.
IsKeyChordPotentiallyCharInput :: proc(key_chord : ImGuiKeyChord) -> bool
{
	// Mimic 'ignore_char_inputs' logic in InputText()
	g : ^ImGuiContext = GImGui^

	// When the right mods are pressed it cannot be a char input so we won't filter the shortcut out.
	mods : ImGuiKey = cast(ImGuiKey) (key_chord & ImGuiKey.ImGuiMod_Mask_)
	ignore_char_inputs : bool = ((mods & ImGuiKey.ImGuiMod_Ctrl) && !(mods & ImGuiKey.ImGuiMod_Alt)) || (g.IO.ConfigMacOSXBehaviors && (mods & ImGuiKey.ImGuiMod_Ctrl))
	if ignore_char_inputs { return false }

	// Return true for A-Z, 0-9 and other keys associated to char inputs. Other keys such as F1-F12 won't be filtered.
	key : ImGuiKey = cast(ImGuiKey) (key_chord & !ImGuiKey.ImGuiMod_Mask_)
	if key == ImGuiKey.ImGuiKey_None { return false }
	return TestBit(&g.KeysMayBeCharInput, key)
}

// owner_id needs to be explicit and cannot be 0
// Request a desired route for an input chord (key + mods).
// Return true if the route is available this frame.
// - Routes and key ownership are attributed at the beginning of next frame based on best score and mod state.
//   (Conceptually this does a "Submit for next frame" + "Test for current frame".
//   As such, it could be called TrySetXXX or SubmitXXX, or the Submit and Test operations should be separate.)
SetShortcutRouting :: proc(key_chord : ImGuiKeyChord, flags : ImGuiInputFlags, owner_id : ImGuiID) -> bool
{
	g : ^ImGuiContext = GImGui^
	if (flags & ImGuiInputFlagsPrivate_.ImGuiInputFlags_RouteTypeMask_) == 0 {
		// IMPORTANT: This is the default for SetShortcutRouting() but NOT Shortcut()
		flags |= ImGuiInputFlags_.ImGuiInputFlags_RouteGlobal | ImGuiInputFlags_.ImGuiInputFlags_RouteOverFocused | ImGuiInputFlags_.ImGuiInputFlags_RouteOverActive
	}
	else {
		// Check that only 1 routing flag is used
		IM_ASSERT(ImIsPowerOfTwo(flags & ImGuiInputFlagsPrivate_.ImGuiInputFlags_RouteTypeMask_))
	}
	IM_ASSERT(owner_id != ImGuiKeyOwner_Any && owner_id != ImGuiKeyOwner_NoOwner)
	if flags & (ImGuiInputFlags_.ImGuiInputFlags_RouteOverFocused | ImGuiInputFlags_.ImGuiInputFlags_RouteOverActive | ImGuiInputFlags_.ImGuiInputFlags_RouteUnlessBgFocused) { IM_ASSERT(flags & ImGuiInputFlags_.ImGuiInputFlags_RouteGlobal) }

	// Add ImGuiMod_XXXX when a corresponding ImGuiKey_LeftXXX/ImGuiKey_RightXXX is specified.
	key_chord = FixupKeyChord(key_chord)

	// [DEBUG] Debug break requested by user
	if g.DebugBreakInShortcutRouting == key_chord { IM_DEBUG_BREAK() }

	if ImGuiInputFlags_RouteUnlessBgFocused : ^flags; ImGuiInputFlags_RouteUnlessBgFocused { if g.NavWindow == nil { return false } }

	// Note how ImGuiInputFlags_RouteAlways won't set routing and thus won't set owner. May want to rework this?
	if ImGuiInputFlags_RouteAlways : ^flags; ImGuiInputFlags_RouteAlways {
		IMGUI_DEBUG_LOG_INPUTROUTING("SetShortcutRouting(%s, flags=%04X, owner_id=0x%08X) -> always, no register\n", GetKeyChordName(key_chord), flags, owner_id)
		return true
	}

	// Specific culling when there's an active item.
	if g.ActiveId != 0 && g.ActiveId != owner_id {
		if ImGuiInputFlags_RouteActive : ^flags; ImGuiInputFlags_RouteActive { return false }

		// Cull shortcuts with no modifiers when it could generate a character.
		// e.g. Shortcut(ImGuiKey_G) also generates 'g' character, should not trigger when InputText() is active.
		// but  Shortcut(Ctrl+G) should generally trigger when InputText() is active.
		// TL;DR: lettered shortcut with no mods or with only Alt mod will not trigger while an item reading text input is active.
		// (We cannot filter based on io.InputQueueCharacters[] contents because of trickling and key<>chars submission order are undefined)
		if g.IO.WantTextInput && IsKeyChordPotentiallyCharInput(key_chord) {
			IMGUI_DEBUG_LOG_INPUTROUTING("SetShortcutRouting(%s, flags=%04X, owner_id=0x%08X) -> filtered as potential char input\n", GetKeyChordName(key_chord), flags, owner_id)
			return false
		}

		// ActiveIdUsingAllKeyboardKeys trumps all for ActiveId
		if (flags & ImGuiInputFlags_.ImGuiInputFlags_RouteOverActive) == 0 && g.ActiveIdUsingAllKeyboardKeys {
			key : ImGuiKey = cast(ImGuiKey) (key_chord & !ImGuiKey.ImGuiMod_Mask_)
			if key == ImGuiKey.ImGuiKey_None { key = ConvertSingleModFlagToKey(cast(ImGuiKey) (key_chord & ImGuiKey.ImGuiMod_Mask_)) }
			if key >= ImGuiKey_Keyboard_BEGIN && key < ImGuiKey_Keyboard_END { return false }
		}
	}

	// Where do we evaluate route for?
	focus_scope_id : ImGuiID = g.CurrentFocusScopeId
	if ImGuiInputFlags_RouteFromRootWindow : ^flags; ImGuiInputFlags_RouteFromRootWindow {
		// See PushFocusScope() call in Begin()
		focus_scope_id = g.CurrentWindow.RootWindow.ID
	}

	score : i32 = CalcRoutingScore(focus_scope_id, owner_id, flags)
	IMGUI_DEBUG_LOG_INPUTROUTING("SetShortcutRouting(%s, flags=%04X, owner_id=0x%08X) -> score %d\n", GetKeyChordName(key_chord), flags, owner_id, score)
	if score == 255 { return false }

	// Submit routing for NEXT frame (assuming score is sufficient)
	// FIXME: Could expose a way to use a "serve last" policy for same score resolution (using <= instead of <).
	routing_data : ^ImGuiKeyRoutingData = GetShortcutRoutingData(key_chord)
	//const bool set_route = (flags & ImGuiInputFlags_ServeLast) ? (score <= routing_data->RoutingNextScore) : (score < routing_data->RoutingNextScore);
	if score < routing_data.RoutingNextScore {
		routing_data.RoutingNext = owner_id
		routing_data.RoutingNextScore = cast(ImU8) score
	}

	// Return routing state for CURRENT frame
	if routing_data.RoutingCurr == owner_id { IMGUI_DEBUG_LOG_INPUTROUTING("--> granting current route\n") }
	return routing_data.RoutingCurr == owner_id
}

// Currently unused by core (but used by tests)
// Note: this cannot be turned into GetShortcutRouting() because we do the owner_id->routing_id translation, name would be more misleading.
TestShortcutRouting :: proc(key_chord : ImGuiKeyChord, owner_id : ImGuiID) -> bool
{
	routing_id : ImGuiID = GetRoutingIdFromOwnerId(owner_id)
	key_chord = FixupKeyChord(key_chord)
	routing_data : ^ImGuiKeyRoutingData = GetShortcutRoutingData(key_chord); // FIXME: Could avoid creating entry.
	return routing_data.RoutingCurr == routing_id
}

// Inputs Utilities: Keyboard/Mouse/Gamepad
// - the ImGuiKey enum contains all possible keyboard, mouse and gamepad inputs (e.g. ImGuiKey_A, ImGuiKey_MouseLeft, ImGuiKey_GamepadDpadUp...).
// - (legacy: before v1.87, we used ImGuiKey to carry native/user indices as defined by each backends. This was obsoleted in 1.87 (2022-02) and completely removed in 1.91.5 (2024-11). See https://github.com/ocornut/imgui/issues/4921)
// - (legacy: any use of ImGuiKey will assert when key < 512 to detect passing legacy native/user indices)
// is key being held.
// [EXPERIMENTAL] High-Level: Input Access functions w/ support for Key/Input Ownership
// - Important: legacy IsKeyPressed(ImGuiKey, bool repeat=true) _DEFAULTS_ to repeat, new IsKeyPressed() requires _EXPLICIT_ ImGuiInputFlags_Repeat flag.
// - Expected to be later promoted to public API, the prototypes are designed to replace existing ones (since owner_id can default to Any == 0)
// - Specifying a value for 'ImGuiID owner' will test that EITHER the key is NOT owned (UNLESS locked), EITHER the key is owned by 'owner'.
//   Legacy functions use ImGuiKeyOwner_Any meaning that they typically ignore ownership, unless a call to SetKeyOwner() explicitly used ImGuiInputFlags_LockThisFrame or ImGuiInputFlags_LockUntilRelease.
// - Binding generators may want to ignore those for now, or suffix them with Ex() until we decide if this gets moved into public API.
// Note that Dear ImGui doesn't know the meaning/semantic of ImGuiKey from 0..511: they are legacy native keycodes.
// Consider transitioning from 'IsKeyDown(MY_ENGINE_KEY_A)' (<1.87) to IsKeyDown(ImGuiKey_A) (>= 1.87)
IsKeyDown_0 :: proc(key : ImGuiKey) -> bool
{
	return IsKeyDown(key, ImGuiKeyOwner_Any)
}

// Inputs Utilities: Keyboard/Mouse/Gamepad
// - the ImGuiKey enum contains all possible keyboard, mouse and gamepad inputs (e.g. ImGuiKey_A, ImGuiKey_MouseLeft, ImGuiKey_GamepadDpadUp...).
// - (legacy: before v1.87, we used ImGuiKey to carry native/user indices as defined by each backends. This was obsoleted in 1.87 (2022-02) and completely removed in 1.91.5 (2024-11). See https://github.com/ocornut/imgui/issues/4921)
// - (legacy: any use of ImGuiKey will assert when key < 512 to detect passing legacy native/user indices)
// is key being held.
// [EXPERIMENTAL] High-Level: Input Access functions w/ support for Key/Input Ownership
// - Important: legacy IsKeyPressed(ImGuiKey, bool repeat=true) _DEFAULTS_ to repeat, new IsKeyPressed() requires _EXPLICIT_ ImGuiInputFlags_Repeat flag.
// - Expected to be later promoted to public API, the prototypes are designed to replace existing ones (since owner_id can default to Any == 0)
// - Specifying a value for 'ImGuiID owner' will test that EITHER the key is NOT owned (UNLESS locked), EITHER the key is owned by 'owner'.
//   Legacy functions use ImGuiKeyOwner_Any meaning that they typically ignore ownership, unless a call to SetKeyOwner() explicitly used ImGuiInputFlags_LockThisFrame or ImGuiInputFlags_LockUntilRelease.
// - Binding generators may want to ignore those for now, or suffix them with Ex() until we decide if this gets moved into public API.
IsKeyDown_1 :: proc(key : ImGuiKey, owner_id : ImGuiID) -> bool
{
	key_data : ^ImGuiKeyData = GetKeyData(key)
	if !key_data.Down { return false }
	if !TestKeyOwner(key, owner_id) { return false }
	return true
}

// was key pressed (went from !Down to Down)? if repeat=true, uses io.KeyRepeatDelay / KeyRepeatRate
// Important: when transitioning from old to new IsKeyPressed(): old API has "bool repeat = true", so would default to repeat. New API requiress explicit ImGuiInputFlags_Repeat.
IsKeyPressed_0 :: proc(key : ImGuiKey, repeat : bool) -> bool
{
	return IsKeyPressed(key, repeat ? ImGuiInputFlags_.ImGuiInputFlags_Repeat : ImGuiInputFlags_.ImGuiInputFlags_None, ImGuiKeyOwner_Any)
}

// was key pressed (went from !Down to Down)? if repeat=true, uses io.KeyRepeatDelay / KeyRepeatRate
// Important: when transitioning from old to new IsKeyPressed(): old API has "bool repeat = true", so would default to repeat. New API requiress explicit ImGuiInputFlags_Repeat.
// Important: unlike legacy IsKeyPressed(ImGuiKey, bool repeat=true) which DEFAULT to repeat, this requires EXPLICIT repeat.
IsKeyPressed_1 :: proc(key : ImGuiKey, flags : ImGuiInputFlags, owner_id : ImGuiID) -> bool
{
	key_data : ^ImGuiKeyData = GetKeyData(key)
	if !key_data.Down {
		// In theory this should already be encoded as (DownDuration < 0.0f), but testing this facilitates eating mechanism (until we finish work on key ownership)return false
	}
	t : f32 = key_data.DownDuration
	if t < 0.0 { return false }
	IM_ASSERT((flags & !ImGuiInputFlagsPrivate_.ImGuiInputFlags_SupportedByIsKeyPressed) == 0); // Passing flags not supported by this function!
	if flags & (ImGuiInputFlagsPrivate_.ImGuiInputFlags_RepeatRateMask_ | ImGuiInputFlagsPrivate_.ImGuiInputFlags_RepeatUntilMask_) {
		// Setting any _RepeatXXX option enables _Repeatflags |= ImGuiInputFlags_.ImGuiInputFlags_Repeat
	}

	pressed : bool = (t == 0.0)
	if !pressed && (flags & ImGuiInputFlags_.ImGuiInputFlags_Repeat) != 0 {
		repeat_delay : f32; repeat_rate : f32
		GetTypematicRepeatRate(flags, &repeat_delay, &repeat_rate)
		pressed = (t > repeat_delay) && GetKeyPressedAmount(key, repeat_delay, repeat_rate) > 0
		if pressed && (flags & ImGuiInputFlagsPrivate_.ImGuiInputFlags_RepeatUntilMask_) {
			// Slightly bias 'key_pressed_time' as DownDuration is an accumulation of DeltaTime which we compare to an absolute time value.
			// Ideally we'd replace DownDuration with KeyPressedTime but it would break user's code.
			g : ^ImGuiContext = GImGui^
			key_pressed_time : f64 = g.Time - t + 0.00001
			if (flags & ImGuiInputFlagsPrivate_.ImGuiInputFlags_RepeatUntilKeyModsChange) && (g.LastKeyModsChangeTime > key_pressed_time) { pressed = false }
			if (flags & ImGuiInputFlagsPrivate_.ImGuiInputFlags_RepeatUntilKeyModsChangeFromNone) && (g.LastKeyModsChangeFromNoneTime > key_pressed_time) { pressed = false }
			if (flags & ImGuiInputFlagsPrivate_.ImGuiInputFlags_RepeatUntilOtherKeyPress) && (g.LastKeyboardKeyPressTime > key_pressed_time) { pressed = false }
		}
	}
	if !pressed { return false }
	if !TestKeyOwner(key, owner_id) { return false }
	return true
}

// was key released (went from Down to !Down)?
IsKeyReleased_0 :: proc(key : ImGuiKey) -> bool
{
	return IsKeyReleased(key, ImGuiKeyOwner_Any)
}

// was key released (went from Down to !Down)?
IsKeyReleased_1 :: proc(key : ImGuiKey, owner_id : ImGuiID) -> bool
{
	key_data : ^ImGuiKeyData = GetKeyData(key)
	if key_data.DownDurationPrev < 0.0 || key_data.Down { return false }
	if !TestKeyOwner(key, owner_id) { return false }
	return true
}

// Inputs Utilities: Mouse
// - To refer to a mouse button, you may use named enums in your code e.g. ImGuiMouseButton_Left, ImGuiMouseButton_Right.
// - You can also use regular integer: it is forever guaranteed that 0=Left, 1=Right, 2=Middle.
// - Dragging operations are only reported after mouse has moved a certain distance away from the initial clicking position (see 'lock_threshold' and 'io.MouseDraggingThreshold')
// is mouse button held?
IsMouseDown_0 :: proc(button : ImGuiMouseButton) -> bool
{
	g : ^ImGuiContext = GImGui^
	IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown))
	return g.IO.MouseDown[button] && TestKeyOwner(MouseButtonToKey(button), ImGuiKeyOwner_Any)// should be same as IsKeyDown(MouseButtonToKey(button), ImGuiKeyOwner_Any), but this allows legacy code hijacking the io.Mousedown[] array.
}

// Inputs Utilities: Mouse
// - To refer to a mouse button, you may use named enums in your code e.g. ImGuiMouseButton_Left, ImGuiMouseButton_Right.
// - You can also use regular integer: it is forever guaranteed that 0=Left, 1=Right, 2=Middle.
// - Dragging operations are only reported after mouse has moved a certain distance away from the initial clicking position (see 'lock_threshold' and 'io.MouseDraggingThreshold')
// is mouse button held?
IsMouseDown_1 :: proc(button : ImGuiMouseButton, owner_id : ImGuiID) -> bool
{
	g : ^ImGuiContext = GImGui^
	IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown))
	return g.IO.MouseDown[button] && TestKeyOwner(MouseButtonToKey(button), owner_id)// Should be same as IsKeyDown(MouseButtonToKey(button), owner_id), but this allows legacy code hijacking the io.Mousedown[] array.
}

// did mouse button clicked? (went from !Down to Down). Same as GetMouseClickedCount() == 1.
IsMouseClicked_0 :: proc(button : ImGuiMouseButton, repeat : bool) -> bool
{
	return IsMouseClicked(button, repeat ? ImGuiInputFlags_.ImGuiInputFlags_Repeat : ImGuiInputFlags_.ImGuiInputFlags_None, ImGuiKeyOwner_Any)
}

// did mouse button clicked? (went from !Down to Down). Same as GetMouseClickedCount() == 1.
IsMouseClicked_1 :: proc(button : ImGuiMouseButton, flags : ImGuiInputFlags, owner_id : ImGuiID) -> bool
{
	g : ^ImGuiContext = GImGui^
	IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown))
	if !g.IO.MouseDown[button] {
		// In theory this should already be encoded as (DownDuration < 0.0f), but testing this facilitates eating mechanism (until we finish work on key ownership)return false
	}
	t : f32 = g.IO.MouseDownDuration[button]
	if t < 0.0 { return false }
	IM_ASSERT((flags & !ImGuiInputFlagsPrivate_.ImGuiInputFlags_SupportedByIsMouseClicked) == 0); // Passing flags not supported by this function! // FIXME: Could support RepeatRate and RepeatUntil flags here.

	repeat : bool = (flags & ImGuiInputFlags_.ImGuiInputFlags_Repeat) != 0
	pressed : bool = (t == 0.0) || (repeat && t > g.IO.KeyRepeatDelay && CalcTypematicRepeatAmount(t - g.IO.DeltaTime, t, g.IO.KeyRepeatDelay, g.IO.KeyRepeatRate) > 0)
	if !pressed { return false }

	if !TestKeyOwner(MouseButtonToKey(button), owner_id) { return false }

	return true
}

// did mouse button released? (went from Down to !Down)
IsMouseReleased_0 :: proc(button : ImGuiMouseButton) -> bool
{
	g : ^ImGuiContext = GImGui^
	IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown))
	return g.IO.MouseReleased[button] && TestKeyOwner(MouseButtonToKey(button), ImGuiKeyOwner_Any)// Should be same as IsKeyReleased(MouseButtonToKey(button), ImGuiKeyOwner_Any)
}

// did mouse button released? (went from Down to !Down)
IsMouseReleased_1 :: proc(button : ImGuiMouseButton, owner_id : ImGuiID) -> bool
{
	g : ^ImGuiContext = GImGui^
	IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown))
	return g.IO.MouseReleased[button] && TestKeyOwner(MouseButtonToKey(button), owner_id)// Should be same as IsKeyReleased(MouseButtonToKey(button), owner_id)
}

// did mouse button double-clicked? Same as GetMouseClickedCount() == 2. (note that a double-click will also report IsMouseClicked() == true)
IsMouseDoubleClicked_0 :: proc(button : ImGuiMouseButton) -> bool
{
	g : ^ImGuiContext = GImGui^
	IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown))
	return g.IO.MouseClickedCount[button] == 2 && TestKeyOwner(MouseButtonToKey(button), ImGuiKeyOwner_Any)
}

// did mouse button double-clicked? Same as GetMouseClickedCount() == 2. (note that a double-click will also report IsMouseClicked() == true)
IsMouseDoubleClicked_1 :: proc(button : ImGuiMouseButton, owner_id : ImGuiID) -> bool
{
	g : ^ImGuiContext = GImGui^
	IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown))
	return g.IO.MouseClickedCount[button] == 2 && TestKeyOwner(MouseButtonToKey(button), owner_id)
}

// return the number of successive mouse-clicks at the time where a click happen (otherwise 0).
GetMouseClickedCount :: proc(button : ImGuiMouseButton) -> i32
{
	g : ^ImGuiContext = GImGui^
	IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown))
	return g.IO.MouseClickedCount[button]
}

// is mouse hovering given bounding rect (in screen space). clipped by current clipping settings, but disregarding of other consideration of focus/window ordering/popup-block.
// Test if mouse cursor is hovering given rectangle
// NB- Rectangle is clipped by our current clip setting
// NB- Expand the rectangle to be generous on imprecise inputs systems (g.Style.TouchExtraPadding)
IsMouseHoveringRect :: proc(r_min : ^ImVec2, r_max : ^ImVec2, clip : bool) -> bool
{
	g : ^ImGuiContext = GImGui^

	// Clip
	rect_clipped : ImRect; init(&rect_clipped, r_min, r_max)
	if clip { ClipWith(&rect_clipped, g.CurrentWindow.ClipRect) }

	// Hit testing, expanded for touch input
	if !ContainsWithPad(&rect_clipped, g.IO.MousePos, g.Style.TouchExtraPadding) { return false }
	if !Overlaps(&GetMainRect(g.MouseViewport), rect_clipped) { return false }
	return true
}

// Return if a mouse click/drag went past the given threshold. Valid to call during the MouseReleased frame.
// [Internal] This doesn't test if the button is pressed
IsMouseDragPastThreshold :: proc(button : ImGuiMouseButton, lock_threshold : f32) -> bool
{
	g : ^ImGuiContext = GImGui^
	IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown))
	if lock_threshold < 0.0 { lock_threshold = g.IO.MouseDragThreshold }
	return g.IO.MouseDragMaxDistanceSqr[button] >= lock_threshold * lock_threshold
}

// is mouse dragging? (uses io.MouseDraggingThreshold if lock_threshold < 0.0f)
IsMouseDragging :: proc(button : ImGuiMouseButton, lock_threshold : f32) -> bool
{
	g : ^ImGuiContext = GImGui^
	IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown))
	if !g.IO.MouseDown[button] { return false }
	return IsMouseDragPastThreshold(button, lock_threshold)
}

// shortcut to ImGui::GetIO().MousePos provided by user, to be consistent with other calls
GetMousePos :: proc() -> ImVec2
{
	g : ^ImGuiContext = GImGui^
	return g.IO.MousePos
}

// This is called TeleportMousePos() and not SetMousePos() to emphasis that setting MousePosPrev will effectively clear mouse delta as well.
// It is expected you only call this if (io.BackendFlags & ImGuiBackendFlags_HasSetMousePos) is set and supported by backend.
TeleportMousePos :: proc(pos : ^ImVec2)
{
	g : ^ImGuiContext = GImGui^
	g.IO.MousePosPrev = pos; g.IO.MousePos = g.IO.MousePosPrev
	g.IO.MouseDelta = ImVec2(0.0, 0.0)
	g.IO.WantSetMousePos = true
	//IMGUI_DEBUG_LOG_IO("TeleportMousePos: (%.1f,%.1f)\n", io.MousePos.x, io.MousePos.y);
}

// retrieve mouse position at the time of opening popup we have BeginPopup() into (helper to avoid user backing that value themselves)
// NB: prefer to call right after BeginPopup(). At the time Selectable/MenuItem is activated, the popup is already closed!
GetMousePosOnOpeningCurrentPopup :: proc() -> ImVec2
{
	g : ^ImGuiContext = GImGui^
	if g.BeginPopupStack.Size > 0 { return g.OpenPopupStack[g.BeginPopupStack.Size - 1].OpenMousePos }
	return g.IO.MousePos
}

// by convention we use (-FLT_MAX,-FLT_MAX) to denote that there is no mouse available
// We typically use ImVec2(-FLT_MAX,-FLT_MAX) to denote an invalid mouse position.
IsMousePosValid :: proc(mouse_pos : ^ImVec2) -> bool
{
	// The assert is only to silence a false-positive in XCode Static Analysis.
	// Because GImGui is not dereferenced in every code path, the static analyzer assume that it may be NULL (which it doesn't for other functions).
	IM_ASSERT(GImGui != nil)
	MOUSE_INVALID : f32 = -256000.0
	p : ImVec2 = mouse_pos ? mouse_pos^ : GImGui.IO.MousePos
	return p.x >= MOUSE_INVALID && p.y >= MOUSE_INVALID
}

// [WILL OBSOLETE] is any mouse button held? This was designed for backends, but prefer having backend maintain a mask of held mouse buttons, because upcoming input queue system will make this invalid.
// [WILL OBSOLETE] This was designed for backends, but prefer having backend maintain a mask of held mouse buttons, because upcoming input queue system will make this invalid.
IsAnyMouseDown :: proc() -> bool
{
	g : ^ImGuiContext = GImGui^
	for n : i32 = 0; n < IM_ARRAYSIZE(g.IO.MouseDown); post_incr(&n) { if g.IO.MouseDown[n] { return true } }

	return false
}

// return the delta from the initial clicking position while the mouse button is pressed or was just released. This is locked and return 0.0f until the mouse moves past a distance threshold at least once (uses io.MouseDraggingThreshold if lock_threshold < 0.0f)
// Return the delta from the initial clicking position while the mouse button is clicked or was just released.
// This is locked and return 0.0f until the mouse moves past a distance threshold at least once.
// NB: This is only valid if IsMousePosValid(). backends in theory should always keep mouse position valid when dragging even outside the client window.
GetMouseDragDelta :: proc(button : ImGuiMouseButton, lock_threshold : f32) -> ImVec2
{
	g : ^ImGuiContext = GImGui^
	IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown))
	if lock_threshold < 0.0 { lock_threshold = g.IO.MouseDragThreshold }
	if g.IO.MouseDown[button] || g.IO.MouseReleased[button] { if g.IO.MouseDragMaxDistanceSqr[button] >= lock_threshold * lock_threshold { if IsMousePosValid(&g.IO.MousePos) && IsMousePosValid(&g.IO.MouseClickedPos[button]) { return g.IO.MousePos - g.IO.MouseClickedPos[button] } } }
	return ImVec2(0.0, 0.0)
}

//
ResetMouseDragDelta :: proc(button : ImGuiMouseButton)
{
	g : ^ImGuiContext = GImGui^
	IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown))
	// NB: We don't need to reset g.IO.MouseDragMaxDistanceSqr
	g.IO.MouseClickedPos[button] = g.IO.MousePos
}

// get desired mouse cursor shape. Important: reset in ImGui::NewFrame(), this is updated during the frame. valid before Render(). If you use software rendering by setting io.MouseDrawCursor ImGui will render those for you
// Get desired mouse cursor shape.
// Important: this is meant to be used by a platform backend, it is reset in ImGui::NewFrame(),
// updated during the frame, and locked in EndFrame()/Render().
// If you use software rendering by setting io.MouseDrawCursor then Dear ImGui will render those for you
GetMouseCursor :: proc() -> ImGuiMouseCursor
{
	g : ^ImGuiContext = GImGui^
	return g.MouseCursor
}

// set desired mouse cursor shape
// We intentionally accept values of ImGuiMouseCursor that are outside our bounds, in case users needs to hack-in a custom cursor value.
// Custom cursors may be handled by custom backends. If you are using a standard backend and want to hack in a custom cursor, you may
// handle it before the backend _NewFrame() call and temporarily set ImGuiConfigFlags_NoMouseCursorChange during the backend _NewFrame() call.
SetMouseCursor :: proc(cursor_type : ImGuiMouseCursor)
{
	g : ^ImGuiContext = GImGui^
	g.MouseCursor = cursor_type
}

UpdateAliasKey :: proc(key : ImGuiKey, v : bool, analog_value : f32)
{
	IM_ASSERT(IsAliasKey(key))
	key_data : ^ImGuiKeyData = GetKeyData(key)
	key_data.Down = v
	key_data.AnalogValue = analog_value
}

// [Internal] Do not use directly
GetMergedModsFromKeys :: proc() -> ImGuiKeyChord
{
	mods : ImGuiKeyChord = 0
	if IsKeyDown(ImGuiKey.ImGuiMod_Ctrl) { mods |= ImGuiKey.ImGuiMod_Ctrl }
	if IsKeyDown(ImGuiKey.ImGuiMod_Shift) { mods |= ImGuiKey.ImGuiMod_Shift }
	if IsKeyDown(ImGuiKey.ImGuiMod_Alt) { mods |= ImGuiKey.ImGuiMod_Alt }
	if IsKeyDown(ImGuiKey.ImGuiMod_Super) { mods |= ImGuiKey.ImGuiMod_Super }
	return mods
}

// Inputs
UpdateKeyboardInputs :: proc()
{
	g : ^ImGuiContext = GImGui^
	io : ^ImGuiIO = g.IO

	if io.ConfigFlags & ImGuiConfigFlags_.ImGuiConfigFlags_NoKeyboard { ClearInputKeys(&io) }

	// Update aliases
	for n : i32 = 0; n < ImGuiMouseButton_.ImGuiMouseButton_COUNT; post_incr(&n) { UpdateAliasKey(MouseButtonToKey(n), io.MouseDown[n], io.MouseDown[n] ? 1.0 : 0.0) }

	UpdateAliasKey(ImGuiKey.ImGuiKey_MouseWheelX, io.MouseWheelH != 0.0, io.MouseWheelH)
	UpdateAliasKey(ImGuiKey.ImGuiKey_MouseWheelY, io.MouseWheel != 0.0, io.MouseWheel)

	// Synchronize io.KeyMods and io.KeyCtrl/io.KeyShift/etc. values.
	// - New backends (1.87+): send io.AddKeyEvent(ImGuiMod_XXX) ->                                      -> (here) deriving io.KeyMods + io.KeyXXX from key array.
	// - Legacy backends:      set io.KeyXXX bools               -> (above) set key array from io.KeyXXX -> (here) deriving io.KeyMods + io.KeyXXX from key array.
	// So with legacy backends the 4 values will do a unnecessary back-and-forth but it makes the code simpler and future facing.
	prev_key_mods : ImGuiKeyChord = io.KeyMods
	io.KeyMods = GetMergedModsFromKeys()
	io.KeyCtrl = (io.KeyMods & ImGuiKey.ImGuiMod_Ctrl) != 0
	io.KeyShift = (io.KeyMods & ImGuiKey.ImGuiMod_Shift) != 0
	io.KeyAlt = (io.KeyMods & ImGuiKey.ImGuiMod_Alt) != 0
	io.KeySuper = (io.KeyMods & ImGuiKey.ImGuiMod_Super) != 0
	if prev_key_mods != io.KeyMods { g.LastKeyModsChangeTime = g.Time }
	if prev_key_mods != io.KeyMods && prev_key_mods == 0 { g.LastKeyModsChangeFromNoneTime = g.Time }

	// Clear gamepad data if disabled
	if (io.BackendFlags & ImGuiBackendFlags_.ImGuiBackendFlags_HasGamepad) == 0 { for key : i32 = ImGuiKey_Gamepad_BEGIN; key < ImGuiKey_Gamepad_END; post_incr(&key) {
	io.KeysData[key - ImGuiKey.ImGuiKey_NamedKey_BEGIN].Down = false
	io.KeysData[key - ImGuiKey.ImGuiKey_NamedKey_BEGIN].AnalogValue = 0.0
} }

	// Update keys
	for key : i32 = ImGuiKey.ImGuiKey_NamedKey_BEGIN; key < ImGuiKey.ImGuiKey_NamedKey_END; post_incr(&key) {
		key_data : ^ImGuiKeyData = &io.KeysData[key - ImGuiKey.ImGuiKey_NamedKey_BEGIN]
		key_data.DownDurationPrev = key_data.DownDuration
		key_data.DownDuration = key_data.Down ? (key_data.DownDuration < 0.0 ? 0.0 : key_data.DownDuration + io.DeltaTime) : -1.0
		if key_data.DownDuration == 0.0 {
			if IsKeyboardKey(cast(ImGuiKey) key) { g.LastKeyboardKeyPressTime = g.Time }
			else if key == ImGuiKey.ImGuiKey_ReservedForModCtrl || key == ImGuiKey.ImGuiKey_ReservedForModShift || key == ImGuiKey.ImGuiKey_ReservedForModAlt || key == ImGuiKey.ImGuiKey_ReservedForModSuper { g.LastKeyboardKeyPressTime = g.Time }
		}
	}

	// Update keys/input owner (named keys only): one entry per key
	for key : ImGuiKey = ImGuiKey.ImGuiKey_NamedKey_BEGIN; key < ImGuiKey.ImGuiKey_NamedKey_END; key = cast(ImGuiKey) (key + 1) {
		key_data : ^ImGuiKeyData = &io.KeysData[key - ImGuiKey.ImGuiKey_NamedKey_BEGIN]
		owner_data : ^ImGuiKeyOwnerData = &g.KeysOwnerData[key - ImGuiKey.ImGuiKey_NamedKey_BEGIN]
		owner_data.OwnerCurr = owner_data.OwnerNext
		if !key_data.Down {
			// Important: ownership is released on the frame after a release. Ensure a 'MouseDown -> CloseWindow -> MouseUp' chain doesn't lead to someone else seeing the MouseUp.owner_data.OwnerNext = ImGuiKeyOwner_NoOwner
		}
		owner_data.LockUntilRelease = owner_data.LockUntilRelease && key_data.Down; owner_data.LockThisFrame = owner_data.LockUntilRelease; // Clear LockUntilRelease when key is not Down anymore
	}

	// Update key routing (for e.g. shortcuts)
	UpdateKeyRoutingTable(&g.KeysRoutingTable)
}

UpdateMouseInputs :: proc()
{
	g : ^ImGuiContext = GImGui^
	io : ^ImGuiIO = g.IO

	// Mouse Wheel swapping flag
	// As a standard behavior holding SHIFT while using Vertical Mouse Wheel triggers Horizontal scroll instead
	// - We avoid doing it on OSX as it the OS input layer handles this already.
	// - FIXME: However this means when running on OSX over Emscripten, Shift+WheelY will incur two swapping (1 in OS, 1 here), canceling the feature.
	// - FIXME: When we can distinguish e.g. touchpad scroll events from mouse ones, we'll set this accordingly based on input source.
	io.MouseWheelRequestAxisSwap = io.KeyShift && !io.ConfigMacOSXBehaviors

	// Round mouse position to avoid spreading non-rounded position (e.g. UpdateManualResize doesn't support them well)
	if IsMousePosValid(&io.MousePos) { g.MouseLastValidPos = ImFloor(io.MousePos); io.MousePos = g.MouseLastValidPos }

	// If mouse just appeared or disappeared (usually denoted by -FLT_MAX components) we cancel out movement in MouseDelta
	if IsMousePosValid(&io.MousePos) && IsMousePosValid(&io.MousePosPrev) { io.MouseDelta = io.MousePos - io.MousePosPrev }
	else { io.MouseDelta = ImVec2(0.0, 0.0) }

	// Update stationary timer.
	// FIXME: May need to rework again to have some tolerance for occasional small movement, while being functional on high-framerates.
	mouse_stationary_threshold : f32 = (io.MouseSource == ImGuiMouseSource.ImGuiMouseSource_Mouse) ? 2.0 : 3.0; // Slightly higher threshold for ImGuiMouseSource_TouchScreen/ImGuiMouseSource_Pen, may need rework.
	mouse_stationary : bool = (ImLengthSqr(io.MouseDelta) <= mouse_stationary_threshold * mouse_stationary_threshold)
	g.MouseStationaryTimer = mouse_stationary ? (g.MouseStationaryTimer + io.DeltaTime) : 0.0
	//IMGUI_DEBUG_LOG("%.4f\n", g.MouseStationaryTimer);

	// If mouse moved we re-enable mouse hovering in case it was disabled by keyboard/gamepad. In theory should use a >0.0f threshold but would need to reset in everywhere we set this to true.
	if io.MouseDelta.x != 0.0 || io.MouseDelta.y != 0.0 { g.NavHighlightItemUnderNav = false }

	for i : i32 = 0; i < IM_ARRAYSIZE(io.MouseDown); post_incr(&i) {
		io.MouseClicked[i] = io.MouseDown[i] && io.MouseDownDuration[i] < 0.0
		io.MouseClickedCount[i] = 0; // Will be filled below
		io.MouseReleased[i] = !io.MouseDown[i] && io.MouseDownDuration[i] >= 0.0
		io.MouseDownDurationPrev[i] = io.MouseDownDuration[i]
		io.MouseDownDuration[i] = io.MouseDown[i] ? (io.MouseDownDuration[i] < 0.0 ? 0.0 : io.MouseDownDuration[i] + io.DeltaTime) : -1.0
		if io.MouseClicked[i] {
			is_repeated_click : bool = false
			if cast(f32) (g.Time - io.MouseClickedTime[i]) < io.MouseDoubleClickTime {
				delta_from_click_pos : ImVec2 = IsMousePosValid(&io.MousePos) ? (io.MousePos - io.MouseClickedPos[i]) : ImVec2(0.0, 0.0)
				if ImLengthSqr(delta_from_click_pos) < io.MouseDoubleClickMaxDist * io.MouseDoubleClickMaxDist { is_repeated_click = true }
			}
			if is_repeated_click { post_incr(&io.MouseClickedLastCount[i]) }
			else { io.MouseClickedLastCount[i] = 1 }
			io.MouseClickedTime[i] = g.Time
			io.MouseClickedPos[i] = io.MousePos
			io.MouseClickedCount[i] = io.MouseClickedLastCount[i]
			io.MouseDragMaxDistanceAbs[i] = ImVec2(0.0, 0.0)
			io.MouseDragMaxDistanceSqr[i] = 0.0
		}
		else if io.MouseDown[i] {
			// Maintain the maximum distance we reaching from the initial click position, which is used with dragging threshold
			delta_from_click_pos : ImVec2 = IsMousePosValid(&io.MousePos) ? (io.MousePos - io.MouseClickedPos[i]) : ImVec2(0.0, 0.0)
			io.MouseDragMaxDistanceSqr[i] = ImMax(io.MouseDragMaxDistanceSqr[i], ImLengthSqr(delta_from_click_pos))
			io.MouseDragMaxDistanceAbs[i].x = ImMax(io.MouseDragMaxDistanceAbs[i].x, delta_from_click_pos.x < 0.0 ? -delta_from_click_pos.x : delta_from_click_pos.x)
			io.MouseDragMaxDistanceAbs[i].y = ImMax(io.MouseDragMaxDistanceAbs[i].y, delta_from_click_pos.y < 0.0 ? -delta_from_click_pos.y : delta_from_click_pos.y)
		}

		// We provide io.MouseDoubleClicked[] as a legacy service
		io.MouseDoubleClicked[i] = (io.MouseClickedCount[i] == 2)

		// Clicking any mouse button reactivate mouse hovering which may have been deactivated by keyboard/gamepad navigation
		if io.MouseClicked[i] { g.NavHighlightItemUnderNav = false }
	}
}

LockWheelingWindow :: proc(window : ^ImGuiWindow, wheel_amount : f32)
{
	g : ^ImGuiContext = GImGui^
	if window { g.WheelingWindowReleaseTimer = ImMin(g.WheelingWindowReleaseTimer + ImAbs(wheel_amount) * WINDOWS_MOUSE_WHEEL_SCROLL_LOCK_TIMER, WINDOWS_MOUSE_WHEEL_SCROLL_LOCK_TIMER) }
	else { g.WheelingWindowReleaseTimer = 0.0 }
	if g.WheelingWindow == window { return }
	IMGUI_DEBUG_LOG_IO("[io] LockWheelingWindow() \"%s\"\n", window ? window.Name : "NULL")
	g.WheelingWindow = window
	g.WheelingWindowRefMousePos = g.IO.MousePos
	if window == nil {
		g.WheelingWindowStartFrame = -1
		g.WheelingAxisAvg = ImVec2(0.0, 0.0)
	}
}

FindBestWheelingWindow :: proc(wheel : ^ImVec2) -> ^ImGuiWindow
{
	// For each axis, find window in the hierarchy that may want to use scrolling
	g : ^ImGuiContext = GImGui^
	windows : [2]^ImGuiWindow = {nil, nil}
	for axis : i32 = 0; axis < 2; post_incr(&axis) {
		if wheel[axis] != 0.0 {
			windows[axis] = g.HoveredWindow
			for window : ^ImGuiWindow = g.HoveredWindow; window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_ChildWindow; windows[axis], window = window.ParentWindow, windows[axis] {
				// Bubble up into parent window if:
				// - a child window doesn't allow any scrolling.
				// - a child window has the ImGuiWindowFlags_NoScrollWithMouse flag.
				//// - a child window doesn't need scrolling because it is already at the edge for the direction we are going in (FIXME-WIP)
				has_scrolling : bool = (window.ScrollMax[axis] != 0.0)
				inputs_disabled : bool = (window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoScrollWithMouse) && !(window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoMouseInputs)
				//const bool scrolling_past_limits = (wheel_v < 0.0f) ? (window->Scroll[axis] <= 0.0f) : (window->Scroll[axis] >= window->ScrollMax[axis]);
				if has_scrolling && !inputs_disabled {
					// && !scrolling_past_limits)
					// select this window
					break
				}
			}
		}
	}

	if windows[0] == nil && windows[1] == nil { return nil }

	// If there's only one window or only one axis then there's no ambiguity
	if windows[0] == windows[1] || windows[0] == nil || windows[1] == nil { return windows[1] ? windows[1] : windows[0] }

	// If candidate are different windows we need to decide which one to prioritize
	// - First frame: only find a winner if one axis is zero.
	// - Subsequent frames: only find a winner when one is more than the other.
	if g.WheelingWindowStartFrame == -1 { g.WheelingWindowStartFrame = g.FrameCount }
	if (g.WheelingWindowStartFrame == g.FrameCount && wheel.x != 0.0 && wheel.y != 0.0) || (g.WheelingAxisAvg.x == g.WheelingAxisAvg.y) {
		g.WheelingWindowWheelRemainder = wheel
		return nil
	}
	return (g.WheelingAxisAvg.x > g.WheelingAxisAvg.y) ? windows[0] : windows[1]
}

// Called by NewFrame()
UpdateMouseWheel :: proc()
{
	// Reset the locked window if we move the mouse or after the timer elapses.
	// FIXME: Ideally we could refactor to have one timer for "changing window w/ same axis" and a shorter timer for "changing window or axis w/ other axis" (#3795)
	g : ^ImGuiContext = GImGui^
	if g.WheelingWindow != nil {
		g.WheelingWindowReleaseTimer -= g.IO.DeltaTime
		if IsMousePosValid() && ImLengthSqr(g.IO.MousePos - g.WheelingWindowRefMousePos) > g.IO.MouseDragThreshold * g.IO.MouseDragThreshold { g.WheelingWindowReleaseTimer = 0.0 }
		if g.WheelingWindowReleaseTimer <= 0.0 { LockWheelingWindow(nil, 0.0) }
	}

	wheel : ImVec2
	wheel.x = TestKeyOwner(ImGuiKey.ImGuiKey_MouseWheelX, ImGuiKeyOwner_NoOwner) ? g.IO.MouseWheelH : 0.0
	wheel.y = TestKeyOwner(ImGuiKey.ImGuiKey_MouseWheelY, ImGuiKeyOwner_NoOwner) ? g.IO.MouseWheel : 0.0

	//IMGUI_DEBUG_LOG("MouseWheel X:%.3f Y:%.3f\n", wheel_x, wheel_y);
	mouse_window : ^ImGuiWindow = g.WheelingWindow ? g.WheelingWindow : g.HoveredWindow
	if !mouse_window || mouse_window.Collapsed { return }

	// Zoom / Scale window
	// FIXME-OBSOLETE: This is an old feature, it still works but pretty much nobody is using it and may be best redesigned.
	if wheel.y != 0.0 && g.IO.KeyCtrl && g.IO.FontAllowUserScaling {
		LockWheelingWindow(mouse_window, wheel.y)
		window : ^ImGuiWindow = mouse_window
		new_font_scale : f32 = ImClamp(window.FontWindowScale + g.IO.MouseWheel * 0.10, 0.50, 2.50)
		scale : f32 = new_font_scale / window.FontWindowScale
		window.FontWindowScale = new_font_scale
		if window == window.RootWindow {
			offset : ImVec2 = window.Size * (1.0 - scale) * (g.IO.MousePos - window.Pos) / window.Size
			SetWindowPos(window, window.Pos + offset, 0)
			window.Size = ImTrunc(window.Size * scale)
			window.SizeFull = ImTrunc(window.SizeFull * scale)
		}
		return
	}
	if g.IO.KeyCtrl { return }

	// Mouse wheel scrolling
	// Read about io.MouseWheelRequestAxisSwap and its issue on Mac+Emscripten in UpdateMouseInputs()
	if g.IO.MouseWheelRequestAxisSwap { wheel = ImVec2(wheel.y, 0.0) }

	// Maintain a rough average of moving magnitude on both axises
	// FIXME: should by based on wall clock time rather than frame-counter
	g.WheelingAxisAvg.x = ImExponentialMovingAverage(g.WheelingAxisAvg.x, ImAbs(wheel.x), 30)
	g.WheelingAxisAvg.y = ImExponentialMovingAverage(g.WheelingAxisAvg.y, ImAbs(wheel.y), 30)

	// In the rare situation where FindBestWheelingWindow() had to defer first frame of wheeling due to ambiguous main axis, reinject it now.
	wheel += g.WheelingWindowWheelRemainder
	g.WheelingWindowWheelRemainder = ImVec2(0.0, 0.0)
	if wheel.x == 0.0 && wheel.y == 0.0 { return }

	// Mouse wheel scrolling: find target and apply
	// - don't renew lock if axis doesn't apply on the window.
	// - select a main axis when both axises are being moved.
	if window : ^ImGuiWindow = (g.WheelingWindow ? g.WheelingWindow : FindBestWheelingWindow(wheel)); window { if !(window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoScrollWithMouse) && !(window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoMouseInputs) {
	do_scroll : [2]bool = {wheel.x != 0.0 && window.ScrollMax.x != 0.0, wheel.y != 0.0 && window.ScrollMax.y != 0.0}
	if do_scroll[ImGuiAxis.ImGuiAxis_X] && do_scroll[ImGuiAxis.ImGuiAxis_Y] { do_scroll[(g.WheelingAxisAvg.x > g.WheelingAxisAvg.y) ? ImGuiAxis.ImGuiAxis_Y : ImGuiAxis.ImGuiAxis_X] = false }
	if do_scroll[ImGuiAxis.ImGuiAxis_X] {
		LockWheelingWindow(window, wheel.x)
		max_step : f32 = GetWidth(&window.InnerRect) * 0.67
		scroll_step : f32 = ImTrunc(ImMin(2 * CalcFontSize(window), max_step))
		SetScrollX(window, window.Scroll.x - wheel.x * scroll_step)
		g.WheelingWindowScrolledFrame = g.FrameCount
	}
	if do_scroll[ImGuiAxis.ImGuiAxis_Y] {
		LockWheelingWindow(window, wheel.y)
		max_step : f32 = GetHeight(&window.InnerRect) * 0.67
		scroll_step : f32 = ImTrunc(ImMin(5 * CalcFontSize(window), max_step))
		SetScrollY(window, window.Scroll.y - wheel.y * scroll_step)
		g.WheelingWindowScrolledFrame = g.FrameCount
	}
} }
}

// Override io.WantCaptureKeyboard flag next frame (said flag is left for your application to handle, typically when true it instructs your app to ignore inputs). e.g. force capture keyboard when your widget is being hovered. This is equivalent to setting "io.WantCaptureKeyboard = want_capture_keyboard"; after the next NewFrame() call.
SetNextFrameWantCaptureKeyboard :: proc(want_capture_keyboard : bool)
{
	g : ^ImGuiContext = GImGui^
	g.WantCaptureKeyboardNextFrame = want_capture_keyboard ? 1 : 0
}

// Override io.WantCaptureMouse flag next frame (said flag is left for your application to handle, typical when true it instucts your app to ignore inputs). This is equivalent to setting "io.WantCaptureMouse = want_capture_mouse;" after the next NewFrame() call.
SetNextFrameWantCaptureMouse :: proc(want_capture_mouse : bool)
{
	g : ^ImGuiContext = GImGui^
	g.WantCaptureMouseNextFrame = want_capture_mouse ? 1 : 0
}

when ! IMGUI_DISABLE_DEBUG_TOOLS { // @gen ifndef
GetInputSourceName :: proc(source : ImGuiInputSource) -> ^u8
{
	input_source_names : [^]^u8 = {"None", "Mouse", "Keyboard", "Gamepad"}
	IM_ASSERT(IM_ARRAYSIZE(input_source_names) == ImGuiInputSource.ImGuiInputSource_COUNT && source >= 0 && source < ImGuiInputSource.ImGuiInputSource_COUNT)
	return input_source_names[source]
}
GetMouseSourceName :: proc(source : ImGuiMouseSource) -> ^u8
{
	mouse_source_names : [^]^u8 = {"Mouse", "TouchScreen", "Pen"}
	IM_ASSERT(IM_ARRAYSIZE(mouse_source_names) == ImGuiMouseSource.ImGuiMouseSource_COUNT && source >= 0 && source < ImGuiMouseSource.ImGuiMouseSource_COUNT)
	return mouse_source_names[source]
}
DebugPrintInputEvent :: proc(prefix : ^u8, e : ^ImGuiInputEvent)
{
	g : ^ImGuiContext = GImGui^
	if e.Type == ImGuiInputEventType.ImGuiInputEventType_MousePos {if e.MousePos.PosX == -FLT_MAX && e.MousePos.PosY == -FLT_MAX { IMGUI_DEBUG_LOG_IO("[io] %s: MousePos (-FLT_MAX, -FLT_MAX)\n", prefix) }
		else { IMGUI_DEBUG_LOG_IO("[io] %s: MousePos (%.1f, %.1f) (%s)\n", prefix, e.MousePos.PosX, e.MousePos.PosY, GetMouseSourceName(e.MousePos.MouseSource)) }; return
	}
	if e.Type == ImGuiInputEventType.ImGuiInputEventType_MouseButton {IMGUI_DEBUG_LOG_IO("[io] %s: MouseButton %d %s (%s)\n", prefix, e.MouseButton.Button, e.MouseButton.Down ? "Down" : "Up", GetMouseSourceName(e.MouseButton.MouseSource)); return
	}
	if e.Type == ImGuiInputEventType.ImGuiInputEventType_MouseWheel {IMGUI_DEBUG_LOG_IO("[io] %s: MouseWheel (%.3f, %.3f) (%s)\n", prefix, e.MouseWheel.WheelX, e.MouseWheel.WheelY, GetMouseSourceName(e.MouseWheel.MouseSource)); return
	}
	if e.Type == ImGuiInputEventType.ImGuiInputEventType_MouseViewport {IMGUI_DEBUG_LOG_IO("[io] %s: MouseViewport (0x%08X)\n", prefix, e.MouseViewport.HoveredViewportID); return
	}
	if e.Type == ImGuiInputEventType.ImGuiInputEventType_Key {IMGUI_DEBUG_LOG_IO("[io] %s: Key \"%s\" %s\n", prefix, GetKeyName(e.Key.Key), e.Key.Down ? "Down" : "Up"); return
	}
	if e.Type == ImGuiInputEventType.ImGuiInputEventType_Text {IMGUI_DEBUG_LOG_IO("[io] %s: Text: %c (U+%08X)\n", prefix, e.Text.Char, e.Text.Char); return
	}
	if e.Type == ImGuiInputEventType.ImGuiInputEventType_Focus {IMGUI_DEBUG_LOG_IO("[io] %s: AppFocused %d\n", prefix, e.AppFocused.Focused); return
	}
}
} // preproc endif

// NewFrame
// Process input queue
// We always call this with the value of 'bool g.IO.ConfigInputTrickleEventQueue'.
// - trickle_fast_inputs = false : process all events, turn into flattened input state (e.g. successive down/up/down/up will be lost)
// - trickle_fast_inputs = true  : process as many events as possible (successive down/up/down/up will be trickled over several frames so nothing is lost) (new feature in 1.87)
UpdateInputEvents :: proc(trickle_fast_inputs : bool)
{
	g : ^ImGuiContext = GImGui^
	io : ^ImGuiIO = g.IO

	// Only trickle chars<>key when working with InputText()
	// FIXME: InputText() could parse event trail?
	// FIXME: Could specialize chars<>keys trickling rules for control keys (those not typically associated to characters)
	trickle_interleaved_nonchar_keys_and_text : bool = (trickle_fast_inputs && g.WantTextInputNextFrame == 1)

	mouse_moved : bool = false; mouse_wheeled : bool = false; key_changed : bool = false; key_changed_nonchar : bool = false; text_inputted : bool = false
	mouse_button_changed : i32 = 0x00
	key_changed_mask : ImBitArray(ImGuiKey_NamedKey_COUNT)

	event_n : i32 = 0
	for ; event_n < g.InputEventsQueue.Size; post_incr(&event_n) {
		e : ^ImGuiInputEvent = &g.InputEventsQueue[event_n]
		if e.Type == ImGuiInputEventType.ImGuiInputEventType_MousePos {
			if g.IO.WantSetMousePos { continue }
			// Trickling Rule: Stop processing queued events if we already handled a mouse button change
			event_pos : ImVec2; init(&event_pos, e.MousePos.PosX, e.MousePos.PosY)
			if trickle_fast_inputs && (mouse_button_changed != 0 || mouse_wheeled || key_changed || text_inputted) { break }
			io.MousePos = event_pos
			io.MouseSource = e.MousePos.MouseSource
			mouse_moved = true
		}
		else if e.Type == ImGuiInputEventType.ImGuiInputEventType_MouseButton {
			// Trickling Rule: Stop processing queued events if we got multiple action on the same button
			button : ImGuiMouseButton = e.MouseButton.Button
			IM_ASSERT(button >= 0 && button < ImGuiMouseButton_.ImGuiMouseButton_COUNT)
			if trickle_fast_inputs && ((mouse_button_changed & (1 << button)) || mouse_wheeled) { break }
			if trickle_fast_inputs && e.MouseButton.MouseSource == ImGuiMouseSource.ImGuiMouseSource_TouchScreen && mouse_moved {
				// #2702: TouchScreen have no initial hover.break
			}
			io.MouseDown[button] = e.MouseButton.Down
			io.MouseSource = e.MouseButton.MouseSource
			mouse_button_changed |= (1 << button)
		}
		else if e.Type == ImGuiInputEventType.ImGuiInputEventType_MouseWheel {
			// Trickling Rule: Stop processing queued events if we got multiple action on the event
			if trickle_fast_inputs && (mouse_moved || mouse_button_changed != 0) { break }
			io.MouseWheelH += e.MouseWheel.WheelX
			io.MouseWheel += e.MouseWheel.WheelY
			io.MouseSource = e.MouseWheel.MouseSource
			mouse_wheeled = true
		}
		else if e.Type == ImGuiInputEventType.ImGuiInputEventType_MouseViewport {
			io.MouseHoveredViewport = e.MouseViewport.HoveredViewportID
		}
		else if e.Type == ImGuiInputEventType.ImGuiInputEventType_Key {
			// Trickling Rule: Stop processing queued events if we got multiple action on the same button
			if io.ConfigFlags & ImGuiConfigFlags_.ImGuiConfigFlags_NoKeyboard { continue }
			key : ImGuiKey = e.Key.Key
			IM_ASSERT(key != ImGuiKey.ImGuiKey_None)
			key_data : ^ImGuiKeyData = GetKeyData(key)
			key_data_index : i32 = cast(i32) (key_data - g.IO.KeysData)
			if trickle_fast_inputs && key_data.Down != e.Key.Down && (TestBit(&key_changed_mask, key_data_index) || mouse_button_changed != 0) { break }

			key_is_potentially_for_char_input : bool = IsKeyChordPotentiallyCharInput(GetMergedModsFromKeys() | key)
			if trickle_interleaved_nonchar_keys_and_text && (text_inputted && !key_is_potentially_for_char_input) { break }

			key_data.Down = e.Key.Down
			key_data.AnalogValue = e.Key.AnalogValue
			key_changed = true
			SetBit(&key_changed_mask, key_data_index)
			if trickle_interleaved_nonchar_keys_and_text && !key_is_potentially_for_char_input { key_changed_nonchar = true }
		}
		else if e.Type == ImGuiInputEventType.ImGuiInputEventType_Text {
			if io.ConfigFlags & ImGuiConfigFlags_.ImGuiConfigFlags_NoKeyboard { continue }
			// Trickling Rule: Stop processing queued events if keys/mouse have been interacted with
			if trickle_fast_inputs && (mouse_button_changed != 0 || mouse_moved || mouse_wheeled) { break }
			if trickle_interleaved_nonchar_keys_and_text && key_changed_nonchar { break }
			c : u32 = e.Text.Char
			push_back(&io.InputQueueCharacters, c <= IM_UNICODE_CODEPOINT_MAX ? cast(ImWchar) c : IM_UNICODE_CODEPOINT_INVALID)
			if trickle_interleaved_nonchar_keys_and_text { text_inputted = true }
		}
		else if e.Type == ImGuiInputEventType.ImGuiInputEventType_Focus {
			// We intentionally overwrite this and process in NewFrame(), in order to give a chance
			// to multi-viewports backends to queue AddFocusEvent(false) + AddFocusEvent(true) in same frame.
			focus_lost : bool = !e.AppFocused.Focused
			io.AppFocusLost = focus_lost
		}
		else {
			IM_ASSERT(0 && "Unknown event!")
		}
	}

	// Record trail (for domain-specific applications wanting to access a precise trail)
	//if (event_n != 0) IMGUI_DEBUG_LOG_IO("Processed: %d / Remaining: %d\n", event_n, g.InputEventsQueue.Size - event_n);
	for n : i32 = 0; n < event_n; post_incr(&n) { push_back(&g.InputEventsTrail, g.InputEventsQueue[n]) }

	// [DEBUG]
	when ! IMGUI_DISABLE_DEBUG_TOOLS { // @gen ifndef
	if event_n != 0 && (g.DebugLogFlags & ImGuiDebugLogFlags_.ImGuiDebugLogFlags_EventIO) { for n : i32 = 0; n < g.InputEventsQueue.Size; post_incr(&n) { DebugPrintInputEvent(n < event_n ? "Processed" : "Remaining", &g.InputEventsQueue[n]) } }
	} // preproc endif

	// Remaining events will be processed on the next frame
	if event_n == g.InputEventsQueue.Size { resize(&g.InputEventsQueue, 0) }
	else { erase(&g.InputEventsQueue, g.InputEventsQueue.Data, g.InputEventsQueue.Data + event_n) }

	// Clear buttons state when focus is lost
	// - this is useful so e.g. releasing Alt after focus loss on Alt-Tab doesn't trigger the Alt menu toggle.
	// - we clear in EndFrame() and not now in order allow application/user code polling this flag
	//   (e.g. custom backend may want to clear additional data, custom widgets may want to react with a "canceling" event).
	if g.IO.AppFocusLost {
		ClearInputKeys(&g.IO)
		ClearInputMouse(&g.IO)
	}
}

// [EXPERIMENTAL] Low-Level: Key/Input Ownership
// - The idea is that instead of "eating" a given input, we can link to an owner id.
// - Ownership is most often claimed as a result of reacting to a press/down event (but occasionally may be claimed ahead).
// - Input queries can then read input by specifying ImGuiKeyOwner_Any (== 0), ImGuiKeyOwner_NoOwner (== -1) or a custom ID.
// - Legacy input queries (without specifying an owner or _Any or _None) are equivalent to using ImGuiKeyOwner_Any (== 0).
// - Input ownership is automatically released on the frame after a key is released. Therefore:
//   - for ownership registration happening as a result of a down/press event, the SetKeyOwner() call may be done once (common case).
//   - for ownership registration happening ahead of a down/press event, the SetKeyOwner() call needs to be made every frame (happens if e.g. claiming ownership on hover).
// - SetItemKeyOwner() is a shortcut for common simple case. A custom widget will probably want to call SetKeyOwner() multiple times directly based on its interaction state.
// - This is marked experimental because not all widgets are fully honoring the Set/Test idioms. We will need to move forward step by step.
//   Please open a GitHub Issue to submit your usage scenario or if there's a use case you need solved.
GetKeyOwner :: proc(key : ImGuiKey) -> ImGuiID
{
	if !IsNamedKeyOrMod(key) { return ImGuiKeyOwner_NoOwner }

	g : ^ImGuiContext = GImGui^
	owner_data : ^ImGuiKeyOwnerData = GetKeyOwnerData(&g, key)
	owner_id : ImGuiID = owner_data.OwnerCurr

	if g.ActiveIdUsingAllKeyboardKeys && owner_id != g.ActiveId && owner_id != ImGuiKeyOwner_Any { if key >= ImGuiKey_Keyboard_BEGIN && key < ImGuiKey_Keyboard_END { return ImGuiKeyOwner_NoOwner } }

	return owner_id
}

// Test that key is either not owned, either owned by 'owner_id'
// TestKeyOwner(..., ID)   : (owner == None || owner == ID)
// TestKeyOwner(..., None) : (owner == None)
// TestKeyOwner(..., Any)  : no owner test
// All paths are also testing for key not being locked, for the rare cases that key have been locked with using ImGuiInputFlags_LockXXX flags.
TestKeyOwner :: proc(key : ImGuiKey, owner_id : ImGuiID) -> bool
{
	if !IsNamedKeyOrMod(key) { return true }

	g : ^ImGuiContext = GImGui^
	if g.ActiveIdUsingAllKeyboardKeys && owner_id != g.ActiveId && owner_id != ImGuiKeyOwner_Any { if key >= ImGuiKey_Keyboard_BEGIN && key < ImGuiKey_Keyboard_END { return false } }

	owner_data : ^ImGuiKeyOwnerData = GetKeyOwnerData(&g, key)
	if owner_id == ImGuiKeyOwner_Any { return (owner_data.LockThisFrame == false) }

	// Note: SetKeyOwner() sets OwnerCurr. It is not strictly required for most mouse routing overlap (because of ActiveId/HoveredId
	// are acting as filter before this has a chance to filter), but sane as soon as user tries to look into things.
	// Setting OwnerCurr in SetKeyOwner() is more consistent than testing OwnerNext here: would be inconsistent with getter and other functions.
	if owner_data.OwnerCurr != owner_id {
		if owner_data.LockThisFrame { return false }
		if owner_data.OwnerCurr != ImGuiKeyOwner_NoOwner { return false }
	}

	return true
}

// _LockXXX flags are useful to lock keys away from code which is not input-owner aware.
// When using _LockXXX flags, you can use ImGuiKeyOwner_Any to lock keys from everyone.
// - SetKeyOwner(..., None)              : clears owner
// - SetKeyOwner(..., Any, !Lock)        : illegal (assert)
// - SetKeyOwner(..., Any or None, Lock) : set lock
SetKeyOwner :: proc(key : ImGuiKey, owner_id : ImGuiID, flags : ImGuiInputFlags)
{
	g : ^ImGuiContext = GImGui^
	IM_ASSERT(IsNamedKeyOrMod(key) && (owner_id != ImGuiKeyOwner_Any || (flags & (ImGuiInputFlagsPrivate_.ImGuiInputFlags_LockThisFrame | ImGuiInputFlagsPrivate_.ImGuiInputFlags_LockUntilRelease)))); // Can only use _Any with _LockXXX flags (to eat a key away without an ID to retrieve it)
	IM_ASSERT((flags & !ImGuiInputFlagsPrivate_.ImGuiInputFlags_SupportedBySetKeyOwner) == 0); // Passing flags not supported by this function!
	//IMGUI_DEBUG_LOG("SetKeyOwner(%s, owner_id=0x%08X, flags=%08X)\n", GetKeyName(key), owner_id, flags);

	owner_data : ^ImGuiKeyOwnerData = GetKeyOwnerData(&g, key)
	owner_data.OwnerNext = owner_id; owner_data.OwnerCurr = owner_data.OwnerNext

	// We cannot lock by default as it would likely break lots of legacy code.
	// In the case of using LockUntilRelease while key is not down we still lock during the frame (no key_data->Down test)
	owner_data.LockUntilRelease = (flags & ImGuiInputFlagsPrivate_.ImGuiInputFlags_LockUntilRelease) != 0
	owner_data.LockThisFrame = (flags & ImGuiInputFlagsPrivate_.ImGuiInputFlags_LockThisFrame) != 0 || (owner_data.LockUntilRelease)
}

// Rarely used helper
SetKeyOwnersForKeyChord :: proc(key_chord : ImGuiKeyChord, owner_id : ImGuiID, flags : ImGuiInputFlags)
{
	if ImGuiMod_Ctrl : ^key_chord; ImGuiMod_Ctrl { SetKeyOwner(ImGuiMod_Ctrl, owner_id, flags) }
	if ImGuiMod_Shift : ^key_chord; ImGuiMod_Shift { SetKeyOwner(ImGuiMod_Shift, owner_id, flags) }
	if ImGuiMod_Alt : ^key_chord; ImGuiMod_Alt { SetKeyOwner(ImGuiMod_Alt, owner_id, flags) }
	if ImGuiMod_Super : ^key_chord; ImGuiMod_Super { SetKeyOwner(ImGuiMod_Super, owner_id, flags) }
	if key_chord & !ImGuiKey.ImGuiMod_Mask_ { SetKeyOwner(cast(ImGuiKey) (key_chord & !ImGuiKey.ImGuiMod_Mask_), owner_id, flags) }
}

// Inputs Utilities: Key/Input Ownership [BETA]
// - One common use case would be to allow your items to disable standard inputs behaviors such
//   as Tab or Alt key handling, Mouse Wheel scrolling, etc.
//   e.g. Button(...); SetItemKeyOwner(ImGuiKey_MouseWheelY); to make hovering/activating a button disable wheel for scrolling.
// - Reminder ImGuiKey enum include access to mouse buttons and gamepad, so key ownership can apply to them.
// - Many related features are still in imgui_internal.h. For instance, most IsKeyXXX()/IsMouseXXX() functions have an owner-id-aware version.
// Set key owner to last item ID if it is hovered or active. Equivalent to 'if (IsItemHovered() || IsItemActive()) { SetKeyOwner(key, GetItemID());'.
// Set key owner to last item if it is hovered or active. Equivalent to 'if (IsItemHovered() || IsItemActive()) { SetKeyOwner(key, GetItemID());'.
// This is more or less equivalent to:
//   if (IsItemHovered() || IsItemActive())
//       SetKeyOwner(key, GetItemID());
// Extensive uses of that (e.g. many calls for a single item) may want to manually perform the tests once and then call SetKeyOwner() multiple times.
// More advanced usage scenarios may want to call SetKeyOwner() manually based on different condition.
// Worth noting is that only one item can be hovered and only one item can be active, therefore this usage pattern doesn't need to bother with routing and priority.
SetItemKeyOwner_0 :: proc(key : ImGuiKey, flags : ImGuiInputFlags)
{
	g : ^ImGuiContext = GImGui^
	id : ImGuiID = g.LastItemData.ID
	if id == 0 || (g.HoveredId != id && g.ActiveId != id) { return }
	if (flags & ImGuiInputFlagsPrivate_.ImGuiInputFlags_CondMask_) == 0 { flags |= ImGuiInputFlagsPrivate_.ImGuiInputFlags_CondDefault_ }
	if (g.HoveredId == id && (flags & ImGuiInputFlagsPrivate_.ImGuiInputFlags_CondHovered)) || (g.ActiveId == id && (flags & ImGuiInputFlagsPrivate_.ImGuiInputFlags_CondActive)) {
		IM_ASSERT((flags & !ImGuiInputFlagsPrivate_.ImGuiInputFlags_SupportedBySetItemKeyOwner) == 0); // Passing flags not supported by this function!
		SetKeyOwner(key, id, flags & !ImGuiInputFlagsPrivate_.ImGuiInputFlags_CondMask_)
	}
}

// Inputs Utilities: Key/Input Ownership [BETA]
// - One common use case would be to allow your items to disable standard inputs behaviors such
//   as Tab or Alt key handling, Mouse Wheel scrolling, etc.
//   e.g. Button(...); SetItemKeyOwner(ImGuiKey_MouseWheelY); to make hovering/activating a button disable wheel for scrolling.
// - Reminder ImGuiKey enum include access to mouse buttons and gamepad, so key ownership can apply to them.
// - Many related features are still in imgui_internal.h. For instance, most IsKeyXXX()/IsMouseXXX() functions have an owner-id-aware version.
// Set key owner to last item ID if it is hovered or active. Equivalent to 'if (IsItemHovered() || IsItemActive()) { SetKeyOwner(key, GetItemID());'.
// Set key owner to last item if it is hovered or active. Equivalent to 'if (IsItemHovered() || IsItemActive()) { SetKeyOwner(key, GetItemID());'.
SetItemKeyOwner_1 :: proc(key : ImGuiKey)
{
	SetItemKeyOwner(key, ImGuiInputFlags_.ImGuiInputFlags_None)
}

// was key chord (mods + key) pressed, e.g. you can pass 'ImGuiMod_Ctrl | ImGuiKey_S' as a key-chord. This doesn't do any routing or focus check, please consider using Shortcut() function instead.
// This is the only public API until we expose owner_id versions of the API as replacements.
IsKeyChordPressed_0 :: proc(key_chord : ImGuiKeyChord) -> bool
{
	return IsKeyChordPressed(key_chord, ImGuiInputFlags_.ImGuiInputFlags_None, ImGuiKeyOwner_Any)
}

// was key chord (mods + key) pressed, e.g. you can pass 'ImGuiMod_Ctrl | ImGuiKey_S' as a key-chord. This doesn't do any routing or focus check, please consider using Shortcut() function instead.
// This is equivalent to comparing KeyMods + doing a IsKeyPressed()
IsKeyChordPressed_1 :: proc(key_chord : ImGuiKeyChord, flags : ImGuiInputFlags, owner_id : ImGuiID) -> bool
{
	g : ^ImGuiContext = GImGui^
	key_chord = FixupKeyChord(key_chord)
	mods : ImGuiKey = cast(ImGuiKey) (key_chord & ImGuiKey.ImGuiMod_Mask_)
	if g.IO.KeyMods != mods { return false }

	// Special storage location for mods
	key : ImGuiKey = cast(ImGuiKey) (key_chord & !ImGuiKey.ImGuiMod_Mask_)
	if key == ImGuiKey.ImGuiKey_None { key = ConvertSingleModFlagToKey(mods) }
	if !IsKeyPressed(key, (flags & ImGuiInputFlagsPrivate_.ImGuiInputFlags_RepeatMask_), owner_id) { return false }
	return true
}

SetNextItemShortcut :: proc(key_chord : ImGuiKeyChord, flags : ImGuiInputFlags)
{
	g : ^ImGuiContext = GImGui^
	g.NextItemData.HasFlags |= ImGuiNextItemDataFlags_.ImGuiNextItemDataFlags_HasShortcut
	g.NextItemData.Shortcut = key_chord
	g.NextItemData.ShortcutFlags = flags
}

// Item
// Called from within ItemAdd: at this point we can read from NextItemData and write to LastItemData
ItemHandleShortcut :: proc(id : ImGuiID)
{
	g : ^ImGuiContext = GImGui^
	flags : ImGuiInputFlags = g.NextItemData.ShortcutFlags
	IM_ASSERT((flags & !ImGuiInputFlagsPrivate_.ImGuiInputFlags_SupportedBySetNextItemShortcut) == 0); // Passing flags not supported by SetNextItemShortcut()!

	if g.LastItemData.ItemFlags & ImGuiItemFlagsPrivate_.ImGuiItemFlags_Disabled { return }
	if ImGuiInputFlags_Tooltip : ^flags; ImGuiInputFlags_Tooltip {
		g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_.ImGuiItemStatusFlags_HasShortcut
		g.LastItemData.Shortcut = g.NextItemData.Shortcut
	}
	if !Shortcut(g.NextItemData.Shortcut, flags & ImGuiInputFlagsPrivate_.ImGuiInputFlags_SupportedByShortcut, id) || g.NavActivateId != 0 { return }

	// FIXME: Generalize Activation queue?
	g.NavActivateId = id; // Will effectively disable clipping.
	g.NavActivateFlags = ImGuiActivateFlags_.ImGuiActivateFlags_PreferInput | ImGuiActivateFlags_.ImGuiActivateFlags_FromShortcut
	//if (g.ActiveId == 0 || g.ActiveId == id)
	g.NavActivatePressedId = id; g.NavActivateDownId = g.NavActivatePressedId
	NavHighlightActivated(id)
}

// Inputs Utilities: Shortcut Testing & Routing [BETA]
// - ImGuiKeyChord = a ImGuiKey + optional ImGuiMod_Alt/ImGuiMod_Ctrl/ImGuiMod_Shift/ImGuiMod_Super.
//       ImGuiKey_C                          // Accepted by functions taking ImGuiKey or ImGuiKeyChord arguments)
//       ImGuiMod_Ctrl | ImGuiKey_C          // Accepted by functions taking ImGuiKeyChord arguments)
//   only ImGuiMod_XXX values are legal to combine with an ImGuiKey. You CANNOT combine two ImGuiKey values.
// - The general idea is that several callers may register interest in a shortcut, and only one owner gets it.
//      Parent   -> call Shortcut(Ctrl+S)    // When Parent is focused, Parent gets the shortcut.
//        Child1 -> call Shortcut(Ctrl+S)    // When Child1 is focused, Child1 gets the shortcut (Child1 overrides Parent shortcuts)
//        Child2 -> no call                  // When Child2 is focused, Parent gets the shortcut.
//   The whole system is order independent, so if Child1 makes its calls before Parent, results will be identical.
//   This is an important property as it facilitate working with foreign code or larger codebase.
// - To understand the difference:
//   - IsKeyChordPressed() compares mods and call IsKeyPressed() -> function has no side-effect.
//   - Shortcut() submits a route, routes are resolved, if it currently can be routed it calls IsKeyChordPressed() -> function has (desirable) side-effects as it can prevents another call from getting the route.
// - Visualize registered routes in 'Metrics/Debugger->Inputs'.
// Shortcut Testing & Routing
// - Set Shortcut() and SetNextItemShortcut() in imgui.h
// - When a policy (except for ImGuiInputFlags_RouteAlways *) is set, Shortcut() will register itself with SetShortcutRouting(),
//   allowing the system to decide where to route the input among other route-aware calls.
//   (* using ImGuiInputFlags_RouteAlways is roughly equivalent to calling IsKeyChordPressed(key) and bypassing route registration and check)
// - When using one of the routing option:
//   - The default route is ImGuiInputFlags_RouteFocused (accept inputs if window is in focus stack. Deep-most focused window takes inputs. ActiveId takes inputs over deep-most focused window.)
//   - Routes are requested given a chord (key + modifiers) and a routing policy.
//   - Routes are resolved during NewFrame(): if keyboard modifiers are matching current ones: SetKeyOwner() is called + route is granted for the frame.
//   - Each route may be granted to a single owner. When multiple requests are made we have policies to select the winning route (e.g. deep most window).
//   - Multiple read sites may use the same owner id can all access the granted route.
//   - When owner_id is 0 we use the current Focus Scope ID as a owner ID in order to identify our location.
// - You can chain two unrelated windows in the focus stack using SetWindowParentWindowForFocusRoute()
//   e.g. if you have a tool window associated to a document, and you want document shortcuts to run when the tool is focused.
Shortcut_0 :: proc(key_chord : ImGuiKeyChord, flags : ImGuiInputFlags) -> bool
{
	return Shortcut(key_chord, flags, ImGuiKeyOwner_Any)
}

// Inputs Utilities: Shortcut Testing & Routing [BETA]
// - ImGuiKeyChord = a ImGuiKey + optional ImGuiMod_Alt/ImGuiMod_Ctrl/ImGuiMod_Shift/ImGuiMod_Super.
//       ImGuiKey_C                          // Accepted by functions taking ImGuiKey or ImGuiKeyChord arguments)
//       ImGuiMod_Ctrl | ImGuiKey_C          // Accepted by functions taking ImGuiKeyChord arguments)
//   only ImGuiMod_XXX values are legal to combine with an ImGuiKey. You CANNOT combine two ImGuiKey values.
// - The general idea is that several callers may register interest in a shortcut, and only one owner gets it.
//      Parent   -> call Shortcut(Ctrl+S)    // When Parent is focused, Parent gets the shortcut.
//        Child1 -> call Shortcut(Ctrl+S)    // When Child1 is focused, Child1 gets the shortcut (Child1 overrides Parent shortcuts)
//        Child2 -> no call                  // When Child2 is focused, Parent gets the shortcut.
//   The whole system is order independent, so if Child1 makes its calls before Parent, results will be identical.
//   This is an important property as it facilitate working with foreign code or larger codebase.
// - To understand the difference:
//   - IsKeyChordPressed() compares mods and call IsKeyPressed() -> function has no side-effect.
//   - Shortcut() submits a route, routes are resolved, if it currently can be routed it calls IsKeyChordPressed() -> function has (desirable) side-effects as it can prevents another call from getting the route.
// - Visualize registered routes in 'Metrics/Debugger->Inputs'.
// Shortcut Testing & Routing
// - Set Shortcut() and SetNextItemShortcut() in imgui.h
// - When a policy (except for ImGuiInputFlags_RouteAlways *) is set, Shortcut() will register itself with SetShortcutRouting(),
//   allowing the system to decide where to route the input among other route-aware calls.
//   (* using ImGuiInputFlags_RouteAlways is roughly equivalent to calling IsKeyChordPressed(key) and bypassing route registration and check)
// - When using one of the routing option:
//   - The default route is ImGuiInputFlags_RouteFocused (accept inputs if window is in focus stack. Deep-most focused window takes inputs. ActiveId takes inputs over deep-most focused window.)
//   - Routes are requested given a chord (key + modifiers) and a routing policy.
//   - Routes are resolved during NewFrame(): if keyboard modifiers are matching current ones: SetKeyOwner() is called + route is granted for the frame.
//   - Each route may be granted to a single owner. When multiple requests are made we have policies to select the winning route (e.g. deep most window).
//   - Multiple read sites may use the same owner id can all access the granted route.
//   - When owner_id is 0 we use the current Focus Scope ID as a owner ID in order to identify our location.
// - You can chain two unrelated windows in the focus stack using SetWindowParentWindowForFocusRoute()
//   e.g. if you have a tool window associated to a document, and you want document shortcuts to run when the tool is focused.
Shortcut_1 :: proc(key_chord : ImGuiKeyChord, flags : ImGuiInputFlags, owner_id : ImGuiID) -> bool
{
	g : ^ImGuiContext = GImGui^
	//IMGUI_DEBUG_LOG("Shortcut(%s, flags=%X, owner_id=0x%08X)\n", GetKeyChordName(key_chord, g.TempBuffer.Data, g.TempBuffer.Size), flags, owner_id);

	// When using (owner_id == 0/Any): SetShortcutRouting() will use CurrentFocusScopeId and filter with this, so IsKeyPressed() is fine with he 0/Any.
	if (flags & ImGuiInputFlagsPrivate_.ImGuiInputFlags_RouteTypeMask_) == 0 { flags |= ImGuiInputFlags_.ImGuiInputFlags_RouteFocused }

	// Using 'owner_id == ImGuiKeyOwner_Any/0': auto-assign an owner based on current focus scope (each window has its focus scope by default)
	// Effectively makes Shortcut() always input-owner aware.
	if owner_id == ImGuiKeyOwner_Any || owner_id == ImGuiKeyOwner_NoOwner { owner_id = GetRoutingIdFromOwnerId(owner_id) }

	if g.CurrentItemFlags & ImGuiItemFlagsPrivate_.ImGuiItemFlags_Disabled { return false }

	// Submit route
	if !SetShortcutRouting(key_chord, flags, owner_id) { return false }

	// Default repeat behavior for Shortcut()
	// So e.g. pressing Ctrl+W and releasing Ctrl while holding W will not trigger the W shortcut.
	if (flags & ImGuiInputFlags_.ImGuiInputFlags_Repeat) != 0 && (flags & ImGuiInputFlagsPrivate_.ImGuiInputFlags_RepeatUntilMask_) == 0 { flags |= ImGuiInputFlagsPrivate_.ImGuiInputFlags_RepeatUntilKeyModsChange }

	if !IsKeyChordPressed(key_chord, flags, owner_id) { return false }

	// Claim mods during the press
	SetKeyOwnersForKeyChord(key_chord & ImGuiKey.ImGuiMod_Mask_, owner_id)

	IM_ASSERT((flags & !ImGuiInputFlagsPrivate_.ImGuiInputFlags_SupportedByShortcut) == 0); // Passing flags not supported by this function!
	return true
}

// This is called by IMGUI_CHECKVERSION() macro.
//-----------------------------------------------------------------------------
// [SECTION] ERROR CHECKING, STATE RECOVERY
//-----------------------------------------------------------------------------
// - DebugCheckVersionAndDataLayout() (called via IMGUI_CHECKVERSION() macros)
// - ErrorCheckUsingSetCursorPosToExtendParentBoundaries()
// - ErrorCheckNewFrameSanityChecks()
// - ErrorCheckEndFrameSanityChecks()
// - ErrorRecoveryStoreState()
// - ErrorRecoveryTryToRecoverState()
// - ErrorRecoveryTryToRecoverWindowState()
// - ErrorLog()
//-----------------------------------------------------------------------------

// Verify ABI compatibility between caller code and compiled version of Dear ImGui. This helps detects some build issues.
// Called by IMGUI_CHECKVERSION().
// Verify that the type sizes are matching between the calling file's compilation unit and imgui.cpp's compilation unit
// If this triggers you have mismatched headers and compiled code versions.
// - It could be because of a build issue (using new headers with old compiled code)
// - It could be because of mismatched configuration #define, compilation settings, packing pragma etc.
//   THE CONFIGURATION SETTINGS MENTIONED IN imconfig.h MUST BE SET FOR ALL COMPILATION UNITS INVOLVED WITH DEAR IMGUI.
//   Which is why it is required you put them in your imconfig file (and NOT only before including imgui.h).
//   Otherwise it is possible that different compilation units would see different structure layout.
//   If you don't want to modify imconfig.h you can use the IMGUI_USER_CONFIG define to change filename.
DebugCheckVersionAndDataLayout :: proc(version : ^u8, sz_io : uint, sz_style : uint, sz_vec2 : uint, sz_vec4 : uint, sz_vert : uint, sz_idx : uint) -> bool
{
	error : bool = false
	if strcmp(version, IMGUI_VERSION) != 0 {error = true; IM_ASSERT(strcmp(version, IMGUI_VERSION) == 0 && "Mismatched version string!")
	}
	if sz_io != size_of(ImGuiIO) {error = true; IM_ASSERT(sz_io == size_of(ImGuiIO) && "Mismatched struct layout!")
	}
	if sz_style != size_of(ImGuiStyle) {error = true; IM_ASSERT(sz_style == size_of(ImGuiStyle) && "Mismatched struct layout!")
	}
	if sz_vec2 != size_of(ImVec2) {error = true; IM_ASSERT(sz_vec2 == size_of(ImVec2) && "Mismatched struct layout!")
	}
	if sz_vec4 != size_of(ImVec4) {error = true; IM_ASSERT(sz_vec4 == size_of(ImVec4) && "Mismatched struct layout!")
	}
	if sz_vert != size_of(ImDrawVert) {error = true; IM_ASSERT(sz_vert == size_of(ImDrawVert) && "Mismatched struct layout!")
	}
	if sz_idx != size_of(ImDrawIdx) {error = true; IM_ASSERT(sz_idx == size_of(ImDrawIdx) && "Mismatched struct layout!")
	}
	return !error
}

// Until 1.89 (IMGUI_VERSION_NUM < 18814) it was legal to use SetCursorPos() to extend the boundary of a parent (e.g. window or table cell)
// This is causing issues and ambiguity and we need to retire that.
// See https://github.com/ocornut/imgui/issues/5548 for more details.
// [Scenario 1]
//  Previously this would make the window content size ~200x200:
//    Begin(...) + SetCursorScreenPos(GetCursorScreenPos() + ImVec2(200,200)) + End();  // NOT OK
//  Instead, please submit an item:
//    Begin(...) + SetCursorScreenPos(GetCursorScreenPos() + ImVec2(200,200)) + Dummy(ImVec2(0,0)) + End(); // OK
//  Alternative:
//    Begin(...) + Dummy(ImVec2(200,200)) + End(); // OK
// [Scenario 2]
//  For reference this is one of the issue what we aim to fix with this change:
//    BeginGroup() + SomeItem("foobar") + SetCursorScreenPos(GetCursorScreenPos()) + EndGroup()
//  The previous logic made SetCursorScreenPos(GetCursorScreenPos()) have a side-effect! It would erroneously incorporate ItemSpacing.y after the item into content size, making the group taller!
//  While this code is a little twisted, no-one would expect SetXXX(GetXXX()) to have a side-effect. Using vertical alignment patterns could trigger this issue.
ErrorCheckUsingSetCursorPosToExtendParentBoundaries :: proc()
{
	g : ^ImGuiContext = GImGui^
	window : ^ImGuiWindow = g.CurrentWindow
	IM_ASSERT(window.DC.IsSetPos)
	window.DC.IsSetPos = false
	when IMGUI_DISABLE_OBSOLETE_FUNCTIONS { // @gen ifdef
	if window.DC.CursorPos.x <= window.DC.CursorMaxPos.x && window.DC.CursorPos.y <= window.DC.CursorMaxPos.y { return }
	if window.SkipItems { return }
	IM_ASSERT(0 && "Code uses SetCursorPos()/SetCursorScreenPos() to extend window/parent boundaries. Please submit an item e.g. Dummy() to validate extent.")
	} else { // preproc else
	window.DC.CursorMaxPos = ImMax(window.DC.CursorMaxPos, window.DC.CursorPos)
	} // preproc endif
}

// Error Checking and Debug Tools
ErrorCheckNewFrameSanityChecks :: proc()
{
	g : ^ImGuiContext = GImGui^

	// Check user IM_ASSERT macro
	// (IF YOU GET A WARNING OR COMPILE ERROR HERE: it means your assert macro is incorrectly defined!
	//  If your macro uses multiple statements, it NEEDS to be surrounded by a 'do { ... } while (0)' block.
	//  This is a common C/C++ idiom to allow multiple statements macros to be used in control flow blocks.)
	// #define IM_ASSERT(EXPR)   if (SomeCode(EXPR)) SomeMoreCode();                    // Wrong!
	// #define IM_ASSERT(EXPR)   do { if (SomeCode(EXPR)) SomeMoreCode(); } while (0)   // Correct!
	if true { IM_ASSERT(1) }
	else { IM_ASSERT(0) }

	// Emscripten backends are often imprecise in their submission of DeltaTime. (#6114, #3644)
	// Ideally the Emscripten app/backend should aim to fix or smooth this value and avoid feeding zero, but we tolerate it.
	when __EMSCRIPTEN__ { // @gen ifdef
	if g.IO.DeltaTime <= 0.0 && g.FrameCount > 0 { g.IO.DeltaTime = 0.00001 }
	} // preproc endif

	// Check user data
	// (We pass an error message in the assert expression to make it visible to programmers who are not using a debugger, as most assert handlers display their argument)
	IM_ASSERT(g.Initialized)
	IM_ASSERT((g.IO.DeltaTime > 0.0 || g.FrameCount == 0) && "Need a positive DeltaTime!")
	IM_ASSERT((g.FrameCount == 0 || g.FrameCountEnded == g.FrameCount) && "Forgot to call Render() or EndFrame() at the end of the previous frame?")
	IM_ASSERT(g.IO.DisplaySize.x >= 0.0 && g.IO.DisplaySize.y >= 0.0 && "Invalid DisplaySize value!")
	IM_ASSERT(IsBuilt(g.IO.Fonts) && "Font Atlas not built! Make sure you called ImGui_ImplXXXX_NewFrame() function for renderer backend, which should call io.Fonts->GetTexDataAsRGBA32() / GetTexDataAsAlpha8()")
	IM_ASSERT(g.Style.CurveTessellationTol > 0.0 && "Invalid style setting!")
	IM_ASSERT(g.Style.CircleTessellationMaxError > 0.0 && "Invalid style setting!")
	IM_ASSERT(g.Style.Alpha >= 0.0 && g.Style.Alpha <= 1.0 && "Invalid style setting!"); // Allows us to avoid a few clamps in color computations
	IM_ASSERT(g.Style.WindowMinSize.x >= 1.0 && g.Style.WindowMinSize.y >= 1.0 && "Invalid style setting.")
	IM_ASSERT(g.Style.WindowMenuButtonPosition == ImGuiDir.ImGuiDir_None || g.Style.WindowMenuButtonPosition == ImGuiDir.ImGuiDir_Left || g.Style.WindowMenuButtonPosition == ImGuiDir.ImGuiDir_Right)
	IM_ASSERT(g.Style.ColorButtonPosition == ImGuiDir.ImGuiDir_Left || g.Style.ColorButtonPosition == ImGuiDir.ImGuiDir_Right)

	// Error handling: we do not accept 100% silent recovery! Please contact me if you feel this is getting in your way.
	if g.IO.ConfigErrorRecovery { IM_ASSERT(g.IO.ConfigErrorRecoveryEnableAssert || g.IO.ConfigErrorRecoveryEnableDebugLog || g.IO.ConfigErrorRecoveryEnableTooltip || g.ErrorCallback != nil) }



	// Perform simple check: error if Docking or Viewport are enabled _exactly_ on frame 1 (instead of frame 0 or later), which is a common error leading to loss of .ini data.
	if g.FrameCount == 1 && (g.IO.ConfigFlags & ImGuiConfigFlags_.ImGuiConfigFlags_DockingEnable) && (g.ConfigFlagsLastFrame & ImGuiConfigFlags_.ImGuiConfigFlags_DockingEnable) == 0 { IM_ASSERT(0 && "Please set DockingEnable before the first call to NewFrame()! Otherwise you will lose your .ini settings!") }
	if g.FrameCount == 1 && (g.IO.ConfigFlags & ImGuiConfigFlags_.ImGuiConfigFlags_ViewportsEnable) && (g.ConfigFlagsLastFrame & ImGuiConfigFlags_.ImGuiConfigFlags_ViewportsEnable) == 0 { IM_ASSERT(0 && "Please set ViewportsEnable before the first call to NewFrame()! Otherwise you will lose your .ini settings!") }

	// Perform simple checks: multi-viewport and platform windows support
	if g.IO.ConfigFlags & ImGuiConfigFlags_.ImGuiConfigFlags_ViewportsEnable {
		if (g.IO.BackendFlags & ImGuiBackendFlags_.ImGuiBackendFlags_PlatformHasViewports) && (g.IO.BackendFlags & ImGuiBackendFlags_.ImGuiBackendFlags_RendererHasViewports) {
			IM_ASSERT((g.FrameCount == 0 || g.FrameCount == g.FrameCountPlatformEnded) && "Forgot to call UpdatePlatformWindows() in main loop after EndFrame()? Check examples/ applications for reference.")
			IM_ASSERT(g.PlatformIO.Platform_CreateWindow != nil && "Platform init didn't install handlers?")
			IM_ASSERT(g.PlatformIO.Platform_DestroyWindow != nil && "Platform init didn't install handlers?")
			IM_ASSERT(g.PlatformIO.Platform_GetWindowPos != nil && "Platform init didn't install handlers?")
			IM_ASSERT(g.PlatformIO.Platform_SetWindowPos != nil && "Platform init didn't install handlers?")
			IM_ASSERT(g.PlatformIO.Platform_GetWindowSize != nil && "Platform init didn't install handlers?")
			IM_ASSERT(g.PlatformIO.Platform_SetWindowSize != nil && "Platform init didn't install handlers?")
			IM_ASSERT(g.PlatformIO.Monitors.Size > 0 && "Platform init didn't setup Monitors list?")
			IM_ASSERT((g.Viewports[0].PlatformUserData != nil || g.Viewports[0].PlatformHandle != nil) && "Platform init didn't setup main viewport.")
			if g.IO.ConfigDockingTransparentPayload && (g.IO.ConfigFlags & ImGuiConfigFlags_.ImGuiConfigFlags_DockingEnable) { IM_ASSERT(g.PlatformIO.Platform_SetWindowAlpha != nil && "Platform_SetWindowAlpha handler is required to use io.ConfigDockingTransparent!") }
		}
		else {
			// Disable feature, our backends do not support it
			g.IO.ConfigFlags &= !ImGuiConfigFlags_.ImGuiConfigFlags_ViewportsEnable
		}

		// Perform simple checks on platform monitor data + compute a total bounding box for quick early outs
		for mon in g.PlatformIO.Monitors {
			IM_UNUSED(mon)
			IM_ASSERT(mon.MainSize.x > 0.0 && mon.MainSize.y > 0.0 && "Monitor main bounds not setup properly.")
			IM_ASSERT(Contains(&ImRect(mon.MainPos, mon.MainPos + mon.MainSize), ImRect(mon.WorkPos, mon.WorkPos + mon.WorkSize)) && "Monitor work bounds not setup properly. If you don't have work area information, just copy MainPos/MainSize into them.")
			IM_ASSERT(mon.DpiScale > 0.0 && mon.DpiScale < 99.0 && "Monitor DpiScale is invalid."); // Typical correct values would be between 1.0f and 4.0f
		}
	}
}

ErrorCheckEndFrameSanityChecks :: proc()
{
	// Verify that io.KeyXXX fields haven't been tampered with. Key mods should not be modified between NewFrame() and EndFrame()
	// One possible reason leading to this assert is that your backends update inputs _AFTER_ NewFrame().
	// It is known that when some modal native windows called mid-frame takes focus away, some backends such as GLFW will
	// send key release events mid-frame. This would normally trigger this assertion and lead to sheared inputs.
	// We silently accommodate for this case by ignoring the case where all io.KeyXXX modifiers were released (aka key_mod_flags == 0),
	// while still correctly asserting on mid-frame key press events.
	g : ^ImGuiContext = GImGui^
	key_mods : ImGuiKeyChord = GetMergedModsFromKeys()
	IM_UNUSED(g)
	IM_UNUSED(key_mods)
	IM_ASSERT((key_mods == 0 || g.IO.KeyMods == key_mods) && "Mismatching io.KeyCtrl/io.KeyShift/io.KeyAlt/io.KeySuper vs io.KeyMods")
	IM_UNUSED(key_mods)

	IM_ASSERT(g.CurrentWindowStack.Size == 1)
	IM_ASSERT(g.CurrentWindowStack[0].Window.IsFallbackWindow)
}

// Save current stack sizes. Called e.g. by NewFrame() and by Begin() but may be called for manual recovery.
ErrorRecoveryStoreState :: proc(state_out : ^ImGuiErrorRecoveryState)
{
	g : ^ImGuiContext = GImGui^
	state_out.SizeOfWindowStack = cast(i16) g.CurrentWindowStack.Size
	state_out.SizeOfIDStack = cast(i16) g.CurrentWindow.IDStack.Size
	state_out.SizeOfTreeStack = cast(i16) g.CurrentWindow.DC.TreeDepth; // NOT g.TreeNodeStack.Size which is a partial stack!
	state_out.SizeOfColorStack = cast(i16) g.ColorStack.Size
	state_out.SizeOfStyleVarStack = cast(i16) g.StyleVarStack.Size
	state_out.SizeOfFontStack = cast(i16) g.FontStack.Size
	state_out.SizeOfFocusScopeStack = cast(i16) g.FocusScopeStack.Size
	state_out.SizeOfGroupStack = cast(i16) g.GroupStack.Size
	state_out.SizeOfItemFlagsStack = cast(i16) g.ItemFlagsStack.Size
	state_out.SizeOfBeginPopupStack = cast(i16) g.BeginPopupStack.Size
	state_out.SizeOfDisabledStack = cast(i16) g.DisabledStackSize
}

// Chosen name "Try to recover" over e.g. "Restore" to suggest this is not a 100% guaranteed recovery.
// Called by e.g. EndFrame() but may be called for manual recovery.
// Attempt to recover full window stack.
ErrorRecoveryTryToRecoverState :: proc(state_in : ^ImGuiErrorRecoveryState)
{
	// PVS-Studio V1044 is "Loop break conditions do not depend on the number of iterations"
	g : ^ImGuiContext = GImGui^
	for g.CurrentWindowStack.Size > state_in.SizeOfWindowStack {
		// Recap:
		// - Begin()/BeginChild() return false to indicate the window is collapsed or fully clipped.
		// - Always call a matching End() for each Begin() call, regardless of its return value!
		// - Begin/End and BeginChild/EndChild logic is KNOWN TO BE INCONSISTENT WITH ALL OTHER BEGIN/END FUNCTIONS.
		// - We will fix that in a future major update.
		window : ^ImGuiWindow = g.CurrentWindow
		if window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_ChildWindow {
			if g.CurrentTable != nil && g.CurrentTable.InnerWindow == g.CurrentWindow {
				IM_ASSERT_USER_ERROR(0, "Missing EndTable()")
				EndTable()
			}
			else {
				IM_ASSERT_USER_ERROR(0, "Missing EndChild()")
				EndChild()
			}
		}
		else {
			IM_ASSERT_USER_ERROR(0, "Missing End()")
			End()
		}
	}

	if g.CurrentWindowStack.Size == state_in.SizeOfWindowStack { ErrorRecoveryTryToRecoverWindowState(state_in) }
}

// Called by e.g. End() but may be called for manual recovery.
// Read '// Error Handling [BETA]' block in imgui_internal.h for details.
// Attempt to recover from incorrect usage of BeginXXX/EndXXX/PushXXX/PopXXX calls.
ErrorRecoveryTryToRecoverWindowState :: proc(state_in : ^ImGuiErrorRecoveryState)
{
	g : ^ImGuiContext = GImGui^

	for g.CurrentTable != nil && g.CurrentTable.InnerWindow == g.CurrentWindow {
		IM_ASSERT_USER_ERROR(0, "Missing EndTable()")
		EndTable()
	}

	window : ^ImGuiWindow = g.CurrentWindow

	// FIXME: Can't recover from inside BeginTabItem/EndTabItem yet.
	for g.CurrentTabBar != nil && g.CurrentTabBar.Window == window {
		IM_ASSERT_USER_ERROR(0, "Missing EndTabBar()")
		EndTabBar()
	}

	for g.CurrentMultiSelect != nil && g.CurrentMultiSelect.Storage.Window == window {
		IM_ASSERT_USER_ERROR(0, "Missing EndMultiSelect()")
		EndMultiSelect()
	}

	for window.DC.TreeDepth > state_in.SizeOfTreeStack {
		IM_ASSERT_USER_ERROR(0, "Missing TreePop()")
		TreePop()
	}

	for g.GroupStack.Size > state_in.SizeOfGroupStack {
		IM_ASSERT_USER_ERROR(0, "Missing EndGroup()")
		EndGroup()
	}

	IM_ASSERT(g.GroupStack.Size == state_in.SizeOfGroupStack)
	for window.IDStack.Size > state_in.SizeOfIDStack {
		IM_ASSERT_USER_ERROR(0, "Missing PopID()")
		PopID()
	}

	for g.DisabledStackSize > state_in.SizeOfDisabledStack {
		IM_ASSERT_USER_ERROR(0, "Missing EndDisabled()")
		if g.CurrentItemFlags & ImGuiItemFlagsPrivate_.ImGuiItemFlags_Disabled { EndDisabled() }
		else {
			EndDisabledOverrideReenable()
			back(&g.CurrentWindowStack).DisabledOverrideReenable = false
		}
	}

	IM_ASSERT(g.DisabledStackSize == state_in.SizeOfDisabledStack)
	for g.ColorStack.Size > state_in.SizeOfColorStack {
		IM_ASSERT_USER_ERROR(0, "Missing PopStyleColor()")
		PopStyleColor()
	}

	for g.ItemFlagsStack.Size > state_in.SizeOfItemFlagsStack {
		IM_ASSERT_USER_ERROR(0, "Missing PopItemFlag()")
		PopItemFlag()
	}

	for g.StyleVarStack.Size > state_in.SizeOfStyleVarStack {
		IM_ASSERT_USER_ERROR(0, "Missing PopStyleVar()")
		PopStyleVar()
	}

	for g.FontStack.Size > state_in.SizeOfFontStack {
		IM_ASSERT_USER_ERROR(0, "Missing PopFont()")
		PopFont()
	}

	for g.FocusScopeStack.Size > state_in.SizeOfFocusScopeStack {
		IM_ASSERT_USER_ERROR(0, "Missing PopFocusScope()")
		PopFocusScope()
	}

	//IM_ASSERT(g.FocusScopeStack.Size == state_in->SizeOfFocusScopeStack);
}

// Error handling, State Recovery
ErrorLog :: proc(msg : ^u8) -> bool
{
	g : ^ImGuiContext = GImGui^

	// Output to debug log
	when ! IMGUI_DISABLE_DEBUG_TOOLS { // @gen ifndef
	window : ^ImGuiWindow = g.CurrentWindow

	if g.IO.ConfigErrorRecoveryEnableDebugLog {
		if g.ErrorFirst { IMGUI_DEBUG_LOG_ERROR("[imgui-error] (current settings: Assert=%d, Log=%d, Tooltip=%d)\n", g.IO.ConfigErrorRecoveryEnableAssert, g.IO.ConfigErrorRecoveryEnableDebugLog, g.IO.ConfigErrorRecoveryEnableTooltip) }
		IMGUI_DEBUG_LOG_ERROR("[imgui-error] In window '%s': %s\n", window ? window.Name : "NULL", msg)
	}
	g.ErrorFirst = false

	// Output to tooltip
	if g.IO.ConfigErrorRecoveryEnableTooltip {
		if g.WithinFrameScope && BeginErrorTooltip() {
			if g.ErrorCountCurrentFrame < 20 {
				Text("In window '%s': %s", window ? window.Name : "NULL", msg)
				if window && (!window.IsFallbackWindow || window.WasActive) { AddRect(GetForegroundDrawList(window), window.Pos, window.Pos + window.Size, IM_COL32(255, 0, 0, 255)) }
			}
			if g.ErrorCountCurrentFrame == 20 { Text("(and more errors)") }
			// EndFrame() will amend debug buttons to this window, after all errors have been submitted.
			EndErrorTooltip()
		}
		post_incr(&g.ErrorCountCurrentFrame)
	}
	} // preproc endif

	// Output to callback
	if g.ErrorCallback != nil { ErrorCallback(&g, &g, g.ErrorCallbackUserData, msg) }

	// Return whether we should assert
	return g.IO.ConfigErrorRecoveryEnableAssert
}

ErrorCheckEndFrameFinalizeErrorTooltip :: proc()
{
	when ! IMGUI_DISABLE_DEBUG_TOOLS { // @gen ifndef
	g : ^ImGuiContext = GImGui^
	if g.DebugDrawIdConflicts != 0 && g.IO.KeyCtrl == false { g.DebugDrawIdConflictsCount = g.HoveredIdPreviousFrameItemCount }
	if g.DebugDrawIdConflicts != 0 && g.DebugItemPickerActive == false && BeginErrorTooltip() {
		Text("Programmer error: %d visible items with conflicting ID!", g.DebugDrawIdConflictsCount)
		BulletText("Code should use PushID()/PopID() in loops, or append \"##xx\" to same-label identifiers!")
		BulletText("Empty label e.g. Button(\"\") == same ID as parent widget/node. Use Button(\"##xx\") instead!")
		//BulletText("Code intending to use duplicate ID may use e.g. PushItemFlag(ImGuiItemFlags_AllowDuplicateId, true); ... PopItemFlag()"); // Not making this too visible for fear of it being abused.
		BulletText("Set io.ConfigDebugHighlightIdConflicts=false to disable this warning in non-programmers builds.")
		Separator()
		Text("(Hold CTRL to: use")
		SameLine()
		if SmallButton("Item Picker") { DebugStartItemPicker() }
		SameLine()
		Text("to break in item call-stack, or")
		SameLine()
		if SmallButton("Open FAQ->About ID Stack System") && g.PlatformIO.Platform_OpenInShellFn != nil { Platform_OpenInShellFn(&g.PlatformIO, &g, "https://github.com/ocornut/imgui/blob/master/docs/FAQ.md#qa-usage") }
		EndErrorTooltip()
	}

	if g.ErrorCountCurrentFrame > 0 && BeginErrorTooltip() {
		// Amend at end of frame
		Separator()
		Text("(Hold CTRL to:")
		SameLine()
		if SmallButton("Enable Asserts") { g.IO.ConfigErrorRecoveryEnableAssert = true }
		//SameLine();
		//if (SmallButton("Hide Error Tooltips"))
		//    g.IO.ConfigErrorRecoveryEnableTooltip = false; // Too dangerous
		SameLine(0, 0)
		Text(")")
		EndErrorTooltip()
	}
	} // preproc endif
}

// Pseudo-tooltip. Follow mouse until CTRL is held. When CTRL is held we lock position, allowing to click it.
BeginErrorTooltip :: proc() -> bool
{
	g : ^ImGuiContext = GImGui^
	window : ^ImGuiWindow = FindWindowByName("##Tooltip_Error")
	use_locked_pos : bool = (g.IO.KeyCtrl && window && window.WasActive)
	PushStyleColor(ImGuiCol_.ImGuiCol_PopupBg, ImLerp(g.Style.Colors[ImGuiCol_.ImGuiCol_PopupBg], ImVec4(1.0, 0.0, 0.0, 1.0), 0.15))
	if use_locked_pos { SetNextWindowPos(g.ErrorTooltipLockedPos) }
	is_visible : bool = Begin("##Tooltip_Error", nil, ImGuiWindowFlags_.ImGuiWindowFlags_Tooltip | ImGuiWindowFlags_.ImGuiWindowFlags_NoDecoration | ImGuiWindowFlags_.ImGuiWindowFlags_NoMove | ImGuiWindowFlags_.ImGuiWindowFlags_NoResize | ImGuiWindowFlags_.ImGuiWindowFlags_NoSavedSettings | ImGuiWindowFlags_.ImGuiWindowFlags_AlwaysAutoResize)
	PopStyleColor()
	if is_visible && g.CurrentWindow.BeginCount == 1 {
		SeparatorText("MESSAGE FROM DEAR IMGUI")
		BringWindowToDisplayFront(g.CurrentWindow)
		BringWindowToFocusFront(g.CurrentWindow)
		g.ErrorTooltipLockedPos = GetWindowPos()
	}
	else if !is_visible {
		End()
	}
	return is_visible
}

EndErrorTooltip :: proc()
{
	End()
}

//-----------------------------------------------------------------------------
// [SECTION] ITEM SUBMISSION
//-----------------------------------------------------------------------------
// - KeepAliveID()
// - ItemAdd()
//-----------------------------------------------------------------------------

// Code not using ItemAdd() may need to call this manually otherwise ActiveId will be cleared. In IMGUI_VERSION_NUM < 18717 this was called by GetID().
KeepAliveID :: proc(id : ImGuiID)
{
	g : ^ImGuiContext = GImGui^
	if g.ActiveId == id { g.ActiveIdIsAlive = id }
	if g.ActiveIdPreviousFrame == id { g.ActiveIdPreviousFrameIsAlive = true }
}

// Declare item bounding box for clipping and interaction.
// Note that the size can be different than the one provided to ItemSize(). Typically, widgets that spread over available surface
// declare their minimum size requirement to ItemSize() and provide a larger region to ItemAdd() which is used drawing/interaction.
// THIS IS IN THE PERFORMANCE CRITICAL PATH (UNTIL THE CLIPPING TEST AND EARLY-RETURN)

ItemAdd :: proc(bb : ^ImRect, id : ImGuiID, nav_bb_arg : ^ImRect, extra_flags : ImGuiItemFlags) -> bool
{
	g : ^ImGuiContext = GImGui^
	window : ^ImGuiWindow = g.CurrentWindow

	// Set item data
	// (DisplayRect is left untouched, made valid when ImGuiItemStatusFlags_HasDisplayRect is set)
	g.LastItemData.ID = id
	g.LastItemData.Rect = bb
	g.LastItemData.NavRect = nav_bb_arg ? nav_bb_arg^ : bb
	g.LastItemData.ItemFlags = g.CurrentItemFlags | g.NextItemData.ItemFlags | extra_flags
	g.LastItemData.StatusFlags = ImGuiItemStatusFlags_.ImGuiItemStatusFlags_None
	// Note: we don't copy 'g.NextItemData.SelectionUserData' to an hypothetical g.LastItemData.SelectionUserData: since the former is not cleared.

	if id != 0 {
		KeepAliveID(id)

		// Directional navigation processing
		// Runs prior to clipping early-out
		//  (a) So that NavInitRequest can be honored, for newly opened windows to select a default widget
		//  (b) So that we can scroll up/down past clipped items. This adds a small O(N) cost to regular navigation requests
		//      unfortunately, but it is still limited to one window. It may not scale very well for windows with ten of
		//      thousands of item, but at least NavMoveRequest is only set on user interaction, aka maximum once a frame.
		//      We could early out with "if (is_clipped && !g.NavInitRequest) return false;" but when we wouldn't be able
		//      to reach unclipped widgets. This would work if user had explicit scrolling control (e.g. mapped on a stick).
		// We intentionally don't check if g.NavWindow != NULL because g.NavAnyRequest should only be set when it is non null.
		// If we crash on a NULL g.NavWindow we need to fix the bug elsewhere.
		if !(g.LastItemData.ItemFlags & ImGuiItemFlags_.ImGuiItemFlags_NoNav) {
			// FIMXE-NAV: investigate changing the window tests into a simple 'if (g.NavFocusScopeId == g.CurrentFocusScopeId)' test.
			window.DC.NavLayersActiveMaskNext |= (1 << window.DC.NavLayerCurrent)
			if g.NavId == id || g.NavAnyRequest { if g.NavWindow.RootWindowForNav == window.RootWindowForNav { if window == g.NavWindow || ((window.ChildFlags | g.NavWindow.ChildFlags) & ImGuiChildFlags_.ImGuiChildFlags_NavFlattened) { NavProcessItem() } } }
		}

		if g.NextItemData.HasFlags & ImGuiNextItemDataFlags_.ImGuiNextItemDataFlags_HasShortcut { ItemHandleShortcut(id) }
	}

	// Lightweight clear of SetNextItemXXX data.
	g.NextItemData.HasFlags = ImGuiNextItemDataFlags_.ImGuiNextItemDataFlags_None
	g.NextItemData.ItemFlags = ImGuiItemFlags_.ImGuiItemFlags_None

	when IMGUI_ENABLE_TEST_ENGINE { // @gen ifdef
	if id != 0 { IMGUI_TEST_ENGINE_ITEM_ADD(id, g.LastItemData.NavRect, &g.LastItemData) }
	} // preproc endif

	// Clipping test
	// (this is an inline copy of IsClippedEx() so we can reuse the is_rect_visible value, otherwise we'd do 'if (IsClippedEx(bb, id)) return false')
	// g.NavActivateId is not necessarily == g.NavId, in the case of remote activation (e.g. shortcuts)
	is_rect_visible : bool = Overlaps(&bb, window.ClipRect)
	if !is_rect_visible { if id == 0 || (id != g.ActiveId && id != g.ActiveIdPreviousFrame && id != g.NavId && id != g.NavActivateId) { if !g.ItemUnclipByLog { return false } } }

	// [DEBUG]
	when ! IMGUI_DISABLE_DEBUG_TOOLS { // @gen ifndef
	if id != 0 {
		if id == g.DebugLocateId { DebugLocateItemResolveWithLastItem() }

		// [DEBUG] People keep stumbling on this problem and using "" as identifier in the root of a window instead of "##something".
		// Empty identifier are valid and useful in a small amount of cases, but 99.9% of the time you want to use "##something".
		// READ THE FAQ: https://dearimgui.com/faq
		IM_ASSERT(id != window.ID && "Cannot have an empty ID at the root of a window. If you need an empty label, use ## and read the FAQ about how the ID Stack works!")
	}
	//if (g.IO.KeyAlt) window->DrawList->AddRect(bb.Min, bb.Max, IM_COL32(255,255,0,120)); // [DEBUG]
	//if ((g.LastItemData.ItemFlags & ImGuiItemFlags_NoNav) == 0)
	//    window->DrawList->AddRect(g.LastItemData.NavRect.Min, g.LastItemData.NavRect.Max, IM_COL32(255,255,0,255)); // [DEBUG]
	} // preproc endif

	// We need to calculate this now to take account of the current clipping rectangle (as items like Selectable may change them)
	if is_rect_visible { g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_.ImGuiItemStatusFlags_Visible }
	if IsMouseHoveringRect(bb.Min, bb.Max) { g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_.ImGuiItemStatusFlags_HoveredRect }
	return true
}


// Basic Helpers for widget code
// FIXME: This is a misleading API since we expect CursorPos to be bb.Min.
//-----------------------------------------------------------------------------
// [SECTION] LAYOUT
//-----------------------------------------------------------------------------
// - ItemSize()
// - SameLine()
// - GetCursorScreenPos()
// - SetCursorScreenPos()
// - GetCursorPos(), GetCursorPosX(), GetCursorPosY()
// - SetCursorPos(), SetCursorPosX(), SetCursorPosY()
// - GetCursorStartPos()
// - Indent()
// - Unindent()
// - SetNextItemWidth()
// - PushItemWidth()
// - PushMultiItemsWidths()
// - PopItemWidth()
// - CalcItemWidth()
// - CalcItemSize()
// - GetTextLineHeight()
// - GetTextLineHeightWithSpacing()
// - GetFrameHeight()
// - GetFrameHeightWithSpacing()
// - GetContentRegionMax()
// - GetContentRegionAvail(),
// - BeginGroup()
// - EndGroup()
// Also see in imgui_widgets: tab bars, and in imgui_tables: tables, columns.
//-----------------------------------------------------------------------------

// Advance cursor given item size for layout.
// Register minimum needed size so it can extend the bounding box used for auto-fit calculation.
// See comments in ItemAdd() about how/why the size provided to ItemSize() vs ItemAdd() may often different.
// THIS IS IN THE PERFORMANCE CRITICAL PATH.

ItemSize_1 :: proc(size : ^ImVec2, text_baseline_y : f32)
{
	g : ^ImGuiContext = GImGui^
	window : ^ImGuiWindow = g.CurrentWindow
	if window.SkipItems { return }

	// We increase the height in this function to accommodate for baseline offset.
	// In theory we should be offsetting the starting position (window->DC.CursorPos), that will be the topic of a larger refactor,
	// but since ItemSize() is not yet an API that moves the cursor (to handle e.g. wrapping) enlarging the height has the same effect.
	offset_to_match_baseline_y : f32 = (text_baseline_y >= 0) ? ImMax(0.0, window.DC.CurrLineTextBaseOffset - text_baseline_y) : 0.0

	line_y1 : f32 = window.DC.IsSameLine ? window.DC.CursorPosPrevLine.y : window.DC.CursorPos.y
	line_height : f32 = ImMax(window.DC.CurrLineSize.y, window.DC.CursorPos.y - line_y1 + size.y + offset_to_match_baseline_y)

	// Always align ourselves on pixel boundaries
	//if (g.IO.KeyAlt) window->DrawList->AddRect(window->DC.CursorPos, window->DC.CursorPos + ImVec2(size.x, line_height), IM_COL32(255,0,0,200)); // [DEBUG]
	window.DC.CursorPosPrevLine.x = window.DC.CursorPos.x + size.x
	window.DC.CursorPosPrevLine.y = line_y1
	window.DC.CursorPos.x = IM_TRUNC(window.Pos.x + window.DC.Indent.x + window.DC.ColumnsOffset.x); // Next line
	window.DC.CursorPos.y = IM_TRUNC(line_y1 + line_height + g.Style.ItemSpacing.y); // Next line
	window.DC.CursorMaxPos.x = ImMax(window.DC.CursorMaxPos.x, window.DC.CursorPosPrevLine.x)
	window.DC.CursorMaxPos.y = ImMax(window.DC.CursorMaxPos.y, window.DC.CursorPos.y - g.Style.ItemSpacing.y)
	//if (g.IO.KeyAlt) window->DrawList->AddCircle(window->DC.CursorMaxPos, 3.0f, IM_COL32(255,0,0,255), 4); // [DEBUG]

	window.DC.PrevLineSize.y = line_height
	window.DC.CurrLineSize.y = 0.0
	window.DC.PrevLineTextBaseOffset = ImMax(window.DC.CurrLineTextBaseOffset, text_baseline_y)
	window.DC.CurrLineTextBaseOffset = 0.0
	window.DC.IsSetPos = false; window.DC.IsSameLine = window.DC.IsSetPos

	// Horizontal layout mode
	if window.DC.LayoutType == ImGuiLayoutType_.ImGuiLayoutType_Horizontal { SameLine() }
}


// call between widgets or groups to layout them horizontally. X position given in window coordinates.
// Gets back to previous line and continue with horizontal layout
//      offset_from_start_x == 0 : follow right after previous item
//      offset_from_start_x != 0 : align to specified x position (relative to window/group left)
//      spacing_w < 0            : use default spacing if offset_from_start_x == 0, no spacing if offset_from_start_x != 0
//      spacing_w >= 0           : enforce spacing amount
SameLine :: proc(offset_from_start_x : f32, spacing_w : f32)
{
	g : ^ImGuiContext = GImGui^
	window : ^ImGuiWindow = g.CurrentWindow
	if window.SkipItems { return }

	if offset_from_start_x != 0.0 {
		if spacing_w < 0.0 { spacing_w = 0.0 }
		window.DC.CursorPos.x = window.Pos.x - window.Scroll.x + offset_from_start_x + spacing_w + window.DC.GroupOffset.x + window.DC.ColumnsOffset.x
		window.DC.CursorPos.y = window.DC.CursorPosPrevLine.y
	}
	else {
		if spacing_w < 0.0 { spacing_w = g.Style.ItemSpacing.x }
		window.DC.CursorPos.x = window.DC.CursorPosPrevLine.x + spacing_w
		window.DC.CursorPos.y = window.DC.CursorPosPrevLine.y
	}
	window.DC.CurrLineSize = window.DC.PrevLineSize
	window.DC.CurrLineTextBaseOffset = window.DC.PrevLineTextBaseOffset
	window.DC.IsSameLine = true
}

// Layout cursor positioning
// - By "cursor" we mean the current output position.
// - The typical widget behavior is to output themselves at the current cursor position, then move the cursor one line down.
// - You can call SameLine() between widgets to undo the last carriage return and output at the right of the preceding widget.
// - YOU CAN DO 99% OF WHAT YOU NEED WITH ONLY GetCursorScreenPos() and GetContentRegionAvail().
// - Attention! We currently have inconsistencies between window-local and absolute positions we will aim to fix with future API:
//    - Absolute coordinate:        GetCursorScreenPos(), SetCursorScreenPos(), all ImDrawList:: functions. -> this is the preferred way forward.
//    - Window-local coordinates:   SameLine(offset), GetCursorPos(), SetCursorPos(), GetCursorStartPos(), PushTextWrapPos()
//    - Window-local coordinates:   GetContentRegionMax(), GetWindowContentRegionMin(), GetWindowContentRegionMax() --> all obsoleted. YOU DON'T NEED THEM.
// - GetCursorScreenPos() = GetCursorPos() + GetWindowPos(). GetWindowPos() is almost only ever useful to convert from window-local to absolute coordinates. Try not to use it.
// cursor position, absolute coordinates. THIS IS YOUR BEST FRIEND (prefer using this rather than GetCursorPos(), also more useful to work with ImDrawList API).
GetCursorScreenPos :: proc() -> ImVec2
{
	window : ^ImGuiWindow = GetCurrentWindowRead()
	return window.DC.CursorPos
}

// cursor position, absolute coordinates. THIS IS YOUR BEST FRIEND.
SetCursorScreenPos :: proc(pos : ^ImVec2)
{
	window : ^ImGuiWindow = GetCurrentWindow()
	window.DC.CursorPos = pos
	//window->DC.CursorMaxPos = ImMax(window->DC.CursorMaxPos, window->DC.CursorPos);
	window.DC.IsSetPos = true
}

// [window-local] cursor position in window-local coordinates. This is not your best friend.
// User generally sees positions in window coordinates. Internally we store CursorPos in absolute screen coordinates because it is more convenient.
// Conversion happens as we pass the value to user, but it makes our naming convention confusing because GetCursorPos() == (DC.CursorPos - window.Pos). May want to rename 'DC.CursorPos'.
GetCursorPos :: proc() -> ImVec2
{
	window : ^ImGuiWindow = GetCurrentWindowRead()
	return window.DC.CursorPos - window.Pos + window.Scroll
}

// [window-local] "
GetCursorPosX :: proc() -> f32
{
	window : ^ImGuiWindow = GetCurrentWindowRead()
	return window.DC.CursorPos.x - window.Pos.x + window.Scroll.x
}

// [window-local] "
GetCursorPosY :: proc() -> f32
{
	window : ^ImGuiWindow = GetCurrentWindowRead()
	return window.DC.CursorPos.y - window.Pos.y + window.Scroll.y
}

// [window-local] "
SetCursorPos :: proc(local_pos : ^ImVec2)
{
	window : ^ImGuiWindow = GetCurrentWindow()
	window.DC.CursorPos = window.Pos - window.Scroll + local_pos
	//window->DC.CursorMaxPos = ImMax(window->DC.CursorMaxPos, window->DC.CursorPos);
	window.DC.IsSetPos = true
}

// [window-local] "
SetCursorPosX :: proc(x : f32)
{
	window : ^ImGuiWindow = GetCurrentWindow()
	window.DC.CursorPos.x = window.Pos.x - window.Scroll.x + x
	//window->DC.CursorMaxPos.x = ImMax(window->DC.CursorMaxPos.x, window->DC.CursorPos.x);
	window.DC.IsSetPos = true
}

// [window-local] "
SetCursorPosY :: proc(y : f32)
{
	window : ^ImGuiWindow = GetCurrentWindow()
	window.DC.CursorPos.y = window.Pos.y - window.Scroll.y + y
	//window->DC.CursorMaxPos.y = ImMax(window->DC.CursorMaxPos.y, window->DC.CursorPos.y);
	window.DC.IsSetPos = true
}

// [window-local] initial cursor position, in window-local coordinates. Call GetCursorScreenPos() after Begin() to get the absolute coordinates version.
GetCursorStartPos :: proc() -> ImVec2
{
	window : ^ImGuiWindow = GetCurrentWindowRead()
	return window.DC.CursorStartPos - window.Pos
}

// move content position toward the right, by indent_w, or style.IndentSpacing if indent_w <= 0
Indent :: proc(indent_w : f32)
{
	g : ^ImGuiContext = GImGui^
	window : ^ImGuiWindow = GetCurrentWindow()
	window.DC.Indent.x += (indent_w != 0.0) ? indent_w : g.Style.IndentSpacing
	window.DC.CursorPos.x = window.Pos.x + window.DC.Indent.x + window.DC.ColumnsOffset.x
}

// move content position back to the left, by indent_w, or style.IndentSpacing if indent_w <= 0
Unindent :: proc(indent_w : f32)
{
	g : ^ImGuiContext = GImGui^
	window : ^ImGuiWindow = GetCurrentWindow()
	window.DC.Indent.x -= (indent_w != 0.0) ? indent_w : g.Style.IndentSpacing
	window.DC.CursorPos.x = window.Pos.x + window.DC.Indent.x + window.DC.ColumnsOffset.x
}

// set width of the _next_ common large "item+label" widget. >0.0f: width in pixels, <0.0f align xx pixels to the right of window (so -FLT_MIN always align width to the right side)
// Affect large frame+labels widgets only.
SetNextItemWidth :: proc(item_width : f32)
{
	g : ^ImGuiContext = GImGui^
	g.NextItemData.HasFlags |= ImGuiNextItemDataFlags_.ImGuiNextItemDataFlags_HasWidth
	g.NextItemData.Width = item_width
}

// Parameters stacks (current window)
// push width of items for common large "item+label" widgets. >0.0f: width in pixels, <0.0f align xx pixels to the right of window (so -FLT_MIN always align width to the right side).
// FIXME: Remove the == 0.0f behavior?
PushItemWidth :: proc(item_width : f32)
{
	g : ^ImGuiContext = GImGui^
	window : ^ImGuiWindow = g.CurrentWindow
	push_back(&window.DC.ItemWidthStack, window.DC.ItemWidth); // Backup current width
	window.DC.ItemWidth = (item_width == 0.0 ? window.ItemWidthDefault : item_width)
	g.NextItemData.HasFlags &= !ImGuiNextItemDataFlags_.ImGuiNextItemDataFlags_HasWidth
}

PushMultiItemsWidths :: proc(components : i32, w_full : f32)
{
	g : ^ImGuiContext = GImGui^
	window : ^ImGuiWindow = g.CurrentWindow
	IM_ASSERT(components > 0)
	style : ^ImGuiStyle = g.Style
	push_back(&window.DC.ItemWidthStack, window.DC.ItemWidth); // Backup current width
	w_items : f32 = w_full - style.ItemInnerSpacing.x * (components - 1)
	prev_split : f32 = w_items
	for i : i32 = components - 1; i > 0; post_decr(&i) {
		next_split : f32 = IM_TRUNC(w_items * i / components)
		push_back(&window.DC.ItemWidthStack, ImMax(prev_split - next_split, 1.0))
		prev_split = next_split
	}

	window.DC.ItemWidth = ImMax(prev_split, 1.0)
	g.NextItemData.HasFlags &= !ImGuiNextItemDataFlags_.ImGuiNextItemDataFlags_HasWidth
}

PopItemWidth :: proc()
{
	g : ^ImGuiContext = GImGui^
	window : ^ImGuiWindow = g.CurrentWindow
	if window.DC.ItemWidthStack.Size <= 0 {
		IM_ASSERT_USER_ERROR(0, "Calling PopItemWidth() too many times!")
		return
	}
	window.DC.ItemWidth = back(&window.DC.ItemWidthStack)
	pop_back(&window.DC.ItemWidthStack)
}

// width of item given pushed settings and current cursor position. NOT necessarily the width of last item unlike most 'Item' functions.
// Calculate default item width given value passed to PushItemWidth() or SetNextItemWidth().
// The SetNextItemWidth() data is generally cleared/consumed by ItemAdd() or NextItemData.ClearFlags()
CalcItemWidth :: proc() -> f32
{
	g : ^ImGuiContext = GImGui^
	window : ^ImGuiWindow = g.CurrentWindow
	w : f32
	if g.NextItemData.HasFlags & ImGuiNextItemDataFlags_.ImGuiNextItemDataFlags_HasWidth { w = g.NextItemData.Width }
	else { w = window.DC.ItemWidth }
	if w < 0.0 {
		region_avail_x : f32 = GetContentRegionAvail().x
		w = ImMax(1.0, region_avail_x + w)
	}
	w = IM_TRUNC(w)
	return w
}

// [Internal] Calculate full item size given user provided 'size' parameter and default width/height. Default width is often == CalcItemWidth().
// Those two functions CalcItemWidth vs CalcItemSize are awkwardly named because they are not fully symmetrical.
// Note that only CalcItemWidth() is publicly exposed.
// The 4.0f here may be changed to match CalcItemWidth() and/or BeginChild() (right now we have a mismatch which is harmless but undesirable)
CalcItemSize :: proc(size : ImVec2, default_w : f32, default_h : f32) -> ImVec2
{
	avail : ImVec2
	if size.x < 0.0 || size.y < 0.0 { avail = GetContentRegionAvail() }

	if size.x == 0.0 { size.x = default_w }
	else if size.x < 0.0 {
		// <-- size.x is negative here so we are subtracting
		size.x = ImMax(4.0, avail.x + size.x)
	}

	if size.y == 0.0 { size.y = default_h }
	else if size.y < 0.0 {
		// <-- size.y is negative here so we are subtracting
		size.y = ImMax(4.0, avail.y + size.y)
	}

	return size
}

// ~ FontSize
GetTextLineHeight :: proc() -> f32
{
	g : ^ImGuiContext = GImGui^
	return g.FontSize
}

// ~ FontSize + style.ItemSpacing.y (distance in pixels between 2 consecutive lines of text)
GetTextLineHeightWithSpacing :: proc() -> f32
{
	g : ^ImGuiContext = GImGui^
	return g.FontSize + g.Style.ItemSpacing.y
}

// ~ FontSize + style.FramePadding.y * 2
GetFrameHeight :: proc() -> f32
{
	g : ^ImGuiContext = GImGui^
	return g.FontSize + g.Style.FramePadding.y * 2.0
}

// ~ FontSize + style.FramePadding.y * 2 + style.ItemSpacing.y (distance in pixels between 2 consecutive lines of framed widgets)
GetFrameHeightWithSpacing :: proc() -> f32
{
	g : ^ImGuiContext = GImGui^
	return g.FontSize + g.Style.FramePadding.y * 2.0 + g.Style.ItemSpacing.y
}

// available space from current position. THIS IS YOUR BEST FRIEND.
GetContentRegionAvail :: proc() -> ImVec2
{
	g : ^ImGuiContext = GImGui^
	window : ^ImGuiWindow = g.CurrentWindow
	mx : ImVec2 = (window.DC.CurrentColumns || g.CurrentTable) ? window.WorkRect.Max : window.ContentRegionRect.Max
	return mx - window.DC.CursorPos
}



// lock horizontal starting position
// Lock horizontal starting position + capture group bounding box into one "item" (so you can use IsItemHovered() or layout primitives such as SameLine() on whole group, etc.)
// Groups are currently a mishmash of functionalities which should perhaps be clarified and separated.
// FIXME-OPT: Could we safely early out on ->SkipItems?
BeginGroup :: proc()
{
	g : ^ImGuiContext = GImGui^
	window : ^ImGuiWindow = g.CurrentWindow

	resize(&g.GroupStack, g.GroupStack.Size + 1)
	group_data : ^ImGuiGroupData = back(&g.GroupStack)
	group_data.WindowID = window.ID
	group_data.BackupCursorPos = window.DC.CursorPos
	group_data.BackupCursorPosPrevLine = window.DC.CursorPosPrevLine
	group_data.BackupCursorMaxPos = window.DC.CursorMaxPos
	group_data.BackupIndent = window.DC.Indent
	group_data.BackupGroupOffset = window.DC.GroupOffset
	group_data.BackupCurrLineSize = window.DC.CurrLineSize
	group_data.BackupCurrLineTextBaseOffset = window.DC.CurrLineTextBaseOffset
	group_data.BackupActiveIdIsAlive = g.ActiveIdIsAlive
	group_data.BackupHoveredIdIsAlive = g.HoveredId != 0
	group_data.BackupIsSameLine = window.DC.IsSameLine
	group_data.BackupActiveIdPreviousFrameIsAlive = g.ActiveIdPreviousFrameIsAlive
	group_data.EmitItem = true

	window.DC.GroupOffset.x = window.DC.CursorPos.x - window.Pos.x - window.DC.ColumnsOffset.x
	window.DC.Indent = window.DC.GroupOffset
	window.DC.CursorMaxPos = window.DC.CursorPos
	window.DC.CurrLineSize = ImVec2(0.0, 0.0)
	if g.LogEnabled {
		// To enforce a carriage return
		g.LogLinePosY = -FLT_MAX
	}
}

// unlock horizontal starting position + capture the whole group bounding box into one "item" (so you can use IsItemHovered() or layout primitives such as SameLine() on whole group, etc.)
EndGroup :: proc()
{
	g : ^ImGuiContext = GImGui^
	window : ^ImGuiWindow = g.CurrentWindow
	IM_ASSERT(g.GroupStack.Size > 0); // Mismatched BeginGroup()/EndGroup() calls

	group_data : ^ImGuiGroupData = back(&g.GroupStack)
	IM_ASSERT(group_data.WindowID == window.ID); // EndGroup() in wrong window?

	if window.DC.IsSetPos { ErrorCheckUsingSetCursorPosToExtendParentBoundaries() }

	// Include LastItemData.Rect.Max as a workaround for e.g. EndTable() undershooting with CursorMaxPos report. (#7543)
	group_bb : ImRect; init(&group_bb, group_data.BackupCursorPos, ImMax(ImMax(window.DC.CursorMaxPos, g.LastItemData.Rect.Max), group_data.BackupCursorPos))
	window.DC.CursorPos = group_data.BackupCursorPos
	window.DC.CursorPosPrevLine = group_data.BackupCursorPosPrevLine
	window.DC.CursorMaxPos = ImMax(group_data.BackupCursorMaxPos, group_bb.Max)
	window.DC.Indent = group_data.BackupIndent
	window.DC.GroupOffset = group_data.BackupGroupOffset
	window.DC.CurrLineSize = group_data.BackupCurrLineSize
	window.DC.CurrLineTextBaseOffset = group_data.BackupCurrLineTextBaseOffset
	window.DC.IsSameLine = group_data.BackupIsSameLine
	if g.LogEnabled {
		// To enforce a carriage return
		g.LogLinePosY = -FLT_MAX
	}

	if !group_data.EmitItem {
		pop_back(&g.GroupStack)
		return
	}

	window.DC.CurrLineTextBaseOffset = ImMax(window.DC.PrevLineTextBaseOffset, group_data.BackupCurrLineTextBaseOffset); // FIXME: Incorrect, we should grab the base offset from the *first line* of the group but it is hard to obtain now.
	ItemSize(GetSize(&group_bb))
	ItemAdd(group_bb, 0, nil, ImGuiItemFlags_.ImGuiItemFlags_NoTabStop)

	// If the current ActiveId was declared within the boundary of our group, we copy it to LastItemId so IsItemActive(), IsItemDeactivated() etc. will be functional on the entire group.
	// It would be neater if we replaced window.DC.LastItemId by e.g. 'bool LastItemIsActive', but would put a little more burden on individual widgets.
	// Also if you grep for LastItemId you'll notice it is only used in that context.
	// (The two tests not the same because ActiveIdIsAlive is an ID itself, in order to be able to handle ActiveId being overwritten during the frame.)
	group_contains_curr_active_id : bool = (group_data.BackupActiveIdIsAlive != g.ActiveId) && (g.ActiveIdIsAlive == g.ActiveId) && g.ActiveId
	group_contains_prev_active_id : bool = (group_data.BackupActiveIdPreviousFrameIsAlive == false) && (g.ActiveIdPreviousFrameIsAlive == true)
	if group_contains_curr_active_id { g.LastItemData.ID = g.ActiveId }
	else if group_contains_prev_active_id { g.LastItemData.ID = g.ActiveIdPreviousFrame }
	g.LastItemData.Rect = group_bb

	// Forward Hovered flag
	group_contains_curr_hovered_id : bool = (group_data.BackupHoveredIdIsAlive == false) && g.HoveredId != 0
	if group_contains_curr_hovered_id { g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_.ImGuiItemStatusFlags_HoveredWindow }

	// Forward Edited flag
	if group_contains_curr_active_id && g.ActiveIdHasBeenEditedThisFrame { g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_.ImGuiItemStatusFlags_Edited }

	// Forward Deactivated flag
	g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_.ImGuiItemStatusFlags_HasDeactivated
	if group_contains_prev_active_id && g.ActiveId != g.ActiveIdPreviousFrame { g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_.ImGuiItemStatusFlags_Deactivated }

	pop_back(&g.GroupStack)
	if g.DebugShowGroupRects {
		// [Debug]
		AddRect(window.DrawList, group_bb.Min, group_bb.Max, IM_COL32(255, 0, 255, 255))
	}
}


//-----------------------------------------------------------------------------
// [SECTION] SCROLLING
//-----------------------------------------------------------------------------

// Helper to snap on edges when aiming at an item very close to the edge,
// So the difference between WindowPadding and ItemSpacing will be in the visible area after scrolling.
// When we refactor the scrolling API this may be configurable with a flag?
// Note that the effect for this won't be visible on X axis with default Style settings as WindowPadding.x == ItemSpacing.x by default.
CalcScrollEdgeSnap :: proc(target : f32, snap_min : f32, snap_max : f32, snap_threshold : f32, center_ratio : f32) -> f32
{
	if target <= snap_min + snap_threshold { return ImLerp(snap_min, target, center_ratio) }
	if target >= snap_max - snap_threshold { return ImLerp(target, snap_max, center_ratio) }
	return target
}

CalcNextScrollFromScrollTargetAndClamp :: proc(window : ^ImGuiWindow) -> ImVec2
{
	scroll : ImVec2 = window.Scroll
	decoration_size : ImVec2; init(&decoration_size, window.DecoOuterSizeX1 + window.DecoInnerSizeX1 + window.DecoOuterSizeX2, window.DecoOuterSizeY1 + window.DecoInnerSizeY1 + window.DecoOuterSizeY2)
	for axis : i32 = 0; axis < 2; post_incr(&axis) {
		if window.ScrollTarget[axis] < FLT_MAX {
			center_ratio : f32 = window.ScrollTargetCenterRatio[axis]
			scroll_target : f32 = window.ScrollTarget[axis]
			if window.ScrollTargetEdgeSnapDist[axis] > 0.0 {
				snap_min : f32 = 0.0
				snap_max : f32 = window.ScrollMax[axis] + window.SizeFull[axis] - decoration_size[axis]
				scroll_target = CalcScrollEdgeSnap(scroll_target, snap_min, snap_max, window.ScrollTargetEdgeSnapDist[axis], center_ratio)
			}
			scroll[axis] = scroll_target - center_ratio * (window.SizeFull[axis] - decoration_size[axis])
		}
		scroll[axis] = IM_ROUND(ImMax(scroll[axis], 0.0))
		if !window.Collapsed && !window.SkipItems { scroll[axis] = ImMin(scroll[axis], window.ScrollMax[axis]) }
	}

	return scroll
}

// Early work-in-progress API (ScrollToItem() will become public)
ScrollToItem :: proc(flags : ImGuiScrollFlags)
{
	g : ^ImGuiContext = GImGui^
	window : ^ImGuiWindow = g.CurrentWindow
	ScrollToRectEx(window, g.LastItemData.NavRect, flags)
}

ScrollToRect :: proc(window : ^ImGuiWindow, item_rect : ^ImRect, flags : ImGuiScrollFlags)
{
	ScrollToRectEx(window, item_rect, flags)
}

// Scroll to keep newly navigated item fully into view
ScrollToRectEx :: proc(window : ^ImGuiWindow, item_rect : ^ImRect, flags : ImGuiScrollFlags) -> ImVec2
{
	g : ^ImGuiContext = GImGui^
	scroll_rect : ImRect; init(&scroll_rect, window.InnerRect.Min - ImVec2(1, 1), window.InnerRect.Max + ImVec2(1, 1))
	scroll_rect.Min.x = ImMin(scroll_rect.Min.x + window.DecoInnerSizeX1, scroll_rect.Max.x)
	scroll_rect.Min.y = ImMin(scroll_rect.Min.y + window.DecoInnerSizeY1, scroll_rect.Max.y)
	//GetForegroundDrawList(window)->AddRect(item_rect.Min, item_rect.Max, IM_COL32(255,0,0,255), 0.0f, 0, 5.0f); // [DEBUG]
	//GetForegroundDrawList(window)->AddRect(scroll_rect.Min, scroll_rect.Max, IM_COL32_WHITE); // [DEBUG]

	// Check that only one behavior is selected per axis
	IM_ASSERT((flags & ImGuiScrollFlags_.ImGuiScrollFlags_MaskX_) == 0 || ImIsPowerOfTwo(flags & ImGuiScrollFlags_.ImGuiScrollFlags_MaskX_))
	IM_ASSERT((flags & ImGuiScrollFlags_.ImGuiScrollFlags_MaskY_) == 0 || ImIsPowerOfTwo(flags & ImGuiScrollFlags_.ImGuiScrollFlags_MaskY_))

	// Defaults
	in_flags : ImGuiScrollFlags = flags
	if (flags & ImGuiScrollFlags_.ImGuiScrollFlags_MaskX_) == 0 && window.ScrollbarX { flags |= ImGuiScrollFlags_.ImGuiScrollFlags_KeepVisibleEdgeX }
	if (flags & ImGuiScrollFlags_.ImGuiScrollFlags_MaskY_) == 0 { flags |= window.Appearing ? ImGuiScrollFlags_.ImGuiScrollFlags_AlwaysCenterY : ImGuiScrollFlags_.ImGuiScrollFlags_KeepVisibleEdgeY }

	fully_visible_x : bool = item_rect.Min.x >= scroll_rect.Min.x && item_rect.Max.x <= scroll_rect.Max.x
	fully_visible_y : bool = item_rect.Min.y >= scroll_rect.Min.y && item_rect.Max.y <= scroll_rect.Max.y
	can_be_fully_visible_x : bool = (GetWidth(&item_rect) + g.Style.ItemSpacing.x * 2.0) <= GetWidth(&scroll_rect) || (window.AutoFitFramesX > 0) || (window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_AlwaysAutoResize) != 0
	can_be_fully_visible_y : bool = (GetHeight(&item_rect) + g.Style.ItemSpacing.y * 2.0) <= GetHeight(&scroll_rect) || (window.AutoFitFramesY > 0) || (window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_AlwaysAutoResize) != 0

	if (flags & ImGuiScrollFlags_.ImGuiScrollFlags_KeepVisibleEdgeX) && !fully_visible_x {
		if item_rect.Min.x < scroll_rect.Min.x || !can_be_fully_visible_x { SetScrollFromPosX(window, item_rect.Min.x - g.Style.ItemSpacing.x - window.Pos.x, 0.0) }
		else if item_rect.Max.x >= scroll_rect.Max.x { SetScrollFromPosX(window, item_rect.Max.x + g.Style.ItemSpacing.x - window.Pos.x, 1.0) }
	}
	else if ((flags & ImGuiScrollFlags_.ImGuiScrollFlags_KeepVisibleCenterX) && !fully_visible_x) || (flags & ImGuiScrollFlags_.ImGuiScrollFlags_AlwaysCenterX) {
		if can_be_fully_visible_x { SetScrollFromPosX(window, ImTrunc((item_rect.Min.x + item_rect.Max.x) * 0.5) - window.Pos.x, 0.5) }
		else { SetScrollFromPosX(window, item_rect.Min.x - window.Pos.x, 0.0) }
	}

	if (flags & ImGuiScrollFlags_.ImGuiScrollFlags_KeepVisibleEdgeY) && !fully_visible_y {
		if item_rect.Min.y < scroll_rect.Min.y || !can_be_fully_visible_y { SetScrollFromPosY(window, item_rect.Min.y - g.Style.ItemSpacing.y - window.Pos.y, 0.0) }
		else if item_rect.Max.y >= scroll_rect.Max.y { SetScrollFromPosY(window, item_rect.Max.y + g.Style.ItemSpacing.y - window.Pos.y, 1.0) }
	}
	else if ((flags & ImGuiScrollFlags_.ImGuiScrollFlags_KeepVisibleCenterY) && !fully_visible_y) || (flags & ImGuiScrollFlags_.ImGuiScrollFlags_AlwaysCenterY) {
		if can_be_fully_visible_y { SetScrollFromPosY(window, ImTrunc((item_rect.Min.y + item_rect.Max.y) * 0.5) - window.Pos.y, 0.5) }
		else { SetScrollFromPosY(window, item_rect.Min.y - window.Pos.y, 0.0) }
	}

	next_scroll : ImVec2 = CalcNextScrollFromScrollTargetAndClamp(window)
	delta_scroll : ImVec2 = next_scroll - window.Scroll

	// Also scroll parent window to keep us into view if necessary
	if !(flags & ImGuiScrollFlags_.ImGuiScrollFlags_NoScrollParent) && (window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_ChildWindow) {
		// FIXME-SCROLL: May be an option?
		if (in_flags & (ImGuiScrollFlags_.ImGuiScrollFlags_AlwaysCenterX | ImGuiScrollFlags_.ImGuiScrollFlags_KeepVisibleCenterX)) != 0 { in_flags = (in_flags & !ImGuiScrollFlags_.ImGuiScrollFlags_MaskX_) | ImGuiScrollFlags_.ImGuiScrollFlags_KeepVisibleEdgeX }
		if (in_flags & (ImGuiScrollFlags_.ImGuiScrollFlags_AlwaysCenterY | ImGuiScrollFlags_.ImGuiScrollFlags_KeepVisibleCenterY)) != 0 { in_flags = (in_flags & !ImGuiScrollFlags_.ImGuiScrollFlags_MaskY_) | ImGuiScrollFlags_.ImGuiScrollFlags_KeepVisibleEdgeY }
		delta_scroll += ScrollToRectEx(window.ParentWindow, ImRect(item_rect.Min - delta_scroll, item_rect.Max - delta_scroll), in_flags)
	}

	return delta_scroll
}

// Windows Scrolling
// - Any change of Scroll will be applied at the beginning of next frame in the first call to Begin().
// - You may instead use SetNextWindowScroll() prior to calling Begin() to avoid this delay, as an alternative to using SetScrollX()/SetScrollY().
// get scrolling amount [0 .. GetScrollMaxX()]
GetScrollX :: proc() -> f32
{
	window : ^ImGuiWindow = GImGui.CurrentWindow
	return window.Scroll.x
}

// get scrolling amount [0 .. GetScrollMaxY()]
GetScrollY :: proc() -> f32
{
	window : ^ImGuiWindow = GImGui.CurrentWindow
	return window.Scroll.y
}

// get maximum scrolling amount ~~ ContentSize.x - WindowSize.x - DecorationsSize.x
GetScrollMaxX :: proc() -> f32
{
	window : ^ImGuiWindow = GImGui.CurrentWindow
	return window.ScrollMax.x
}

// get maximum scrolling amount ~~ ContentSize.y - WindowSize.y - DecorationsSize.y
GetScrollMaxY :: proc() -> f32
{
	window : ^ImGuiWindow = GImGui.CurrentWindow
	return window.ScrollMax.y
}

// set scrolling amount [0 .. GetScrollMaxX()]
// Scrolling
SetScrollX_0 :: proc(window : ^ImGuiWindow, scroll_x : f32)
{
	window.ScrollTarget.x = scroll_x
	window.ScrollTargetCenterRatio.x = 0.0
	window.ScrollTargetEdgeSnapDist.x = 0.0
}

// set scrolling amount [0 .. GetScrollMaxY()]
SetScrollY_0 :: proc(window : ^ImGuiWindow, scroll_y : f32)
{
	window.ScrollTarget.y = scroll_y
	window.ScrollTargetCenterRatio.y = 0.0
	window.ScrollTargetEdgeSnapDist.y = 0.0
}

// set scrolling amount [0 .. GetScrollMaxX()]
// Scrolling
SetScrollX_1 :: proc(scroll_x : f32)
{
	g : ^ImGuiContext = GImGui^
	SetScrollX(g.CurrentWindow, scroll_x)
}

// set scrolling amount [0 .. GetScrollMaxY()]
SetScrollY_1 :: proc(scroll_y : f32)
{
	g : ^ImGuiContext = GImGui^
	SetScrollY(g.CurrentWindow, scroll_y)
}

// adjust scrolling amount to make given position visible. Generally GetCursorStartPos() + offset to compute a valid position.
// Note that a local position will vary depending on initial scroll value,
// This is a little bit confusing so bear with us:
//  - local_pos = (absolution_pos - window->Pos)
//  - So local_x/local_y are 0.0f for a position at the upper-left corner of a window,
//    and generally local_x/local_y are >(padding+decoration) && <(size-padding-decoration) when in the visible area.
//  - They mostly exist because of legacy API.
// Following the rules above, when trying to work with scrolling code, consider that:
//  - SetScrollFromPosY(0.0f) == SetScrollY(0.0f + scroll.y) == has no effect!
//  - SetScrollFromPosY(-scroll.y) == SetScrollY(-scroll.y + scroll.y) == SetScrollY(0.0f) == reset scroll. Of course writing SetScrollY(0.0f) directly then makes more sense
// We store a target position so centering and clamping can occur on the next frame when we are guaranteed to have a known window size
SetScrollFromPosX_0 :: proc(window : ^ImGuiWindow, local_x : f32, center_x_ratio : f32)
{
	IM_ASSERT(center_x_ratio >= 0.0 && center_x_ratio <= 1.0)
	window.ScrollTarget.x = IM_TRUNC(local_x - window.DecoOuterSizeX1 - window.DecoInnerSizeX1 + window.Scroll.x); // Convert local position to scroll offset
	window.ScrollTargetCenterRatio.x = center_x_ratio
	window.ScrollTargetEdgeSnapDist.x = 0.0
}

// adjust scrolling amount to make given position visible. Generally GetCursorStartPos() + offset to compute a valid position.
SetScrollFromPosY_0 :: proc(window : ^ImGuiWindow, local_y : f32, center_y_ratio : f32)
{
	IM_ASSERT(center_y_ratio >= 0.0 && center_y_ratio <= 1.0)
	window.ScrollTarget.y = IM_TRUNC(local_y - window.DecoOuterSizeY1 - window.DecoInnerSizeY1 + window.Scroll.y); // Convert local position to scroll offset
	window.ScrollTargetCenterRatio.y = center_y_ratio
	window.ScrollTargetEdgeSnapDist.y = 0.0
}

// adjust scrolling amount to make given position visible. Generally GetCursorStartPos() + offset to compute a valid position.
SetScrollFromPosX_1 :: proc(local_x : f32, center_x_ratio : f32)
{
	g : ^ImGuiContext = GImGui^
	SetScrollFromPosX(g.CurrentWindow, local_x, center_x_ratio)
}

// adjust scrolling amount to make given position visible. Generally GetCursorStartPos() + offset to compute a valid position.
SetScrollFromPosY_1 :: proc(local_y : f32, center_y_ratio : f32)
{
	g : ^ImGuiContext = GImGui^
	SetScrollFromPosY(g.CurrentWindow, local_y, center_y_ratio)
}

// adjust scrolling amount to make current cursor position visible. center_x_ratio=0.0: left, 0.5: center, 1.0: right. When using to make a "default/current item" visible, consider using SetItemDefaultFocus() instead.
// center_x_ratio: 0.0f left of last item, 0.5f horizontal center of last item, 1.0f right of last item.
SetScrollHereX :: proc(center_x_ratio : f32)
{
	g : ^ImGuiContext = GImGui^
	window : ^ImGuiWindow = g.CurrentWindow
	spacing_x : f32 = ImMax(window.WindowPadding.x, g.Style.ItemSpacing.x)
	target_pos_x : f32 = ImLerp(g.LastItemData.Rect.Min.x - spacing_x, g.LastItemData.Rect.Max.x + spacing_x, center_x_ratio)
	SetScrollFromPosX(window, target_pos_x - window.Pos.x, center_x_ratio); // Convert from absolute to local pos

	// Tweak: snap on edges when aiming at an item very close to the edge
	window.ScrollTargetEdgeSnapDist.x = ImMax(0.0, window.WindowPadding.x - spacing_x)
}

// adjust scrolling amount to make current cursor position visible. center_y_ratio=0.0: top, 0.5: center, 1.0: bottom. When using to make a "default/current item" visible, consider using SetItemDefaultFocus() instead.
// center_y_ratio: 0.0f top of last item, 0.5f vertical center of last item, 1.0f bottom of last item.
SetScrollHereY :: proc(center_y_ratio : f32)
{
	g : ^ImGuiContext = GImGui^
	window : ^ImGuiWindow = g.CurrentWindow
	spacing_y : f32 = ImMax(window.WindowPadding.y, g.Style.ItemSpacing.y)
	target_pos_y : f32 = ImLerp(window.DC.CursorPosPrevLine.y - spacing_y, window.DC.CursorPosPrevLine.y + window.DC.PrevLineSize.y + spacing_y, center_y_ratio)
	SetScrollFromPosY(window, target_pos_y - window.Pos.y, center_y_ratio); // Convert from absolute to local pos

	// Tweak: snap on edges when aiming at an item very close to the edge
	window.ScrollTargetEdgeSnapDist.y = ImMax(0.0, window.WindowPadding.y - spacing_y)
}

// Tooltips
// - Tooltips are windows following the mouse. They do not take focus away.
// - A tooltip window can contain items of any types.
// - SetTooltip() is more or less a shortcut for the 'if (BeginTooltip()) { Text(...); EndTooltip(); }' idiom (with a subtlety that it discard any previously submitted tooltip)
// begin/append a tooltip window.
//-----------------------------------------------------------------------------
// [SECTION] TOOLTIPS
//-----------------------------------------------------------------------------

BeginTooltip :: proc() -> bool
{
	return BeginTooltipEx(ImGuiTooltipFlags_.ImGuiTooltipFlags_None, ImGuiWindowFlags_.ImGuiWindowFlags_None)
}

// Tooltips: helpers for showing a tooltip when hovering an item
// - BeginItemTooltip() is a shortcut for the 'if (IsItemHovered(ImGuiHoveredFlags_ForTooltip) && BeginTooltip())' idiom.
// - SetItemTooltip() is a shortcut for the 'if (IsItemHovered(ImGuiHoveredFlags_ForTooltip)) { SetTooltip(...); }' idiom.
// - Where 'ImGuiHoveredFlags_ForTooltip' itself is a shortcut to use 'style.HoverFlagsForTooltipMouse' or 'style.HoverFlagsForTooltipNav' depending on active input type. For mouse it defaults to 'ImGuiHoveredFlags_Stationary | ImGuiHoveredFlags_DelayShort'.
// begin/append a tooltip window if preceding item was hovered.
BeginItemTooltip :: proc() -> bool
{
	if !IsItemHovered(ImGuiHoveredFlags_.ImGuiHoveredFlags_ForTooltip) { return false }
	return BeginTooltipEx(ImGuiTooltipFlags_.ImGuiTooltipFlags_None, ImGuiWindowFlags_.ImGuiWindowFlags_None)
}

// Tooltips
BeginTooltipEx :: proc(tooltip_flags : ImGuiTooltipFlags, extra_window_flags : ImGuiWindowFlags) -> bool
{
	g : ^ImGuiContext = GImGui^

	is_dragdrop_tooltip : bool = g.DragDropWithinSource || g.DragDropWithinTarget
	if is_dragdrop_tooltip {
		// Drag and Drop tooltips are positioning differently than other tooltips:
		// - offset visibility to increase visibility around mouse.
		// - never clamp within outer viewport boundary.
		// We call SetNextWindowPos() to enforce position and disable clamping.
		// See FindBestWindowPosForPopup() for positionning logic of other tooltips (not drag and drop ones).
		//ImVec2 tooltip_pos = g.IO.MousePos - g.ActiveIdClickOffset - g.Style.WindowPadding;
		is_touchscreen : bool = (g.IO.MouseSource == ImGuiMouseSource.ImGuiMouseSource_TouchScreen)
		if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_.ImGuiNextWindowDataFlags_HasPos) == 0 {
			tooltip_pos : ImVec2 = is_touchscreen ? (g.IO.MousePos + TOOLTIP_DEFAULT_OFFSET_TOUCH * g.Style.MouseCursorScale) : (g.IO.MousePos + TOOLTIP_DEFAULT_OFFSET_MOUSE * g.Style.MouseCursorScale)
			tooltip_pivot : ImVec2 = is_touchscreen ? TOOLTIP_DEFAULT_PIVOT_TOUCH : ImVec2(0.0, 0.0)
			SetNextWindowPos(tooltip_pos, ImGuiCond_.ImGuiCond_None, tooltip_pivot)
		}

		SetNextWindowBgAlpha(g.Style.Colors[ImGuiCol_.ImGuiCol_PopupBg].w * 0.60)
		//PushStyleVar(ImGuiStyleVar_Alpha, g.Style.Alpha * 0.60f); // This would be nice but e.g ColorButton with checkboard has issue with transparent colors :(
		tooltip_flags |= ImGuiTooltipFlags_.ImGuiTooltipFlags_OverridePrevious
	}

	window_name_template : ^u8 = is_dragdrop_tooltip ? "##Tooltip_DragDrop_%02d" : "##Tooltip_%02d"
	window_name : [32]u8
	ImFormatString(window_name, IM_ARRAYSIZE(window_name), window_name_template, g.TooltipOverrideCount)
	if (tooltip_flags & ImGuiTooltipFlags_.ImGuiTooltipFlags_OverridePrevious) && g.TooltipPreviousWindow != nil && g.TooltipPreviousWindow.Active {
		// Hide previous tooltip from being displayed. We can't easily "reset" the content of a window so we create a new one.
		//IMGUI_DEBUG_LOG("[tooltip] '%s' already active, using +1 for this frame\n", window_name);
		SetWindowHiddenAndSkipItemsForCurrentFrame(g.TooltipPreviousWindow)
		ImFormatString(window_name, IM_ARRAYSIZE(window_name), window_name_template, pre_incr(&g.TooltipOverrideCount))
	}

	flags : ImGuiWindowFlags = ImGuiWindowFlags_.ImGuiWindowFlags_Tooltip | ImGuiWindowFlags_.ImGuiWindowFlags_NoInputs | ImGuiWindowFlags_.ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_.ImGuiWindowFlags_NoMove | ImGuiWindowFlags_.ImGuiWindowFlags_NoResize | ImGuiWindowFlags_.ImGuiWindowFlags_NoSavedSettings | ImGuiWindowFlags_.ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_.ImGuiWindowFlags_NoDocking
	Begin(window_name, nil, flags | extra_window_flags)
	// 2023-03-09: Added bool return value to the API, but currently always returning true.
	// If this ever returns false we need to update BeginDragDropSource() accordingly.
	//if (!ret)
	//    End();
	//return ret;
	return true
}

// only call EndTooltip() if BeginTooltip()/BeginItemTooltip() returns true!
EndTooltip :: proc()
{
	IM_ASSERT(GetCurrentWindowRead().Flags & ImGuiWindowFlags_.ImGuiWindowFlags_Tooltip); // Mismatched BeginTooltip()/EndTooltip() calls
	End()
}

// set a text-only tooltip. Often used after a ImGui::IsItemHovered() check. Override any previous call to SetTooltip().
SetTooltip :: proc(fmt : ^u8, args : ..[]any)
{
	args : []any
	va_start(args, fmt)
	SetTooltipV(fmt, args)
	va_end(args)
}

SetTooltipV :: proc(fmt : ^u8, args : []any)
{
	if !BeginTooltipEx(ImGuiTooltipFlags_.ImGuiTooltipFlags_OverridePrevious, ImGuiWindowFlags_.ImGuiWindowFlags_None) { return }
	TextV(fmt, args)
	EndTooltip()
}

// set a text-only tooltip if preceding item was hovered. override any previous call to SetTooltip().
// Shortcut to use 'style.HoverFlagsForTooltipMouse' or 'style.HoverFlagsForTooltipNav'.
// Defaults to == ImGuiHoveredFlags_Stationary | ImGuiHoveredFlags_DelayShort when using the mouse.
SetItemTooltip :: proc(fmt : ^u8, args : ..[]any)
{
	args : []any
	va_start(args, fmt)
	if IsItemHovered(ImGuiHoveredFlags_.ImGuiHoveredFlags_ForTooltip) { SetTooltipV(fmt, args) }
	va_end(args)
}

SetItemTooltipV :: proc(fmt : ^u8, args : []any)
{
	if IsItemHovered(ImGuiHoveredFlags_.ImGuiHoveredFlags_ForTooltip) { SetTooltipV(fmt, args) }
}


// Popups: query functions
//  - IsPopupOpen(): return true if the popup is open at the current BeginPopup() level of the popup stack.
//  - IsPopupOpen() with ImGuiPopupFlags_AnyPopupId: return true if any popup is open at the current BeginPopup() level of the popup stack.
//  - IsPopupOpen() with ImGuiPopupFlags_AnyPopupId + ImGuiPopupFlags_AnyPopupLevel: return true if any popup is open.
// return true if the popup is open.
//-----------------------------------------------------------------------------
// [SECTION] POPUPS
//-----------------------------------------------------------------------------

// Supported flags: ImGuiPopupFlags_AnyPopupId, ImGuiPopupFlags_AnyPopupLevel
IsPopupOpen_0 :: proc(id : ImGuiID, popup_flags : ImGuiPopupFlags) -> bool
{
	g : ^ImGuiContext = GImGui^
	if ImGuiPopupFlags_AnyPopupId : ^popup_flags; ImGuiPopupFlags_AnyPopupId {
		// Return true if any popup is open at the current BeginPopup() level of the popup stack
		// This may be used to e.g. test for another popups already opened to handle popups priorities at the same level.
		IM_ASSERT(id == 0)
		if ImGuiPopupFlags_AnyPopupLevel : ^popup_flags; ImGuiPopupFlags_AnyPopupLevel { return g.OpenPopupStack.Size > 0 }
		else { return g.OpenPopupStack.Size > g.BeginPopupStack.Size }
	}
	else {
		if ImGuiPopupFlags_AnyPopupLevel : ^popup_flags; ImGuiPopupFlags_AnyPopupLevel {
			// Return true if the popup is open anywhere in the popup stack
			for popup_data in g.OpenPopupStack { if popup_data.PopupId == id { return true } }

			return false
		}
		else {
			// Return true if the popup is open at the current BeginPopup() level of the popup stack (this is the most-common query)
			return g.OpenPopupStack.Size > g.BeginPopupStack.Size && g.OpenPopupStack[g.BeginPopupStack.Size].PopupId == id
		}
	}
}

// Popups: query functions
//  - IsPopupOpen(): return true if the popup is open at the current BeginPopup() level of the popup stack.
//  - IsPopupOpen() with ImGuiPopupFlags_AnyPopupId: return true if any popup is open at the current BeginPopup() level of the popup stack.
//  - IsPopupOpen() with ImGuiPopupFlags_AnyPopupId + ImGuiPopupFlags_AnyPopupLevel: return true if any popup is open.
// return true if the popup is open.
IsPopupOpen_1 :: proc(str_id : ^u8, popup_flags : ImGuiPopupFlags) -> bool
{
	g : ^ImGuiContext = GImGui^
	id : ImGuiID = (popup_flags & ImGuiPopupFlags_.ImGuiPopupFlags_AnyPopupId) ? 0 : GetID(g.CurrentWindow, str_id)
	if (popup_flags & ImGuiPopupFlags_.ImGuiPopupFlags_AnyPopupLevel) && id != 0 {
		// But non-string version is legal and used internally
		IM_ASSERT(0 && "Cannot use IsPopupOpen() with a string id and ImGuiPopupFlags_AnyPopupLevel.")
	}
	return IsPopupOpen(id, popup_flags)
}

// Also see FindBlockingModal(NULL)
GetTopMostPopupModal :: proc() -> ^ImGuiWindow
{
	g : ^ImGuiContext = GImGui^
	for n : i32 = g.OpenPopupStack.Size - 1; n >= 0; post_decr(&n) { if popup : ^ImGuiWindow = g.OpenPopupStack.Data[n].Window; popup { if popup.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_Modal { return popup } } }

	return nil
}

// See Demo->Stacked Modal to confirm what this is for.
GetTopMostAndVisiblePopupModal :: proc() -> ^ImGuiWindow
{
	g : ^ImGuiContext = GImGui^
	for n : i32 = g.OpenPopupStack.Size - 1; n >= 0; post_decr(&n) { if popup : ^ImGuiWindow = g.OpenPopupStack.Data[n].Window; popup { if (popup.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_Modal) && IsWindowActiveAndVisible(popup) { return popup } } }

	return nil
}


// When a modal popup is open, newly created windows that want focus (i.e. are not popups and do not specify ImGuiWindowFlags_NoFocusOnAppearing)
// should be positioned behind that modal window, unless the window was created inside the modal begin-stack.
// In case of multiple stacked modals newly created window honors begin stack order and does not go below its own modal parent.
// - WindowA            // FindBlockingModal() returns Modal1
//   - WindowB          //                  .. returns Modal1
//   - Modal1           //                  .. returns Modal2
//      - WindowC       //                  .. returns Modal2
//          - WindowD   //                  .. returns Modal2
//          - Modal2    //                  .. returns Modal2
//            - WindowE //                  .. returns NULL
// Notes:
// - FindBlockingModal(NULL) == NULL is generally equivalent to GetTopMostPopupModal() == NULL.
//   Only difference is here we check for ->Active/WasActive but it may be unnecessary.
FindBlockingModal :: proc(window : ^ImGuiWindow) -> ^ImGuiWindow
{
	g : ^ImGuiContext = GImGui^
	if g.OpenPopupStack.Size <= 0 { return nil }

	// Find a modal that has common parent with specified window. Specified window should be positioned behind that modal.
	for popup_data in g.OpenPopupStack {
		popup_window : ^ImGuiWindow = popup_data.Window
		if popup_window == nil || !(popup_window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_Modal) { continue }
		if !popup_window.Active && !popup_window.WasActive {
			// Check WasActive, because this code may run before popup renders on current frame, also check Active to handle newly created windows.continue
		}
		if window == nil {
			// FindBlockingModal(NULL) test for if FocusWindow(NULL) is naturally possible via a mouse click.return popup_window
		}
		if IsWindowWithinBeginStackOf(window, popup_window) {
			// Window may be over modalcontinue
		}
		return popup_window// Place window right below first block modal
	}

	return nil
}

// Popups: open/close functions
//  - OpenPopup(): set popup state to open. ImGuiPopupFlags are available for opening options.
//  - If not modal: they can be closed by clicking anywhere outside them, or by pressing ESCAPE.
//  - CloseCurrentPopup(): use inside the BeginPopup()/EndPopup() scope to close manually.
//  - CloseCurrentPopup() is called by default by Selectable()/MenuItem() when activated (FIXME: need some options).
//  - Use ImGuiPopupFlags_NoOpenOverExistingPopup to avoid opening a popup if there's already one at the same level. This is equivalent to e.g. testing for !IsAnyPopupOpen() prior to OpenPopup().
//  - Use IsWindowAppearing() after BeginPopup() to tell if a window just opened.
//  - IMPORTANT: Notice that for OpenPopupOnItemClick() we exceptionally default flags to 1 (== ImGuiPopupFlags_MouseButtonRight) for backward compatibility with older API taking 'int mouse_button = 1' parameter
// call to mark popup as open (don't call every frame!).
// id overload to facilitate calling from nested stacks
OpenPopup_0 :: proc(str_id : ^u8, popup_flags : ImGuiPopupFlags)
{
	g : ^ImGuiContext = GImGui^
	id : ImGuiID = GetID(g.CurrentWindow, str_id)
	IMGUI_DEBUG_LOG_POPUP("[popup] OpenPopup(\"%s\" -> 0x%08X)\n", str_id, id)
	OpenPopupEx(id, popup_flags)
}

// Popups: open/close functions
//  - OpenPopup(): set popup state to open. ImGuiPopupFlags are available for opening options.
//  - If not modal: they can be closed by clicking anywhere outside them, or by pressing ESCAPE.
//  - CloseCurrentPopup(): use inside the BeginPopup()/EndPopup() scope to close manually.
//  - CloseCurrentPopup() is called by default by Selectable()/MenuItem() when activated (FIXME: need some options).
//  - Use ImGuiPopupFlags_NoOpenOverExistingPopup to avoid opening a popup if there's already one at the same level. This is equivalent to e.g. testing for !IsAnyPopupOpen() prior to OpenPopup().
//  - Use IsWindowAppearing() after BeginPopup() to tell if a window just opened.
//  - IMPORTANT: Notice that for OpenPopupOnItemClick() we exceptionally default flags to 1 (== ImGuiPopupFlags_MouseButtonRight) for backward compatibility with older API taking 'int mouse_button = 1' parameter
// call to mark popup as open (don't call every frame!).
// id overload to facilitate calling from nested stacks
OpenPopup_1 :: proc(id : ImGuiID, popup_flags : ImGuiPopupFlags)
{
	OpenPopupEx(id, popup_flags)
}

// Mark popup as open (toggle toward open state).
// Popups are closed when user click outside, or activate a pressable item, or CloseCurrentPopup() is called within a BeginPopup()/EndPopup() block.
// Popup identifiers are relative to the current ID-stack (so OpenPopup and BeginPopup needs to be at the same level).
// One open popup per level of the popup hierarchy (NB: when assigning we reset the Window member of ImGuiPopupRef to NULL)
OpenPopupEx :: proc(id : ImGuiID, popup_flags : ImGuiPopupFlags)
{
	g : ^ImGuiContext = GImGui^
	parent_window : ^ImGuiWindow = g.CurrentWindow
	current_stack_size : i32 = g.BeginPopupStack.Size

	if ImGuiPopupFlags_NoOpenOverExistingPopup : ^popup_flags; ImGuiPopupFlags_NoOpenOverExistingPopup { if IsPopupOpen(cast(ImGuiID) 0, ImGuiPopupFlags_.ImGuiPopupFlags_AnyPopupId) { return } }

	popup_ref : ImGuiPopupData; // Tagged as new ref as Window will be set back to NULL if we write this into OpenPopupStack.
	popup_ref.PopupId = id
	popup_ref.Window = nil
	popup_ref.RestoreNavWindow = g.NavWindow; // When popup closes focus may be restored to NavWindow (depend on window type).
	popup_ref.OpenFrameCount = g.FrameCount
	popup_ref.OpenParentId = back(&parent_window.IDStack)
	popup_ref.OpenPopupPos = NavCalcPreferredRefPos()
	popup_ref.OpenMousePos = IsMousePosValid(&g.IO.MousePos) ? g.IO.MousePos : popup_ref.OpenPopupPos

	IMGUI_DEBUG_LOG_POPUP("[popup] OpenPopupEx(0x%08X)\n", id)
	if g.OpenPopupStack.Size < current_stack_size + 1 {
		push_back(&g.OpenPopupStack, popup_ref)
	}
	else {
		// Gently handle the user mistakenly calling OpenPopup() every frames: it is likely a programming mistake!
		// However, if we were to run the regular code path, the ui would become completely unusable because the popup will always be
		// in hidden-while-calculating-size state _while_ claiming focus. Which is extremely confusing situation for the programmer.
		// Instead, for successive frames calls to OpenPopup(), we silently avoid reopening even if ImGuiPopupFlags_NoReopen is not specified.
		keep_existing : bool = false
		if g.OpenPopupStack[current_stack_size].PopupId == id { if (g.OpenPopupStack[current_stack_size].OpenFrameCount == g.FrameCount - 1) || (popup_flags & ImGuiPopupFlags_.ImGuiPopupFlags_NoReopen) { keep_existing = true } }
		if keep_existing {
			// No reopen
			g.OpenPopupStack[current_stack_size].OpenFrameCount = popup_ref.OpenFrameCount
		}
		else {
			// Reopen: close child popups if any, then flag popup for open/reopen (set position, focus, init navigation)
			ClosePopupToLevel(current_stack_size, true)
			push_back(&g.OpenPopupStack, popup_ref)
		}

		// When reopening a popup we first refocus its parent, otherwise if its parent is itself a popup it would get closed by ClosePopupsOverWindow().
		// This is equivalent to what ClosePopupToLevel() does.
		//if (g.OpenPopupStack[current_stack_size].PopupId == id)
		//    FocusWindow(parent_window);
	}
}

// When popups are stacked, clicking on a lower level popups puts focus back to it and close popups above it.
// This function closes any popups that are over 'ref_window'.
ClosePopupsOverWindow :: proc(ref_window : ^ImGuiWindow, restore_focus_to_window_under_popup : bool)
{
	g : ^ImGuiContext = GImGui^
	if g.OpenPopupStack.Size == 0 { return }

	// Don't close our own child popup windows.
	//IMGUI_DEBUG_LOG_POPUP("[popup] ClosePopupsOverWindow(\"%s\") restore_under=%d\n", ref_window ? ref_window->Name : "<NULL>", restore_focus_to_window_under_popup);
	popup_count_to_keep : i32 = 0
	if ref_window {
		// Find the highest popup which is a descendant of the reference window (generally reference window = NavWindow)
		for ; popup_count_to_keep < g.OpenPopupStack.Size; post_incr(&popup_count_to_keep) {
			popup : ^ImGuiPopupData = g.OpenPopupStack[popup_count_to_keep]
			if !popup.Window { continue }
			IM_ASSERT((popup.Window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_Popup) != 0)

			// Trim the stack unless the popup is a direct parent of the reference window (the reference window is often the NavWindow)
			// - Clicking/Focusing Window2 won't close Popup1:
			//     Window -> Popup1 -> Window2(Ref)
			// - Clicking/focusing Popup1 will close Popup2 and Popup3:
			//     Window -> Popup1(Ref) -> Popup2 -> Popup3
			// - Each popups may contain child windows, which is why we compare ->RootWindowDockTree!
			//     Window -> Popup1 -> Popup1_Child -> Popup2 -> Popup2_Child
			// We step through every popup from bottom to top to validate their position relative to reference window.
			ref_window_is_descendent_of_popup : bool = false
			for n : i32 = popup_count_to_keep; n < g.OpenPopupStack.Size; post_incr(&n) {
				if popup_window : ^ImGuiWindow = g.OpenPopupStack[n].Window; popup_window {
					//if (popup_window->RootWindowDockTree == ref_window->RootWindowDockTree) // FIXME-MERGE
					if IsWindowWithinBeginStackOf(ref_window, popup_window) {
						ref_window_is_descendent_of_popup = true
						break
					}
				}
			}

			if !ref_window_is_descendent_of_popup { break }
		}
	}
	if popup_count_to_keep < g.OpenPopupStack.Size {
		// This test is not required but it allows to set a convenient breakpoint on the statement below
		IMGUI_DEBUG_LOG_POPUP("[popup] ClosePopupsOverWindow(\"%s\")\n", ref_window ? ref_window.Name : "<NULL>")
		ClosePopupToLevel(popup_count_to_keep, restore_focus_to_window_under_popup)
	}
}

ClosePopupsExceptModals :: proc()
{
	g : ^ImGuiContext = GImGui^

	popup_count_to_keep : i32
	for popup_count_to_keep = g.OpenPopupStack.Size; popup_count_to_keep > 0; post_decr(&popup_count_to_keep) {
		window : ^ImGuiWindow = g.OpenPopupStack[popup_count_to_keep - 1].Window
		if !window || (window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_Modal) { break }
	}

	if popup_count_to_keep < g.OpenPopupStack.Size {
		// This test is not required but it allows to set a convenient breakpoint on the statement belowClosePopupToLevel(popup_count_to_keep, true)
	}
}

ClosePopupToLevel :: proc(remaining : i32, restore_focus_to_window_under_popup : bool)
{
	g : ^ImGuiContext = GImGui^
	IMGUI_DEBUG_LOG_POPUP("[popup] ClosePopupToLevel(%d), restore_under=%d\n", remaining, restore_focus_to_window_under_popup)
	IM_ASSERT(remaining >= 0 && remaining < g.OpenPopupStack.Size)
	if g.DebugLogFlags & ImGuiDebugLogFlags_.ImGuiDebugLogFlags_EventPopup { for n : i32 = remaining; n < g.OpenPopupStack.Size; post_incr(&n) { IMGUI_DEBUG_LOG_POPUP("[popup] - Closing PopupID 0x%08X Window \"%s\"\n", g.OpenPopupStack[n].PopupId, g.OpenPopupStack[n].Window ? g.OpenPopupStack[n].Window.Name : nil) } }

	// Trim open popup stack
	prev_popup : ImGuiPopupData = g.OpenPopupStack[remaining]
	resize(&g.OpenPopupStack, remaining)

	// Restore focus (unless popup window was not yet submitted, and didn't have a chance to take focus anyhow. See #7325 for an edge case)
	if restore_focus_to_window_under_popup && prev_popup.Window {
		popup_window : ^ImGuiWindow = prev_popup.Window
		focus_window : ^ImGuiWindow = (popup_window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_ChildMenu) ? popup_window.ParentWindow : prev_popup.RestoreNavWindow
		if focus_window && !focus_window.WasActive {
			// Fallback
			FocusTopMostWindowUnderOne(popup_window, nil, nil, ImGuiFocusRequestFlags_.ImGuiFocusRequestFlags_RestoreFocusedChild)
		}
		else { FocusWindow(focus_window, (g.NavLayer == ImGuiNavLayer.ImGuiNavLayer_Main) ? ImGuiFocusRequestFlags_.ImGuiFocusRequestFlags_RestoreFocusedChild : ImGuiFocusRequestFlags_.ImGuiFocusRequestFlags_None) }
	}
}

// manually close the popup we have begin-ed into.
// Close the popup we have begin-ed into.
CloseCurrentPopup :: proc()
{
	g : ^ImGuiContext = GImGui^
	popup_idx : i32 = g.BeginPopupStack.Size - 1
	if popup_idx < 0 || popup_idx >= g.OpenPopupStack.Size || g.BeginPopupStack[popup_idx].PopupId != g.OpenPopupStack[popup_idx].PopupId { return }

	// Closing a menu closes its top-most parent popup (unless a modal)
	for popup_idx > 0 {
		popup_window : ^ImGuiWindow = g.OpenPopupStack[popup_idx].Window
		parent_popup_window : ^ImGuiWindow = g.OpenPopupStack[popup_idx - 1].Window
		close_parent : bool = false
		if popup_window && (popup_window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_ChildMenu) { if parent_popup_window && !(parent_popup_window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_MenuBar) { close_parent = true } }
		if !close_parent { break }
		post_decr(&popup_idx)
	}

	IMGUI_DEBUG_LOG_POPUP("[popup] CloseCurrentPopup %d -> %d\n", g.BeginPopupStack.Size - 1, popup_idx)
	ClosePopupToLevel(popup_idx, true)

	// A common pattern is to close a popup when selecting a menu item/selectable that will open another window.
	// To improve this usage pattern, we avoid nav highlight for a single frame in the parent window.
	// Similarly, we could avoid mouse hover highlight in this window but it is less visually problematic.
	if window : ^ImGuiWindow = g.NavWindow; window { window.DC.NavHideHighlightOneFrame = true }
}

// Popups, Modals
// Attention! BeginPopup() adds default flags when calling BeginPopupEx()!
BeginPopupEx :: proc(id : ImGuiID, extra_window_flags : ImGuiWindowFlags) -> bool
{
	g : ^ImGuiContext = GImGui^
	if !IsPopupOpen(id, ImGuiPopupFlags_.ImGuiPopupFlags_None) {
		ClearFlags(&g.NextWindowData); // We behave like Begin() and need to consume those values
		return false
	}

	name : [20]u8
	if ImGuiWindowFlags_ChildMenu : ^extra_window_flags; ImGuiWindowFlags_ChildMenu {
		// Recycle windows based on depth
		ImFormatString(name, IM_ARRAYSIZE(name), "##Menu_%02d", g.BeginMenuDepth)
	}
	else {
		// Not recycling, so we can close/open during the same frame
		ImFormatString(name, IM_ARRAYSIZE(name), "##Popup_%08x", id)
	}

	is_open : bool = Begin(name, nil, extra_window_flags | ImGuiWindowFlags_.ImGuiWindowFlags_Popup | ImGuiWindowFlags_.ImGuiWindowFlags_NoDocking)
	if !is_open {
		// NB: Begin can return false when the popup is completely clipped (e.g. zero size display)EndPopup()
	}

	//g.CurrentWindow->FocusRouteParentWindow = g.CurrentWindow->ParentWindowInBeginStack;

	return is_open
}

// Popups, Modals
//  - They block normal mouse hovering detection (and therefore most mouse interactions) behind them.
//  - If not modal: they can be closed by clicking anywhere outside them, or by pressing ESCAPE.
//  - Their visibility state (~bool) is held internally instead of being held by the programmer as we are used to with regular Begin*() calls.
//  - The 3 properties above are related: we need to retain popup visibility state in the library because popups may be closed as any time.
//  - You can bypass the hovering restriction by using ImGuiHoveredFlags_AllowWhenBlockedByPopup when calling IsItemHovered() or IsWindowHovered().
//  - IMPORTANT: Popup identifiers are relative to the current ID stack, so OpenPopup and BeginPopup generally needs to be at the same level of the stack.
//    This is sometimes leading to confusing mistakes. May rework this in the future.
//  - BeginPopup(): query popup state, if open start appending into the window. Call EndPopup() afterwards if returned true. ImGuiWindowFlags are forwarded to the window.
//  - BeginPopupModal(): block every interaction behind the window, cannot be closed by user, add a dimming background, has a title bar.
// return true if the popup is open, and you can start outputting to it.
BeginPopup :: proc(str_id : ^u8, flags : ImGuiWindowFlags) -> bool
{
	g : ^ImGuiContext = GImGui^
	if g.OpenPopupStack.Size <= g.BeginPopupStack.Size {
		// Early out for performance
		ClearFlags(&g.NextWindowData); // We behave like Begin() and need to consume those values
		return false
	}
	flags |= ImGuiWindowFlags_.ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_.ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_.ImGuiWindowFlags_NoSavedSettings
	id : ImGuiID = GetID(g.CurrentWindow, str_id)
	return BeginPopupEx(id, flags)
}

// return true if the modal is open, and you can start outputting to it.
// If 'p_open' is specified for a modal popup window, the popup will have a regular close button which will close the popup.
// Note that popup visibility status is owned by Dear ImGui (and manipulated with e.g. OpenPopup).
// - *p_open set back to false in BeginPopupModal() when popup is not open.
// - if you set *p_open to false before calling BeginPopupModal(), it will close the popup.
BeginPopupModal :: proc(name : ^u8, p_open : ^bool, flags : ImGuiWindowFlags) -> bool
{
	g : ^ImGuiContext = GImGui^
	window : ^ImGuiWindow = g.CurrentWindow
	id : ImGuiID = GetID(window, name)
	if !IsPopupOpen(id, ImGuiPopupFlags_.ImGuiPopupFlags_None) {
		ClearFlags(&g.NextWindowData); // We behave like Begin() and need to consume those values
		if p_open && p_open^ { p_open^ = false }
		return false
	}

	// Center modal windows by default for increased visibility
	// (this won't really last as settings will kick in, and is mostly for backward compatibility. user may do the same themselves)
	// FIXME: Should test for (PosCond & window->SetWindowPosAllowFlags) with the upcoming window.
	if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_.ImGuiNextWindowDataFlags_HasPos) == 0 {
		viewport : ^ImGuiViewport = window.WasActive ? window.Viewport : GetMainViewport(); // FIXME-VIEWPORT: What may be our reference viewport?
		SetNextWindowPos(GetCenter(viewport), ImGuiCond_.ImGuiCond_FirstUseEver, ImVec2(0.5, 0.5))
	}

	flags |= ImGuiWindowFlags_.ImGuiWindowFlags_Popup | ImGuiWindowFlags_.ImGuiWindowFlags_Modal | ImGuiWindowFlags_.ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_.ImGuiWindowFlags_NoDocking
	is_open : bool = Begin(name, p_open, flags)
	if !is_open || (p_open && !p_open^) {
		// NB: is_open can be 'false' when the popup is completely clipped (e.g. zero size display)
		EndPopup()
		if is_open { ClosePopupToLevel(g.BeginPopupStack.Size, true) }
		return false
	}
	return is_open
}

// only call EndPopup() if BeginPopupXXX() returns true!
EndPopup :: proc()
{
	g : ^ImGuiContext = GImGui^
	window : ^ImGuiWindow = g.CurrentWindow
	IM_ASSERT(window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_Popup); // Mismatched BeginPopup()/EndPopup() calls
	IM_ASSERT(g.BeginPopupStack.Size > 0)

	// Make all menus and popups wrap around for now, may need to expose that policy (e.g. focus scope could include wrap/loop policy flags used by new move requests)
	if g.NavWindow == window { NavMoveRequestTryWrapping(window, ImGuiNavMoveFlags_.ImGuiNavMoveFlags_LoopY) }

	// Child-popups don't need to be laid out
	backup_within_end_child_id : ImGuiID = g.WithinEndChildID
	if window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_ChildWindow { g.WithinEndChildID = window.ID }
	End()
	g.WithinEndChildID = backup_within_end_child_id
}

// helper to open popup when clicked on last item. Default to ImGuiPopupFlags_MouseButtonRight == 1. (note: actually triggers on the mouse _released_ event to be consistent with popup behaviors)
// Helper to open a popup if mouse button is released over the item
// - This is essentially the same as BeginPopupContextItem() but without the trailing BeginPopup()
OpenPopupOnItemClick :: proc(str_id : ^u8, popup_flags : ImGuiPopupFlags)
{
	g : ^ImGuiContext = GImGui^
	window : ^ImGuiWindow = g.CurrentWindow
	mouse_button : i32 = (popup_flags & ImGuiPopupFlags_.ImGuiPopupFlags_MouseButtonMask_)
	if IsMouseReleased(mouse_button) && IsItemHovered(ImGuiHoveredFlags_.ImGuiHoveredFlags_AllowWhenBlockedByPopup) {
		id : ImGuiID = str_id ? GetID(window, str_id) : g.LastItemData.ID; // If user hasn't passed an ID, we can use the LastItemID. Using LastItemID as a Popup ID won't conflict!
		IM_ASSERT(id != 0); // You cannot pass a NULL str_id if the last item has no identifier (e.g. a Text() item)
		OpenPopupEx(id, popup_flags)
	}
}

// Popups: open+begin combined functions helpers
//  - Helpers to do OpenPopup+BeginPopup where the Open action is triggered by e.g. hovering an item and right-clicking.
//  - They are convenient to easily create context menus, hence the name.
//  - IMPORTANT: Notice that BeginPopupContextXXX takes ImGuiPopupFlags just like OpenPopup() and unlike BeginPopup(). For full consistency, we may add ImGuiWindowFlags to the BeginPopupContextXXX functions in the future.
//  - IMPORTANT: Notice that we exceptionally default their flags to 1 (== ImGuiPopupFlags_MouseButtonRight) for backward compatibility with older API taking 'int mouse_button = 1' parameter, so if you add other flags remember to re-add the ImGuiPopupFlags_MouseButtonRight.
// open+begin popup when clicked on last item. Use str_id==NULL to associate the popup to previous item. If you want to use that on a non-interactive item such as Text() you need to pass in an explicit ID here. read comments in .cpp!
// This is a helper to handle the simplest case of associating one named popup to one given widget.
// - To create a popup associated to the last item, you generally want to pass a NULL value to str_id.
// - To create a popup with a specific identifier, pass it in str_id.
//    - This is useful when using using BeginPopupContextItem() on an item which doesn't have an identifier, e.g. a Text() call.
//    - This is useful when multiple code locations may want to manipulate/open the same popup, given an explicit id.
// - You may want to handle the whole on user side if you have specific needs (e.g. tweaking IsItemHovered() parameters).
//   This is essentially the same as:
//       id = str_id ? GetID(str_id) : GetItemID();
//       OpenPopupOnItemClick(str_id, ImGuiPopupFlags_MouseButtonRight);
//       return BeginPopup(id);
//   Which is essentially the same as:
//       id = str_id ? GetID(str_id) : GetItemID();
//       if (IsItemHovered() && IsMouseReleased(ImGuiMouseButton_Right))
//           OpenPopup(id);
//       return BeginPopup(id);
//   The main difference being that this is tweaked to avoid computing the ID twice.
BeginPopupContextItem :: proc(str_id : ^u8, popup_flags : ImGuiPopupFlags) -> bool
{
	g : ^ImGuiContext = GImGui^
	window : ^ImGuiWindow = g.CurrentWindow
	if window.SkipItems { return false }
	id : ImGuiID = str_id ? GetID(window, str_id) : g.LastItemData.ID; // If user hasn't passed an ID, we can use the LastItemID. Using LastItemID as a Popup ID won't conflict!
	IM_ASSERT(id != 0); // You cannot pass a NULL str_id if the last item has no identifier (e.g. a Text() item)
	mouse_button : i32 = (popup_flags & ImGuiPopupFlags_.ImGuiPopupFlags_MouseButtonMask_)
	if IsMouseReleased(mouse_button) && IsItemHovered(ImGuiHoveredFlags_.ImGuiHoveredFlags_AllowWhenBlockedByPopup) { OpenPopupEx(id, popup_flags) }
	return BeginPopupEx(id, ImGuiWindowFlags_.ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_.ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_.ImGuiWindowFlags_NoSavedSettings)
}

// open+begin popup when clicked on current window.
BeginPopupContextWindow :: proc(str_id : ^u8, popup_flags : ImGuiPopupFlags) -> bool
{
	g : ^ImGuiContext = GImGui^
	window : ^ImGuiWindow = g.CurrentWindow
	if !str_id { str_id = "window_context" }
	id : ImGuiID = GetID(window, str_id)
	mouse_button : i32 = (popup_flags & ImGuiPopupFlags_.ImGuiPopupFlags_MouseButtonMask_)
	if IsMouseReleased(mouse_button) && IsWindowHovered(ImGuiHoveredFlags_.ImGuiHoveredFlags_AllowWhenBlockedByPopup) { if !(popup_flags & ImGuiPopupFlags_.ImGuiPopupFlags_NoOpenOverItems) || !IsAnyItemHovered() { OpenPopupEx(id, popup_flags) } }
	return BeginPopupEx(id, ImGuiWindowFlags_.ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_.ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_.ImGuiWindowFlags_NoSavedSettings)
}

// open+begin popup when clicked in void (where there are no windows).
BeginPopupContextVoid :: proc(str_id : ^u8, popup_flags : ImGuiPopupFlags) -> bool
{
	g : ^ImGuiContext = GImGui^
	window : ^ImGuiWindow = g.CurrentWindow
	if !str_id { str_id = "void_context" }
	id : ImGuiID = GetID(window, str_id)
	mouse_button : i32 = (popup_flags & ImGuiPopupFlags_.ImGuiPopupFlags_MouseButtonMask_)
	if IsMouseReleased(mouse_button) && !IsWindowHovered(ImGuiHoveredFlags_.ImGuiHoveredFlags_AnyWindow) { if GetTopMostPopupModal() == nil { OpenPopupEx(id, popup_flags) } }
	return BeginPopupEx(id, ImGuiWindowFlags_.ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_.ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_.ImGuiWindowFlags_NoSavedSettings)
}

// r_avoid = the rectangle to avoid (e.g. for tooltip it is a rectangle around the mouse cursor which we want to avoid. for popups it's a small point around the cursor.)
// r_outer = the visible area rectangle, minus safe area padding. If our popup size won't fit because of safe area padding we ignore it.
// (r_outer is usually equivalent to the viewport rectangle minus padding, but when multi-viewports are enabled and monitor
//  information are available, it may represent the entire platform monitor from the frame of reference of the current viewport.
//  this allows us to have tooltips/popups displayed out of the parent viewport.)
FindBestWindowPosForPopupEx :: proc(ref_pos : ^ImVec2, size : ^ImVec2, last_dir : ^ImGuiDir, r_outer : ^ImRect, r_avoid : ^ImRect, policy : ImGuiPopupPositionPolicy) -> ImVec2
{
	base_pos_clamped : ImVec2 = ImClamp(ref_pos, r_outer.Min, r_outer.Max - size)
	//GetForegroundDrawList()->AddRect(r_avoid.Min, r_avoid.Max, IM_COL32(255,0,0,255));
	//GetForegroundDrawList()->AddRect(r_outer.Min, r_outer.Max, IM_COL32(0,255,0,255));

	// Combo Box policy (we want a connecting edge)
	if policy == ImGuiPopupPositionPolicy.ImGuiPopupPositionPolicy_ComboBox {
		dir_prefered_order : [ImGuiDir.ImGuiDir_COUNT]ImGuiDir = {ImGuiDir.ImGuiDir_Down, ImGuiDir.ImGuiDir_Right, ImGuiDir.ImGuiDir_Left, ImGuiDir.ImGuiDir_Up}
		for n : i32 = (last_dir^ != ImGuiDir.ImGuiDir_None) ? -1 : 0; n < ImGuiDir.ImGuiDir_COUNT; post_incr(&n) {
			dir : ImGuiDir = (n == -1) ? last_dir^ : dir_prefered_order[n]
			if n != -1 && dir == last_dir^ {
				// Already tried this direction?continue
			}
			pos : ImVec2
			if dir == ImGuiDir.ImGuiDir_Down {
				// Below, Toward Right (default)
				pos = ImVec2(r_avoid.Min.x, r_avoid.Max.y)
			}
			if dir == ImGuiDir.ImGuiDir_Right {
				// Above, Toward Right
				pos = ImVec2(r_avoid.Min.x, r_avoid.Min.y - size.y)
			}
			if dir == ImGuiDir.ImGuiDir_Left {
				// Below, Toward Left
				pos = ImVec2(r_avoid.Max.x - size.x, r_avoid.Max.y)
			}
			if dir == ImGuiDir.ImGuiDir_Up {
				// Above, Toward Left
				pos = ImVec2(r_avoid.Max.x - size.x, r_avoid.Min.y - size.y)
			}
			if !Contains(&r_outer, ImRect(pos, pos + size)) { continue }
			last_dir^ = dir
			return pos
		}
	}

	// Tooltip and Default popup policy
	// (Always first try the direction we used on the last frame, if any)
	if policy == ImGuiPopupPositionPolicy.ImGuiPopupPositionPolicy_Tooltip || policy == ImGuiPopupPositionPolicy.ImGuiPopupPositionPolicy_Default {
		dir_prefered_order : [ImGuiDir.ImGuiDir_COUNT]ImGuiDir = {ImGuiDir.ImGuiDir_Right, ImGuiDir.ImGuiDir_Down, ImGuiDir.ImGuiDir_Up, ImGuiDir.ImGuiDir_Left}
		for n : i32 = (last_dir^ != ImGuiDir.ImGuiDir_None) ? -1 : 0; n < ImGuiDir.ImGuiDir_COUNT; post_incr(&n) {
			dir : ImGuiDir = (n == -1) ? last_dir^ : dir_prefered_order[n]
			if n != -1 && dir == last_dir^ {
				// Already tried this direction?continue
			}

			avail_w : f32 = (dir == ImGuiDir.ImGuiDir_Left ? r_avoid.Min.x : r_outer.Max.x) - (dir == ImGuiDir.ImGuiDir_Right ? r_avoid.Max.x : r_outer.Min.x)
			avail_h : f32 = (dir == ImGuiDir.ImGuiDir_Up ? r_avoid.Min.y : r_outer.Max.y) - (dir == ImGuiDir.ImGuiDir_Down ? r_avoid.Max.y : r_outer.Min.y)

			// If there's not enough room on one axis, there's no point in positioning on a side on this axis (e.g. when not enough width, use a top/bottom position to maximize available width)
			if avail_w < size.x && (dir == ImGuiDir.ImGuiDir_Left || dir == ImGuiDir.ImGuiDir_Right) { continue }
			if avail_h < size.y && (dir == ImGuiDir.ImGuiDir_Up || dir == ImGuiDir.ImGuiDir_Down) { continue }

			pos : ImVec2
			pos.x = (dir == ImGuiDir.ImGuiDir_Left) ? r_avoid.Min.x - size.x : (dir == ImGuiDir.ImGuiDir_Right) ? r_avoid.Max.x : base_pos_clamped.x
			pos.y = (dir == ImGuiDir.ImGuiDir_Up) ? r_avoid.Min.y - size.y : (dir == ImGuiDir.ImGuiDir_Down) ? r_avoid.Max.y : base_pos_clamped.y

			// Clamp top-left corner of popup
			pos.x = ImMax(pos.x, r_outer.Min.x)
			pos.y = ImMax(pos.y, r_outer.Min.y)

			last_dir^ = dir
			return pos
		}
	}

	// Fallback when not enough room:
	last_dir^ = ImGuiDir.ImGuiDir_None

	// For tooltip we prefer avoiding the cursor at all cost even if it means that part of the tooltip won't be visible.
	if policy == ImGuiPopupPositionPolicy.ImGuiPopupPositionPolicy_Tooltip { return ref_pos + ImVec2(2, 2) }

	// Otherwise try to keep within display
	pos : ImVec2 = ref_pos
	pos.x = ImMax(ImMin(pos.x + size.x, r_outer.Max.x) - size.x, r_outer.Min.x)
	pos.y = ImMax(ImMin(pos.y + size.y, r_outer.Max.y) - size.y, r_outer.Min.y)
	return pos
}

// Note that this is used for popups, which can overlap the non work-area of individual viewports.
GetPopupAllowedExtentRect :: proc(window : ^ImGuiWindow) -> ImRect
{
	g : ^ImGuiContext = GImGui^
	r_screen : ImRect
	if window.ViewportAllowPlatformMonitorExtend >= 0 {
		// Extent with be in the frame of reference of the given viewport (so Min is likely to be negative here)
		monitor : ^ImGuiPlatformMonitor = g.PlatformIO.Monitors[window.ViewportAllowPlatformMonitorExtend]
		r_screen.Min = monitor.WorkPos
		r_screen.Max = monitor.WorkPos + monitor.WorkSize
	}
	else {
		// Use the full viewport area (not work area) for popups
		r_screen = GetMainRect(window.Viewport)
	}
	padding : ImVec2 = g.Style.DisplaySafeAreaPadding
	Expand(&r_screen, ImVec2((GetWidth(&r_screen) > padding.x * 2) ? -padding.x : 0.0, (GetHeight(&r_screen) > padding.y * 2) ? -padding.y : 0.0))
	return r_screen
}

FindBestWindowPosForPopup :: proc(window : ^ImGuiWindow) -> ImVec2
{
	g : ^ImGuiContext = GImGui^

	r_outer : ImRect = GetPopupAllowedExtentRect(window)
	if window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_ChildMenu {
		// Child menus typically request _any_ position within the parent menu item, and then we move the new menu outside the parent bounds.
		// This is how we end up with child menus appearing (most-commonly) on the right of the parent menu.
		parent_window : ^ImGuiWindow = window.ParentWindow
		horizontal_overlap : f32 = g.Style.ItemInnerSpacing.x; // We want some overlap to convey the relative depth of each menu (currently the amount of overlap is hard-coded to style.ItemSpacing.x).
		r_avoid : ImRect
		if parent_window.DC.MenuBarAppending {
			// Avoid parent menu-bar. If we wanted multi-line menu-bar, we may instead want to have the calling window setup e.g. a NextWindowData.PosConstraintAvoidRect field
			r_avoid = ImRect(-FLT_MAX, parent_window.ClipRect.Min.y, FLT_MAX, parent_window.ClipRect.Max.y)
		}
		else { r_avoid = ImRect(parent_window.Pos.x + horizontal_overlap, -FLT_MAX, parent_window.Pos.x + parent_window.Size.x - horizontal_overlap - parent_window.ScrollbarSizes.x, FLT_MAX) }
		return FindBestWindowPosForPopupEx(window.Pos, window.Size, &window.AutoPosLastDirection, r_outer, r_avoid, ImGuiPopupPositionPolicy.ImGuiPopupPositionPolicy_Default)
	}
	if window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_Popup {
		return FindBestWindowPosForPopupEx(window.Pos, window.Size, &window.AutoPosLastDirection, r_outer, ImRect(window.Pos, window.Pos), ImGuiPopupPositionPolicy.ImGuiPopupPositionPolicy_Default)// Ideally we'd disable r_avoid here
	}
	if window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_Tooltip {
		// Position tooltip (always follows mouse + clamp within outer boundaries)
		// FIXME:
		// - Too many paths. One problem is that FindBestWindowPosForPopupEx() doesn't allow passing a suggested position (so touch screen path doesn't use it by default).
		// - Drag and drop tooltips are not using this path either: BeginTooltipEx() manually sets their position.
		// - Require some tidying up. In theory we could handle both cases in same location, but requires a bit of shuffling
		//   as drag and drop tooltips are calling SetNextWindowPos() leading to 'window_pos_set_by_api' being set in Begin().
		IM_ASSERT(g.CurrentWindow == window)
		scale : f32 = g.Style.MouseCursorScale
		ref_pos : ImVec2 = NavCalcPreferredRefPos()

		if g.IO.MouseSource == ImGuiMouseSource.ImGuiMouseSource_TouchScreen && NavCalcPreferredRefPosSource() == ImGuiInputSource.ImGuiInputEventType_Mouse {
			tooltip_pos : ImVec2 = ref_pos + TOOLTIP_DEFAULT_OFFSET_TOUCH * scale - (TOOLTIP_DEFAULT_PIVOT_TOUCH * window.Size)
			if Contains(&r_outer, ImRect(tooltip_pos, tooltip_pos + window.Size)) { return tooltip_pos }
		}

		tooltip_pos : ImVec2 = ref_pos + TOOLTIP_DEFAULT_OFFSET_MOUSE * scale
		r_avoid : ImRect
		if g.NavCursorVisible && g.NavHighlightItemUnderNav && !g.IO.ConfigNavMoveSetMousePos { r_avoid = ImRect(ref_pos.x - 16, ref_pos.y - 8, ref_pos.x + 16, ref_pos.y + 8) }
		else {
			// FIXME: Hard-coded based on mouse cursor shape expectation. Exact dimension not very important.
			r_avoid = ImRect(ref_pos.x - 16, ref_pos.y - 8, ref_pos.x + 24 * scale, ref_pos.y + 24 * scale)
		}
		//GetForegroundDrawList()->AddRect(r_avoid.Min, r_avoid.Max, IM_COL32(255, 0, 255, 255));

		return FindBestWindowPosForPopupEx(tooltip_pos, window.Size, &window.AutoPosLastDirection, r_outer, r_avoid, ImGuiPopupPositionPolicy.ImGuiPopupPositionPolicy_Tooltip)
	}
	IM_ASSERT(0)
	return window.Pos
}

// (not recommended) set current window to be focused / top-most. prefer using SetNextWindowFocus().
// set named window to be focused / top-most. use NULL to remove focus.
//-----------------------------------------------------------------------------
// [SECTION] WINDOW FOCUS
//----------------------------------------------------------------------------
// - SetWindowFocus()
// - SetNextWindowFocus()
// - IsWindowFocused()
// - UpdateWindowInFocusOrderList() [Internal]
// - BringWindowToFocusFront() [Internal]
// - BringWindowToDisplayFront() [Internal]
// - BringWindowToDisplayBack() [Internal]
// - BringWindowToDisplayBehind() [Internal]
// - FindWindowDisplayIndex() [Internal]
// - FocusWindow() [Internal]
// - FocusTopMostWindowUnderOne() [Internal]
//-----------------------------------------------------------------------------

SetWindowFocus_0 :: proc()
{
	FocusWindow(GImGui.CurrentWindow)
}

// (not recommended) set current window to be focused / top-most. prefer using SetNextWindowFocus().
// set named window to be focused / top-most. use NULL to remove focus.
SetWindowFocus_1 :: proc(name : ^u8)
{
	if name {
		if window : ^ImGuiWindow = FindWindowByName(name); window { FocusWindow(window) }
	}
	else {
		FocusWindow(nil)
	}
}

// set next window to be focused / top-most. call before Begin()
SetNextWindowFocus :: proc()
{
	g : ^ImGuiContext = GImGui^
	g.NextWindowData.Flags |= ImGuiNextWindowDataFlags_.ImGuiNextWindowDataFlags_HasFocus
}

// is current window focused? or its root/child, depending on flags. see flags for options.
// Similar to IsWindowHovered()
IsWindowFocused :: proc(flags : ImGuiFocusedFlags) -> bool
{
	g : ^ImGuiContext = GImGui^
	ref_window : ^ImGuiWindow = g.NavWindow
	cur_window : ^ImGuiWindow = g.CurrentWindow

	if ref_window == nil { return false }
	if ImGuiFocusedFlags_AnyWindow : ^flags; ImGuiFocusedFlags_AnyWindow { return true }

	IM_ASSERT(cur_window); // Not inside a Begin()/End()
	popup_hierarchy : bool = (flags & ImGuiFocusedFlags_.ImGuiFocusedFlags_NoPopupHierarchy) == 0
	dock_hierarchy : bool = (flags & ImGuiFocusedFlags_.ImGuiFocusedFlags_DockHierarchy) != 0
	if ImGuiHoveredFlags_RootWindow : ^flags; ImGuiHoveredFlags_RootWindow { cur_window = GetCombinedRootWindow(cur_window, popup_hierarchy, dock_hierarchy) }

	if ImGuiHoveredFlags_ChildWindows : ^flags; ImGuiHoveredFlags_ChildWindows { return IsWindowChildOf(ref_window, cur_window, popup_hierarchy, dock_hierarchy) }
	else { return (ref_window == cur_window) }
}

// Window Focus
FindWindowFocusIndex :: proc(window : ^ImGuiWindow) -> i32
{
	g : ^ImGuiContext = GImGui^
	IM_UNUSED(g)
	order : i32 = window.FocusOrder
	IM_ASSERT(window.RootWindow == window); // No child window (not testing _ChildWindow because of docking)
	IM_ASSERT(g.WindowsFocusOrder[order] == window)
	return order
}

UpdateWindowInFocusOrderList :: proc(window : ^ImGuiWindow, just_created : bool, new_flags : ImGuiWindowFlags)
{
	g : ^ImGuiContext = GImGui^

	new_is_explicit_child : bool = (new_flags & ImGuiWindowFlags_.ImGuiWindowFlags_ChildWindow) != 0 && ((new_flags & ImGuiWindowFlags_.ImGuiWindowFlags_Popup) == 0 || (new_flags & ImGuiWindowFlags_.ImGuiWindowFlags_ChildMenu) != 0)
	child_flag_changed : bool = new_is_explicit_child != window.IsExplicitChild
	if (just_created || child_flag_changed) && !new_is_explicit_child {
		IM_ASSERT(!contains(&g.WindowsFocusOrder, window))
		push_back(&g.WindowsFocusOrder, window)
		window.FocusOrder = cast(i16) (g.WindowsFocusOrder.Size - 1)
	}
	else if !just_created && child_flag_changed && new_is_explicit_child {
		IM_ASSERT(g.WindowsFocusOrder[window.FocusOrder] == window)
		for n : i32 = window.FocusOrder + 1; n < g.WindowsFocusOrder.Size; post_incr(&n) { post_decr(&g.WindowsFocusOrder[n].FocusOrder) }

		erase(&g.WindowsFocusOrder, g.WindowsFocusOrder.Data + window.FocusOrder)
		window.FocusOrder = -1
	}
	window.IsExplicitChild = new_is_explicit_child
}

BringWindowToFocusFront :: proc(window : ^ImGuiWindow)
{
	g : ^ImGuiContext = GImGui^
	IM_ASSERT(window == window.RootWindow)

	cur_order : i32 = window.FocusOrder
	IM_ASSERT(g.WindowsFocusOrder[cur_order] == window)
	if back(&g.WindowsFocusOrder) == window { return }

	new_order : i32 = g.WindowsFocusOrder.Size - 1
	for n : i32 = cur_order; n < new_order; post_incr(&n) {
		g.WindowsFocusOrder[n] = g.WindowsFocusOrder[n + 1]
		post_decr(&g.WindowsFocusOrder[n].FocusOrder)
		IM_ASSERT(g.WindowsFocusOrder[n].FocusOrder == n)
	}

	g.WindowsFocusOrder[new_order] = window
	window.FocusOrder = cast(i16) new_order
}

// Note technically focus related but rather adjacent and close to BringWindowToFocusFront()
BringWindowToDisplayFront :: proc(window : ^ImGuiWindow)
{
	g : ^ImGuiContext = GImGui^
	current_front_window : ^ImGuiWindow = back(&g.Windows)
	if current_front_window == window || current_front_window.RootWindowDockTree == window {
		// Cheap early out (could be better)return
	}
	for i : i32 = g.Windows.Size - 2; i >= 0; post_decr(&i) { if g.Windows[i] == window {
	memmove(&g.Windows[i], &g.Windows[i + 1], cast(uint) (g.Windows.Size - i - 1) * size_of(^ImGuiWindow))
	g.Windows[g.Windows.Size - 1] = window
	break
} }
}

BringWindowToDisplayBack :: proc(window : ^ImGuiWindow)
{
	g : ^ImGuiContext = GImGui^
	if g.Windows[0] == window { return }
	for i : i32 = 0; i < g.Windows.Size; post_incr(&i) { if g.Windows[i] == window {
	memmove(&g.Windows[1], &g.Windows[0], cast(uint) i * size_of(^ImGuiWindow))
	g.Windows[0] = window
	break
} }
}

BringWindowToDisplayBehind :: proc(window : ^ImGuiWindow, behind_window : ^ImGuiWindow)
{
	IM_ASSERT(window != nil && behind_window != nil)
	g : ^ImGuiContext = GImGui^
	window = window.RootWindow
	behind_window = behind_window.RootWindow
	pos_wnd : i32 = FindWindowDisplayIndex(window)
	pos_beh : i32 = FindWindowDisplayIndex(behind_window)
	if pos_wnd < pos_beh {
		copy_bytes : uint = (pos_beh - pos_wnd - 1) * size_of(^ImGuiWindow)
		memmove(&g.Windows.Data[pos_wnd], &g.Windows.Data[pos_wnd + 1], copy_bytes)
		g.Windows[pos_beh - 1] = window
	}
	else {
		copy_bytes : uint = (pos_wnd - pos_beh) * size_of(^ImGuiWindow)
		memmove(&g.Windows.Data[pos_beh + 1], &g.Windows.Data[pos_beh], copy_bytes)
		g.Windows[pos_beh] = window
	}
}

FindWindowDisplayIndex :: proc(window : ^ImGuiWindow) -> i32
{
	g : ^ImGuiContext = GImGui^
	return index_from_ptr(&g.Windows, find(&g.Windows, window))
}

// Windows: Display Order and Focus Order
// Moving window to front of display and set focus (which happens to be back of our sorted list)
FocusWindow :: proc(window : ^ImGuiWindow, flags : ImGuiFocusRequestFlags)
{
	g : ^ImGuiContext = GImGui^

	// Modal check?
	if (flags & ImGuiFocusRequestFlags_.ImGuiFocusRequestFlags_UnlessBelowModal) && (g.NavWindow != window) {
		// Early out in common case.
		if blocking_modal : ^ImGuiWindow = FindBlockingModal(window); blocking_modal {
			// This block would typically be reached in two situations:
			// - API call to FocusWindow() with a window under a modal and ImGuiFocusRequestFlags_UnlessBelowModal flag.
			// - User clicking on void or anything behind a modal while a modal is open (window == NULL)
			IMGUI_DEBUG_LOG_FOCUS("[focus] FocusWindow(\"%s\", UnlessBelowModal): prevented by \"%s\".\n", window ? window.Name : "<NULL>", blocking_modal.Name)
			if window && window == window.RootWindow && (window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoBringToFrontOnFocus) == 0 {
				// Still bring right under modal. (FIXME: Could move in focus list too?)
				BringWindowToDisplayBehind(window, blocking_modal)
			}
			ClosePopupsOverWindow(GetTopMostPopupModal(), false); // Note how we need to use GetTopMostPopupModal() aad NOT blocking_modal, to handle nested modals
			return
		}
	}

	// Find last focused child (if any) and focus it instead.
	if (flags & ImGuiFocusRequestFlags_.ImGuiFocusRequestFlags_RestoreFocusedChild) && window != nil { window = NavRestoreLastChildNavWindow(window) }

	// Apply focus
	if g.NavWindow != window {
		SetNavWindow(window)
		if window && g.NavHighlightItemUnderNav { g.NavMousePosDirty = true }
		g.NavId = window ? window.NavLastIds[0] : 0; // Restore NavId
		g.NavLayer = ImGuiNavLayer.ImGuiNavLayer_Main
		SetNavFocusScope(window ? window.NavRootFocusScopeId : 0)
		g.NavIdIsAlive = false
		g.NavLastValidSelectionUserData = ImGuiSelectionUserData_Invalid

		// Close popups if any
		ClosePopupsOverWindow(window, false)
	}

	// Move the root window to the top of the pile
	IM_ASSERT(window == nil || window.RootWindowDockTree != nil)
	focus_front_window : ^ImGuiWindow = window ? window.RootWindow : nil
	display_front_window : ^ImGuiWindow = window ? window.RootWindowDockTree : nil
	dock_node : ^ImGuiDockNode = window ? window.DockNode : nil
	active_id_window_is_dock_node_host : bool = (g.ActiveIdWindow && dock_node && dock_node.HostWindow == g.ActiveIdWindow)

	// Steal active widgets. Some of the cases it triggers includes:
	// - Focus a window while an InputText in another window is active, if focus happens before the old InputText can run.
	// - When using Nav to activate menu items (due to timing of activating on press->new window appears->losing ActiveId)
	// - Using dock host items (tab, collapse button) can trigger this before we redirect the ActiveIdWindow toward the child window.
	if g.ActiveId != 0 && g.ActiveIdWindow && g.ActiveIdWindow.RootWindow != focus_front_window { if !g.ActiveIdNoClearOnFocusLoss && !active_id_window_is_dock_node_host { ClearActiveID() } }

	// Passing NULL allow to disable keyboard focus
	if !window { return }
	window.LastFrameJustFocused = g.FrameCount

	// Select in dock node
	// For #2304 we avoid applying focus immediately before the tabbar is visible.
	//if (dock_node && dock_node->TabBar)
	//    dock_node->TabBar->SelectedTabId = dock_node->TabBar->NextSelectedTabId = window->TabId;

	// Bring to front
	BringWindowToFocusFront(focus_front_window)
	if ((window.Flags | focus_front_window.Flags | display_front_window.Flags) & ImGuiWindowFlags_.ImGuiWindowFlags_NoBringToFrontOnFocus) == 0 { BringWindowToDisplayFront(display_front_window) }
}

FocusTopMostWindowUnderOne :: proc(under_this_window : ^ImGuiWindow, ignore_window : ^ImGuiWindow, filter_viewport : ^ImGuiViewport, flags : ImGuiFocusRequestFlags)
{
	g : ^ImGuiContext = GImGui^
	start_idx : i32 = g.WindowsFocusOrder.Size - 1
	if under_this_window != nil {
		// Aim at root window behind us, if we are in a child window that's our own root (see #4640)
		offset : i32 = -1
		for under_this_window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_ChildWindow {
			under_this_window = under_this_window.ParentWindow
			offset = 0
		}

		start_idx = FindWindowFocusIndex(under_this_window) + offset
	}
	for i : i32 = start_idx; i >= 0; post_decr(&i) {
		// We may later decide to test for different NoXXXInputs based on the active navigation input (mouse vs nav) but that may feel more confusing to the user.
		window : ^ImGuiWindow = g.WindowsFocusOrder[i]
		if window == ignore_window || !window.WasActive { continue }
		if filter_viewport != nil && window.Viewport != filter_viewport { continue }
		if (window.Flags & (ImGuiWindowFlags_.ImGuiWindowFlags_NoMouseInputs | ImGuiWindowFlags_.ImGuiWindowFlags_NoNavInputs)) != (ImGuiWindowFlags_.ImGuiWindowFlags_NoMouseInputs | ImGuiWindowFlags_.ImGuiWindowFlags_NoNavInputs) {
			// FIXME-DOCK: When ImGuiFocusRequestFlags_RestoreFocusedChild is set...
			// This is failing (lagging by one frame) for docked windows.
			// If A and B are docked into window and B disappear, at the NewFrame() call site window->NavLastChildNavWindow will still point to B.
			// We might leverage the tab order implicitly stored in window->DockNodeAsHost->TabBar (essentially the 'most_recently_selected_tab' code in tab bar will do that but on next update)
			// to tell which is the "previous" window. Or we may leverage 'LastFrameFocused/LastFrameJustFocused' and have this function handle child window itself?
			FocusWindow(window, flags)
			return
		}
	}

	FocusWindow(nil, flags)
}

// Keyboard/Gamepad Navigation
// alter visibility of keyboard/gamepad cursor. by default: show when using an arrow key, hide when clicking with mouse.
//-----------------------------------------------------------------------------
// [SECTION] KEYBOARD/GAMEPAD NAVIGATION
//-----------------------------------------------------------------------------

// FIXME-NAV: The existence of SetNavID vs SetFocusID vs FocusWindow() needs to be clarified/reworked.
// In our terminology those should be interchangeable, yet right now this is super confusing.
// Those two functions are merely a legacy artifact, so at minimum naming should be clarified.

SetNavCursorVisible :: proc(visible : bool)
{
	g : ^ImGuiContext = GImGui^
	if g.IO.ConfigNavCursorVisibleAlways { visible = true }
	g.NavCursorVisible = visible
}

// (was called NavRestoreHighlightAfterMove() before 1.91.4)
SetNavCursorVisibleAfterMove :: proc()
{
	g : ^ImGuiContext = GImGui^
	if g.IO.ConfigNavCursorVisibleAuto { g.NavCursorVisible = true }
	g.NavMousePosDirty = true; g.NavHighlightItemUnderNav = g.NavMousePosDirty
}

SetNavWindow :: proc(window : ^ImGuiWindow)
{
	g : ^ImGuiContext = GImGui^
	if g.NavWindow != window {
		IMGUI_DEBUG_LOG_FOCUS("[focus] SetNavWindow(\"%s\")\n", window ? window.Name : "<NULL>")
		g.NavWindow = window
		g.NavLastValidSelectionUserData = ImGuiSelectionUserData_Invalid
	}
	g.NavMoveScoringItems = false; g.NavMoveSubmitted = g.NavMoveScoringItems; g.NavInitRequest = g.NavMoveSubmitted
	NavUpdateAnyRequestFlag()
}

NavHighlightActivated :: proc(id : ImGuiID)
{
	g : ^ImGuiContext = GImGui^
	g.NavHighlightActivatedId = id
	g.NavHighlightActivatedTimer = NAV_ACTIVATE_HIGHLIGHT_TIMER
}

NavClearPreferredPosForAxis :: proc(axis : ImGuiAxis)
{
	g : ^ImGuiContext = GImGui^
	g.NavWindow.RootWindowForNav.NavPreferredScoringPosRel[g.NavLayer][axis] = FLT_MAX
}

SetNavID :: proc(id : ImGuiID, nav_layer : ImGuiNavLayer, focus_scope_id : ImGuiID, rect_rel : ^ImRect)
{
	g : ^ImGuiContext = GImGui^
	IM_ASSERT(g.NavWindow != nil)
	IM_ASSERT(nav_layer == ImGuiNavLayer.ImGuiNavLayer_Main || nav_layer == ImGuiNavLayer.ImGuiNavLayer_Menu)
	g.NavId = id
	g.NavLayer = nav_layer
	SetNavFocusScope(focus_scope_id)
	g.NavWindow.NavLastIds[nav_layer] = id
	g.NavWindow.NavRectRel[nav_layer] = rect_rel

	// Clear preferred scoring position (NavMoveRequestApplyResult() will tend to restore it)
	NavClearPreferredPosForAxis(ImGuiAxis.ImGuiAxis_X)
	NavClearPreferredPosForAxis(ImGuiAxis.ImGuiAxis_Y)
}

SetFocusID :: proc(id : ImGuiID, window : ^ImGuiWindow)
{
	g : ^ImGuiContext = GImGui^
	IM_ASSERT(id != 0)

	if g.NavWindow != window { SetNavWindow(window) }

	// Assume that SetFocusID() is called in the context where its window->DC.NavLayerCurrent and g.CurrentFocusScopeId are valid.
	// Note that window may be != g.CurrentWindow (e.g. SetFocusID call in InputTextEx for multi-line text)
	nav_layer : ImGuiNavLayer = window.DC.NavLayerCurrent
	g.NavId = id
	g.NavLayer = nav_layer
	SetNavFocusScope(g.CurrentFocusScopeId)
	window.NavLastIds[nav_layer] = id
	if g.LastItemData.ID == id { window.NavRectRel[nav_layer] = WindowRectAbsToRel(window, g.LastItemData.NavRect) }

	if g.ActiveIdSource == ImGuiInputSource.ImGuiInputSource_Keyboard || g.ActiveIdSource == ImGuiInputSource.ImGuiInputSource_Gamepad { g.NavHighlightItemUnderNav = true }
	else if g.IO.ConfigNavCursorVisibleAuto { g.NavCursorVisible = false }

	// Clear preferred scoring position (NavMoveRequestApplyResult() will tend to restore it)
	NavClearPreferredPosForAxis(ImGuiAxis.ImGuiAxis_X)
	NavClearPreferredPosForAxis(ImGuiAxis.ImGuiAxis_Y)
}

ImGetDirQuadrantFromDelta :: proc(dx : f32, dy : f32) -> ImGuiDir
{
	if ImFabs(dx) > ImFabs(dy) { return (dx > 0.0) ? ImGuiDir.ImGuiDir_Right : ImGuiDir.ImGuiDir_Left }
	return (dy > 0.0) ? ImGuiDir.ImGuiDir_Down : ImGuiDir.ImGuiDir_Up
}

NavScoreItemDistInterval :: #force_inline proc(cand_min : f32, cand_max : f32, curr_min : f32, curr_max : f32) -> f32
{
	if cand_max < curr_min { return cand_max - curr_min }
	if curr_max < cand_min { return cand_min - curr_max }
	return 0.0
}

// Scoring function for keyboard/gamepad directional navigation. Based on https://gist.github.com/rygorous/6981057
NavScoreItem :: proc(result : ^ImGuiNavItemData) -> bool
{
	g : ^ImGuiContext = GImGui^
	window : ^ImGuiWindow = g.CurrentWindow
	if g.NavLayer != window.DC.NavLayerCurrent { return false }

	// FIXME: Those are not good variables names
	cand : ImRect = g.LastItemData.NavRect; // Current item nav rectangle
	curr : ImRect = g.NavScoringRect; // Current modified source rect (NB: we've applied Max.x = Min.x in NavUpdate() to inhibit the effect of having varied item width)
	post_incr(&g.NavScoringDebugCount)

	// When entering through a NavFlattened border, we consider child window items as fully clipped for scoring
	if window.ParentWindow == g.NavWindow {
		IM_ASSERT((window.ChildFlags | g.NavWindow.ChildFlags) & ImGuiChildFlags_.ImGuiChildFlags_NavFlattened)
		if !Overlaps(&window.ClipRect, cand) { return false }
		ClipWithFull(&cand, window.ClipRect); // This allows the scored item to not overlap other candidates in the parent window
	}

	// Compute distance between boxes
	// FIXME-NAV: Introducing biases for vertical navigation, needs to be removed.
	dbx : f32 = NavScoreItemDistInterval(cand.Min.x, cand.Max.x, curr.Min.x, curr.Max.x)
	dby : f32 = NavScoreItemDistInterval(ImLerp(cand.Min.y, cand.Max.y, 0.2), ImLerp(cand.Min.y, cand.Max.y, 0.8), ImLerp(curr.Min.y, curr.Max.y, 0.2), ImLerp(curr.Min.y, curr.Max.y, 0.8)); // Scale down on Y to keep using box-distance for vertically touching items
	if dby != 0.0 && dbx != 0.0 { dbx = (dbx / 1000.0) + ((dbx > 0.0) ? +1.0 : -1.0) }
	dist_box : f32 = ImFabs(dbx) + ImFabs(dby)

	// Compute distance between centers (this is off by a factor of 2, but we only compare center distances with each other so it doesn't matter)
	dcx : f32 = (cand.Min.x + cand.Max.x) - (curr.Min.x + curr.Max.x)
	dcy : f32 = (cand.Min.y + cand.Max.y) - (curr.Min.y + curr.Max.y)
	dist_center : f32 = ImFabs(dcx) + ImFabs(dcy); // L1 metric (need this for our connectedness guarantee)

	// Determine which quadrant of 'curr' our candidate item 'cand' lies in based on distance
	quadrant : ImGuiDir
	dax : f32 = 0.0; day : f32 = 0.0; dist_axial : f32 = 0.0
	if dbx != 0.0 || dby != 0.0 {
		// For non-overlapping boxes, use distance between boxes
		// FIXME-NAV: Quadrant may be incorrect because of (1) dbx bias and (2) curr.Max.y bias applied by NavBiasScoringRect() where typically curr.Max.y==curr.Min.y
		// One typical case where this happens, with style.WindowMenuButtonPosition == ImGuiDir_Right, pressing Left to navigate from Close to Collapse tends to fail.
		// Also see #6344. Calling ImGetDirQuadrantFromDelta() with unbiased values may be good but side-effects are plenty.
		dax = dbx
		day = dby
		dist_axial = dist_box
		quadrant = ImGetDirQuadrantFromDelta(dbx, dby)
	}
	else if dcx != 0.0 || dcy != 0.0 {
		// For overlapping boxes with different centers, use distance between centers
		dax = dcx
		day = dcy
		dist_axial = dist_center
		quadrant = ImGetDirQuadrantFromDelta(dcx, dcy)
	}
	else {
		// Degenerate case: two overlapping buttons with same center, break ties arbitrarily (note that LastItemId here is really the _previous_ item order, but it doesn't matter)
		quadrant = (g.LastItemData.ID < g.NavId) ? ImGuiDir.ImGuiDir_Left : ImGuiDir.ImGuiDir_Right
	}

	move_dir : ImGuiDir = g.NavMoveDir
	when IMGUI_DEBUG_NAV_SCORING {
	buf : [200]u8
	if g.IO.KeyCtrl {
		// Hold CTRL to preview score in matching quadrant. CTRL+Arrow to rotate.
		if quadrant == move_dir {
			ImFormatString(buf, IM_ARRAYSIZE(buf), "%.0f/%.0f", dist_box, dist_center)
			draw_list : ^ImDrawList = GetForegroundDrawList(window)
			AddRectFilled(draw_list, cand.Min, cand.Max, IM_COL32(255, 0, 0, 80))
			AddRectFilled(draw_list, cand.Min, cand.Min + CalcTextSize(buf), IM_COL32(255, 0, 0, 200))
			AddText(draw_list, cand.Min, IM_COL32(255, 255, 255, 255), buf)
		}
	}
	debug_hovering : bool = IsMouseHoveringRect(cand.Min, cand.Max)
	debug_tty : bool = (g.IO.KeyCtrl && IsKeyPressed(ImGuiKey.ImGuiKey_Space))
	if debug_hovering || debug_tty {
		ImFormatString(buf, IM_ARRAYSIZE(buf), "d-box    (%7.3f,%7.3f) -> %7.3f\nd-center (%7.3f,%7.3f) -> %7.3f\nd-axial  (%7.3f,%7.3f) -> %7.3f\nnav %c, quadrant %c", dbx, dby, dist_box, dcx, dcy, dist_center, dax, day, dist_axial, "-WENS"[move_dir + 1], "-WENS"[quadrant + 1])
		if debug_hovering {
			draw_list : ^ImDrawList = GetForegroundDrawList(window)
			AddRect(draw_list, curr.Min, curr.Max, IM_COL32(255, 200, 0, 100))
			AddRect(draw_list, cand.Min, cand.Max, IM_COL32(255, 255, 0, 200))
			AddRectFilled(draw_list, cand.Max - ImVec2(4, 4), cand.Max + CalcTextSize(buf) + ImVec2(4, 4), IM_COL32(40, 0, 0, 200))
			AddText(draw_list, cand.Max, !0, buf)
		}
		if debug_tty { IMGUI_DEBUG_LOG_NAV("id 0x%08X\n%s\n", g.LastItemData.ID, buf) }
	}
	} // preproc endif

	// Is it in the quadrant we're interested in moving to?
	new_best : bool = false
	if quadrant == move_dir {
		// Does it beat the current best candidate?
		if dist_box < result.DistBox {
			result.DistBox = dist_box
			result.DistCenter = dist_center
			return true
		}
		if dist_box == result.DistBox {
			// Try using distance between center points to break ties
			if dist_center < result.DistCenter {
				result.DistCenter = dist_center
				new_best = true
			}
			else if dist_center == result.DistCenter {
				// Still tied! we need to be extra-careful to make sure everything gets linked properly. We consistently break ties by symbolically moving "later" items
				// (with higher index) to the right/downwards by an infinitesimal amount since we the current "best" button already (so it must have a lower index),
				// this is fairly easy. This rule ensures that all buttons with dx==dy==0 will end up being linked in order of appearance along the x axis.
				if ((move_dir == ImGuiDir.ImGuiDir_Up || move_dir == ImGuiDir.ImGuiDir_Down) ? dby : dbx) < 0.0 {
					// moving bj to the right/down decreases distancenew_best = true
				}
			}
		}
	}

	// Axial check: if 'curr' has no link at all in some direction and 'cand' lies roughly in that direction, add a tentative link. This will only be kept if no "real" matches
	// are found, so it only augments the graph produced by the above method using extra links. (important, since it doesn't guarantee strong connectedness)
	// This is just to avoid buttons having no links in a particular direction when there's a suitable neighbor. you get good graphs without this too.
	// 2017/09/29: FIXME: This now currently only enabled inside menu bars, ideally we'd disable it everywhere. Menus in particular need to catch failure. For general navigation it feels awkward.
	// Disabling it may lead to disconnected graphs when nodes are very spaced out on different axis. Perhaps consider offering this as an option?
	if result.DistBox == FLT_MAX && dist_axial < result.DistAxial {
		// Check axial match
		if g.NavLayer == ImGuiNavLayer.ImGuiNavLayer_Menu && !(g.NavWindow.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_ChildMenu) {
			if (move_dir == ImGuiDir.ImGuiDir_Left && dax < 0.0) || (move_dir == ImGuiDir.ImGuiDir_Right && dax > 0.0) || (move_dir == ImGuiDir.ImGuiDir_Up && day < 0.0) || (move_dir == ImGuiDir.ImGuiDir_Down && day > 0.0) {
				result.DistAxial = dist_axial
				new_best = true
			}
		}
	}

	return new_best
}

NavApplyItemToResult :: proc(result : ^ImGuiNavItemData)
{
	g : ^ImGuiContext = GImGui^
	window : ^ImGuiWindow = g.CurrentWindow
	result.Window = window
	result.ID = g.LastItemData.ID
	result.FocusScopeId = g.CurrentFocusScopeId
	result.ItemFlags = g.LastItemData.ItemFlags
	result.RectRel = WindowRectAbsToRel(window, g.LastItemData.NavRect)
	if result.ItemFlags & ImGuiItemFlagsPrivate_.ImGuiItemFlags_HasSelectionUserData {
		IM_ASSERT(g.NextItemData.SelectionUserData != ImGuiSelectionUserData_Invalid)
		result.SelectionUserData = g.NextItemData.SelectionUserData; // INTENTIONAL: At this point this field is not cleared in NextItemData. Avoid unnecessary copy to LastItemData.
	}
}

// True when current work location may be scrolled horizontally when moving left / right.
// This is generally always true UNLESS within a column. We don't have a vertical equivalent.
NavUpdateCurrentWindowIsScrollPushableX :: proc()
{
	g : ^ImGuiContext = GImGui^
	window : ^ImGuiWindow = g.CurrentWindow
	window.DC.NavIsScrollPushableX = (g.CurrentTable == nil && window.DC.CurrentColumns == nil)
}

// We get there when either NavId == id, or when g.NavAnyRequest is set (which is updated by NavUpdateAnyRequestFlag above)
// This is called after LastItemData is set, but NextItemData is also still valid.
NavProcessItem :: proc()
{
	g : ^ImGuiContext = GImGui^
	window : ^ImGuiWindow = g.CurrentWindow
	id : ImGuiID = g.LastItemData.ID
	item_flags : ImGuiItemFlags = g.LastItemData.ItemFlags

	// When inside a container that isn't scrollable with Left<>Right, clip NavRect accordingly (#2221)
	if window.DC.NavIsScrollPushableX == false {
		g.LastItemData.NavRect.Min.x = ImClamp(g.LastItemData.NavRect.Min.x, window.ClipRect.Min.x, window.ClipRect.Max.x)
		g.LastItemData.NavRect.Max.x = ImClamp(g.LastItemData.NavRect.Max.x, window.ClipRect.Min.x, window.ClipRect.Max.x)
	}
	nav_bb : ImRect = g.LastItemData.NavRect

	// Process Init Request
	if g.NavInitRequest && g.NavLayer == window.DC.NavLayerCurrent && (item_flags & ImGuiItemFlagsPrivate_.ImGuiItemFlags_Disabled) == 0 {
		// Even if 'ImGuiItemFlags_NoNavDefaultFocus' is on (typically collapse/close button) we record the first ResultId so they can be used as a fallback
		candidate_for_nav_default_focus : bool = (item_flags & ImGuiItemFlags_.ImGuiItemFlags_NoNavDefaultFocus) == 0
		if candidate_for_nav_default_focus || g.NavInitResult.ID == 0 {
			NavApplyItemToResult(&g.NavInitResult)
		}
		if candidate_for_nav_default_focus {
			g.NavInitRequest = false; // Found a match, clear request
			NavUpdateAnyRequestFlag()
		}
	}

	// Process Move Request (scoring for navigation)
	// FIXME-NAV: Consider policy for double scoring (scoring from NavScoringRect + scoring from a rect wrapped according to current wrapping policy)
	if g.NavMoveScoringItems && (item_flags & ImGuiItemFlagsPrivate_.ImGuiItemFlags_Disabled) == 0 {
		if (g.NavMoveFlags & ImGuiNavMoveFlags_.ImGuiNavMoveFlags_FocusApi) || (window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoNavInputs) == 0 {
			is_tabbing : bool = (g.NavMoveFlags & ImGuiNavMoveFlags_.ImGuiNavMoveFlags_IsTabbing) != 0
			if is_tabbing {
				NavProcessItemForTabbingRequest(id, item_flags, g.NavMoveFlags)
			}
			else if g.NavId != id || (g.NavMoveFlags & ImGuiNavMoveFlags_.ImGuiNavMoveFlags_AllowCurrentNavId) {
				result : ^ImGuiNavItemData = (window == g.NavWindow) ? &g.NavMoveResultLocal : &g.NavMoveResultOther
				if NavScoreItem(result) { NavApplyItemToResult(result) }

				// Features like PageUp/PageDown need to maintain a separate score for the visible set of items.
				VISIBLE_RATIO : f32 = 0.70
				if (g.NavMoveFlags & ImGuiNavMoveFlags_.ImGuiNavMoveFlags_AlsoScoreVisibleSet) && Overlaps(&window.ClipRect, nav_bb) { if ImClamp(nav_bb.Max.y, window.ClipRect.Min.y, window.ClipRect.Max.y) - ImClamp(nav_bb.Min.y, window.ClipRect.Min.y, window.ClipRect.Max.y) >= (nav_bb.Max.y - nav_bb.Min.y) * VISIBLE_RATIO { if NavScoreItem(&g.NavMoveResultLocalVisible) { NavApplyItemToResult(&g.NavMoveResultLocalVisible) } } }
			}
		}
	}

	// Update information for currently focused/navigated item
	if g.NavId == id {
		if g.NavWindow != window {
			// Always refresh g.NavWindow, because some operations such as FocusItem() may not have a window.
			SetNavWindow(window)
		}
		g.NavLayer = window.DC.NavLayerCurrent
		SetNavFocusScope(g.CurrentFocusScopeId); // Will set g.NavFocusScopeId AND store g.NavFocusScopePath
		g.NavFocusScopeId = g.CurrentFocusScopeId
		g.NavIdIsAlive = true
		if g.LastItemData.ItemFlags & ImGuiItemFlagsPrivate_.ImGuiItemFlags_HasSelectionUserData {
			IM_ASSERT(g.NextItemData.SelectionUserData != ImGuiSelectionUserData_Invalid)
			g.NavLastValidSelectionUserData = g.NextItemData.SelectionUserData; // INTENTIONAL: At this point this field is not cleared in NextItemData. Avoid unnecessary copy to LastItemData.
		}
		window.NavRectRel[window.DC.NavLayerCurrent] = WindowRectAbsToRel(window, nav_bb); // Store item bounding box (relative to window position)
	}
}

// Handle "scoring" of an item for a tabbing/focusing request initiated by NavUpdateCreateTabbingRequest().
// Note that SetKeyboardFocusHere() API calls are considered tabbing requests!
// - Case 1: no nav/active id:    set result to first eligible item, stop storing.
// - Case 2: tab forward:         on ref id set counter, on counter elapse store result
// - Case 3: tab forward wrap:    set result to first eligible item (preemptively), on ref id set counter, on next frame if counter hasn't elapsed store result. // FIXME-TABBING: Could be done as a next-frame forwarded request
// - Case 4: tab backward:        store all results, on ref id pick prev, stop storing
// - Case 5: tab backward wrap:   store all results, on ref id if no result keep storing until last // FIXME-TABBING: Could be done as next-frame forwarded requested
NavProcessItemForTabbingRequest :: proc(id : ImGuiID, item_flags : ImGuiItemFlags, move_flags : ImGuiNavMoveFlags)
{
	g : ^ImGuiContext = GImGui^

	if (move_flags & ImGuiNavMoveFlags_.ImGuiNavMoveFlags_FocusApi) == 0 {
		if g.NavLayer != g.CurrentWindow.DC.NavLayerCurrent { return }
		if g.NavFocusScopeId != g.CurrentFocusScopeId { return }
	}

	// - Can always land on an item when using API call.
	// - Tabbing with _NavEnableKeyboard (space/enter/arrows): goes through every item.
	// - Tabbing without _NavEnableKeyboard: goes through inputable items only.
	can_stop : bool
	if ImGuiNavMoveFlags_FocusApi : ^move_flags; ImGuiNavMoveFlags_FocusApi { can_stop = true }
	else { can_stop = (item_flags & ImGuiItemFlags_.ImGuiItemFlags_NoTabStop) == 0 && ((g.IO.ConfigFlags & ImGuiConfigFlags_.ImGuiConfigFlags_NavEnableKeyboard) || (item_flags & ImGuiItemFlagsPrivate_.ImGuiItemFlags_Inputable)) }

	// Always store in NavMoveResultLocal (unlike directional request which uses NavMoveResultOther on sibling/flattened windows)
	result : ^ImGuiNavItemData = &g.NavMoveResultLocal
	if g.NavTabbingDir == +1 {
		// Tab Forward or SetKeyboardFocusHere() with >= 0
		if can_stop && g.NavTabbingResultFirst.ID == 0 { NavApplyItemToResult(&g.NavTabbingResultFirst) }
		if can_stop && g.NavTabbingCounter > 0 && pre_decr(&g.NavTabbingCounter) == 0 { NavMoveRequestResolveWithLastItem(result) }
		else if g.NavId == id { g.NavTabbingCounter = 1 }
	}
	else if g.NavTabbingDir == -1 {
		// Tab Backward
		if g.NavId == id {
			if result.ID {
				g.NavMoveScoringItems = false
				NavUpdateAnyRequestFlag()
			}
		}
		else if can_stop {
			// Keep applying until reaching NavId
			NavApplyItemToResult(result)
		}
	}
	else if g.NavTabbingDir == 0 {
		if can_stop && g.NavId == id { NavMoveRequestResolveWithLastItem(result) }
		if can_stop && g.NavTabbingResultFirst.ID == 0 {
			// Tab initNavApplyItemToResult(&g.NavTabbingResultFirst)
		}
	}
}

NavMoveRequestButNoResultYet :: proc() -> bool
{
	g : ^ImGuiContext = GImGui^
	return g.NavMoveScoringItems && g.NavMoveResultLocal.ID == 0 && g.NavMoveResultOther.ID == 0
}

// FIXME: ScoringRect is not set
NavMoveRequestSubmit :: proc(move_dir : ImGuiDir, clip_dir : ImGuiDir, move_flags : ImGuiNavMoveFlags, scroll_flags : ImGuiScrollFlags)
{
	g : ^ImGuiContext = GImGui^
	IM_ASSERT(g.NavWindow != nil)
	//IMGUI_DEBUG_LOG_NAV("[nav] NavMoveRequestSubmit: dir %c, window \"%s\"\n", "-WENS"[move_dir + 1], g.NavWindow->Name);

	if ImGuiNavMoveFlags_IsTabbing : ^move_flags; ImGuiNavMoveFlags_IsTabbing { move_flags |= ImGuiNavMoveFlags_.ImGuiNavMoveFlags_AllowCurrentNavId }

	g.NavMoveScoringItems = true; g.NavMoveSubmitted = g.NavMoveScoringItems
	g.NavMoveDir = move_dir
	g.NavMoveDirForDebug = move_dir
	g.NavMoveClipDir = clip_dir
	g.NavMoveFlags = move_flags
	g.NavMoveScrollFlags = scroll_flags
	g.NavMoveForwardToNextFrame = false
	g.NavMoveKeyMods = (move_flags & ImGuiNavMoveFlags_.ImGuiNavMoveFlags_FocusApi) ? 0 : g.IO.KeyMods
	Clear(&g.NavMoveResultLocal)
	Clear(&g.NavMoveResultLocalVisible)
	Clear(&g.NavMoveResultOther)
	g.NavTabbingCounter = 0
	Clear(&g.NavTabbingResultFirst)
	NavUpdateAnyRequestFlag()
}

NavMoveRequestResolveWithLastItem :: proc(result : ^ImGuiNavItemData)
{
	g : ^ImGuiContext = GImGui^
	g.NavMoveScoringItems = false; // Ensure request doesn't need more processing
	NavApplyItemToResult(result)
	NavUpdateAnyRequestFlag()
}

// Called by TreePop() to implement ImGuiTreeNodeFlags_NavLeftJumpsBackHere
NavMoveRequestResolveWithPastTreeNode :: proc(result : ^ImGuiNavItemData, tree_node_data : ^ImGuiTreeNodeStackData)
{
	g : ^ImGuiContext = GImGui^
	g.NavMoveScoringItems = false
	g.LastItemData.ID = tree_node_data.ID
	g.LastItemData.ItemFlags = tree_node_data.ItemFlags & !ImGuiItemFlagsPrivate_.ImGuiItemFlags_HasSelectionUserData; // Losing SelectionUserData, recovered next-frame (cheaper).
	g.LastItemData.NavRect = tree_node_data.NavRect
	NavApplyItemToResult(result); // Result this instead of implementing a NavApplyPastTreeNodeToResult()
	NavClearPreferredPosForAxis(ImGuiAxis.ImGuiAxis_Y)
	NavUpdateAnyRequestFlag()
}

NavMoveRequestCancel :: proc()
{
	g : ^ImGuiContext = GImGui^
	g.NavMoveScoringItems = false; g.NavMoveSubmitted = g.NavMoveScoringItems
	NavUpdateAnyRequestFlag()
}

// Forward will reuse the move request again on the next frame (generally with modifications done to it)
NavMoveRequestForward :: proc(move_dir : ImGuiDir, clip_dir : ImGuiDir, move_flags : ImGuiNavMoveFlags, scroll_flags : ImGuiScrollFlags)
{
	g : ^ImGuiContext = GImGui^
	IM_ASSERT(g.NavMoveForwardToNextFrame == false)
	NavMoveRequestCancel()
	g.NavMoveForwardToNextFrame = true
	g.NavMoveDir = move_dir
	g.NavMoveClipDir = clip_dir
	g.NavMoveFlags = move_flags | ImGuiNavMoveFlags_.ImGuiNavMoveFlags_Forwarded
	g.NavMoveScrollFlags = scroll_flags
}

// Navigation wrap-around logic is delayed to the end of the frame because this operation is only valid after entire
// popup is assembled and in case of appended popups it is not clear which EndPopup() call is final.
NavMoveRequestTryWrapping :: proc(window : ^ImGuiWindow, wrap_flags : ImGuiNavMoveFlags)
{
	g : ^ImGuiContext = GImGui^
	IM_ASSERT((wrap_flags & ImGuiNavMoveFlags_.ImGuiNavMoveFlags_WrapMask_) != 0 && (wrap_flags & !ImGuiNavMoveFlags_.ImGuiNavMoveFlags_WrapMask_) == 0); // Call with _WrapX, _WrapY, _LoopX, _LoopY

	// In theory we should test for NavMoveRequestButNoResultYet() but there's no point doing it:
	// as NavEndFrame() will do the same test. It will end up calling NavUpdateCreateWrappingRequest().
	if g.NavWindow == window && g.NavMoveScoringItems && g.NavLayer == ImGuiNavLayer.ImGuiNavLayer_Main { g.NavMoveFlags = (g.NavMoveFlags & !ImGuiNavMoveFlags_.ImGuiNavMoveFlags_WrapMask_) | wrap_flags }
}

// FIXME: This could be replaced by updating a frame number in each window when (window == NavWindow) and (NavLayer == 0).
// This way we could find the last focused window among our children. It would be much less confusing this way?
NavSaveLastChildNavWindowIntoParent :: proc(nav_window : ^ImGuiWindow)
{
	parent : ^ImGuiWindow = nav_window
	for parent && parent.RootWindow != parent && (parent.Flags & (ImGuiWindowFlags_.ImGuiWindowFlags_Popup | ImGuiWindowFlags_.ImGuiWindowFlags_ChildMenu)) == 0 { parent = parent.ParentWindow }

	if parent && parent != nav_window { parent.NavLastChildNavWindow = nav_window }
}

// Restore the last focused child.
// Call when we are expected to land on the Main Layer (0) after FocusWindow()
NavRestoreLastChildNavWindow :: proc(window : ^ImGuiWindow) -> ^ImGuiWindow
{
	if window.NavLastChildNavWindow && window.NavLastChildNavWindow.WasActive { return window.NavLastChildNavWindow }
	if window.DockNodeAsHost && window.DockNodeAsHost.TabBar { if tab : ^ImGuiTabItem = TabBarFindMostRecentlySelectedTabForActiveWindow(window.DockNodeAsHost.TabBar); tab { return tab.Window } }
	return window
}

NavRestoreLayer :: proc(layer : ImGuiNavLayer)
{
	g : ^ImGuiContext = GImGui^
	if layer == ImGuiNavLayer.ImGuiNavLayer_Main {
		prev_nav_window : ^ImGuiWindow = g.NavWindow
		g.NavWindow = NavRestoreLastChildNavWindow(g.NavWindow); // FIXME-NAV: Should clear ongoing nav requests?
		g.NavLastValidSelectionUserData = ImGuiSelectionUserData_Invalid
		if prev_nav_window { IMGUI_DEBUG_LOG_FOCUS("[focus] NavRestoreLayer: from \"%s\" to SetNavWindow(\"%s\")\n", prev_nav_window.Name, g.NavWindow.Name) }
	}
	window : ^ImGuiWindow = g.NavWindow
	if window.NavLastIds[layer] != 0 {
		SetNavID(window.NavLastIds[layer], layer, 0, window.NavRectRel[layer])
	}
	else {
		g.NavLayer = layer
		NavInitWindow(window, true)
	}
}

NavUpdateAnyRequestFlag :: #force_inline proc()
{
	g : ^ImGuiContext = GImGui^
	g.NavAnyRequest = g.NavMoveScoringItems || g.NavInitRequest || (IMGUI_DEBUG_NAV_SCORING && g.NavWindow != nil)
	if g.NavAnyRequest { IM_ASSERT(g.NavWindow != nil) }
}

// Keyboard/Gamepad Navigation
// This needs to be called before we submit any widget (aka in or before Begin)
NavInitWindow :: proc(window : ^ImGuiWindow, force_reinit : bool)
{
	// FIXME: ChildWindow test here is wrong for docking
	g : ^ImGuiContext = GImGui^
	IM_ASSERT(window == g.NavWindow)

	if window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoNavInputs {
		g.NavId = 0
		SetNavFocusScope(window.NavRootFocusScopeId)
		return
	}

	init_for_nav : bool = false
	if window == window.RootWindow || (window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_Popup) || (window.NavLastIds[0] == 0) || force_reinit { init_for_nav = true }
	IMGUI_DEBUG_LOG_NAV("[nav] NavInitRequest: from NavInitWindow(), init_for_nav=%d, window=\"%s\", layer=%d\n", init_for_nav, window.Name, g.NavLayer)
	if init_for_nav {
		SetNavID(0, g.NavLayer, window.NavRootFocusScopeId, ImRect())
		g.NavInitRequest = true
		g.NavInitRequestFromMove = false
		g.NavInitResult.ID = 0
		NavUpdateAnyRequestFlag()
	}
	else {
		g.NavId = window.NavLastIds[0]
		SetNavFocusScope(window.NavRootFocusScopeId)
	}
}

NavCalcPreferredRefPosSource :: proc() -> ImGuiInputSource
{
	g : ^ImGuiContext = GImGui^
	window : ^ImGuiWindow = g.NavWindow
	activated_shortcut : bool = g.ActiveId != 0 && g.ActiveIdFromShortcut && g.ActiveId == g.LastItemData.ID

	// Testing for !activated_shortcut here could in theory be removed if we decided that activating a remote shortcut altered one of the g.NavDisableXXX flag.
	if (!g.NavCursorVisible || !g.NavHighlightItemUnderNav || !window) && !activated_shortcut { return ImGuiInputSource.ImGuiInputEventType_Mouse }
	else {
		// or Nav in general
		return ImGuiInputSource.ImGuiInputSource_Keyboard
	}
}

NavCalcPreferredRefPos :: proc() -> ImVec2
{
	g : ^ImGuiContext = GImGui^
	window : ^ImGuiWindow = g.NavWindow
	source : ImGuiInputSource = NavCalcPreferredRefPosSource()

	activated_shortcut : bool = g.ActiveId != 0 && g.ActiveIdFromShortcut && g.ActiveId == g.LastItemData.ID

	// Testing for !activated_shortcut here could in theory be removed if we decided that activating a remote shortcut altered one of the g.NavDisableXXX flag.
	if source == ImGuiInputSource.ImGuiInputEventType_Mouse {
		// Mouse (we need a fallback in case the mouse becomes invalid after being used)
		// The +1.0f offset when stored by OpenPopupEx() allows reopening this or another popup (same or another mouse button) while not moving the mouse, it is pretty standard.
		// In theory we could move that +1.0f offset in OpenPopupEx()
		p : ImVec2 = IsMousePosValid(&g.IO.MousePos) ? g.IO.MousePos : g.MouseLastValidPos
		return ImVec2(p.x + 1.0, p.y)
	}
	else {
		// When navigation is active and mouse is disabled, pick a position around the bottom left of the currently navigated item
		ref_rect : ImRect
		if activated_shortcut { ref_rect = g.LastItemData.NavRect }
		else { ref_rect = WindowRectRelToAbs(window, window.NavRectRel[g.NavLayer]) }

		// Take account of upcoming scrolling (maybe set mouse pos should be done in EndFrame?)
		if window.LastFrameActive != g.FrameCount && (window.ScrollTarget.x != FLT_MAX || window.ScrollTarget.y != FLT_MAX) {
			next_scroll : ImVec2 = CalcNextScrollFromScrollTargetAndClamp(window)
			Translate(&ref_rect, window.Scroll - next_scroll)
		}
		pos : ImVec2 = ImVec2(ref_rect.Min.x + ImMin(g.Style.FramePadding.x * 4, GetWidth(&ref_rect)), ref_rect.Max.y - ImMin(g.Style.FramePadding.y, GetHeight(&ref_rect)))
		viewport : ^ImGuiViewport = window.Viewport
		return ImTrunc(ImClamp(pos, viewport.Pos, viewport.Pos + viewport.Size))// ImTrunc() is important because non-integer mouse position application in backend might be lossy and result in undesirable non-zero delta.
	}
}

GetNavTweakPressedAmount :: proc(axis : ImGuiAxis) -> f32
{
	g : ^ImGuiContext = GImGui^
	repeat_delay : f32; repeat_rate : f32
	GetTypematicRepeatRate(ImGuiInputFlagsPrivate_.ImGuiInputFlags_RepeatRateNavTweak, &repeat_delay, &repeat_rate)

	key_less : ImGuiKey; key_more : ImGuiKey
	if g.NavInputSource == ImGuiInputSource.ImGuiInputSource_Gamepad {
		key_less = (axis == ImGuiAxis.ImGuiAxis_X) ? ImGuiKey.ImGuiKey_GamepadDpadLeft : ImGuiKey.ImGuiKey_GamepadDpadUp
		key_more = (axis == ImGuiAxis.ImGuiAxis_X) ? ImGuiKey.ImGuiKey_GamepadDpadRight : ImGuiKey.ImGuiKey_GamepadDpadDown
	}
	else {
		key_less = (axis == ImGuiAxis.ImGuiAxis_X) ? ImGuiKey.ImGuiKey_LeftArrow : ImGuiKey.ImGuiKey_UpArrow
		key_more = (axis == ImGuiAxis.ImGuiAxis_X) ? ImGuiKey.ImGuiKey_RightArrow : ImGuiKey.ImGuiKey_DownArrow
	}
	amount : f32 = cast(f32) GetKeyPressedAmount(key_more, repeat_delay, repeat_rate) - cast(f32) GetKeyPressedAmount(key_less, repeat_delay, repeat_rate)
	if amount != 0.0 && IsKeyDown(key_less) && IsKeyDown(key_more) {
		// Cancel when opposite directions are held, regardless of repeat phaseamount = 0.0
	}
	return amount
}

// Navigation
NavUpdate :: proc()
{
	g : ^ImGuiContext = GImGui^
	io : ^ImGuiIO = g.IO

	io.WantSetMousePos = false
	//if (g.NavScoringDebugCount > 0) IMGUI_DEBUG_LOG_NAV("[nav] NavScoringDebugCount %d for '%s' layer %d (Init:%d, Move:%d)\n", g.NavScoringDebugCount, g.NavWindow ? g.NavWindow->Name : "NULL", g.NavLayer, g.NavInitRequest || g.NavInitResultId != 0, g.NavMoveRequest);

	// Set input source based on which keys are last pressed (as some features differs when used with Gamepad vs Keyboard)
	// FIXME-NAV: Now that keys are separated maybe we can get rid of NavInputSource?
	nav_gamepad_active : bool = (io.ConfigFlags & ImGuiConfigFlags_.ImGuiConfigFlags_NavEnableGamepad) != 0 && (io.BackendFlags & ImGuiBackendFlags_.ImGuiBackendFlags_HasGamepad) != 0
	nav_gamepad_keys_to_change_source : [^]ImGuiKey = {ImGuiKey.ImGuiKey_GamepadFaceRight, ImGuiKey.ImGuiKey_GamepadFaceLeft, ImGuiKey.ImGuiKey_GamepadFaceUp, ImGuiKey.ImGuiKey_GamepadFaceDown, ImGuiKey.ImGuiKey_GamepadDpadRight, ImGuiKey.ImGuiKey_GamepadDpadLeft, ImGuiKey.ImGuiKey_GamepadDpadUp, ImGuiKey.ImGuiKey_GamepadDpadDown}
	if nav_gamepad_active { for key in nav_gamepad_keys_to_change_source { if IsKeyDown(key) { g.NavInputSource = ImGuiInputSource.ImGuiInputSource_Gamepad } } }
	nav_keyboard_active : bool = (io.ConfigFlags & ImGuiConfigFlags_.ImGuiConfigFlags_NavEnableKeyboard) != 0
	nav_keyboard_keys_to_change_source : [^]ImGuiKey = {ImGuiKey.ImGuiKey_Space, ImGuiKey.ImGuiKey_Enter, ImGuiKey.ImGuiKey_Escape, ImGuiKey.ImGuiKey_RightArrow, ImGuiKey.ImGuiKey_LeftArrow, ImGuiKey.ImGuiKey_UpArrow, ImGuiKey.ImGuiKey_DownArrow}
	if nav_keyboard_active { for key in nav_keyboard_keys_to_change_source { if IsKeyDown(key) { g.NavInputSource = ImGuiInputSource.ImGuiInputSource_Keyboard } } }

	// Process navigation init request (select first/default focus)
	g.NavJustMovedToId = 0
	g.NavJustMovedFromFocusScopeId = 0; g.NavJustMovedToFocusScopeId = g.NavJustMovedFromFocusScopeId
	if g.NavInitResult.ID != 0 { NavInitRequestApplyResult() }
	g.NavInitRequest = false
	g.NavInitRequestFromMove = false
	g.NavInitResult.ID = 0

	// Process navigation move request
	if g.NavMoveSubmitted { NavMoveRequestApplyResult() }
	g.NavTabbingCounter = 0
	g.NavMoveScoringItems = false; g.NavMoveSubmitted = g.NavMoveScoringItems
	if g.NavCursorHideFrames > 0 { if pre_decr(&g.NavCursorHideFrames) == 0 { g.NavCursorVisible = true } }

	// Schedule mouse position update (will be done at the bottom of this function, after 1) processing all move requests and 2) updating scrolling)
	set_mouse_pos : bool = false
	if g.NavMousePosDirty && g.NavIdIsAlive { if g.NavCursorVisible && g.NavHighlightItemUnderNav && g.NavWindow { set_mouse_pos = true } }
	g.NavMousePosDirty = false
	IM_ASSERT(g.NavLayer == ImGuiNavLayer.ImGuiNavLayer_Main || g.NavLayer == ImGuiNavLayer.ImGuiNavLayer_Menu)

	// Store our return window (for returning from Menu Layer to Main Layer) and clear it as soon as we step back in our own Layer 0
	if g.NavWindow { NavSaveLastChildNavWindowIntoParent(g.NavWindow) }
	if g.NavWindow && g.NavWindow.NavLastChildNavWindow != nil && g.NavLayer == ImGuiNavLayer.ImGuiNavLayer_Main { g.NavWindow.NavLastChildNavWindow = nil }

	// Update CTRL+TAB and Windowing features (hold Square to move/resize/etc.)
	NavUpdateWindowing()

	// Set output flags for user application
	io.NavActive = (nav_keyboard_active || nav_gamepad_active) && g.NavWindow && !(g.NavWindow.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoNavInputs)
	io.NavVisible = (io.NavActive && g.NavId != 0 && g.NavCursorVisible) || (g.NavWindowingTarget != nil)

	// Process NavCancel input (to close a popup, get back to parent, clear focus)
	NavUpdateCancelRequest()

	// Process manual activation request
	g.NavActivatePressedId = 0; g.NavActivateDownId = g.NavActivatePressedId; g.NavActivateId = g.NavActivateDownId
	g.NavActivateFlags = ImGuiActivateFlags_.ImGuiActivateFlags_None
	if g.NavId != 0 && g.NavCursorVisible && !g.NavWindowingTarget && g.NavWindow && !(g.NavWindow.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoNavInputs) {
		activate_down : bool = (nav_keyboard_active && IsKeyDown(ImGuiKey.ImGuiKey_Space, ImGuiKeyOwner_NoOwner)) || (nav_gamepad_active && IsKeyDown(ImGuiKey_NavGamepadActivate, ImGuiKeyOwner_NoOwner))
		activate_pressed : bool = activate_down && ((nav_keyboard_active && IsKeyPressed(ImGuiKey.ImGuiKey_Space, 0, ImGuiKeyOwner_NoOwner)) || (nav_gamepad_active && IsKeyPressed(ImGuiKey_NavGamepadActivate, 0, ImGuiKeyOwner_NoOwner)))
		input_down : bool = (nav_keyboard_active && (IsKeyDown(ImGuiKey.ImGuiKey_Enter, ImGuiKeyOwner_NoOwner) || IsKeyDown(ImGuiKey.ImGuiKey_KeypadEnter, ImGuiKeyOwner_NoOwner))) || (nav_gamepad_active && IsKeyDown(ImGuiKey_NavGamepadInput, ImGuiKeyOwner_NoOwner))
		input_pressed : bool = input_down && ((nav_keyboard_active && (IsKeyPressed(ImGuiKey.ImGuiKey_Enter, 0, ImGuiKeyOwner_NoOwner) || IsKeyPressed(ImGuiKey.ImGuiKey_KeypadEnter, 0, ImGuiKeyOwner_NoOwner))) || (nav_gamepad_active && IsKeyPressed(ImGuiKey_NavGamepadInput, 0, ImGuiKeyOwner_NoOwner)))
		if g.ActiveId == 0 && activate_pressed {
			g.NavActivateId = g.NavId
			g.NavActivateFlags = ImGuiActivateFlags_.ImGuiActivateFlags_PreferTweak
		}
		if (g.ActiveId == 0 || g.ActiveId == g.NavId) && input_pressed {
			g.NavActivateId = g.NavId
			g.NavActivateFlags = ImGuiActivateFlags_.ImGuiActivateFlags_PreferInput
		}
		if (g.ActiveId == 0 || g.ActiveId == g.NavId) && (activate_down || input_down) { g.NavActivateDownId = g.NavId }
		if (g.ActiveId == 0 || g.ActiveId == g.NavId) && (activate_pressed || input_pressed) {
			g.NavActivatePressedId = g.NavId
			NavHighlightActivated(g.NavId)
		}
	}
	if g.NavWindow && (g.NavWindow.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoNavInputs) { g.NavCursorVisible = false }
	else if g.IO.ConfigNavCursorVisibleAlways && g.NavCursorHideFrames == 0 { g.NavCursorVisible = true }
	if g.NavActivateId != 0 { IM_ASSERT(g.NavActivateDownId == g.NavActivateId) }

	// Highlight
	if g.NavHighlightActivatedTimer > 0.0 { g.NavHighlightActivatedTimer = ImMax(0.0, g.NavHighlightActivatedTimer - io.DeltaTime) }
	if g.NavHighlightActivatedTimer == 0.0 { g.NavHighlightActivatedId = 0 }

	// Process programmatic activation request
	// FIXME-NAV: Those should eventually be queued (unlike focus they don't cancel each others)
	if g.NavNextActivateId != 0 {
		g.NavActivatePressedId = g.NavNextActivateId; g.NavActivateDownId = g.NavActivatePressedId; g.NavActivateId = g.NavActivateDownId
		g.NavActivateFlags = g.NavNextActivateFlags
	}
	g.NavNextActivateId = 0

	// Process move requests
	NavUpdateCreateMoveRequest()
	if g.NavMoveDir == ImGuiDir.ImGuiDir_None { NavUpdateCreateTabbingRequest() }
	NavUpdateAnyRequestFlag()
	g.NavIdIsAlive = false

	// Scrolling
	if g.NavWindow && !(g.NavWindow.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoNavInputs) && !g.NavWindowingTarget {
		// *Fallback* manual-scroll with Nav directional keys when window has no navigable item
		window : ^ImGuiWindow = g.NavWindow
		scroll_speed : f32 = IM_ROUND(CalcFontSize(window) * 100 * io.DeltaTime); // We need round the scrolling speed because sub-pixel scroll isn't reliably supported.
		move_dir : ImGuiDir = g.NavMoveDir
		if window.DC.NavLayersActiveMask == 0x00 && window.DC.NavWindowHasScrollY && move_dir != ImGuiDir.ImGuiDir_None {
			if move_dir == ImGuiDir.ImGuiDir_Left || move_dir == ImGuiDir.ImGuiDir_Right { SetScrollX(window, ImTrunc(window.Scroll.x + ((move_dir == ImGuiDir.ImGuiDir_Left) ? -1.0 : +1.0) * scroll_speed)) }
			if move_dir == ImGuiDir.ImGuiDir_Up || move_dir == ImGuiDir.ImGuiDir_Down { SetScrollY(window, ImTrunc(window.Scroll.y + ((move_dir == ImGuiDir.ImGuiDir_Up) ? -1.0 : +1.0) * scroll_speed)) }
		}

		// *Normal* Manual scroll with LStick
		// Next movement request will clamp the NavId reference rectangle to the visible area, so navigation will resume within those bounds.
		if nav_gamepad_active {
			scroll_dir : ImVec2 = GetKeyMagnitude2d(ImGuiKey.ImGuiKey_GamepadLStickLeft, ImGuiKey.ImGuiKey_GamepadLStickRight, ImGuiKey.ImGuiKey_GamepadLStickUp, ImGuiKey.ImGuiKey_GamepadLStickDown)
			tweak_factor : f32 = IsKeyDown(ImGuiKey_NavGamepadTweakSlow) ? 1.0 / 10.0 : IsKeyDown(ImGuiKey_NavGamepadTweakFast) ? 10.0 : 1.0
			if scroll_dir.x != 0.0 && window.ScrollbarX { SetScrollX(window, ImTrunc(window.Scroll.x + scroll_dir.x * scroll_speed * tweak_factor)) }
			if scroll_dir.y != 0.0 { SetScrollY(window, ImTrunc(window.Scroll.y + scroll_dir.y * scroll_speed * tweak_factor)) }
		}
	}

	// Always prioritize mouse highlight if navigation is disabled
	if !nav_keyboard_active && !nav_gamepad_active {
		g.NavCursorVisible = false
		set_mouse_pos = false; g.NavHighlightItemUnderNav = set_mouse_pos
	}

	// Update mouse position if requested
	// (This will take into account the possibility that a Scroll was queued in the window to offset our absolute mouse position before scroll has been applied)
	if set_mouse_pos && io.ConfigNavMoveSetMousePos && (io.BackendFlags & ImGuiBackendFlags_.ImGuiBackendFlags_HasSetMousePos) { TeleportMousePos(NavCalcPreferredRefPos()) }

	// [DEBUG]
	g.NavScoringDebugCount = 0
	when IMGUI_DEBUG_NAV_RECTS {
	if debug_window : ^ImGuiWindow = g.NavWindow; debug_window {
		draw_list : ^ImDrawList = GetForegroundDrawList(debug_window)
		layer : i32 = g.NavLayer; /* for (int layer = 0; layer < 2; layer++)*/{r : ImRect = WindowRectRelToAbs(debug_window, debug_window.NavRectRel[layer]); AddRect(draw_list, r.Min, r.Max, IM_COL32(255, 200, 0, 255))}
		//if (1) { ImU32 col = (!debug_window->Hidden) ? IM_COL32(255,0,255,255) : IM_COL32(255,0,0,255); ImVec2 p = NavCalcPreferredRefPos(); char buf[32]; ImFormatString(buf, 32, "%d", g.NavLayer); draw_list->AddCircleFilled(p, 3.0f, col); draw_list->AddText(NULL, 13.0f, p + ImVec2(8,-4), col, buf); }
	}
	} // preproc endif
}

NavInitRequestApplyResult :: proc()
{
	// In very rare cases g.NavWindow may be null (e.g. clearing focus after requesting an init request, which does happen when releasing Alt while clicking on void)
	g : ^ImGuiContext = GImGui^
	if !g.NavWindow { return }

	result : ^ImGuiNavItemData = &g.NavInitResult
	if g.NavId != result.ID {
		g.NavJustMovedFromFocusScopeId = g.NavFocusScopeId
		g.NavJustMovedToId = result.ID
		g.NavJustMovedToFocusScopeId = result.FocusScopeId
		g.NavJustMovedToKeyMods = 0
		g.NavJustMovedToIsTabbing = false
		g.NavJustMovedToHasSelectionData = (result.ItemFlags & ImGuiItemFlagsPrivate_.ImGuiItemFlags_HasSelectionUserData) != 0
	}

	// Apply result from previous navigation init request (will typically select the first item, unless SetItemDefaultFocus() has been called)
	// FIXME-NAV: On _NavFlattened windows, g.NavWindow will only be updated during subsequent frame. Not a problem currently.
	IMGUI_DEBUG_LOG_NAV("[nav] NavInitRequest: ApplyResult: NavID 0x%08X in Layer %d Window \"%s\"\n", result.ID, g.NavLayer, g.NavWindow.Name)
	SetNavID(result.ID, g.NavLayer, result.FocusScopeId, result.RectRel)
	g.NavIdIsAlive = true; // Mark as alive from previous frame as we got a result
	if result.SelectionUserData != ImGuiSelectionUserData_Invalid { g.NavLastValidSelectionUserData = result.SelectionUserData }
	if g.NavInitRequestFromMove { SetNavCursorVisibleAfterMove() }
}

// Bias scoring rect ahead of scoring + update preferred pos (if missing) using source position
NavBiasScoringRect :: proc(r : ^ImRect, preferred_pos_rel : ^ImVec2, move_dir : ImGuiDir, move_flags : ImGuiNavMoveFlags)
{
	// Bias initial rect
	g : ^ImGuiContext = GImGui^
	rel_to_abs_offset : ImVec2 = g.NavWindow.DC.CursorStartPos

	// Initialize bias on departure if we don't have any. So mouse-click + arrow will record bias.
	// - We default to L/U bias, so moving down from a large source item into several columns will land on left-most column.
	// - But each successful move sets new bias on one axis, only cleared when using mouse.
	if (move_flags & ImGuiNavMoveFlags_.ImGuiNavMoveFlags_Forwarded) == 0 {
		if preferred_pos_rel.x == FLT_MAX { preferred_pos_rel.x = ImMin(r.Min.x + 1.0, r.Max.x) - rel_to_abs_offset.x }
		if preferred_pos_rel.y == FLT_MAX { preferred_pos_rel.y = GetCenter(&r).y - rel_to_abs_offset.y }
	}

	// Apply general bias on the other axis
	if (move_dir == ImGuiDir.ImGuiDir_Up || move_dir == ImGuiDir.ImGuiDir_Down) && preferred_pos_rel.x != FLT_MAX { r.Max.x = preferred_pos_rel.x + rel_to_abs_offset.x; r.Min.x = r.Max.x }
	else if (move_dir == ImGuiDir.ImGuiDir_Left || move_dir == ImGuiDir.ImGuiDir_Right) && preferred_pos_rel.y != FLT_MAX { r.Max.y = preferred_pos_rel.y + rel_to_abs_offset.y; r.Min.y = r.Max.y }
}

NavUpdateCreateMoveRequest :: proc()
{
	g : ^ImGuiContext = GImGui^
	io : ^ImGuiIO = g.IO
	window : ^ImGuiWindow = g.NavWindow
	nav_gamepad_active : bool = (io.ConfigFlags & ImGuiConfigFlags_.ImGuiConfigFlags_NavEnableGamepad) != 0 && (io.BackendFlags & ImGuiBackendFlags_.ImGuiBackendFlags_HasGamepad) != 0
	nav_keyboard_active : bool = (io.ConfigFlags & ImGuiConfigFlags_.ImGuiConfigFlags_NavEnableKeyboard) != 0

	if g.NavMoveForwardToNextFrame && window != nil {
		// Forwarding previous request (which has been modified, e.g. wrap around menus rewrite the requests with a starting rectangle at the other side of the window)
		// (preserve most state, which were already set by the NavMoveRequestForward() function)
		IM_ASSERT(g.NavMoveDir != ImGuiDir.ImGuiDir_None && g.NavMoveClipDir != ImGuiDir.ImGuiDir_None)
		IM_ASSERT(g.NavMoveFlags & ImGuiNavMoveFlags_.ImGuiNavMoveFlags_Forwarded)
		IMGUI_DEBUG_LOG_NAV("[nav] NavMoveRequestForward %d\n", g.NavMoveDir)
	}
	else {
		// Initiate directional inputs request
		g.NavMoveDir = ImGuiDir.ImGuiDir_None
		g.NavMoveFlags = ImGuiNavMoveFlags_.ImGuiNavMoveFlags_None
		g.NavMoveScrollFlags = ImGuiScrollFlags_.ImGuiScrollFlags_None
		if window && !g.NavWindowingTarget && !(window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoNavInputs) {
			repeat_mode : ImGuiInputFlags = ImGuiInputFlags_.ImGuiInputFlags_Repeat | cast(ImGuiInputFlags) ImGuiInputFlagsPrivate_.ImGuiInputFlags_RepeatRateNavMove
			if !IsActiveIdUsingNavDir(ImGuiDir.ImGuiDir_Left) && ((nav_gamepad_active && IsKeyPressed(ImGuiKey.ImGuiKey_GamepadDpadLeft, repeat_mode, ImGuiKeyOwner_NoOwner)) || (nav_keyboard_active && IsKeyPressed(ImGuiKey.ImGuiKey_LeftArrow, repeat_mode, ImGuiKeyOwner_NoOwner))) { g.NavMoveDir = ImGuiDir.ImGuiDir_Left }
			if !IsActiveIdUsingNavDir(ImGuiDir.ImGuiDir_Right) && ((nav_gamepad_active && IsKeyPressed(ImGuiKey.ImGuiKey_GamepadDpadRight, repeat_mode, ImGuiKeyOwner_NoOwner)) || (nav_keyboard_active && IsKeyPressed(ImGuiKey.ImGuiKey_RightArrow, repeat_mode, ImGuiKeyOwner_NoOwner))) { g.NavMoveDir = ImGuiDir.ImGuiDir_Right }
			if !IsActiveIdUsingNavDir(ImGuiDir.ImGuiDir_Up) && ((nav_gamepad_active && IsKeyPressed(ImGuiKey.ImGuiKey_GamepadDpadUp, repeat_mode, ImGuiKeyOwner_NoOwner)) || (nav_keyboard_active && IsKeyPressed(ImGuiKey.ImGuiKey_UpArrow, repeat_mode, ImGuiKeyOwner_NoOwner))) { g.NavMoveDir = ImGuiDir.ImGuiDir_Up }
			if !IsActiveIdUsingNavDir(ImGuiDir.ImGuiDir_Down) && ((nav_gamepad_active && IsKeyPressed(ImGuiKey.ImGuiKey_GamepadDpadDown, repeat_mode, ImGuiKeyOwner_NoOwner)) || (nav_keyboard_active && IsKeyPressed(ImGuiKey.ImGuiKey_DownArrow, repeat_mode, ImGuiKeyOwner_NoOwner))) { g.NavMoveDir = ImGuiDir.ImGuiDir_Down }
		}
		g.NavMoveClipDir = g.NavMoveDir
		g.NavScoringNoClipRect = ImRect(+FLT_MAX, +FLT_MAX, -FLT_MAX, -FLT_MAX)
	}

	// Update PageUp/PageDown/Home/End scroll
	// FIXME-NAV: Consider enabling those keys even without the master ImGuiConfigFlags_NavEnableKeyboard flag?
	scoring_rect_offset_y : f32 = 0.0
	if window && g.NavMoveDir == ImGuiDir.ImGuiDir_None && nav_keyboard_active { scoring_rect_offset_y = NavUpdatePageUpPageDown() }
	if scoring_rect_offset_y != 0.0 {
		g.NavScoringNoClipRect = window.InnerRect
		TranslateY(&g.NavScoringNoClipRect, scoring_rect_offset_y)
	}

	// [DEBUG] Always send a request when holding CTRL. Hold CTRL + Arrow change the direction.
	when IMGUI_DEBUG_NAV_SCORING {
	//if (io.KeyCtrl && IsKeyPressed(ImGuiKey_C))
	//    g.NavMoveDirForDebug = (ImGuiDir)((g.NavMoveDirForDebug + 1) & 3);
	if io.KeyCtrl {
		if g.NavMoveDir == ImGuiDir.ImGuiDir_None { g.NavMoveDir = g.NavMoveDirForDebug }
		g.NavMoveClipDir = g.NavMoveDir
		g.NavMoveFlags |= ImGuiNavMoveFlags_.ImGuiNavMoveFlags_DebugNoResult
	}
	} // preproc endif

	// Submit
	g.NavMoveForwardToNextFrame = false
	if g.NavMoveDir != ImGuiDir.ImGuiDir_None { NavMoveRequestSubmit(g.NavMoveDir, g.NavMoveClipDir, g.NavMoveFlags, g.NavMoveScrollFlags) }

	// Moving with no reference triggers an init request (will be used as a fallback if the direction fails to find a match)
	if g.NavMoveSubmitted && g.NavId == 0 {
		IMGUI_DEBUG_LOG_NAV("[nav] NavInitRequest: from move, window \"%s\", layer=%d\n", window ? window.Name : "<NULL>", g.NavLayer)
		g.NavInitRequestFromMove = true; g.NavInitRequest = g.NavInitRequestFromMove
		g.NavInitResult.ID = 0
		if g.IO.ConfigNavCursorVisibleAuto { g.NavCursorVisible = true }
	}

	// When using gamepad, we project the reference nav bounding box into window visible area.
	// This is to allow resuming navigation inside the visible area after doing a large amount of scrolling,
	// since with gamepad all movements are relative (can't focus a visible object like we can with the mouse).
	if g.NavMoveSubmitted && g.NavInputSource == ImGuiInputSource.ImGuiInputSource_Gamepad && g.NavLayer == ImGuiNavLayer.ImGuiNavLayer_Main && window != nil {
		// && (g.NavMoveFlags & ImGuiNavMoveFlags_Forwarded))
		clamp_x : bool = (g.NavMoveFlags & (ImGuiNavMoveFlags_.ImGuiNavMoveFlags_LoopX | ImGuiNavMoveFlags_.ImGuiNavMoveFlags_WrapX)) == 0
		clamp_y : bool = (g.NavMoveFlags & (ImGuiNavMoveFlags_.ImGuiNavMoveFlags_LoopY | ImGuiNavMoveFlags_.ImGuiNavMoveFlags_WrapY)) == 0
		inner_rect_rel : ImRect = WindowRectAbsToRel(window, ImRect(window.InnerRect.Min - ImVec2(1, 1), window.InnerRect.Max + ImVec2(1, 1)))

		// Take account of changing scroll to handle triggering a new move request on a scrolling frame. (#6171)
		// Otherwise 'inner_rect_rel' would be off on the move result frame.
		Translate(&inner_rect_rel, CalcNextScrollFromScrollTargetAndClamp(window) - window.Scroll)

		if (clamp_x || clamp_y) && !Contains(&inner_rect_rel, window.NavRectRel[g.NavLayer]) {
			IMGUI_DEBUG_LOG_NAV("[nav] NavMoveRequest: clamp NavRectRel for gamepad move\n")
			pad_x : f32 = ImMin(GetWidth(&inner_rect_rel), CalcFontSize(window) * 0.5)
			pad_y : f32 = ImMin(GetHeight(&inner_rect_rel), CalcFontSize(window) * 0.5); // Terrible approximation for the intent of starting navigation from first fully visible item
			inner_rect_rel.Min.x = clamp_x ? (inner_rect_rel.Min.x + pad_x) : -FLT_MAX
			inner_rect_rel.Max.x = clamp_x ? (inner_rect_rel.Max.x - pad_x) : +FLT_MAX
			inner_rect_rel.Min.y = clamp_y ? (inner_rect_rel.Min.y + pad_y) : -FLT_MAX
			inner_rect_rel.Max.y = clamp_y ? (inner_rect_rel.Max.y - pad_y) : +FLT_MAX
			ClipWithFull(&window.NavRectRel[g.NavLayer], inner_rect_rel)
			g.NavId = 0
		}
	}

	// For scoring we use a single segment on the left side our current item bounding box (not touching the edge to avoid box overlap with zero-spaced items)
	scoring_rect : ImRect
	if window != nil {
		nav_rect_rel : ImRect = !IsInverted(&window.NavRectRel[g.NavLayer]) ? window.NavRectRel[g.NavLayer] : ImRect(0, 0, 0, 0)
		scoring_rect = WindowRectRelToAbs(window, nav_rect_rel)
		TranslateY(&scoring_rect, scoring_rect_offset_y)
		if g.NavMoveSubmitted { NavBiasScoringRect(scoring_rect, window.RootWindowForNav.NavPreferredScoringPosRel[g.NavLayer], g.NavMoveDir, g.NavMoveFlags) }
		IM_ASSERT(!IsInverted(&scoring_rect)); // Ensure we have a non-inverted bounding box here will allow us to remove extraneous ImFabs() calls in NavScoreItem().
		//GetForegroundDrawList()->AddRect(scoring_rect.Min, scoring_rect.Max, IM_COL32(255,200,0,255)); // [DEBUG]
		//if (!g.NavScoringNoClipRect.IsInverted()) { GetForegroundDrawList()->AddRect(g.NavScoringNoClipRect.Min, g.NavScoringNoClipRect.Max, IM_COL32(255, 200, 0, 255)); } // [DEBUG]
	}
	g.NavScoringRect = scoring_rect
	Add(&g.NavScoringNoClipRect, scoring_rect)
}

NavUpdateCreateTabbingRequest :: proc()
{
	g : ^ImGuiContext = GImGui^
	window : ^ImGuiWindow = g.NavWindow
	IM_ASSERT(g.NavMoveDir == ImGuiDir.ImGuiDir_None)
	if window == nil || g.NavWindowingTarget != nil || (window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoNavInputs) { return }

	tab_pressed : bool = IsKeyPressed(ImGuiKey.ImGuiKey_Tab, ImGuiInputFlags_.ImGuiInputFlags_Repeat, ImGuiKeyOwner_NoOwner) && !g.IO.KeyCtrl && !g.IO.KeyAlt
	if !tab_pressed { return }

	// Initiate tabbing request
	// (this is ALWAYS ENABLED, regardless of ImGuiConfigFlags_NavEnableKeyboard flag!)
	// See NavProcessItemForTabbingRequest() for a description of the various forward/backward tabbing cases with and without wrapping.
	nav_keyboard_active : bool = (g.IO.ConfigFlags & ImGuiConfigFlags_.ImGuiConfigFlags_NavEnableKeyboard) != 0
	if nav_keyboard_active { g.NavTabbingDir = g.IO.KeyShift ? -1 : (g.NavCursorVisible == false && g.ActiveId == 0) ? 0 : +1 }
	else { g.NavTabbingDir = g.IO.KeyShift ? -1 : (g.ActiveId == 0) ? 0 : +1 }
	move_flags : ImGuiNavMoveFlags = ImGuiNavMoveFlags_.ImGuiNavMoveFlags_IsTabbing | ImGuiNavMoveFlags_.ImGuiNavMoveFlags_Activate
	scroll_flags : ImGuiScrollFlags = window.Appearing ? ImGuiScrollFlags_.ImGuiScrollFlags_KeepVisibleEdgeX | ImGuiScrollFlags_.ImGuiScrollFlags_AlwaysCenterY : ImGuiScrollFlags_.ImGuiScrollFlags_KeepVisibleEdgeX | ImGuiScrollFlags_.ImGuiScrollFlags_KeepVisibleEdgeY
	clip_dir : ImGuiDir = (g.NavTabbingDir < 0) ? ImGuiDir.ImGuiDir_Up : ImGuiDir.ImGuiDir_Down
	NavMoveRequestSubmit(ImGuiDir.ImGuiDir_None, clip_dir, move_flags, scroll_flags); // FIXME-NAV: Once we refactor tabbing, add LegacyApi flag to not activate non-inputable.
	g.NavTabbingCounter = -1
}

// Apply result from previous frame navigation directional move request. Always called from NavUpdate()
NavMoveRequestApplyResult :: proc()
{
	g : ^ImGuiContext = GImGui^
	when IMGUI_DEBUG_NAV_SCORING {
	if g.NavMoveFlags & ImGuiNavMoveFlags_.ImGuiNavMoveFlags_DebugNoResult {
		// [DEBUG] Scoring all items in NavWindow at all timesreturn
	}
	} // preproc endif

	// Select which result to use
	result : ^ImGuiNavItemData = (g.NavMoveResultLocal.ID != 0) ? &g.NavMoveResultLocal : (g.NavMoveResultOther.ID != 0) ? &g.NavMoveResultOther : nil

	// Tabbing forward wrap
	if (g.NavMoveFlags & ImGuiNavMoveFlags_.ImGuiNavMoveFlags_IsTabbing) && result == nil { if (g.NavTabbingCounter == 1 || g.NavTabbingDir == 0) && g.NavTabbingResultFirst.ID { result = &g.NavTabbingResultFirst } }

	// In a situation when there are no results but NavId != 0, re-enable the Navigation highlight (because g.NavId is not considered as a possible result)
	axis : ImGuiAxis = (g.NavMoveDir == ImGuiDir.ImGuiDir_Up || g.NavMoveDir == ImGuiDir.ImGuiDir_Down) ? ImGuiAxis.ImGuiAxis_Y : ImGuiAxis.ImGuiAxis_X
	if result == nil {
		if g.NavMoveFlags & ImGuiNavMoveFlags_.ImGuiNavMoveFlags_IsTabbing { g.NavMoveFlags |= ImGuiNavMoveFlags_.ImGuiNavMoveFlags_NoSetNavCursorVisible }
		if g.NavId != 0 && (g.NavMoveFlags & ImGuiNavMoveFlags_.ImGuiNavMoveFlags_NoSetNavCursorVisible) == 0 { SetNavCursorVisibleAfterMove() }
		NavClearPreferredPosForAxis(axis); // On a failed move, clear preferred pos for this axis.
		IMGUI_DEBUG_LOG_NAV("[nav] NavMoveSubmitted but not led to a result!\n")
		return
	}

	// PageUp/PageDown behavior first jumps to the bottom/top mostly visible item, _otherwise_ use the result from the previous/next page.
	if g.NavMoveFlags & ImGuiNavMoveFlags_.ImGuiNavMoveFlags_AlsoScoreVisibleSet { if g.NavMoveResultLocalVisible.ID != 0 && g.NavMoveResultLocalVisible.ID != g.NavId { result = &g.NavMoveResultLocalVisible } }

	// Maybe entering a flattened child from the outside? In this case solve the tie using the regular scoring rules.
	if result != &g.NavMoveResultOther && g.NavMoveResultOther.ID != 0 && g.NavMoveResultOther.Window.ParentWindow == g.NavWindow { if (g.NavMoveResultOther.DistBox < result.DistBox) || (g.NavMoveResultOther.DistBox == result.DistBox && g.NavMoveResultOther.DistCenter < result.DistCenter) { result = &g.NavMoveResultOther } }
	IM_ASSERT(g.NavWindow && result.Window)

	// Scroll to keep newly navigated item fully into view.
	if g.NavLayer == ImGuiNavLayer.ImGuiNavLayer_Main {
		rect_abs : ImRect = WindowRectRelToAbs(result.Window, result.RectRel)
		ScrollToRectEx(result.Window, rect_abs, g.NavMoveScrollFlags)

		if g.NavMoveFlags & ImGuiNavMoveFlags_.ImGuiNavMoveFlags_ScrollToEdgeY {
			// FIXME: Should remove this? Or make more precise: use ScrollToRectEx() with edge?
			scroll_target : f32 = (g.NavMoveDir == ImGuiDir.ImGuiDir_Up) ? result.Window.ScrollMax.y : 0.0
			SetScrollY(result.Window, scroll_target)
		}
	}

	if g.NavWindow != result.Window {
		IMGUI_DEBUG_LOG_FOCUS("[focus] NavMoveRequest: SetNavWindow(\"%s\")\n", result.Window.Name)
		g.NavWindow = result.Window
		g.NavLastValidSelectionUserData = ImGuiSelectionUserData_Invalid
	}

	// Clear active id unless requested not to
	// FIXME: ImGuiNavMoveFlags_NoClearActiveId is currently unused as we don't have a clear strategy to preserve active id after interaction,
	// so this is mostly provided as a gateway for further experiments (see #1418, #2890)
	if g.ActiveId != result.ID && (g.NavMoveFlags & ImGuiNavMoveFlags_.ImGuiNavMoveFlags_NoClearActiveId) == 0 { ClearActiveID() }

	// Don't set NavJustMovedToId if just landed on the same spot (which may happen with ImGuiNavMoveFlags_AllowCurrentNavId)
	// PageUp/PageDown however sets always set NavJustMovedTo (vs Home/End which doesn't) mimicking Windows behavior.
	if (g.NavId != result.ID || (g.NavMoveFlags & ImGuiNavMoveFlags_.ImGuiNavMoveFlags_IsPageMove)) && (g.NavMoveFlags & ImGuiNavMoveFlags_.ImGuiNavMoveFlags_NoSelect) == 0 {
		g.NavJustMovedFromFocusScopeId = g.NavFocusScopeId
		g.NavJustMovedToId = result.ID
		g.NavJustMovedToFocusScopeId = result.FocusScopeId
		g.NavJustMovedToKeyMods = g.NavMoveKeyMods
		g.NavJustMovedToIsTabbing = (g.NavMoveFlags & ImGuiNavMoveFlags_.ImGuiNavMoveFlags_IsTabbing) != 0
		g.NavJustMovedToHasSelectionData = (result.ItemFlags & ImGuiItemFlagsPrivate_.ImGuiItemFlags_HasSelectionUserData) != 0
		//IMGUI_DEBUG_LOG_NAV("[nav] NavJustMovedFromFocusScopeId = 0x%08X, NavJustMovedToFocusScopeId = 0x%08X\n", g.NavJustMovedFromFocusScopeId, g.NavJustMovedToFocusScopeId);
	}

	// Apply new NavID/Focus
	IMGUI_DEBUG_LOG_NAV("[nav] NavMoveRequest: result NavID 0x%08X in Layer %d Window \"%s\"\n", result.ID, g.NavLayer, g.NavWindow.Name)
	preferred_scoring_pos_rel : ImVec2 = g.NavWindow.RootWindowForNav.NavPreferredScoringPosRel[g.NavLayer]
	SetNavID(result.ID, g.NavLayer, result.FocusScopeId, result.RectRel)
	if result.SelectionUserData != ImGuiSelectionUserData_Invalid { g.NavLastValidSelectionUserData = result.SelectionUserData }

	// Restore last preferred position for current axis
	// (storing in RootWindowForNav-> as the info is desirable at the beginning of a Move Request. In theory all storage should use RootWindowForNav..)
	if (g.NavMoveFlags & ImGuiNavMoveFlags_.ImGuiNavMoveFlags_IsTabbing) == 0 {
		preferred_scoring_pos_rel[axis] = GetCenter(&result.RectRel)[axis]
		g.NavWindow.RootWindowForNav.NavPreferredScoringPosRel[g.NavLayer] = preferred_scoring_pos_rel
	}

	// Tabbing: Activates Inputable, otherwise only Focus
	if (g.NavMoveFlags & ImGuiNavMoveFlags_.ImGuiNavMoveFlags_IsTabbing) && (result.ItemFlags & ImGuiItemFlagsPrivate_.ImGuiItemFlags_Inputable) == 0 { g.NavMoveFlags &= !ImGuiNavMoveFlags_.ImGuiNavMoveFlags_Activate }

	// Activate
	if g.NavMoveFlags & ImGuiNavMoveFlags_.ImGuiNavMoveFlags_Activate {
		g.NavNextActivateId = result.ID
		g.NavNextActivateFlags = ImGuiActivateFlags_.ImGuiActivateFlags_None
		if g.NavMoveFlags & ImGuiNavMoveFlags_.ImGuiNavMoveFlags_IsTabbing { g.NavNextActivateFlags |= ImGuiActivateFlags_.ImGuiActivateFlags_PreferInput | ImGuiActivateFlags_.ImGuiActivateFlags_TryToPreserveState | ImGuiActivateFlags_.ImGuiActivateFlags_FromTabbing }
	}

	// Make nav cursor visible
	if (g.NavMoveFlags & ImGuiNavMoveFlags_.ImGuiNavMoveFlags_NoSetNavCursorVisible) == 0 { SetNavCursorVisibleAfterMove() }
}

// Process Escape/NavCancel input (to close a popup, get back to parent, clear focus)
// FIXME: In order to support e.g. Escape to clear a selection we'll need:
// - either to store the equivalent of ActiveIdUsingKeyInputMask for a FocusScope and test for it.
// - either to move most/all of those tests to the epilogue/end functions of the scope they are dealing with (e.g. exit child window in EndChild()) or in EndFrame(), to allow an earlier intercept
NavUpdateCancelRequest :: proc()
{
	g : ^ImGuiContext = GImGui^
	nav_gamepad_active : bool = (g.IO.ConfigFlags & ImGuiConfigFlags_.ImGuiConfigFlags_NavEnableGamepad) != 0 && (g.IO.BackendFlags & ImGuiBackendFlags_.ImGuiBackendFlags_HasGamepad) != 0
	nav_keyboard_active : bool = (g.IO.ConfigFlags & ImGuiConfigFlags_.ImGuiConfigFlags_NavEnableKeyboard) != 0
	if !(nav_keyboard_active && IsKeyPressed(ImGuiKey.ImGuiKey_Escape, 0, ImGuiKeyOwner_NoOwner)) && !(nav_gamepad_active && IsKeyPressed(ImGuiKey_NavGamepadCancel, 0, ImGuiKeyOwner_NoOwner)) { return }

	IMGUI_DEBUG_LOG_NAV("[nav] NavUpdateCancelRequest()\n")
	if g.ActiveId != 0 {
		ClearActiveID()
	}
	else if g.NavLayer != ImGuiNavLayer.ImGuiNavLayer_Main {
		// Leave the "menu" layer
		NavRestoreLayer(ImGuiNavLayer.ImGuiNavLayer_Main)
		SetNavCursorVisibleAfterMove()
	}
	else if g.NavWindow && g.NavWindow != g.NavWindow.RootWindow && !(g.NavWindow.RootWindowForNav.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_Popup) && g.NavWindow.RootWindowForNav.ParentWindow {
		// Exit child window
		child_window : ^ImGuiWindow = g.NavWindow.RootWindowForNav
		parent_window : ^ImGuiWindow = child_window.ParentWindow
		IM_ASSERT(child_window.ChildId != 0)
		FocusWindow(parent_window)
		SetNavID(child_window.ChildId, ImGuiNavLayer.ImGuiNavLayer_Main, 0, WindowRectAbsToRel(parent_window, Rect(child_window)))
		SetNavCursorVisibleAfterMove()
	}
	else if g.OpenPopupStack.Size > 0 && back(&g.OpenPopupStack).Window != nil && !(back(&g.OpenPopupStack).Window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_Modal) {
		// Close open popup/menu
		ClosePopupToLevel(g.OpenPopupStack.Size - 1, true)
	}
	else {
		// Clear NavLastId for popups but keep it for regular child window so we can leave one and come back where we were
		// FIXME-NAV: This should happen on window appearing.
		if g.IO.ConfigNavEscapeClearFocusItem || g.IO.ConfigNavEscapeClearFocusWindow { if g.NavWindow && ((g.NavWindow.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_Popup)) {
	// || !(g.NavWindow->Flags & ImGuiWindowFlags_ChildWindow)))g.NavWindow.NavLastIds[0] = 0
} }

		// Clear nav focus
		if g.IO.ConfigNavEscapeClearFocusItem || g.IO.ConfigNavEscapeClearFocusWindow { g.NavId = 0 }
		if g.IO.ConfigNavEscapeClearFocusWindow { FocusWindow(nil) }
	}
}

// Handle PageUp/PageDown/Home/End keys
// Called from NavUpdateCreateMoveRequest() which will use our output to create a move request
// FIXME-NAV: This doesn't work properly with NavFlattened siblings as we use NavWindow rectangle for reference
// FIXME-NAV: how to get Home/End to aim at the beginning/end of a 2D grid?
NavUpdatePageUpPageDown :: proc() -> f32
{
	g : ^ImGuiContext = GImGui^
	window : ^ImGuiWindow = g.NavWindow
	if (window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoNavInputs) || g.NavWindowingTarget != nil { return 0.0 }

	page_up_held : bool = IsKeyDown(ImGuiKey.ImGuiKey_PageUp, ImGuiKeyOwner_NoOwner)
	page_down_held : bool = IsKeyDown(ImGuiKey.ImGuiKey_PageDown, ImGuiKeyOwner_NoOwner)
	home_pressed : bool = IsKeyPressed(ImGuiKey.ImGuiKey_Home, ImGuiInputFlags_.ImGuiInputFlags_Repeat, ImGuiKeyOwner_NoOwner)
	end_pressed : bool = IsKeyPressed(ImGuiKey.ImGuiKey_End, ImGuiInputFlags_.ImGuiInputFlags_Repeat, ImGuiKeyOwner_NoOwner)
	if page_up_held == page_down_held && home_pressed == end_pressed {
		// Proceed if either (not both) are pressed, otherwise early outreturn 0.0
	}

	if g.NavLayer != ImGuiNavLayer.ImGuiNavLayer_Main { NavRestoreLayer(ImGuiNavLayer.ImGuiNavLayer_Main) }

	if window.DC.NavLayersActiveMask == 0x00 && window.DC.NavWindowHasScrollY {
		// Fallback manual-scroll when window has no navigable item
		if IsKeyPressed(ImGuiKey.ImGuiKey_PageUp, ImGuiInputFlags_.ImGuiInputFlags_Repeat, ImGuiKeyOwner_NoOwner) { SetScrollY(window, window.Scroll.y - GetHeight(&window.InnerRect)) }
		else if IsKeyPressed(ImGuiKey.ImGuiKey_PageDown, ImGuiInputFlags_.ImGuiInputFlags_Repeat, ImGuiKeyOwner_NoOwner) { SetScrollY(window, window.Scroll.y + GetHeight(&window.InnerRect)) }
		else if home_pressed { SetScrollY(window, 0.0) }
		else if end_pressed { SetScrollY(window, window.ScrollMax.y) }
	}
	else {
		nav_rect_rel : ^ImRect = window.NavRectRel[g.NavLayer]
		page_offset_y : f32 = ImMax(0.0, GetHeight(&window.InnerRect) - CalcFontSize(window) * 1.0 + GetHeight(&nav_rect_rel))
		nav_scoring_rect_offset_y : f32 = 0.0
		if IsKeyPressed(ImGuiKey.ImGuiKey_PageUp, true) {
			nav_scoring_rect_offset_y = -page_offset_y
			g.NavMoveDir = ImGuiDir.ImGuiDir_Down; // Because our scoring rect is offset up, we request the down direction (so we can always land on the last item)
			g.NavMoveClipDir = ImGuiDir.ImGuiDir_Up
			g.NavMoveFlags = ImGuiNavMoveFlags_.ImGuiNavMoveFlags_AllowCurrentNavId | ImGuiNavMoveFlags_.ImGuiNavMoveFlags_AlsoScoreVisibleSet | ImGuiNavMoveFlags_.ImGuiNavMoveFlags_IsPageMove
		}
		else if IsKeyPressed(ImGuiKey.ImGuiKey_PageDown, true) {
			nav_scoring_rect_offset_y = +page_offset_y
			g.NavMoveDir = ImGuiDir.ImGuiDir_Up; // Because our scoring rect is offset down, we request the up direction (so we can always land on the last item)
			g.NavMoveClipDir = ImGuiDir.ImGuiDir_Down
			g.NavMoveFlags = ImGuiNavMoveFlags_.ImGuiNavMoveFlags_AllowCurrentNavId | ImGuiNavMoveFlags_.ImGuiNavMoveFlags_AlsoScoreVisibleSet | ImGuiNavMoveFlags_.ImGuiNavMoveFlags_IsPageMove
		}
		else if home_pressed {
			// FIXME-NAV: handling of Home/End is assuming that the top/bottom most item will be visible with Scroll.y == 0/ScrollMax.y
			// Scrolling will be handled via the ImGuiNavMoveFlags_ScrollToEdgeY flag, we don't scroll immediately to avoid scrolling happening before nav result.
			// Preserve current horizontal position if we have any.
			nav_rect_rel.Max.y = 0.0; nav_rect_rel.Min.y = nav_rect_rel.Max.y
			if IsInverted(&nav_rect_rel) { nav_rect_rel.Max.x = 0.0; nav_rect_rel.Min.x = nav_rect_rel.Max.x }
			g.NavMoveDir = ImGuiDir.ImGuiDir_Down
			g.NavMoveFlags = ImGuiNavMoveFlags_.ImGuiNavMoveFlags_AllowCurrentNavId | ImGuiNavMoveFlags_.ImGuiNavMoveFlags_ScrollToEdgeY
			// FIXME-NAV: MoveClipDir left to _None, intentional?
		}
		else if end_pressed {
			nav_rect_rel.Max.y = window.ContentSize.y; nav_rect_rel.Min.y = nav_rect_rel.Max.y
			if IsInverted(&nav_rect_rel) { nav_rect_rel.Max.x = 0.0; nav_rect_rel.Min.x = nav_rect_rel.Max.x }
			g.NavMoveDir = ImGuiDir.ImGuiDir_Up
			g.NavMoveFlags = ImGuiNavMoveFlags_.ImGuiNavMoveFlags_AllowCurrentNavId | ImGuiNavMoveFlags_.ImGuiNavMoveFlags_ScrollToEdgeY
			// FIXME-NAV: MoveClipDir left to _None, intentional?
		}
		return nav_scoring_rect_offset_y
	}
	return 0.0
}

NavEndFrame :: proc()
{
	g : ^ImGuiContext = GImGui^

	// Show CTRL+TAB list window
	if g.NavWindowingTarget != nil { NavUpdateWindowingOverlay() }

	// Perform wrap-around in menus
	// FIXME-NAV: Wrap may need to apply a weight bias on the other axis. e.g. 4x4 grid with 2 last items missing on last item won't handle LoopY/WrapY correctly.
	// FIXME-NAV: Wrap (not Loop) support could be handled by the scoring function and then WrapX would function without an extra frame.
	if g.NavWindow && NavMoveRequestButNoResultYet() && (g.NavMoveFlags & ImGuiNavMoveFlags_.ImGuiNavMoveFlags_WrapMask_) && (g.NavMoveFlags & ImGuiNavMoveFlags_.ImGuiNavMoveFlags_Forwarded) == 0 { NavUpdateCreateWrappingRequest() }
}

NavUpdateCreateWrappingRequest :: proc()
{
	g : ^ImGuiContext = GImGui^
	window : ^ImGuiWindow = g.NavWindow

	do_forward : bool = false
	bb_rel : ImRect = window.NavRectRel[g.NavLayer]
	clip_dir : ImGuiDir = g.NavMoveDir

	move_flags : ImGuiNavMoveFlags = g.NavMoveFlags
	//const ImGuiAxis move_axis = (g.NavMoveDir == ImGuiDir_Up || g.NavMoveDir == ImGuiDir_Down) ? ImGuiAxis_Y : ImGuiAxis_X;
	if g.NavMoveDir == ImGuiDir.ImGuiDir_Left && (move_flags & (ImGuiNavMoveFlags_.ImGuiNavMoveFlags_WrapX | ImGuiNavMoveFlags_.ImGuiNavMoveFlags_LoopX)) {
		bb_rel.Max.x = window.ContentSize.x + window.WindowPadding.x; bb_rel.Min.x = bb_rel.Max.x
		if ImGuiNavMoveFlags_WrapX : ^move_flags; ImGuiNavMoveFlags_WrapX {
			TranslateY(&bb_rel, -GetHeight(&bb_rel)); // Previous row
			clip_dir = ImGuiDir.ImGuiDir_Up
		}
		do_forward = true
	}
	if g.NavMoveDir == ImGuiDir.ImGuiDir_Right && (move_flags & (ImGuiNavMoveFlags_.ImGuiNavMoveFlags_WrapX | ImGuiNavMoveFlags_.ImGuiNavMoveFlags_LoopX)) {
		bb_rel.Max.x = -window.WindowPadding.x; bb_rel.Min.x = bb_rel.Max.x
		if ImGuiNavMoveFlags_WrapX : ^move_flags; ImGuiNavMoveFlags_WrapX {
			TranslateY(&bb_rel, +GetHeight(&bb_rel)); // Next row
			clip_dir = ImGuiDir.ImGuiDir_Down
		}
		do_forward = true
	}
	if g.NavMoveDir == ImGuiDir.ImGuiDir_Up && (move_flags & (ImGuiNavMoveFlags_.ImGuiNavMoveFlags_WrapY | ImGuiNavMoveFlags_.ImGuiNavMoveFlags_LoopY)) {
		bb_rel.Max.y = window.ContentSize.y + window.WindowPadding.y; bb_rel.Min.y = bb_rel.Max.y
		if ImGuiNavMoveFlags_WrapY : ^move_flags; ImGuiNavMoveFlags_WrapY {
			TranslateX(&bb_rel, -GetWidth(&bb_rel)); // Previous column
			clip_dir = ImGuiDir.ImGuiDir_Left
		}
		do_forward = true
	}
	if g.NavMoveDir == ImGuiDir.ImGuiDir_Down && (move_flags & (ImGuiNavMoveFlags_.ImGuiNavMoveFlags_WrapY | ImGuiNavMoveFlags_.ImGuiNavMoveFlags_LoopY)) {
		bb_rel.Max.y = -window.WindowPadding.y; bb_rel.Min.y = bb_rel.Max.y
		if ImGuiNavMoveFlags_WrapY : ^move_flags; ImGuiNavMoveFlags_WrapY {
			TranslateX(&bb_rel, +GetWidth(&bb_rel)); // Next column
			clip_dir = ImGuiDir.ImGuiDir_Right
		}
		do_forward = true
	}
	if !do_forward { return }
	window.NavRectRel[g.NavLayer] = bb_rel
	NavClearPreferredPosForAxis(ImGuiAxis.ImGuiAxis_X)
	NavClearPreferredPosForAxis(ImGuiAxis.ImGuiAxis_Y)
	NavMoveRequestForward(g.NavMoveDir, clip_dir, move_flags, g.NavMoveScrollFlags)
}

// Can we focus this window with CTRL+TAB (or PadMenu + PadFocusPrev/PadFocusNext)
// Note that NoNavFocus makes the window not reachable with CTRL+TAB but it can still be focused with mouse or programmatically.
// If you want a window to never be focused, you may use the e.g. NoInputs flag.
IsWindowNavFocusable :: proc(window : ^ImGuiWindow) -> bool
{
	return window.WasActive && window == window.RootWindow && !(window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoNavFocus)
}

// FIXME-OPT O(N)
FindWindowNavFocusable :: proc(i_start : i32, i_stop : i32, dir : i32) -> ^ImGuiWindow
{
	g : ^ImGuiContext = GImGui^
	for i : i32 = i_start; i >= 0 && i < g.WindowsFocusOrder.Size && i != i_stop; i += dir { if IsWindowNavFocusable(g.WindowsFocusOrder[i]) { return g.WindowsFocusOrder[i] } }

	return nil
}

NavUpdateWindowingTarget :: proc(focus_change_dir : i32)
{
	g : ^ImGuiContext = GImGui^
	IM_ASSERT(g.NavWindowingTarget)
	if g.NavWindowingTarget.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_Modal { return }

	i_current : i32 = FindWindowFocusIndex(g.NavWindowingTarget)
	window_target : ^ImGuiWindow = FindWindowNavFocusable(i_current + focus_change_dir, -INT_MAX, focus_change_dir)
	if !window_target { window_target = FindWindowNavFocusable((focus_change_dir < 0) ? (g.WindowsFocusOrder.Size - 1) : 0, i_current, focus_change_dir) }
	if window_target {
		// Don't reset windowing target if there's a single window in the list
		g.NavWindowingTargetAnim = window_target; g.NavWindowingTarget = g.NavWindowingTargetAnim
		g.NavWindowingAccumDeltaSize = ImVec2(0.0, 0.0); g.NavWindowingAccumDeltaPos = g.NavWindowingAccumDeltaSize
	}
	g.NavWindowingToggleLayer = false
}

// Windowing management mode
// Keyboard: CTRL+Tab (change focus/move/resize), Alt (toggle menu layer)
// Gamepad:  Hold Menu/Square (change focus/move/resize), Tap Menu/Square (toggle menu layer)
NavUpdateWindowing :: proc()
{
	g : ^ImGuiContext = GImGui^
	io : ^ImGuiIO = g.IO

	apply_focus_window : ^ImGuiWindow = nil
	apply_toggle_layer : bool = false

	modal_window : ^ImGuiWindow = GetTopMostPopupModal()
	allow_windowing : bool = (modal_window == nil); // FIXME: This prevent CTRL+TAB from being usable with windows that are inside the Begin-stack of that modal.
	if !allow_windowing { g.NavWindowingTarget = nil }

	// Fade out
	if g.NavWindowingTargetAnim && g.NavWindowingTarget == nil {
		g.NavWindowingHighlightAlpha = ImMax(g.NavWindowingHighlightAlpha - io.DeltaTime * 10.0, 0.0)
		if g.DimBgRatio <= 0.0 && g.NavWindowingHighlightAlpha <= 0.0 { g.NavWindowingTargetAnim = nil }
	}

	// Start CTRL+Tab or Square+L/R window selection
	// (g.ConfigNavWindowingKeyNext/g.ConfigNavWindowingKeyPrev defaults are ImGuiMod_Ctrl|ImGuiKey_Tab and ImGuiMod_Ctrl|ImGuiMod_Shift|ImGuiKey_Tab)
	owner_id : ImGuiID = ImHashStr("###NavUpdateWindowing")
	nav_gamepad_active : bool = (io.ConfigFlags & ImGuiConfigFlags_.ImGuiConfigFlags_NavEnableGamepad) != 0 && (io.BackendFlags & ImGuiBackendFlags_.ImGuiBackendFlags_HasGamepad) != 0
	nav_keyboard_active : bool = (io.ConfigFlags & ImGuiConfigFlags_.ImGuiConfigFlags_NavEnableKeyboard) != 0
	keyboard_next_window : bool = allow_windowing && g.ConfigNavWindowingKeyNext && Shortcut(g.ConfigNavWindowingKeyNext, ImGuiInputFlags_.ImGuiInputFlags_Repeat | ImGuiInputFlags_.ImGuiInputFlags_RouteAlways, owner_id)
	keyboard_prev_window : bool = allow_windowing && g.ConfigNavWindowingKeyPrev && Shortcut(g.ConfigNavWindowingKeyPrev, ImGuiInputFlags_.ImGuiInputFlags_Repeat | ImGuiInputFlags_.ImGuiInputFlags_RouteAlways, owner_id)
	start_windowing_with_gamepad : bool = allow_windowing && nav_gamepad_active && !g.NavWindowingTarget && IsKeyPressed(ImGuiKey_NavGamepadMenu, ImGuiInputFlags_.ImGuiInputFlags_None)
	start_windowing_with_keyboard : bool = allow_windowing && !g.NavWindowingTarget && (keyboard_next_window || keyboard_prev_window); // Note: enabled even without NavEnableKeyboard!
	just_started_windowing_from_null_focus : bool = false
	if start_windowing_with_gamepad || start_windowing_with_keyboard { if window : ^ImGuiWindow = g.NavWindow ? g.NavWindow : FindWindowNavFocusable(g.WindowsFocusOrder.Size - 1, -INT_MAX, -1); window {
	g.NavWindowingTargetAnim = window.RootWindow; g.NavWindowingTarget = g.NavWindowingTargetAnim; // Current location
	g.NavWindowingHighlightAlpha = 0.0; g.NavWindowingTimer = g.NavWindowingHighlightAlpha
	g.NavWindowingAccumDeltaSize = ImVec2(0.0, 0.0); g.NavWindowingAccumDeltaPos = g.NavWindowingAccumDeltaSize
	g.NavWindowingToggleLayer = start_windowing_with_gamepad ? true : false; // Gamepad starts toggling layer
	g.NavInputSource = start_windowing_with_keyboard ? ImGuiInputSource.ImGuiInputSource_Keyboard : ImGuiInputSource.ImGuiInputSource_Gamepad
	if g.NavWindow == nil { just_started_windowing_from_null_focus = true }

	// Manually register ownership of our mods. Using a global route in the Shortcut() calls instead would probably be correct but may have more side-effects.
	if keyboard_next_window || keyboard_prev_window { SetKeyOwnersForKeyChord((g.ConfigNavWindowingKeyNext | g.ConfigNavWindowingKeyPrev) & ImGuiKey.ImGuiMod_Mask_, owner_id) }
} }

	// Gamepad update
	g.NavWindowingTimer += io.DeltaTime
	if g.NavWindowingTarget && g.NavInputSource == ImGuiInputSource.ImGuiInputSource_Gamepad {
		// Highlight only appears after a brief time holding the button, so that a fast tap on PadMenu (to toggle NavLayer) doesn't add visual noise
		g.NavWindowingHighlightAlpha = ImMax(g.NavWindowingHighlightAlpha, ImSaturate((g.NavWindowingTimer - NAV_WINDOWING_HIGHLIGHT_DELAY) / 0.05))

		// Select window to focus
		focus_change_dir : i32 = cast(i32) IsKeyPressed(ImGuiKey.ImGuiKey_GamepadL1) - cast(i32) IsKeyPressed(ImGuiKey.ImGuiKey_GamepadR1)
		if focus_change_dir != 0 && !just_started_windowing_from_null_focus {
			NavUpdateWindowingTarget(focus_change_dir)
			g.NavWindowingHighlightAlpha = 1.0
		}

		// Single press toggles NavLayer, long press with L/R apply actual focus on release (until then the window was merely rendered top-most)
		if !IsKeyDown(ImGuiKey_NavGamepadMenu) {
			g.NavWindowingToggleLayer &= (g.NavWindowingHighlightAlpha < 1.0); // Once button was held long enough we don't consider it a tap-to-toggle-layer press anymore.
			if g.NavWindowingToggleLayer && g.NavWindow { apply_toggle_layer = true }
			else if !g.NavWindowingToggleLayer { apply_focus_window = g.NavWindowingTarget }
			g.NavWindowingTarget = nil
		}
	}

	// Keyboard: Focus
	if g.NavWindowingTarget && g.NavInputSource == ImGuiInputSource.ImGuiInputSource_Keyboard {
		// Visuals only appears after a brief time after pressing TAB the first time, so that a fast CTRL+TAB doesn't add visual noise
		shared_mods : ImGuiKeyChord = ((g.ConfigNavWindowingKeyNext ? g.ConfigNavWindowingKeyNext : ImGuiKey.ImGuiMod_Mask_) & (g.ConfigNavWindowingKeyPrev ? g.ConfigNavWindowingKeyPrev : ImGuiKey.ImGuiMod_Mask_)) & ImGuiKey.ImGuiMod_Mask_
		IM_ASSERT(shared_mods != 0); // Next/Prev shortcut currently needs a shared modifier to "hold", otherwise Prev actions would keep cycling between two windows.
		g.NavWindowingHighlightAlpha = ImMax(g.NavWindowingHighlightAlpha, ImSaturate((g.NavWindowingTimer - NAV_WINDOWING_HIGHLIGHT_DELAY) / 0.05)); // 1.0f
		if (keyboard_next_window || keyboard_prev_window) && !just_started_windowing_from_null_focus { NavUpdateWindowingTarget(keyboard_next_window ? -1 : +1) }
		else if (io.KeyMods & shared_mods) != shared_mods { apply_focus_window = g.NavWindowingTarget }
	}

	// Keyboard: Press and Release ALT to toggle menu layer
	windowing_toggle_keys : [^]ImGuiKey = {ImGuiKey.ImGuiKey_LeftAlt, ImGuiKey.ImGuiKey_RightAlt}
	windowing_toggle_layer_start : bool = false
	if g.NavWindow != nil && !(g.NavWindow.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoNavInputs) { for windowing_toggle_key in windowing_toggle_keys { if nav_keyboard_active && IsKeyPressed(windowing_toggle_key, 0, ImGuiKeyOwner_NoOwner) {
	windowing_toggle_layer_start = true
	g.NavWindowingToggleLayer = true
	g.NavWindowingToggleKey = windowing_toggle_key
	g.NavInputSource = ImGuiInputSource.ImGuiInputSource_Keyboard
	break
} } }
	if g.NavWindowingToggleLayer && g.NavInputSource == ImGuiInputSource.ImGuiInputSource_Keyboard {
		// We cancel toggling nav layer when any text has been typed (generally while holding Alt). (See #370)
		// We cancel toggling nav layer when other modifiers are pressed. (See #4439)
		// - AltGR is Alt+Ctrl on some layout but we can't reliably detect it (not all backends/systems/layout emit it as Alt+Ctrl).
		// We cancel toggling nav layer if an owner has claimed the key.
		if io.InputQueueCharacters.Size > 0 || io.KeyCtrl || io.KeyShift || io.KeySuper { g.NavWindowingToggleLayer = false }
		else if windowing_toggle_layer_start == false && g.LastKeyboardKeyPressTime == g.Time { g.NavWindowingToggleLayer = false }
		else if TestKeyOwner(g.NavWindowingToggleKey, ImGuiKeyOwner_NoOwner) == false || TestKeyOwner(ImGuiKey.ImGuiMod_Alt, ImGuiKeyOwner_NoOwner) == false { g.NavWindowingToggleLayer = false }

		// Apply layer toggle on Alt release
		// Important: as before version <18314 we lacked an explicit IO event for focus gain/loss, we also compare mouse validity to detect old backends clearing mouse pos on focus loss.
		if IsKeyReleased(g.NavWindowingToggleKey) && g.NavWindowingToggleLayer { if g.ActiveId == 0 || g.ActiveIdAllowOverlap { if IsMousePosValid(&io.MousePos) == IsMousePosValid(&io.MousePosPrev) { apply_toggle_layer = true } } }
		if !IsKeyDown(g.NavWindowingToggleKey) { g.NavWindowingToggleLayer = false }
	}

	// Move window
	if g.NavWindowingTarget && !(g.NavWindowingTarget.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoMove) {
		nav_move_dir : ImVec2
		if g.NavInputSource == ImGuiInputSource.ImGuiInputSource_Keyboard && !io.KeyShift { nav_move_dir = GetKeyMagnitude2d(ImGuiKey.ImGuiKey_LeftArrow, ImGuiKey.ImGuiKey_RightArrow, ImGuiKey.ImGuiKey_UpArrow, ImGuiKey.ImGuiKey_DownArrow) }
		if g.NavInputSource == ImGuiInputSource.ImGuiInputSource_Gamepad { nav_move_dir = GetKeyMagnitude2d(ImGuiKey.ImGuiKey_GamepadLStickLeft, ImGuiKey.ImGuiKey_GamepadLStickRight, ImGuiKey.ImGuiKey_GamepadLStickUp, ImGuiKey.ImGuiKey_GamepadLStickDown) }
		if nav_move_dir.x != 0.0 || nav_move_dir.y != 0.0 {
			NAV_MOVE_SPEED : f32 = 800.0
			move_step : f32 = NAV_MOVE_SPEED * io.DeltaTime * ImMin(io.DisplayFramebufferScale.x, io.DisplayFramebufferScale.y)
			g.NavWindowingAccumDeltaPos += nav_move_dir * move_step
			g.NavHighlightItemUnderNav = true
			accum_floored : ImVec2 = ImTrunc(g.NavWindowingAccumDeltaPos)
			if accum_floored.x != 0.0 || accum_floored.y != 0.0 {
				moving_window : ^ImGuiWindow = g.NavWindowingTarget.RootWindowDockTree
				SetWindowPos(moving_window, moving_window.Pos + accum_floored, ImGuiCond_.ImGuiCond_Always)
				g.NavWindowingAccumDeltaPos -= accum_floored
			}
		}
	}

	// Apply final focus
	if apply_focus_window && (g.NavWindow == nil || apply_focus_window != g.NavWindow.RootWindow) {
		// FIXME: Many actions here could be part of a higher-level/reused function. Why aren't they in FocusWindow()
		// Investigate for each of them: ClearActiveID(), NavRestoreHighlightAfterMove(), NavRestoreLastChildNavWindow(), ClosePopupsOverWindow(), NavInitWindow()
		previous_viewport : ^ImGuiViewport = g.NavWindow ? g.NavWindow.Viewport : nil
		ClearActiveID()
		SetNavCursorVisibleAfterMove()
		ClosePopupsOverWindow(apply_focus_window, false)
		FocusWindow(apply_focus_window, ImGuiFocusRequestFlags_.ImGuiFocusRequestFlags_RestoreFocusedChild)
		apply_focus_window = g.NavWindow
		if apply_focus_window.NavLastIds[0] == 0 { NavInitWindow(apply_focus_window, false) }

		// If the window has ONLY a menu layer (no main layer), select it directly
		// Use NavLayersActiveMaskNext since windows didn't have a chance to be Begin()-ed on this frame,
		// so CTRL+Tab where the keys are only held for 1 frame will be able to use correct layers mask since
		// the target window as already been previewed once.
		// FIXME-NAV: This should be done in NavInit.. or in FocusWindow... However in both of those cases,
		// we won't have a guarantee that windows has been visible before and therefore NavLayersActiveMask*
		// won't be valid.
		if apply_focus_window.DC.NavLayersActiveMaskNext == (1 << ImGuiNavLayer.ImGuiNavLayer_Menu) { g.NavLayer = ImGuiNavLayer.ImGuiNavLayer_Menu }

		// Request OS level focus
		if apply_focus_window.Viewport != previous_viewport && g.PlatformIO.Platform_SetWindowFocus { Platform_SetWindowFocus(&g.PlatformIO, apply_focus_window.Viewport) }
	}
	if apply_focus_window { g.NavWindowingTarget = nil }

	// Apply menu/layer toggle
	if apply_toggle_layer && g.NavWindow {
		ClearActiveID()

		// Move to parent menu if necessary
		new_nav_window : ^ImGuiWindow = g.NavWindow
		for new_nav_window.ParentWindow && (new_nav_window.DC.NavLayersActiveMask & (1 << ImGuiNavLayer.ImGuiNavLayer_Menu)) == 0 && (new_nav_window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_ChildWindow) != 0 && (new_nav_window.Flags & (ImGuiWindowFlags_.ImGuiWindowFlags_Popup | ImGuiWindowFlags_.ImGuiWindowFlags_ChildMenu)) == 0 { new_nav_window = new_nav_window.ParentWindow }

		if new_nav_window != g.NavWindow {
			old_nav_window : ^ImGuiWindow = g.NavWindow
			FocusWindow(new_nav_window)
			new_nav_window.NavLastChildNavWindow = old_nav_window
		}

		// Toggle layer
		new_nav_layer : ImGuiNavLayer = (g.NavWindow.DC.NavLayersActiveMask & (1 << ImGuiNavLayer.ImGuiNavLayer_Menu)) ? cast(ImGuiNavLayer) (cast(i32) g.NavLayer ~ 1) : ImGuiNavLayer.ImGuiNavLayer_Main
		if new_nav_layer != g.NavLayer {
			// Reinitialize navigation when entering menu bar with the Alt key (FIXME: could be a properly of the layer?)
			preserve_layer_1_nav_id : bool = (new_nav_window.DockNodeAsHost != nil)
			if new_nav_layer == ImGuiNavLayer.ImGuiNavLayer_Menu && !preserve_layer_1_nav_id { g.NavWindow.NavLastIds[new_nav_layer] = 0 }
			NavRestoreLayer(new_nav_layer)
			SetNavCursorVisibleAfterMove()
		}
	}
}

// Window has already passed the IsWindowNavFocusable()
GetFallbackWindowNameForWindowingList :: proc(window : ^ImGuiWindow) -> ^u8
{
	if window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_Popup { return LocalizeGetMsg(ImGuiLocKey.ImGuiLocKey_WindowingPopup) }
	if (window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_MenuBar) && strcmp(window.Name, "##MainMenuBar") == 0 { return LocalizeGetMsg(ImGuiLocKey.ImGuiLocKey_WindowingMainMenuBar) }
	if window.DockNodeAsHost {
		// Not normally shown to user.
		return "(Dock node)"
	}
	return LocalizeGetMsg(ImGuiLocKey.ImGuiLocKey_WindowingUntitled)
}

// Overlay displayed when using CTRL+TAB. Called by EndFrame().
NavUpdateWindowingOverlay :: proc()
{
	g : ^ImGuiContext = GImGui^
	IM_ASSERT(g.NavWindowingTarget != nil)

	if g.NavWindowingTimer < NAV_WINDOWING_LIST_APPEAR_DELAY { return }

	if g.NavWindowingListWindow == nil { g.NavWindowingListWindow = FindWindowByName("###NavWindowingList") }
	viewport : ^ImGuiViewport = GetMainViewport()
	SetNextWindowSizeConstraints(ImVec2(viewport.Size.x * 0.20, viewport.Size.y * 0.20), ImVec2(FLT_MAX, FLT_MAX))
	SetNextWindowPos(GetCenter(viewport), ImGuiCond_.ImGuiCond_Always, ImVec2(0.5, 0.5))
	PushStyleVar(ImGuiStyleVar_.ImGuiStyleVar_WindowPadding, g.Style.WindowPadding * 2.0)
	Begin("###NavWindowingList", nil, ImGuiWindowFlags_.ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_.ImGuiWindowFlags_NoFocusOnAppearing | ImGuiWindowFlags_.ImGuiWindowFlags_NoResize | ImGuiWindowFlags_.ImGuiWindowFlags_NoMove | ImGuiWindowFlags_.ImGuiWindowFlags_NoInputs | ImGuiWindowFlags_.ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_.ImGuiWindowFlags_NoSavedSettings)
	if g.ContextName[0] != 0 { SeparatorText(g.ContextName) }
	for n : i32 = g.WindowsFocusOrder.Size - 1; n >= 0; post_decr(&n) {
		window : ^ImGuiWindow = g.WindowsFocusOrder[n]
		IM_ASSERT(window != nil); // Fix static analyzers
		if !IsWindowNavFocusable(window) { continue }
		label : ^u8 = window.Name
		if label == FindRenderedTextEnd(label) { label = GetFallbackWindowNameForWindowingList(window) }
		Selectable(label, g.NavWindowingTarget == window)
	}

	End()
	PopStyleVar()
}

// Drag and Drop
//-----------------------------------------------------------------------------
// [SECTION] DRAG AND DROP
//-----------------------------------------------------------------------------

IsDragDropActive :: proc() -> bool
{
	g : ^ImGuiContext = GImGui^
	return g.DragDropActive
}

ClearDragDrop :: proc()
{
	g : ^ImGuiContext = GImGui^
	if g.DragDropActive { IMGUI_DEBUG_LOG_ACTIVEID("[dragdrop] ClearDragDrop()\n") }
	g.DragDropActive = false
	Clear(&g.DragDropPayload)
	g.DragDropAcceptFlags = ImGuiDragDropFlags_.ImGuiDragDropFlags_None
	g.DragDropAcceptIdPrev = 0; g.DragDropAcceptIdCurr = g.DragDropAcceptIdPrev
	g.DragDropAcceptIdCurrRectSurface = FLT_MAX
	g.DragDropAcceptFrameCount = -1

	clear(&g.DragDropPayloadBufHeap)
	memset(&g.DragDropPayloadBufLocal, 0, size_of(g.DragDropPayloadBufLocal))
}

BeginTooltipHidden :: proc() -> bool
{
	g : ^ImGuiContext = GImGui^
	ret : bool = Begin("##Tooltip_Hidden", nil, ImGuiWindowFlags_.ImGuiWindowFlags_Tooltip | ImGuiWindowFlags_.ImGuiWindowFlags_NoInputs | ImGuiWindowFlags_.ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_.ImGuiWindowFlags_NoMove | ImGuiWindowFlags_.ImGuiWindowFlags_NoResize | ImGuiWindowFlags_.ImGuiWindowFlags_NoSavedSettings | ImGuiWindowFlags_.ImGuiWindowFlags_AlwaysAutoResize)
	SetWindowHiddenAndSkipItemsForCurrentFrame(g.CurrentWindow)
	return ret
}

// Drag and Drop
// - On source items, call BeginDragDropSource(), if it returns true also call SetDragDropPayload() + EndDragDropSource().
// - On target candidates, call BeginDragDropTarget(), if it returns true also call AcceptDragDropPayload() + EndDragDropTarget().
// - If you stop calling BeginDragDropSource() the payload is preserved however it won't have a preview tooltip (we currently display a fallback "..." tooltip, see #1725)
// - An item can be both drag source and drop target.
// call after submitting an item which may be dragged. when this return true, you can call SetDragDropPayload() + EndDragDropSource()
// When this returns true you need to: a) call SetDragDropPayload() exactly once, b) you may render the payload visual/description, c) call EndDragDropSource()
// If the item has an identifier:
// - This assume/require the item to be activated (typically via ButtonBehavior).
// - Therefore if you want to use this with a mouse button other than left mouse button, it is up to the item itself to activate with another button.
// - We then pull and use the mouse button that was used to activate the item and use it to carry on the drag.
// If the item has no identifier:
// - Currently always assume left mouse button.
BeginDragDropSource :: proc(flags : ImGuiDragDropFlags) -> bool
{
	g : ^ImGuiContext = GImGui^
	window : ^ImGuiWindow = g.CurrentWindow

	// FIXME-DRAGDROP: While in the common-most "drag from non-zero active id" case we can tell the mouse button,
	// in both SourceExtern and id==0 cases we may requires something else (explicit flags or some heuristic).
	mouse_button : ImGuiMouseButton = ImGuiMouseButton_.ImGuiMouseButton_Left

	source_drag_active : bool = false
	source_id : ImGuiID = 0
	source_parent_id : ImGuiID = 0
	if (flags & ImGuiDragDropFlags_.ImGuiDragDropFlags_SourceExtern) == 0 {
		source_id = g.LastItemData.ID
		if source_id != 0 {
			// Common path: items with ID
			if g.ActiveId != source_id { return false }
			if g.ActiveIdMouseButton != -1 { mouse_button = g.ActiveIdMouseButton }
			if g.IO.MouseDown[mouse_button] == false || window.SkipItems { return false }
			g.ActiveIdAllowOverlap = false
		}
		else {
			// Uncommon path: items without ID
			if g.IO.MouseDown[mouse_button] == false || window.SkipItems { return false }
			if (g.LastItemData.StatusFlags & ImGuiItemStatusFlags_.ImGuiItemStatusFlags_HoveredRect) == 0 && (g.ActiveId == 0 || g.ActiveIdWindow != window) { return false }

			// If you want to use BeginDragDropSource() on an item with no unique identifier for interaction, such as Text() or Image(), you need to:
			// A) Read the explanation below, B) Use the ImGuiDragDropFlags_SourceAllowNullID flag.
			if !(flags & ImGuiDragDropFlags_.ImGuiDragDropFlags_SourceAllowNullID) {
				IM_ASSERT(0)
				return false
			}

			// Magic fallback to handle items with no assigned ID, e.g. Text(), Image()
			// We build a throwaway ID based on current ID stack + relative AABB of items in window.
			// THE IDENTIFIER WON'T SURVIVE ANY REPOSITIONING/RESIZINGG OF THE WIDGET, so if your widget moves your dragging operation will be canceled.
			// We don't need to maintain/call ClearActiveID() as releasing the button will early out this function and trigger !ActiveIdIsAlive.
			// Rely on keeping other window->LastItemXXX fields intact.
			g.LastItemData.ID = GetIDFromRectangle(window, g.LastItemData.Rect); source_id = g.LastItemData.ID
			KeepAliveID(source_id)
			is_hovered : bool = ItemHoverable(g.LastItemData.Rect, source_id, g.LastItemData.ItemFlags)
			if is_hovered && g.IO.MouseClicked[mouse_button] {
				SetActiveID(source_id, window)
				FocusWindow(window)
			}
			if g.ActiveId == source_id {
				// Allow the underlying widget to display/return hovered during the mouse release frame, else we would get a flicker.g.ActiveIdAllowOverlap = is_hovered
			}
		}
		if g.ActiveId != source_id { return false }
		source_parent_id = back(&window.IDStack)
		source_drag_active = IsMouseDragging(mouse_button)

		// Disable navigation and key inputs while dragging + cancel existing request if any
		SetActiveIdUsingAllKeyboardKeys()
	}
	else {
		// When ImGuiDragDropFlags_SourceExtern is set:
		window = nil
		source_id = ImHashStr("#SourceExtern")
		source_drag_active = true
		mouse_button = g.IO.MouseDown[0] ? 0 : -1
		KeepAliveID(source_id)
		SetActiveID(source_id, nil)
	}

	IM_ASSERT(g.DragDropWithinTarget == false); // Can't nest BeginDragDropSource() and BeginDragDropTarget()
	if !source_drag_active { return false }

	// Activate drag and drop
	if !g.DragDropActive {
		IM_ASSERT(source_id != 0)
		ClearDragDrop()
		IMGUI_DEBUG_LOG_ACTIVEID("[dragdrop] BeginDragDropSource() DragDropActive = true, source_id = 0x%08X%s\n", source_id, (flags & ImGuiDragDropFlags_.ImGuiDragDropFlags_SourceExtern) ? " (EXTERN)" : "")
		payload : ^ImGuiPayload = g.DragDropPayload
		payload.SourceId = source_id
		payload.SourceParentId = source_parent_id
		g.DragDropActive = true
		g.DragDropSourceFlags = flags
		g.DragDropMouseButton = mouse_button
		if payload.SourceId == g.ActiveId { g.ActiveIdNoClearOnFocusLoss = true }
	}
	g.DragDropSourceFrameCount = g.FrameCount
	g.DragDropWithinSource = true

	if !(flags & ImGuiDragDropFlags_.ImGuiDragDropFlags_SourceNoPreviewTooltip) {
		// Target can request the Source to not display its tooltip (we use a dedicated flag to make this request explicit)
		// We unfortunately can't just modify the source flags and skip the call to BeginTooltip, as caller may be emitting contents.
		ret : bool
		if g.DragDropAcceptIdPrev && (g.DragDropAcceptFlags & ImGuiDragDropFlags_.ImGuiDragDropFlags_AcceptNoPreviewTooltip) { ret = BeginTooltipHidden() }
		else { ret = BeginTooltip() }
		IM_ASSERT(ret); // FIXME-NEWBEGIN: If this ever becomes false, we need to Begin("##Hidden", NULL, ImGuiWindowFlags_NoSavedSettings) + SetWindowHiddendAndSkipItemsForCurrentFrame().
		IM_UNUSED(ret)
	}

	if !(flags & ImGuiDragDropFlags_.ImGuiDragDropFlags_SourceNoDisableHover) && !(flags & ImGuiDragDropFlags_.ImGuiDragDropFlags_SourceExtern) { g.LastItemData.StatusFlags &= !ImGuiItemStatusFlags_.ImGuiItemStatusFlags_HoveredRect }

	return true
}

// only call EndDragDropSource() if BeginDragDropSource() returns true!
EndDragDropSource :: proc()
{
	g : ^ImGuiContext = GImGui^
	IM_ASSERT(g.DragDropActive)
	IM_ASSERT(g.DragDropWithinSource && "Not after a BeginDragDropSource()?")

	if !(g.DragDropSourceFlags & ImGuiDragDropFlags_.ImGuiDragDropFlags_SourceNoPreviewTooltip) { EndTooltip() }

	// Discard the drag if have not called SetDragDropPayload()
	if g.DragDropPayload.DataFrameCount == -1 { ClearDragDrop() }
	g.DragDropWithinSource = false
}

// type is a user defined string of maximum 32 characters. Strings starting with '_' are reserved for dear imgui internal types. Data is copied and held by imgui. Return true when payload has been accepted.
// Use 'cond' to choose to submit payload on drag start or every frame
SetDragDropPayload :: proc(type : ^u8, data : rawptr, data_size : uint, cond : ImGuiCond) -> bool
{
	g : ^ImGuiContext = GImGui^
	payload : ^ImGuiPayload = g.DragDropPayload
	if cond == 0 { cond = ImGuiCond_.ImGuiCond_Always }

	IM_ASSERT(type != nil)
	IM_ASSERT(strlen(type) < IM_ARRAYSIZE(payload.DataType) && "Payload type can be at most 32 characters long")
	IM_ASSERT((data != nil && data_size > 0) || (data == nil && data_size == 0))
	IM_ASSERT(cond == ImGuiCond_.ImGuiCond_Always || cond == ImGuiCond_.ImGuiCond_Once)
	IM_ASSERT(payload.SourceId != 0); // Not called between BeginDragDropSource() and EndDragDropSource()

	if cond == ImGuiCond_.ImGuiCond_Always || payload.DataFrameCount == -1 {
		// Copy payload
		ImStrncpy(payload.DataType, type, IM_ARRAYSIZE(payload.DataType))
		resize(&g.DragDropPayloadBufHeap, 0)
		if data_size > size_of(g.DragDropPayloadBufLocal) {
			// Store in heap
			resize(&g.DragDropPayloadBufHeap, cast(i32) data_size)
			payload.Data = g.DragDropPayloadBufHeap.Data
			memcpy(payload.Data, data, data_size)
		}
		else if data_size > 0 {
			// Store locally
			memset(&g.DragDropPayloadBufLocal, 0, size_of(g.DragDropPayloadBufLocal))
			payload.Data = g.DragDropPayloadBufLocal
			memcpy(payload.Data, data, data_size)
		}
		else {
			payload.Data = nil
		}
		payload.DataSize = cast(i32) data_size
	}
	payload.DataFrameCount = g.FrameCount

	// Return whether the payload has been accepted
	return (g.DragDropAcceptFrameCount == g.FrameCount) || (g.DragDropAcceptFrameCount == g.FrameCount - 1)
}

BeginDragDropTargetCustom :: proc(bb : ^ImRect, id : ImGuiID) -> bool
{
	g : ^ImGuiContext = GImGui^
	if !g.DragDropActive { return false }

	window : ^ImGuiWindow = g.CurrentWindow
	hovered_window : ^ImGuiWindow = g.HoveredWindowUnderMovingWindow
	if hovered_window == nil || window.RootWindowDockTree != hovered_window.RootWindowDockTree { return false }
	IM_ASSERT(id != 0)
	if !IsMouseHoveringRect(bb.Min, bb.Max) || (id == g.DragDropPayload.SourceId) { return false }
	if window.SkipItems { return false }

	IM_ASSERT(g.DragDropWithinTarget == false && g.DragDropWithinSource == false); // Can't nest BeginDragDropSource() and BeginDragDropTarget()
	g.DragDropTargetRect = bb
	g.DragDropTargetClipRect = window.ClipRect; // May want to be overridden by user depending on use case?
	g.DragDropTargetId = id
	g.DragDropWithinTarget = true
	return true
}

// call after submitting an item that may receive a payload. If this returns true, you can call AcceptDragDropPayload() + EndDragDropTarget()
// We don't use BeginDragDropTargetCustom() and duplicate its code because:
// 1) we use LastItemData's ImGuiItemStatusFlags_HoveredRect which handles items that push a temporarily clip rectangle in their code. Calling BeginDragDropTargetCustom(LastItemRect) would not handle them.
// 2) and it's faster. as this code may be very frequently called, we want to early out as fast as we can.
// Also note how the HoveredWindow test is positioned differently in both functions (in both functions we optimize for the cheapest early out case)
BeginDragDropTarget :: proc() -> bool
{
	g : ^ImGuiContext = GImGui^
	if !g.DragDropActive { return false }

	window : ^ImGuiWindow = g.CurrentWindow
	if !(g.LastItemData.StatusFlags & ImGuiItemStatusFlags_.ImGuiItemStatusFlags_HoveredRect) { return false }
	hovered_window : ^ImGuiWindow = g.HoveredWindowUnderMovingWindow
	if hovered_window == nil || window.RootWindowDockTree != hovered_window.RootWindowDockTree || window.SkipItems { return false }

	display_rect : ^ImRect = (g.LastItemData.StatusFlags & ImGuiItemStatusFlags_.ImGuiItemStatusFlags_HasDisplayRect) ? g.LastItemData.DisplayRect : g.LastItemData.Rect
	id : ImGuiID = g.LastItemData.ID
	if id == 0 {
		id = GetIDFromRectangle(window, display_rect)
		KeepAliveID(id)
	}
	if g.DragDropPayload.SourceId == id { return false }

	IM_ASSERT(g.DragDropWithinTarget == false && g.DragDropWithinSource == false); // Can't nest BeginDragDropSource() and BeginDragDropTarget()
	g.DragDropTargetRect = display_rect
	g.DragDropTargetClipRect = (g.LastItemData.StatusFlags & ImGuiItemStatusFlags_.ImGuiItemStatusFlags_HasClipRect) ? g.LastItemData.ClipRect : window.ClipRect
	g.DragDropTargetId = id
	g.DragDropWithinTarget = true
	return true
}

IsDragDropPayloadBeingAccepted :: proc() -> bool
{
	g : ^ImGuiContext = GImGui^
	return g.DragDropActive && g.DragDropAcceptIdPrev != 0
}

// accept contents of a given type. If ImGuiDragDropFlags_AcceptBeforeDelivery is set you can peek into the payload before the mouse button is released.
AcceptDragDropPayload :: proc(type : ^u8, flags : ImGuiDragDropFlags) -> ^ImGuiPayload
{
	g : ^ImGuiContext = GImGui^
	payload : ^ImGuiPayload = g.DragDropPayload
	IM_ASSERT(g.DragDropActive); // Not called between BeginDragDropTarget() and EndDragDropTarget() ?
	IM_ASSERT(payload.DataFrameCount != -1); // Forgot to call EndDragDropTarget() ?
	if type != nil && !IsDataType(&payload, type) { return nil }

	// Accept smallest drag target bounding box, this allows us to nest drag targets conveniently without ordering constraints.
	// NB: We currently accept NULL id as target. However, overlapping targets requires a unique ID to function!
	was_accepted_previously : bool = (g.DragDropAcceptIdPrev == g.DragDropTargetId)
	r : ImRect = g.DragDropTargetRect
	r_surface : f32 = GetWidth(&r) * GetHeight(&r)
	if r_surface > g.DragDropAcceptIdCurrRectSurface { return nil }

	g.DragDropAcceptFlags = flags
	g.DragDropAcceptIdCurr = g.DragDropTargetId
	g.DragDropAcceptIdCurrRectSurface = r_surface
	//IMGUI_DEBUG_LOG("AcceptDragDropPayload(): %08X: accept\n", g.DragDropTargetId);

	// Render default drop visuals
	payload.Preview = was_accepted_previously
	flags |= (g.DragDropSourceFlags & ImGuiDragDropFlags_.ImGuiDragDropFlags_AcceptNoDrawDefaultRect); // Source can also inhibit the preview (useful for external sources that live for 1 frame)
	if !(flags & ImGuiDragDropFlags_.ImGuiDragDropFlags_AcceptNoDrawDefaultRect) && payload.Preview { RenderDragDropTargetRect(r, g.DragDropTargetClipRect) }

	g.DragDropAcceptFrameCount = g.FrameCount
	if (g.DragDropSourceFlags & ImGuiDragDropFlags_.ImGuiDragDropFlags_SourceExtern) && g.DragDropMouseButton == -1 { payload.Delivery = was_accepted_previously && (g.DragDropSourceFrameCount < g.FrameCount) }
	else {
		// For extern drag sources affecting OS window focus, it's easier to just test !IsMouseDown() instead of IsMouseReleased()
		payload.Delivery = was_accepted_previously && !IsMouseDown(g.DragDropMouseButton)
	}
	if !payload.Delivery && !(flags & ImGuiDragDropFlags_.ImGuiDragDropFlags_AcceptBeforeDelivery) { return nil }

	if payload.Delivery { IMGUI_DEBUG_LOG_ACTIVEID("[dragdrop] AcceptDragDropPayload(): 0x%08X: payload delivery\n", g.DragDropTargetId) }
	return &payload
}

// FIXME-STYLE FIXME-DRAGDROP: Settle on a proper default visuals for drop target.
RenderDragDropTargetRect :: proc(bb : ^ImRect, item_clip_rect : ^ImRect)
{
	g : ^ImGuiContext = GImGui^
	window : ^ImGuiWindow = g.CurrentWindow
	bb_display : ImRect = bb
	ClipWith(&bb_display, item_clip_rect); // Clip THEN expand so we have a way to visualize that target is not entirely visible.
	Expand(&bb_display, 3.5)
	push_clip_rect : bool = !Contains(&window.ClipRect, bb_display)
	if push_clip_rect { PushClipRectFullScreen(window.DrawList) }
	AddRect(window.DrawList, bb_display.Min, bb_display.Max, GetColorU32(ImGuiCol_.ImGuiCol_DragDropTarget), 0.0, 0, 2.0)
	if push_clip_rect { PopClipRect(window.DrawList) }
}

// peek directly into the current payload from anywhere. returns NULL when drag and drop is finished or inactive. use ImGuiPayload::IsDataType() to test for the payload type.
GetDragDropPayload :: proc() -> ^ImGuiPayload
{
	g : ^ImGuiContext = GImGui^
	return (g.DragDropActive && g.DragDropPayload.DataFrameCount != -1) ? &g.DragDropPayload : nil
}

// only call EndDragDropTarget() if BeginDragDropTarget() returns true!
EndDragDropTarget :: proc()
{
	g : ^ImGuiContext = GImGui^
	IM_ASSERT(g.DragDropActive)
	IM_ASSERT(g.DragDropWithinTarget)
	g.DragDropWithinTarget = false

	// Clear drag and drop state payload right after delivery
	if g.DragDropPayload.Delivery { ClearDragDrop() }
}

//-----------------------------------------------------------------------------
// [SECTION] LOGGING/CAPTURING
//-----------------------------------------------------------------------------
// All text output from the interface can be captured into tty/file/clipboard.
// By default, tree nodes are automatically opened during logging.
//-----------------------------------------------------------------------------

// Pass text data straight to log (without being displayed)
LogTextV_0 :: #force_inline proc(g : ^ImGuiContext, fmt : ^u8, args : []any)
{
	if g.LogFile {
		resize(&g.LogBuffer.Buf, 0)
		appendfv(&g.LogBuffer, fmt, args)
		ImFileWrite(c_str(&g.LogBuffer), size_of(u8), cast(ImU64) size(&g.LogBuffer), g.LogFile)
	}
	else {
		appendfv(&g.LogBuffer, fmt, args)
	}
}

// pass text data straight to log (without being displayed)
LogText :: proc(fmt : ^u8, args : ..[]any)
{
	g : ^ImGuiContext = GImGui^
	if !g.LogEnabled { return }

	args : []any
	va_start(args, fmt)
	LogTextV(g, fmt, args)
	va_end(args)
}

LogTextV_1 :: proc(fmt : ^u8, args : []any)
{
	g : ^ImGuiContext = GImGui^
	if !g.LogEnabled { return }

	LogTextV(g, fmt, args)
}

// Internal version that takes a position to decide on newline placement and pad items according to their depth.
// We split text into individual lines to add current tree level padding
// FIXME: This code is a little complicated perhaps, considering simplifying the whole system.
LogRenderedText :: proc(ref_pos : ^ImVec2, text : ^u8, text_end : ^u8)
{
	g : ^ImGuiContext = GImGui^
	window : ^ImGuiWindow = g.CurrentWindow

	prefix : ^u8 = g.LogNextPrefix
	suffix : ^u8 = g.LogNextSuffix
	g.LogNextSuffix = nil; g.LogNextPrefix = g.LogNextSuffix

	if !text_end { text_end = FindRenderedTextEnd(text, text_end) }

	log_new_line : bool = ref_pos && (ref_pos.y > g.LogLinePosY + g.Style.FramePadding.y + 1)
	if ref_pos { g.LogLinePosY = ref_pos.y }
	if log_new_line {
		LogText(IM_NEWLINE)
		g.LogLineFirstItem = true
	}

	if prefix {
		// Calculate end ourself to ensure "##" are included here.
		LogRenderedText(ref_pos, prefix, prefix + strlen(prefix))
	}

	// Re-adjust padding if we have popped out of our starting depth
	if g.LogDepthRef > window.DC.TreeDepth { g.LogDepthRef = window.DC.TreeDepth }
	tree_depth : i32 = (window.DC.TreeDepth - g.LogDepthRef)

	text_remaining : ^u8 = text
	for {
		// Split the string. Each new line (after a '\n') is followed by indentation corresponding to the current depth of our log entry.
		// We don't add a trailing \n yet to allow a subsequent item on the same line to be captured.
		line_start : ^u8 = text_remaining
		line_end : ^u8 = ImStreolRange(line_start, text_end)
		is_last_line : bool = (line_end == text_end)
		if line_start != line_end || !is_last_line {
			line_length : i32 = cast(i32) (line_end - line_start)
			indentation : i32 = g.LogLineFirstItem ? tree_depth * 4 : 1
			LogText("%*s%.*s", indentation, "", line_length, line_start)
			g.LogLineFirstItem = false
			if line_end^ == '\n' {
				LogText(IM_NEWLINE)
				g.LogLineFirstItem = true
			}
		}
		if is_last_line { break }
		text_remaining = line_end + 1
	}

	if suffix { LogRenderedText(ref_pos, suffix, suffix + strlen(suffix)) }
}

// Logging/Capture
// -> BeginCapture() when we design v2 api, for now stay under the radar by using the old name.
// Start logging/capturing text output
LogBegin :: proc(flags : ImGuiLogFlags, auto_open_depth : i32)
{
	g : ^ImGuiContext = GImGui^
	window : ^ImGuiWindow = g.CurrentWindow
	IM_ASSERT(g.LogEnabled == false)
	IM_ASSERT(g.LogFile == nil && empty(&g.LogBuffer))
	IM_ASSERT(ImIsPowerOfTwo(flags & ImGuiLogFlags_.ImGuiLogFlags_OutputMask_)); // Check that only 1 type flag is used

	g.ItemUnclipByLog = true; g.LogEnabled = g.ItemUnclipByLog
	g.LogFlags = flags
	g.LogWindow = window
	g.LogNextSuffix = nil; g.LogNextPrefix = g.LogNextSuffix
	g.LogDepthRef = window.DC.TreeDepth
	g.LogDepthToExpand = ((auto_open_depth >= 0) ? auto_open_depth : g.LogDepthToExpandDefault)
	g.LogLinePosY = FLT_MAX
	g.LogLineFirstItem = true
}

// Important: doesn't copy underlying data, use carefully (prefix/suffix must be in scope at the time of the next LogRenderedText)
LogSetNextTextDecoration :: proc(prefix : ^u8, suffix : ^u8)
{
	g : ^ImGuiContext = GImGui^
	g.LogNextPrefix = prefix
	g.LogNextSuffix = suffix
}

// Logging/Capture
// - All text output from the interface can be captured into tty/file/clipboard. By default, tree nodes are automatically opened during logging.
// start logging to tty (stdout)
LogToTTY :: proc(auto_open_depth : i32)
{
	g : ^ImGuiContext = GImGui^
	if g.LogEnabled { return }
	IM_UNUSED(auto_open_depth)
	when ! IMGUI_DISABLE_TTY_FUNCTIONS { // @gen ifndef
	LogBegin(ImGuiLogFlags_.ImGuiLogFlags_OutputTTY, auto_open_depth)
	g.LogFile = stdout
	} // preproc endif
}

// start logging to file
// Start logging/capturing text output to given file
LogToFile :: proc(auto_open_depth : i32, filename : ^u8)
{
	g : ^ImGuiContext = GImGui^
	if g.LogEnabled { return }

	// FIXME: We could probably open the file in text mode "at", however note that clipboard/buffer logging will still
	// be subject to outputting OS-incompatible carriage return if within strings the user doesn't use IM_NEWLINE.
	// By opening the file in binary mode "ab" we have consistent output everywhere.
	if !filename { filename = g.IO.LogFilename }
	if !filename || !filename[0] { return }
	f : ImFileHandle = ImFileOpen(filename, "ab")
	if !f {
		IM_ASSERT(0)
		return
	}

	LogBegin(ImGuiLogFlags_.ImGuiLogFlags_OutputFile, auto_open_depth)
	g.LogFile = f
}

// start logging to OS clipboard
// Start logging/capturing text output to clipboard
LogToClipboard :: proc(auto_open_depth : i32)
{
	g : ^ImGuiContext = GImGui^
	if g.LogEnabled { return }
	LogBegin(ImGuiLogFlags_.ImGuiLogFlags_OutputClipboard, auto_open_depth)
}

// Start logging/capturing to internal buffer
LogToBuffer :: proc(auto_open_depth : i32)
{
	g : ^ImGuiContext = GImGui^
	if g.LogEnabled { return }
	LogBegin(ImGuiLogFlags_.ImGuiLogFlags_OutputBuffer, auto_open_depth)
}

// stop logging (close file, etc.)
LogFinish :: proc()
{
	g : ^ImGuiContext = GImGui^
	if !g.LogEnabled { return }

	LogText(IM_NEWLINE)
	switch g.LogFlags & ImGuiLogFlags_.ImGuiLogFlags_OutputMask_ {
		case ImGuiLogFlags_.ImGuiLogFlags_OutputTTY:
			when ! IMGUI_DISABLE_TTY_FUNCTIONS { // @gen ifndef
			fflush(g.LogFile)
			} // preproc endif
			break

		case ImGuiLogFlags_.ImGuiLogFlags_OutputFile:
			ImFileClose(g.LogFile)
			break

		case ImGuiLogFlags_.ImGuiLogFlags_OutputBuffer:
			break

		case ImGuiLogFlags_.ImGuiLogFlags_OutputClipboard:
			if !empty(&g.LogBuffer) { SetClipboardText(begin(&g.LogBuffer)) }
			break

		case:
			IM_ASSERT(0)
			break
	}

	g.ItemUnclipByLog = false; g.LogEnabled = g.ItemUnclipByLog
	g.LogFlags = ImGuiLogFlags_.ImGuiLogFlags_None
	g.LogFile = nil
	clear(&g.LogBuffer)
}

// helper to display buttons for logging to tty/file/clipboard
// Helper to display logging buttons
// FIXME-OBSOLETE: We should probably obsolete this and let the user have their own helper (this is one of the oldest function alive!)
LogButtons :: proc()
{
	g : ^ImGuiContext = GImGui^

	PushID("LogButtons")
	when ! IMGUI_DISABLE_TTY_FUNCTIONS { // @gen ifndef
	log_to_tty : bool = Button("Log To TTY"); SameLine()
	} else { // preproc else
	log_to_tty : bool = false
	} // preproc endif
	log_to_file : bool = Button("Log To File"); SameLine()
	log_to_clipboard : bool = Button("Log To Clipboard"); SameLine()
	PushItemFlag(ImGuiItemFlags_.ImGuiItemFlags_NoTabStop, true)
	SetNextItemWidth(80.0)
	SliderInt("Default Depth", &g.LogDepthToExpandDefault, 0, 9, nil)
	PopItemFlag()
	PopID()

	// Start logging at the end of the function so that the buttons don't appear in the log
	if log_to_tty { LogToTTY() }
	if log_to_file { LogToFile() }
	if log_to_clipboard { LogToClipboard() }
}

// Misc
//-----------------------------------------------------------------------------
// [SECTION] SETTINGS
//-----------------------------------------------------------------------------
// - UpdateSettings() [Internal]
// - MarkIniSettingsDirty() [Internal]
// - FindSettingsHandler() [Internal]
// - ClearIniSettings() [Internal]
// - LoadIniSettingsFromDisk()
// - LoadIniSettingsFromMemory()
// - SaveIniSettingsToDisk()
// - SaveIniSettingsToMemory()
//-----------------------------------------------------------------------------
// - CreateNewWindowSettings() [Internal]
// - FindWindowSettingsByID() [Internal]
// - FindWindowSettingsByWindow() [Internal]
// - ClearWindowSettings() [Internal]
// - WindowSettingsHandler_***() [Internal]
//-----------------------------------------------------------------------------

// Called by NewFrame()
UpdateSettings :: proc()
{
	// Load settings on first frame (if not explicitly loaded manually before)
	g : ^ImGuiContext = GImGui^
	if !g.SettingsLoaded {
		IM_ASSERT(empty(&g.SettingsWindows))
		if g.IO.IniFilename { LoadIniSettingsFromDisk(g.IO.IniFilename) }
		g.SettingsLoaded = true
	}

	// Save settings (with a delay after the last modification, so we don't spam disk too much)
	if g.SettingsDirtyTimer > 0.0 {
		g.SettingsDirtyTimer -= g.IO.DeltaTime
		if g.SettingsDirtyTimer <= 0.0 {
			if g.IO.IniFilename != nil { SaveIniSettingsToDisk(g.IO.IniFilename) }
			else {
				// Let user know they can call SaveIniSettingsToMemory(). user will need to clear io.WantSaveIniSettings themselves.
				g.IO.WantSaveIniSettings = true
			}
			g.SettingsDirtyTimer = 0.0
		}
	}
}

// Settings
MarkIniSettingsDirty_0 :: proc()
{
	g : ^ImGuiContext = GImGui^
	if g.SettingsDirtyTimer <= 0.0 { g.SettingsDirtyTimer = g.IO.IniSavingRate }
}

// Settings
MarkIniSettingsDirty_1 :: proc(window : ^ImGuiWindow)
{
	g : ^ImGuiContext = GImGui^
	if !(window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoSavedSettings) { if g.SettingsDirtyTimer <= 0.0 { g.SettingsDirtyTimer = g.IO.IniSavingRate } }
}

AddSettingsHandler :: proc(handler : ^ImGuiSettingsHandler)
{
	g : ^ImGuiContext = GImGui^
	IM_ASSERT(FindSettingsHandler(handler.TypeName) == nil)
	push_back(&g.SettingsHandlers, handler^)
}

RemoveSettingsHandler :: proc(type_name : ^u8)
{
	g : ^ImGuiContext = GImGui^
	if handler : ^ImGuiSettingsHandler = FindSettingsHandler(type_name); handler { erase(&g.SettingsHandlers, handler) }
}

FindSettingsHandler :: proc(type_name : ^u8) -> ^ImGuiSettingsHandler
{
	g : ^ImGuiContext = GImGui^
	type_hash : ImGuiID = ImHashStr(type_name)
	for handler in g.SettingsHandlers { if handler.TypeHash == type_hash { return &handler } }

	return nil
}

// Clear all settings (windows, tables, docking etc.)
ClearIniSettings :: proc()
{
	g : ^ImGuiContext = GImGui^
	clear(&g.SettingsIniData)
	for handler in g.SettingsHandlers { if handler.ClearAllFn != nil { ClearAllFn(&handler, &g, &handler) } }
}

// Settings/.Ini Utilities
// - The disk functions are automatically called if io.IniFilename != NULL (default is "imgui.ini").
// - Set io.IniFilename to NULL to load/save manually. Read io.WantSaveIniSettings description about handling .ini saving manually.
// - Important: default value "imgui.ini" is relative to current working dir! Most apps will want to lock this to an absolute path (e.g. same path as executables).
// call after CreateContext() and before the first call to NewFrame(). NewFrame() automatically calls LoadIniSettingsFromDisk(io.IniFilename).
LoadIniSettingsFromDisk :: proc(ini_filename : ^u8)
{
	file_data_size : uint = 0
	file_data : ^u8 = cast(^u8) ImFileLoadToMemory(ini_filename, "rb", &file_data_size)
	if !file_data { return }
	if file_data_size > 0 { LoadIniSettingsFromMemory(file_data, cast(uint) file_data_size) }
	IM_FREE(file_data)
}

// call after CreateContext() and before the first call to NewFrame() to provide .ini data from your own data source.
// Zero-tolerance, no error reporting, cheap .ini parsing
// Set ini_size==0 to let us use strlen(ini_data). Do not call this function with a 0 if your buffer is actually empty!
LoadIniSettingsFromMemory :: proc(ini_data : ^u8, ini_size : uint)
{
	g : ^ImGuiContext = GImGui^
	IM_ASSERT(g.Initialized)
	//IM_ASSERT(!g.WithinFrameScope && "Cannot be called between NewFrame() and EndFrame()");
	//IM_ASSERT(g.SettingsLoaded == false && g.FrameCount == 0);

	// For user convenience, we allow passing a non zero-terminated string (hence the ini_size parameter).
	// For our convenience and to make the code simpler, we'll also write zero-terminators within the buffer. So let's create a writable copy..
	if ini_size == 0 { ini_size = strlen(ini_data) }
	resize(&g.SettingsIniData.Buf, cast(i32) ini_size + 1)
	buf : ^u8 = g.SettingsIniData.Buf.Data
	buf_end : ^u8 = buf + ini_size
	memcpy(buf, ini_data, ini_size)
	buf_end[0] = 0

	// Call pre-read handlers
	// Some types will clear their data (e.g. dock information) some types will allow merge/override (window)
	for handler in g.SettingsHandlers { if handler.ReadInitFn != nil { ReadInitFn(&handler, &g, &handler) } }

	entry_data : rawptr = nil
	entry_handler : ^ImGuiSettingsHandler = nil

	line_end : ^u8 = nil
	for line : ^u8 = buf; line < buf_end; line = line_end + 1 {
		// Skip new lines markers, then find end of the line
		for line^ == '\n' || line^ == '\r' { post_incr(&line) }

		line_end = line
		for line_end < buf_end && line_end^ != '\n' && line_end^ != '\r' { post_incr(&line_end) }

		line_end[0] = 0
		if line[0] == ';' { continue }
		if line[0] == '[' && line_end > line && line_end[-1] == ']' {
			// Parse "[Type][Name]". Note that 'Name' can itself contains [] characters, which is acceptable with the current format and parsing code.
			line_end[-1] = 0
			name_end : ^u8 = line_end - 1
			type_start : ^u8 = line + 1
			type_end : ^u8 = cast(^u8) cast(rawptr) ImStrchrRange(type_start, name_end, ']')
			name_start : ^u8 = type_end ? ImStrchrRange(type_end + 1, name_end, '[') : nil
			if !type_end || !name_start { continue }
			type_end^ = 0; // Overwrite first ']'
			post_incr(&name_start); // Skip second '['
			entry_handler = FindSettingsHandler(type_start)
			entry_data = entry_handler ? ReadOpenFn(entry_handler, &g, entry_handler, name_start) : nil
		}
		else if entry_handler != nil && entry_data != nil {
			// Let type handler parse the line
			ReadLineFn(entry_handler, &g, entry_handler, entry_data, line)
		}
	}

	g.SettingsLoaded = true

	// [DEBUG] Restore untouched copy so it can be browsed in Metrics (not strictly necessary)
	memcpy(buf, ini_data, ini_size)

	// Call post-read handlers
	for handler in g.SettingsHandlers { if handler.ApplyAllFn != nil { ApplyAllFn(&handler, &g, &handler) } }
}

// this is automatically called (if io.IniFilename is not empty) a few seconds after any modification that should be reflected in the .ini file (and also by DestroyContext).
SaveIniSettingsToDisk :: proc(ini_filename : ^u8)
{
	g : ^ImGuiContext = GImGui^
	g.SettingsDirtyTimer = 0.0
	if !ini_filename { return }

	ini_data_size : uint = 0
	ini_data : ^u8 = SaveIniSettingsToMemory(&ini_data_size)
	f : ImFileHandle = ImFileOpen(ini_filename, "wt")
	if !f { return }
	ImFileWrite(ini_data, size_of(u8), ini_data_size, f)
	ImFileClose(f)
}

// return a zero-terminated string with the .ini data which you can save by your own mean. call when io.WantSaveIniSettings is set, then save data by your own mean and clear io.WantSaveIniSettings.
// Call registered handlers (e.g. SettingsHandlerWindow_WriteAll() + custom handlers) to write their stuff into a text buffer
SaveIniSettingsToMemory :: proc(out_size : ^uint) -> ^u8
{
	g : ^ImGuiContext = GImGui^
	g.SettingsDirtyTimer = 0.0
	resize(&g.SettingsIniData.Buf, 0)
	push_back(&g.SettingsIniData.Buf, 0)
	for handler in g.SettingsHandlers { WriteAllFn(&handler, &g, &handler, &g.SettingsIniData) }

	if out_size { out_size^ = cast(uint) size(&g.SettingsIniData) }
	return c_str(&g.SettingsIniData)
}

// Settings - Windows
CreateNewWindowSettings :: proc(name : ^u8) -> ^ImGuiWindowSettings
{
	g : ^ImGuiContext = GImGui^

	if g.IO.ConfigDebugIniSettings == false {
		// Skip to the "###" marker if any. We don't skip past to match the behavior of GetID()
		// Preserve the full string when ConfigDebugVerboseIniSettings is set to make .ini inspection easier.
		if p : ^u8 = strstr(name, "###"); p { name = p }
	}
	name_len : uint = strlen(name)

	// Allocate chunk
	chunk_size : uint = size_of(ImGuiWindowSettings) + name_len + 1
	settings : ^ImGuiWindowSettings = alloc_chunk(&g.SettingsWindows, chunk_size)
	ImGuiWindowSettings()
	settings.ID = ImHashStr(name, name_len)
	memcpy(GetName(settings), name, name_len + 1); // Store with zero terminator

	return settings
}

// We don't provide a FindWindowSettingsByName() because Docking system doesn't always hold on names.
// This is called once per window .ini entry + once per newly instantiated window.
FindWindowSettingsByID :: proc(id : ImGuiID) -> ^ImGuiWindowSettings
{
	g : ^ImGuiContext = GImGui^
	for settings : ^ImGuiWindowSettings = begin(&g.SettingsWindows); settings != nil; settings = next_chunk(&g.SettingsWindows, settings) { if settings.ID == id && !settings.WantDelete { return settings } }

	return nil
}

// This is faster if you are holding on a Window already as we don't need to perform a search.
FindWindowSettingsByWindow :: proc(window : ^ImGuiWindow) -> ^ImGuiWindowSettings
{
	g : ^ImGuiContext = GImGui^
	if window.SettingsOffset != -1 { return ptr_from_offset(&g.SettingsWindows, window.SettingsOffset) }
	return FindWindowSettingsByID(window.ID)
}

// This will revert window to its initial state, including enabling the ImGuiCond_FirstUseEver/ImGuiCond_Once conditions once more.
ClearWindowSettings :: proc(name : ^u8)
{
	//IMGUI_DEBUG_LOG("ClearWindowSettings('%s')\n", name);
	g : ^ImGuiContext = GImGui^
	window : ^ImGuiWindow = FindWindowByName(name)
	if window != nil {
		window.Flags |= ImGuiWindowFlags_.ImGuiWindowFlags_NoSavedSettings
		InitOrLoadWindowSettings(window, nil)
		if window.DockId != 0 { DockContextProcessUndockWindow(&g, window, true) }
	}
	if settings : ^ImGuiWindowSettings = window ? FindWindowSettingsByWindow(window) : FindWindowSettingsByID(ImHashStr(name)); settings { settings.WantDelete = true }
}

// Settings
WindowSettingsHandler_ClearAll :: proc(ctx : ^ImGuiContext, _ : ^ImGuiSettingsHandler)
{
	g : ^ImGuiContext = ctx^
	for window in g.Windows { window.SettingsOffset = -1 }

	clear(&g.SettingsWindows)
}

WindowSettingsHandler_ReadOpen :: proc(_ : ^ImGuiContext, _ : ^ImGuiSettingsHandler, name : ^u8) -> rawptr
{
	id : ImGuiID = ImHashStr(name)
	settings : ^ImGuiWindowSettings = FindWindowSettingsByID(id)
	if settings {
		// Clear existing if recycling previous entry
		settings^ = ImGuiWindowSettings()
	}
	else { settings = CreateNewWindowSettings(name) }
	settings.ID = id
	settings.WantApply = true
	return cast(rawptr) settings
}

WindowSettingsHandler_ReadLine :: proc(_ : ^ImGuiContext, _ : ^ImGuiSettingsHandler, entry : rawptr, line : ^u8)
{
	settings : ^ImGuiWindowSettings = cast(^ImGuiWindowSettings) entry
	x : i32; y : i32
	i : i32
	u1 : ImU32
	if sscanf(line, "Pos=%i,%i", &x, &y) == 2 { settings.Pos = ImVec2ih(cast(i16) x, cast(i16) y) }
	else if sscanf(line, "Size=%i,%i", &x, &y) == 2 { settings.Size = ImVec2ih(cast(i16) x, cast(i16) y) }
	else if sscanf(line, "ViewportId=0x%08X", &u1) == 1 { settings.ViewportId = u1 }
	else if sscanf(line, "ViewportPos=%i,%i", &x, &y) == 2 { settings.ViewportPos = ImVec2ih(cast(i16) x, cast(i16) y) }
	else if sscanf(line, "Collapsed=%d", &i) == 1 { settings.Collapsed = (i != 0) }
	else if sscanf(line, "IsChild=%d", &i) == 1 { settings.IsChild = (i != 0) }
	else if sscanf(line, "DockId=0x%X,%d", &u1, &i) == 2 {settings.DockId = u1; settings.DockOrder = cast(i16) i
	}
	else if sscanf(line, "DockId=0x%X", &u1) == 1 {settings.DockId = u1; settings.DockOrder = -1
	}
	else if sscanf(line, "ClassId=0x%X", &u1) == 1 { settings.ClassId = u1 }
}

// Apply to existing windows (if any)
WindowSettingsHandler_ApplyAll :: proc(ctx : ^ImGuiContext, _ : ^ImGuiSettingsHandler)
{
	g : ^ImGuiContext = ctx^
	for settings : ^ImGuiWindowSettings = begin(&g.SettingsWindows); settings != nil; settings = next_chunk(&g.SettingsWindows, settings) { if settings.WantApply {
	if window : ^ImGuiWindow = FindWindowByID(settings.ID); window { ApplyWindowSettings(window, settings) }
	settings.WantApply = false
} }
}

WindowSettingsHandler_WriteAll :: proc(ctx : ^ImGuiContext, handler : ^ImGuiSettingsHandler, buf : ^ImGuiTextBuffer)
{
	// Gather data from windows that were active during this session
	// (if a window wasn't opened in this session we preserve its settings)
	g : ^ImGuiContext = ctx^
	for window in g.Windows {
		if window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoSavedSettings { continue }

		settings : ^ImGuiWindowSettings = FindWindowSettingsByWindow(window)
		if !settings {
			settings = CreateNewWindowSettings(window.Name)
			window.SettingsOffset = offset_from_ptr(&g.SettingsWindows, settings)
		}
		IM_ASSERT(settings.ID == window.ID)
		settings.Pos = ImVec2ih(window.Pos - window.ViewportPos)
		settings.Size = ImVec2ih(window.SizeFull)
		settings.ViewportId = window.ViewportId
		settings.ViewportPos = ImVec2ih(window.ViewportPos)
		IM_ASSERT(window.DockNode == nil || window.DockNode.ID == window.DockId)
		settings.DockId = window.DockId
		settings.ClassId = window.WindowClass.ClassId
		settings.DockOrder = window.DockOrder
		settings.Collapsed = window.Collapsed
		settings.IsChild = (window.RootWindow != window); // Cannot rely on ImGuiWindowFlags_ChildWindow here as docked windows have this set.
		settings.WantDelete = false
	}

	// Write to text buffer
	reserve(buf, size(buf) + size(&g.SettingsWindows) * 6); // ballpark reserve
	for settings : ^ImGuiWindowSettings = begin(&g.SettingsWindows); settings != nil; settings = next_chunk(&g.SettingsWindows, settings) {
		if settings.WantDelete { continue }
		settings_name : ^u8 = GetName(settings)
		appendf(buf, "[%s][%s]\n", handler.TypeName, settings_name)
		if settings.IsChild {
			appendf(buf, "IsChild=1\n")
			appendf(buf, "Size=%d,%d\n", settings.Size.x, settings.Size.y)
		}
		else {
			if settings.ViewportId != 0 && settings.ViewportId != ImGui_IMGUI_VIEWPORT_DEFAULT_ID {
				appendf(buf, "ViewportPos=%d,%d\n", settings.ViewportPos.x, settings.ViewportPos.y)
				appendf(buf, "ViewportId=0x%08X\n", settings.ViewportId)
			}
			if settings.Pos.x != 0 || settings.Pos.y != 0 || settings.ViewportId == ImGui_IMGUI_VIEWPORT_DEFAULT_ID { appendf(buf, "Pos=%d,%d\n", settings.Pos.x, settings.Pos.y) }
			if settings.Size.x != 0 || settings.Size.y != 0 { appendf(buf, "Size=%d,%d\n", settings.Size.x, settings.Size.y) }
			appendf(buf, "Collapsed=%d\n", settings.Collapsed)
			if settings.DockId != 0 {
				//buf->appendf("TabId=0x%08X\n", ImHashStr("#TAB", 4, settings->ID)); // window->TabId: this is not read back but writing it makes "debugging" the .ini data easier.
				if settings.DockOrder == -1 { appendf(buf, "DockId=0x%08X\n", settings.DockId) }
				else { appendf(buf, "DockId=0x%08X,%d\n", settings.DockId, settings.DockOrder) }
				if settings.ClassId != 0 { appendf(buf, "ClassId=0x%08X\n", settings.ClassId) }
			}
		}
		append(buf, "\n")
	}
}

// Localization
//-----------------------------------------------------------------------------
// [SECTION] LOCALIZATION
//-----------------------------------------------------------------------------

LocalizeRegisterEntries :: proc(entries : ^ImGuiLocEntry, count : i32)
{
	g : ^ImGuiContext = GImGui^
	for n : i32 = 0; n < count; post_incr(&n) { g.LocalizationTable[entries[n].Key] = entries[n].Text }
}

// Viewports
// - Currently represents the Platform Window created by the application which is hosting our Dear ImGui windows.
// - In 'docking' branch with multi-viewport enabled, we extend this concept to have multiple active viewports.
// - In the future we will extend this concept further to also represent Platform Monitor and support a "no main platform window" operation mode.
// return primary/default viewport. This can never be NULL.
//-----------------------------------------------------------------------------
// [SECTION] VIEWPORTS, PLATFORM WINDOWS
//-----------------------------------------------------------------------------
// - GetMainViewport()
// - FindViewportByID()
// - FindViewportByPlatformHandle()
// - SetCurrentViewport() [Internal]
// - SetWindowViewport() [Internal]
// - GetWindowAlwaysWantOwnViewport() [Internal]
// - UpdateTryMergeWindowIntoHostViewport() [Internal]
// - UpdateTryMergeWindowIntoHostViewports() [Internal]
// - TranslateWindowsInViewport() [Internal]
// - ScaleWindowsInViewport() [Internal]
// - FindHoveredViewportFromPlatformWindowStack() [Internal]
// - UpdateViewportsNewFrame() [Internal]
// - UpdateViewportsEndFrame() [Internal]
// - AddUpdateViewport() [Internal]
// - WindowSelectViewport() [Internal]
// - WindowSyncOwnedViewport() [Internal]
// - UpdatePlatformWindows()
// - RenderPlatformWindowsDefault()
// - FindPlatformMonitorForPos() [Internal]
// - FindPlatformMonitorForRect() [Internal]
// - UpdateViewportPlatformMonitor() [Internal]
// - DestroyPlatformWindow() [Internal]
// - DestroyPlatformWindows()
//-----------------------------------------------------------------------------

GetMainViewport :: proc() -> ^ImGuiViewport
{
	g : ^ImGuiContext = GImGui^
	return g.Viewports[0]
}

// this is a helper for backends.
// FIXME: This leaks access to viewports not listed in PlatformIO.Viewports[]. Problematic? (#4236)
FindViewportByID :: proc(id : ImGuiID) -> ^ImGuiViewport
{
	g : ^ImGuiContext = GImGui^
	for viewport in g.Viewports { if viewport.ID == id { return viewport } }

	return nil
}

// this is a helper for backends. the type platform_handle is decided by the backend (e.g. HWND, MyWindow*, GLFWwindow* etc.)
FindViewportByPlatformHandle :: proc(platform_handle : rawptr) -> ^ImGuiViewport
{
	g : ^ImGuiContext = GImGui^
	for viewport in g.Viewports { if viewport.PlatformHandle == platform_handle { return viewport } }

	return nil
}

SetCurrentViewport :: proc(current_window : ^ImGuiWindow, viewport : ^ImGuiViewportP)
{
	g : ^ImGuiContext = GImGui^
	_ = current_window

	if viewport { viewport.LastFrameActive = g.FrameCount }
	if g.CurrentViewport == viewport { return }
	g.CurrentDpiScale = viewport ? viewport.DpiScale : 1.0
	g.CurrentViewport = viewport
	IM_ASSERT(g.CurrentDpiScale > 0.0 && g.CurrentDpiScale < 99.0); // Typical correct values would be between 1.0f and 4.0f
	//IMGUI_DEBUG_LOG_VIEWPORT("[viewport] SetCurrentViewport changed '%s' 0x%08X\n", current_window ? current_window->Name : NULL, viewport ? viewport->ID : 0);

	// Notify platform layer of viewport changes
	// FIXME-DPI: This is only currently used for experimenting with handling of multiple DPI
	if g.CurrentViewport && g.PlatformIO.Platform_OnChangedViewport { Platform_OnChangedViewport(&g.PlatformIO, g.CurrentViewport) }
}

SetWindowViewport :: proc(window : ^ImGuiWindow, viewport : ^ImGuiViewportP)
{
	// Abandon viewport
	if window.ViewportOwned && window.Viewport.Window == window { window.Viewport.Size = ImVec2(0.0, 0.0) }

	window.Viewport = viewport
	window.ViewportId = viewport.ID
	window.ViewportOwned = (viewport.Window == window)
}

GetWindowAlwaysWantOwnViewport :: proc(window : ^ImGuiWindow) -> bool
{
	// Tooltips and menus are not automatically forced into their own viewport when the NoMerge flag is set, however the multiplication of viewports makes them more likely to protrude and create their own.
	g : ^ImGuiContext = GImGui^
	if g.IO.ConfigViewportsNoAutoMerge || (window.WindowClass.ViewportFlagsOverrideSet & ImGuiViewportFlags_.ImGuiViewportFlags_NoAutoMerge) { if g.ConfigFlagsCurrFrame & ImGuiConfigFlags_.ImGuiConfigFlags_ViewportsEnable { if !window.DockIsActive { if (window.Flags & (ImGuiWindowFlags_.ImGuiWindowFlags_ChildWindow | ImGuiWindowFlags_.ImGuiWindowFlags_ChildMenu | ImGuiWindowFlags_.ImGuiWindowFlags_Tooltip)) == 0 { if (window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_Popup) == 0 || (window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_Modal) != 0 { return true } } } } }
	return false
}

UpdateTryMergeWindowIntoHostViewport :: proc(window : ^ImGuiWindow, viewport : ^ImGuiViewportP) -> bool
{
	g : ^ImGuiContext = GImGui^
	if window.Viewport == viewport { return false }
	if (viewport.Flags & ImGuiViewportFlags_.ImGuiViewportFlags_CanHostOtherWindows) == 0 { return false }
	if (viewport.Flags & ImGuiViewportFlags_.ImGuiViewportFlags_IsMinimized) != 0 { return false }
	if !Contains(&GetMainRect(viewport), Rect(window)) { return false }
	if GetWindowAlwaysWantOwnViewport(window) { return false }

	// FIXME: Can't use g.WindowsFocusOrder[] for root windows only as we care about Z order. If we maintained a DisplayOrder along with FocusOrder we could..
	for window_behind in g.Windows {
		if window_behind == window { break }
		if window_behind.WasActive && window_behind.ViewportOwned && !(window_behind.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_ChildWindow) { if Overlaps(&GetMainRect(window_behind.Viewport), Rect(window)) { return false } }
	}

	// Move to the existing viewport, Move child/hosted windows as well (FIXME-OPT: iterate child)
	old_viewport : ^ImGuiViewportP = window.Viewport
	if window.ViewportOwned { for n : i32 = 0; n < g.Windows.Size; post_incr(&n) { if g.Windows[n].Viewport == old_viewport { SetWindowViewport(g.Windows[n], viewport) } } }
	SetWindowViewport(window, viewport)
	BringWindowToDisplayFront(window)

	return true
}

// FIXME: handle 0 to N host viewports
UpdateTryMergeWindowIntoHostViewports :: proc(window : ^ImGuiWindow) -> bool
{
	g : ^ImGuiContext = GImGui^
	return UpdateTryMergeWindowIntoHostViewport(window, g.Viewports[0])
}

// Viewports
// Translate Dear ImGui windows when a Host Viewport has been moved
// (This additionally keeps windows at the same place when ImGuiConfigFlags_ViewportsEnable is toggled!)
TranslateWindowsInViewport :: proc(viewport : ^ImGuiViewportP, old_pos : ^ImVec2, new_pos : ^ImVec2, old_size : ^ImVec2, new_size : ^ImVec2)
{
	g : ^ImGuiContext = GImGui^
	IM_ASSERT(viewport.Window == nil && (viewport.Flags & ImGuiViewportFlags_.ImGuiViewportFlags_CanHostOtherWindows))

	// 1) We test if ImGuiConfigFlags_ViewportsEnable was just toggled, which allows us to conveniently
	// translate imgui windows from OS-window-local to absolute coordinates or vice-versa.
	// 2) If it's not going to fit into the new size, keep it at same absolute position.
	// One problem with this is that most Win32 applications doesn't update their render while dragging,
	// and so the window will appear to teleport when releasing the mouse.
	translate_all_windows : bool = (g.ConfigFlagsCurrFrame & ImGuiConfigFlags_.ImGuiConfigFlags_ViewportsEnable) != (g.ConfigFlagsLastFrame & ImGuiConfigFlags_.ImGuiConfigFlags_ViewportsEnable)
	test_still_fit_rect : ImRect; init(&test_still_fit_rect, old_pos, old_pos + viewport.Size)
	delta_pos : ImVec2 = new_pos - old_pos
	for window in g.Windows { if translate_all_windows || (window.Viewport == viewport && (old_size == new_size || Contains(&test_still_fit_rect, Rect(window)))) { TranslateWindow(window, delta_pos) } }
}

// Scale all windows (position, size). Use when e.g. changing DPI. (This is a lossy operation!)
ScaleWindowsInViewport :: proc(viewport : ^ImGuiViewportP, scale : f32)
{
	g : ^ImGuiContext = GImGui^
	if viewport.Window {
		ScaleWindow(viewport.Window, scale)
	}
	else {
		for window in g.Windows { if window.Viewport == viewport { ScaleWindow(window, scale) } }
	}
}

// If the backend doesn't set MouseLastHoveredViewport or doesn't honor ImGuiViewportFlags_NoInputs, we do a search ourselves.
// A) It won't take account of the possibility that non-imgui windows may be in-between our dragged window and our target window.
// B) It requires Platform_GetWindowFocus to be implemented by backend.
FindHoveredViewportFromPlatformWindowStack :: proc(mouse_platform_pos : ^ImVec2) -> ^ImGuiViewportP
{
	g : ^ImGuiContext = GImGui^
	best_candidate : ^ImGuiViewportP = nil
	for viewport in g.Viewports { if !(viewport.Flags & (ImGuiViewportFlags_.ImGuiViewportFlags_NoInputs | ImGuiViewportFlags_.ImGuiViewportFlags_IsMinimized)) && Contains(&GetMainRect(viewport), mouse_platform_pos) { if best_candidate == nil || best_candidate.LastFocusedStampCount < viewport.LastFocusedStampCount { best_candidate = viewport } } }

	return best_candidate
}

// Update viewports and monitor infos
// Note that this is running even if 'ImGuiConfigFlags_ViewportsEnable' is not set, in order to clear unused viewports (if any) and update monitor info.
UpdateViewportsNewFrame :: proc()
{
	g : ^ImGuiContext = GImGui^
	IM_ASSERT(g.PlatformIO.Viewports.Size <= g.Viewports.Size)

	// Update Minimized status (we need it first in order to decide if we'll apply Pos/Size of the main viewport)
	// Update Focused status
	viewports_enabled : bool = (g.ConfigFlagsCurrFrame & ImGuiConfigFlags_.ImGuiConfigFlags_ViewportsEnable) != 0
	if viewports_enabled {
		focused_viewport : ^ImGuiViewportP = nil
		for viewport in g.Viewports {
			platform_funcs_available : bool = viewport.PlatformWindowCreated
			if g.PlatformIO.Platform_GetWindowMinimized && platform_funcs_available {
				is_minimized : bool = Platform_GetWindowMinimized(&g.PlatformIO, viewport)
				if is_minimized { viewport.Flags |= ImGuiViewportFlags_.ImGuiViewportFlags_IsMinimized }
				else { viewport.Flags &= !ImGuiViewportFlags_.ImGuiViewportFlags_IsMinimized }
			}

			// Update our implicit z-order knowledge of platform windows, which is used when the backend cannot provide io.MouseHoveredViewport.
			// When setting Platform_GetWindowFocus, it is expected that the platform backend can handle calls without crashing if it doesn't have data stored.
			if g.PlatformIO.Platform_GetWindowFocus && platform_funcs_available {
				is_focused : bool = Platform_GetWindowFocus(&g.PlatformIO, viewport)
				if is_focused { viewport.Flags |= ImGuiViewportFlags_.ImGuiViewportFlags_IsFocused }
				else { viewport.Flags &= !ImGuiViewportFlags_.ImGuiViewportFlags_IsFocused }
				if is_focused { focused_viewport = viewport }
			}
		}

		// Focused viewport has changed?
		if focused_viewport && g.PlatformLastFocusedViewportId != focused_viewport.ID {
			IMGUI_DEBUG_LOG_VIEWPORT("[viewport] Focused viewport changed %08X -> %08X, attempting to apply our focus.\n", g.PlatformLastFocusedViewportId, focused_viewport.ID)
			prev_focused_viewport : ^ImGuiViewport = FindViewportByID(g.PlatformLastFocusedViewportId)
			prev_focused_has_been_destroyed : bool = (prev_focused_viewport == nil) || (prev_focused_viewport.PlatformWindowCreated == false)

			// Store a tag so we can infer z-order easily from all our windows
			// We compare PlatformLastFocusedViewportId so newly created viewports with _NoFocusOnAppearing flag
			// will keep the front most stamp instead of losing it back to their parent viewport.
			if focused_viewport.LastFocusedStampCount != g.ViewportFocusedStampCount { focused_viewport.LastFocusedStampCount = pre_incr(&g.ViewportFocusedStampCount) }
			g.PlatformLastFocusedViewportId = focused_viewport.ID

			// Focus associated dear imgui window
			// - if focus didn't happen with a click within imgui boundaries, e.g. Clicking platform title bar. (#6299)
			// - if focus didn't happen because we destroyed another window (#6462)
			// FIXME: perhaps 'FocusTopMostWindowUnderOne()' can handle the 'focused_window->Window != NULL' case as well.
			apply_imgui_focus_on_focused_viewport : bool = !IsAnyMouseDown() && !prev_focused_has_been_destroyed
			if apply_imgui_focus_on_focused_viewport {
				focused_viewport.LastFocusedHadNavWindow |= (g.NavWindow != nil) && (g.NavWindow.Viewport == focused_viewport); // Update so a window changing viewport won't lose focus.
				focus_request_flags : ImGuiFocusRequestFlags = ImGuiFocusRequestFlags_.ImGuiFocusRequestFlags_UnlessBelowModal | ImGuiFocusRequestFlags_.ImGuiFocusRequestFlags_RestoreFocusedChild
				if focused_viewport.Window != nil { FocusWindow(focused_viewport.Window, focus_request_flags) }
				else if focused_viewport.LastFocusedHadNavWindow {
					// Focus top most in viewport
					FocusTopMostWindowUnderOne(nil, nil, focused_viewport, focus_request_flags)
				}
				else {
					// No window had focus last time viewport was focused
					FocusWindow(nil, focus_request_flags)
				}
			}
		}
		if focused_viewport { focused_viewport.LastFocusedHadNavWindow = (g.NavWindow != nil) && (g.NavWindow.Viewport == focused_viewport) }
	}

	// Create/update main viewport with current platform position.
	// FIXME-VIEWPORT: Size is driven by backend/user code for backward-compatibility but we should aim to make this more consistent.
	main_viewport : ^ImGuiViewportP = g.Viewports[0]
	IM_ASSERT(main_viewport.ID == IMGUI_VIEWPORT_DEFAULT_ID)
	IM_ASSERT(main_viewport.Window == nil)
	main_viewport_pos : ImVec2 = viewports_enabled ? Platform_GetWindowPos(&g.PlatformIO, main_viewport) : ImVec2(0.0, 0.0)
	main_viewport_size : ImVec2 = g.IO.DisplaySize
	if viewports_enabled && (main_viewport.Flags & ImGuiViewportFlags_.ImGuiViewportFlags_IsMinimized) {
		main_viewport_pos = main_viewport.Pos; // Preserve last pos/size when minimized (FIXME: We don't do the same for Size outside of the viewport path)
		main_viewport_size = main_viewport.Size
	}
	AddUpdateViewport(nil, IMGUI_VIEWPORT_DEFAULT_ID, main_viewport_pos, main_viewport_size, ImGuiViewportFlags_.ImGuiViewportFlags_OwnedByApp | ImGuiViewportFlags_.ImGuiViewportFlags_CanHostOtherWindows)

	g.CurrentDpiScale = 0.0
	g.CurrentViewport = nil
	g.MouseViewport = nil
	for n : i32 = 0; n < g.Viewports.Size; post_incr(&n) {
		viewport : ^ImGuiViewportP = g.Viewports[n]
		viewport.Idx = n

		// Erase unused viewports
		if n > 0 && viewport.LastFrameActive < g.FrameCount - 2 {
			DestroyViewport(viewport)
			post_decr(&n)
			continue
		}

		platform_funcs_available : bool = viewport.PlatformWindowCreated
		if viewports_enabled {
			// Update Position and Size (from Platform Window to ImGui) if requested.
			// We do it early in the frame instead of waiting for UpdatePlatformWindows() to avoid a frame of lag when moving/resizing using OS facilities.
			if !(viewport.Flags & ImGuiViewportFlags_.ImGuiViewportFlags_IsMinimized) && platform_funcs_available {
				// Viewport->WorkPos and WorkSize will be updated below
				if viewport.PlatformRequestMove { viewport.LastPlatformPos = Platform_GetWindowPos(&g.PlatformIO, viewport); viewport.Pos = viewport.LastPlatformPos }
				if viewport.PlatformRequestResize { viewport.LastPlatformSize = Platform_GetWindowSize(&g.PlatformIO, viewport); viewport.Size = viewport.LastPlatformSize }
			}
		}

		// Update/copy monitor info
		UpdateViewportPlatformMonitor(viewport)

		// Lock down space taken by menu bars and status bars + query initial insets from backend
		// Setup initial value for functions like BeginMainMenuBar(), DockSpaceOverViewport() etc.
		viewport.WorkInsetMin = viewport.BuildWorkInsetMin
		viewport.WorkInsetMax = viewport.BuildWorkInsetMax
		viewport.BuildWorkInsetMax = ImVec2(0.0, 0.0); viewport.BuildWorkInsetMin = viewport.BuildWorkInsetMax
		if g.PlatformIO.Platform_GetWindowWorkAreaInsets != nil && platform_funcs_available {
			insets : ImVec4 = Platform_GetWindowWorkAreaInsets(&g.PlatformIO, viewport)
			IM_ASSERT(insets.x >= 0.0 && insets.y >= 0.0 && insets.z >= 0.0 && insets.w >= 0.0)
			viewport.BuildWorkInsetMin = ImVec2(insets.x, insets.y)
			viewport.BuildWorkInsetMax = ImVec2(insets.z, insets.w)
		}
		UpdateWorkRect(viewport)

		// Reset alpha every frame. Users of transparency (docking) needs to request a lower alpha back.
		viewport.Alpha = 1.0

		// Translate Dear ImGui windows when a Host Viewport has been moved
		// (This additionally keeps windows at the same place when ImGuiConfigFlags_ViewportsEnable is toggled!)
		viewport_delta_pos : ImVec2 = viewport.Pos - viewport.LastPos
		if (viewport.Flags & ImGuiViewportFlags_.ImGuiViewportFlags_CanHostOtherWindows) && (viewport_delta_pos.x != 0.0 || viewport_delta_pos.y != 0.0) { TranslateWindowsInViewport(viewport, viewport.LastPos, viewport.Pos, viewport.LastSize, viewport.Size) }

		// Update DPI scale
		new_dpi_scale : f32
		if g.PlatformIO.Platform_GetWindowDpiScale && platform_funcs_available { new_dpi_scale = Platform_GetWindowDpiScale(&g.PlatformIO, viewport) }
		else if viewport.PlatformMonitor != -1 { new_dpi_scale = g.PlatformIO.Monitors[viewport.PlatformMonitor].DpiScale }
		else { new_dpi_scale = (viewport.DpiScale != 0.0) ? viewport.DpiScale : 1.0 }
		IM_ASSERT(new_dpi_scale > 0.0 && new_dpi_scale < 99.0); // Typical correct values would be between 1.0f and 4.0f
		if viewport.DpiScale != 0.0 && new_dpi_scale != viewport.DpiScale {
			scale_factor : f32 = new_dpi_scale / viewport.DpiScale
			if g.IO.ConfigFlags & ImGuiConfigFlags_.ImGuiConfigFlags_DpiEnableScaleViewports { ScaleWindowsInViewport(viewport, scale_factor) }
			//if (viewport == GetMainViewport())
			//    g.PlatformInterface.SetWindowSize(viewport, viewport->Size * scale_factor);

			// Scale our window moving pivot so that the window will rescale roughly around the mouse position.
			// FIXME-VIEWPORT: This currently creates a resizing feedback loop when a window is straddling a DPI transition border.
			// (Minor: since our sizes do not perfectly linearly scale, deferring the click offset scale until we know the actual window scale ratio may get us slightly more precise mouse positioning.)
			//if (g.MovingWindow != NULL && g.MovingWindow->Viewport == viewport)
			//    g.ActiveIdClickOffset = ImTrunc(g.ActiveIdClickOffset * scale_factor);
		}
		viewport.DpiScale = new_dpi_scale
	}

	// Update fallback monitor
	g.PlatformMonitorsFullWorkRect = ImRect(+FLT_MAX, +FLT_MAX, -FLT_MAX, -FLT_MAX)
	if g.PlatformIO.Monitors.Size == 0 {
		monitor : ^ImGuiPlatformMonitor = &g.FallbackMonitor
		monitor.MainPos = main_viewport.Pos
		monitor.MainSize = main_viewport.Size
		monitor.WorkPos = main_viewport.WorkPos
		monitor.WorkSize = main_viewport.WorkSize
		monitor.DpiScale = main_viewport.DpiScale
		Add(&g.PlatformMonitorsFullWorkRect, monitor.WorkPos)
		Add(&g.PlatformMonitorsFullWorkRect, monitor.WorkPos + monitor.WorkSize)
	}
	else {
		g.FallbackMonitor = g.PlatformIO.Monitors[0]
	}
	for monitor in g.PlatformIO.Monitors {
		Add(&g.PlatformMonitorsFullWorkRect, monitor.WorkPos)
		Add(&g.PlatformMonitorsFullWorkRect, monitor.WorkPos + monitor.WorkSize)
	}

	if !viewports_enabled {
		g.MouseViewport = main_viewport
		return
	}

	// Mouse handling: decide on the actual mouse viewport for this frame between the active/focused viewport and the hovered viewport.
	// Note that 'viewport_hovered' should skip over any viewport that has the ImGuiViewportFlags_NoInputs flags set.
	viewport_hovered : ^ImGuiViewportP = nil
	if g.IO.BackendFlags & ImGuiBackendFlags_.ImGuiBackendFlags_HasMouseHoveredViewport {
		viewport_hovered = g.IO.MouseHoveredViewport ? cast(^ImGuiViewportP) FindViewportByID(g.IO.MouseHoveredViewport) : nil
		if viewport_hovered && (viewport_hovered.Flags & ImGuiViewportFlags_.ImGuiViewportFlags_NoInputs) {
			// Backend failed to handle _NoInputs viewport: revert to our fallback.
			viewport_hovered = FindHoveredViewportFromPlatformWindowStack(g.IO.MousePos)
		}
	}
	else {
		// If the backend doesn't know how to honor ImGuiViewportFlags_NoInputs, we do a search ourselves. Note that this search:
		// A) won't take account of the possibility that non-imgui windows may be in-between our dragged window and our target window.
		// B) won't take account of how the backend apply parent<>child relationship to secondary viewports, which affects their Z order.
		// C) uses LastFrameAsRefViewport as a flawed replacement for the last time a window was focused (we could/should fix that by introducing Focus functions in PlatformIO)
		viewport_hovered = FindHoveredViewportFromPlatformWindowStack(g.IO.MousePos)
	}
	if viewport_hovered != nil { g.MouseLastHoveredViewport = viewport_hovered }
	else if g.MouseLastHoveredViewport == nil { g.MouseLastHoveredViewport = g.Viewports[0] }

	// Update mouse reference viewport
	// (when moving a window we aim at its viewport, but this will be overwritten below if we go in drag and drop mode)
	// (MovingViewport->Viewport will be NULL in the rare situation where the window disappared while moving, set UpdateMouseMovingWindowNewFrame() for details)
	if g.MovingWindow && g.MovingWindow.Viewport { g.MouseViewport = g.MovingWindow.Viewport }
	else { g.MouseViewport = g.MouseLastHoveredViewport }

	// When dragging something, always refer to the last hovered viewport.
	// - when releasing a moving window we will revert to aiming behind (at viewport_hovered)
	// - when we are between viewports, our dragged preview will tend to show in the last viewport _even_ if we don't have tooltips in their viewports (when lacking monitor info)
	// - consider the case of holding on a menu item to browse child menus: even thou a mouse button is held, there's no active id because menu items only react on mouse release.
	// FIXME-VIEWPORT: This is essentially broken, when ImGuiBackendFlags_HasMouseHoveredViewport is set we want to trust when viewport_hovered==NULL and use that.
	is_mouse_dragging_with_an_expected_destination : bool = g.DragDropActive
	if is_mouse_dragging_with_an_expected_destination && viewport_hovered == nil { viewport_hovered = g.MouseLastHoveredViewport }
	if is_mouse_dragging_with_an_expected_destination || g.ActiveId == 0 || !IsAnyMouseDown() { if viewport_hovered != nil && viewport_hovered != g.MouseViewport && !(viewport_hovered.Flags & ImGuiViewportFlags_.ImGuiViewportFlags_NoInputs) { g.MouseViewport = viewport_hovered } }

	IM_ASSERT(g.MouseViewport != nil)
}

// Update user-facing viewport list (g.Viewports -> g.PlatformIO.Viewports after filtering out some)
UpdateViewportsEndFrame :: proc()
{
	g : ^ImGuiContext = GImGui^
	resize(&g.PlatformIO.Viewports, 0)
	for i : i32 = 0; i < g.Viewports.Size; post_incr(&i) {
		viewport : ^ImGuiViewportP = g.Viewports[i]
		viewport.LastPos = viewport.Pos
		viewport.LastSize = viewport.Size
		if viewport.LastFrameActive < g.FrameCount || viewport.Size.x <= 0.0 || viewport.Size.y <= 0.0 { if i > 0 {
	// Always include main viewport in the listcontinue
} }
		if viewport.Window && !IsWindowActiveAndVisible(viewport.Window) { continue }
		if i > 0 { IM_ASSERT(viewport.Window != nil) }
		push_back(&g.PlatformIO.Viewports, viewport)
	}

	ClearRequestFlags(g.Viewports[0]); // Clear main viewport flags because UpdatePlatformWindows() won't do it and may not even be called
}

// Using an arbitrary constant instead of e.g. ImHashStr("ViewportDefault", 0); so it's easier to spot in the debugger. The exact value doesn't matter.
// FIXME: We should ideally refactor the system to call this every frame (we currently don't)
AddUpdateViewport :: proc(window : ^ImGuiWindow, id : ImGuiID, pos : ^ImVec2, size : ^ImVec2, flags : ImGuiViewportFlags) -> ^ImGuiViewportP
{
	g : ^ImGuiContext = GImGui^
	IM_ASSERT(id != 0)

	flags |= ImGuiViewportFlags_.ImGuiViewportFlags_IsPlatformWindow
	if window != nil {
		if g.MovingWindow && g.MovingWindow.RootWindowDockTree == window { flags |= ImGuiViewportFlags_.ImGuiViewportFlags_NoInputs | ImGuiViewportFlags_.ImGuiViewportFlags_NoFocusOnAppearing }
		if (window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoMouseInputs) && (window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoNavInputs) { flags |= ImGuiViewportFlags_.ImGuiViewportFlags_NoInputs }
		if window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoFocusOnAppearing { flags |= ImGuiViewportFlags_.ImGuiViewportFlags_NoFocusOnAppearing }
	}

	viewport : ^ImGuiViewportP = cast(^ImGuiViewportP) FindViewportByID(id)
	if viewport {
		// Always update for main viewport as we are already pulling correct platform pos/size (see #4900)
		if !viewport.PlatformRequestMove || viewport.ID == IMGUI_VIEWPORT_DEFAULT_ID { viewport.Pos = pos }
		if !viewport.PlatformRequestResize || viewport.ID == IMGUI_VIEWPORT_DEFAULT_ID { viewport.Size = size }
		viewport.Flags = flags | (viewport.Flags & (ImGuiViewportFlags_.ImGuiViewportFlags_IsMinimized | ImGuiViewportFlags_.ImGuiViewportFlags_IsFocused)); // Preserve existing flags
	}
	else {
		// New viewport
		viewport = IM_NEW(this.ImGuiViewportP)()
		viewport.ID = id
		viewport.Idx = g.Viewports.Size
		viewport.LastPos = pos; viewport.Pos = viewport.LastPos
		viewport.LastSize = size; viewport.Size = viewport.LastSize
		viewport.Flags = flags
		UpdateViewportPlatformMonitor(viewport)
		push_back(&g.Viewports, viewport)
		post_incr(&g.ViewportCreatedCount)
		IMGUI_DEBUG_LOG_VIEWPORT("[viewport] Add Viewport %08X '%s'\n", id, window ? window.Name : "<NULL>")

		// We normally setup for all viewports in NewFrame() but here need to handle the mid-frame creation of a new viewport.
		// We need to extend the fullscreen clip rect so the OverlayDrawList clip is correct for that the first frame
		g.DrawListSharedData.ClipRectFullscreen.x = ImMin(g.DrawListSharedData.ClipRectFullscreen.x, viewport.Pos.x)
		g.DrawListSharedData.ClipRectFullscreen.y = ImMin(g.DrawListSharedData.ClipRectFullscreen.y, viewport.Pos.y)
		g.DrawListSharedData.ClipRectFullscreen.z = ImMax(g.DrawListSharedData.ClipRectFullscreen.z, viewport.Pos.x + viewport.Size.x)
		g.DrawListSharedData.ClipRectFullscreen.w = ImMax(g.DrawListSharedData.ClipRectFullscreen.w, viewport.Pos.y + viewport.Size.y)

		// Store initial DpiScale before the OS platform window creation, based on expected monitor data.
		// This is so we can select an appropriate font size on the first frame of our window lifetime
		if viewport.PlatformMonitor != -1 { viewport.DpiScale = g.PlatformIO.Monitors[viewport.PlatformMonitor].DpiScale }
	}

	viewport.Window = window
	viewport.LastFrameActive = g.FrameCount
	UpdateWorkRect(viewport)
	IM_ASSERT(window == nil || viewport.ID == window.ID)

	if window != nil { window.ViewportOwned = true }

	return viewport
}

DestroyViewport :: proc(viewport : ^ImGuiViewportP)
{
	// Clear references to this viewport in windows (window->ViewportId becomes the master data)
	g : ^ImGuiContext = GImGui^
	for window in g.Windows {
		if window.Viewport != viewport { continue }
		window.Viewport = nil
		window.ViewportOwned = false
	}

	if viewport == g.MouseLastHoveredViewport { g.MouseLastHoveredViewport = nil }

	// Destroy
	IMGUI_DEBUG_LOG_VIEWPORT("[viewport] Delete Viewport %08X '%s'\n", viewport.ID, viewport.Window ? viewport.Window.Name : "n/a")
	DestroyPlatformWindow(viewport); // In most circumstances the platform window will already be destroyed here.
	IM_ASSERT(contains(&g.PlatformIO.Viewports, viewport) == false)
	IM_ASSERT(g.Viewports[viewport.Idx] == viewport)
	erase(&g.Viewports, g.Viewports.Data + viewport.Idx)
	IM_DELETE(viewport)
}

// FIXME-VIEWPORT: This is all super messy and ought to be clarified or rewritten.
WindowSelectViewport :: proc(window : ^ImGuiWindow)
{
	g : ^ImGuiContext = GImGui^
	flags : ImGuiWindowFlags = window.Flags
	window.ViewportAllowPlatformMonitorExtend = -1

	// Restore main viewport if multi-viewport is not supported by the backend
	main_viewport : ^ImGuiViewportP = cast(^ImGuiViewportP) cast(rawptr) GetMainViewport()
	if !(g.ConfigFlagsCurrFrame & ImGuiConfigFlags_.ImGuiConfigFlags_ViewportsEnable) {
		SetWindowViewport(window, main_viewport)
		return
	}
	window.ViewportOwned = false

	// Appearing popups reset their viewport so they can inherit again
	if (flags & (ImGuiWindowFlags_.ImGuiWindowFlags_Popup | ImGuiWindowFlags_.ImGuiWindowFlags_Tooltip)) && window.Appearing {
		window.Viewport = nil
		window.ViewportId = 0
	}

	if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_.ImGuiNextWindowDataFlags_HasViewport) == 0 {
		// By default inherit from parent window
		if window.Viewport == nil && window.ParentWindow && (!window.ParentWindow.IsFallbackWindow || window.ParentWindow.WasActive) { window.Viewport = window.ParentWindow.Viewport }

		// Attempt to restore saved viewport id (= window that hasn't been activated yet), try to restore the viewport based on saved 'window->ViewportPos' restored from .ini file
		if window.Viewport == nil && window.ViewportId != 0 {
			window.Viewport = cast(^ImGuiViewportP) FindViewportByID(window.ViewportId)
			if window.Viewport == nil && window.ViewportPos.x != FLT_MAX && window.ViewportPos.y != FLT_MAX { window.Viewport = AddUpdateViewport(window, window.ID, window.ViewportPos, window.Size, ImGuiViewportFlags_.ImGuiViewportFlags_None) }
		}
	}

	lock_viewport : bool = false
	if g.NextWindowData.Flags & ImGuiNextWindowDataFlags_.ImGuiNextWindowDataFlags_HasViewport {
		// Code explicitly request a viewport
		window.Viewport = cast(^ImGuiViewportP) FindViewportByID(g.NextWindowData.ViewportId)
		window.ViewportId = g.NextWindowData.ViewportId; // Store ID even if Viewport isn't resolved yet.
		if window.Viewport && (window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_DockNodeHost) != 0 && window.Viewport.Window != nil {
			window.Viewport.Window = window
			window.ViewportId = window.ID; window.Viewport.ID = window.ViewportId; // Overwrite ID (always owned by node)
		}
		lock_viewport = true
	}
	else if (flags & ImGuiWindowFlags_.ImGuiWindowFlags_ChildWindow) || (flags & ImGuiWindowFlags_.ImGuiWindowFlags_ChildMenu) {
		// Always inherit viewport from parent window
		if window.DockNode && window.DockNode.HostWindow { IM_ASSERT(window.DockNode.HostWindow.Viewport == window.ParentWindow.Viewport) }
		window.Viewport = window.ParentWindow.Viewport
	}
	else if window.DockNode && window.DockNode.HostWindow {
		// This covers the "always inherit viewport from parent window" case for when a window reattach to a node that was just created mid-frame
		window.Viewport = window.DockNode.HostWindow.Viewport
	}
	else if ImGuiWindowFlags_Tooltip : ^flags; ImGuiWindowFlags_Tooltip {
		window.Viewport = g.MouseViewport
	}
	else if GetWindowAlwaysWantOwnViewport(window) {
		window.Viewport = AddUpdateViewport(window, window.ID, window.Pos, window.Size, ImGuiViewportFlags_.ImGuiViewportFlags_None)
	}
	else if g.MovingWindow && g.MovingWindow.RootWindowDockTree == window && IsMousePosValid() {
		if window.Viewport != nil && window.Viewport.Window == window { window.Viewport = AddUpdateViewport(window, window.ID, window.Pos, window.Size, ImGuiViewportFlags_.ImGuiViewportFlags_None) }
	}
	else {
		// Merge into host viewport?
		// We cannot test window->ViewportOwned as it set lower in the function.
		// Testing (g.ActiveId == 0 || g.ActiveIdAllowOverlap) to avoid merging during a short-term widget interaction. Main intent was to avoid during resize (see #4212)
		try_to_merge_into_host_viewport : bool = (window.Viewport && window == window.Viewport.Window && (g.ActiveId == 0 || g.ActiveIdAllowOverlap))
		if try_to_merge_into_host_viewport { UpdateTryMergeWindowIntoHostViewports(window) }
	}

	// Fallback: merge in default viewport if z-order matches, otherwise create a new viewport
	if window.Viewport == nil { if !UpdateTryMergeWindowIntoHostViewport(window, main_viewport) { window.Viewport = AddUpdateViewport(window, window.ID, window.Pos, window.Size, ImGuiViewportFlags_.ImGuiViewportFlags_None) } }

	// Mark window as allowed to protrude outside of its viewport and into the current monitor
	if !lock_viewport {
		if flags & (ImGuiWindowFlags_.ImGuiWindowFlags_Tooltip | ImGuiWindowFlags_.ImGuiWindowFlags_Popup) {
			// We need to take account of the possibility that mouse may become invalid.
			// Popups/Tooltip always set ViewportAllowPlatformMonitorExtend so GetWindowAllowedExtentRect() will return full monitor bounds.
			mouse_ref : ImVec2 = (flags & ImGuiWindowFlags_.ImGuiWindowFlags_Tooltip) ? g.IO.MousePos : back(&g.BeginPopupStack).OpenMousePos
			use_mouse_ref : bool = (!g.NavCursorVisible || !g.NavHighlightItemUnderNav || !g.NavWindow)
			mouse_valid : bool = IsMousePosValid(&mouse_ref)
			if (window.Appearing || (flags & (ImGuiWindowFlags_.ImGuiWindowFlags_Tooltip | ImGuiWindowFlags_.ImGuiWindowFlags_ChildMenu))) && (!use_mouse_ref || mouse_valid) { window.ViewportAllowPlatformMonitorExtend = FindPlatformMonitorForPos((use_mouse_ref && mouse_valid) ? mouse_ref : NavCalcPreferredRefPos()) }
			else { window.ViewportAllowPlatformMonitorExtend = window.Viewport.PlatformMonitor }
		}
		else if window.Viewport && window != window.Viewport.Window && window.Viewport.Window && !(flags & ImGuiWindowFlags_.ImGuiWindowFlags_ChildWindow) && window.DockNode == nil {
			// When called from Begin() we don't have access to a proper version of the Hidden flag yet, so we replicate this code.
			will_be_visible : bool = (window.DockIsActive && !window.DockTabIsVisible) ? false : true
			if (window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_DockNodeHost) && window.Viewport.LastFrameActive < g.FrameCount && will_be_visible {
				// Steal/transfer ownership
				IMGUI_DEBUG_LOG_VIEWPORT("[viewport] Window '%s' steal Viewport %08X from Window '%s'\n", window.Name, window.Viewport.ID, window.Viewport.Window.Name)
				window.Viewport.Window = window
				window.Viewport.ID = window.ID
				window.Viewport.LastNameHash = 0
			}
			else if !UpdateTryMergeWindowIntoHostViewports(window) {
				// Merge?
				// New viewport
				window.Viewport = AddUpdateViewport(window, window.ID, window.Pos, window.Size, ImGuiViewportFlags_.ImGuiViewportFlags_NoFocusOnAppearing)
			}
		}
		else if window.ViewportAllowPlatformMonitorExtend < 0 && (flags & ImGuiWindowFlags_.ImGuiWindowFlags_ChildWindow) == 0 {
			// Regular (non-child, non-popup) windows by default are also allowed to protrude
			// Child windows are kept contained within their parent.
			window.ViewportAllowPlatformMonitorExtend = window.Viewport.PlatformMonitor
		}
	}

	// Update flags
	window.ViewportOwned = (window == window.Viewport.Window)
	window.ViewportId = window.Viewport.ID

	// If the OS window has a title bar, hide our imgui title bar
	//if (window->ViewportOwned && !(window->Viewport->Flags & ImGuiViewportFlags_NoDecoration))
	//    window->Flags |= ImGuiWindowFlags_NoTitleBar;
}

WindowSyncOwnedViewport :: proc(window : ^ImGuiWindow, parent_window_in_stack : ^ImGuiWindow)
{
	g : ^ImGuiContext = GImGui^

	viewport_rect_changed : bool = false

	// Synchronize window --> viewport in most situations
	// Synchronize viewport -> window in case the platform window has been moved or resized from the OS/WM
	if window.Viewport.PlatformRequestMove {
		window.Pos = window.Viewport.Pos
		MarkIniSettingsDirty(window)
	}
	else if memcmp(&window.Viewport.Pos, &window.Pos, size_of(window.Pos)) != 0 {
		viewport_rect_changed = true
		window.Viewport.Pos = window.Pos
	}

	if window.Viewport.PlatformRequestResize {
		window.SizeFull = window.Viewport.Size; window.Size = window.SizeFull
		MarkIniSettingsDirty(window)
	}
	else if memcmp(&window.Viewport.Size, &window.Size, size_of(window.Size)) != 0 {
		viewport_rect_changed = true
		window.Viewport.Size = window.Size
	}
	UpdateWorkRect(window.Viewport)

	// The viewport may have changed monitor since the global update in UpdateViewportsNewFrame()
	// Either a SetNextWindowPos() call in the current frame or a SetWindowPos() call in the previous frame may have this effect.
	if viewport_rect_changed { UpdateViewportPlatformMonitor(window.Viewport) }

	// Update common viewport flags
	viewport_flags_to_clear : ImGuiViewportFlags = ImGuiViewportFlags_.ImGuiViewportFlags_TopMost | ImGuiViewportFlags_.ImGuiViewportFlags_NoTaskBarIcon | ImGuiViewportFlags_.ImGuiViewportFlags_NoDecoration | ImGuiViewportFlags_.ImGuiViewportFlags_NoRendererClear
	viewport_flags : ImGuiViewportFlags = window.Viewport.Flags & !viewport_flags_to_clear
	window_flags : ImGuiWindowFlags = window.Flags
	is_modal : bool = (window_flags & ImGuiWindowFlags_.ImGuiWindowFlags_Modal) != 0
	is_short_lived_floating_window : bool = (window_flags & (ImGuiWindowFlags_.ImGuiWindowFlags_ChildMenu | ImGuiWindowFlags_.ImGuiWindowFlags_Tooltip | ImGuiWindowFlags_.ImGuiWindowFlags_Popup)) != 0
	if ImGuiWindowFlags_Tooltip : ^window_flags; ImGuiWindowFlags_Tooltip { viewport_flags |= ImGuiViewportFlags_.ImGuiViewportFlags_TopMost }
	if (g.IO.ConfigViewportsNoTaskBarIcon || is_short_lived_floating_window) && !is_modal { viewport_flags |= ImGuiViewportFlags_.ImGuiViewportFlags_NoTaskBarIcon }
	if g.IO.ConfigViewportsNoDecoration || is_short_lived_floating_window { viewport_flags |= ImGuiViewportFlags_.ImGuiViewportFlags_NoDecoration }

	// Not correct to set modal as topmost because:
	// - Because other popups can be stacked above a modal (e.g. combo box in a modal)
	// - ImGuiViewportFlags_TopMost is currently handled different in backends: in Win32 it is "appear top most" whereas in GLFW and SDL it is "stay topmost"
	//if (flags & ImGuiWindowFlags_Modal)
	//    viewport_flags |= ImGuiViewportFlags_TopMost;

	// For popups and menus that may be protruding out of their parent viewport, we enable _NoFocusOnClick so that clicking on them
	// won't steal the OS focus away from their parent window (which may be reflected in OS the title bar decoration).
	// Setting _NoFocusOnClick would technically prevent us from bringing back to front in case they are being covered by an OS window from a different app,
	// but it shouldn't be much of a problem considering those are already popups that are closed when clicking elsewhere.
	if is_short_lived_floating_window && !is_modal { viewport_flags |= ImGuiViewportFlags_.ImGuiViewportFlags_NoFocusOnAppearing | ImGuiViewportFlags_.ImGuiViewportFlags_NoFocusOnClick }

	// We can overwrite viewport flags using ImGuiWindowClass (advanced users)
	if window.WindowClass.ViewportFlagsOverrideSet { viewport_flags |= window.WindowClass.ViewportFlagsOverrideSet }
	if window.WindowClass.ViewportFlagsOverrideClear { viewport_flags &= !window.WindowClass.ViewportFlagsOverrideClear }

	// We can also tell the backend that clearing the platform window won't be necessary,
	// as our window background is filling the viewport and we have disabled BgAlpha.
	// FIXME: Work on support for per-viewport transparency (#2766)
	if !(window_flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoBackground) { viewport_flags |= ImGuiViewportFlags_.ImGuiViewportFlags_NoRendererClear }

	window.Viewport.Flags = viewport_flags

	// Update parent viewport ID
	// (the !IsFallbackWindow test mimic the one done in WindowSelectViewport())
	if window.WindowClass.ParentViewportId != cast(ImGuiID) -1 { window.Viewport.ParentViewportId = window.WindowClass.ParentViewportId }
	else if (window_flags & (ImGuiWindowFlags_.ImGuiWindowFlags_Popup | ImGuiWindowFlags_.ImGuiWindowFlags_Tooltip)) && parent_window_in_stack && (!parent_window_in_stack.IsFallbackWindow || parent_window_in_stack.WasActive) { window.Viewport.ParentViewportId = parent_window_in_stack.Viewport.ID }
	else { window.Viewport.ParentViewportId = g.IO.ConfigViewportsNoDefaultParent ? 0 : IMGUI_VIEWPORT_DEFAULT_ID }
}

// (Optional) Platform/OS interface for multi-viewport support
// Read comments around the ImGuiPlatformIO structure for more details.
// Note: You may use GetWindowViewport() to get the current viewport of the current window.
// call in main loop. will call CreateWindow/ResizeWindow/etc. platform functions for each secondary viewport, and DestroyWindow for each inactive viewport.
// Called by user at the end of the main loop, after EndFrame()
// This will handle the creation/update of all OS windows via function defined in the ImGuiPlatformIO api.
UpdatePlatformWindows :: proc()
{
	g : ^ImGuiContext = GImGui^
	IM_ASSERT(g.FrameCountEnded == g.FrameCount && "Forgot to call Render() or EndFrame() before UpdatePlatformWindows()?")
	IM_ASSERT(g.FrameCountPlatformEnded < g.FrameCount)
	g.FrameCountPlatformEnded = g.FrameCount
	if !(g.ConfigFlagsCurrFrame & ImGuiConfigFlags_.ImGuiConfigFlags_ViewportsEnable) { return }

	// Create/resize/destroy platform windows to match each active viewport.
	// Skip the main viewport (index 0), which is always fully handled by the application!
	for i : i32 = 1; i < g.Viewports.Size; post_incr(&i) {
		viewport : ^ImGuiViewportP = g.Viewports[i]

		// Destroy platform window if the viewport hasn't been submitted or if it is hosting a hidden window
		// (the implicit/fallback Debug##Default window will be registering its viewport then be disabled, causing a dummy DestroyPlatformWindow to be made each frame)
		destroy_platform_window : bool = false
		destroy_platform_window |= (viewport.LastFrameActive < g.FrameCount - 1)
		destroy_platform_window |= (viewport.Window && !IsWindowActiveAndVisible(viewport.Window))
		if destroy_platform_window {
			DestroyPlatformWindow(viewport)
			continue
		}

		// New windows that appears directly in a new viewport won't always have a size on their first frame
		if viewport.LastFrameActive < g.FrameCount || viewport.Size.x <= 0 || viewport.Size.y <= 0 { continue }

		// Create window
		is_new_platform_window : bool = (viewport.PlatformWindowCreated == false)
		if is_new_platform_window {
			IMGUI_DEBUG_LOG_VIEWPORT("[viewport] Create Platform Window %08X '%s'\n", viewport.ID, viewport.Window ? viewport.Window.Name : "n/a")
			Platform_CreateWindow(&g.PlatformIO, viewport)
			if g.PlatformIO.Renderer_CreateWindow != nil { Renderer_CreateWindow(&g.PlatformIO, viewport) }
			post_incr(&g.PlatformWindowsCreatedCount)
			viewport.LastNameHash = 0
			viewport.LastPlatformSize = ImVec2(FLT_MAX, FLT_MAX); viewport.LastPlatformPos = viewport.LastPlatformSize; // By clearing those we'll enforce a call to Platform_SetWindowPos/Size below, before Platform_ShowWindow (FIXME: Is that necessary?)
			viewport.LastRendererSize = viewport.Size; // We don't need to call Renderer_SetWindowSize() as it is expected Renderer_CreateWindow() already did it.
			viewport.PlatformWindowCreated = true
		}

		// Apply Position and Size (from ImGui to Platform/Renderer backends)
		if (viewport.LastPlatformPos.x != viewport.Pos.x || viewport.LastPlatformPos.y != viewport.Pos.y) && !viewport.PlatformRequestMove { Platform_SetWindowPos(&g.PlatformIO, viewport, viewport.Pos) }
		if (viewport.LastPlatformSize.x != viewport.Size.x || viewport.LastPlatformSize.y != viewport.Size.y) && !viewport.PlatformRequestResize { Platform_SetWindowSize(&g.PlatformIO, viewport, viewport.Size) }
		if (viewport.LastRendererSize.x != viewport.Size.x || viewport.LastRendererSize.y != viewport.Size.y) && g.PlatformIO.Renderer_SetWindowSize { Renderer_SetWindowSize(&g.PlatformIO, viewport, viewport.Size) }
		viewport.LastPlatformPos = viewport.Pos
		viewport.LastRendererSize = viewport.Size; viewport.LastPlatformSize = viewport.LastRendererSize

		// Update title bar (if it changed)
		if window_for_title : ^ImGuiWindow = GetWindowForTitleDisplay(viewport.Window); window_for_title {
			title_begin : ^u8 = window_for_title.Name
			title_end : ^u8 = cast(^u8) cast(intptr_t) FindRenderedTextEnd(title_begin)
			title_hash : ImGuiID = ImHashStr(title_begin, title_end - title_begin)
			if viewport.LastNameHash != title_hash {
				title_end_backup_c : u8 = title_end^
				title_end^ = 0; // Cut existing buffer short instead of doing an alloc/free, no small gain.
				Platform_SetWindowTitle(&g.PlatformIO, viewport, title_begin)
				title_end^ = title_end_backup_c
				viewport.LastNameHash = title_hash
			}
		}

		// Update alpha (if it changed)
		if viewport.LastAlpha != viewport.Alpha && g.PlatformIO.Platform_SetWindowAlpha { Platform_SetWindowAlpha(&g.PlatformIO, viewport, viewport.Alpha) }
		viewport.LastAlpha = viewport.Alpha

		// Optional, general purpose call to allow the backend to perform general book-keeping even if things haven't changed.
		if g.PlatformIO.Platform_UpdateWindow { Platform_UpdateWindow(&g.PlatformIO, viewport) }

		if is_new_platform_window {
			// On startup ensure new platform window don't steal focus (give it a few frames, as nested contents may lead to viewport being created a few frames late)
			if g.FrameCount < 3 { viewport.Flags |= ImGuiViewportFlags_.ImGuiViewportFlags_NoFocusOnAppearing }

			// Show window
			Platform_ShowWindow(&g.PlatformIO, viewport)

			// Even without focus, we assume the window becomes front-most.
			// This is useful for our platform z-order heuristic when io.MouseHoveredViewport is not available.
			if viewport.LastFocusedStampCount != g.ViewportFocusedStampCount { viewport.LastFocusedStampCount = pre_incr(&g.ViewportFocusedStampCount) }
		}

		// Clear request flags
		ClearRequestFlags(viewport)
	}
}

// call in main loop. will call RenderWindow/SwapBuffers platform functions for each secondary viewport which doesn't have the ImGuiViewportFlags_Minimized flag set. May be reimplemented by user for custom rendering needs.
// This is a default/basic function for performing the rendering/swap of multiple Platform Windows.
// Custom renderers may prefer to not call this function at all, and instead iterate the publicly exposed platform data and handle rendering/sync themselves.
// The Render/Swap functions stored in ImGuiPlatformIO are merely here to allow for this helper to exist, but you can do it yourself:
//
//    ImGuiPlatformIO& platform_io = ImGui::GetPlatformIO();
//    for (int i = 1; i < platform_io.Viewports.Size; i++)
//        if ((platform_io.Viewports[i]->Flags & ImGuiViewportFlags_Minimized) == 0)
//            MyRenderFunction(platform_io.Viewports[i], my_args);
//    for (int i = 1; i < platform_io.Viewports.Size; i++)
//        if ((platform_io.Viewports[i]->Flags & ImGuiViewportFlags_Minimized) == 0)
//            MySwapBufferFunction(platform_io.Viewports[i], my_args);
//
RenderPlatformWindowsDefault :: proc(platform_render_arg : rawptr, renderer_render_arg : rawptr)
{
	// Skip the main viewport (index 0), which is always fully handled by the application!
	platform_io : ^ImGuiPlatformIO = GetPlatformIO()
	for i : i32 = 1; i < platform_io.Viewports.Size; post_incr(&i) {
		viewport : ^ImGuiViewport = platform_io.Viewports[i]
		if viewport.Flags & ImGuiViewportFlags_.ImGuiViewportFlags_IsMinimized { continue }
		if platform_io.Platform_RenderWindow { Platform_RenderWindow(&platform_io, viewport, platform_render_arg) }
		if platform_io.Renderer_RenderWindow { Renderer_RenderWindow(&platform_io, viewport, renderer_render_arg) }
	}

	for i : i32 = 1; i < platform_io.Viewports.Size; post_incr(&i) {
		viewport : ^ImGuiViewport = platform_io.Viewports[i]
		if viewport.Flags & ImGuiViewportFlags_.ImGuiViewportFlags_IsMinimized { continue }
		if platform_io.Platform_SwapBuffers { Platform_SwapBuffers(&platform_io, viewport, platform_render_arg) }
		if platform_io.Renderer_SwapBuffers { Renderer_SwapBuffers(&platform_io, viewport, renderer_render_arg) }
	}
}

FindPlatformMonitorForPos :: proc(pos : ^ImVec2) -> i32
{
	g : ^ImGuiContext = GImGui^
	for monitor_n : i32 = 0; monitor_n < g.PlatformIO.Monitors.Size; post_incr(&monitor_n) {
		monitor : ^ImGuiPlatformMonitor = g.PlatformIO.Monitors[monitor_n]
		if Contains(&ImRect(monitor.MainPos, monitor.MainPos + monitor.MainSize), pos) { return monitor_n }
	}

	return -1
}

// Search for the monitor with the largest intersection area with the given rectangle
// We generally try to avoid searching loops but the monitor count should be very small here
// FIXME-OPT: We could test the last monitor used for that viewport first, and early
FindPlatformMonitorForRect :: proc(rect : ^ImRect) -> i32
{
	g : ^ImGuiContext = GImGui^

	monitor_count : i32 = g.PlatformIO.Monitors.Size
	if monitor_count <= 1 { return monitor_count - 1 }

	// Use a minimum threshold of 1.0f so a zero-sized rect won't false positive, and will still find the correct monitor given its position.
	// This is necessary for tooltips which always resize down to zero at first.
	surface_threshold : f32 = ImMax(GetWidth(&rect) * GetHeight(&rect) * 0.5, 1.0)
	best_monitor_n : i32 = -1
	best_monitor_surface : f32 = 0.001

	for monitor_n : i32 = 0; monitor_n < g.PlatformIO.Monitors.Size && best_monitor_surface < surface_threshold; post_incr(&monitor_n) {
		monitor : ^ImGuiPlatformMonitor = g.PlatformIO.Monitors[monitor_n]
		monitor_rect : ImRect = ImRect(monitor.MainPos, monitor.MainPos + monitor.MainSize)
		if Contains(&monitor_rect, rect) { return monitor_n }
		overlapping_rect : ImRect = rect
		ClipWithFull(&overlapping_rect, monitor_rect)
		overlapping_surface : f32 = GetWidth(&overlapping_rect) * GetHeight(&overlapping_rect)
		if overlapping_surface < best_monitor_surface { continue }
		best_monitor_surface = overlapping_surface
		best_monitor_n = monitor_n
	}

	return best_monitor_n
}

// Update monitor from viewport rectangle (we'll use this info to clamp windows and save windows lost in a removed monitor)
UpdateViewportPlatformMonitor :: proc(viewport : ^ImGuiViewportP)
{
	viewport.PlatformMonitor = cast(i16) FindPlatformMonitorForRect(GetMainRect(viewport))
}

// Return value is always != NULL, but don't hold on it across frames.
GetViewportPlatformMonitor :: proc(viewport_p : ^ImGuiViewport) -> ^ImGuiPlatformMonitor
{
	g : ^ImGuiContext = GImGui^
	viewport : ^ImGuiViewportP = cast(^ImGuiViewportP) cast(rawptr) viewport_p
	monitor_idx : i32 = viewport.PlatformMonitor
	if monitor_idx >= 0 && monitor_idx < g.PlatformIO.Monitors.Size { return &g.PlatformIO.Monitors[monitor_idx] }
	return &g.FallbackMonitor
}

DestroyPlatformWindow :: proc(viewport : ^ImGuiViewportP)
{
	g : ^ImGuiContext = GImGui^
	if viewport.PlatformWindowCreated {
		IMGUI_DEBUG_LOG_VIEWPORT("[viewport] Destroy Platform Window %08X '%s'\n", viewport.ID, viewport.Window ? viewport.Window.Name : "n/a")
		if g.PlatformIO.Renderer_DestroyWindow { Renderer_DestroyWindow(&g.PlatformIO, viewport) }
		if g.PlatformIO.Platform_DestroyWindow { Platform_DestroyWindow(&g.PlatformIO, viewport) }
		IM_ASSERT(viewport.RendererUserData == nil && viewport.PlatformUserData == nil)

		// Don't clear PlatformWindowCreated for the main viewport, as we initially set that up to true in Initialize()
		// The righter way may be to leave it to the backend to set this flag all-together, and made the flag public.
		if viewport.ID != IMGUI_VIEWPORT_DEFAULT_ID { viewport.PlatformWindowCreated = false }
	}
	else {
		IM_ASSERT(viewport.RendererUserData == nil && viewport.PlatformUserData == nil && viewport.PlatformHandle == nil)
	}
	viewport.PlatformHandle = nil; viewport.PlatformUserData = viewport.PlatformHandle; viewport.RendererUserData = viewport.PlatformUserData
	ClearRequestFlags(viewport)
}

// call DestroyWindow platform functions for all viewports. call from backend Shutdown() if you need to close platform windows before imgui shutdown. otherwise will be called by DestroyContext().
DestroyPlatformWindows :: proc()
{
	// We call the destroy window on every viewport (including the main viewport, index 0) to give a chance to the backend
	// to clear any data they may have stored in e.g. PlatformUserData, RendererUserData.
	// It is convenient for the platform backend code to store something in the main viewport, in order for e.g. the mouse handling
	// code to operator a consistent manner.
	// It is expected that the backend can handle calls to Renderer_DestroyWindow/Platform_DestroyWindow without
	// crashing if it doesn't have data stored.
	g : ^ImGuiContext = GImGui^
	for viewport in g.Viewports { DestroyPlatformWindow(viewport) }
}


//-----------------------------------------------------------------------------
// [SECTION] DOCKING
//-----------------------------------------------------------------------------
// Docking: Internal Types
// Docking: Forward Declarations
// Docking: ImGuiDockContext
// Docking: ImGuiDockContext Docking/Undocking functions
// Docking: ImGuiDockNode
// Docking: ImGuiDockNode Tree manipulation functions
// Docking: Public Functions (SetWindowDock, DockSpace, DockSpaceOverViewport)
// Docking: Builder Functions
// Docking: Begin/End Support Functions (called from Begin/End)
// Docking: Settings
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// Typical Docking call flow: (root level is generally public API):
//-----------------------------------------------------------------------------
// - NewFrame()                               new dear imgui frame
//    | DockContextNewFrameUpdateUndocking()  - process queued undocking requests
//    | - DockContextProcessUndockWindow()    - process one window undocking request
//    | - DockContextProcessUndockNode()      - process one whole node undocking request
//    | DockContextNewFrameUpdateUndocking()  - process queue docking requests, create floating dock nodes
//    | - update g.HoveredDockNode            - [debug] update node hovered by mouse
//    | - DockContextProcessDock()            - process one docking request
//    | - DockNodeUpdate()
//    |   - DockNodeUpdateForRootNode()
//    |     - DockNodeUpdateFlagsAndCollapse()
//    |     - DockNodeFindInfo()
//    |   - destroy unused node or tab bar
//    |   - create dock node host window
//    |      - Begin() etc.
//    |   - DockNodeStartMouseMovingWindow()
//    |   - DockNodeTreeUpdatePosSize()
//    |   - DockNodeTreeUpdateSplitter()
//    |   - draw node background
//    |   - DockNodeUpdateTabBar()            - create/update tab bar for a docking node
//    |     - DockNodeAddTabBar()
//    |     - DockNodeWindowMenuUpdate()
//    |     - DockNodeCalcTabBarLayout()
//    |     - BeginTabBarEx()
//    |     - TabItemEx() calls
//    |     - EndTabBar()
//    |   - BeginDockableDragDropTarget()
//    |      - DockNodeUpdate()               - recurse into child nodes...
//-----------------------------------------------------------------------------
// - DockSpace()                              user submit a dockspace into a window
//    | Begin(Child)                          - create a child window
//    | DockNodeUpdate()                      - call main dock node update function
//    | End(Child)
//    | ItemSize()
//-----------------------------------------------------------------------------
// - Begin()
//    | BeginDocked()
//    | BeginDockableDragDropSource()
//    | BeginDockableDragDropTarget()
//    | - DockNodePreviewDockRender()
//-----------------------------------------------------------------------------
// - EndFrame()
//    | DockContextEndFrame()
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// Docking: Internal Types
//-----------------------------------------------------------------------------
// - ImGuiDockRequestType
// - ImGuiDockRequest
// - ImGuiDockPreviewData
// - ImGuiDockNodeSettings
// - ImGuiDockContext
//-----------------------------------------------------------------------------

ImGuiDockRequestType :: enum i32 {
	ImGuiDockRequestType_None = 0,
	ImGuiDockRequestType_Dock,
	ImGuiDockRequestType_Undock,
	ImGuiDockRequestType_Split, // Split is the same as Dock but without a DockPayload
}

// Docking system context
ImGuiDockRequest :: struct {
	Type : ImGuiDockRequestType,
	DockTargetWindow : ^ImGuiWindow, // Destination/Target Window to dock into (may be a loose window or a DockNode, might be NULL in which case DockTargetNode cannot be NULL)
	DockTargetNode : ^ImGuiDockNode, // Destination/Target Node to dock into
	DockPayload : ^ImGuiWindow, // Source/Payload window to dock (may be a loose window or a DockNode), [Optional]
	DockSplitDir : ImGuiDir,
	DockSplitRatio : f32,
	DockSplitOuter : bool,
	UndockTargetWindow : ^ImGuiWindow,
	UndockTargetNode : ^ImGuiDockNode,
}

ImGuiDockRequest_init :: proc(this : ^ImGuiDockRequest)
{
	this.Type = ImGuiDockRequestType.ImGuiDockRequestType_None
	this.UndockTargetWindow = nil; this.DockPayload = this.UndockTargetWindow; this.DockTargetWindow = this.DockPayload
	this.UndockTargetNode = nil; this.DockTargetNode = this.UndockTargetNode
	this.DockSplitDir = ImGuiDir.ImGuiDir_None
	this.DockSplitRatio = 0.5
	this.DockSplitOuter = false
}

ImGuiDockPreviewData :: struct {
	FutureNode : ImGuiDockNode,
	IsDropAllowed : bool,
	IsCenterAvailable : bool,
	IsSidesAvailable : bool, // Hold your breath, grammar freaks..
	IsSplitDirExplicit : bool, // Set when hovered the drop rect (vs. implicit SplitDir==None when hovered the window)
	SplitNode : ^ImGuiDockNode,
	SplitDir : ImGuiDir,
	SplitRatio : f32,
	DropRectsDraw : [int(ImGuiDir.ImGuiDir_COUNT) + 1]ImRect, }

// May be slightly different from hit-testing drop rects used in DockNodeCalcDropRects()

ImGuiDockPreviewData_init :: proc(this : ^ImGuiDockPreviewData)
{
	init(&this.FutureNode, 0); this.IsSplitDirExplicit = false; this.IsSidesAvailable = this.IsSplitDirExplicit; this.IsCenterAvailable = this.IsSidesAvailable; this.IsDropAllowed = this.IsCenterAvailable; this.SplitNode = nil; this.SplitDir = ImGuiDir.ImGuiDir_None; this.SplitRatio = 0.; for n : i32 = 0; n < IM_ARRAYSIZE(this.DropRectsDraw); post_incr(&n) { this.DropRectsDraw[n] = ImRect(+FLT_MAX, +FLT_MAX, -FLT_MAX, -FLT_MAX) }
}

// Docking system node (hold a list of Windows OR two child dock nodes)
// Persistent Settings data, stored contiguously in SettingsNodes (sizeof() ~32 bytes)
ImGuiDockNodeSettings :: struct {
	ID : ImGuiID,
	ParentNodeId : ImGuiID,
	ParentWindowId : ImGuiID,
	SelectedTabId : ImGuiID,
	SplitAxis : i8,
	Depth : u8,
	Flags : ImGuiDockNodeFlags, // NB: We save individual flags one by one in ascii format (ImGuiDockNodeFlags_SavedFlagsMask_)
	Pos : ImVec2ih,
	Size : ImVec2ih,
	SizeRef : ImVec2ih,
}

ImGuiDockNodeSettings_init :: proc(this : ^ImGuiDockNodeSettings)
{
	memset(this, 0, size_of(this)); this.SplitAxis = ImGuiAxis.ImGuiAxis_None
}

//-----------------------------------------------------------------------------
// Docking: Forward Declarations
//-----------------------------------------------------------------------------

DockNodeGetHostWindowTitle :: proc(node : ^ImGuiDockNode, buf : ^u8, buf_size : i32) -> ^u8
{
	ImFormatString(buf, buf_size, "##DockNode_%02X", node.ID); return buf
}
// Docking
// (some functions are only declared in imgui.cpp, see Docking section)
//-----------------------------------------------------------------------------
// Docking: ImGuiDockContext
//-----------------------------------------------------------------------------
// The lifetime model is different from the one of regular windows: we always create a ImGuiDockNode for each ImGuiDockNodeSettings,
// or we always hold the entire docking node tree. Nodes are frequently hidden, e.g. if the window(s) or child nodes they host are not active.
// At boot time only, we run a simple GC to remove nodes that have no references.
// Because dock node settings (which are small, contiguous structures) are always mirrored by their corresponding dock nodes (more complete structures),
// we can also very easily recreate the nodes from scratch given the settings data (this is what DockContextRebuild() does).
// This is convenient as docking reconfiguration can be implemented by mostly poking at the simpler settings data.
//-----------------------------------------------------------------------------
// - DockContextInitialize()
// - DockContextShutdown()
// - DockContextClearNodes()
// - DockContextRebuildNodes()
// - DockContextNewFrameUpdateUndocking()
// - DockContextNewFrameUpdateDocking()
// - DockContextEndFrame()
// - DockContextFindNodeByID()
// - DockContextBindNodeToWindow()
// - DockContextGenNodeID()
// - DockContextAddNode()
// - DockContextRemoveNode()
// - ImGuiDockContextPruneNodeData
// - DockContextPruneUnusedSettingsNodes()
// - DockContextBuildNodesFromSettings()
// - DockContextBuildAddWindowsToNodes()
//-----------------------------------------------------------------------------

DockContextInitialize :: proc(ctx : ^ImGuiContext)
{
	g : ^ImGuiContext = ctx^

	// Add .ini handle for persistent docking data
	ini_handler : ImGuiSettingsHandler
	ini_handler.TypeName = "Docking"
	ini_handler.TypeHash = ImHashStr("Docking")
	ini_handler.ClearAllFn = DockSettingsHandler_ClearAll
	ini_handler.ReadInitFn = DockSettingsHandler_ClearAll; // Also clear on read
	ini_handler.ReadOpenFn = DockSettingsHandler_ReadOpen
	ini_handler.ReadLineFn = DockSettingsHandler_ReadLine
	ini_handler.ApplyAllFn = DockSettingsHandler_ApplyAll
	ini_handler.WriteAllFn = DockSettingsHandler_WriteAll
	push_back(&g.SettingsHandlers, ini_handler)

	g.DockNodeWindowMenuHandler = &DockNodeWindowMenuHandler_Default
}

DockContextShutdown :: proc(ctx : ^ImGuiContext)
{
	dc : ^ImGuiDockContext = &ctx.DockContext
	for n : i32 = 0; n < dc.Nodes.Data.Size; post_incr(&n) { if node : ^ImGuiDockNode = cast(^ImGuiDockNode) dc.Nodes.Data[n].val_p; node { IM_DELETE(node) } }
}

// Use root_id==0 to clear all
DockContextClearNodes :: proc(ctx : ^ImGuiContext, root_id : ImGuiID, clear_settings_refs : bool)
{
	IM_UNUSED(ctx)
	IM_ASSERT(ctx == GImGui)
	DockBuilderRemoveNodeDockedWindows(root_id, clear_settings_refs)
	DockBuilderRemoveNodeChildNodes(root_id)
}

// [DEBUG] This function also acts as a defacto test to make sure we can rebuild from scratch without a glitch
// (Different from DockSettingsHandler_ClearAll() + DockSettingsHandler_ApplyAll() because this reuses current settings!)
DockContextRebuildNodes :: proc(ctx : ^ImGuiContext)
{
	g : ^ImGuiContext = ctx^
	dc : ^ImGuiDockContext = &ctx.DockContext
	IMGUI_DEBUG_LOG_DOCKING("[docking] DockContextRebuildNodes\n")
	SaveIniSettingsToMemory()
	root_id : ImGuiID = 0; // Rebuild all
	DockContextClearNodes(ctx, root_id, false)
	DockContextBuildNodesFromSettings(ctx, dc.NodesSettings.Data, dc.NodesSettings.Size)
	DockContextBuildAddWindowsToNodes(ctx, root_id)
}

// Docking context update function, called by NewFrame()
DockContextNewFrameUpdateUndocking :: proc(ctx : ^ImGuiContext)
{
	g : ^ImGuiContext = ctx^
	dc : ^ImGuiDockContext = &ctx.DockContext
	if !(g.IO.ConfigFlags & ImGuiConfigFlags_.ImGuiConfigFlags_DockingEnable) {
		if dc.Nodes.Data.Size > 0 || dc.Requests.Size > 0 { DockContextClearNodes(ctx, 0, true) }
		return
	}

	// Setting NoSplit at runtime merges all nodes
	if g.IO.ConfigDockingNoSplit { for n : i32 = 0; n < dc.Nodes.Data.Size; post_incr(&n) { if node : ^ImGuiDockNode = cast(^ImGuiDockNode) dc.Nodes.Data[n].val_p; node { if IsRootNode(node) && IsSplitNode(node) {
	DockBuilderRemoveNodeChildNodes(node.ID)
	//dc->WantFullRebuild = true;
} } } }

	// Process full rebuild

	if dc.WantFullRebuild {
		DockContextRebuildNodes(ctx)
		dc.WantFullRebuild = false
	}

	// Process Undocking requests (we need to process them _before_ the UpdateMouseMovingWindowNewFrame call in NewFrame)
	for req in dc.Requests {
		if req.Type == ImGuiDockRequestType.ImGuiDockRequestType_Undock && req.UndockTargetWindow { DockContextProcessUndockWindow(ctx, req.UndockTargetWindow) }
		else if req.Type == ImGuiDockRequestType.ImGuiDockRequestType_Undock && req.UndockTargetNode { DockContextProcessUndockNode(ctx, req.UndockTargetNode) }
	}
}

// Docking context update function, called by NewFrame()
DockContextNewFrameUpdateDocking :: proc(ctx : ^ImGuiContext)
{
	g : ^ImGuiContext = ctx^
	dc : ^ImGuiDockContext = &ctx.DockContext
	if !(g.IO.ConfigFlags & ImGuiConfigFlags_.ImGuiConfigFlags_DockingEnable) { return }

	// [DEBUG] Store hovered dock node.
	// We could in theory use DockNodeTreeFindVisibleNodeByPos() on the root host dock node, but using ->DockNode is a good shortcut.
	// Note this is mostly a debug thing and isn't actually used for docking target, because docking involve more detailed filtering.
	g.DebugHoveredDockNode = nil
	if hovered_window : ^ImGuiWindow = g.HoveredWindowUnderMovingWindow; hovered_window {
		if hovered_window.DockNodeAsHost { g.DebugHoveredDockNode = DockNodeTreeFindVisibleNodeByPos(hovered_window.DockNodeAsHost, g.IO.MousePos) }
		else if hovered_window.RootWindow.DockNode { g.DebugHoveredDockNode = hovered_window.RootWindow.DockNode }
	}

	// Process Docking requests
	for req in dc.Requests { if req.Type == ImGuiDockRequestType.ImGuiDockRequestType_Dock { DockContextProcessDock(ctx, &req) } }

	resize(&dc.Requests, 0)

	// Create windows for each automatic docking nodes
	// We can have NULL pointers when we delete nodes, but because ID are recycled this should amortize nicely (and our node count will never be very high)
	for n : i32 = 0; n < dc.Nodes.Data.Size; post_incr(&n) { if node : ^ImGuiDockNode = cast(^ImGuiDockNode) dc.Nodes.Data[n].val_p; node { if IsFloatingNode(node) { DockNodeUpdate(node) } } }
}

DockContextEndFrame :: proc(ctx : ^ImGuiContext)
{
	// Draw backgrounds of node missing their window
	g : ^ImGuiContext = ctx^
	dc : ^ImGuiDockContext = &g.DockContext
	for n : i32 = 0; n < dc.Nodes.Data.Size; post_incr(&n) { if node : ^ImGuiDockNode = cast(^ImGuiDockNode) dc.Nodes.Data[n].val_p; node { if node.LastFrameActive == g.FrameCount && node.IsVisible && node.HostWindow && IsLeafNode(node) && !node.IsBgDrawnThisFrame {
	bg_rect : ImRect; init(&bg_rect, node.Pos + ImVec2(0.0, GetFrameHeight()), node.Pos + node.Size)
	bg_rounding_flags : ImDrawFlags = CalcRoundingFlagsForRectInRect(bg_rect, Rect(node.HostWindow), g.Style.DockingSeparatorSize)
	ChannelsSetCurrent(node.HostWindow.DrawList, DOCKING_HOST_DRAW_CHANNEL_BG)
	AddRectFilled(node.HostWindow.DrawList, bg_rect.Min, bg_rect.Max, node.LastBgColor, node.HostWindow.WindowRounding, bg_rounding_flags)
} } }
}

DockContextFindNodeByID :: proc(ctx : ^ImGuiContext, id : ImGuiID) -> ^ImGuiDockNode
{
	return cast(^ImGuiDockNode) GetVoidPtr(&ctx.DockContext.Nodes, id)
}

DockContextGenNodeID :: proc(ctx : ^ImGuiContext) -> ImGuiID
{
	// Generate an ID for new node (the exact ID value doesn't matter as long as it is not already used)
	// FIXME-OPT FIXME-DOCK: This is suboptimal, even if the node count is small enough not to be a worry.0
	// We should poke in ctx->Nodes to find a suitable ID faster. Even more so trivial that ctx->Nodes lookup is already sorted.
	id : ImGuiID = 0x0001
	for DockContextFindNodeByID(ctx, id) != nil { post_incr(&id) }

	return id
}

// ImGuiDockContext
DockContextAddNode :: proc(ctx : ^ImGuiContext, id : ImGuiID) -> ^ImGuiDockNode
{
	// Generate an ID for the new node (the exact ID value doesn't matter as long as it is not already used) and add the first window.
	g : ^ImGuiContext = ctx^
	if id == 0 { id = DockContextGenNodeID(ctx) }
	else { IM_ASSERT(DockContextFindNodeByID(ctx, id) == nil) }

	// We don't set node->LastFrameAlive on construction. Nodes are always created at all time to reflect .ini settings!
	IMGUI_DEBUG_LOG_DOCKING("[docking] DockContextAddNode 0x%08X\n", id)
	node : ^ImGuiDockNode = IM_NEW(ImGuiDockNode)(id)
	SetVoidPtr(&ctx.DockContext.Nodes, node.ID, node)
	return node
}

DockContextRemoveNode :: proc(ctx : ^ImGuiContext, node : ^ImGuiDockNode, merge_sibling_into_parent_node : bool)
{
	g : ^ImGuiContext = ctx^
	dc : ^ImGuiDockContext = &ctx.DockContext

	IMGUI_DEBUG_LOG_DOCKING("[docking] DockContextRemoveNode 0x%08X\n", node.ID)
	IM_ASSERT(DockContextFindNodeByID(ctx, node.ID) == node)
	IM_ASSERT(node.ChildNodes[0] == nil && node.ChildNodes[1] == nil)
	IM_ASSERT(node.Windows.Size == 0)

	if node.HostWindow { node.HostWindow.DockNodeAsHost = nil }

	parent_node : ^ImGuiDockNode = node.ParentNode
	merge : bool = (merge_sibling_into_parent_node && parent_node != nil)
	if merge {
		IM_ASSERT(parent_node.ChildNodes[0] == node || parent_node.ChildNodes[1] == node)
		sibling_node : ^ImGuiDockNode = (parent_node.ChildNodes[0] == node ? parent_node.ChildNodes[1] : parent_node.ChildNodes[0])
		DockNodeTreeMerge(&g, parent_node, sibling_node)
	}
	else {
		for n : i32 = 0; parent_node && n < IM_ARRAYSIZE(parent_node.ChildNodes); post_incr(&n) { if parent_node.ChildNodes[n] == node { node.ParentNode.ChildNodes[n] = nil } }

		SetVoidPtr(&dc.Nodes, node.ID, nil)
		IM_DELETE(node)
	}
}

DockNodeComparerDepthMostFirst :: proc(lhs : rawptr, rhs : rawptr) -> i32
{
	a : ^ImGuiDockNode = cast(^^ImGuiDockNode) lhs^
	b : ^ImGuiDockNode = cast(^^ImGuiDockNode) rhs^
	return DockNodeGetDepth(b) - DockNodeGetDepth(a)
}

// Pre C++0x doesn't allow us to use a function-local type (without linkage) as template parameter, so we moved this here.
ImGuiDockContextPruneNodeData :: struct {
	CountWindows : i32, CountChildWindows : i32, CountChildNodes : i32,
	RootId : ImGuiID,
}

ImGuiDockContextPruneNodeData_init :: proc(this : ^ImGuiDockContextPruneNodeData)
{
	this.CountChildNodes = 0; this.CountChildWindows = this.CountChildNodes; this.CountWindows = this.CountChildWindows; this.RootId = 0
}

// Garbage collect unused nodes (run once at init time)
DockContextPruneUnusedSettingsNodes :: proc(ctx : ^ImGuiContext)
{
	g : ^ImGuiContext = ctx^
	dc : ^ImGuiDockContext = &ctx.DockContext
	IM_ASSERT(g.Windows.Size == 0)

	pool : ImPool(ImGuiDockContextPruneNodeData)
	Reserve(&pool, dc.NodesSettings.Size)

	// Count child nodes and compute RootID
	for settings_n : i32 = 0; settings_n < dc.NodesSettings.Size; post_incr(&settings_n) {
		settings : ^ImGuiDockNodeSettings = &dc.NodesSettings[settings_n]
		parent_data : ^ImGuiDockContextPruneNodeData = settings.ParentNodeId ? GetByKey(&pool, settings.ParentNodeId) : 0
		GetOrAddByKey(&pool, settings.ID).RootId = parent_data ? parent_data.RootId : settings.ID
		if settings.ParentNodeId { post_incr(&GetOrAddByKey(&pool, settings.ParentNodeId).CountChildNodes) }
	}

	// Count reference to dock ids from dockspaces
	// We track the 'auto-DockNode <- manual-Window <- manual-DockSpace' in order to avoid 'auto-DockNode' being ditched by DockContextPruneUnusedSettingsNodes()
	for settings_n : i32 = 0; settings_n < dc.NodesSettings.Size; post_incr(&settings_n) {
		settings : ^ImGuiDockNodeSettings = &dc.NodesSettings[settings_n]
		if settings.ParentWindowId != 0 { if window_settings : ^ImGuiWindowSettings = FindWindowSettingsByID(settings.ParentWindowId); window_settings { if window_settings.DockId { if data : ^ImGuiDockContextPruneNodeData = GetByKey(&pool, window_settings.DockId); data { post_incr(&data.CountChildNodes) } } } }
	}

	// Count reference to dock ids from window settings
	// We guard against the possibility of an invalid .ini file (RootID may point to a missing node)
	for settings : ^ImGuiWindowSettings = begin(&g.SettingsWindows); settings != nil; settings = next_chunk(&g.SettingsWindows, settings) { if dock_id : ImGuiID = settings.DockId; dock_id { if data : ^ImGuiDockContextPruneNodeData = GetByKey(&pool, dock_id); data {
	post_incr(&data.CountWindows)
	if data_root : ^ImGuiDockContextPruneNodeData = (data.RootId == dock_id) ? data : GetByKey(&pool, data.RootId); data_root { post_incr(&data_root.CountChildWindows) }
} } }

	// Prune
	for settings_n : i32 = 0; settings_n < dc.NodesSettings.Size; post_incr(&settings_n) {
		settings : ^ImGuiDockNodeSettings = &dc.NodesSettings[settings_n]
		data : ^ImGuiDockContextPruneNodeData = GetByKey(&pool, settings.ID)
		if data.CountWindows > 1 { continue }
		data_root : ^ImGuiDockContextPruneNodeData = (data.RootId == settings.ID) ? data : GetByKey(&pool, data.RootId)

		remove : bool = false
		remove |= (data.CountWindows == 1 && settings.ParentNodeId == 0 && data.CountChildNodes == 0 && !(settings.Flags & ImGuiDockNodeFlagsPrivate_.ImGuiDockNodeFlags_CentralNode)); // Floating root node with only 1 window
		remove |= (data.CountWindows == 0 && settings.ParentNodeId == 0 && data.CountChildNodes == 0); // Leaf nodes with 0 window
		remove |= (data_root.CountChildWindows == 0)
		if remove {
			IMGUI_DEBUG_LOG_DOCKING("[docking] DockContextPruneUnusedSettingsNodes: Prune 0x%08X\n", settings.ID)
			DockSettingsRemoveNodeReferences(&settings.ID, 1)
			settings.ID = 0
		}
	}
}

DockContextBuildNodesFromSettings :: proc(ctx : ^ImGuiContext, node_settings_array : ^ImGuiDockNodeSettings, node_settings_count : i32)
{
	// Build nodes
	for node_n : i32 = 0; node_n < node_settings_count; post_incr(&node_n) {
		settings : ^ImGuiDockNodeSettings = &node_settings_array[node_n]
		if settings.ID == 0 { continue }
		node : ^ImGuiDockNode = DockContextAddNode(ctx, settings.ID)
		node.ParentNode = settings.ParentNodeId ? DockContextFindNodeByID(ctx, settings.ParentNodeId) : nil
		node.Pos = ImVec2(settings.Pos.x, settings.Pos.y)
		node.Size = ImVec2(settings.Size.x, settings.Size.y)
		node.SizeRef = ImVec2(settings.SizeRef.x, settings.SizeRef.y)
		node.AuthorityForViewport = ImGuiDataAuthority_.ImGuiDataAuthority_DockNode; node.AuthorityForSize = node.AuthorityForViewport; node.AuthorityForPos = node.AuthorityForSize
		if node.ParentNode && node.ParentNode.ChildNodes[0] == nil { node.ParentNode.ChildNodes[0] = node }
		else if node.ParentNode && node.ParentNode.ChildNodes[1] == nil { node.ParentNode.ChildNodes[1] = node }
		node.SelectedTabId = settings.SelectedTabId
		node.SplitAxis = cast(ImGuiAxis) settings.SplitAxis
		SetLocalFlags(node, settings.Flags & ImGuiDockNodeFlagsPrivate_.ImGuiDockNodeFlags_SavedFlagsMask_)

		// Bind host window immediately if it already exist (in case of a rebuild)
		// This is useful as the RootWindowForTitleBarHighlight links necessary to highlight the currently focused node requires node->HostWindow to be set.
		host_window_title : [20]u8
		root_node : ^ImGuiDockNode = DockNodeGetRootNode(node)
		node.HostWindow = FindWindowByName(DockNodeGetHostWindowTitle(root_node, host_window_title, IM_ARRAYSIZE(host_window_title)))
	}
}

// Use root_id==0 to add all
DockContextBuildAddWindowsToNodes :: proc(ctx : ^ImGuiContext, root_id : ImGuiID)
{
	// Rebind all windows to nodes (they can also lazily rebind but we'll have a visible glitch during the first frame)
	g : ^ImGuiContext = ctx^
	for window in g.Windows {
		if window.DockId == 0 || window.LastFrameActive < g.FrameCount - 1 { continue }
		if window.DockNode != nil { continue }

		node : ^ImGuiDockNode = DockContextFindNodeByID(ctx, window.DockId)
		IM_ASSERT(node != nil); // This should have been called after DockContextBuildNodesFromSettings()
		if root_id == 0 || DockNodeGetRootNode(node).ID == root_id { DockNodeAddWindow(node, window, true) }
	}
}

//-----------------------------------------------------------------------------
// Docking: ImGuiDockContext Docking/Undocking functions
//-----------------------------------------------------------------------------
// - DockContextQueueDock()
// - DockContextQueueUndockWindow()
// - DockContextQueueUndockNode()
// - DockContextQueueNotifyRemovedNode()
// - DockContextProcessDock()
// - DockContextProcessUndockWindow()
// - DockContextProcessUndockNode()
// - DockContextCalcDropPosForDocking()
//-----------------------------------------------------------------------------

DockContextQueueDock :: proc(ctx : ^ImGuiContext, target : ^ImGuiWindow, target_node : ^ImGuiDockNode, payload : ^ImGuiWindow, split_dir : ImGuiDir, split_ratio : f32, split_outer : bool)
{
	IM_ASSERT(target != payload)
	req : ImGuiDockRequest
	req.Type = ImGuiDockRequestType.ImGuiDockRequestType_Dock
	req.DockTargetWindow = target
	req.DockTargetNode = target_node
	req.DockPayload = payload
	req.DockSplitDir = split_dir
	req.DockSplitRatio = split_ratio
	req.DockSplitOuter = split_outer
	push_back(&ctx.DockContext.Requests, req)
}

DockContextQueueUndockWindow :: proc(ctx : ^ImGuiContext, window : ^ImGuiWindow)
{
	req : ImGuiDockRequest
	req.Type = ImGuiDockRequestType.ImGuiDockRequestType_Undock
	req.UndockTargetWindow = window
	push_back(&ctx.DockContext.Requests, req)
}

DockContextQueueUndockNode :: proc(ctx : ^ImGuiContext, node : ^ImGuiDockNode)
{
	req : ImGuiDockRequest
	req.Type = ImGuiDockRequestType.ImGuiDockRequestType_Undock
	req.UndockTargetNode = node
	push_back(&ctx.DockContext.Requests, req)
}

DockContextQueueNotifyRemovedNode :: proc(ctx : ^ImGuiContext, node : ^ImGuiDockNode)
{
	dc : ^ImGuiDockContext = &ctx.DockContext
	for req in dc.Requests { if req.DockTargetNode == node { req.Type = ImGuiDockRequestType.ImGuiDockRequestType_None } }
}

DockContextProcessDock :: proc(ctx : ^ImGuiContext, req : ^ImGuiDockRequest)
{
	IM_ASSERT((req.Type == ImGuiDockRequestType.ImGuiDockRequestType_Dock && req.DockPayload != nil) || (req.Type == ImGuiDockRequestType.ImGuiDockRequestType_Split && req.DockPayload == nil))
	IM_ASSERT(req.DockTargetWindow != nil || req.DockTargetNode != nil)

	g : ^ImGuiContext = ctx^
	IM_UNUSED(g)

	payload_window : ^ImGuiWindow = req.DockPayload; // Optional
	target_window : ^ImGuiWindow = req.DockTargetWindow
	node : ^ImGuiDockNode = req.DockTargetNode
	if payload_window { IMGUI_DEBUG_LOG_DOCKING("[docking] DockContextProcessDock node 0x%08X target '%s' dock window '%s', split_dir %d\n", node ? node.ID : 0, target_window ? target_window.Name : "NULL", payload_window.Name, req.DockSplitDir) }
	else { IMGUI_DEBUG_LOG_DOCKING("[docking] DockContextProcessDock node 0x%08X, split_dir %d\n", node ? node.ID : 0, req.DockSplitDir) }

	// Decide which Tab will be selected at the end of the operation
	next_selected_id : ImGuiID = 0
	payload_node : ^ImGuiDockNode = nil
	if payload_window {
		payload_node = payload_window.DockNodeAsHost
		payload_window.DockNodeAsHost = nil; // Important to clear this as the node will have its life as a child which might be merged/deleted later.
		if payload_node && IsLeafNode(payload_node) { next_selected_id = payload_node.TabBar.NextSelectedTabId ? payload_node.TabBar.NextSelectedTabId : payload_node.TabBar.SelectedTabId }
		if payload_node == nil { next_selected_id = payload_window.TabId }
	}

	// FIXME-DOCK: When we are trying to dock an existing single-window node into a loose window, transfer Node ID as well
	// When processing an interactive split, usually LastFrameAlive will be < g.FrameCount. But DockBuilder operations can make it ==.
	if node { IM_ASSERT(node.LastFrameAlive <= g.FrameCount) }
	if node && target_window && node == target_window.DockNodeAsHost { IM_ASSERT(node.Windows.Size > 0 || IsSplitNode(node) || IsCentralNode(node)) }

	// Create new node and add existing window to it
	if node == nil {
		node = DockContextAddNode(ctx, 0)
		node.Pos = target_window.Pos
		node.Size = target_window.Size
		if target_window.DockNodeAsHost == nil {
			DockNodeAddWindow(node, target_window, true)
			node.TabBar.Tabs[0].Flags &= !ImGuiTabItemFlagsPrivate_.ImGuiTabItemFlags_Unsorted
			target_window.DockIsActive = true
		}
	}

	split_dir : ImGuiDir = req.DockSplitDir
	if split_dir != ImGuiDir.ImGuiDir_None {
		// Split into two, one side will be our payload node unless we are dropping a loose window
		split_axis : ImGuiAxis = (split_dir == ImGuiDir.ImGuiDir_Left || split_dir == ImGuiDir.ImGuiDir_Right) ? ImGuiAxis.ImGuiAxis_X : ImGuiAxis.ImGuiAxis_Y
		split_inheritor_child_idx : i32 = (split_dir == ImGuiDir.ImGuiDir_Left || split_dir == ImGuiDir.ImGuiDir_Up) ? 1 : 0; // Current contents will be moved to the opposite side
		split_ratio : f32 = req.DockSplitRatio
		DockNodeTreeSplit(ctx, node, split_axis, split_inheritor_child_idx, split_ratio, payload_node); // payload_node may be NULL here!
		new_node : ^ImGuiDockNode = node.ChildNodes[split_inheritor_child_idx ~ 1]
		new_node.HostWindow = node.HostWindow
		node = new_node
	}
	SetLocalFlags(node, node.LocalFlags & !ImGuiDockNodeFlagsPrivate_.ImGuiDockNodeFlags_HiddenTabBar)

	if node != payload_node {
		// Create tab bar before we call DockNodeMoveWindows (which would attempt to move the old tab-bar, which would lead us to payload tabs wrongly appearing before target tabs!)
		if node.Windows.Size > 0 && node.TabBar == nil {
			DockNodeAddTabBar(node)
			for n : i32 = 0; n < node.Windows.Size; post_incr(&n) { TabBarAddTab(node.TabBar, ImGuiTabItemFlags_.ImGuiTabItemFlags_None, node.Windows[n]) }
		}

		if payload_node != nil {
			// Transfer full payload node (with 1+ child windows or child nodes)
			if IsSplitNode(payload_node) {
				if node.Windows.Size > 0 {
					// We can dock a split payload into a node that already has windows _only_ if our payload is a node tree with a single visible node.
					// In this situation, we move the windows of the target node into the currently visible node of the payload.
					// This allows us to preserve some of the underlying dock tree settings nicely.
					IM_ASSERT(payload_node.OnlyNodeWithWindows != nil); // The docking should have been blocked by DockNodePreviewDockSetup() early on and never submitted.
					visible_node : ^ImGuiDockNode = payload_node.OnlyNodeWithWindows
					if visible_node.TabBar { IM_ASSERT(visible_node.TabBar.Tabs.Size > 0) }
					DockNodeMoveWindows(node, visible_node)
					DockNodeMoveWindows(visible_node, node)
					DockSettingsRenameNodeReferences(node.ID, visible_node.ID)
				}
				if IsCentralNode(node) {
					// Central node property needs to be moved to a leaf node, pick the last focused one.
					// FIXME-DOCK: If we had to transfer other flags here, what would the policy be?
					last_focused_node : ^ImGuiDockNode = DockContextFindNodeByID(ctx, payload_node.LastFocusedNodeId)
					IM_ASSERT(last_focused_node != nil)
					last_focused_root_node : ^ImGuiDockNode = DockNodeGetRootNode(last_focused_node)
					IM_ASSERT(last_focused_root_node == DockNodeGetRootNode(payload_node))
					SetLocalFlags(last_focused_node, last_focused_node.LocalFlags | ImGuiDockNodeFlagsPrivate_.ImGuiDockNodeFlags_CentralNode)
					SetLocalFlags(node, node.LocalFlags & !ImGuiDockNodeFlagsPrivate_.ImGuiDockNodeFlags_CentralNode)
					last_focused_root_node.CentralNode = last_focused_node
				}

				IM_ASSERT(node.Windows.Size == 0)
				DockNodeMoveChildNodes(node, payload_node)
			}
			else {
				payload_dock_id : ImGuiID = payload_node.ID
				DockNodeMoveWindows(node, payload_node)
				DockSettingsRenameNodeReferences(payload_dock_id, node.ID)
			}
			DockContextRemoveNode(ctx, payload_node, true)
		}
		else if payload_window {
			// Transfer single window
			payload_dock_id : ImGuiID = payload_window.DockId
			node.VisibleWindow = payload_window
			DockNodeAddWindow(node, payload_window, true)
			if payload_dock_id != 0 { DockSettingsRenameNodeReferences(payload_dock_id, node.ID) }
		}
	}
	else {
		// When docking a floating single window node we want to reevaluate auto-hiding of the tab bar
		node.WantHiddenTabBarUpdate = true
	}

	// Update selection immediately
	if tab_bar : ^ImGuiTabBar = node.TabBar; tab_bar { tab_bar.NextSelectedTabId = next_selected_id }
	MarkIniSettingsDirty()
}

// Problem:
//   Undocking a large (~full screen) window would leave it so large that the bottom right sizing corner would more
//   than likely be off the screen and the window would be hard to resize to fit on screen. This can be particularly problematic
//   with 'ConfigWindowsMoveFromTitleBarOnly=true' and/or with 'ConfigWindowsResizeFromEdges=false' as well (the later can be
//   due to missing ImGuiBackendFlags_HasMouseCursors backend flag).
// Solution:
//   When undocking a window we currently force its maximum size to 90% of the host viewport or monitor.
// Reevaluate this when we implement preserving docked/undocked size ("docking_wip/undocked_size" branch).
FixLargeWindowsWhenUndocking :: proc(size : ^ImVec2, ref_viewport : ^ImGuiViewport) -> ImVec2
{
	if ref_viewport == nil { return size }

	g : ^ImGuiContext = GImGui^
	max_size : ImVec2 = ImTrunc(ref_viewport.WorkSize * 0.90)
	if g.ConfigFlagsCurrFrame & ImGuiConfigFlags_.ImGuiConfigFlags_ViewportsEnable {
		monitor : ^ImGuiPlatformMonitor = GetViewportPlatformMonitor(ref_viewport)
		max_size = ImTrunc(monitor.WorkSize * 0.90)
	}
	return ImMin(size, max_size)
}

DockContextProcessUndockWindow :: proc(ctx : ^ImGuiContext, window : ^ImGuiWindow, clear_persistent_docking_ref : bool)
{
	g : ^ImGuiContext = ctx^
	IMGUI_DEBUG_LOG_DOCKING("[docking] DockContextProcessUndockWindow window '%s', clear_persistent_docking_ref = %d\n", window.Name, clear_persistent_docking_ref)
	if window.DockNode { DockNodeRemoveWindow(window.DockNode, window, clear_persistent_docking_ref ? 0 : window.DockId) }
	else { window.DockId = 0 }
	window.Collapsed = false
	window.DockIsActive = false
	window.DockTabIsVisible = false; window.DockNodeIsVisible = window.DockTabIsVisible
	window.SizeFull = FixLargeWindowsWhenUndocking(window.SizeFull, window.Viewport); window.Size = window.SizeFull

	MarkIniSettingsDirty()
}

DockContextProcessUndockNode :: proc(ctx : ^ImGuiContext, node : ^ImGuiDockNode)
{
	g : ^ImGuiContext = ctx^
	IMGUI_DEBUG_LOG_DOCKING("[docking] DockContextProcessUndockNode node %08X\n", node.ID)
	IM_ASSERT(IsLeafNode(node))
	IM_ASSERT(node.Windows.Size >= 1)

	if IsRootNode(node) || IsCentralNode(node) {
		// In the case of a root node or central node, the node will have to stay in place. Create a new node to receive the payload.
		new_node : ^ImGuiDockNode = DockContextAddNode(ctx, 0)
		new_node.Pos = node.Pos
		new_node.Size = node.Size
		new_node.SizeRef = node.SizeRef
		DockNodeMoveWindows(new_node, node)
		DockSettingsRenameNodeReferences(node.ID, new_node.ID)
		node = new_node
	}
	else {
		// Otherwise extract our node and merge our sibling back into the parent node.
		IM_ASSERT(node.ParentNode.ChildNodes[0] == node || node.ParentNode.ChildNodes[1] == node)
		index_in_parent : i32 = (node.ParentNode.ChildNodes[0] == node) ? 0 : 1
		node.ParentNode.ChildNodes[index_in_parent] = nil
		DockNodeTreeMerge(ctx, node.ParentNode, node.ParentNode.ChildNodes[index_in_parent ~ 1])
		node.ParentNode.AuthorityForViewport = ImGuiDataAuthority_.ImGuiDataAuthority_Window; // The node that stays in place keeps the viewport, so our newly dragged out node will create a new viewport
		node.ParentNode = nil
	}
	for window in node.Windows {
		window.Flags &= !ImGuiWindowFlags_.ImGuiWindowFlags_ChildWindow
		if window.ParentWindow { find_erase(&window.ParentWindow.DC.ChildWindows, window) }
		UpdateWindowParentAndRootLinks(window, window.Flags, nil)
	}

	node.AuthorityForSize = ImGuiDataAuthority_.ImGuiDataAuthority_DockNode; node.AuthorityForPos = node.AuthorityForSize
	node.Size = FixLargeWindowsWhenUndocking(node.Size, node.Windows[0].Viewport)
	node.WantMouseMove = true
	MarkIniSettingsDirty()
}

// This is mostly used for automation.
DockContextCalcDropPosForDocking :: proc(target : ^ImGuiWindow, target_node : ^ImGuiDockNode, payload_window : ^ImGuiWindow, payload_node : ^ImGuiDockNode, split_dir : ImGuiDir, split_outer : bool, out_pos : ^ImVec2) -> bool
{
	if target != nil && target_node == nil { target_node = target.DockNode }

	// In DockNodePreviewDockSetup() for a root central node instead of showing both "inner" and "outer" drop rects
	// (which would be functionally identical) we only show the outer one. Reflect this here.
	if target_node && target_node.ParentNode == nil && IsCentralNode(target_node) && split_dir != ImGuiDir.ImGuiDir_None { split_outer = true }
	split_data : ImGuiDockPreviewData
	DockNodePreviewDockSetup(target, target_node, payload_window, payload_node, &split_data, false, split_outer)
	if IsInverted(&split_data.DropRectsDraw[split_dir + 1]) { return false }
	out_pos^ = GetCenter(&split_data.DropRectsDraw[split_dir + 1])
	return true
}

//-----------------------------------------------------------------------------
// Docking: ImGuiDockNode
//-----------------------------------------------------------------------------
// - DockNodeGetTabOrder()
// - DockNodeAddWindow()
// - DockNodeRemoveWindow()
// - DockNodeMoveChildNodes()
// - DockNodeMoveWindows()
// - DockNodeApplyPosSizeToWindows()
// - DockNodeHideHostWindow()
// - ImGuiDockNodeFindInfoResults
// - DockNodeFindInfo()
// - DockNodeFindWindowByID()
// - DockNodeUpdateFlagsAndCollapse()
// - DockNodeUpdateHasCentralNodeFlag()
// - DockNodeUpdateVisibleFlag()
// - DockNodeStartMouseMovingWindow()
// - DockNodeUpdate()
// - DockNodeUpdateWindowMenu()
// - DockNodeBeginAmendTabBar()
// - DockNodeEndAmendTabBar()
// - DockNodeUpdateTabBar()
// - DockNodeAddTabBar()
// - DockNodeRemoveTabBar()
// - DockNodeIsDropAllowedOne()
// - DockNodeIsDropAllowed()
// - DockNodeCalcTabBarLayout()
// - DockNodeCalcSplitRects()
// - DockNodeCalcDropRectsAndTestMousePos()
// - DockNodePreviewDockSetup()
// - DockNodePreviewDockRender()
//-----------------------------------------------------------------------------

ImGuiDockNode_init :: proc(this : ^ImGuiDockNode, id : ImGuiID)
{
	this.ID = id
	this.MergedFlags = ImGuiDockNodeFlags_.ImGuiDockNodeFlags_None; this.LocalFlagsInWindows = this.MergedFlags; this.LocalFlags = this.LocalFlagsInWindows; this.SharedFlags = this.LocalFlags
	this.ChildNodes[1] = nil; this.ChildNodes[0] = this.ChildNodes[1]; this.ParentNode = this.ChildNodes[0]
	this.TabBar = nil
	this.SplitAxis = ImGuiAxis.ImGuiAxis_None

	this.State = ImGuiDockNodeState.ImGuiDockNodeState_Unknown
	this.LastBgColor = IM_COL32_WHITE
	this.VisibleWindow = nil; this.HostWindow = this.VisibleWindow
	this.OnlyNodeWithWindows = nil; this.CentralNode = this.OnlyNodeWithWindows
	this.CountNodeWithWindows = 0
	this.LastFrameFocused = -1; this.LastFrameActive = this.LastFrameFocused; this.LastFrameAlive = this.LastFrameActive
	this.LastFocusedNodeId = 0
	this.SelectedTabId = 0
	this.WantCloseTabId = 0
	this.RefViewportId = 0
	this.AuthorityForSize = ImGuiDataAuthority_.ImGuiDataAuthority_DockNode; this.AuthorityForPos = this.AuthorityForSize
	this.AuthorityForViewport = ImGuiDataAuthority_.ImGuiDataAuthority_Auto
	this.IsVisible = true
	this.HasCentralNodeChild = false; this.HasWindowMenuButton = this.HasCentralNodeChild; this.HasCloseButton = this.HasWindowMenuButton; this.IsFocused = this.HasCloseButton
	this.IsBgDrawnThisFrame = false
	this.WantHiddenTabBarToggle = false; this.WantHiddenTabBarUpdate = this.WantHiddenTabBarToggle; this.WantMouseMove = this.WantHiddenTabBarUpdate; this.WantLockSizeOnce = this.WantMouseMove; this.WantCloseAll = this.WantLockSizeOnce
}

ImGuiDockNode_deinit :: proc(this : ^ImGuiDockNode)
{
	IM_DELETE(this.TabBar)
	this.TabBar = nil
	this.ChildNodes[1] = nil; this.ChildNodes[0] = this.ChildNodes[1]
}

DockNodeGetTabOrder :: proc(window : ^ImGuiWindow) -> i32
{
	tab_bar : ^ImGuiTabBar = window.DockNode.TabBar
	if tab_bar == nil { return -1 }
	tab : ^ImGuiTabItem = TabBarFindTabByID(tab_bar, window.TabId)
	return tab ? TabBarGetTabOrder(tab_bar, tab) : -1
}

DockNodeHideWindowDuringHostWindowCreation :: proc(window : ^ImGuiWindow)
{
	window.Hidden = true
	window.HiddenFramesCanSkipItems = window.Active ? 1 : 2
}

// ImGuiDockNode
DockNodeAddWindow :: proc(node : ^ImGuiDockNode, window : ^ImGuiWindow, add_to_tab_bar : bool)
{
	g : ^ImGuiContext = GImGui^; _ = g
	if window.DockNode {
		// Can overwrite an existing window->DockNode (e.g. pointing to a disabled DockSpace node)
		IM_ASSERT(window.DockNode.ID != node.ID)
		DockNodeRemoveWindow(window.DockNode, window, 0)
	}
	IM_ASSERT(window.DockNode == nil || window.DockNodeAsHost == nil)
	IMGUI_DEBUG_LOG_DOCKING("[docking] DockNodeAddWindow node 0x%08X window '%s'\n", node.ID, window.Name)

	// If more than 2 windows appeared on the same frame leading to the creation of a new hosting window,
	// we'll hide windows until the host window is ready. Hide the 1st window after its been output (so it is not visible for one frame).
	// We will call DockNodeHideWindowDuringHostWindowCreation() on ourselves in Begin()
	if node.HostWindow == nil && node.Windows.Size == 1 && node.Windows[0].WasActive == false { DockNodeHideWindowDuringHostWindowCreation(node.Windows[0]) }

	push_back(&node.Windows, window)
	node.WantHiddenTabBarUpdate = true
	window.DockNode = node
	window.DockId = node.ID
	window.DockIsActive = (node.Windows.Size > 1)
	window.DockTabWantClose = false

	// When reactivating a node with one or two loose window, the window pos/size/viewport are authoritative over the node storage.
	// In particular it is important we init the viewport from the first window so we don't create two viewports and drop one.
	if node.HostWindow == nil && IsFloatingNode(node) {
		if node.AuthorityForPos == ImGuiDataAuthority_.ImGuiDataAuthority_Auto { node.AuthorityForPos = ImGuiDataAuthority_.ImGuiDataAuthority_Window }
		if node.AuthorityForSize == ImGuiDataAuthority_.ImGuiDataAuthority_Auto { node.AuthorityForSize = ImGuiDataAuthority_.ImGuiDataAuthority_Window }
		if node.AuthorityForViewport == ImGuiDataAuthority_.ImGuiDataAuthority_Auto { node.AuthorityForViewport = ImGuiDataAuthority_.ImGuiDataAuthority_Window }
	}

	// Add to tab bar if requested
	if add_to_tab_bar {
		if node.TabBar == nil {
			DockNodeAddTabBar(node)
			node.TabBar.NextSelectedTabId = node.SelectedTabId; node.TabBar.SelectedTabId = node.TabBar.NextSelectedTabId

			// Add existing windows
			for n : i32 = 0; n < node.Windows.Size - 1; post_incr(&n) { TabBarAddTab(node.TabBar, ImGuiTabItemFlags_.ImGuiTabItemFlags_None, node.Windows[n]) }
		}
		TabBarAddTab(node.TabBar, ImGuiTabItemFlagsPrivate_.ImGuiTabItemFlags_Unsorted, window)
	}

	DockNodeUpdateVisibleFlag(node)

	// Update this without waiting for the next time we Begin() in the window, so our host window will have the proper title bar color on its first frame.
	if node.HostWindow { UpdateWindowParentAndRootLinks(window, window.Flags | ImGuiWindowFlags_.ImGuiWindowFlags_ChildWindow, node.HostWindow) }
}

DockNodeRemoveWindow :: proc(node : ^ImGuiDockNode, window : ^ImGuiWindow, save_dock_id : ImGuiID)
{
	g : ^ImGuiContext = GImGui^
	IM_ASSERT(window.DockNode == node)
	//IM_ASSERT(window->RootWindowDockTree == node->HostWindow);
	//IM_ASSERT(window->LastFrameActive < g.FrameCount);    // We may call this from Begin()
	IM_ASSERT(save_dock_id == 0 || save_dock_id == node.ID)
	IMGUI_DEBUG_LOG_DOCKING("[docking] DockNodeRemoveWindow node 0x%08X window '%s'\n", node.ID, window.Name)

	window.DockNode = nil
	window.DockTabWantClose = false; window.DockIsActive = window.DockTabWantClose
	window.DockId = save_dock_id
	window.Flags &= !ImGuiWindowFlags_.ImGuiWindowFlags_ChildWindow
	if window.ParentWindow { find_erase(&window.ParentWindow.DC.ChildWindows, window) }
	UpdateWindowParentAndRootLinks(window, window.Flags, nil); // Update immediately

	if node.HostWindow && node.HostWindow.ViewportOwned {
		// When undocking from a user interaction this will always run in NewFrame() and have not much effect.
		// But mid-frame, if we clear viewport we need to mark window as hidden as well.
		window.Viewport = nil
		window.ViewportId = 0
		window.ViewportOwned = false
		window.Hidden = true
	}

	// Remove window
	erased : bool = false
	for n : i32 = 0; n < node.Windows.Size; post_incr(&n) { if node.Windows[n] == window {
	erase(&node.Windows, node.Windows.Data + n)
	erased = true
	break
} }

	if !erased { IM_ASSERT(erased) }
	if node.VisibleWindow == window { node.VisibleWindow = nil }

	// Remove tab and possibly tab bar
	node.WantHiddenTabBarUpdate = true
	if node.TabBar {
		TabBarRemoveTab(node.TabBar, window.TabId)
		tab_count_threshold_for_tab_bar : i32 = IsCentralNode(node) ? 1 : 2
		if node.Windows.Size < tab_count_threshold_for_tab_bar { DockNodeRemoveTabBar(node) }
	}

	if node.Windows.Size == 0 && !IsCentralNode(node) && !IsDockSpace(node) && window.DockId != node.ID {
		// Automatic dock node delete themselves if they are not holding at least one tab
		DockContextRemoveNode(&g, node, true)
		return
	}

	if node.Windows.Size == 1 && !IsCentralNode(node) && node.HostWindow {
		remaining_window : ^ImGuiWindow = node.Windows[0]
		// Note: we used to transport viewport ownership here.
		remaining_window.Collapsed = node.HostWindow.Collapsed
	}

	// Update visibility immediately is required so the DockNodeUpdateRemoveInactiveChilds() processing can reflect changes up the tree
	DockNodeUpdateVisibleFlag(node)
}

DockNodeMoveChildNodes :: proc(dst_node : ^ImGuiDockNode, src_node : ^ImGuiDockNode)
{
	IM_ASSERT(dst_node.Windows.Size == 0)
	dst_node.ChildNodes[0] = src_node.ChildNodes[0]
	dst_node.ChildNodes[1] = src_node.ChildNodes[1]
	if dst_node.ChildNodes[0] { dst_node.ChildNodes[0].ParentNode = dst_node }
	if dst_node.ChildNodes[1] { dst_node.ChildNodes[1].ParentNode = dst_node }
	dst_node.SplitAxis = src_node.SplitAxis
	dst_node.SizeRef = src_node.SizeRef
	src_node.ChildNodes[1] = nil; src_node.ChildNodes[0] = src_node.ChildNodes[1]
}

DockNodeMoveWindows :: proc(dst_node : ^ImGuiDockNode, src_node : ^ImGuiDockNode)
{
	// Insert tabs in the same orders as currently ordered (node->Windows isn't ordered)
	IM_ASSERT(src_node && dst_node && dst_node != src_node)
	src_tab_bar : ^ImGuiTabBar = src_node.TabBar
	if src_tab_bar != nil { IM_ASSERT(src_node.Windows.Size <= src_node.TabBar.Tabs.Size) }

	// If the dst_node is empty we can just move the entire tab bar (to preserve selection, scrolling, etc.)
	move_tab_bar : bool = (src_tab_bar != nil) && (dst_node.TabBar == nil)
	if move_tab_bar {
		dst_node.TabBar = src_node.TabBar
		src_node.TabBar = nil
	}

	// Tab order is not important here, it is preserved by sorting in DockNodeUpdateTabBar().
	for window in src_node.Windows {
		window.DockNode = nil
		window.DockIsActive = false
		DockNodeAddWindow(dst_node, window, !move_tab_bar)
	}

	clear(&src_node.Windows)

	if !move_tab_bar && src_node.TabBar {
		if dst_node.TabBar { dst_node.TabBar.SelectedTabId = src_node.TabBar.SelectedTabId }
		DockNodeRemoveTabBar(src_node)
	}
}

DockNodeApplyPosSizeToWindows :: proc(node : ^ImGuiDockNode)
{
	for window in node.Windows {
		SetWindowPos(window, node.Pos, ImGuiCond_.ImGuiCond_Always); // We don't assign directly to Pos because it can break the calculation of SizeContents on next frame
		SetWindowSize(window, node.Size, ImGuiCond_.ImGuiCond_Always)
	}
}

DockNodeHideHostWindow :: proc(node : ^ImGuiDockNode)
{
	if node.HostWindow {
		if node.HostWindow.DockNodeAsHost == node { node.HostWindow.DockNodeAsHost = nil }
		node.HostWindow = nil
	}

	if node.Windows.Size == 1 {
		node.VisibleWindow = node.Windows[0]
		node.Windows[0].DockIsActive = false
	}

	if node.TabBar { DockNodeRemoveTabBar(node) }
}

// Search function called once by root node in DockNodeUpdate()
ImGuiDockNodeTreeInfo :: struct {
	CentralNode : ^ImGuiDockNode,
	FirstNodeWithWindows : ^ImGuiDockNode,
	CountNodesWithWindows : i32,
}

//ImGuiWindowClass  WindowClassForMerges;

ImGuiDockNodeTreeInfo_init :: proc(this : ^ImGuiDockNodeTreeInfo) { memset(this, 0, size_of(this)) }

DockNodeFindInfo :: proc(node : ^ImGuiDockNode, info : ^ImGuiDockNodeTreeInfo)
{
	if node.Windows.Size > 0 {
		if info.FirstNodeWithWindows == nil { info.FirstNodeWithWindows = node }
		post_incr(&info.CountNodesWithWindows)
	}
	if IsCentralNode(node) {
		IM_ASSERT(info.CentralNode == nil); // Should be only one
		IM_ASSERT(IsLeafNode(node) && "If you get this assert: please submit .ini file + repro of actions leading to this.")
		info.CentralNode = node
	}
	if info.CountNodesWithWindows > 1 && info.CentralNode != nil { return }
	if node.ChildNodes[0] { DockNodeFindInfo(node.ChildNodes[0], info) }
	if node.ChildNodes[1] { DockNodeFindInfo(node.ChildNodes[1], info) }
}

DockNodeFindWindowByID :: proc(node : ^ImGuiDockNode, id : ImGuiID) -> ^ImGuiWindow
{
	IM_ASSERT(id != 0)
	for window in node.Windows { if window.ID == id { return window } }

	return nil
}

// - Remove inactive windows/nodes.
// - Update visibility flag.
DockNodeUpdateFlagsAndCollapse :: proc(node : ^ImGuiDockNode)
{
	g : ^ImGuiContext = GImGui^
	IM_ASSERT(node.ParentNode == nil || node.ParentNode.ChildNodes[0] == node || node.ParentNode.ChildNodes[1] == node)

	// Inherit most flags
	if node.ParentNode { node.SharedFlags = node.ParentNode.SharedFlags & ImGuiDockNodeFlagsPrivate_.ImGuiDockNodeFlags_SharedFlagsInheritMask_ }

	// Recurse into children
	// There is the possibility that one of our child becoming empty will delete itself and moving its sibling contents into 'node'.
	// If 'node->ChildNode[0]' delete itself, then 'node->ChildNode[1]->Windows' will be moved into 'node'
	// If 'node->ChildNode[1]' delete itself, then 'node->ChildNode[0]->Windows' will be moved into 'node' and the "remove inactive windows" loop will have run twice on those windows (harmless)
	node.HasCentralNodeChild = false
	if node.ChildNodes[0] { DockNodeUpdateFlagsAndCollapse(node.ChildNodes[0]) }
	if node.ChildNodes[1] { DockNodeUpdateFlagsAndCollapse(node.ChildNodes[1]) }

	// Remove inactive windows, collapse nodes
	// Merge node flags overrides stored in windows
	node.LocalFlagsInWindows = ImGuiDockNodeFlags_.ImGuiDockNodeFlags_None
	for window_n : i32 = 0; window_n < node.Windows.Size; post_incr(&window_n) {
		window : ^ImGuiWindow = node.Windows[window_n]
		IM_ASSERT(window.DockNode == node)

		node_was_active : bool = (node.LastFrameActive + 1 == g.FrameCount)
		remove : bool = false
		remove |= node_was_active && (window.LastFrameActive + 1 < g.FrameCount)
		remove |= node_was_active && (node.WantCloseAll || node.WantCloseTabId == window.TabId) && window.HasCloseButton && !(window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_UnsavedDocument); // Submit all _expected_ closure from last frame
		remove |= (window.DockTabWantClose)
		if remove {
			window.DockTabWantClose = false
			if node.Windows.Size == 1 && !IsCentralNode(node) {
				DockNodeHideHostWindow(node)
				node.State = ImGuiDockNodeState.ImGuiDockNodeState_HostWindowHiddenBecauseSingleWindow
				DockNodeRemoveWindow(node, window, node.ID); // Will delete the node so it'll be invalid on return
				return
			}
			DockNodeRemoveWindow(node, window, node.ID)
			post_decr(&window_n)
			continue
		}

		// FIXME-DOCKING: Missing policies for conflict resolution, hence the "Experimental" tag on this.
		//node->LocalFlagsInWindow &= ~window->WindowClass.DockNodeFlagsOverrideClear;
		node.LocalFlagsInWindows |= window.WindowClass.DockNodeFlagsOverrideSet
	}

	UpdateMergedFlags(node)

	// Auto-hide tab bar option
	node_flags : ImGuiDockNodeFlags = node.MergedFlags
	if node.WantHiddenTabBarUpdate && node.Windows.Size == 1 && (node_flags & ImGuiDockNodeFlags_.ImGuiDockNodeFlags_AutoHideTabBar) && !IsHiddenTabBar(node) { node.WantHiddenTabBarToggle = true }
	node.WantHiddenTabBarUpdate = false

	// Cancel toggling if we know our tab bar is enforced to be hidden at all times
	if node.WantHiddenTabBarToggle && node.VisibleWindow && (node.VisibleWindow.WindowClass.DockNodeFlagsOverrideSet & ImGuiDockNodeFlagsPrivate_.ImGuiDockNodeFlags_HiddenTabBar) { node.WantHiddenTabBarToggle = false }

	// Apply toggles at a single point of the frame (here!)
	if node.Windows.Size > 1 { SetLocalFlags(node, node.LocalFlags & !ImGuiDockNodeFlagsPrivate_.ImGuiDockNodeFlags_HiddenTabBar) }
	else if node.WantHiddenTabBarToggle { SetLocalFlags(node, node.LocalFlags ~ ImGuiDockNodeFlagsPrivate_.ImGuiDockNodeFlags_HiddenTabBar) }
	node.WantHiddenTabBarToggle = false

	DockNodeUpdateVisibleFlag(node)
}

// This is rarely called as DockNodeUpdateForRootNode() generally does it most frames.
DockNodeUpdateHasCentralNodeChild :: proc(node : ^ImGuiDockNode)
{
	node.HasCentralNodeChild = false
	if node.ChildNodes[0] { DockNodeUpdateHasCentralNodeChild(node.ChildNodes[0]) }
	if node.ChildNodes[1] { DockNodeUpdateHasCentralNodeChild(node.ChildNodes[1]) }
	if IsRootNode(node) {
		mark_node : ^ImGuiDockNode = node.CentralNode
		for mark_node {
			mark_node.HasCentralNodeChild = true
			mark_node = mark_node.ParentNode
		}
	}
}

DockNodeUpdateVisibleFlag :: proc(node : ^ImGuiDockNode)
{
	// Update visibility flag
	is_visible : bool = (node.ParentNode == nil) ? IsDockSpace(node) : IsCentralNode(node)
	is_visible |= (node.Windows.Size > 0)
	is_visible |= (node.ChildNodes[0] && node.ChildNodes[0].IsVisible)
	is_visible |= (node.ChildNodes[1] && node.ChildNodes[1].IsVisible)
	node.IsVisible = is_visible
}

DockNodeStartMouseMovingWindow :: proc(node : ^ImGuiDockNode, window : ^ImGuiWindow)
{
	g : ^ImGuiContext = GImGui^
	IM_ASSERT(node.WantMouseMove == true)
	StartMouseMovingWindow(window)
	g.ActiveIdClickOffset = g.IO.MouseClickedPos[0] - node.Pos
	g.MovingWindow = window; // If we are docked into a non moveable root window, StartMouseMovingWindow() won't set g.MovingWindow. Override that decision.
	node.WantMouseMove = false
}

// Update CentralNode, OnlyNodeWithWindows, LastFocusedNodeID. Copy window class.
DockNodeUpdateForRootNode :: proc(node : ^ImGuiDockNode)
{
	DockNodeUpdateFlagsAndCollapse(node)

	// - Setup central node pointers
	// - Find if there's only a single visible window in the hierarchy (in which case we need to display a regular title bar -> FIXME-DOCK: that last part is not done yet!)
	// Cannot merge this with DockNodeUpdateFlagsAndCollapse() because FirstNodeWithWindows is found after window removal and child collapsing
	info : ImGuiDockNodeTreeInfo
	DockNodeFindInfo(node, &info)
	node.CentralNode = info.CentralNode
	node.OnlyNodeWithWindows = (info.CountNodesWithWindows == 1) ? info.FirstNodeWithWindows : nil
	node.CountNodeWithWindows = info.CountNodesWithWindows
	if node.LastFocusedNodeId == 0 && info.FirstNodeWithWindows != nil { node.LastFocusedNodeId = info.FirstNodeWithWindows.ID }

	// Copy the window class from of our first window so it can be used for proper dock filtering.
	// When node has mixed windows, prioritize the class with the most constraint (DockingAllowUnclassed = false) as the reference to copy.
	// FIXME-DOCK: We don't recurse properly, this code could be reworked to work from DockNodeUpdateScanRec.
	if first_node_with_windows : ^ImGuiDockNode = info.FirstNodeWithWindows; first_node_with_windows {
		node.WindowClass = first_node_with_windows.Windows[0].WindowClass
		for n : i32 = 1; n < first_node_with_windows.Windows.Size; post_incr(&n) { if first_node_with_windows.Windows[n].WindowClass.DockingAllowUnclassed == false {
	node.WindowClass = first_node_with_windows.Windows[n].WindowClass
	break
} }
	}

	mark_node : ^ImGuiDockNode = node.CentralNode
	for mark_node {
		mark_node.HasCentralNodeChild = true
		mark_node = mark_node.ParentNode
	}
}

DockNodeSetupHostWindow :: proc(node : ^ImGuiDockNode, host_window : ^ImGuiWindow)
{
	// Remove ourselves from any previous different host window
	// This can happen if a user mistakenly does (see #4295 for details):
	//  - N+0: DockBuilderAddNode(id, 0)    // missing ImGuiDockNodeFlags_DockSpace
	//  - N+1: NewFrame()                   // will create floating host window for that node
	//  - N+1: DockSpace(id)                // requalify node as dockspace, moving host window
	if node.HostWindow && node.HostWindow != host_window && node.HostWindow.DockNodeAsHost == node { node.HostWindow.DockNodeAsHost = nil }

	host_window.DockNodeAsHost = node
	node.HostWindow = host_window
}

DockNodeUpdate :: proc(node : ^ImGuiDockNode)
{
	g : ^ImGuiContext = GImGui^
	IM_ASSERT(node.LastFrameActive != g.FrameCount)
	node.LastFrameAlive = g.FrameCount
	node.IsBgDrawnThisFrame = false

	node.OnlyNodeWithWindows = nil; node.CentralNode = node.OnlyNodeWithWindows
	if IsRootNode(node) { DockNodeUpdateForRootNode(node) }

	// Remove tab bar if not needed
	if node.TabBar && IsNoTabBar(node) { DockNodeRemoveTabBar(node) }

	// Early out for hidden root dock nodes (when all DockId references are in inactive windows, or there is only 1 floating window holding on the DockId)
	want_to_hide_host_window : bool = false
	if IsFloatingNode(node) {
		if node.Windows.Size <= 1 && IsLeafNode(node) { if !g.IO.ConfigDockingAlwaysTabBar && (node.Windows.Size == 0 || !node.Windows[0].WindowClass.DockingAlwaysTabBar) { want_to_hide_host_window = true } }
		if node.CountNodeWithWindows == 0 { want_to_hide_host_window = true }
	}
	if want_to_hide_host_window {
		if node.Windows.Size == 1 {
			// Floating window pos/size is authoritative
			single_window : ^ImGuiWindow = node.Windows[0]
			node.Pos = single_window.Pos
			node.Size = single_window.SizeFull
			node.AuthorityForViewport = ImGuiDataAuthority_.ImGuiDataAuthority_Window; node.AuthorityForSize = node.AuthorityForViewport; node.AuthorityForPos = node.AuthorityForSize

			// Transfer focus immediately so when we revert to a regular window it is immediately selected
			if node.HostWindow && g.NavWindow == node.HostWindow { FocusWindow(single_window) }
			if node.HostWindow {
				IMGUI_DEBUG_LOG_VIEWPORT("[viewport] Node %08X transfer Viewport %08X->%08X to Window '%s'\n", node.ID, node.HostWindow.Viewport.ID, single_window.ID, single_window.Name)
				single_window.Viewport = node.HostWindow.Viewport
				single_window.ViewportId = node.HostWindow.ViewportId
				if node.HostWindow.ViewportOwned {
					single_window.Viewport.ID = single_window.ID
					single_window.Viewport.Window = single_window
					single_window.ViewportOwned = true
				}
			}
			node.RefViewportId = single_window.ViewportId
		}

		DockNodeHideHostWindow(node)
		node.State = ImGuiDockNodeState.ImGuiDockNodeState_HostWindowHiddenBecauseSingleWindow
		node.WantCloseAll = false
		node.WantCloseTabId = 0
		node.HasWindowMenuButton = false; node.HasCloseButton = node.HasWindowMenuButton
		node.LastFrameActive = g.FrameCount

		if node.WantMouseMove && node.Windows.Size == 1 { DockNodeStartMouseMovingWindow(node, node.Windows[0]) }
		return
	}

	// In some circumstance we will defer creating the host window (so everything will be kept hidden),
	// while the expected visible window is resizing itself.
	// This is important for first-time (no ini settings restored) single window when io.ConfigDockingAlwaysTabBar is enabled,
	// otherwise the node ends up using the minimum window size. Effectively those windows will take an extra frame to show up:
	//   N+0: Begin(): window created (with no known size), node is created
	//   N+1: DockNodeUpdate(): node skip creating host window / Begin(): window size applied, not visible
	//   N+2: DockNodeUpdate(): node can create host window / Begin(): window becomes visible
	// We could remove this frame if we could reliably calculate the expected window size during node update, before the Begin() code.
	// It would require a generalization of CalcWindowExpectedSize(), probably extracting code away from Begin().
	// In reality it isn't very important as user quickly ends up with size data in .ini file.
	if node.IsVisible && node.HostWindow == nil && IsFloatingNode(node) && IsLeafNode(node) {
		IM_ASSERT(node.Windows.Size > 0)
		ref_window : ^ImGuiWindow = nil
		if node.SelectedTabId != 0 {
			// Note that we prune single-window-node settings on .ini loading, so this is generally 0 for them!ref_window = DockNodeFindWindowByID(node, node.SelectedTabId)
		}
		if ref_window == nil { ref_window = node.Windows[0] }
		if ref_window.AutoFitFramesX > 0 || ref_window.AutoFitFramesY > 0 {
			node.State = ImGuiDockNodeState.ImGuiDockNodeState_HostWindowHiddenBecauseWindowsAreResizing
			return
		}
	}

	node_flags : ImGuiDockNodeFlags = node.MergedFlags

	// Decide if the node will have a close button and a window menu button
	node.HasWindowMenuButton = (node.Windows.Size > 0) && (node_flags & ImGuiDockNodeFlagsPrivate_.ImGuiDockNodeFlags_NoWindowMenuButton) == 0
	node.HasCloseButton = false
	for window in node.Windows {
		// FIXME-DOCK: Setting DockIsActive here means that for single active window in a leaf node, DockIsActive will be cleared until the next Begin() call.
		node.HasCloseButton |= window.HasCloseButton
		window.DockIsActive = (node.Windows.Size > 1)
	}

	if ImGuiDockNodeFlags_NoCloseButton : ^node_flags; ImGuiDockNodeFlags_NoCloseButton { node.HasCloseButton = false }

	// Bind or create host window
	host_window : ^ImGuiWindow = nil
	beginned_into_host_window : bool = false
	if IsDockSpace(node) {
		// [Explicit root dockspace node]
		IM_ASSERT(node.HostWindow)
		host_window = node.HostWindow
	}
	else {
		// [Automatic root or child nodes]
		if IsRootNode(node) && node.IsVisible {
			ref_window : ^ImGuiWindow = (node.Windows.Size > 0) ? node.Windows[0] : nil

			// Sync Pos
			if node.AuthorityForPos == ImGuiDataAuthority_.ImGuiDataAuthority_Window && ref_window { SetNextWindowPos(ref_window.Pos) }
			else if node.AuthorityForPos == ImGuiDataAuthority_.ImGuiDataAuthority_DockNode { SetNextWindowPos(node.Pos) }

			// Sync Size
			if node.AuthorityForSize == ImGuiDataAuthority_.ImGuiDataAuthority_Window && ref_window { SetNextWindowSize(ref_window.SizeFull) }
			else if node.AuthorityForSize == ImGuiDataAuthority_.ImGuiDataAuthority_DockNode { SetNextWindowSize(node.Size) }

			// Sync Collapsed
			if node.AuthorityForSize == ImGuiDataAuthority_.ImGuiDataAuthority_Window && ref_window { SetNextWindowCollapsed(ref_window.Collapsed) }

			// Sync Viewport
			if node.AuthorityForViewport == ImGuiDataAuthority_.ImGuiDataAuthority_Window && ref_window { SetNextWindowViewport(ref_window.ViewportId) }
			else if node.AuthorityForViewport == ImGuiDataAuthority_.ImGuiDataAuthority_Window && node.RefViewportId != 0 { SetNextWindowViewport(node.RefViewportId) }

			SetNextWindowClass(&node.WindowClass)

			// Begin into the host window
			window_label : [20]u8
			DockNodeGetHostWindowTitle(node, window_label, IM_ARRAYSIZE(window_label))
			window_flags : ImGuiWindowFlags = ImGuiWindowFlags_.ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_.ImGuiWindowFlags_NoScrollWithMouse | ImGuiWindowFlags_.ImGuiWindowFlags_DockNodeHost
			window_flags |= ImGuiWindowFlags_.ImGuiWindowFlags_NoFocusOnAppearing
			window_flags |= ImGuiWindowFlags_.ImGuiWindowFlags_NoSavedSettings | ImGuiWindowFlags_.ImGuiWindowFlags_NoNavFocus | ImGuiWindowFlags_.ImGuiWindowFlags_NoCollapse
			window_flags |= ImGuiWindowFlags_.ImGuiWindowFlags_NoTitleBar

			SetNextWindowBgAlpha(0.0); // Don't set ImGuiWindowFlags_NoBackground because it disables borders
			PushStyleVar(ImGuiStyleVar_.ImGuiStyleVar_WindowPadding, ImVec2(0, 0))
			Begin(window_label, nil, window_flags)
			PopStyleVar()
			beginned_into_host_window = true

			host_window = g.CurrentWindow
			DockNodeSetupHostWindow(node, host_window)
			host_window.DC.CursorPos = host_window.Pos
			node.Pos = host_window.Pos
			node.Size = host_window.Size

			// We set ImGuiWindowFlags_NoFocusOnAppearing because we don't want the host window to take full focus (e.g. steal NavWindow)
			// But we still it bring it to the front of display. There's no way to choose this precise behavior via window flags.
			// One simple case to ponder if: window A has a toggle to create windows B/C/D. Dock B/C/D together, clear the toggle and enable it again.
			// When reappearing B/C/D will request focus and be moved to the top of the display pile, but they are not linked to the dock host window
			// during the frame they appear. The dock host window would keep its old display order, and the sorting in EndFrame would move B/C/D back
			// after the dock host window, losing their top-most status.
			if node.HostWindow.Appearing { BringWindowToDisplayFront(node.HostWindow) }

			node.AuthorityForViewport = ImGuiDataAuthority_.ImGuiDataAuthority_Auto; node.AuthorityForSize = node.AuthorityForViewport; node.AuthorityForPos = node.AuthorityForSize
		}
		else if node.ParentNode {
			host_window = node.ParentNode.HostWindow; node.HostWindow = host_window
			node.AuthorityForViewport = ImGuiDataAuthority_.ImGuiDataAuthority_Auto; node.AuthorityForSize = node.AuthorityForViewport; node.AuthorityForPos = node.AuthorityForSize
		}
		if node.WantMouseMove && node.HostWindow { DockNodeStartMouseMovingWindow(node, node.HostWindow) }
	}
	node.RefViewportId = 0; // Clear when we have a host window

	// Update focused node (the one whose title bar is highlight) within a node tree
	if IsSplitNode(node) { IM_ASSERT(node.TabBar == nil) }
	if IsRootNode(node) { if p_window : ^ImGuiWindow = g.NavWindow ? g.NavWindow.RootWindow : nil; p_window { for p_window != nil && p_window.DockNode != nil {
	p_node : ^ImGuiDockNode = DockNodeGetRootNode(p_window.DockNode)
	if p_node == node {
		node.LastFocusedNodeId = p_window.DockNode.ID; // Note: not using root node ID!
		break
	}
	p_window = p_node.HostWindow ? p_node.HostWindow.RootWindow : nil
} } }

	// Register a hit-test hole in the window unless we are currently dragging a window that is compatible with our dockspace
	central_node : ^ImGuiDockNode = node.CentralNode
	central_node_hole : bool = IsRootNode(node) && host_window && (node_flags & ImGuiDockNodeFlags_.ImGuiDockNodeFlags_PassthruCentralNode) != 0 && central_node != nil && IsEmpty(central_node)
	central_node_hole_register_hit_test_hole : bool = central_node_hole
	if central_node_hole { if payload : ^ImGuiPayload = GetDragDropPayload(); payload { if IsDataType(payload, IMGUI_PAYLOAD_TYPE_WINDOW) && DockNodeIsDropAllowed(host_window, cast(^^ImGuiWindow) payload.Data^) { central_node_hole_register_hit_test_hole = false } } }
	if central_node_hole_register_hit_test_hole {
		// We add a little padding to match the "resize from edges" behavior and allow grabbing the splitter easily.
		// (But we only add it if there's something else on the other side of the hole, otherwise for e.g. fullscreen
		// covering passthru node we'd have a gap on the edge not covered by the hole)
		IM_ASSERT(IsDockSpace(node)); // We cannot pass this flag without the DockSpace() api. Testing this because we also setup the hole in host_window->ParentNode
		root_node : ^ImGuiDockNode = DockNodeGetRootNode(central_node)
		root_rect : ImRect; init(&root_rect, root_node.Pos, root_node.Pos + root_node.Size)
		hole_rect : ImRect; init(&hole_rect, central_node.Pos, central_node.Pos + central_node.Size)
		if hole_rect.Min.x > root_rect.Min.x { hole_rect.Min.x += WINDOWS_HOVER_PADDING }
		if hole_rect.Max.x < root_rect.Max.x { hole_rect.Max.x -= WINDOWS_HOVER_PADDING }
		if hole_rect.Min.y > root_rect.Min.y { hole_rect.Min.y += WINDOWS_HOVER_PADDING }
		if hole_rect.Max.y < root_rect.Max.y { hole_rect.Max.y -= WINDOWS_HOVER_PADDING }
		//GetForegroundDrawList()->AddRect(hole_rect.Min, hole_rect.Max, IM_COL32(255, 0, 0, 255));
		if central_node_hole && !IsInverted(&hole_rect) {
			SetWindowHitTestHole(host_window, hole_rect.Min, hole_rect.Max - hole_rect.Min)
			if host_window.ParentWindow { SetWindowHitTestHole(host_window.ParentWindow, hole_rect.Min, hole_rect.Max - hole_rect.Min) }
		}
	}

	// Update position/size, process and draw resizing splitters
	if IsRootNode(node) && host_window {
		DockNodeTreeUpdatePosSize(node, host_window.Pos, host_window.Size)
		PushStyleColor(ImGuiCol_.ImGuiCol_Separator, g.Style.Colors[ImGuiCol_.ImGuiCol_Border])
		PushStyleColor(ImGuiCol_.ImGuiCol_SeparatorActive, g.Style.Colors[ImGuiCol_.ImGuiCol_ResizeGripActive])
		PushStyleColor(ImGuiCol_.ImGuiCol_SeparatorHovered, g.Style.Colors[ImGuiCol_.ImGuiCol_ResizeGripHovered])
		DockNodeTreeUpdateSplitter(node)
		PopStyleColor(3)
	}

	// Draw empty node background (currently can only be the Central Node)
	if host_window && IsEmpty(node) && node.IsVisible {
		ChannelsSetCurrent(host_window.DrawList, DOCKING_HOST_DRAW_CHANNEL_BG)
		node.LastBgColor = (node_flags & ImGuiDockNodeFlags_.ImGuiDockNodeFlags_PassthruCentralNode) ? 0 : GetColorU32(ImGuiCol_.ImGuiCol_DockingEmptyBg)
		if node.LastBgColor != 0 { AddRectFilled(host_window.DrawList, node.Pos, node.Pos + node.Size, node.LastBgColor) }
		node.IsBgDrawnThisFrame = true
	}

	// Draw whole dockspace background if ImGuiDockNodeFlags_PassthruCentralNode if set.
	// We need to draw a background at the root level if requested by ImGuiDockNodeFlags_PassthruCentralNode, but we will only know the correct pos/size
	// _after_ processing the resizing splitters. So we are using the DrawList channel splitting facility to submit drawing primitives out of order!
	render_dockspace_bg : bool = IsRootNode(node) && host_window && (node_flags & ImGuiDockNodeFlags_.ImGuiDockNodeFlags_PassthruCentralNode) != 0
	if render_dockspace_bg && node.IsVisible {
		ChannelsSetCurrent(host_window.DrawList, DOCKING_HOST_DRAW_CHANNEL_BG)
		if central_node_hole { RenderRectFilledWithHole(host_window.DrawList, Rect(node), Rect(central_node), GetColorU32(ImGuiCol_.ImGuiCol_WindowBg), 0.0) }
		else { AddRectFilled(host_window.DrawList, node.Pos, node.Pos + node.Size, GetColorU32(ImGuiCol_.ImGuiCol_WindowBg), 0.0) }
	}

	// Draw and populate Tab Bar
	if host_window { ChannelsSetCurrent(host_window.DrawList, DOCKING_HOST_DRAW_CHANNEL_FG) }
	if host_window && node.Windows.Size > 0 {
		DockNodeUpdateTabBar(node, host_window)
	}
	else {
		node.WantCloseAll = false
		node.WantCloseTabId = 0
		node.IsFocused = false
	}
	if node.TabBar && node.TabBar.SelectedTabId { node.SelectedTabId = node.TabBar.SelectedTabId }
	else if node.Windows.Size > 0 { node.SelectedTabId = node.Windows[0].TabId }

	// Draw payload drop target
	if host_window && node.IsVisible { if IsRootNode(node) && (g.MovingWindow == nil || g.MovingWindow.RootWindowDockTree != host_window) { BeginDockableDragDropTarget(host_window) } }

	// We update this after DockNodeUpdateTabBar()
	node.LastFrameActive = g.FrameCount

	// Recurse into children
	// FIXME-DOCK FIXME-OPT: Should not need to recurse into children
	if host_window {
		if node.ChildNodes[0] { DockNodeUpdate(node.ChildNodes[0]) }
		if node.ChildNodes[1] { DockNodeUpdate(node.ChildNodes[1]) }

		// Render outer borders last (after the tab bar)
		if IsRootNode(node) { RenderWindowOuterBorders(host_window) }
	}

	// End host window
	if beginned_into_host_window {
		//-V1020End()
	}
}

// Compare TabItem nodes given the last known DockOrder (will persist in .ini file as hint), used to sort tabs when multiple tabs are added on the same frame.
TabItemComparerByDockOrder :: proc(lhs : rawptr, rhs : rawptr) -> i32
{
	a : ^ImGuiWindow = (cast(^ImGuiTabItem) lhs).Window
	b : ^ImGuiWindow = (cast(^ImGuiTabItem) rhs).Window
	if d : i32 = ((a.DockOrder == -1) ? INT_MAX : a.DockOrder) - ((b.DockOrder == -1) ? INT_MAX : b.DockOrder); d { return d }
	return (a.BeginOrderWithinContext - b.BeginOrderWithinContext)
}

// Default handler for g.DockNodeWindowMenuHandler(): display the list of windows for a given dock-node.
// This is exceptionally stored in a function pointer to also user applications to tweak this menu (undocumented)
// Custom overrides may want to decorate, group, sort entries.
// Please note those are internal structures: if you copy this expect occasional breakage.
// (if you don't need to modify the "Tabs.Size == 1" behavior/path it is recommend you call this function in your handler)
DockNodeWindowMenuHandler_Default :: proc(ctx : ^ImGuiContext, node : ^ImGuiDockNode, tab_bar : ^ImGuiTabBar)
{
	IM_UNUSED(ctx)
	if tab_bar.Tabs.Size == 1 {
		// "Hide tab bar" option. Being one of our rare user-facing string we pull it from a table.
		if MenuItem(LocalizeGetMsg(ImGuiLocKey.ImGuiLocKey_DockingHideTabBar), nil, IsHiddenTabBar(node)) { node.WantHiddenTabBarToggle = true }
	}
	else {
		// Display a selectable list of windows in this docking node
		for tab_n : i32 = 0; tab_n < tab_bar.Tabs.Size; post_incr(&tab_n) {
			tab : ^ImGuiTabItem = &tab_bar.Tabs[tab_n]
			if tab.Flags & ImGuiTabItemFlagsPrivate_.ImGuiTabItemFlags_Button { continue }
			if Selectable(TabBarGetTabName(tab_bar, tab), tab.ID == tab_bar.SelectedTabId) { TabBarQueueFocus(tab_bar, tab) }
			SameLine()
			Text("   ")
		}
	}
}

DockNodeWindowMenuUpdate :: proc(node : ^ImGuiDockNode, tab_bar : ^ImGuiTabBar)
{
	// Try to position the menu so it is more likely to stays within the same viewport
	g : ^ImGuiContext = GImGui^
	if g.Style.WindowMenuButtonPosition == ImGuiDir.ImGuiDir_Left { SetNextWindowPos(ImVec2(node.Pos.x, node.Pos.y + GetFrameHeight()), ImGuiCond_.ImGuiCond_Always, ImVec2(0.0, 0.0)) }
	else { SetNextWindowPos(ImVec2(node.Pos.x + node.Size.x, node.Pos.y + GetFrameHeight()), ImGuiCond_.ImGuiCond_Always, ImVec2(1.0, 0.0)) }
	if BeginPopup("#WindowMenu") {
		node.IsFocused = true
		DockNodeWindowMenuHandler(&g, &g, node, tab_bar)
		EndPopup()
	}
}

// User helper to append/amend into a dock node tab bar. Most commonly used to add e.g. a "+" button.
DockNodeBeginAmendTabBar :: proc(node : ^ImGuiDockNode) -> bool
{
	if node.TabBar == nil || node.HostWindow == nil { return false }
	if node.MergedFlags & ImGuiDockNodeFlags_.ImGuiDockNodeFlags_KeepAliveOnly { return false }
	if node.TabBar.ID == 0 { return false }
	Begin(node.HostWindow.Name)
	PushOverrideID(node.ID)
	ret : bool = BeginTabBarEx(node.TabBar, node.TabBar.BarRect, node.TabBar.Flags)
	IM_UNUSED(ret)
	IM_ASSERT(ret)
	return true
}

DockNodeEndAmendTabBar :: proc()
{
	EndTabBar()
	PopID()
	End()
}

IsDockNodeTitleBarHighlighted :: proc(node : ^ImGuiDockNode, root_node : ^ImGuiDockNode) -> bool
{
	// CTRL+Tab highlight (only highlighting leaf node, not whole hierarchy)
	g : ^ImGuiContext = GImGui^
	if g.NavWindowingTarget { return (g.NavWindowingTarget.DockNode == node) }

	// FIXME-DOCKING: May want alternative to treat central node void differently? e.g. if (g.NavWindow == host_window)
	if g.NavWindow && root_node.LastFocusedNodeId == node.ID {
		// FIXME: This could all be backed in RootWindowForTitleBarHighlight? Probably need to reorganize for both dock nodes + other RootWindowForTitleBarHighlight users (not-node)
		parent_window : ^ImGuiWindow = g.NavWindow.RootWindow
		for parent_window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_ChildMenu { parent_window = parent_window.ParentWindow.RootWindow }

		start_parent_node : ^ImGuiDockNode = parent_window.DockNodeAsHost ? parent_window.DockNodeAsHost : parent_window.DockNode
		for parent_node : ^ImGuiDockNode = start_parent_node; parent_node != nil; parent_node = parent_node.HostWindow ? parent_node.HostWindow.RootWindow.DockNode : nil { parent_node = DockNodeGetRootNode(parent_node); if parent_node == root_node { return true } }
	}
	return false
}

// Submit the tab bar corresponding to a dock node and various housekeeping details.
DockNodeUpdateTabBar :: proc(node : ^ImGuiDockNode, host_window : ^ImGuiWindow)
{
	g : ^ImGuiContext = GImGui^
	style : ^ImGuiStyle = g.Style

	node_was_active : bool = (node.LastFrameActive + 1 == g.FrameCount)
	closed_all : bool = node.WantCloseAll && node_was_active
	closed_one : ImGuiID = node.WantCloseTabId && node_was_active
	node.WantCloseAll = false
	node.WantCloseTabId = 0

	// Decide if we should use a focused title bar color
	is_focused : bool = false
	root_node : ^ImGuiDockNode = DockNodeGetRootNode(node)
	if IsDockNodeTitleBarHighlighted(node, root_node) { is_focused = true }

	// Hidden tab bar will show a triangle on the upper-left (in Begin)
	if IsHiddenTabBar(node) || IsNoTabBar(node) {
		node.VisibleWindow = (node.Windows.Size > 0) ? node.Windows[0] : nil
		node.IsFocused = is_focused
		if is_focused { node.LastFrameFocused = g.FrameCount }
		if node.VisibleWindow {
			// Notify root of visible window (used to display title in OS task bar)
			if is_focused || root_node.VisibleWindow == nil { root_node.VisibleWindow = node.VisibleWindow }
			if node.TabBar { node.TabBar.VisibleTabId = node.VisibleWindow.TabId }
		}
		return
	}

	// Move ourselves to the Menu layer (so we can be accessed by tapping Alt) + undo SkipItems flag in order to draw over the title bar even if the window is collapsed
	backup_skip_item : bool = host_window.SkipItems
	if !IsDockSpace(node) {
		host_window.SkipItems = false
		host_window.DC.NavLayerCurrent = ImGuiNavLayer.ImGuiNavLayer_Menu
	}

	// Use PushOverrideID() instead of PushID() to use the node id _without_ the host window ID.
	// This is to facilitate computing those ID from the outside, and will affect more or less only the ID of the collapse button, popup and tabs,
	// as docked windows themselves will override the stack with their own root ID.
	PushOverrideID(node.ID)
	tab_bar : ^ImGuiTabBar = node.TabBar
	tab_bar_is_recreated : bool = (tab_bar == nil); // Tab bar are automatically destroyed when a node gets hidden
	if tab_bar == nil {
		DockNodeAddTabBar(node)
		tab_bar = node.TabBar
	}

	focus_tab_id : ImGuiID = 0
	node.IsFocused = is_focused

	node_flags : ImGuiDockNodeFlags = node.MergedFlags
	has_window_menu_button : bool = (node_flags & ImGuiDockNodeFlagsPrivate_.ImGuiDockNodeFlags_NoWindowMenuButton) == 0 && (style.WindowMenuButtonPosition != ImGuiDir.ImGuiDir_None)

	// In a dock node, the Collapse Button turns into the Window Menu button.
	// FIXME-DOCK FIXME-OPT: Could we recycle popups id across multiple dock nodes?
	if has_window_menu_button && IsPopupOpen("#WindowMenu") {
		next_selected_tab_id : ImGuiID = tab_bar.NextSelectedTabId
		DockNodeWindowMenuUpdate(node, tab_bar)
		if tab_bar.NextSelectedTabId != 0 && tab_bar.NextSelectedTabId != next_selected_tab_id { focus_tab_id = tab_bar.NextSelectedTabId }
		is_focused |= node.IsFocused
	}

	// Layout
	title_bar_rect : ImRect; tab_bar_rect : ImRect
	window_menu_button_pos : ImVec2
	close_button_pos : ImVec2
	DockNodeCalcTabBarLayout(node, &title_bar_rect, &tab_bar_rect, &window_menu_button_pos, &close_button_pos)

	// Submit new tabs, they will be added as Unsorted and sorted below based on relative DockOrder value.
	tabs_count_old : i32 = tab_bar.Tabs.Size
	for window_n : i32 = 0; window_n < node.Windows.Size; post_incr(&window_n) {
		window : ^ImGuiWindow = node.Windows[window_n]
		if TabBarFindTabByID(tab_bar, window.TabId) == nil { TabBarAddTab(tab_bar, ImGuiTabItemFlagsPrivate_.ImGuiTabItemFlags_Unsorted, window) }
	}

	// Title bar
	if is_focused { node.LastFrameFocused = g.FrameCount }
	title_bar_col : ImU32 = GetColorU32(host_window.Collapsed ? ImGuiCol_.ImGuiCol_TitleBgCollapsed : is_focused ? ImGuiCol_.ImGuiCol_TitleBgActive : ImGuiCol_.ImGuiCol_TitleBg)
	rounding_flags : ImDrawFlags = CalcRoundingFlagsForRectInRect(title_bar_rect, Rect(host_window), g.Style.DockingSeparatorSize)
	AddRectFilled(host_window.DrawList, title_bar_rect.Min, title_bar_rect.Max, title_bar_col, host_window.WindowRounding, rounding_flags)

	// Docking/Collapse button
	if has_window_menu_button {
		if CollapseButton(GetID(host_window, "#COLLAPSE"), window_menu_button_pos, node) {
			// == DockNodeGetWindowMenuButtonId(node)OpenPopup("#WindowMenu")
		}
		if IsItemActive() { focus_tab_id = tab_bar.SelectedTabId }
		if IsItemHovered(ImGuiHoveredFlags_.ImGuiHoveredFlags_ForTooltip | ImGuiHoveredFlags_.ImGuiHoveredFlags_DelayNormal) && g.HoveredIdTimer > 0.5 { SetTooltip("%s", LocalizeGetMsg(ImGuiLocKey.ImGuiLocKey_DockingDragToUndockOrMoveNode)) }
	}

	// If multiple tabs are appearing on the same frame, sort them based on their persistent DockOrder value
	tabs_unsorted_start : i32 = tab_bar.Tabs.Size
	for tab_n : i32 = tab_bar.Tabs.Size - 1; tab_n >= 0 && (tab_bar.Tabs[tab_n].Flags & ImGuiTabItemFlagsPrivate_.ImGuiTabItemFlags_Unsorted); post_decr(&tab_n) {
		// FIXME-DOCK: Consider only clearing the flag after the tab has been alive for a few consecutive frames, allowing late comers to not break sorting?
		tab_bar.Tabs[tab_n].Flags &= !ImGuiTabItemFlagsPrivate_.ImGuiTabItemFlags_Unsorted
		tabs_unsorted_start = tab_n
	}

	if tab_bar.Tabs.Size > tabs_unsorted_start {
		IMGUI_DEBUG_LOG_DOCKING("[docking] In node 0x%08X: %d new appearing tabs:%s\n", node.ID, tab_bar.Tabs.Size - tabs_unsorted_start, (tab_bar.Tabs.Size > tabs_unsorted_start + 1) ? " (will sort)" : "")
		for tab_n : i32 = tabs_unsorted_start; tab_n < tab_bar.Tabs.Size; post_incr(&tab_n) {
			tab : ^ImGuiTabItem = &tab_bar.Tabs[tab_n]
			IM_UNUSED(tab)
			IMGUI_DEBUG_LOG_DOCKING("[docking] - Tab 0x%08X '%s' Order %d\n", tab.ID, TabBarGetTabName(tab_bar, tab), tab.Window ? tab.Window.DockOrder : -1)
		}

		IMGUI_DEBUG_LOG_DOCKING("[docking] SelectedTabId = 0x%08X, NavWindow->TabId = 0x%08X\n", node.SelectedTabId, g.NavWindow ? g.NavWindow.TabId : -1)
		if tab_bar.Tabs.Size > tabs_unsorted_start + 1 { ImQsort(tab_bar.Tabs.Data + tabs_unsorted_start, tab_bar.Tabs.Size - tabs_unsorted_start, size_of(ImGuiTabItem), TabItemComparerByDockOrder) }
	}

	// Apply NavWindow focus back to the tab bar
	if g.NavWindow && g.NavWindow.RootWindow.DockNode == node { tab_bar.SelectedTabId = g.NavWindow.RootWindow.TabId }

	// Selected newly added tabs, or persistent tab ID if the tab bar was just recreated
	if tab_bar_is_recreated && TabBarFindTabByID(tab_bar, node.SelectedTabId) != nil { tab_bar.NextSelectedTabId = node.SelectedTabId; tab_bar.SelectedTabId = tab_bar.NextSelectedTabId }
	else if tab_bar.Tabs.Size > tabs_count_old { tab_bar.NextSelectedTabId = back(&tab_bar.Tabs).Window.TabId; tab_bar.SelectedTabId = tab_bar.NextSelectedTabId }

	// Begin tab bar
	tab_bar_flags : ImGuiTabBarFlags = ImGuiTabBarFlags_.ImGuiTabBarFlags_Reorderable | ImGuiTabBarFlags_.ImGuiTabBarFlags_AutoSelectNewTabs; // | ImGuiTabBarFlags_NoTabListScrollingButtons);
	tab_bar_flags |= ImGuiTabBarFlagsPrivate_.ImGuiTabBarFlags_SaveSettings | ImGuiTabBarFlagsPrivate_.ImGuiTabBarFlags_DockNode; // | ImGuiTabBarFlags_FittingPolicyScroll;
	tab_bar_flags |= ImGuiTabBarFlags_.ImGuiTabBarFlags_DrawSelectedOverline
	if !host_window.Collapsed && is_focused { tab_bar_flags |= ImGuiTabBarFlagsPrivate_.ImGuiTabBarFlags_IsFocused }
	tab_bar.ID = GetID("#TabBar")
	tab_bar.SeparatorMinX = node.Pos.x + host_window.WindowBorderSize; // Separator cover the whole node width
	tab_bar.SeparatorMaxX = node.Pos.x + node.Size.x - host_window.WindowBorderSize
	BeginTabBarEx(tab_bar, tab_bar_rect, tab_bar_flags)
	//host_window->DrawList->AddRect(tab_bar_rect.Min, tab_bar_rect.Max, IM_COL32(255,0,255,255));

	// Backup style colors
	backup_style_cols : [ImGuiWindowDockStyleCol.ImGuiWindowDockStyleCol_COUNT]ImVec4
	for color_n : i32 = 0; color_n < ImGuiWindowDockStyleCol.ImGuiWindowDockStyleCol_COUNT; post_incr(&color_n) { backup_style_cols[color_n] = g.Style.Colors[GWindowDockStyleColors[color_n]] }

	// Submit actual tabs
	node.VisibleWindow = nil
	for window_n : i32 = 0; window_n < node.Windows.Size; post_incr(&window_n) {
		window : ^ImGuiWindow = node.Windows[window_n]
		if (closed_all || closed_one == window.TabId) && window.HasCloseButton && !(window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_UnsavedDocument) { continue }
		if window.LastFrameActive + 1 >= g.FrameCount || !node_was_active {
			tab_item_flags : ImGuiTabItemFlags = 0
			tab_item_flags |= window.WindowClass.TabItemFlagsOverrideSet
			if window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_UnsavedDocument { tab_item_flags |= ImGuiTabItemFlags_.ImGuiTabItemFlags_UnsavedDocument }
			if tab_bar.Flags & ImGuiTabBarFlags_.ImGuiTabBarFlags_NoCloseWithMiddleMouseButton { tab_item_flags |= ImGuiTabItemFlags_.ImGuiTabItemFlags_NoCloseWithMiddleMouseButton }

			// Apply stored style overrides for the window
			for color_n : i32 = 0; color_n < ImGuiWindowDockStyleCol.ImGuiWindowDockStyleCol_COUNT; post_incr(&color_n) { g.Style.Colors[GWindowDockStyleColors[color_n]] = ColorConvertU32ToFloat4(window.DockStyle.Colors[color_n]) }

			// Note that TabItemEx() calls TabBarCalcTabID() so our tab item ID will ignore the current ID stack (rightly so)
			tab_open : bool = true
			TabItemEx(tab_bar, window.Name, window.HasCloseButton ? &tab_open : nil, tab_item_flags, window)
			if !tab_open { node.WantCloseTabId = window.TabId }
			if tab_bar.VisibleTabId == window.TabId { node.VisibleWindow = window }

			// Store last item data so it can be queried with IsItemXXX functions after the user Begin() call
			window.DockTabItemStatusFlags = g.LastItemData.StatusFlags
			window.DockTabItemRect = g.LastItemData.Rect

			// Update navigation ID on menu layer
			if g.NavWindow && g.NavWindow.RootWindow == window && (window.DC.NavLayersActiveMask & (1 << ImGuiNavLayer.ImGuiNavLayer_Menu)) == 0 { host_window.NavLastIds[1] = window.TabId }
		}
	}

	// Restore style colors
	for color_n : i32 = 0; color_n < ImGuiWindowDockStyleCol.ImGuiWindowDockStyleCol_COUNT; post_incr(&color_n) { g.Style.Colors[GWindowDockStyleColors[color_n]] = backup_style_cols[color_n] }

	// Notify root of visible window (used to display title in OS task bar)
	if node.VisibleWindow { if is_focused || root_node.VisibleWindow == nil { root_node.VisibleWindow = node.VisibleWindow } }

	// Close button (after VisibleWindow was updated)
	// Note that VisibleWindow may have been overrided by CTRL+Tabbing, so VisibleWindow->TabId may be != from tab_bar->SelectedTabId
	close_button_is_enabled : bool = node.HasCloseButton && node.VisibleWindow && node.VisibleWindow.HasCloseButton
	close_button_is_visible : bool = node.HasCloseButton
	//const bool close_button_is_visible = close_button_is_enabled; // Most people would expect this behavior of not even showing the button (leaving a hole since we can't claim that space as other windows in the tba bar have one)
	if close_button_is_visible {
		if !close_button_is_enabled {
			PushItemFlag(ImGuiItemFlagsPrivate_.ImGuiItemFlags_Disabled, true)
			PushStyleColor(ImGuiCol_.ImGuiCol_Text, style.Colors[ImGuiCol_.ImGuiCol_Text] * ImVec4(1.0, 1.0, 1.0, 0.4))
		}
		if CloseButton(GetID(host_window, "#CLOSE"), close_button_pos) {
			node.WantCloseAll = true
			for n : i32 = 0; n < tab_bar.Tabs.Size; post_incr(&n) { TabBarCloseTab(tab_bar, &tab_bar.Tabs[n]) }
		}
		//if (IsItemActive())
		//    focus_tab_id = tab_bar->SelectedTabId;
		if !close_button_is_enabled {
			PopStyleColor()
			PopItemFlag()
		}
	}

	// When clicking on the title bar outside of tabs, we still focus the selected tab for that node
	// FIXME: TabItems submitted earlier use AllowItemOverlap so we manually perform a more specific test for now (hovered || held) in order to not cover them.
	title_bar_id : ImGuiID = GetID(host_window, "#TITLEBAR")
	if g.HoveredId == 0 || g.HoveredId == title_bar_id || g.ActiveId == title_bar_id {
		// AllowOverlap mode required for appending into dock node tab bar,
		// otherwise dragging window will steal HoveredId and amended tabs cannot get them.
		held : bool
		KeepAliveID(title_bar_id)
		ButtonBehavior(title_bar_rect, title_bar_id, nil, &held, ImGuiButtonFlagsPrivate_.ImGuiButtonFlags_AllowOverlap)
		if g.HoveredId == title_bar_id {
			g.LastItemData.ID = title_bar_id
		}
		if held {
			if IsMouseClicked(0) { focus_tab_id = tab_bar.SelectedTabId }

			// Forward moving request to selected window
			if tab : ^ImGuiTabItem = TabBarFindTabByID(tab_bar, tab_bar.SelectedTabId); tab {
				// Undock from tab bar empty space
				StartMouseMovingWindowOrNode(tab.Window ? tab.Window : node.HostWindow, node, false)
			}
		}
	}

	// Forward focus from host node to selected window
	//if (is_focused && g.NavWindow == host_window && !g.NavWindowingTarget)
	//    focus_tab_id = tab_bar->SelectedTabId;

	// When clicked on a tab we requested focus to the docked child
	// This overrides the value set by "forward focus from host node to selected window".
	if tab_bar.NextSelectedTabId { focus_tab_id = tab_bar.NextSelectedTabId }

	// Apply navigation focus
	if focus_tab_id != 0 { if tab : ^ImGuiTabItem = TabBarFindTabByID(tab_bar, focus_tab_id); tab { if tab.Window {
	FocusWindow(tab.Window)
	NavInitWindow(tab.Window, false)
} } }

	EndTabBar()
	PopID()

	// Restore SkipItems flag
	if !IsDockSpace(node) {
		host_window.DC.NavLayerCurrent = ImGuiNavLayer.ImGuiNavLayer_Main
		host_window.SkipItems = backup_skip_item
	}
}

DockNodeAddTabBar :: proc(node : ^ImGuiDockNode)
{
	IM_ASSERT(node.TabBar == nil)
	node.TabBar = IM_NEW(ImGuiTabBar)
}

DockNodeRemoveTabBar :: proc(node : ^ImGuiDockNode)
{
	if node.TabBar == nil { return }
	IM_DELETE(node.TabBar)
	node.TabBar = nil
}

DockNodeIsDropAllowedOne :: proc(payload : ^ImGuiWindow, host_window : ^ImGuiWindow) -> bool
{
	if host_window.DockNodeAsHost && IsDockSpace(host_window.DockNodeAsHost) && payload.BeginOrderWithinContext < host_window.BeginOrderWithinContext { return false }

	host_class : ^ImGuiWindowClass = host_window.DockNodeAsHost ? &host_window.DockNodeAsHost.WindowClass : &host_window.WindowClass
	payload_class : ^ImGuiWindowClass = &payload.WindowClass
	if host_class.ClassId != payload_class.ClassId {
		pass : bool = false
		if host_class.ClassId != 0 && host_class.DockingAllowUnclassed && payload_class.ClassId == 0 { pass = true }
		if payload_class.ClassId != 0 && payload_class.DockingAllowUnclassed && host_class.ClassId == 0 { pass = true }
		if !pass { return false }
	}

	// Prevent docking any window created above a popup
	// Technically we should support it (e.g. in the case of a long-lived modal window that had fancy docking features),
	// by e.g. adding a 'if (!ImGui::IsWindowWithinBeginStackOf(host_window, popup_window))' test.
	// But it would requires more work on our end because the dock host windows is technically created in NewFrame()
	// and our ->ParentXXX and ->RootXXX pointers inside windows are currently mislading or lacking.
	g : ^ImGuiContext = GImGui^
	for i : i32 = g.OpenPopupStack.Size - 1; i >= 0; post_decr(&i) { if popup_window : ^ImGuiWindow = g.OpenPopupStack[i].Window; popup_window { if IsWindowWithinBeginStackOf(payload, popup_window) {
	// Payload is created from within a popup begin stack.return false
} } }

	return true
}

DockNodeIsDropAllowed :: proc(host_window : ^ImGuiWindow, root_payload : ^ImGuiWindow) -> bool
{
	if root_payload.DockNodeAsHost && IsSplitNode(root_payload.DockNodeAsHost) {
		// FIXME-DOCK: Missing filteringreturn true
	}

	payload_count : i32 = root_payload.DockNodeAsHost ? root_payload.DockNodeAsHost.Windows.Size : 1
	for payload_n : i32 = 0; payload_n < payload_count; post_incr(&payload_n) {
		payload : ^ImGuiWindow = root_payload.DockNodeAsHost ? root_payload.DockNodeAsHost.Windows[payload_n] : root_payload
		if DockNodeIsDropAllowedOne(payload, host_window) { return true }
	}

	return false
}

// window menu button == collapse button when not in a dock node.
// FIXME: This is similar to RenderWindowTitleBarContents(), may want to share code.
DockNodeCalcTabBarLayout :: proc(node : ^ImGuiDockNode, out_title_rect : ^ImRect, out_tab_bar_rect : ^ImRect, out_window_menu_button_pos : ^ImVec2, out_close_button_pos : ^ImVec2)
{
	g : ^ImGuiContext = GImGui^
	style : ^ImGuiStyle = g.Style

	r : ImRect = ImRect(node.Pos.x, node.Pos.y, node.Pos.x + node.Size.x, node.Pos.y + g.FontSize + g.Style.FramePadding.y * 2.0)
	if out_title_rect { out_title_rect^ = r }

	r.Min.x += style.WindowBorderSize
	r.Max.x -= style.WindowBorderSize

	button_sz : f32 = g.FontSize
	r.Min.x += style.FramePadding.x
	r.Max.x -= style.FramePadding.x
	window_menu_button_pos : ImVec2 = ImVec2(r.Min.x, r.Min.y + style.FramePadding.y)
	if node.HasCloseButton {
		if out_close_button_pos { out_close_button_pos^ = ImVec2(r.Max.x - button_sz, r.Min.y + style.FramePadding.y) }
		r.Max.x -= button_sz + style.ItemInnerSpacing.x
	}
	if node.HasWindowMenuButton && style.WindowMenuButtonPosition == ImGuiDir.ImGuiDir_Left {
		r.Min.x += button_sz + style.ItemInnerSpacing.x
	}
	else if node.HasWindowMenuButton && style.WindowMenuButtonPosition == ImGuiDir.ImGuiDir_Right {
		window_menu_button_pos = ImVec2(r.Max.x - button_sz, r.Min.y + style.FramePadding.y)
		r.Max.x -= button_sz + style.ItemInnerSpacing.x
	}
	if out_tab_bar_rect { out_tab_bar_rect^ = r }
	if out_window_menu_button_pos { out_window_menu_button_pos^ = window_menu_button_pos }
}

DockNodeCalcSplitRects :: proc(pos_old : ^ImVec2, size_old : ^ImVec2, pos_new : ^ImVec2, size_new : ^ImVec2, dir : ImGuiDir, size_new_desired : ImVec2)
{
	g : ^ImGuiContext = GImGui^
	dock_spacing : f32 = g.Style.ItemInnerSpacing.x
	axis : ImGuiAxis = (dir == ImGuiDir.ImGuiDir_Left || dir == ImGuiDir.ImGuiDir_Right) ? ImGuiAxis.ImGuiAxis_X : ImGuiAxis.ImGuiAxis_Y
	pos_new[axis ~ 1] = pos_old[axis ~ 1]
	size_new[axis ~ 1] = size_old[axis ~ 1]

	// Distribute size on given axis (with a desired size or equally)
	w_avail : f32 = size_old[axis] - dock_spacing
	if size_new_desired[axis] > 0.0 && size_new_desired[axis] <= w_avail * 0.5 {
		size_new[axis] = size_new_desired[axis]
		size_old[axis] = IM_TRUNC(w_avail - size_new[axis])
	}
	else {
		size_new[axis] = IM_TRUNC(w_avail * 0.5)
		size_old[axis] = IM_TRUNC(w_avail - size_new[axis])
	}

	// Position each node
	if dir == ImGuiDir.ImGuiDir_Right || dir == ImGuiDir.ImGuiDir_Down {
		pos_new[axis] = pos_old[axis] + size_old[axis] + dock_spacing
	}
	else if dir == ImGuiDir.ImGuiDir_Left || dir == ImGuiDir.ImGuiDir_Up {
		pos_new[axis] = pos_old[axis]
		pos_old[axis] = pos_new[axis] + size_new[axis] + dock_spacing
	}
}

// Retrieve the drop rectangles for a given direction or for the center + perform hit testing.
DockNodeCalcDropRectsAndTestMousePos :: proc(parent : ^ImRect, dir : ImGuiDir, out_r : ^ImRect, outer_docking : bool, test_mouse_pos : ^ImVec2) -> bool
{
	g : ^ImGuiContext = GImGui^

	parent_smaller_axis : f32 = ImMin(GetWidth(&parent), GetHeight(&parent))
	hs_for_central_nodes : f32 = ImMin(g.FontSize * 1.5, ImMax(g.FontSize * 0.5, parent_smaller_axis / 8.0))
	hs_w : f32; // Half-size, longer axis
	hs_h : f32; // Half-size, smaller axis
	off : ImVec2; // Distance from edge or center
	if outer_docking {
		//hs_w = ImTrunc(ImClamp(parent_smaller_axis - hs_for_central_nodes * 4.0f, g.FontSize * 0.5f, g.FontSize * 8.0f));
		//hs_h = ImTrunc(hs_w * 0.15f);
		//off = ImVec2(ImTrunc(parent.GetWidth() * 0.5f - GetFrameHeightWithSpacing() * 1.4f - hs_h), ImTrunc(parent.GetHeight() * 0.5f - GetFrameHeightWithSpacing() * 1.4f - hs_h));
		hs_w = ImTrunc(hs_for_central_nodes * 1.50)
		hs_h = ImTrunc(hs_for_central_nodes * 0.80)
		off = ImTrunc(ImVec2(GetWidth(&parent) * 0.5 - hs_h, GetHeight(&parent) * 0.5 - hs_h))
	}
	else {
		hs_w = ImTrunc(hs_for_central_nodes)
		hs_h = ImTrunc(hs_for_central_nodes * 0.90)
		off = ImTrunc(ImVec2(hs_w * 2.40, hs_w * 2.40))
	}

	c : ImVec2 = ImTrunc(GetCenter(&parent))
	if dir == ImGuiDir.ImGuiDir_None { out_r = ImRect(c.x - hs_w, c.y - hs_w, c.x + hs_w, c.y + hs_w) }
	else if dir == ImGuiDir.ImGuiDir_Up { out_r = ImRect(c.x - hs_w, c.y - off.y - hs_h, c.x + hs_w, c.y - off.y + hs_h) }
	else if dir == ImGuiDir.ImGuiDir_Down { out_r = ImRect(c.x - hs_w, c.y + off.y - hs_h, c.x + hs_w, c.y + off.y + hs_h) }
	else if dir == ImGuiDir.ImGuiDir_Left { out_r = ImRect(c.x - off.x - hs_h, c.y - hs_w, c.x - off.x + hs_h, c.y + hs_w) }
	else if dir == ImGuiDir.ImGuiDir_Right { out_r = ImRect(c.x + off.x - hs_h, c.y - hs_w, c.x + off.x + hs_h, c.y + hs_w) }

	if test_mouse_pos == nil { return false }

	hit_r : ImRect = out_r
	if !outer_docking {
		// Custom hit testing for the 5-way selection, designed to reduce flickering when moving diagonally between sides
		Expand(&hit_r, ImTrunc(hs_w * 0.30))
		mouse_delta : ImVec2 = (test_mouse_pos^ - c)
		mouse_delta_len2 : f32 = ImLengthSqr(mouse_delta)
		r_threshold_center : f32 = hs_w * 1.4
		r_threshold_sides : f32 = hs_w * (1.4 + 1.2)
		if mouse_delta_len2 < r_threshold_center * r_threshold_center { return (dir == ImGuiDir.ImGuiDir_None) }
		if mouse_delta_len2 < r_threshold_sides * r_threshold_sides { return (dir == ImGetDirQuadrantFromDelta(mouse_delta.x, mouse_delta.y)) }
	}
	return Contains(&hit_r, test_mouse_pos^)
}

// host_node may be NULL if the window doesn't have a DockNode already.
// FIXME-DOCK: This is misnamed since it's also doing the filtering.
DockNodePreviewDockSetup :: proc(host_window : ^ImGuiWindow, host_node : ^ImGuiDockNode, payload_window : ^ImGuiWindow, payload_node : ^ImGuiDockNode, data : ^ImGuiDockPreviewData, is_explicit_target : bool, is_outer_docking : bool)
{
	g : ^ImGuiContext = GImGui^

	// There is an edge case when docking into a dockspace which only has inactive nodes.
	// In this case DockNodeTreeFindNodeByPos() will have selected a leaf node which is inactive.
	// Because the inactive leaf node doesn't have proper pos/size yet, we'll use the root node as reference.
	if payload_node == nil { payload_node = payload_window.DockNodeAsHost }
	ref_node_for_rect : ^ImGuiDockNode = (host_node && !host_node.IsVisible) ? DockNodeGetRootNode(host_node) : host_node
	if ref_node_for_rect { IM_ASSERT(ref_node_for_rect.IsVisible == true) }

	// Filter, figure out where we are allowed to dock
	src_node_flags : ImGuiDockNodeFlags = payload_node ? payload_node.MergedFlags : payload_window.WindowClass.DockNodeFlagsOverrideSet
	dst_node_flags : ImGuiDockNodeFlags = host_node ? host_node.MergedFlags : host_window.WindowClass.DockNodeFlagsOverrideSet
	data.IsCenterAvailable = true
	if is_outer_docking { data.IsCenterAvailable = false }
	else if ImGuiDockNodeFlags_NoDockingOverMe : ^dst_node_flags; ImGuiDockNodeFlags_NoDockingOverMe { data.IsCenterAvailable = false }
	else if host_node && (dst_node_flags & ImGuiDockNodeFlags_.ImGuiDockNodeFlags_NoDockingOverCentralNode) && IsCentralNode(host_node) { data.IsCenterAvailable = false }
	else if (!host_node || !IsEmpty(host_node)) && payload_node && IsSplitNode(payload_node) && (payload_node.OnlyNodeWithWindows == nil) {
		// Is _visibly_ split?data.IsCenterAvailable = false
	}
	else if (src_node_flags & ImGuiDockNodeFlagsPrivate_.ImGuiDockNodeFlags_NoDockingOverOther) && (!host_node || !IsEmpty(host_node)) { data.IsCenterAvailable = false }
	else if (src_node_flags & ImGuiDockNodeFlagsPrivate_.ImGuiDockNodeFlags_NoDockingOverEmpty) && host_node && IsEmpty(host_node) { data.IsCenterAvailable = false }

	data.IsSidesAvailable = true
	if (dst_node_flags & ImGuiDockNodeFlags_.ImGuiDockNodeFlags_NoDockingSplit) || g.IO.ConfigDockingNoSplit { data.IsSidesAvailable = false }
	else if !is_outer_docking && host_node && host_node.ParentNode == nil && IsCentralNode(host_node) { data.IsSidesAvailable = false }
	else if ImGuiDockNodeFlags_NoDockingSplitOther : ^src_node_flags; ImGuiDockNodeFlags_NoDockingSplitOther { data.IsSidesAvailable = false }

	// Build a tentative future node (reuse same structure because it is practical. Shape will be readjusted when previewing a split)
	data.FutureNode.HasCloseButton = (host_node ? host_node.HasCloseButton : host_window.HasCloseButton) || (payload_window.HasCloseButton)
	data.FutureNode.HasWindowMenuButton = host_node ? true : ((host_window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoCollapse) == 0)
	data.FutureNode.Pos = ref_node_for_rect ? ref_node_for_rect.Pos : host_window.Pos
	data.FutureNode.Size = ref_node_for_rect ? ref_node_for_rect.Size : host_window.Size

	// Calculate drop shapes geometry for allowed splitting directions
	IM_ASSERT(ImGuiDir.ImGuiDir_None == -1)
	data.SplitNode = host_node
	data.SplitDir = ImGuiDir.ImGuiDir_None
	data.IsSplitDirExplicit = false
	if !host_window.Collapsed { for dir : i32 = ImGuiDir.ImGuiDir_None; dir < ImGuiDir.ImGuiDir_COUNT; post_incr(&dir) {
	if dir == ImGuiDir.ImGuiDir_None && !data.IsCenterAvailable { continue }
	if dir != ImGuiDir.ImGuiDir_None && !data.IsSidesAvailable { continue }
	if DockNodeCalcDropRectsAndTestMousePos(Rect(&data.FutureNode), cast(ImGuiDir) dir, data.DropRectsDraw[dir + 1], is_outer_docking, &g.IO.MousePos) {
		data.SplitDir = cast(ImGuiDir) dir
		data.IsSplitDirExplicit = true
	}
} }

	// When docking without holding Shift, we only allow and preview docking when hovering over a drop rect or over the title bar
	data.IsDropAllowed = (data.SplitDir != ImGuiDir.ImGuiDir_None) || (data.IsCenterAvailable)
	if !is_explicit_target && !data.IsSplitDirExplicit && !g.IO.ConfigDockingWithShift { data.IsDropAllowed = false }

	// Calculate split area
	data.SplitRatio = 0.0
	if data.SplitDir != ImGuiDir.ImGuiDir_None {
		split_dir : ImGuiDir = data.SplitDir
		split_axis : ImGuiAxis = (split_dir == ImGuiDir.ImGuiDir_Left || split_dir == ImGuiDir.ImGuiDir_Right) ? ImGuiAxis.ImGuiAxis_X : ImGuiAxis.ImGuiAxis_Y
		pos_new : ImVec2; pos_old : ImVec2 = data.FutureNode.Pos
		size_new : ImVec2; size_old : ImVec2 = data.FutureNode.Size
		DockNodeCalcSplitRects(pos_old, size_old, pos_new, size_new, split_dir, payload_window.Size)

		// Calculate split ratio so we can pass it down the docking request
		split_ratio : f32 = ImSaturate(size_new[split_axis] / data.FutureNode.Size[split_axis])
		data.FutureNode.Pos = pos_new
		data.FutureNode.Size = size_new
		data.SplitRatio = (split_dir == ImGuiDir.ImGuiDir_Right || split_dir == ImGuiDir.ImGuiDir_Down) ? (1.0 - split_ratio) : (split_ratio)
	}
}

DockNodePreviewDockRender :: proc(host_window : ^ImGuiWindow, host_node : ^ImGuiDockNode, root_payload : ^ImGuiWindow, data : ^ImGuiDockPreviewData)
{
	g : ^ImGuiContext = GImGui^
	IM_ASSERT(g.CurrentWindow == host_window); // Because we rely on font size to calculate tab sizes

	// With this option, we only display the preview on the target viewport, and the payload viewport is made transparent.
	// To compensate for the single layer obstructed by the payload, we'll increase the alpha of the preview nodes.
	is_transparent_payload : bool = g.IO.ConfigDockingTransparentPayload

	// In case the two windows involved are on different viewports, we will draw the overlay on each of them.
	overlay_draw_lists_count : i32 = 0
	overlay_draw_lists : [2]^ImDrawList
	overlay_draw_lists[post_incr(&overlay_draw_lists_count)] = GetForegroundDrawList(host_window.Viewport)
	if host_window.Viewport != root_payload.Viewport && !is_transparent_payload { overlay_draw_lists[post_incr(&overlay_draw_lists_count)] = GetForegroundDrawList(root_payload.Viewport) }

	// Draw main preview rectangle
	overlay_col_main : ImU32 = GetColorU32(ImGuiCol_.ImGuiCol_DockingPreview, is_transparent_payload ? 0.60 : 0.40)
	overlay_col_drop : ImU32 = GetColorU32(ImGuiCol_.ImGuiCol_DockingPreview, is_transparent_payload ? 0.90 : 0.70)
	overlay_col_drop_hovered : ImU32 = GetColorU32(ImGuiCol_.ImGuiCol_DockingPreview, is_transparent_payload ? 1.20 : 1.00)
	overlay_col_lines : ImU32 = GetColorU32(ImGuiCol_.ImGuiCol_NavWindowingHighlight, is_transparent_payload ? 0.80 : 0.60)

	// Display area preview
	can_preview_tabs : bool = (root_payload.DockNodeAsHost == nil || root_payload.DockNodeAsHost.Windows.Size > 0)
	if data.IsDropAllowed {
		overlay_rect : ImRect = Rect(&data.FutureNode)
		if data.SplitDir == ImGuiDir.ImGuiDir_None && can_preview_tabs { overlay_rect.Min.y += GetFrameHeight() }
		if data.SplitDir != ImGuiDir.ImGuiDir_None || data.IsCenterAvailable { for overlay_n : i32 = 0; overlay_n < overlay_draw_lists_count; post_incr(&overlay_n) { AddRectFilled(overlay_draw_lists[overlay_n], overlay_rect.Min, overlay_rect.Max, overlay_col_main, host_window.WindowRounding, CalcRoundingFlagsForRectInRect(overlay_rect, Rect(host_window), g.Style.DockingSeparatorSize)) } }
	}

	// Display tab shape/label preview unless we are splitting node (it generally makes the situation harder to read)
	if data.IsDropAllowed && can_preview_tabs && data.SplitDir == ImGuiDir.ImGuiDir_None && data.IsCenterAvailable {
		// Compute target tab bar geometry so we can locate our preview tabs
		tab_bar_rect : ImRect
		DockNodeCalcTabBarLayout(&data.FutureNode, nil, &tab_bar_rect, nil, nil)
		tab_pos : ImVec2 = tab_bar_rect.Min
		if host_node && host_node.TabBar {
			if !IsHiddenTabBar(host_node) && !IsNoTabBar(host_node) {
				// We don't use OffsetNewTab because when using non-persistent-order tab bar it is incremented with each Tab submission.
				tab_pos.x += host_node.TabBar.WidthAllTabs + g.Style.ItemInnerSpacing.x
			}
			else { tab_pos.x += g.Style.ItemInnerSpacing.x + TabItemCalcSize(host_node.Windows[0]).x }
		}
		else if !(host_window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_DockNodeHost) {
			tab_pos.x += g.Style.ItemInnerSpacing.x + TabItemCalcSize(host_window).x; // Account for slight offset which will be added when changing from title bar to tab bar
		}

		// Draw tab shape/label preview (payload may be a loose window or a host window carrying multiple tabbed windows)
		if root_payload.DockNodeAsHost { IM_ASSERT(root_payload.DockNodeAsHost.Windows.Size <= root_payload.DockNodeAsHost.TabBar.Tabs.Size) }
		tab_bar_with_payload : ^ImGuiTabBar = root_payload.DockNodeAsHost ? root_payload.DockNodeAsHost.TabBar : nil
		payload_count : i32 = tab_bar_with_payload ? tab_bar_with_payload.Tabs.Size : 1
		for payload_n : i32 = 0; payload_n < payload_count; post_incr(&payload_n) {
			// DockNode's TabBar may have non-window Tabs manually appended by user
			payload_window : ^ImGuiWindow = tab_bar_with_payload ? tab_bar_with_payload.Tabs[payload_n].Window : root_payload
			if tab_bar_with_payload && payload_window == nil { continue }
			if !DockNodeIsDropAllowedOne(payload_window, host_window) { continue }

			// Calculate the tab bounding box for each payload window
			tab_size : ImVec2 = TabItemCalcSize(payload_window)
			tab_bb : ImRect; init(&tab_bb, tab_pos.x, tab_pos.y, tab_pos.x + tab_size.x, tab_pos.y + tab_size.y)
			tab_pos.x += tab_size.x + g.Style.ItemInnerSpacing.x
			overlay_col_text : ImU32 = GetColorU32(payload_window.DockStyle.Colors[ImGuiWindowDockStyleCol.ImGuiWindowDockStyleCol_Text])
			overlay_col_tabs : ImU32 = GetColorU32(payload_window.DockStyle.Colors[ImGuiWindowDockStyleCol.ImGuiWindowDockStyleCol_TabSelected])
			PushStyleColor(ImGuiCol_.ImGuiCol_Text, overlay_col_text)
			for overlay_n : i32 = 0; overlay_n < overlay_draw_lists_count; post_incr(&overlay_n) {
				tab_flags : ImGuiTabItemFlags = (payload_window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_UnsavedDocument) ? ImGuiTabItemFlags_.ImGuiTabItemFlags_UnsavedDocument : 0
				if !Contains(&tab_bar_rect, tab_bb) { PushClipRect(overlay_draw_lists[overlay_n], tab_bar_rect.Min, tab_bar_rect.Max) }
				TabItemBackground(overlay_draw_lists[overlay_n], tab_bb, tab_flags, overlay_col_tabs)
				TabItemLabelAndCloseButton(overlay_draw_lists[overlay_n], tab_bb, tab_flags, g.Style.FramePadding, payload_window.Name, 0, 0, false, nil, nil)
				if !Contains(&tab_bar_rect, tab_bb) { PopClipRect(overlay_draw_lists[overlay_n]) }
			}

			PopStyleColor()
		}
	}

	// Display drop boxes
	overlay_rounding : f32 = ImMax(3.0, g.Style.FrameRounding)
	for dir : i32 = ImGuiDir.ImGuiDir_None; dir < ImGuiDir.ImGuiDir_COUNT; post_incr(&dir) {
		if !IsInverted(&data.DropRectsDraw[dir + 1]) {
			draw_r : ImRect = data.DropRectsDraw[dir + 1]
			draw_r_in : ImRect = draw_r
			Expand(&draw_r_in, -2.0)
			overlay_col : ImU32 = (data.SplitDir == cast(ImGuiDir) dir && data.IsSplitDirExplicit) ? overlay_col_drop_hovered : overlay_col_drop
			for overlay_n : i32 = 0; overlay_n < overlay_draw_lists_count; post_incr(&overlay_n) {
				center : ImVec2 = ImFloor(GetCenter(&draw_r_in))
				AddRectFilled(overlay_draw_lists[overlay_n], draw_r.Min, draw_r.Max, overlay_col, overlay_rounding)
				AddRect(overlay_draw_lists[overlay_n], draw_r_in.Min, draw_r_in.Max, overlay_col_lines, overlay_rounding)
				if dir == ImGuiDir.ImGuiDir_Left || dir == ImGuiDir.ImGuiDir_Right { AddLine(overlay_draw_lists[overlay_n], ImVec2(center.x, draw_r_in.Min.y), ImVec2(center.x, draw_r_in.Max.y), overlay_col_lines) }
				if dir == ImGuiDir.ImGuiDir_Up || dir == ImGuiDir.ImGuiDir_Down { AddLine(overlay_draw_lists[overlay_n], ImVec2(draw_r_in.Min.x, center.y), ImVec2(draw_r_in.Max.x, center.y), overlay_col_lines) }
			}
		}

		// Stop after ImGuiDir_None
		if (host_node && (host_node.MergedFlags & ImGuiDockNodeFlags_.ImGuiDockNodeFlags_NoDockingSplit)) || g.IO.ConfigDockingNoSplit { return }
	}
}

// ImGuiDockNode tree manipulations
//-----------------------------------------------------------------------------
// Docking: ImGuiDockNode Tree manipulation functions
//-----------------------------------------------------------------------------
// - DockNodeTreeSplit()
// - DockNodeTreeMerge()
// - DockNodeTreeUpdatePosSize()
// - DockNodeTreeUpdateSplitterFindTouchingNode()
// - DockNodeTreeUpdateSplitter()
// - DockNodeTreeFindFallbackLeafNode()
// - DockNodeTreeFindNodeByPos()
//-----------------------------------------------------------------------------

DockNodeTreeSplit :: proc(ctx : ^ImGuiContext, parent_node : ^ImGuiDockNode, split_axis : ImGuiAxis, split_inheritor_child_idx : i32, split_ratio : f32, new_node : ^ImGuiDockNode)
{
	g : ^ImGuiContext = GImGui^
	IM_ASSERT(split_axis != ImGuiAxis.ImGuiAxis_None)

	child_0 : ^ImGuiDockNode = (new_node && split_inheritor_child_idx != 0) ? new_node : DockContextAddNode(ctx, 0)
	child_0.ParentNode = parent_node

	child_1 : ^ImGuiDockNode = (new_node && split_inheritor_child_idx != 1) ? new_node : DockContextAddNode(ctx, 0)
	child_1.ParentNode = parent_node

	child_inheritor : ^ImGuiDockNode = (split_inheritor_child_idx == 0) ? child_0 : child_1
	DockNodeMoveChildNodes(child_inheritor, parent_node)
	parent_node.ChildNodes[0] = child_0
	parent_node.ChildNodes[1] = child_1
	parent_node.ChildNodes[split_inheritor_child_idx].VisibleWindow = parent_node.VisibleWindow
	parent_node.SplitAxis = split_axis
	parent_node.VisibleWindow = nil
	parent_node.AuthorityForSize = ImGuiDataAuthority_.ImGuiDataAuthority_DockNode; parent_node.AuthorityForPos = parent_node.AuthorityForSize

	size_avail : f32 = (parent_node.Size[split_axis] - g.Style.DockingSeparatorSize)
	size_avail = ImMax(size_avail, g.Style.WindowMinSize[split_axis] * 2.0)
	IM_ASSERT(size_avail > 0.0); // If you created a node manually with DockBuilderAddNode(), you need to also call DockBuilderSetNodeSize() before splitting.
	child_1.SizeRef = parent_node.Size; child_0.SizeRef = child_1.SizeRef
	child_0.SizeRef[split_axis] = ImTrunc(size_avail * split_ratio)
	child_1.SizeRef[split_axis] = ImTrunc(size_avail - child_0.SizeRef[split_axis])

	DockNodeMoveWindows(parent_node.ChildNodes[split_inheritor_child_idx], parent_node)
	DockSettingsRenameNodeReferences(parent_node.ID, parent_node.ChildNodes[split_inheritor_child_idx].ID)
	DockNodeUpdateHasCentralNodeChild(DockNodeGetRootNode(parent_node))
	DockNodeTreeUpdatePosSize(parent_node, parent_node.Pos, parent_node.Size)

	// Flags transfer (e.g. this is where we transfer the ImGuiDockNodeFlags_CentralNode property)
	child_0.SharedFlags = parent_node.SharedFlags & ImGuiDockNodeFlagsPrivate_.ImGuiDockNodeFlags_SharedFlagsInheritMask_
	child_1.SharedFlags = parent_node.SharedFlags & ImGuiDockNodeFlagsPrivate_.ImGuiDockNodeFlags_SharedFlagsInheritMask_
	child_inheritor.LocalFlags = parent_node.LocalFlags & ImGuiDockNodeFlagsPrivate_.ImGuiDockNodeFlags_LocalFlagsTransferMask_
	parent_node.LocalFlags &= !ImGuiDockNodeFlagsPrivate_.ImGuiDockNodeFlags_LocalFlagsTransferMask_
	UpdateMergedFlags(child_0)
	UpdateMergedFlags(child_1)
	UpdateMergedFlags(parent_node)
	if IsCentralNode(child_inheritor) { DockNodeGetRootNode(parent_node).CentralNode = child_inheritor }
}

DockNodeTreeMerge :: proc(ctx : ^ImGuiContext, parent_node : ^ImGuiDockNode, merge_lead_child : ^ImGuiDockNode)
{
	// When called from DockContextProcessUndockNode() it is possible that one of the child is NULL.
	g : ^ImGuiContext = GImGui^
	child_0 : ^ImGuiDockNode = parent_node.ChildNodes[0]
	child_1 : ^ImGuiDockNode = parent_node.ChildNodes[1]
	IM_ASSERT(child_0 || child_1)
	IM_ASSERT(merge_lead_child == child_0 || merge_lead_child == child_1)
	if (child_0 && child_0.Windows.Size > 0) || (child_1 && child_1.Windows.Size > 0) {
		IM_ASSERT(parent_node.TabBar == nil)
		IM_ASSERT(parent_node.Windows.Size == 0)
	}
	IMGUI_DEBUG_LOG_DOCKING("[docking] DockNodeTreeMerge: 0x%08X + 0x%08X back into parent 0x%08X\n", child_0 ? child_0.ID : 0, child_1 ? child_1.ID : 0, parent_node.ID)

	backup_last_explicit_size : ImVec2 = parent_node.SizeRef
	DockNodeMoveChildNodes(parent_node, merge_lead_child)
	if child_0 {
		DockNodeMoveWindows(parent_node, child_0); // Generally only 1 of the 2 child node will have windows
		DockSettingsRenameNodeReferences(child_0.ID, parent_node.ID)
	}
	if child_1 {
		DockNodeMoveWindows(parent_node, child_1)
		DockSettingsRenameNodeReferences(child_1.ID, parent_node.ID)
	}
	DockNodeApplyPosSizeToWindows(parent_node)
	parent_node.AuthorityForViewport = ImGuiDataAuthority_.ImGuiDataAuthority_Auto; parent_node.AuthorityForSize = parent_node.AuthorityForViewport; parent_node.AuthorityForPos = parent_node.AuthorityForSize
	parent_node.VisibleWindow = merge_lead_child.VisibleWindow
	parent_node.SizeRef = backup_last_explicit_size

	// Flags transfer
	parent_node.LocalFlags &= !ImGuiDockNodeFlagsPrivate_.ImGuiDockNodeFlags_LocalFlagsTransferMask_; // Preserve Dockspace flag
	parent_node.LocalFlags |= (child_0 ? child_0.LocalFlags : 0) & ImGuiDockNodeFlagsPrivate_.ImGuiDockNodeFlags_LocalFlagsTransferMask_
	parent_node.LocalFlags |= (child_1 ? child_1.LocalFlags : 0) & ImGuiDockNodeFlagsPrivate_.ImGuiDockNodeFlags_LocalFlagsTransferMask_
	parent_node.LocalFlagsInWindows = (child_0 ? child_0.LocalFlagsInWindows : 0) | (child_1 ? child_1.LocalFlagsInWindows : 0); // FIXME: Would be more consistent to update from actual windows
	UpdateMergedFlags(parent_node)

	if child_0 {
		SetVoidPtr(&ctx.DockContext.Nodes, child_0.ID, nil)
		IM_DELETE(child_0)
	}
	if child_1 {
		SetVoidPtr(&ctx.DockContext.Nodes, child_1.ID, nil)
		IM_DELETE(child_1)
	}
}

// Update Pos/Size for a node hierarchy (don't affect child Windows yet)
// (Depth-first, Pre-Order)
DockNodeTreeUpdatePosSize :: proc(node : ^ImGuiDockNode, pos : ImVec2, size : ImVec2, only_write_to_single_node : ^ImGuiDockNode)
{
	// During the regular dock node update we write to all nodes.
	// 'only_write_to_single_node' is only set when turning a node visible mid-frame and we need its size right-away.
	g : ^ImGuiContext = GImGui^
	write_to_node : bool = only_write_to_single_node == nil || only_write_to_single_node == node
	if write_to_node {
		node.Pos = pos
		node.Size = size
	}

	if IsLeafNode(node) { return }

	child_0 : ^ImGuiDockNode = node.ChildNodes[0]
	child_1 : ^ImGuiDockNode = node.ChildNodes[1]
	child_0_pos : ImVec2 = pos; child_1_pos : ImVec2 = pos
	child_0_size : ImVec2 = size; child_1_size : ImVec2 = size

	child_0_is_toward_single_node : bool = (only_write_to_single_node != nil && DockNodeIsInHierarchyOf(only_write_to_single_node, child_0))
	child_1_is_toward_single_node : bool = (only_write_to_single_node != nil && DockNodeIsInHierarchyOf(only_write_to_single_node, child_1))
	child_0_is_or_will_be_visible : bool = child_0.IsVisible || child_0_is_toward_single_node
	child_1_is_or_will_be_visible : bool = child_1.IsVisible || child_1_is_toward_single_node

	if child_0_is_or_will_be_visible && child_1_is_or_will_be_visible {
		spacing : f32 = g.Style.DockingSeparatorSize
		axis : ImGuiAxis = cast(ImGuiAxis) node.SplitAxis
		size_avail : f32 = ImMax(size[axis] - spacing, 0.0)

		// Size allocation policy
		// 1) The first 0..WindowMinSize[axis]*2 are allocated evenly to both windows.
		size_min_each : f32 = ImTrunc(ImMin(size_avail, g.Style.WindowMinSize[axis] * 2.0) * 0.5)

		// FIXME: Blocks 2) and 3) are essentially doing nearly the same thing.
		// Difference are: write-back to SizeRef; application of a minimum size; rounding before ImTrunc()
		// Clarify and rework differences between Size & SizeRef and purpose of WantLockSizeOnce

		// 2) Process locked absolute size (during a splitter resize we preserve the child of nodes not touching the splitter edge)
		if child_0.WantLockSizeOnce && !child_1.WantLockSizeOnce {
			child_0.SizeRef[axis] = ImMin(size_avail - 1.0, child_0.Size[axis]); child_0_size[axis] = child_0.SizeRef[axis]
			child_1.SizeRef[axis] = (size_avail - child_0_size[axis]); child_1_size[axis] = child_1.SizeRef[axis]
			IM_ASSERT(child_0.SizeRef[axis] > 0.0 && child_1.SizeRef[axis] > 0.0)
		}
		else if child_1.WantLockSizeOnce && !child_0.WantLockSizeOnce {
			child_1.SizeRef[axis] = ImMin(size_avail - 1.0, child_1.Size[axis]); child_1_size[axis] = child_1.SizeRef[axis]
			child_0.SizeRef[axis] = (size_avail - child_1_size[axis]); child_0_size[axis] = child_0.SizeRef[axis]
			IM_ASSERT(child_0.SizeRef[axis] > 0.0 && child_1.SizeRef[axis] > 0.0)
		}
		else if child_0.WantLockSizeOnce && child_1.WantLockSizeOnce {
			// FIXME-DOCK: We cannot honor the requested size, so apply ratio.
			// Currently this path will only be taken if code programmatically sets WantLockSizeOnce
			split_ratio : f32 = child_0_size[axis] / (child_0_size[axis] + child_1_size[axis])
			child_0.SizeRef[axis] = ImTrunc(size_avail * split_ratio); child_0_size[axis] = child_0.SizeRef[axis]
			child_1.SizeRef[axis] = (size_avail - child_0_size[axis]); child_1_size[axis] = child_1.SizeRef[axis]
			IM_ASSERT(child_0.SizeRef[axis] > 0.0 && child_1.SizeRef[axis] > 0.0)
		}
		else if child_0.SizeRef[axis] != 0.0 && child_1.HasCentralNodeChild {
			// 3) If one window is the central node (~ use remaining space, should be made explicit!), use explicit size from the other, and remainder for the central node
			child_0_size[axis] = ImMin(size_avail - size_min_each, child_0.SizeRef[axis])
			child_1_size[axis] = (size_avail - child_0_size[axis])
		}
		else if child_1.SizeRef[axis] != 0.0 && child_0.HasCentralNodeChild {
			child_1_size[axis] = ImMin(size_avail - size_min_each, child_1.SizeRef[axis])
			child_0_size[axis] = (size_avail - child_1_size[axis])
		}
		else {
			// 4) Otherwise distribute according to the relative ratio of each SizeRef value
			split_ratio : f32 = child_0.SizeRef[axis] / (child_0.SizeRef[axis] + child_1.SizeRef[axis])
			child_0_size[axis] = ImMax(size_min_each, ImTrunc(size_avail * split_ratio + 0.5))
			child_1_size[axis] = (size_avail - child_0_size[axis])
		}

		child_1_pos[axis] += spacing + child_0_size[axis]
	}

	if only_write_to_single_node == nil { child_1.WantLockSizeOnce = false; child_0.WantLockSizeOnce = child_1.WantLockSizeOnce }

	child_0_recurse : bool = only_write_to_single_node ? child_0_is_toward_single_node : child_0.IsVisible
	child_1_recurse : bool = only_write_to_single_node ? child_1_is_toward_single_node : child_1.IsVisible
	if child_0_recurse { DockNodeTreeUpdatePosSize(child_0, child_0_pos, child_0_size) }
	if child_1_recurse { DockNodeTreeUpdatePosSize(child_1, child_1_pos, child_1_size) }
}

DockNodeTreeUpdateSplitterFindTouchingNode :: proc(node : ^ImGuiDockNode, axis : ImGuiAxis, side : i32, touching_nodes : ^ImVector(^ImGuiDockNode))
{
	if IsLeafNode(node) {
		push_back(touching_nodes, node)
		return
	}
	if node.ChildNodes[0].IsVisible { if node.SplitAxis != axis || side == 0 || !node.ChildNodes[1].IsVisible { DockNodeTreeUpdateSplitterFindTouchingNode(node.ChildNodes[0], axis, side, touching_nodes) } }
	if node.ChildNodes[1].IsVisible { if node.SplitAxis != axis || side == 1 || !node.ChildNodes[0].IsVisible { DockNodeTreeUpdateSplitterFindTouchingNode(node.ChildNodes[1], axis, side, touching_nodes) } }
}

// (Depth-First, Pre-Order)
DockNodeTreeUpdateSplitter :: proc(node : ^ImGuiDockNode)
{
	if IsLeafNode(node) { return }

	g : ^ImGuiContext = GImGui^

	child_0 : ^ImGuiDockNode = node.ChildNodes[0]
	child_1 : ^ImGuiDockNode = node.ChildNodes[1]
	if child_0.IsVisible && child_1.IsVisible {
		// Bounding box of the splitter cover the space between both nodes (w = Spacing, h = Size[xy^1] for when splitting horizontally)
		axis : ImGuiAxis = cast(ImGuiAxis) node.SplitAxis
		IM_ASSERT(axis != ImGuiAxis.ImGuiAxis_None)
		bb : ImRect
		bb.Min = child_0.Pos
		bb.Max = child_1.Pos
		bb.Min[axis] += child_0.Size[axis]
		bb.Max[axis ~ 1] += child_1.Size[axis ~ 1]
		//if (g.IO.KeyCtrl) GetForegroundDrawList(g.CurrentWindow->Viewport)->AddRect(bb.Min, bb.Max, IM_COL32(255,0,255,255));

		merged_flags : ImGuiDockNodeFlags = child_0.MergedFlags | child_1.MergedFlags; // Merged flags for BOTH childs
		no_resize_axis_flag : ImGuiDockNodeFlags = (axis == ImGuiAxis.ImGuiAxis_X) ? ImGuiDockNodeFlagsPrivate_.ImGuiDockNodeFlags_NoResizeX : ImGuiDockNodeFlagsPrivate_.ImGuiDockNodeFlags_NoResizeY
		if (merged_flags & ImGuiDockNodeFlags_.ImGuiDockNodeFlags_NoResize) || (merged_flags & no_resize_axis_flag) {
			window : ^ImGuiWindow = g.CurrentWindow
			AddRectFilled(window.DrawList, bb.Min, bb.Max, GetColorU32(ImGuiCol_.ImGuiCol_Separator), g.Style.FrameRounding)
		}
		else {
			//bb.Min[axis] += 1; // Display a little inward so highlight doesn't connect with nearby tabs on the neighbor node.
			//bb.Max[axis] -= 1;
			PushID(node.ID)

			// Find resizing limits by gathering list of nodes that are touching the splitter line.
			touching_nodes : [2]ImVector(^ImGuiDockNode)
			min_size : f32 = g.Style.WindowMinSize[axis]
			resize_limits : [2]f32
			resize_limits[0] = node.ChildNodes[0].Pos[axis] + min_size
			resize_limits[1] = node.ChildNodes[1].Pos[axis] + node.ChildNodes[1].Size[axis] - min_size

			splitter_id : ImGuiID = GetID("##Splitter")
			if g.ActiveId == splitter_id {
				// Only process when splitter is active
				DockNodeTreeUpdateSplitterFindTouchingNode(child_0, axis, 1, &touching_nodes[0])
				DockNodeTreeUpdateSplitterFindTouchingNode(child_1, axis, 0, &touching_nodes[1])
				for touching_node_n : i32 = 0; touching_node_n < touching_nodes[0].Size; post_incr(&touching_node_n) { resize_limits[0] = ImMax(resize_limits[0], Rect(touching_nodes[0][touching_node_n]).Min[axis] + min_size) }

				for touching_node_n : i32 = 0; touching_node_n < touching_nodes[1].Size; post_incr(&touching_node_n) { resize_limits[1] = ImMin(resize_limits[1], Rect(touching_nodes[1][touching_node_n]).Max[axis] - min_size) }

				// [DEBUG] Render touching nodes & limits
				/*
                ImDrawList* draw_list = node->HostWindow ? GetForegroundDrawList(node->HostWindow) : GetForegroundDrawList(GetMainViewport());
                for (int n = 0; n < 2; n++)
                {
                    for (int touching_node_n = 0; touching_node_n < touching_nodes[n].Size; touching_node_n++)
                        draw_list->AddRect(touching_nodes[n][touching_node_n]->Pos, touching_nodes[n][touching_node_n]->Pos + touching_nodes[n][touching_node_n]->Size, IM_COL32(0, 255, 0, 255));
                    if (axis == ImGuiAxis_X)
                        draw_list->AddLine(ImVec2(resize_limits[n], node->ChildNodes[n]->Pos.y), ImVec2(resize_limits[n], node->ChildNodes[n]->Pos.y + node->ChildNodes[n]->Size.y), IM_COL32(255, 0, 255, 255), 3.0f);
                    else
                        draw_list->AddLine(ImVec2(node->ChildNodes[n]->Pos.x, resize_limits[n]), ImVec2(node->ChildNodes[n]->Pos.x + node->ChildNodes[n]->Size.x, resize_limits[n]), IM_COL32(255, 0, 255, 255), 3.0f);
                }
                */
			}

			// Use a short delay before highlighting the splitter (and changing the mouse cursor) in order for regular mouse movement to not highlight many splitters
			cur_size_0 : f32 = child_0.Size[axis]
			cur_size_1 : f32 = child_1.Size[axis]
			min_size_0 : f32 = resize_limits[0] - child_0.Pos[axis]
			min_size_1 : f32 = child_1.Pos[axis] + child_1.Size[axis] - resize_limits[1]
			bg_col : ImU32 = GetColorU32(ImGuiCol_.ImGuiCol_WindowBg)
			if SplitterBehavior(bb, GetID("##Splitter"), axis, &cur_size_0, &cur_size_1, min_size_0, min_size_1, WINDOWS_HOVER_PADDING, WINDOWS_RESIZE_FROM_EDGES_FEEDBACK_TIMER, bg_col) {
				if touching_nodes[0].Size > 0 && touching_nodes[1].Size > 0 {
					child_0.SizeRef[axis] = cur_size_0; child_0.Size[axis] = child_0.SizeRef[axis]
					child_1.Pos[axis] -= cur_size_1 - child_1.Size[axis]
					child_1.SizeRef[axis] = cur_size_1; child_1.Size[axis] = child_1.SizeRef[axis]

					// Lock the size of every node that is a sibling of the node we are touching
					// This might be less desirable if we can merge sibling of a same axis into the same parental level.
					for side_n : i32 = 0; side_n < 2; post_incr(&side_n) { for touching_node_n : i32 = 0; touching_node_n < touching_nodes[side_n].Size; post_incr(&touching_node_n) {
	touching_node : ^ImGuiDockNode = touching_nodes[side_n][touching_node_n]
	//ImDrawList* draw_list = node->HostWindow ? GetForegroundDrawList(node->HostWindow) : GetForegroundDrawList(GetMainViewport());
	//draw_list->AddRect(touching_node->Pos, touching_node->Pos + touching_node->Size, IM_COL32(255, 128, 0, 255));
	for touching_node.ParentNode != node {
		if touching_node.ParentNode.SplitAxis == axis {
			// Mark other node so its size will be preserved during the upcoming call to DockNodeTreeUpdatePosSize().
			node_to_preserve : ^ImGuiDockNode = touching_node.ParentNode.ChildNodes[side_n]
			node_to_preserve.WantLockSizeOnce = true
			//draw_list->AddRect(touching_node->Pos, touching_node->Rect().Max, IM_COL32(255, 0, 0, 255));
			//draw_list->AddRectFilled(node_to_preserve->Pos, node_to_preserve->Rect().Max, IM_COL32(0, 255, 0, 100));
		}
		touching_node = touching_node.ParentNode
	}
} }

					DockNodeTreeUpdatePosSize(child_0, child_0.Pos, child_0.Size)
					DockNodeTreeUpdatePosSize(child_1, child_1.Pos, child_1.Size)
					MarkIniSettingsDirty()
				}
			}
			PopID()
		}
	}

	if child_0.IsVisible { DockNodeTreeUpdateSplitter(child_0) }
	if child_1.IsVisible { DockNodeTreeUpdateSplitter(child_1) }
}

DockNodeTreeFindFallbackLeafNode :: proc(node : ^ImGuiDockNode) -> ^ImGuiDockNode
{
	if IsLeafNode(node) { return node }
	if leaf_node : ^ImGuiDockNode = DockNodeTreeFindFallbackLeafNode(node.ChildNodes[0]); leaf_node { return leaf_node }
	if leaf_node : ^ImGuiDockNode = DockNodeTreeFindFallbackLeafNode(node.ChildNodes[1]); leaf_node { return leaf_node }
	return nil
}

DockNodeTreeFindVisibleNodeByPos :: proc(node : ^ImGuiDockNode, pos : ImVec2) -> ^ImGuiDockNode
{
	if !node.IsVisible { return nil }

	dock_spacing : f32 = 0.0; // g.Style.ItemInnerSpacing.x; // FIXME: Relation to DOCKING_SPLITTER_SIZE?
	r : ImRect; init(&r, node.Pos, node.Pos + node.Size)
	Expand(&r, dock_spacing * 0.5)
	inside : bool = Contains(&r, pos)
	if !inside { return nil }

	if IsLeafNode(node) { return node }
	if hovered_node : ^ImGuiDockNode = DockNodeTreeFindVisibleNodeByPos(node.ChildNodes[0], pos); hovered_node { return hovered_node }
	if hovered_node : ^ImGuiDockNode = DockNodeTreeFindVisibleNodeByPos(node.ChildNodes[1], pos); hovered_node { return hovered_node }

	// This means we are hovering over the splitter/spacing of a parent node
	return node
}

//-----------------------------------------------------------------------------
// Docking: Public Functions (SetWindowDock, DockSpace, DockSpaceOverViewport)
//-----------------------------------------------------------------------------
// - SetWindowDock() [Internal]
// - DockSpace()
// - DockSpaceOverViewport()
//-----------------------------------------------------------------------------

// [Internal] Called via SetNextWindowDockID()
SetWindowDock :: proc(window : ^ImGuiWindow, dock_id : ImGuiID, cond : ImGuiCond)
{
	// Test condition (NB: bit 0 is always true) and clear flags for next time
	if cond && (window.SetWindowDockAllowFlags & cond) == 0 { return }
	window.SetWindowDockAllowFlags &= !(ImGuiCond_.ImGuiCond_Once | ImGuiCond_.ImGuiCond_FirstUseEver | ImGuiCond_.ImGuiCond_Appearing)

	if window.DockId == dock_id { return }

	// If the user attempt to set a dock id that is a split node, we'll dig within to find a suitable docking spot
	g : ^ImGuiContext = GImGui^
	if new_node : ^ImGuiDockNode = DockContextFindNodeByID(&g, dock_id); new_node { if IsSplitNode(new_node) {
	// Policy: Find central node or latest focused node. We first move back to our root node.
	new_node = DockNodeGetRootNode(new_node)
	if new_node.CentralNode {
		IM_ASSERT(IsCentralNode(new_node.CentralNode))
		dock_id = new_node.CentralNode.ID
	}
	else {
		dock_id = new_node.LastFocusedNodeId
	}
} }

	if window.DockId == dock_id { return }

	if window.DockNode { DockNodeRemoveWindow(window.DockNode, window, 0) }
	window.DockId = dock_id
}

// Docking
// [BETA API] Enable with io.ConfigFlags |= ImGuiConfigFlags_DockingEnable.
// Note: You can use most Docking facilities without calling any API. You DO NOT need to call DockSpace() to use Docking!
// - Drag from window title bar or their tab to dock/undock. Hold SHIFT to disable docking.
// - Drag from window menu button (upper-left button) to undock an entire node (all windows).
// - When io.ConfigDockingWithShift == true, you instead need to hold SHIFT to enable docking.
// About dockspaces:
// - Use DockSpaceOverViewport() to create a window covering the screen or a specific viewport + a dockspace inside it.
//   This is often used with ImGuiDockNodeFlags_PassthruCentralNode to make it transparent.
// - Use DockSpace() to create an explicit dock node _within_ an existing window. See Docking demo for details.
// - Important: Dockspaces need to be submitted _before_ any window they can host. Submit it early in your frame!
// - Important: Dockspaces need to be kept alive if hidden, otherwise windows docked into it will be undocked.
//   e.g. if you have multiple tabs with a dockspace inside each tab: submit the non-visible dockspaces with ImGuiDockNodeFlags_KeepAliveOnly.
// Create an explicit dockspace node within an existing window. Also expose dock node flags and creates a CentralNode by default.
// The Central Node is always displayed even when empty and shrink/extend according to the requested size of its neighbors.
// DockSpace() needs to be submitted _before_ any window they can host. If you use a dockspace, submit it early in your app.
// When ImGuiDockNodeFlags_KeepAliveOnly is set, nothing is submitted in the current window (function may be called from any location).
DockSpace :: proc(dockspace_id : ImGuiID, size_arg : ^ImVec2, flags : ImGuiDockNodeFlags, window_class : ^ImGuiWindowClass) -> ImGuiID
{
	g : ^ImGuiContext = GImGui^
	window : ^ImGuiWindow = GetCurrentWindowRead()
	if !(g.IO.ConfigFlags & ImGuiConfigFlags_.ImGuiConfigFlags_DockingEnable) { return 0 }

	// Early out if parent window is hidden/collapsed
	// This is faster but also DockNodeUpdateTabBar() relies on TabBarLayout() running (which won't if SkipItems=true) to set NextSelectedTabId = 0). See #2960.
	// If for whichever reason this is causing problem we would need to ensure that DockNodeUpdateTabBar() ends up clearing NextSelectedTabId even if SkipItems=true.
	if window.SkipItems { flags |= ImGuiDockNodeFlags_.ImGuiDockNodeFlags_KeepAliveOnly }
	if (flags & ImGuiDockNodeFlags_.ImGuiDockNodeFlags_KeepAliveOnly) == 0 {
		// call to set window->WriteAccessed = true;
		window = GetCurrentWindow()
	}

	IM_ASSERT((flags & ImGuiDockNodeFlagsPrivate_.ImGuiDockNodeFlags_DockSpace) == 0); // Flag is automatically set by DockSpace() as LocalFlags, not SharedFlags!
	IM_ASSERT((flags & ImGuiDockNodeFlagsPrivate_.ImGuiDockNodeFlags_CentralNode) == 0); // Flag is automatically set by DockSpace() as LocalFlags, not SharedFlags! (#8145)

	IM_ASSERT(dockspace_id != 0)
	node : ^ImGuiDockNode = DockContextFindNodeByID(&g, dockspace_id)
	if node == nil {
		IMGUI_DEBUG_LOG_DOCKING("[docking] DockSpace: dockspace node 0x%08X created\n", dockspace_id)
		node = DockContextAddNode(&g, dockspace_id)
		SetLocalFlags(node, ImGuiDockNodeFlagsPrivate_.ImGuiDockNodeFlags_CentralNode)
	}
	if window_class && window_class.ClassId != node.WindowClass.ClassId { IMGUI_DEBUG_LOG_DOCKING("[docking] DockSpace: dockspace node 0x%08X: setup WindowClass 0x%08X -> 0x%08X\n", dockspace_id, node.WindowClass.ClassId, window_class.ClassId) }
	node.SharedFlags = flags
	node.WindowClass = window_class ? window_class^ : ImGuiWindowClass()

	// When a DockSpace transitioned form implicit to explicit this may be called a second time
	// It is possible that the node has already been claimed by a docked window which appeared before the DockSpace() node, so we overwrite IsDockSpace again.
	if node.LastFrameActive == g.FrameCount && !(flags & ImGuiDockNodeFlags_.ImGuiDockNodeFlags_KeepAliveOnly) {
		IM_ASSERT(IsDockSpace(node) == false && "Cannot call DockSpace() twice a frame with the same ID")
		SetLocalFlags(node, node.LocalFlags | ImGuiDockNodeFlagsPrivate_.ImGuiDockNodeFlags_DockSpace)
		return dockspace_id
	}
	SetLocalFlags(node, node.LocalFlags | ImGuiDockNodeFlagsPrivate_.ImGuiDockNodeFlags_DockSpace)

	// Keep alive mode, this is allow windows docked into this node so stay docked even if they are not visible
	if ImGuiDockNodeFlags_KeepAliveOnly : ^flags; ImGuiDockNodeFlags_KeepAliveOnly {
		node.LastFrameAlive = g.FrameCount
		return dockspace_id
	}

	content_avail : ImVec2 = GetContentRegionAvail()
	size : ImVec2 = ImTrunc(size_arg)
	if size.x <= 0.0 {
		// Arbitrary minimum child size (0.0f causing too much issues)
		size.x = ImMax(content_avail.x + size.x, 4.0)
	}
	if size.y <= 0.0 { size.y = ImMax(content_avail.y + size.y, 4.0) }
	IM_ASSERT(size.x > 0.0 && size.y > 0.0)

	node.Pos = window.DC.CursorPos
	node.SizeRef = size; node.Size = node.SizeRef
	SetNextWindowPos(node.Pos)
	SetNextWindowSize(node.Size)
	g.NextWindowData.PosUndock = false

	// FIXME-DOCK: Why do we need a child window to host a dockspace, could we host it in the existing window?
	// FIXME-DOCK: What is the reason for not simply calling BeginChild()? (OK to have a reason but should be commented)
	window_flags : ImGuiWindowFlags = ImGuiWindowFlags_.ImGuiWindowFlags_ChildWindow | ImGuiWindowFlags_.ImGuiWindowFlags_DockNodeHost
	window_flags |= ImGuiWindowFlags_.ImGuiWindowFlags_NoSavedSettings | ImGuiWindowFlags_.ImGuiWindowFlags_NoResize | ImGuiWindowFlags_.ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_.ImGuiWindowFlags_NoTitleBar
	window_flags |= ImGuiWindowFlags_.ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_.ImGuiWindowFlags_NoScrollWithMouse
	window_flags |= ImGuiWindowFlags_.ImGuiWindowFlags_NoBackground

	title : [256]u8
	ImFormatString(title, IM_ARRAYSIZE(title), "%s/DockSpace_%08X", window.Name, dockspace_id)

	PushStyleVar(ImGuiStyleVar_.ImGuiStyleVar_ChildBorderSize, 0.0)
	Begin(title, nil, window_flags)
	PopStyleVar()

	host_window : ^ImGuiWindow = g.CurrentWindow
	DockNodeSetupHostWindow(node, host_window)
	host_window.ChildId = GetID(window, title)
	node.OnlyNodeWithWindows = nil

	IM_ASSERT(IsRootNode(node))

	// We need to handle the rare case were a central node is missing.
	// This can happen if the node was first created manually with DockBuilderAddNode() but _without_ the ImGuiDockNodeFlags_Dockspace.
	// Doing it correctly would set the _CentralNode flags, which would then propagate according to subsequent split.
	// It would also be ambiguous to attempt to assign a central node while there are split nodes, so we wait until there's a single node remaining.
	// The specific sub-property of _CentralNode we are interested in recovering here is the "Don't delete when empty" property,
	// as it doesn't make sense for an empty dockspace to not have this property.
	if IsLeafNode(node) && !IsCentralNode(node) { SetLocalFlags(node, node.LocalFlags | ImGuiDockNodeFlagsPrivate_.ImGuiDockNodeFlags_CentralNode) }

	// Update the node
	DockNodeUpdate(node)

	End()

	bb : ImRect; init(&bb, node.Pos, node.Pos + size)
	ItemSize(size)
	ItemAdd(bb, dockspace_id, nil, ImGuiItemFlags_.ImGuiItemFlags_NoNav); // Not a nav point (could be, would need to draw the nav rect and replicate/refactor activation from BeginChild(), but seems like CTRL+Tab works better here?)
	if (g.LastItemData.StatusFlags & ImGuiItemStatusFlags_.ImGuiItemStatusFlags_HoveredRect) && IsWindowChildOf(g.HoveredWindow, host_window, false, true) {
		// To fullfill IsItemHovered(), similar to EndChild()g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_.ImGuiItemStatusFlags_HoveredWindow
	}

	return dockspace_id
}

// Tips: Use with ImGuiDockNodeFlags_PassthruCentralNode!
// The limitation with this call is that your window won't have a local menu bar, but you can also use BeginMainMenuBar().
// Even though we could pass window flags, it would also require the user to be able to call BeginMenuBar() somehow meaning we can't Begin/End in a single function.
// If you really want a menu bar inside the same window as the one hosting the dockspace, you will need to copy this code somewhere and tweak it.
DockSpaceOverViewport :: proc(dockspace_id : ImGuiID, viewport : ^ImGuiViewport, dockspace_flags : ImGuiDockNodeFlags, window_class : ^ImGuiWindowClass) -> ImGuiID
{
	if viewport == nil { viewport = GetMainViewport() }

	// Submit a window filling the entire viewport
	SetNextWindowPos(viewport.WorkPos)
	SetNextWindowSize(viewport.WorkSize)
	SetNextWindowViewport(viewport.ID)

	host_window_flags : ImGuiWindowFlags = 0
	host_window_flags |= ImGuiWindowFlags_.ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_.ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_.ImGuiWindowFlags_NoResize | ImGuiWindowFlags_.ImGuiWindowFlags_NoMove | ImGuiWindowFlags_.ImGuiWindowFlags_NoDocking
	host_window_flags |= ImGuiWindowFlags_.ImGuiWindowFlags_NoBringToFrontOnFocus | ImGuiWindowFlags_.ImGuiWindowFlags_NoNavFocus
	if ImGuiDockNodeFlags_PassthruCentralNode : ^dockspace_flags; ImGuiDockNodeFlags_PassthruCentralNode { host_window_flags |= ImGuiWindowFlags_.ImGuiWindowFlags_NoBackground }

	// FIXME-OPT: When using ImGuiDockNodeFlags_KeepAliveOnly with DockSpaceOverViewport() we might be able to spare submitting the window,
	// since DockSpace() with that flag doesn't need a window. We'd only need to compute the default ID accordingly.
	if ImGuiDockNodeFlags_KeepAliveOnly : ^dockspace_flags; ImGuiDockNodeFlags_KeepAliveOnly { host_window_flags |= ImGuiWindowFlags_.ImGuiWindowFlags_NoMouseInputs }

	label : [32]u8
	ImFormatString(label, IM_ARRAYSIZE(label), "WindowOverViewport_%08X", viewport.ID)

	PushStyleVar(ImGuiStyleVar_.ImGuiStyleVar_WindowRounding, 0.0)
	PushStyleVar(ImGuiStyleVar_.ImGuiStyleVar_WindowBorderSize, 0.0)
	PushStyleVar(ImGuiStyleVar_.ImGuiStyleVar_WindowPadding, ImVec2(0.0, 0.0))
	Begin(label, nil, host_window_flags)
	PopStyleVar(3)

	// Submit the dockspace
	if dockspace_id == 0 { dockspace_id = GetID("DockSpace") }
	DockSpace(dockspace_id, ImVec2(0.0, 0.0), dockspace_flags, window_class)

	End()

	return dockspace_id
}

// Docking - Builder function needs to be generally called before the node is used/submitted.
// - The DockBuilderXXX functions are designed to _eventually_ become a public API, but it is too early to expose it and guarantee stability.
// - Do not hold on ImGuiDockNode* pointers! They may be invalidated by any split/merge/remove operation and every frame.
// - To create a DockSpace() node, make sure to set the ImGuiDockNodeFlags_DockSpace flag when calling DockBuilderAddNode().
//   You can create dockspace nodes (attached to a window) _or_ floating nodes (carry its own window) with this API.
// - DockBuilderSplitNode() create 2 child nodes within 1 node. The initial node becomes a parent node.
// - If you intend to split the node immediately after creation using DockBuilderSplitNode(), make sure
//   to call DockBuilderSetNodeSize() beforehand. If you don't, the resulting split sizes may not be reliable.
// - Call DockBuilderFinish() after you are done.
//-----------------------------------------------------------------------------
// Docking: Builder Functions
//-----------------------------------------------------------------------------
// Very early end-user API to manipulate dock nodes.
// Only available in imgui_internal.h. Expect this API to change/break!
// It is expected that those functions are all called _before_ the dockspace node submission.
//-----------------------------------------------------------------------------
// - DockBuilderDockWindow()
// - DockBuilderGetNode()
// - DockBuilderSetNodePos()
// - DockBuilderSetNodeSize()
// - DockBuilderAddNode()
// - DockBuilderRemoveNode()
// - DockBuilderRemoveNodeChildNodes()
// - DockBuilderRemoveNodeDockedWindows()
// - DockBuilderSplitNode()
// - DockBuilderCopyNodeRec()
// - DockBuilderCopyNode()
// - DockBuilderCopyWindowSettings()
// - DockBuilderCopyDockSpace()
// - DockBuilderFinish()
//-----------------------------------------------------------------------------

DockBuilderDockWindow :: proc(window_name : ^u8, node_id : ImGuiID)
{
	// We don't preserve relative order of multiple docked windows (by clearing DockOrder back to -1)
	g : ^ImGuiContext = GImGui^; IM_UNUSED(g)
	IMGUI_DEBUG_LOG_DOCKING("[docking] DockBuilderDockWindow '%s' to node 0x%08X\n", window_name, node_id)
	window_id : ImGuiID = ImHashStr(window_name)
	if window : ^ImGuiWindow = FindWindowByID(window_id); window {
		// Apply to created window
		prev_node_id : ImGuiID = window.DockId
		SetWindowDock(window, node_id, ImGuiCond_.ImGuiCond_Always)
		if window.DockId != prev_node_id { window.DockOrder = -1 }
	}
	else {
		// Apply to settings
		settings : ^ImGuiWindowSettings = FindWindowSettingsByID(window_id)
		if settings == nil { settings = CreateNewWindowSettings(window_name) }
		if settings.DockId != node_id { settings.DockOrder = -1 }
		settings.DockId = node_id
	}
}

DockBuilderGetNode :: proc(node_id : ImGuiID) -> ^ImGuiDockNode
{
	g : ^ImGuiContext = GImGui^
	return DockContextFindNodeByID(&g, node_id)
}

DockBuilderSetNodePos :: proc(node_id : ImGuiID, pos : ImVec2)
{
	g : ^ImGuiContext = GImGui^
	node : ^ImGuiDockNode = DockContextFindNodeByID(&g, node_id)
	if node == nil { return }
	node.Pos = pos
	node.AuthorityForPos = ImGuiDataAuthority_.ImGuiDataAuthority_DockNode
}

DockBuilderSetNodeSize :: proc(node_id : ImGuiID, size : ImVec2)
{
	g : ^ImGuiContext = GImGui^
	node : ^ImGuiDockNode = DockContextFindNodeByID(&g, node_id)
	if node == nil { return }
	IM_ASSERT(size.x > 0.0 && size.y > 0.0)
	node.SizeRef = size; node.Size = node.SizeRef
	node.AuthorityForSize = ImGuiDataAuthority_.ImGuiDataAuthority_DockNode
}

// Make sure to use the ImGuiDockNodeFlags_DockSpace flag to create a dockspace node! Otherwise this will create a floating node!
// - Floating node: you can then call DockBuilderSetNodePos()/DockBuilderSetNodeSize() to position and size the floating node.
// - Dockspace node: calling DockBuilderSetNodePos() is unnecessary.
// - If you intend to split a node immediately after creation using DockBuilderSplitNode(), make sure to call DockBuilderSetNodeSize() beforehand!
//   For various reason, the splitting code currently needs a base size otherwise space may not be allocated as precisely as you would expect.
// - Use (id == 0) to let the system allocate a node identifier.
// - Existing node with a same id will be removed.
DockBuilderAddNode :: proc(node_id : ImGuiID, flags : ImGuiDockNodeFlags) -> ImGuiID
{
	g : ^ImGuiContext = GImGui^; IM_UNUSED(g)
	IMGUI_DEBUG_LOG_DOCKING("[docking] DockBuilderAddNode 0x%08X flags=%08X\n", node_id, flags)

	if node_id != 0 { DockBuilderRemoveNode(node_id) }

	node : ^ImGuiDockNode = nil
	if ImGuiDockNodeFlags_DockSpace : ^flags; ImGuiDockNodeFlags_DockSpace {
		DockSpace(node_id, ImVec2(0, 0), (flags & !ImGuiDockNodeFlags_DockSpace) | ImGuiDockNodeFlags_.ImGuiDockNodeFlags_KeepAliveOnly)
		node = DockContextFindNodeByID(&g, node_id)
	}
	else {
		node = DockContextAddNode(&g, node_id)
		SetLocalFlags(node, flags)
	}
	node.LastFrameAlive = g.FrameCount; // Set this otherwise BeginDocked will undock during the same frame.
	return node.ID
}

// Remove node and all its child, undock all windows
DockBuilderRemoveNode :: proc(node_id : ImGuiID)
{
	g : ^ImGuiContext = GImGui^; IM_UNUSED(g)
	IMGUI_DEBUG_LOG_DOCKING("[docking] DockBuilderRemoveNode 0x%08X\n", node_id)

	node : ^ImGuiDockNode = DockContextFindNodeByID(&g, node_id)
	if node == nil { return }
	DockBuilderRemoveNodeDockedWindows(node_id, true)
	DockBuilderRemoveNodeChildNodes(node_id)
	// Node may have moved or deleted if e.g. any merge happened
	node = DockContextFindNodeByID(&g, node_id)
	if node == nil { return }
	if IsCentralNode(node) && node.ParentNode { SetLocalFlags(node.ParentNode, node.ParentNode.LocalFlags | ImGuiDockNodeFlagsPrivate_.ImGuiDockNodeFlags_CentralNode) }
	DockContextRemoveNode(&g, node, true)
}

// Remove all split/hierarchy. All remaining docked windows will be re-docked to the remaining root node (node_id).
// root_id = 0 to remove all, root_id != 0 to remove child of given node.
DockBuilderRemoveNodeChildNodes :: proc(root_id : ImGuiID)
{
	g : ^ImGuiContext = GImGui^
	dc : ^ImGuiDockContext = &g.DockContext

	root_node : ^ImGuiDockNode = root_id ? DockContextFindNodeByID(&g, root_id) : nil
	if root_id && root_node == nil { return }
	has_central_node : bool = false

	backup_root_node_authority_for_pos : ImGuiDataAuthority = root_node ? root_node.AuthorityForPos : ImGuiDataAuthority_.ImGuiDataAuthority_Auto
	backup_root_node_authority_for_size : ImGuiDataAuthority = root_node ? root_node.AuthorityForSize : ImGuiDataAuthority_.ImGuiDataAuthority_Auto

	// Process active windows
	nodes_to_remove : ImVector(^ImGuiDockNode)
	for n : i32 = 0; n < dc.Nodes.Data.Size; post_incr(&n) { if node : ^ImGuiDockNode = cast(^ImGuiDockNode) dc.Nodes.Data[n].val_p; node {
	want_removal : bool = (root_id == 0) || (node.ID != root_id && DockNodeGetRootNode(node).ID == root_id)
	if want_removal {
		if IsCentralNode(node) { has_central_node = true }
		if root_id != 0 { DockContextQueueNotifyRemovedNode(&g, node) }
		if root_node {
			DockNodeMoveWindows(root_node, node)
			DockSettingsRenameNodeReferences(node.ID, root_node.ID)
		}
		push_back(&nodes_to_remove, node)
	}
} }

	// DockNodeMoveWindows->DockNodeAddWindow will normally set those when reaching two windows (which is only adequate during interactive merge)
	// Make sure we don't lose our current pos/size. (FIXME-DOCK: Consider tidying up that code in DockNodeAddWindow instead)
	if root_node {
		root_node.AuthorityForPos = backup_root_node_authority_for_pos
		root_node.AuthorityForSize = backup_root_node_authority_for_size
	}

	// Apply to settings
	for settings : ^ImGuiWindowSettings = begin(&g.SettingsWindows); settings != nil; settings = next_chunk(&g.SettingsWindows, settings) { if window_settings_dock_id : ImGuiID = settings.DockId; window_settings_dock_id { for n : i32 = 0; n < nodes_to_remove.Size; post_incr(&n) { if nodes_to_remove[n].ID == window_settings_dock_id {
	settings.DockId = root_id
	break
} } } }

	// Not really efficient, but easier to destroy a whole hierarchy considering DockContextRemoveNode is attempting to merge nodes
	if nodes_to_remove.Size > 1 { ImQsort(nodes_to_remove.Data, nodes_to_remove.Size, size_of(^ImGuiDockNode), DockNodeComparerDepthMostFirst) }
	for n : i32 = 0; n < nodes_to_remove.Size; post_incr(&n) { DockContextRemoveNode(&g, nodes_to_remove[n], false) }

	if root_id == 0 {
		Clear(&dc.Nodes)
		clear(&dc.Requests)
	}
	else if has_central_node {
		root_node.CentralNode = root_node
		SetLocalFlags(root_node, root_node.LocalFlags | ImGuiDockNodeFlagsPrivate_.ImGuiDockNodeFlags_CentralNode)
	}
}

DockBuilderRemoveNodeDockedWindows :: proc(root_id : ImGuiID, clear_settings_refs : bool)
{
	// Clear references in settings
	g : ^ImGuiContext = GImGui^
	if clear_settings_refs {
		for settings : ^ImGuiWindowSettings = begin(&g.SettingsWindows); settings != nil; settings = next_chunk(&g.SettingsWindows, settings) {
			want_removal : bool = (root_id == 0) || (settings.DockId == root_id)
			if !want_removal && settings.DockId != 0 { if node : ^ImGuiDockNode = DockContextFindNodeByID(&g, settings.DockId); node { if DockNodeGetRootNode(node).ID == root_id { want_removal = true } } }
			if want_removal { settings.DockId = 0 }
		}
	}

	// Clear references in windows
	for n : i32 = 0; n < g.Windows.Size; post_incr(&n) {
		window : ^ImGuiWindow = g.Windows[n]
		want_removal : bool = (root_id == 0) || (window.DockNode && DockNodeGetRootNode(window.DockNode).ID == root_id) || (window.DockNodeAsHost && window.DockNodeAsHost.ID == root_id)
		if want_removal {
			backup_dock_id : ImGuiID = window.DockId
			IM_UNUSED(backup_dock_id)
			DockContextProcessUndockWindow(&g, window, clear_settings_refs)
			if !clear_settings_refs { IM_ASSERT(window.DockId == backup_dock_id) }
		}
	}
}

// Create 2 child nodes in this parent node.
// If 'out_id_at_dir' or 'out_id_at_opposite_dir' are non NULL, the function will write out the ID of the two new nodes created.
// Return value is ID of the node at the specified direction, so same as (*out_id_at_dir) if that pointer is set.
// FIXME-DOCK: We are not exposing nor using split_outer.
DockBuilderSplitNode :: proc(id : ImGuiID, split_dir : ImGuiDir, size_ratio_for_node_at_dir : f32, out_id_at_dir : ^ImGuiID, out_id_at_opposite_dir : ^ImGuiID) -> ImGuiID
{
	g : ^ImGuiContext = GImGui^
	IM_ASSERT(split_dir != ImGuiDir.ImGuiDir_None)
	IMGUI_DEBUG_LOG_DOCKING("[docking] DockBuilderSplitNode: node 0x%08X, split_dir %d\n", id, split_dir)

	node : ^ImGuiDockNode = DockContextFindNodeByID(&g, id)
	if node == nil {
		IM_ASSERT(node != nil)
		return 0
	}

	IM_ASSERT(!IsSplitNode(node)); // Assert if already Split

	req : ImGuiDockRequest
	req.Type = ImGuiDockRequestType.ImGuiDockRequestType_Split
	req.DockTargetWindow = nil
	req.DockTargetNode = node
	req.DockPayload = nil
	req.DockSplitDir = split_dir
	req.DockSplitRatio = ImSaturate((split_dir == ImGuiDir.ImGuiDir_Left || split_dir == ImGuiDir.ImGuiDir_Up) ? size_ratio_for_node_at_dir : 1.0 - size_ratio_for_node_at_dir)
	req.DockSplitOuter = false
	DockContextProcessDock(&g, &req)

	id_at_dir : ImGuiID = node.ChildNodes[(split_dir == ImGuiDir.ImGuiDir_Left || split_dir == ImGuiDir.ImGuiDir_Up) ? 0 : 1].ID
	id_at_opposite_dir : ImGuiID = node.ChildNodes[(split_dir == ImGuiDir.ImGuiDir_Left || split_dir == ImGuiDir.ImGuiDir_Up) ? 1 : 0].ID
	if out_id_at_dir { out_id_at_dir^ = id_at_dir }
	if out_id_at_opposite_dir { out_id_at_opposite_dir^ = id_at_opposite_dir }
	return id_at_dir
}

DockBuilderCopyNodeRec :: proc(src_node : ^ImGuiDockNode, dst_node_id_if_known : ImGuiID, out_node_remap_pairs : ^ImVector(ImGuiID)) -> ^ImGuiDockNode
{
	g : ^ImGuiContext = GImGui^
	dst_node : ^ImGuiDockNode = DockContextAddNode(&g, dst_node_id_if_known)
	dst_node.SharedFlags = src_node.SharedFlags
	dst_node.LocalFlags = src_node.LocalFlags
	dst_node.LocalFlagsInWindows = ImGuiDockNodeFlags_.ImGuiDockNodeFlags_None
	dst_node.Pos = src_node.Pos
	dst_node.Size = src_node.Size
	dst_node.SizeRef = src_node.SizeRef
	dst_node.SplitAxis = src_node.SplitAxis
	UpdateMergedFlags(dst_node)

	push_back(out_node_remap_pairs, src_node.ID)
	push_back(out_node_remap_pairs, dst_node.ID)

	for child_n : i32 = 0; child_n < IM_ARRAYSIZE(src_node.ChildNodes); post_incr(&child_n) { if src_node.ChildNodes[child_n] {
	dst_node.ChildNodes[child_n] = DockBuilderCopyNodeRec(src_node.ChildNodes[child_n], 0, out_node_remap_pairs)
	dst_node.ChildNodes[child_n].ParentNode = dst_node
} }

	IMGUI_DEBUG_LOG_DOCKING("[docking] Fork node %08X -> %08X (%d childs)\n", src_node.ID, dst_node.ID, IsSplitNode(dst_node) ? 2 : 0)
	return dst_node
}

DockBuilderCopyNode :: proc(src_node_id : ImGuiID, dst_node_id : ImGuiID, out_node_remap_pairs : ^ImVector(ImGuiID))
{
	g : ^ImGuiContext = GImGui^
	IM_ASSERT(src_node_id != 0)
	IM_ASSERT(dst_node_id != 0)
	IM_ASSERT(out_node_remap_pairs != nil)

	DockBuilderRemoveNode(dst_node_id)

	src_node : ^ImGuiDockNode = DockContextFindNodeByID(&g, src_node_id)
	IM_ASSERT(src_node != nil)

	clear(out_node_remap_pairs)
	DockBuilderCopyNodeRec(src_node, dst_node_id, out_node_remap_pairs)

	IM_ASSERT((out_node_remap_pairs.Size % 2) == 0)
}

DockBuilderCopyWindowSettings :: proc(src_name : ^u8, dst_name : ^u8)
{
	src_window : ^ImGuiWindow = FindWindowByName(src_name)
	if src_window == nil { return }
	if dst_window : ^ImGuiWindow = FindWindowByName(dst_name); dst_window {
		dst_window.Pos = src_window.Pos
		dst_window.Size = src_window.Size
		dst_window.SizeFull = src_window.SizeFull
		dst_window.Collapsed = src_window.Collapsed
	}
	else {
		dst_settings : ^ImGuiWindowSettings = FindWindowSettingsByID(ImHashStr(dst_name))
		if !dst_settings { dst_settings = CreateNewWindowSettings(dst_name) }
		window_pos_2ih : ImVec2ih = ImVec2ih(src_window.Pos)
		if src_window.ViewportId != 0 && src_window.ViewportId != IMGUI_VIEWPORT_DEFAULT_ID {
			dst_settings.ViewportPos = window_pos_2ih
			dst_settings.ViewportId = src_window.ViewportId
			dst_settings.Pos = ImVec2ih(0, 0)
		}
		else {
			dst_settings.Pos = window_pos_2ih
		}
		dst_settings.Size = ImVec2ih(src_window.SizeFull)
		dst_settings.Collapsed = src_window.Collapsed
	}
}

// FIXME: Will probably want to change this signature, in particular how the window remapping pairs are passed.
DockBuilderCopyDockSpace :: proc(src_dockspace_id : ImGuiID, dst_dockspace_id : ImGuiID, in_window_remap_pairs : ^ImVector(^u8))
{
	g : ^ImGuiContext = GImGui^
	IM_ASSERT(src_dockspace_id != 0)
	IM_ASSERT(dst_dockspace_id != 0)
	IM_ASSERT(in_window_remap_pairs != nil)
	IM_ASSERT((in_window_remap_pairs.Size % 2) == 0)

	// Duplicate entire dock
	// FIXME: When overwriting dst_dockspace_id, windows that aren't part of our dockspace window class but that are docked in a same node will be split apart,
	// whereas we could attempt to at least keep them together in a new, same floating node.
	node_remap_pairs : ImVector(ImGuiID)
	DockBuilderCopyNode(src_dockspace_id, dst_dockspace_id, &node_remap_pairs)

	// Attempt to transition all the upcoming windows associated to dst_dockspace_id into the newly created hierarchy of dock nodes
	// (The windows associated to src_dockspace_id are staying in place)
	src_windows : ImVector(ImGuiID)
	for remap_window_n : i32 = 0; remap_window_n < in_window_remap_pairs.Size; remap_window_n += 2 {
		src_window_name : ^u8 = (in_window_remap_pairs^)[remap_window_n]
		dst_window_name : ^u8 = (in_window_remap_pairs^)[remap_window_n + 1]
		src_window_id : ImGuiID = ImHashStr(src_window_name)
		push_back(&src_windows, src_window_id)

		// Search in the remapping tables
		src_dock_id : ImGuiID = 0
		if src_window : ^ImGuiWindow = FindWindowByID(src_window_id); src_window { src_dock_id = src_window.DockId }
		else if src_window_settings : ^ImGuiWindowSettings = FindWindowSettingsByID(src_window_id); src_window_settings { src_dock_id = src_window_settings.DockId }
		dst_dock_id : ImGuiID = 0
		for dock_remap_n : i32 = 0; dock_remap_n < node_remap_pairs.Size; dock_remap_n += 2 { if node_remap_pairs[dock_remap_n] == src_dock_id {
	dst_dock_id = node_remap_pairs[dock_remap_n + 1]
	//node_remap_pairs[dock_remap_n] = node_remap_pairs[dock_remap_n + 1] = 0; // Clear
	break
} }

		if dst_dock_id != 0 {
			// Docked windows gets redocked into the new node hierarchy.
			IMGUI_DEBUG_LOG_DOCKING("[docking] Remap live window '%s' 0x%08X -> '%s' 0x%08X\n", src_window_name, src_dock_id, dst_window_name, dst_dock_id)
			DockBuilderDockWindow(dst_window_name, dst_dock_id)
		}
		else {
			// Floating windows gets their settings transferred (regardless of whether the new window already exist or not)
			// When this is leading to a Copy and not a Move, we would get two overlapping floating windows. Could we possibly dock them together?
			IMGUI_DEBUG_LOG_DOCKING("[docking] Remap window settings '%s' -> '%s'\n", src_window_name, dst_window_name)
			DockBuilderCopyWindowSettings(src_window_name, dst_window_name)
		}
	}

	// Anything else in the source nodes of 'node_remap_pairs' are windows that are not included in the remapping list.
// Find those windows and move to them to the cloned dock node. This may be optional?
// Dock those are a second step as undocking would invalidate source dock nodes.
DockRemainingWindowTask :: struct { Window : ^ImGuiWindow, DockId : ImGuiID, }

	DockRemainingWindowTask_init :: proc(this : ^DockRemainingWindowTask, window : ^ImGuiWindow, dock_id : ImGuiID)
	{
		this.Window = window; this.DockId = dock_id
	}

	dock_remaining_windows : ImVector(DockRemainingWindowTask)
	for dock_remap_n : i32 = 0; dock_remap_n < node_remap_pairs.Size; dock_remap_n += 2 { if src_dock_id : ImGuiID = node_remap_pairs[dock_remap_n]; src_dock_id {
	dst_dock_id : ImGuiID = node_remap_pairs[dock_remap_n + 1]
	node : ^ImGuiDockNode = DockBuilderGetNode(src_dock_id)
	for window_n : i32 = 0; window_n < node.Windows.Size; post_incr(&window_n) {
		window : ^ImGuiWindow = node.Windows[window_n]
		if contains(&src_windows, window.ID) { continue }

		// Docked windows gets redocked into the new node hierarchy.
		IMGUI_DEBUG_LOG_DOCKING("[docking] Remap window '%s' %08X -> %08X\n", window.Name, src_dock_id, dst_dock_id)
		push_back(&dock_remaining_windows, DockRemainingWindowTask(window, dst_dock_id))
	}
} }

	for task in dock_remaining_windows { DockBuilderDockWindow(task.Window.Name, task.DockId) }
}

// FIXME-DOCK: This is awkward because in series of split user is likely to loose access to its root node.
DockBuilderFinish :: proc(root_id : ImGuiID)
{
	g : ^ImGuiContext = GImGui^
	//DockContextRebuild(&g);
	DockContextBuildAddWindowsToNodes(&g, root_id)
}

//-----------------------------------------------------------------------------
// Docking: Begin/End Support Functions (called from Begin/End)
//-----------------------------------------------------------------------------
// - GetWindowAlwaysWantOwnTabBar()
// - DockContextBindNodeToWindow()
// - BeginDocked()
// - BeginDockableDragDropSource()
// - BeginDockableDragDropTarget()
//-----------------------------------------------------------------------------

GetWindowAlwaysWantOwnTabBar :: proc(window : ^ImGuiWindow) -> bool
{
	g : ^ImGuiContext = GImGui^
	if g.IO.ConfigDockingAlwaysTabBar || window.WindowClass.DockingAlwaysTabBar { if (window.Flags & (ImGuiWindowFlags_.ImGuiWindowFlags_ChildWindow | ImGuiWindowFlags_.ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_.ImGuiWindowFlags_NoDocking)) == 0 { if !window.IsFallbackWindow {
	// We don't support AlwaysTabBar on the fallback/implicit window to avoid unused dock-node overhead/noisereturn true
} } }
	return false
}

DockContextBindNodeToWindow :: proc(ctx : ^ImGuiContext, window : ^ImGuiWindow) -> ^ImGuiDockNode
{
	g : ^ImGuiContext = ctx^
	node : ^ImGuiDockNode = DockContextFindNodeByID(ctx, window.DockId)
	IM_ASSERT(window.DockNode == nil)

	// We should not be docking into a split node (SetWindowDock should avoid this)
	if node && IsSplitNode(node) {
		DockContextProcessUndockWindow(ctx, window)
		return nil
	}

	// Create node
	if node == nil {
		node = DockContextAddNode(ctx, window.DockId)
		node.AuthorityForViewport = ImGuiDataAuthority_.ImGuiDataAuthority_Window; node.AuthorityForSize = node.AuthorityForViewport; node.AuthorityForPos = node.AuthorityForSize
		node.LastFrameAlive = g.FrameCount
	}

	// If the node just turned visible and is part of a hierarchy, it doesn't have a Size assigned by DockNodeTreeUpdatePosSize() yet,
	// so we're forcing a Pos/Size update from the first ancestor that is already visible (often it will be the root node).
	// If we don't do this, the window will be assigned a zero-size on its first frame, which won't ideally warm up the layout.
	// This is a little wonky because we don't normally update the Pos/Size of visible node mid-frame.
	if !node.IsVisible {
		ancestor_node : ^ImGuiDockNode = node
		for !ancestor_node.IsVisible && ancestor_node.ParentNode { ancestor_node = ancestor_node.ParentNode }

		IM_ASSERT(ancestor_node.Size.x > 0.0 && ancestor_node.Size.y > 0.0)
		DockNodeUpdateHasCentralNodeChild(DockNodeGetRootNode(ancestor_node))
		DockNodeTreeUpdatePosSize(ancestor_node, ancestor_node.Pos, ancestor_node.Size, node)
	}

	// Add window to node
	node_was_visible : bool = node.IsVisible
	DockNodeAddWindow(node, window, true)
	node.IsVisible = node_was_visible; // Don't mark visible right away (so DockContextEndFrame() doesn't render it, maybe other side effects? will see)
	IM_ASSERT(node == window.DockNode)
	return node
}

StoreDockStyleForWindow :: proc(window : ^ImGuiWindow)
{
	g : ^ImGuiContext = GImGui^
	for color_n : i32 = 0; color_n < ImGuiWindowDockStyleCol.ImGuiWindowDockStyleCol_COUNT; post_incr(&color_n) { window.DockStyle.Colors[color_n] = ColorConvertFloat4ToU32(g.Style.Colors[GWindowDockStyleColors[color_n]]) }
}

BeginDocked :: proc(window : ^ImGuiWindow, p_open : ^bool)
{
	g : ^ImGuiContext = GImGui^

	// Clear fields ahead so most early-out paths don't have to do it
	window.DockTabIsVisible = false; window.DockNodeIsVisible = window.DockTabIsVisible; window.DockIsActive = window.DockNodeIsVisible

	auto_dock_node : bool = GetWindowAlwaysWantOwnTabBar(window)
	if auto_dock_node {
		if window.DockId == 0 {
			IM_ASSERT(window.DockNode == nil)
			window.DockId = DockContextGenNodeID(&g)
		}
	}
	else {
		// Calling SetNextWindowPos() undock windows by default (by setting PosUndock)
		want_undock : bool = false
		want_undock |= (window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoDocking) != 0
		want_undock |= (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_.ImGuiNextWindowDataFlags_HasPos) && (window.SetWindowPosAllowFlags & g.NextWindowData.PosCond) && g.NextWindowData.PosUndock
		if want_undock {
			DockContextProcessUndockWindow(&g, window)
			return
		}
	}

	// Bind to our dock node
	node : ^ImGuiDockNode = window.DockNode
	if node != nil { IM_ASSERT(window.DockId == node.ID) }
	if window.DockId != 0 && node == nil {
		node = DockContextBindNodeToWindow(&g, window)
		if node == nil { return }
	}



	// Undock if our dockspace node disappeared
	// Note how we are testing for LastFrameAlive and NOT LastFrameActive. A DockSpace node can be maintained alive while being inactive with ImGuiDockNodeFlags_KeepAliveOnly.
	if node.LastFrameAlive < g.FrameCount {
		// If the window has been orphaned, transition the docknode to an implicit node processed in DockContextNewFrameUpdateDocking()
		root_node : ^ImGuiDockNode = DockNodeGetRootNode(node)
		if root_node.LastFrameAlive < g.FrameCount { DockContextProcessUndockWindow(&g, window) }
		else { window.DockIsActive = true }
		return
	}

	// Store style overrides
	StoreDockStyleForWindow(window)

	// Fast path return. It is common for windows to hold on a persistent DockId but be the only visible window,
	// and never create neither a host window neither a tab bar.
	// FIXME-DOCK: replace ->HostWindow NULL compare with something more explicit (~was initially intended as a first frame test)
	if node.HostWindow == nil {
		if node.State == ImGuiDockNodeState.ImGuiDockNodeState_HostWindowHiddenBecauseWindowsAreResizing { window.DockIsActive = true }
		if node.Windows.Size > 1 && window.Appearing {
			// Only hide appearing windowDockNodeHideWindowDuringHostWindowCreation(window)
		}
		return
	}

	// We can have zero-sized nodes (e.g. children of a small-size dockspace)
	IM_ASSERT(node.HostWindow)
	IM_ASSERT(IsLeafNode(node))
	IM_ASSERT(node.Size.x >= 0.0 && node.Size.y >= 0.0)
	node.State = ImGuiDockNodeState.ImGuiDockNodeState_HostWindowVisible

	// Undock if we are submitted earlier than the host window
	if !(node.MergedFlags & ImGuiDockNodeFlags_.ImGuiDockNodeFlags_KeepAliveOnly) && window.BeginOrderWithinContext < node.HostWindow.BeginOrderWithinContext {
		DockContextProcessUndockWindow(&g, window)
		return
	}

	// Position/Size window
	SetNextWindowPos(node.Pos)
	SetNextWindowSize(node.Size)
	g.NextWindowData.PosUndock = false; // Cancel implicit undocking of SetNextWindowPos()
	window.DockIsActive = true
	window.DockNodeIsVisible = true
	window.DockTabIsVisible = false
	if node.MergedFlags & ImGuiDockNodeFlags_.ImGuiDockNodeFlags_KeepAliveOnly { return }

	// When the window is selected we mark it as visible.
	if node.VisibleWindow == window { window.DockTabIsVisible = true }

	// Update window flag
	IM_ASSERT((window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_ChildWindow) == 0)
	window.Flags |= ImGuiWindowFlags_.ImGuiWindowFlags_ChildWindow | ImGuiWindowFlags_.ImGuiWindowFlags_NoResize
	window.ChildFlags |= ImGuiChildFlags_.ImGuiChildFlags_AlwaysUseWindowPadding
	if IsHiddenTabBar(node) || IsNoTabBar(node) { window.Flags |= ImGuiWindowFlags_.ImGuiWindowFlags_NoTitleBar }
	else {
		// Clear the NoTitleBar flag in case the user set it: confusingly enough we need a title bar height so we are correctly offset, but it won't be displayed!
		window.Flags &= !ImGuiWindowFlags_.ImGuiWindowFlags_NoTitleBar
	}

	// Save new dock order only if the window has been visible once already
	// This allows multiple windows to be created in the same frame and have their respective dock orders preserved.
	if node.TabBar && window.WasActive { window.DockOrder = cast(i16) DockNodeGetTabOrder(window) }

	if (node.WantCloseAll || node.WantCloseTabId == window.TabId) && p_open != nil { p_open^ = false }

	// Update ChildId to allow returning from Child to Parent with Escape
	parent_window : ^ImGuiWindow = window.DockNode.HostWindow
	window.ChildId = GetID(parent_window, window.Name)
}

BeginDockableDragDropSource :: proc(window : ^ImGuiWindow)
{
	g : ^ImGuiContext = GImGui^
	IM_ASSERT(g.ActiveId == window.MoveId)
	IM_ASSERT(g.MovingWindow == window)
	IM_ASSERT(g.CurrentWindow == window)

	// 0: Hold SHIFT to disable docking, 1: Hold SHIFT to enable docking.
	if g.IO.ConfigDockingWithShift != g.IO.KeyShift {
		// When ConfigDockingWithShift is set, display a tooltip to increase UI affordance.
		// We cannot set for HoveredWindowUnderMovingWindow != NULL here, as it is only valid/useful when drag and drop is already active
		// (because of the 'is_mouse_dragging_with_an_expected_destination' logic in UpdateViewportsNewFrame() function)
		IM_ASSERT(g.NextWindowData.Flags == 0)
		if g.IO.ConfigDockingWithShift && g.MouseStationaryTimer >= 1.0 && g.ActiveId >= 1.0 { SetTooltip("%s", LocalizeGetMsg(ImGuiLocKey.ImGuiLocKey_DockingHoldShiftToDock)) }
		return
	}

	g.LastItemData.ID = window.MoveId
	window = window.RootWindowDockTree
	IM_ASSERT((window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoDocking) == 0)
	is_drag_docking : bool = (g.IO.ConfigDockingWithShift) || Contains(&ImRect(0, 0, window.SizeFull.x, GetFrameHeight()), g.ActiveIdClickOffset); // FIXME-DOCKING: Need to make this stateful and explicit
	drag_drop_flags : ImGuiDragDropFlags = ImGuiDragDropFlags_.ImGuiDragDropFlags_SourceNoPreviewTooltip | ImGuiDragDropFlags_.ImGuiDragDropFlags_SourceNoHoldToOpenOthers | ImGuiDragDropFlags_.ImGuiDragDropFlags_PayloadAutoExpire | ImGuiDragDropFlags_.ImGuiDragDropFlags_PayloadNoCrossContext | ImGuiDragDropFlags_.ImGuiDragDropFlags_PayloadNoCrossProcess
	if is_drag_docking && BeginDragDropSource(drag_drop_flags) {
		SetDragDropPayload(IMGUI_PAYLOAD_TYPE_WINDOW, &window, size_of(window))
		EndDragDropSource()
		StoreDockStyleForWindow(window); // Store style overrides while dragging (even when not docked) because docking preview may need it.
	}
}

BeginDockableDragDropTarget :: proc(window : ^ImGuiWindow)
{
	g : ^ImGuiContext = GImGui^

	//IM_ASSERT(window->RootWindowDockTree == window); // May also be a DockSpace
	IM_ASSERT((window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoDocking) == 0)
	if !g.DragDropActive { return }
	//GetForegroundDrawList(window)->AddRect(window->Pos, window->Pos + window->Size, IM_COL32(255, 255, 0, 255));
	if !BeginDragDropTargetCustom(Rect(window), window.ID) { return }

	// Peek into the payload before calling AcceptDragDropPayload() so we can handle overlapping dock nodes with filtering
	// (this is a little unusual pattern, normally most code would call AcceptDragDropPayload directly)
	payload : ^ImGuiPayload = &g.DragDropPayload
	if !IsDataType(payload, IMGUI_PAYLOAD_TYPE_WINDOW) || !DockNodeIsDropAllowed(window, cast(^^ImGuiWindow) payload.Data^) {
		EndDragDropTarget()
		return
	}

	payload_window : ^ImGuiWindow = cast(^^ImGuiWindow) payload.Data^
	if AcceptDragDropPayload(IMGUI_PAYLOAD_TYPE_WINDOW, ImGuiDragDropFlags_.ImGuiDragDropFlags_AcceptBeforeDelivery | ImGuiDragDropFlags_.ImGuiDragDropFlags_AcceptNoDrawDefaultRect) {
		// Select target node
		// (Important: we cannot use g.HoveredDockNode here! Because each of our target node have filters based on payload, each candidate drop target will do its own evaluation)
		dock_into_floating_window : bool = false
		node : ^ImGuiDockNode = nil
		if window.DockNodeAsHost {
			// Cannot assume that node will != NULL even though we passed the rectangle test: it depends on padding/spacing handled by DockNodeTreeFindVisibleNodeByPos().
			node = DockNodeTreeFindVisibleNodeByPos(window.DockNodeAsHost, g.IO.MousePos)

			// There is an edge case when docking into a dockspace which only has _inactive_ nodes (because none of the windows are active)
			// In this case we need to fallback into any leaf mode, possibly the central node.
			// FIXME-20181220: We should not have to test for IsLeafNode() here but we have another bug to fix first.
			if node && IsDockSpace(node) && IsRootNode(node) { node = (node.CentralNode && IsLeafNode(node)) ? node.CentralNode : DockNodeTreeFindFallbackLeafNode(node) }
		}
		else {
			if window.DockNode { node = window.DockNode }
			else {
				// Dock into a regular window
				dock_into_floating_window = true
			}
		}

		explicit_target_rect : ImRect = (node && node.TabBar && !IsHiddenTabBar(node) && !IsNoTabBar(node)) ? node.TabBar.BarRect : ImRect(window.Pos, window.Pos + ImVec2(window.Size.x, GetFrameHeight()))
		is_explicit_target : bool = g.IO.ConfigDockingWithShift || IsMouseHoveringRect(explicit_target_rect.Min, explicit_target_rect.Max)

		// Preview docking request and find out split direction/ratio
		//const bool do_preview = true;     // Ignore testing for payload->IsPreview() which removes one frame of delay, but breaks overlapping drop targets within the same window.
		do_preview : bool = IsPreview(payload) || IsDelivery(payload)
		if do_preview && (node != nil || dock_into_floating_window) {
			// If we have a non-leaf node it means we are hovering the border of a parent node, in which case only outer markers will appear.
			split_inner : ImGuiDockPreviewData
			split_outer : ImGuiDockPreviewData
			split_data : ^ImGuiDockPreviewData = &split_inner
			if node && (node.ParentNode || IsCentralNode(node) || !IsLeafNode(node)) { if root_node : ^ImGuiDockNode = DockNodeGetRootNode(node); root_node {
	DockNodePreviewDockSetup(window, root_node, payload_window, nil, &split_outer, is_explicit_target, true)
	if split_outer.IsSplitDirExplicit { split_data = &split_outer }
} }
			if !node || IsLeafNode(node) { DockNodePreviewDockSetup(window, node, payload_window, nil, &split_inner, is_explicit_target, false) }
			if split_data == &split_outer { split_inner.IsDropAllowed = false }

			// Draw inner then outer, so that previewed tab (in inner data) will be behind the outer drop boxes
			DockNodePreviewDockRender(window, node, payload_window, &split_inner)
			DockNodePreviewDockRender(window, node, payload_window, &split_outer)

			// Queue docking request
			if split_data.IsDropAllowed && IsDelivery(payload) { DockContextQueueDock(&g, window, split_data.SplitNode, payload_window, split_data.SplitDir, split_data.SplitRatio, split_data == &split_outer) }
		}
	}
	EndDragDropTarget()
}

// Settings
//-----------------------------------------------------------------------------
// Docking: Settings
//-----------------------------------------------------------------------------
// - DockSettingsRenameNodeReferences()
// - DockSettingsRemoveNodeReferences()
// - DockSettingsFindNodeSettings()
// - DockSettingsHandler_ApplyAll()
// - DockSettingsHandler_ReadOpen()
// - DockSettingsHandler_ReadLine()
// - DockSettingsHandler_DockNodeToSettings()
// - DockSettingsHandler_WriteAll()
//-----------------------------------------------------------------------------

DockSettingsRenameNodeReferences :: proc(old_node_id : ImGuiID, new_node_id : ImGuiID)
{
	g : ^ImGuiContext = GImGui^
	IMGUI_DEBUG_LOG_DOCKING("[docking] DockSettingsRenameNodeReferences: from 0x%08X -> to 0x%08X\n", old_node_id, new_node_id)
	for window_n : i32 = 0; window_n < g.Windows.Size; post_incr(&window_n) {
		window : ^ImGuiWindow = g.Windows[window_n]
		if window.DockId == old_node_id && window.DockNode == nil { window.DockId = new_node_id }
	}

	//// FIXME-OPT: We could remove this loop by storing the index in the map
	for settings : ^ImGuiWindowSettings = begin(&g.SettingsWindows); settings != nil; settings = next_chunk(&g.SettingsWindows, settings) { if settings.DockId == old_node_id { settings.DockId = new_node_id } }
}

// Remove references stored in ImGuiWindowSettings to the given ImGuiDockNodeSettings
DockSettingsRemoveNodeReferences :: proc(node_ids : ^ImGuiID, node_ids_count : i32)
{
	g : ^ImGuiContext = GImGui^
	found : i32 = 0
	//// FIXME-OPT: We could remove this loop by storing the index in the map
	for settings : ^ImGuiWindowSettings = begin(&g.SettingsWindows); settings != nil; settings = next_chunk(&g.SettingsWindows, settings) { for node_n : i32 = 0; node_n < node_ids_count; post_incr(&node_n) { if settings.DockId == node_ids[node_n] {
	settings.DockId = 0
	settings.DockOrder = -1
	if pre_incr(&found) < node_ids_count { break }
	return
} } }
}

DockSettingsFindNodeSettings :: proc(ctx : ^ImGuiContext, id : ImGuiID) -> ^ImGuiDockNodeSettings
{
	// FIXME-OPT
	dc : ^ImGuiDockContext = &ctx.DockContext
	for n : i32 = 0; n < dc.NodesSettings.Size; post_incr(&n) { if dc.NodesSettings[n].ID == id { return &dc.NodesSettings[n] } }

	return nil
}

// Clear settings data
DockSettingsHandler_ClearAll :: proc(ctx : ^ImGuiContext, _ : ^ImGuiSettingsHandler)
{
	dc : ^ImGuiDockContext = &ctx.DockContext
	clear(&dc.NodesSettings)
	DockContextClearNodes(ctx, 0, true)
}

// Recreate nodes based on settings data
DockSettingsHandler_ApplyAll :: proc(ctx : ^ImGuiContext, _ : ^ImGuiSettingsHandler)
{
	// Prune settings at boot time only
	dc : ^ImGuiDockContext = &ctx.DockContext
	if ctx.Windows.Size == 0 { DockContextPruneUnusedSettingsNodes(ctx) }
	DockContextBuildNodesFromSettings(ctx, dc.NodesSettings.Data, dc.NodesSettings.Size)
	DockContextBuildAddWindowsToNodes(ctx, 0)
}

DockSettingsHandler_ReadOpen :: proc(_ : ^ImGuiContext, _ : ^ImGuiSettingsHandler, name : ^u8) -> rawptr
{
	if strcmp(name, "Data") != 0 { return nil }
	return cast(rawptr) 1
}

DockSettingsHandler_ReadLine :: proc(ctx : ^ImGuiContext, _ : ^ImGuiSettingsHandler, _ : rawptr, line : ^u8)
{
	c : u8 = 0
	x : i32 = 0; y : i32 = 0
	r : i32 = 0

	// Parsing, e.g.
	// " DockNode   ID=0x00000001 Pos=383,193 Size=201,322 Split=Y,0.506 "
	// "   DockNode ID=0x00000002 Parent=0x00000001 "
	// Important: this code expect currently fields in a fixed order.
	node : ImGuiDockNodeSettings
	line = ImStrSkipBlank(line)
	if strncmp(line, "DockNode", 8) == 0 { line = ImStrSkipBlank(line + strlen("DockNode")) }
	else if strncmp(line, "DockSpace", 9) == 0 {line = ImStrSkipBlank(line + strlen("DockSpace")); node.Flags |= ImGuiDockNodeFlagsPrivate_.ImGuiDockNodeFlags_DockSpace
	}
	else { return }
	if sscanf(line, "ID=0x%08X%n", &node.ID, &r) == 1 { line += r }
	else { return }
	if sscanf(line, " Parent=0x%08X%n", &node.ParentNodeId, &r) == 1 {line += r; if node.ParentNodeId == 0 { return }
	}
	if sscanf(line, " Window=0x%08X%n", &node.ParentWindowId, &r) == 1 {line += r; if node.ParentWindowId == 0 { return }
	}
	if node.ParentNodeId == 0 {
		if sscanf(line, " Pos=%i,%i%n", &x, &y, &r) == 2 {line += r; node.Pos = ImVec2ih(cast(i16) x, cast(i16) y)
		}
		else { return }
		if sscanf(line, " Size=%i,%i%n", &x, &y, &r) == 2 {line += r; node.Size = ImVec2ih(cast(i16) x, cast(i16) y)
		}
		else { return }
	}
	else {
		if sscanf(line, " SizeRef=%i,%i%n", &x, &y, &r) == 2 {line += r; node.SizeRef = ImVec2ih(cast(i16) x, cast(i16) y)
		}
	}
	if sscanf(line, " Split=%c%n", &c, &r) == 1 {line += r; if c == 'X' { node.SplitAxis = ImGuiAxis.ImGuiAxis_X }
		else if c == 'Y' { node.SplitAxis = ImGuiAxis.ImGuiAxis_Y }
	}
	if sscanf(line, " NoResize=%d%n", &x, &r) == 1 {line += r; if x != 0 { node.Flags |= ImGuiDockNodeFlags_.ImGuiDockNodeFlags_NoResize }
	}
	if sscanf(line, " CentralNode=%d%n", &x, &r) == 1 {line += r; if x != 0 { node.Flags |= ImGuiDockNodeFlagsPrivate_.ImGuiDockNodeFlags_CentralNode }
	}
	if sscanf(line, " NoTabBar=%d%n", &x, &r) == 1 {line += r; if x != 0 { node.Flags |= ImGuiDockNodeFlagsPrivate_.ImGuiDockNodeFlags_NoTabBar }
	}
	if sscanf(line, " HiddenTabBar=%d%n", &x, &r) == 1 {line += r; if x != 0 { node.Flags |= ImGuiDockNodeFlagsPrivate_.ImGuiDockNodeFlags_HiddenTabBar }
	}
	if sscanf(line, " NoWindowMenuButton=%d%n", &x, &r) == 1 {line += r; if x != 0 { node.Flags |= ImGuiDockNodeFlagsPrivate_.ImGuiDockNodeFlags_NoWindowMenuButton }
	}
	if sscanf(line, " NoCloseButton=%d%n", &x, &r) == 1 {line += r; if x != 0 { node.Flags |= ImGuiDockNodeFlagsPrivate_.ImGuiDockNodeFlags_NoCloseButton }
	}
	if sscanf(line, " Selected=0x%08X%n", &node.SelectedTabId, &r) == 1 { line += r }
	if node.ParentNodeId != 0 { if parent_settings : ^ImGuiDockNodeSettings = DockSettingsFindNodeSettings(ctx, node.ParentNodeId); parent_settings { node.Depth = parent_settings.Depth + 1 } }
	push_back(&ctx.DockContext.NodesSettings, node)
}

DockSettingsHandler_DockNodeToSettings :: proc(dc : ^ImGuiDockContext, node : ^ImGuiDockNode, depth : i32)
{
	node_settings : ImGuiDockNodeSettings
	IM_ASSERT(depth < (1 << (size_of(node_settings.Depth) << 3)))
	node_settings.ID = node.ID
	node_settings.ParentNodeId = node.ParentNode ? node.ParentNode.ID : 0
	node_settings.ParentWindowId = (IsDockSpace(node) && node.HostWindow && node.HostWindow.ParentWindow) ? node.HostWindow.ParentWindow.ID : 0
	node_settings.SelectedTabId = node.SelectedTabId
	node_settings.SplitAxis = cast(i8) (IsSplitNode(node) ? node.SplitAxis : ImGuiAxis.ImGuiAxis_None)
	node_settings.Depth = cast(u8) depth
	node_settings.Flags = (node.LocalFlags & ImGuiDockNodeFlagsPrivate_.ImGuiDockNodeFlags_SavedFlagsMask_)
	node_settings.Pos = ImVec2ih(node.Pos)
	node_settings.Size = ImVec2ih(node.Size)
	node_settings.SizeRef = ImVec2ih(node.SizeRef)
	push_back(&dc.NodesSettings, node_settings)
	if node.ChildNodes[0] { DockSettingsHandler_DockNodeToSettings(dc, node.ChildNodes[0], depth + 1) }
	if node.ChildNodes[1] { DockSettingsHandler_DockNodeToSettings(dc, node.ChildNodes[1], depth + 1) }
}

DockSettingsHandler_WriteAll :: proc(ctx : ^ImGuiContext, handler : ^ImGuiSettingsHandler, buf : ^ImGuiTextBuffer)
{
	g : ^ImGuiContext = ctx^
	dc : ^ImGuiDockContext = &ctx.DockContext
	if !(g.IO.ConfigFlags & ImGuiConfigFlags_.ImGuiConfigFlags_DockingEnable) { return }

	// Gather settings data
	// (unlike our windows settings, because nodes are always built we can do a full rewrite of the SettingsNode buffer)
	resize(&dc.NodesSettings, 0)
	reserve(&dc.NodesSettings, dc.Nodes.Data.Size)
	for n : i32 = 0; n < dc.Nodes.Data.Size; post_incr(&n) { if node : ^ImGuiDockNode = cast(^ImGuiDockNode) dc.Nodes.Data[n].val_p; node { if IsRootNode(node) { DockSettingsHandler_DockNodeToSettings(dc, node, 0) } } }

	max_depth : i32 = 0
	for node_n : i32 = 0; node_n < dc.NodesSettings.Size; post_incr(&node_n) { max_depth = ImMax(cast(i32) dc.NodesSettings[node_n].Depth, max_depth) }

	// Write to text buffer
	appendf(buf, "[%s][Data]\n", handler.TypeName)
	for node_n : i32 = 0; node_n < dc.NodesSettings.Size; post_incr(&node_n) {
		line_start_pos : i32 = size(buf); _ = line_start_pos
		node_settings : ^ImGuiDockNodeSettings = &dc.NodesSettings[node_n]
		appendf(buf, "%*s%s%*s", node_settings.Depth * 2, "", (node_settings.Flags & ImGuiDockNodeFlagsPrivate_.ImGuiDockNodeFlags_DockSpace) ? "DockSpace" : "DockNode ", (max_depth - node_settings.Depth) * 2, ""); // Text align nodes to facilitate looking at .ini file
		appendf(buf, " ID=0x%08X", node_settings.ID)
		if node_settings.ParentNodeId {
			appendf(buf, " Parent=0x%08X SizeRef=%d,%d", node_settings.ParentNodeId, node_settings.SizeRef.x, node_settings.SizeRef.y)
		}
		else {
			if node_settings.ParentWindowId { appendf(buf, " Window=0x%08X", node_settings.ParentWindowId) }
			appendf(buf, " Pos=%d,%d Size=%d,%d", node_settings.Pos.x, node_settings.Pos.y, node_settings.Size.x, node_settings.Size.y)
		}
		if node_settings.SplitAxis != ImGuiAxis.ImGuiAxis_None { appendf(buf, " Split=%c", (node_settings.SplitAxis == ImGuiAxis.ImGuiAxis_X) ? 'X' : 'Y') }
		if node_settings.Flags & ImGuiDockNodeFlags_.ImGuiDockNodeFlags_NoResize { appendf(buf, " NoResize=1") }
		if node_settings.Flags & ImGuiDockNodeFlagsPrivate_.ImGuiDockNodeFlags_CentralNode { appendf(buf, " CentralNode=1") }
		if node_settings.Flags & ImGuiDockNodeFlagsPrivate_.ImGuiDockNodeFlags_NoTabBar { appendf(buf, " NoTabBar=1") }
		if node_settings.Flags & ImGuiDockNodeFlagsPrivate_.ImGuiDockNodeFlags_HiddenTabBar { appendf(buf, " HiddenTabBar=1") }
		if node_settings.Flags & ImGuiDockNodeFlagsPrivate_.ImGuiDockNodeFlags_NoWindowMenuButton { appendf(buf, " NoWindowMenuButton=1") }
		if node_settings.Flags & ImGuiDockNodeFlagsPrivate_.ImGuiDockNodeFlags_NoCloseButton { appendf(buf, " NoCloseButton=1") }
		if node_settings.SelectedTabId { appendf(buf, " Selected=0x%08X", node_settings.SelectedTabId) }

		// [DEBUG] Include comments in the .ini file to ease debugging (this makes saving slower!)
		if g.IO.ConfigDebugIniSettings { if node : ^ImGuiDockNode = DockContextFindNodeByID(ctx, node_settings.ID); node {
	appendf(buf, "%*s", ImMax(2, (line_start_pos + 92) - size(buf)), ""); // Align everything
	if IsDockSpace(node) && node.HostWindow && node.HostWindow.ParentWindow { appendf(buf, " ; in '%s'", node.HostWindow.ParentWindow.Name) }
	// Iterate settings so we can give info about windows that didn't exist during the session.
	contains_window : i32 = 0
	for settings : ^ImGuiWindowSettings = begin(&g.SettingsWindows); settings != nil; settings = next_chunk(&g.SettingsWindows, settings) { if settings.DockId == node_settings.ID {
	if post_incr(&contains_window) == 0 { appendf(buf, " ; contains ") }
	appendf(buf, "'%s' ", GetName(settings))
} }
} }

		appendf(buf, "\n")
	}

	appendf(buf, "\n")
}


//-----------------------------------------------------------------------------
// [SECTION] PLATFORM DEPENDENT HELPERS
//-----------------------------------------------------------------------------
// - Default clipboard handlers
// - Default shell function handlers
// - Default IME handlers
//-----------------------------------------------------------------------------

when ODIN_OS == .Windows && ! IMGUI_DISABLE_WIN32_FUNCTIONS && ! IMGUI_DISABLE_WIN32_DEFAULT_CLIPBOARD_FUNCTIONS {

// Platform Dependents default implementation for ImGuiPlatformIO functions
// Win32 clipboard implementation
// We use g.ClipboardHandlerData for temporary storage to ensure it is freed on Shutdown()
Platform_GetClipboardTextFn_DefaultImpl :: proc(ctx : ^ImGuiContext) -> ^u8
{
	g : ^ImGuiContext = ctx^
	clear(&g.ClipboardHandlerData)
	if !OpenClipboard(nil) { return nil }
	wbuf_handle : HANDLE = GetClipboardData(CF_UNICODETEXT)
	if wbuf_handle == nil {
		CloseClipboard()
		return nil
	}
	if wbuf_global : ^WCHAR = cast(^WCHAR) GlobalLock(wbuf_handle); wbuf_global {
		buf_len : i32 = WideCharToMultiByte(CP_UTF8, 0, wbuf_global, -1, nil, 0, nil, nil)
		resize(&g.ClipboardHandlerData, buf_len)
		WideCharToMultiByte(CP_UTF8, 0, wbuf_global, -1, g.ClipboardHandlerData.Data, buf_len, nil, nil)
	}
	GlobalUnlock(wbuf_handle)
	CloseClipboard()
	return g.ClipboardHandlerData.Data
}

Platform_SetClipboardTextFn_DefaultImpl :: proc(_ : ^ImGuiContext, text : ^u8)
{
	if !OpenClipboard(nil) { return }
	wbuf_length : i32 = MultiByteToWideChar(CP_UTF8, 0, text, -1, nil, 0)
	wbuf_handle : HGLOBAL = GlobalAlloc(GMEM_MOVEABLE, cast(SIZE_T) wbuf_length * size_of(WCHAR))
	if wbuf_handle == nil {
		CloseClipboard()
		return
	}
	wbuf_global : ^WCHAR = cast(^WCHAR) GlobalLock(wbuf_handle)
	MultiByteToWideChar(CP_UTF8, 0, text, -1, wbuf_global, wbuf_length)
	GlobalUnlock(wbuf_handle)
	EmptyClipboard()
	if SetClipboardData(CF_UNICODETEXT, wbuf_handle) == nil { GlobalFree(wbuf_handle) }
	CloseClipboard()
}

} else when defined ( __APPLE__ ) && TARGET_OS_OSX && defined ( IMGUI_ENABLE_OSX_DEFAULT_CLIPBOARD_FUNCTIONS ) {

main_clipboard : PasteboardRef = 0

// OSX clipboard implementation
// If you enable this you will need to add '-framework ApplicationServices' to your linker command-line!
Platform_SetClipboardTextFn_DefaultImpl :: proc(_ : ^ImGuiContext, text : ^u8)
{
	if !main_clipboard { PasteboardCreate(kPasteboardClipboard, &main_clipboard) }
	PasteboardClear(main_clipboard)
	cf_data : CFDataRef = CFDataCreate(kCFAllocatorDefault, cast(^UInt8) text, strlen(text))
	if cf_data {
		PasteboardPutItemFlavor(main_clipboard, cast(PasteboardItemID) 1, CFSTR("public.utf8-plain-text"), cf_data, 0)
		CFRelease(cf_data)
	}
}

// Platform Dependents default implementation for ImGuiPlatformIO functions
// Win32 clipboard implementation
// We use g.ClipboardHandlerData for temporary storage to ensure it is freed on Shutdown()
Platform_GetClipboardTextFn_DefaultImpl :: proc(ctx : ^ImGuiContext) -> ^u8
{
	g : ^ImGuiContext = ctx^
	if !main_clipboard { PasteboardCreate(kPasteboardClipboard, &main_clipboard) }
	PasteboardSynchronize(main_clipboard)

	item_count : ItemCount = 0
	PasteboardGetItemCount(main_clipboard, &item_count)
	for i : ItemCount = 0; i < item_count; post_incr(&i) {
		item_id : PasteboardItemID = 0
		PasteboardGetItemIdentifier(main_clipboard, i + 1, &item_id)
		flavor_type_array : CFArrayRef = 0
		PasteboardCopyItemFlavors(main_clipboard, item_id, &flavor_type_array)
		for j, nj : CFIndex = 0, CFArrayGetCount(flavor_type_array); j < nj; post_incr(&j) {
			cf_data : CFDataRef
			if PasteboardCopyItemFlavorData(main_clipboard, item_id, CFSTR("public.utf8-plain-text"), &cf_data) == noErr {
				clear(&g.ClipboardHandlerData)
				length : i32 = cast(i32) CFDataGetLength(cf_data)
				resize(&g.ClipboardHandlerData, length + 1)
				CFDataGetBytes(cf_data, CFRangeMake(0, length), cast(^UInt8) g.ClipboardHandlerData.Data)
				g.ClipboardHandlerData[length] = 0
				CFRelease(cf_data)
				return g.ClipboardHandlerData.Data
			}
		}
	}

	return nil
}

} else { // preproc else

// Platform Dependents default implementation for ImGuiPlatformIO functions
// Win32 clipboard implementation
// We use g.ClipboardHandlerData for temporary storage to ensure it is freed on Shutdown()
// Local Dear ImGui-only clipboard implementation, if user hasn't defined better clipboard handlers.
Platform_GetClipboardTextFn_DefaultImpl :: proc(ctx : ^ImGuiContext) -> ^u8
{
	g : ^ImGuiContext = ctx^
	return empty(&g.ClipboardHandlerData) ? nil : begin(&g.ClipboardHandlerData)
}

// OSX clipboard implementation
// If you enable this you will need to add '-framework ApplicationServices' to your linker command-line!
Platform_SetClipboardTextFn_DefaultImpl :: proc(ctx : ^ImGuiContext, text : ^u8)
{
	g : ^ImGuiContext = ctx^
	clear(&g.ClipboardHandlerData)
	text_end : ^u8 = text + strlen(text)
	resize(&g.ClipboardHandlerData, cast(i32) (text_end - text) + 1)
	memcpy(&g.ClipboardHandlerData[0], text, cast(uint) (text_end - text))
	g.ClipboardHandlerData[cast(i32) (text_end - text)] = 0
}

} // preproc endif// Default clipboard handlers

//-----------------------------------------------------------------------------

when ! IMGUI_DISABLE_DEFAULT_SHELL_FUNCTIONS { // @gen ifndef
when ODIN_OS == .Windows { // @gen ifdef
Platform_OpenInShellFn_DefaultImpl :: proc(_ : ^ImGuiContext, path : ^u8) -> bool
{
	return cast(INT_PTR) ShellExecuteA(nil, "open", path, nil, nil, SW_SHOWDEFAULT) > 32
}
} else { // preproc else
Platform_OpenInShellFn_DefaultImpl :: proc(_ : ^ImGuiContext, path : ^u8) -> bool
{
	when defined ( __APPLE__ ) {
	args : [^]^u8 = {"open", "--", path, nil}
	} else { // preproc else
	args : [^]^u8 = {"xdg-open", path, nil}
	} // preproc endif
	pid : pid_t = fork()
	if pid < 0 { return false }
	if !pid {
		execvp(args[0], transmute(^^u8) args)
		exit(-1)
	}
	else {
		status : i32
		waitpid(pid, &status, 0)
		return WEXITSTATUS(status) == 0
	}
}
} // preproc endif
} else { // preproc else
Platform_OpenInShellFn_DefaultImpl :: proc(_ : ^ImGuiContext, _ : ^u8) -> bool { return false }
} // preproc endif// Default shell handlers

//-----------------------------------------------------------------------------

// Win32 API IME support (for Asian languages, etc.)
when ODIN_OS == .Windows && ! IMGUI_DISABLE_WIN32_FUNCTIONS && !IMGUI_DISABLE_WIN32_DEFAULT_IME_FUNCTIONS {

Platform_SetImeDataFn_DefaultImpl :: proc(_ : ^ImGuiContext, viewport : ^ImGuiViewport, data : ^ImGuiPlatformImeData)
{
	// Notify OS Input Method Editor of text input position
	hwnd : HWND = cast(HWND) viewport.PlatformHandleRaw
	if hwnd == 0 { return }

	//::ImmAssociateContextEx(hwnd, NULL, data->WantVisible ? IACE_DEFAULT : 0);
	if himc : HIMC = ImmGetContext(hwnd); himc {
		composition_form : COMPOSITIONFORM = {}
		composition_form.ptCurrentPos.x = cast(LONG) (data.InputPos.x - viewport.Pos.x)
		composition_form.ptCurrentPos.y = cast(LONG) (data.InputPos.y - viewport.Pos.y)
		composition_form.dwStyle = CFS_FORCE_POSITION
		ImmSetCompositionWindow(himc, &composition_form)
		candidate_form : CANDIDATEFORM = {}
		candidate_form.dwStyle = CFS_CANDIDATEPOS
		candidate_form.ptCurrentPos.x = cast(LONG) (data.InputPos.x - viewport.Pos.x)
		candidate_form.ptCurrentPos.y = cast(LONG) (data.InputPos.y - viewport.Pos.y)
		ImmSetCandidateWindow(himc, &candidate_form)
		ImmReleaseContext(hwnd, himc)
	}
}

} else { // preproc else

Platform_SetImeDataFn_DefaultImpl :: proc(_ : ^ImGuiContext, _ : ^ImGuiViewport, _ : ^ImGuiPlatformImeData) { }

} // preproc endif// Default IME handlers

//-----------------------------------------------------------------------------
// [SECTION] METRICS/DEBUGGER WINDOW
//-----------------------------------------------------------------------------
// - DebugRenderViewportThumbnail() [Internal]
// - RenderViewportsThumbnails() [Internal]
// - DebugTextEncoding()
// - MetricsHelpMarker() [Internal]
// - ShowFontAtlas() [Internal]
// - ShowMetricsWindow()
// - DebugNodeColumns() [Internal]
// - DebugNodeDockNode() [Internal]
// - DebugNodeDrawList() [Internal]
// - DebugNodeDrawCmdShowMeshAndBoundingBox() [Internal]
// - DebugNodeFont() [Internal]
// - DebugNodeFontGlyph() [Internal]
// - DebugNodeStorage() [Internal]
// - DebugNodeTabBar() [Internal]
// - DebugNodeViewport() [Internal]
// - DebugNodeWindow() [Internal]
// - DebugNodeWindowSettings() [Internal]
// - DebugNodeWindowsList() [Internal]
// - DebugNodeWindowsListByBeginStackParent() [Internal]
//-----------------------------------------------------------------------------

when ! IMGUI_DISABLE_DEBUG_TOOLS { // @gen ifndef

DebugRenderViewportThumbnail :: proc(draw_list : ^ImDrawList, viewport : ^ImGuiViewportP, bb : ^ImRect)
{
	g : ^ImGuiContext = GImGui^
	window : ^ImGuiWindow = g.CurrentWindow

	scale : ImVec2 = GetSize(&bb) / viewport.Size
	off : ImVec2 = bb.Min - viewport.Pos * scale
	alpha_mul : f32 = (viewport.Flags & ImGuiViewportFlags_.ImGuiViewportFlags_IsMinimized) ? 0.30 : 1.00
	AddRectFilled(window.DrawList, bb.Min, bb.Max, GetColorU32(ImGuiCol_.ImGuiCol_Border, alpha_mul * 0.40))
	for thumb_window in g.Windows {
		if !thumb_window.WasActive || (thumb_window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_ChildWindow) { continue }
		if thumb_window.Viewport != viewport { continue }

		thumb_r : ImRect = Rect(thumb_window)
		title_r : ImRect = TitleBarRect(thumb_window)
		thumb_r = ImRect(ImTrunc(off + thumb_r.Min * scale), ImTrunc(off + thumb_r.Max * scale))
		title_r = ImRect(ImTrunc(off + title_r.Min * scale), ImTrunc(off + ImVec2(title_r.Max.x, title_r.Min.y + GetHeight(&title_r) * 3.0) * scale)); // Exaggerate title bar height
		ClipWithFull(&thumb_r, bb)
		ClipWithFull(&title_r, bb)
		window_is_focused : bool = (g.NavWindow && thumb_window.RootWindowForTitleBarHighlight == g.NavWindow.RootWindowForTitleBarHighlight)
		AddRectFilled(window.DrawList, thumb_r.Min, thumb_r.Max, GetColorU32(ImGuiCol_.ImGuiCol_WindowBg, alpha_mul))
		AddRectFilled(window.DrawList, title_r.Min, title_r.Max, GetColorU32(window_is_focused ? ImGuiCol_.ImGuiCol_TitleBgActive : ImGuiCol_.ImGuiCol_TitleBg, alpha_mul))
		AddRect(window.DrawList, thumb_r.Min, thumb_r.Max, GetColorU32(ImGuiCol_.ImGuiCol_Border, alpha_mul))
		AddText(window.DrawList, g.Font, g.FontSize * 1.0, title_r.Min, GetColorU32(ImGuiCol_.ImGuiCol_Text, alpha_mul), thumb_window.Name, FindRenderedTextEnd(thumb_window.Name))
	}

	AddRect(draw_list, bb.Min, bb.Max, GetColorU32(ImGuiCol_.ImGuiCol_Border, alpha_mul))
	if viewport.ID == g.DebugMetricsConfig.HighlightViewportID { AddRect(window.DrawList, bb.Min, bb.Max, IM_COL32(255, 255, 0, 255)) }
}

RenderViewportsThumbnails :: proc()
{
	g : ^ImGuiContext = GImGui^
	window : ^ImGuiWindow = g.CurrentWindow

	// Draw monitor and calculate their boundaries
	SCALE : f32 = 1.0 / 8.0
	bb_full : ImRect; init(&bb_full, FLT_MAX, FLT_MAX, -FLT_MAX, -FLT_MAX)
	for monitor in g.PlatformIO.Monitors { Add(&bb_full, ImRect(monitor.MainPos, monitor.MainPos + monitor.MainSize)) }

	p : ImVec2 = window.DC.CursorPos
	off : ImVec2 = p - bb_full.Min * SCALE
	for monitor in g.PlatformIO.Monitors {
		monitor_draw_bb : ImRect; init(&monitor_draw_bb, off + (monitor.MainPos) * SCALE, off + (monitor.MainPos + monitor.MainSize) * SCALE)
		AddRect(window.DrawList, monitor_draw_bb.Min, monitor_draw_bb.Max, (g.DebugMetricsConfig.HighlightMonitorIdx == index_from_ptr(&g.PlatformIO.Monitors, &monitor)) ? IM_COL32(255, 255, 0, 255) : GetColorU32(ImGuiCol_.ImGuiCol_Border), 4.0)
		AddRectFilled(window.DrawList, monitor_draw_bb.Min, monitor_draw_bb.Max, GetColorU32(ImGuiCol_.ImGuiCol_Border, 0.10), 4.0)
	}

	// Draw viewports
	for viewport in g.Viewports {
		viewport_draw_bb : ImRect; init(&viewport_draw_bb, off + (viewport.Pos) * SCALE, off + (viewport.Pos + viewport.Size) * SCALE)
		DebugRenderViewportThumbnail(window.DrawList, viewport, viewport_draw_bb)
	}

	Dummy(GetSize(&bb_full) * SCALE)
}

ViewportComparerByLastFocusedStampCount :: proc(lhs : rawptr, rhs : rawptr) -> i32
{
	a : ^ImGuiViewportP = cast(^^ImGuiViewportP) lhs^
	b : ^ImGuiViewportP = cast(^^ImGuiViewportP) rhs^
	return b.LastFocusedStampCount - a.LastFocusedStampCount
}

// Draw an arbitrary US keyboard layout to visualize translated keys
DebugRenderKeyboardPreview :: proc(draw_list : ^ImDrawList)
{
	scale : f32 = GetFontSize() / 13.0
	key_size : ImVec2 = ImVec2(35.0, 35.0) * scale
	key_rounding : f32 = 3.0 * scale
	key_face_size : ImVec2 = ImVec2(25.0, 25.0) * scale
	key_face_pos : ImVec2 = ImVec2(5.0, 3.0) * scale
	key_face_rounding : f32 = 2.0 * scale
	key_label_pos : ImVec2 = ImVec2(7.0, 4.0) * scale
	key_step : ImVec2 = ImVec2(key_size.x - 1.0, key_size.y - 1.0)
	key_row_offset : f32 = 9.0 * scale

	board_min : ImVec2 = GetCursorScreenPos()
	board_max : ImVec2 = ImVec2(board_min.x + 3 * key_step.x + 2 * key_row_offset + 10.0, board_min.y + 3 * key_step.y + 10.0)
	start_pos : ImVec2 = ImVec2(board_min.x + 5.0 - key_step.x, board_min.y)

	KeyLayoutData :: struct { Row : i32, Col : i32, Label : ^u8, Key : ImGuiKey, }
	keys_to_display : [^]KeyLayoutData = {
		{0, 0, "", ImGuiKey.ImGuiKey_Tab}, {0, 1, "Q", ImGuiKey.ImGuiKey_Q}, {0, 2, "W", ImGuiKey.ImGuiKey_W}, {0, 3, "E", ImGuiKey.ImGuiKey_E}, {0, 4, "R", ImGuiKey.ImGuiKey_R},
		{1, 0, "", ImGuiKey.ImGuiKey_CapsLock}, {1, 1, "A", ImGuiKey.ImGuiKey_A}, {1, 2, "S", ImGuiKey.ImGuiKey_S}, {1, 3, "D", ImGuiKey.ImGuiKey_D}, {1, 4, "F", ImGuiKey.ImGuiKey_F},
		{2, 0, "", ImGuiKey.ImGuiKey_LeftShift}, {2, 1, "Z", ImGuiKey.ImGuiKey_Z}, {2, 2, "X", ImGuiKey.ImGuiKey_X}, {2, 3, "C", ImGuiKey.ImGuiKey_C}, {2, 4, "V", ImGuiKey.ImGuiKey_V},
	}

	// Elements rendered manually via ImDrawList API are not clipped automatically.
	// While not strictly necessary, here IsItemVisible() is used to avoid rendering these shapes when they are out of view.
	Dummy(board_max - board_min)
	if !IsItemVisible() { return }
	PushClipRect(draw_list, board_min, board_max, true)
	for n : i32 = 0; n < IM_ARRAYSIZE(keys_to_display); post_incr(&n) {
		key_data : ^KeyLayoutData = &keys_to_display[n]
		key_min : ImVec2 = ImVec2(start_pos.x + key_data.Col * key_step.x + key_data.Row * key_row_offset, start_pos.y + key_data.Row * key_step.y)
		key_max : ImVec2 = key_min + key_size
		AddRectFilled(draw_list, key_min, key_max, IM_COL32(204, 204, 204, 255), key_rounding)
		AddRect(draw_list, key_min, key_max, IM_COL32(24, 24, 24, 255), key_rounding)
		face_min : ImVec2 = ImVec2(key_min.x + key_face_pos.x, key_min.y + key_face_pos.y)
		face_max : ImVec2 = ImVec2(face_min.x + key_face_size.x, face_min.y + key_face_size.y)
		AddRect(draw_list, face_min, face_max, IM_COL32(193, 193, 193, 255), key_face_rounding, ImDrawFlags_.ImDrawFlags_None, 2.0)
		AddRectFilled(draw_list, face_min, face_max, IM_COL32(252, 252, 252, 255), key_face_rounding)
		label_min : ImVec2 = ImVec2(key_min.x + key_label_pos.x, key_min.y + key_label_pos.y)
		AddText(draw_list, label_min, IM_COL32(64, 64, 64, 255), key_data.Label)
		if IsKeyDown(key_data.Key) { AddRectFilled(draw_list, key_min, key_max, IM_COL32(255, 0, 0, 128), key_rounding) }
	}

	PopClipRect(draw_list)
}

// Debug Utilities
// - Your main debugging friend is the ShowMetricsWindow() function, which is also accessible from Demo->Tools->Metrics Debugger
// Helper tool to diagnose between text encoding issues and font loading issues. Pass your UTF-8 string and verify that there are correct.
DebugTextEncoding :: proc(str : ^u8)
{
	Text("Text: \"%s\"", str)
	if !BeginTable("##DebugTextEncoding", 4, ImGuiTableFlags_.ImGuiTableFlags_Borders | ImGuiTableFlags_.ImGuiTableFlags_RowBg | ImGuiTableFlags_.ImGuiTableFlags_SizingFixedFit | ImGuiTableFlags_.ImGuiTableFlags_Resizable) { return }
	TableSetupColumn("Offset")
	TableSetupColumn("UTF-8")
	TableSetupColumn("Glyph")
	TableSetupColumn("Codepoint")
	TableHeadersRow()
	for p : ^u8 = str; p^ != 0;  {
		c : u32
		c_utf8_len : i32 = ImTextCharFromUtf8(&c, p, nil)
		TableNextColumn()
		Text("%d", cast(i32) (p - str))
		TableNextColumn()
		for byte_index : i32 = 0; byte_index < c_utf8_len; post_incr(&byte_index) {
			if byte_index > 0 { SameLine() }
			Text("0x%02X", cast(i32) cast(u8) p[byte_index])
		}

		TableNextColumn()
		if FindGlyphNoFallback(GetFont(), cast(ImWchar) c) { TextUnformatted(p, p + c_utf8_len) }
		else { TextUnformatted((c == IM_UNICODE_CODEPOINT_INVALID) ? "[invalid]" : "[missing]") }
		TableNextColumn()
		Text("U+%04X", cast(i32) c)
		p += c_utf8_len
	}

	EndTable()
}

DebugFlashStyleColorStop :: proc()
{
	g : ^ImGuiContext = GImGui^
	if g.DebugFlashStyleColorIdx != ImGuiCol_.ImGuiCol_COUNT { g.Style.Colors[g.DebugFlashStyleColorIdx] = g.DebugFlashStyleColorBackup }
	g.DebugFlashStyleColorIdx = ImGuiCol_.ImGuiCol_COUNT
}

// Flash a given style color for some + inhibit modifications of this color via PushStyleColor() calls.
DebugFlashStyleColor :: proc(idx : ImGuiCol)
{
	g : ^ImGuiContext = GImGui^
	DebugFlashStyleColorStop()
	g.DebugFlashStyleColorTime = 0.5
	g.DebugFlashStyleColorIdx = idx
	g.DebugFlashStyleColorBackup = g.Style.Colors[idx]
}

UpdateDebugToolFlashStyleColor :: proc()
{
	g : ^ImGuiContext = GImGui^
	if g.DebugFlashStyleColorTime <= 0.0 { return }
	ColorConvertHSVtoRGB(ImCos(g.DebugFlashStyleColorTime * 6.0) * 0.5 + 0.5, 0.5, 0.5, g.Style.Colors[g.DebugFlashStyleColorIdx].x, g.Style.Colors[g.DebugFlashStyleColorIdx].y, g.Style.Colors[g.DebugFlashStyleColorIdx].z)
	g.Style.Colors[g.DebugFlashStyleColorIdx].w = 1.0
	g.DebugFlashStyleColorTime -= g.IO.DeltaTime
	if g.DebugFlashStyleColorTime <= 0.0 { DebugFlashStyleColorStop() }
}

FormatTextureIDForDebugDisplay :: proc(buf : ^u8, buf_size : i32, tex_id : ImTextureID) -> ^u8
{
	tex_id_opaque : struct #raw_union { ptr : rawptr, integer : i32, }
	memcpy(&tex_id_opaque, &tex_id, ImMin(size_of(rawptr), size_of(tex_id)))
	if size_of(tex_id) >= size_of(rawptr) { ImFormatString(buf, buf_size, "0x%p", tex_id_opaque.ptr) }
	else { ImFormatString(buf, buf_size, "0x%04X", tex_id_opaque.integer) }
	return buf
}

// Avoid naming collision with imgui_demo.cpp's HelpMarker() for unity builds.
MetricsHelpMarker :: proc(desc : ^u8)
{
	TextDisabled("(?)")
	if BeginItemTooltip() {
		PushTextWrapPos(GetFontSize() * 35.0)
		TextUnformatted(desc)
		PopTextWrapPos()
		EndTooltip()
	}
}

// [DEBUG] List fonts in a font atlas and display its texture
ShowFontAtlas :: proc(atlas : ^ImFontAtlas)
{
	for font in atlas.Fonts {
		PushID(font)
		DebugNodeFont(font)
		PopID()
	}

	if TreeNode("Font Atlas", "Font Atlas (%dx%d pixels)", atlas.TexWidth, atlas.TexHeight) {
		g : ^ImGuiContext = GImGui^
		cfg : ^ImGuiMetricsConfig = &g.DebugMetricsConfig
		Checkbox("Tint with Text Color", &cfg.ShowAtlasTintedWithTextColor); // Using text color ensure visibility of core atlas data, but will alter custom colored icons
		tint_col : ImVec4 = cfg.ShowAtlasTintedWithTextColor ? GetStyleColorVec4(ImGuiCol_.ImGuiCol_Text) : ImVec4(1.0, 1.0, 1.0, 1.0)
		border_col : ImVec4 = GetStyleColorVec4(ImGuiCol_.ImGuiCol_Border)
		Image(atlas.TexID, ImVec2(cast(f32) atlas.TexWidth, cast(f32) atlas.TexHeight), ImVec2(0.0, 0.0), ImVec2(1.0, 1.0), tint_col, border_col)
		TreePop()
	}
}

// create Metrics/Debugger window. display Dear ImGui internals: windows, draw commands, various internal state, etc.
ShowMetricsWindow :: proc(p_open : ^bool)
{
	g : ^ImGuiContext = GImGui^
	io : ^ImGuiIO = g.IO
	cfg : ^ImGuiMetricsConfig = &g.DebugMetricsConfig
	if cfg.ShowDebugLog { ShowDebugLogWindow(&cfg.ShowDebugLog) }
	if cfg.ShowIDStackTool { ShowIDStackToolWindow(&cfg.ShowIDStackTool) }

	if !Begin("Dear ImGui Metrics/Debugger", p_open) || GetCurrentWindow().BeginCount > 1 {
		End()
		return
	}

	// [DEBUG] Clear debug breaks hooks after exactly one cycle.
	DebugBreakClearData()

	// Basic info
	Text("Dear ImGui %s (%d)", IMGUI_VERSION, IMGUI_VERSION_NUM)
	if g.ContextName[0] != 0 {
		SameLine()
		Text("(Context Name: \"%s\")", g.ContextName)
	}
	Text("Application average %.3f ms/frame (%.1f FPS)", 1000.0 / io.Framerate, io.Framerate)
	Text("%d vertices, %d indices (%d triangles)", io.MetricsRenderVertices, io.MetricsRenderIndices, io.MetricsRenderIndices / 3)
	Text("%d visible windows, %d current allocations", io.MetricsRenderWindows, g.DebugAllocInfo.TotalAllocCount - g.DebugAllocInfo.TotalFreeCount)
	//SameLine(); if (SmallButton("GC")) { g.GcCompactAll = true; }

	Separator()

	// Debugging enums
E1 :: enum i32 { WRT_OuterRect, WRT_OuterRectClipped, WRT_InnerRect, WRT_InnerClipRect, WRT_WorkRect, WRT_Content, WRT_ContentIdeal, WRT_ContentRegionRect, WRT_Count, }// Windows Rect Type
	wrt_rects_names : [E1.WRT_Count]^u8 = {"OuterRect", "OuterRectClipped", "InnerRect", "InnerClipRect", "WorkRect", "Content", "ContentIdeal", "ContentRegionRect"}
	E2 :: enum i32 { TRT_OuterRect, TRT_InnerRect, TRT_WorkRect, TRT_HostClipRect, TRT_InnerClipRect, TRT_BackgroundClipRect, TRT_ColumnsRect, TRT_ColumnsWorkRect, TRT_ColumnsClipRect, TRT_ColumnsContentHeadersUsed, TRT_ColumnsContentHeadersIdeal, TRT_ColumnsContentFrozen, TRT_ColumnsContentUnfrozen, TRT_Count, }// Tables Rect Type
	trt_rects_names : [E2.TRT_Count]^u8 = {"OuterRect", "InnerRect", "WorkRect", "HostClipRect", "InnerClipRect", "BackgroundClipRect", "ColumnsRect", "ColumnsWorkRect", "ColumnsClipRect", "ColumnsContentHeadersUsed", "ColumnsContentHeadersIdeal", "ColumnsContentFrozen", "ColumnsContentUnfrozen"}
	if cfg.ShowWindowsRectsType < 0 { cfg.ShowWindowsRectsType = E1.WRT_WorkRect }
	if cfg.ShowTablesRectsType < 0 { cfg.ShowTablesRectsType = E2.TRT_WorkRect }

	Funcs :: struct {
	}

	Funcs_GetTableRect :: proc(this : ^Funcs, table : ^ImGuiTable, rect_type : i32, n : i32) -> ImRect
	{
		table_instance : ^ImGuiTableInstanceData = TableGetInstanceData(table, table.InstanceCurrent); // Always using last submitted instance
		if rect_type == E2.TRT_OuterRect { return table.OuterRect }
		else if rect_type == E2.TRT_InnerRect { return table.InnerRect }
		else if rect_type == E2.TRT_WorkRect { return table.WorkRect }
		else if rect_type == E2.TRT_HostClipRect { return table.HostClipRect }
		else if rect_type == E2.TRT_InnerClipRect { return table.InnerClipRect }
		else if rect_type == E2.TRT_BackgroundClipRect { return table.BgClipRect }
		else if rect_type == E2.TRT_ColumnsRect {c : ^ImGuiTableColumn = &table.Columns[n]; return ImRect(c.MinX, table.InnerClipRect.Min.y, c.MaxX, table.InnerClipRect.Min.y + table_instance.LastOuterHeight)
		}
		else if rect_type == E2.TRT_ColumnsWorkRect {c : ^ImGuiTableColumn = &table.Columns[n]; return ImRect(c.WorkMinX, table.WorkRect.Min.y, c.WorkMaxX, table.WorkRect.Max.y)
		}
		else if rect_type == E2.TRT_ColumnsClipRect {c : ^ImGuiTableColumn = &table.Columns[n]; return c.ClipRect
		}
		else if rect_type == E2.TRT_ColumnsContentHeadersUsed {
			// Note: y1/y2 not always accurate
			c : ^ImGuiTableColumn = &table.Columns[n]; return ImRect(c.WorkMinX, table.InnerClipRect.Min.y, c.ContentMaxXHeadersUsed, table.InnerClipRect.Min.y + table_instance.LastTopHeadersRowHeight)
		}
		else if rect_type == E2.TRT_ColumnsContentHeadersIdeal {c : ^ImGuiTableColumn = &table.Columns[n]; return ImRect(c.WorkMinX, table.InnerClipRect.Min.y, c.ContentMaxXHeadersIdeal, table.InnerClipRect.Min.y + table_instance.LastTopHeadersRowHeight)
		}
		else if rect_type == E2.TRT_ColumnsContentFrozen {c : ^ImGuiTableColumn = &table.Columns[n]; return ImRect(c.WorkMinX, table.InnerClipRect.Min.y, c.ContentMaxXFrozen, table.InnerClipRect.Min.y + table_instance.LastFrozenHeight)
		}
		else if rect_type == E2.TRT_ColumnsContentUnfrozen {c : ^ImGuiTableColumn = &table.Columns[n]; return ImRect(c.WorkMinX, table.InnerClipRect.Min.y + table_instance.LastFrozenHeight, c.ContentMaxXUnfrozen, table.InnerClipRect.Max.y)
		}
		IM_ASSERT(0)
		return ImRect()
	}

	Funcs_GetWindowRect :: proc(this : ^Funcs, window : ^ImGuiWindow, rect_type : i32) -> ImRect
	{
		if rect_type == E1.WRT_OuterRect { return Rect(window) }
		else if rect_type == E1.WRT_OuterRectClipped { return window.OuterRectClipped }
		else if rect_type == E1.WRT_InnerRect { return window.InnerRect }
		else if rect_type == E1.WRT_InnerClipRect { return window.InnerClipRect }
		else if rect_type == E1.WRT_WorkRect { return window.WorkRect }
		else if rect_type == E1.WRT_Content {min : ImVec2 = window.InnerRect.Min - window.Scroll + window.WindowPadding; return ImRect(min, min + window.ContentSize)
		}
		else if rect_type == E1.WRT_ContentIdeal {min : ImVec2 = window.InnerRect.Min - window.Scroll + window.WindowPadding; return ImRect(min, min + window.ContentSizeIdeal)
		}
		else if rect_type == E1.WRT_ContentRegionRect { return window.ContentRegionRect }
		IM_ASSERT(0)
		return ImRect()
	}

	// Tools
	if TreeNode("Tools") {
		// Debug Break features
		// The Item Picker tool is super useful to visually select an item and break into the call-stack of where it was submitted.
		SeparatorTextEx(0, "Debug breaks", nil, CalcTextSize("(?)").x + g.Style.SeparatorTextPadding.x)
		SameLine()
		MetricsHelpMarker("Will call the IM_DEBUG_BREAK() macro to break in debugger.\nWarning: If you don't have a debugger attached, this will probably crash.")
		if Checkbox("Show Item Picker", &g.DebugItemPickerActive) && g.DebugItemPickerActive { DebugStartItemPicker() }
		Checkbox("Show \"Debug Break\" buttons in other sections (io.ConfigDebugIsDebuggerPresent)", &g.IO.ConfigDebugIsDebuggerPresent)

		SeparatorText("Visualize")

		Checkbox("Show Debug Log", &cfg.ShowDebugLog)
		SameLine()
		MetricsHelpMarker("You can also call ImGui::ShowDebugLogWindow() from your code.")

		Checkbox("Show ID Stack Tool", &cfg.ShowIDStackTool)
		SameLine()
		MetricsHelpMarker("You can also call ImGui::ShowIDStackToolWindow() from your code.")

		Checkbox("Show windows begin order", &cfg.ShowWindowsBeginOrder)
		Checkbox("Show windows rectangles", &cfg.ShowWindowsRects)
		SameLine()
		SetNextItemWidth(GetFontSize() * 12)
		cfg.ShowWindowsRects |= Combo("##show_windows_rect_type", &cfg.ShowWindowsRectsType, wrt_rects_names, E1.WRT_Count, E1.WRT_Count)
		if cfg.ShowWindowsRects && g.NavWindow != nil {
			BulletText("'%s':", g.NavWindow.Name)
			Indent()
			for rect_n : i32 = 0; rect_n < E1.WRT_Count; post_incr(&rect_n) {
				r : ImRect = GetWindowRect(g.NavWindow, rect_n)
				Text("(%6.1f,%6.1f) (%6.1f,%6.1f) Size (%6.1f,%6.1f) %s", r.Min.x, r.Min.y, r.Max.x, r.Max.y, GetWidth(&r), GetHeight(&r), wrt_rects_names[rect_n])
			}

			Unindent()
		}

		Checkbox("Show tables rectangles", &cfg.ShowTablesRects)
		SameLine()
		SetNextItemWidth(GetFontSize() * 12)
		cfg.ShowTablesRects |= Combo("##show_table_rects_type", &cfg.ShowTablesRectsType, trt_rects_names, E2.TRT_Count, E2.TRT_Count)
		if cfg.ShowTablesRects && g.NavWindow != nil {
			for table_n : i32 = 0; table_n < GetMapSize(&g.Tables); post_incr(&table_n) {
				table : ^ImGuiTable = TryGetMapData(&g.Tables, table_n)
				if table == nil || table.LastFrameActive < g.FrameCount - 1 || (table.OuterWindow != g.NavWindow && table.InnerWindow != g.NavWindow) { continue }

				BulletText("Table 0x%08X (%d columns, in '%s')", table.ID, table.ColumnsCount, table.OuterWindow.Name)
				if IsItemHovered() { AddRect(GetForegroundDrawList(), table.OuterRect.Min - ImVec2(1, 1), table.OuterRect.Max + ImVec2(1, 1), IM_COL32(255, 255, 0, 255), 0.0, 0, 2.0) }
				Indent()
				buf : [128]u8
				for rect_n : i32 = 0; rect_n < E2.TRT_Count; post_incr(&rect_n) {
					if rect_n >= E2.TRT_ColumnsRect {
						if rect_n != E2.TRT_ColumnsRect && rect_n != E2.TRT_ColumnsClipRect { continue }
						for column_n : i32 = 0; column_n < table.ColumnsCount; post_incr(&column_n) {
							r : ImRect = GetTableRect(table, rect_n, column_n)
							ImFormatString(buf, IM_ARRAYSIZE(buf), "(%6.1f,%6.1f) (%6.1f,%6.1f) Size (%6.1f,%6.1f) Col %d %s", r.Min.x, r.Min.y, r.Max.x, r.Max.y, GetWidth(&r), GetHeight(&r), column_n, trt_rects_names[rect_n])
							Selectable(buf)
							if IsItemHovered() { AddRect(GetForegroundDrawList(), r.Min - ImVec2(1, 1), r.Max + ImVec2(1, 1), IM_COL32(255, 255, 0, 255), 0.0, 0, 2.0) }
						}
					}
					else {
						r : ImRect = GetTableRect(table, rect_n, -1)
						ImFormatString(buf, IM_ARRAYSIZE(buf), "(%6.1f,%6.1f) (%6.1f,%6.1f) Size (%6.1f,%6.1f) %s", r.Min.x, r.Min.y, r.Max.x, r.Max.y, GetWidth(&r), GetHeight(&r), trt_rects_names[rect_n])
						Selectable(buf)
						if IsItemHovered() { AddRect(GetForegroundDrawList(), r.Min - ImVec2(1, 1), r.Max + ImVec2(1, 1), IM_COL32(255, 255, 0, 255), 0.0, 0, 2.0) }
					}
				}

				Unindent()
			}
		}
		Checkbox("Show groups rectangles", &g.DebugShowGroupRects); // Storing in context as this is used by group code and prefers to be in hot-data

		SeparatorText("Validate")

		Checkbox("Debug Begin/BeginChild return value", &io.ConfigDebugBeginReturnValueLoop)
		SameLine()
		MetricsHelpMarker("Some calls to Begin()/BeginChild() will return false.\n\nWill cycle through window depths then repeat. Windows should be flickering while running.")

		Checkbox("UTF-8 Encoding viewer", &cfg.ShowTextEncodingViewer)
		SameLine()
		MetricsHelpMarker("You can also call ImGui::DebugTextEncoding() from your code with a given string to test that your UTF-8 encoding settings are correct.")
		if cfg.ShowTextEncodingViewer {
			buf : [64]u8 = ""
			SetNextItemWidth(-FLT_MIN)
			InputText("##DebugTextEncodingBuf", buf, IM_ARRAYSIZE(buf))
			if buf[0] != 0 { DebugTextEncoding(buf) }
		}

		TreePop()
	}

	// Windows
	if TreeNode("Windows", "Windows (%d)", g.Windows.Size) {
		//SetNextItemOpen(true, ImGuiCond_Once);
		DebugNodeWindowsList(&g.Windows, "By display order")
		DebugNodeWindowsList(&g.WindowsFocusOrder, "By focus order (root windows)")
		if TreeNode("By submission order (begin stack)") {
			// Here we display windows in their submitted order/hierarchy, however note that the Begin stack doesn't constitute a Parent<>Child relationship!
			temp_buffer : ^ImVector(^ImGuiWindow) = g.WindowsTempSortBuffer
			resize(&temp_buffer, 0)
			for window in g.Windows { if window.LastFrameActive + 1 >= g.FrameCount { push_back(&temp_buffer, window) } }

			Func :: struct { }

			Func_WindowComparerByBeginOrder :: proc(this : ^Func, lhs : rawptr, rhs : rawptr) -> i32 { return (cast(i32) (cast(^^ImGuiWindow) lhs^).BeginOrderWithinContext - (cast(^^ImGuiWindow) rhs^).BeginOrderWithinContext) }

			ImQsort(temp_buffer.Data, cast(uint) temp_buffer.Size, size_of(^ImGuiWindow), this.Func_WindowComparerByBeginOrder)
			DebugNodeWindowsListByBeginStackParent(temp_buffer.Data, temp_buffer.Size, nil)
			TreePop()
		}

		TreePop()
	}

	// DrawLists
	drawlist_count : i32 = 0
	for viewport in g.Viewports { drawlist_count += viewport.DrawDataP.CmdLists.Size }

	if TreeNode("DrawLists", "DrawLists (%d)", drawlist_count) {
		Checkbox("Show ImDrawCmd mesh when hovering", &cfg.ShowDrawCmdMesh)
		Checkbox("Show ImDrawCmd bounding boxes when hovering", &cfg.ShowDrawCmdBoundingBoxes)
		for viewport in g.Viewports {
			viewport_has_drawlist : bool = false
			for draw_list in viewport.DrawDataP.CmdLists {
				if !viewport_has_drawlist { Text("Active DrawLists in Viewport #%d, ID: 0x%08X", viewport.Idx, viewport.ID) }
				viewport_has_drawlist = true
				DebugNodeDrawList(nil, viewport, draw_list, "DrawList")
			}
		}

		TreePop()
	}

	// Viewports
	if TreeNode("Viewports", "Viewports (%d)", g.Viewports.Size) {
		cfg.HighlightMonitorIdx = -1
		open : bool = TreeNode("Monitors", "Monitors (%d)", g.PlatformIO.Monitors.Size)
		SameLine()
		MetricsHelpMarker("Dear ImGui uses monitor data:\n- to query DPI settings on a per monitor basis\n- to position popup/tooltips so they don't straddle monitors.")
		if open {
			for i : i32 = 0; i < g.PlatformIO.Monitors.Size; post_incr(&i) {
				DebugNodePlatformMonitor(&g.PlatformIO.Monitors[i], "Monitor", i)
				if IsItemHovered() { cfg.HighlightMonitorIdx = i }
			}

			DebugNodePlatformMonitor(&g.FallbackMonitor, "Fallback", 0)
			TreePop()
		}

		SetNextItemOpen(true, ImGuiCond_.ImGuiCond_Once)
		if TreeNode("Windows Minimap") {
			RenderViewportsThumbnails()
			TreePop()
		}
		cfg.HighlightViewportID = 0

		BulletText("MouseViewport: 0x%08X (UserHovered 0x%08X, LastHovered 0x%08X)", g.MouseViewport ? g.MouseViewport.ID : 0, g.IO.MouseHoveredViewport, g.MouseLastHoveredViewport ? g.MouseLastHoveredViewport.ID : 0)
		if TreeNode("Inferred Z order (front-to-back)") {
			viewports : ImVector(^ImGuiViewportP)
			resize(&viewports, g.Viewports.Size)
			memcpy(viewports.Data, g.Viewports.Data, size_in_bytes(&g.Viewports))
			if viewports.Size > 1 { ImQsort(viewports.Data, viewports.Size, size_of(^ImGuiViewport), ViewportComparerByLastFocusedStampCount) }
			for viewport in viewports {
				BulletText("Viewport #%d, ID: 0x%08X, LastFocused = %08d, PlatformFocused = %s, Window: \"%s\"", viewport.Idx, viewport.ID, viewport.LastFocusedStampCount, (g.PlatformIO.Platform_GetWindowFocus && viewport.PlatformWindowCreated) ? (Platform_GetWindowFocus(&g.PlatformIO, viewport) ? "1" : "0") : "N/A", viewport.Window ? viewport.Window.Name : "N/A")
				if IsItemHovered() { cfg.HighlightViewportID = viewport.ID }
			}

			TreePop()
		}

		for viewport in g.Viewports { DebugNodeViewport(viewport) }

		TreePop()
	}

	// Details for Popups
	if TreeNode("Popups", "Popups (%d)", g.OpenPopupStack.Size) {
		for popup_data in g.OpenPopupStack {
			// As it's difficult to interact with tree nodes while popups are open, we display everything inline.
			window : ^ImGuiWindow = popup_data.Window
			BulletText("PopupID: %08x, Window: '%s' (%s%s), RestoreNavWindow '%s', ParentWindow '%s'", popup_data.PopupId, window ? window.Name : "NULL", window && (window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_ChildWindow) ? "Child;" : "", window && (window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_ChildMenu) ? "Menu;" : "", popup_data.RestoreNavWindow ? popup_data.RestoreNavWindow.Name : "NULL", window && window.ParentWindow ? window.ParentWindow.Name : "NULL")
		}

		TreePop()
	}

	// Details for TabBars
	if TreeNode("TabBars", "Tab Bars (%d)", GetAliveCount(&g.TabBars)) {
		for n : i32 = 0; n < GetMapSize(&g.TabBars); post_incr(&n) { if tab_bar : ^ImGuiTabBar = TryGetMapData(&g.TabBars, n); tab_bar {
	PushID(tab_bar)
	DebugNodeTabBar(tab_bar, "TabBar")
	PopID()
} }

		TreePop()
	}

	// Details for Tables
	if TreeNode("Tables", "Tables (%d)", GetAliveCount(&g.Tables)) {
		for n : i32 = 0; n < GetMapSize(&g.Tables); post_incr(&n) { if table : ^ImGuiTable = TryGetMapData(&g.Tables, n); table { DebugNodeTable(table) } }

		TreePop()
	}

	// Details for Fonts
	atlas : ^ImFontAtlas = g.IO.Fonts
	if TreeNode("Fonts", "Fonts (%d)", atlas.Fonts.Size) {
		ShowFontAtlas(atlas)
		TreePop()
	}

	// Details for InputText
	if TreeNode("InputText") {
		DebugNodeInputTextState(&g.InputTextState)
		TreePop()
	}

	// Details for TypingSelect
	if TreeNode("TypingSelect", "TypingSelect (%d)", g.TypingSelectState.SearchBuffer[0] != 0 ? 1 : 0) {
		DebugNodeTypingSelectState(&g.TypingSelectState)
		TreePop()
	}

	// Details for MultiSelect
	if TreeNode("MultiSelect", "MultiSelect (%d)", GetAliveCount(&g.MultiSelectStorage)) {
		bs : ^ImGuiBoxSelectState = &g.BoxSelectState
		BulletText("BoxSelect ID=0x%08X, Starting = %d, Active %d", bs.ID, bs.IsStarting, bs.IsActive)
		for n : i32 = 0; n < GetMapSize(&g.MultiSelectStorage); post_incr(&n) { if state : ^ImGuiMultiSelectState = TryGetMapData(&g.MultiSelectStorage, n); state { DebugNodeMultiSelectState(state) } }

		TreePop()
	}

	// Details for Docking
	when IMGUI_HAS_DOCK { // @gen ifdef
	if TreeNode("Docking") {
		root_nodes_only : bool = true
		dc : ^ImGuiDockContext = &g.DockContext
		Checkbox("List root nodes", &root_nodes_only)
		Checkbox("Ctrl shows window dock info", &cfg.ShowDockingNodes)
		if SmallButton("Clear nodes") { DockContextClearNodes(&g, 0, true) }
		SameLine()
		if SmallButton("Rebuild all") { dc.WantFullRebuild = true }
		for n : i32 = 0; n < dc.Nodes.Data.Size; post_incr(&n) { if node : ^ImGuiDockNode = cast(^ImGuiDockNode) dc.Nodes.Data[n].val_p; node { if !root_nodes_only || IsRootNode(node) { DebugNodeDockNode(node, "Node") } } }

		TreePop()
	}
	} // preproc endif// #ifdef IMGUI_HAS_DOCK

	// Settings
	if TreeNode("Settings") {
		if SmallButton("Clear") { ClearIniSettings() }
		SameLine()
		if SmallButton("Save to memory") { SaveIniSettingsToMemory() }
		SameLine()
		if SmallButton("Save to disk") { SaveIniSettingsToDisk(g.IO.IniFilename) }
		SameLine()
		if g.IO.IniFilename { Text("\"%s\"", g.IO.IniFilename) }
		else { TextUnformatted("<NULL>") }
		Checkbox("io.ConfigDebugIniSettings", &io.ConfigDebugIniSettings)
		Text("SettingsDirtyTimer %.2f", g.SettingsDirtyTimer)
		if TreeNode("SettingsHandlers", "Settings handlers: (%d)", g.SettingsHandlers.Size) {
			for handler in g.SettingsHandlers { BulletText("\"%s\"", handler.TypeName) }

			TreePop()
		}
		if TreeNode("SettingsWindows", "Settings packed data: Windows: %d bytes", size(&g.SettingsWindows)) {
			for settings : ^ImGuiWindowSettings = begin(&g.SettingsWindows); settings != nil; settings = next_chunk(&g.SettingsWindows, settings) { DebugNodeWindowSettings(settings) }

			TreePop()
		}

		if TreeNode("SettingsTables", "Settings packed data: Tables: %d bytes", size(&g.SettingsTables)) {
			for settings : ^ImGuiTableSettings = begin(&g.SettingsTables); settings != nil; settings = next_chunk(&g.SettingsTables, settings) { DebugNodeTableSettings(settings) }

			TreePop()
		}

		when IMGUI_HAS_DOCK { // @gen ifdef
		if TreeNode("SettingsDocking", "Settings packed data: Docking") {
			dc : ^ImGuiDockContext = &g.DockContext
			Text("In SettingsWindows:")
			for settings : ^ImGuiWindowSettings = begin(&g.SettingsWindows); settings != nil; settings = next_chunk(&g.SettingsWindows, settings) { if settings.DockId != 0 { BulletText("Window '%s' -> DockId %08X DockOrder=%d", GetName(settings), settings.DockId, settings.DockOrder) } }

			Text("In SettingsNodes:")
			for n : i32 = 0; n < dc.NodesSettings.Size; post_incr(&n) {
				settings : ^ImGuiDockNodeSettings = &dc.NodesSettings[n]
				selected_tab_name : ^u8 = nil
				if settings.SelectedTabId {
					if window : ^ImGuiWindow = FindWindowByID(settings.SelectedTabId); window { selected_tab_name = window.Name }
					else if window_settings : ^ImGuiWindowSettings = FindWindowSettingsByID(settings.SelectedTabId); window_settings { selected_tab_name = GetName(window_settings) }
				}
				BulletText("Node %08X, Parent %08X, SelectedTab %08X ('%s')", settings.ID, settings.ParentNodeId, settings.SelectedTabId, selected_tab_name ? selected_tab_name : settings.SelectedTabId ? "N/A" : "")
			}

			TreePop()
		}
		} // preproc endif// #ifdef IMGUI_HAS_DOCK

		if TreeNode("SettingsIniData", "Settings unpacked data (.ini): %d bytes", size(&g.SettingsIniData)) {
			InputTextMultiline("##Ini", cast(^u8) cast(rawptr) c_str(&g.SettingsIniData), g.SettingsIniData.Buf.Size, ImVec2(-FLT_MIN, GetTextLineHeight() * 20), ImGuiInputTextFlags_.ImGuiInputTextFlags_ReadOnly)
			TreePop()
		}
		TreePop()
	}

	// Settings
	if TreeNode("Memory allocations") {
		info : ^ImGuiDebugAllocInfo = &g.DebugAllocInfo
		Text("%d current allocations", info.TotalAllocCount - info.TotalFreeCount)
		if SmallButton("GC now") { g.GcCompactAll = true }
		Text("Recent frames with allocations:")
		buf_size : i32 = IM_ARRAYSIZE(info.LastEntriesBuf)
		for n : i32 = buf_size - 1; n >= 0; post_decr(&n) {
			entry : ^ImGuiDebugAllocEntry = &info.LastEntriesBuf[(info.LastEntriesIdx - n + buf_size) % buf_size]
			BulletText("Frame %06d: %+3d ( %2d alloc, %2d free )", entry.FrameCount, entry.AllocCount - entry.FreeCount, entry.AllocCount, entry.FreeCount)
			if n == 0 {
				SameLine()
				Text("<- %d frames ago", g.FrameCount - entry.FrameCount)
			}
		}

		TreePop()
	}

	if TreeNode("Inputs") {
		Text("KEYBOARD/GAMEPAD/MOUSE KEYS")
		{
		// User code should never have to go through such hoops! You can generally iterate between ImGuiKey_NamedKey_BEGIN and ImGuiKey_NamedKey_END.
		Indent()
		Text("Keys down:"); for key : ImGuiKey = ImGuiKey.ImGuiKey_NamedKey_BEGIN; key < ImGuiKey.ImGuiKey_NamedKey_END; key = cast(ImGuiKey) (key + 1) {if !IsKeyDown(key) { continue }; SameLine(); Text(IsNamedKey(key) ? "\"%s\"" : "\"%s\" %d", GetKeyName(key), key); SameLine(); Text("(%.02f)", GetKeyData(key).DownDuration)		}

		Text("Keys pressed:"); for key : ImGuiKey = ImGuiKey.ImGuiKey_NamedKey_BEGIN; key < ImGuiKey.ImGuiKey_NamedKey_END; key = cast(ImGuiKey) (key + 1) {if !IsKeyPressed(key) { continue }; SameLine(); Text(IsNamedKey(key) ? "\"%s\"" : "\"%s\" %d", GetKeyName(key), key)		}

		Text("Keys released:"); for key : ImGuiKey = ImGuiKey.ImGuiKey_NamedKey_BEGIN; key < ImGuiKey.ImGuiKey_NamedKey_END; key = cast(ImGuiKey) (key + 1) {if !IsKeyReleased(key) { continue }; SameLine(); Text(IsNamedKey(key) ? "\"%s\"" : "\"%s\" %d", GetKeyName(key), key)		}

		Text("Keys mods: %s%s%s%s", io.KeyCtrl ? "CTRL " : "", io.KeyShift ? "SHIFT " : "", io.KeyAlt ? "ALT " : "", io.KeySuper ? "SUPER " : "")
		Text("Chars queue:"); for i : i32 = 0; i < io.InputQueueCharacters.Size; post_incr(&i) {c : ImWchar = io.InputQueueCharacters[i]; SameLine(); Text("\'%c\' (0x%04X)", (c > ' ' && c <= 255) ? cast(u8) c : '?', c)		}; 

// FIXME: We should convert 'c' to UTF-8 here but the functions are not public.
		DebugRenderKeyboardPreview(GetWindowDrawList())
		Unindent()
		}

		Text("MOUSE STATE")
		{
		Indent()
		if IsMousePosValid() { Text("Mouse pos: (%g, %g)", io.MousePos.x, io.MousePos.y) }
		else { Text("Mouse pos: <INVALID>") }
		Text("Mouse delta: (%g, %g)", io.MouseDelta.x, io.MouseDelta.y)
		count : i32 = IM_ARRAYSIZE(io.MouseDown)
		Text("Mouse down:"); for i : i32 = 0; i < count; post_incr(&i) { if IsMouseDown(i) {SameLine(); Text("b%d (%.02f secs)", i, io.MouseDownDuration[i])
} }

		Text("Mouse clicked:"); for i : i32 = 0; i < count; post_incr(&i) { if IsMouseClicked(i) {SameLine(); Text("b%d (%d)", i, io.MouseClickedCount[i])
} }

		Text("Mouse released:"); for i : i32 = 0; i < count; post_incr(&i) { if IsMouseReleased(i) {SameLine(); Text("b%d", i)
} }

		Text("Mouse wheel: %.1f", io.MouseWheel)
		Text("MouseStationaryTimer: %.2f", g.MouseStationaryTimer)
		Text("Mouse source: %s", GetMouseSourceName(io.MouseSource))
		Text("Pen Pressure: %.1f", io.PenPressure); // Note: currently unused
		Unindent()
		}

		Text("MOUSE WHEELING")
		{
		Indent()
		Text("WheelingWindow: '%s'", g.WheelingWindow ? g.WheelingWindow.Name : "NULL")
		Text("WheelingWindowReleaseTimer: %.2f", g.WheelingWindowReleaseTimer)
		Text("WheelingAxisAvg[] = { %.3f, %.3f }, Main Axis: %s", g.WheelingAxisAvg.x, g.WheelingAxisAvg.y, (g.WheelingAxisAvg.x > g.WheelingAxisAvg.y) ? "X" : (g.WheelingAxisAvg.x < g.WheelingAxisAvg.y) ? "Y" : "<none>")
		Unindent()
		}

		Text("KEY OWNERS")
		{
		Indent()
		if BeginChild("##owners", ImVec2(-FLT_MIN, GetTextLineHeightWithSpacing() * 8), ImGuiChildFlags_.ImGuiChildFlags_FrameStyle | ImGuiChildFlags_.ImGuiChildFlags_ResizeY, ImGuiWindowFlags_.ImGuiWindowFlags_NoSavedSettings) { for key : ImGuiKey = ImGuiKey.ImGuiKey_NamedKey_BEGIN; key < ImGuiKey.ImGuiKey_NamedKey_END; key = cast(ImGuiKey) (key + 1) {
	owner_data : ^ImGuiKeyOwnerData = GetKeyOwnerData(&g, key)
	if owner_data.OwnerCurr == ImGuiKeyOwner_NoOwner { continue }
	Text("%s: 0x%08X%s", GetKeyName(key), owner_data.OwnerCurr, owner_data.LockUntilRelease ? " LockUntilRelease" : owner_data.LockThisFrame ? " LockThisFrame" : "")
	DebugLocateItemOnHover(owner_data.OwnerCurr)
} }
		EndChild()
		Unindent()
		}
		Text("SHORTCUT ROUTING")
		SameLine()
		MetricsHelpMarker("Declared shortcut routes automatically set key owner when mods matches.")
		{
		Indent()
		if BeginChild("##routes", ImVec2(-FLT_MIN, GetTextLineHeightWithSpacing() * 8), ImGuiChildFlags_.ImGuiChildFlags_FrameStyle | ImGuiChildFlags_.ImGuiChildFlags_ResizeY, ImGuiWindowFlags_.ImGuiWindowFlags_NoSavedSettings) { for key : ImGuiKey = ImGuiKey.ImGuiKey_NamedKey_BEGIN; key < ImGuiKey.ImGuiKey_NamedKey_END; key = cast(ImGuiKey) (key + 1) {
	rt : ^ImGuiKeyRoutingTable = &g.KeysRoutingTable
	for idx : ImGuiKeyRoutingIndex = rt.Index[key - ImGuiKey.ImGuiKey_NamedKey_BEGIN]; idx != -1;  {
		routing_data : ^ImGuiKeyRoutingData = &rt.Entries[idx]
		key_chord : ImGuiKeyChord = key | routing_data.Mods
		Text("%s: 0x%08X (scored %d)", GetKeyChordName(key_chord), routing_data.RoutingCurr, routing_data.RoutingCurrScore)
		DebugLocateItemOnHover(routing_data.RoutingCurr)
		if g.IO.ConfigDebugIsDebuggerPresent {
			SameLine()
			if DebugBreakButton("**DebugBreak**", "in SetShortcutRouting() for this KeyChord") { g.DebugBreakInShortcutRouting = key_chord }
		}
		idx = routing_data.NextEntryIndex
	}
} }
		EndChild()
		Text("(ActiveIdUsing: AllKeyboardKeys: %d, NavDirMask: 0x%X)", g.ActiveIdUsingAllKeyboardKeys, g.ActiveIdUsingNavDirMask)
		Unindent()
		}
		TreePop()
	}

	if TreeNode("Internal state") {
		Text("WINDOWING")
		Indent()
		Text("HoveredWindow: '%s'", g.HoveredWindow ? g.HoveredWindow.Name : "NULL")
		Text("HoveredWindow->Root: '%s'", g.HoveredWindow ? g.HoveredWindow.RootWindowDockTree.Name : "NULL")
		Text("HoveredWindowUnderMovingWindow: '%s'", g.HoveredWindowUnderMovingWindow ? g.HoveredWindowUnderMovingWindow.Name : "NULL")
		Text("HoveredDockNode: 0x%08X", g.DebugHoveredDockNode ? g.DebugHoveredDockNode.ID : 0)
		Text("MovingWindow: '%s'", g.MovingWindow ? g.MovingWindow.Name : "NULL")
		Text("MouseViewport: 0x%08X (UserHovered 0x%08X, LastHovered 0x%08X)", g.MouseViewport.ID, g.IO.MouseHoveredViewport, g.MouseLastHoveredViewport ? g.MouseLastHoveredViewport.ID : 0)
		Unindent()

		Text("ITEMS")
		Indent()
		Text("ActiveId: 0x%08X/0x%08X (%.2f sec), AllowOverlap: %d, Source: %s", g.ActiveId, g.ActiveIdPreviousFrame, g.ActiveIdTimer, g.ActiveIdAllowOverlap, GetInputSourceName(g.ActiveIdSource))
		DebugLocateItemOnHover(g.ActiveId)
		Text("ActiveIdWindow: '%s'", g.ActiveIdWindow ? g.ActiveIdWindow.Name : "NULL")
		Text("ActiveIdUsing: AllKeyboardKeys: %d, NavDirMask: %X", g.ActiveIdUsingAllKeyboardKeys, g.ActiveIdUsingNavDirMask)
		Text("HoveredId: 0x%08X (%.2f sec), AllowOverlap: %d", g.HoveredIdPreviousFrame, g.HoveredIdTimer, g.HoveredIdAllowOverlap); // Not displaying g.HoveredId as it is update mid-frame
		Text("HoverItemDelayId: 0x%08X, Timer: %.2f, ClearTimer: %.2f", g.HoverItemDelayId, g.HoverItemDelayTimer, g.HoverItemDelayClearTimer)
		Text("DragDrop: %d, SourceId = 0x%08X, Payload \"%s\" (%d bytes)", g.DragDropActive, g.DragDropPayload.SourceId, g.DragDropPayload.DataType, g.DragDropPayload.DataSize)
		DebugLocateItemOnHover(g.DragDropPayload.SourceId)
		Unindent()

		Text("NAV,FOCUS")
		Indent()
		Text("NavWindow: '%s'", g.NavWindow ? g.NavWindow.Name : "NULL")
		Text("NavId: 0x%08X, NavLayer: %d", g.NavId, g.NavLayer)
		DebugLocateItemOnHover(g.NavId)
		Text("NavInputSource: %s", GetInputSourceName(g.NavInputSource))
		Text(")", g.NavLastValidSelectionUserData, g.NavLastValidSelectionUserData)
		Text("NavActive: %d, NavVisible: %d", g.IO.NavActive, g.IO.NavVisible)
		Text("NavActivateId/DownId/PressedId: %08X/%08X/%08X", g.NavActivateId, g.NavActivateDownId, g.NavActivatePressedId)
		Text("NavActivateFlags: %04X", g.NavActivateFlags)
		Text("NavCursorVisible: %d, NavHighlightItemUnderNav: %d", g.NavCursorVisible, g.NavHighlightItemUnderNav)
		Text("NavFocusScopeId = 0x%08X", g.NavFocusScopeId)
		Text("NavFocusRoute[] = ")
		for path_n : i32 = g.NavFocusRoute.Size - 1; path_n >= 0; post_decr(&path_n) {
			focus_scope : ^ImGuiFocusScopeData = g.NavFocusRoute[path_n]
			SameLine(0.0, 0.0)
			Text("0x%08X/", focus_scope.ID)
			SetItemTooltip("In window \"%s\"", FindWindowByID(focus_scope.WindowID).Name)
		}

		Text("NavWindowingTarget: '%s'", g.NavWindowingTarget ? g.NavWindowingTarget.Name : "NULL")
		Unindent()

		TreePop()
	}

	// Overlay: Display windows Rectangles and Begin Order
	if cfg.ShowWindowsRects || cfg.ShowWindowsBeginOrder {
		for window in g.Windows {
			if !window.WasActive { continue }
			draw_list : ^ImDrawList = GetForegroundDrawList(window)
			if cfg.ShowWindowsRects {
				r : ImRect = GetWindowRect(window, cfg.ShowWindowsRectsType)
				AddRect(draw_list, r.Min, r.Max, IM_COL32(255, 0, 128, 255))
			}
			if cfg.ShowWindowsBeginOrder && !(window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_ChildWindow) {
				buf : [32]u8
				ImFormatString(buf, IM_ARRAYSIZE(buf), "%d", window.BeginOrderWithinContext)
				font_size : f32 = GetFontSize()
				AddRectFilled(draw_list, window.Pos, window.Pos + ImVec2(font_size, font_size), IM_COL32(200, 100, 100, 255))
				AddText(draw_list, window.Pos, IM_COL32(255, 255, 255, 255), buf)
			}
		}
	}

	// Overlay: Display Tables Rectangles
	if cfg.ShowTablesRects {
		for table_n : i32 = 0; table_n < GetMapSize(&g.Tables); post_incr(&table_n) {
			table : ^ImGuiTable = TryGetMapData(&g.Tables, table_n)
			if table == nil || table.LastFrameActive < g.FrameCount - 1 { continue }
			draw_list : ^ImDrawList = GetForegroundDrawList(table.OuterWindow)
			if cfg.ShowTablesRectsType >= E2.TRT_ColumnsRect {
				for column_n : i32 = 0; column_n < table.ColumnsCount; post_incr(&column_n) {
					r : ImRect = GetTableRect(table, cfg.ShowTablesRectsType, column_n)
					col : ImU32 = (table.HoveredColumnBody == column_n) ? IM_COL32(255, 255, 128, 255) : IM_COL32(255, 0, 128, 255)
					thickness : f32 = (table.HoveredColumnBody == column_n) ? 3.0 : 1.0
					AddRect(draw_list, r.Min, r.Max, col, 0.0, 0, thickness)
				}
			}
			else {
				r : ImRect = GetTableRect(table, cfg.ShowTablesRectsType, -1)
				AddRect(draw_list, r.Min, r.Max, IM_COL32(255, 0, 128, 255))
			}
		}
	}

	when IMGUI_HAS_DOCK { // @gen ifdef
	// Overlay: Display Docking info
	if cfg.ShowDockingNodes && g.IO.KeyCtrl && g.DebugHoveredDockNode {
		buf : [64]u8 = ""
		p : ^u8 = buf
		node : ^ImGuiDockNode = g.DebugHoveredDockNode
		overlay_draw_list : ^ImDrawList = node.HostWindow ? GetForegroundDrawList(node.HostWindow) : GetForegroundDrawList(GetMainViewport())
		p += ImFormatString(p, buf + IM_ARRAYSIZE(buf) - p, "DockId: %X%s\n", node.ID, IsCentralNode(node) ? " *CentralNode*" : "")
		p += ImFormatString(p, buf + IM_ARRAYSIZE(buf) - p, "WindowClass: %08X\n", node.WindowClass.ClassId)
		p += ImFormatString(p, buf + IM_ARRAYSIZE(buf) - p, "Size: (%.0f, %.0f)\n", node.Size.x, node.Size.y)
		p += ImFormatString(p, buf + IM_ARRAYSIZE(buf) - p, "SizeRef: (%.0f, %.0f)\n", node.SizeRef.x, node.SizeRef.y)
		depth : i32 = DockNodeGetDepth(node)
		AddRect(overlay_draw_list, node.Pos + ImVec2(3, 3) * cast(f32) depth, node.Pos + node.Size - ImVec2(3, 3) * cast(f32) depth, IM_COL32(200, 100, 100, 255))
		pos : ImVec2 = node.Pos + ImVec2(3, 3) * cast(f32) depth
		AddRectFilled(overlay_draw_list, pos - ImVec2(1, 1), pos + CalcTextSize(buf) + ImVec2(1, 1), IM_COL32(200, 100, 100, 255))
		AddText(overlay_draw_list, nil, 0.0, pos, IM_COL32(255, 255, 255, 255), buf)
	}
	} // preproc endif// #ifdef IMGUI_HAS_DOCK

	End()
}

DebugBreakClearData :: proc()
{
	// Those fields are scattered in their respective subsystem to stay in hot-data locations
	g : ^ImGuiContext = GImGui^
	g.DebugBreakInWindow = 0
	g.DebugBreakInTable = 0
	g.DebugBreakInShortcutRouting = ImGuiKey.ImGuiKey_None
}

DebugBreakButtonTooltip :: proc(keyboard_only : bool, description_of_location : ^u8)
{
	if !BeginItemTooltip() { return }
	Text("To call IM_DEBUG_BREAK() %s:", description_of_location)
	Separator()
	TextUnformatted(keyboard_only ? "- Press 'Pause/Break' on keyboard." : "- Press 'Pause/Break' on keyboard.\n- or Click (may alter focus/active id).\n- or navigate using keyboard and press space.")
	Separator()
	TextUnformatted("Choose one way that doesn't interfere with what you are trying to debug!\nYou need a debugger attached or this will crash!")
	EndTooltip()
}

// Special button that doesn't take focus, doesn't take input owner, and can be activated without a click etc.
// In order to reduce interferences with the contents we are trying to debug into.
DebugBreakButton :: proc(label : ^u8, description_of_location : ^u8) -> bool
{
	window : ^ImGuiWindow = GetCurrentWindow()
	if window.SkipItems { return false }

	g : ^ImGuiContext = GImGui^
	id : ImGuiID = GetID(window, label)
	label_size : ImVec2 = CalcTextSize(label, nil, true)
	pos : ImVec2 = window.DC.CursorPos + ImVec2(0.0, window.DC.CurrLineTextBaseOffset)
	size : ImVec2 = ImVec2(label_size.x + g.Style.FramePadding.x * 2.0, label_size.y)

	bb : ImRect; init(&bb, pos, pos + size)
	ItemSize(size, 0.0)
	if !ItemAdd(bb, id) { return false }

	// WE DO NOT USE ButtonEx() or ButtonBehavior() in order to reduce our side-effects.
	hovered : bool = ItemHoverable(bb, id, g.CurrentItemFlags)
	pressed : bool = hovered && (IsKeyChordPressed(g.DebugBreakKeyChord) || IsMouseClicked(0) || g.NavActivateId == id)
	DebugBreakButtonTooltip(false, description_of_location)

	col4f : ImVec4 = GetStyleColorVec4(hovered ? ImGuiCol_.ImGuiCol_ButtonHovered : ImGuiCol_.ImGuiCol_Button)
	hsv : ImVec4
	ColorConvertRGBtoHSV(col4f.x, col4f.y, col4f.z, hsv.x, hsv.y, hsv.z)
	ColorConvertHSVtoRGB(hsv.x + 0.20, hsv.y, hsv.z, col4f.x, col4f.y, col4f.z)

	RenderNavCursor(bb, id)
	RenderFrame(bb.Min, bb.Max, GetColorU32(col4f), true, g.Style.FrameRounding)
	RenderTextClipped(bb.Min, bb.Max, label, nil, &label_size, g.Style.ButtonTextAlign, &bb)

	IMGUI_TEST_ENGINE_ITEM_INFO(id, label, g.LastItemData.StatusFlags)
	return pressed
}

// [DEBUG] Display contents of Columns
DebugNodeColumns :: proc(columns : ^ImGuiOldColumns)
{
	if !TreeNode(cast(rawptr) cast(uintptr_t) columns.ID, "Columns Id: 0x%08X, Count: %d, Flags: 0x%04X", columns.ID, columns.Count, columns.Flags) { return }
	BulletText("Width: %.1f (MinX: %.1f, MaxX: %.1f)", columns.OffMaxX - columns.OffMinX, columns.OffMinX, columns.OffMaxX)
	for column in columns.Columns { BulletText("Column %02d: OffsetNorm %.3f (= %.1f px)", cast(i32) index_from_ptr(&columns.Columns, &column), column.OffsetNorm, GetColumnOffsetFromNorm(columns, column.OffsetNorm)) }

	TreePop()
}

DebugNodeDockNodeFlags :: proc(p_flags : ^ImGuiDockNodeFlags, label : ^u8, enabled : bool)
{
	PushID(label)
	PushStyleVar(ImGuiStyleVar_.ImGuiStyleVar_FramePadding, ImVec2(0.0, 0.0))
	Text("%s:", label)
	if !enabled { BeginDisabled() }
	CheckboxFlags("NoResize", p_flags, ImGuiDockNodeFlags_.ImGuiDockNodeFlags_NoResize)
	CheckboxFlags("NoResizeX", p_flags, ImGuiDockNodeFlagsPrivate_.ImGuiDockNodeFlags_NoResizeX)
	CheckboxFlags("NoResizeY", p_flags, ImGuiDockNodeFlagsPrivate_.ImGuiDockNodeFlags_NoResizeY)
	CheckboxFlags("NoTabBar", p_flags, ImGuiDockNodeFlagsPrivate_.ImGuiDockNodeFlags_NoTabBar)
	CheckboxFlags("HiddenTabBar", p_flags, ImGuiDockNodeFlagsPrivate_.ImGuiDockNodeFlags_HiddenTabBar)
	CheckboxFlags("NoWindowMenuButton", p_flags, ImGuiDockNodeFlagsPrivate_.ImGuiDockNodeFlags_NoWindowMenuButton)
	CheckboxFlags("NoCloseButton", p_flags, ImGuiDockNodeFlagsPrivate_.ImGuiDockNodeFlags_NoCloseButton)
	CheckboxFlags("DockedWindowsInFocusRoute", p_flags, ImGuiDockNodeFlagsPrivate_.ImGuiDockNodeFlags_DockedWindowsInFocusRoute)
	CheckboxFlags("NoDocking", p_flags, ImGuiDockNodeFlagsPrivate_.ImGuiDockNodeFlags_NoDocking); // Multiple flags
	CheckboxFlags("NoDockingSplit", p_flags, ImGuiDockNodeFlags_.ImGuiDockNodeFlags_NoDockingSplit)
	CheckboxFlags("NoDockingSplitOther", p_flags, ImGuiDockNodeFlagsPrivate_.ImGuiDockNodeFlags_NoDockingSplitOther)
	CheckboxFlags("NoDockingOver", p_flags, ImGuiDockNodeFlagsPrivate_.ImGuiDockNodeFlags_NoDockingOverMe)
	CheckboxFlags("NoDockingOverOther", p_flags, ImGuiDockNodeFlagsPrivate_.ImGuiDockNodeFlags_NoDockingOverOther)
	CheckboxFlags("NoDockingOverEmpty", p_flags, ImGuiDockNodeFlagsPrivate_.ImGuiDockNodeFlags_NoDockingOverEmpty)
	CheckboxFlags("NoUndocking", p_flags, ImGuiDockNodeFlags_.ImGuiDockNodeFlags_NoUndocking)
	if !enabled { EndDisabled() }
	PopStyleVar()
	PopID()
}

// [DEBUG] Display contents of ImDockNode
DebugNodeDockNode :: proc(node : ^ImGuiDockNode, label : ^u8)
{
	g : ^ImGuiContext = GImGui^
	is_alive : bool = (g.FrameCount - node.LastFrameAlive < 2); // Submitted with ImGuiDockNodeFlags_KeepAliveOnly
	is_active : bool = (g.FrameCount - node.LastFrameActive < 2); // Submitted
	if !is_alive { PushStyleColor(ImGuiCol_.ImGuiCol_Text, GetStyleColorVec4(ImGuiCol_.ImGuiCol_TextDisabled)) }
	open : bool
	tree_node_flags : ImGuiTreeNodeFlags = node.IsFocused ? ImGuiTreeNodeFlags_.ImGuiTreeNodeFlags_Selected : ImGuiTreeNodeFlags_.ImGuiTreeNodeFlags_None
	if node.Windows.Size > 0 { open = TreeNodeEx(cast(rawptr) cast(intptr_t) node.ID, tree_node_flags, "%s 0x%04X%s: %d windows (vis: '%s')", label, node.ID, node.IsVisible ? "" : " (hidden)", node.Windows.Size, node.VisibleWindow ? node.VisibleWindow.Name : "NULL") }
	else { open = TreeNodeEx(cast(rawptr) cast(intptr_t) node.ID, tree_node_flags, "%s 0x%04X%s: %s (vis: '%s')", label, node.ID, node.IsVisible ? "" : " (hidden)", (node.SplitAxis == ImGuiAxis.ImGuiAxis_X) ? "horizontal split" : (node.SplitAxis == ImGuiAxis.ImGuiAxis_Y) ? "vertical split" : "empty", node.VisibleWindow ? node.VisibleWindow.Name : "NULL") }
	if !is_alive { PopStyleColor() }
	if is_active && IsItemHovered() { if window : ^ImGuiWindow = node.HostWindow ? node.HostWindow : node.VisibleWindow; window { AddRect(GetForegroundDrawList(window), node.Pos, node.Pos + node.Size, IM_COL32(255, 255, 0, 255)) } }
	if open {
		IM_ASSERT(node.ChildNodes[0] == nil || node.ChildNodes[0].ParentNode == node)
		IM_ASSERT(node.ChildNodes[1] == nil || node.ChildNodes[1].ParentNode == node)
		BulletText("Pos (%.0f,%.0f), Size (%.0f, %.0f) Ref (%.0f, %.0f)", node.Pos.x, node.Pos.y, node.Size.x, node.Size.y, node.SizeRef.x, node.SizeRef.y)
		DebugNodeWindow(node.HostWindow, "HostWindow")
		DebugNodeWindow(node.VisibleWindow, "VisibleWindow")
		BulletText("SelectedTabID: 0x%08X, LastFocusedNodeID: 0x%08X", node.SelectedTabId, node.LastFocusedNodeId)
		BulletText("Misc:%s%s%s%s%s%s%s", IsDockSpace(node) ? " IsDockSpace" : "", IsCentralNode(node) ? " IsCentralNode" : "", is_alive ? " IsAlive" : "", is_active ? " IsActive" : "", node.IsFocused ? " IsFocused" : "", node.WantLockSizeOnce ? " WantLockSizeOnce" : "", node.HasCentralNodeChild ? " HasCentralNodeChild" : "")
		if TreeNode("flags", "Flags Merged: 0x%04X, Local: 0x%04X, InWindows: 0x%04X, Shared: 0x%04X", node.MergedFlags, node.LocalFlags, node.LocalFlagsInWindows, node.SharedFlags) {
			if BeginTable("flags", 4) {
				TableNextColumn(); DebugNodeDockNodeFlags(&node.MergedFlags, "MergedFlags", false)
				TableNextColumn(); DebugNodeDockNodeFlags(&node.LocalFlags, "LocalFlags", true)
				TableNextColumn(); DebugNodeDockNodeFlags(&node.LocalFlagsInWindows, "LocalFlagsInWindows", false)
				TableNextColumn(); DebugNodeDockNodeFlags(&node.SharedFlags, "SharedFlags", true)
				EndTable()
			}
			TreePop()
		}
		if node.ParentNode { DebugNodeDockNode(node.ParentNode, "ParentNode") }
		if node.ChildNodes[0] { DebugNodeDockNode(node.ChildNodes[0], "Child[0]") }
		if node.ChildNodes[1] { DebugNodeDockNode(node.ChildNodes[1], "Child[1]") }
		if node.TabBar { DebugNodeTabBar(node.TabBar, "TabBar") }
		DebugNodeWindowsList(&node.Windows, "Windows")

		TreePop()
	}
}

// [DEBUG] Display contents of ImDrawList
// Note that both 'window' and 'viewport' may be NULL here. Viewport is generally null of destroyed popups which previously owned a viewport.
DebugNodeDrawList :: proc(window : ^ImGuiWindow, viewport : ^ImGuiViewportP, draw_list : ^ImDrawList, label : ^u8)
{
	g : ^ImGuiContext = GImGui^
	cfg : ^ImGuiMetricsConfig = &g.DebugMetricsConfig
	cmd_count : i32 = draw_list.CmdBuffer.Size
	if cmd_count > 0 && back(&draw_list.CmdBuffer).ElemCount == 0 && back(&draw_list.CmdBuffer).UserCallback == nil { post_decr(&cmd_count) }
	node_open : bool = TreeNode(draw_list, "%s: '%s' %d vtx, %d indices, %d cmds", label, draw_list._OwnerName ? draw_list._OwnerName : "", draw_list.VtxBuffer.Size, draw_list.IdxBuffer.Size, cmd_count)
	if draw_list == GetWindowDrawList() {
		SameLine()
		TextColored(ImVec4(1.0, 0.4, 0.4, 1.0), "CURRENTLY APPENDING"); // Can't display stats for active draw list! (we don't have the data double-buffered)
		if node_open { TreePop() }
		return
	}

	fg_draw_list : ^ImDrawList = viewport ? GetForegroundDrawList(viewport) : nil; // Render additional visuals into the top-most draw list
	if window && IsItemHovered() && fg_draw_list { AddRect(fg_draw_list, window.Pos, window.Pos + window.Size, IM_COL32(255, 255, 0, 255)) }
	if !node_open { return }

	if window && !window.WasActive { TextDisabled("Warning: owning Window is inactive. This DrawList is not being rendered!") }

	for pcmd : ^ImDrawCmd = draw_list.CmdBuffer.Data; pcmd < draw_list.CmdBuffer.Data + cmd_count; post_incr(&pcmd) {
		if pcmd.UserCallback {
			BulletText("Callback %p, user_data %p", pcmd.UserCallback, pcmd.UserCallbackData)
			continue
		}

		texid_desc : [20]u8
		FormatTextureIDForDebugDisplay(texid_desc, IM_ARRAYSIZE(texid_desc), pcmd.TextureId)
		buf : [300]u8
		ImFormatString(buf, IM_ARRAYSIZE(buf), "DrawCmd:%5d tris, Tex %s, ClipRect (%4.0f,%4.0f)-(%4.0f,%4.0f)", pcmd.ElemCount / 3, texid_desc, pcmd.ClipRect.x, pcmd.ClipRect.y, pcmd.ClipRect.z, pcmd.ClipRect.w)
		pcmd_node_open : bool = TreeNode(cast(rawptr) (pcmd - begin(&draw_list.CmdBuffer)), "%s", buf)
		if IsItemHovered() && (cfg.ShowDrawCmdMesh || cfg.ShowDrawCmdBoundingBoxes) && fg_draw_list { DebugNodeDrawCmdShowMeshAndBoundingBox(fg_draw_list, draw_list, pcmd, cfg.ShowDrawCmdMesh, cfg.ShowDrawCmdBoundingBoxes) }
		if !pcmd_node_open { continue }

		// Calculate approximate coverage area (touched pixel count)
		// This will be in pixels squared as long there's no post-scaling happening to the renderer output.
		idx_buffer : ^ImDrawIdx = (draw_list.IdxBuffer.Size > 0) ? draw_list.IdxBuffer.Data : nil
		vtx_buffer : ^ImDrawVert = draw_list.VtxBuffer.Data + pcmd.VtxOffset
		total_area : f32 = 0.0
		for idx_n : u32 = pcmd.IdxOffset; idx_n < pcmd.IdxOffset + pcmd.ElemCount;  {
			triangle : [3]ImVec2
			for n : i32 = 0; n < 3; n, idx_n = n + 1, idx_n + 1 { triangle[n] = vtx_buffer[idx_buffer ? idx_buffer[idx_n] : idx_n].pos }

			total_area += ImTriangleArea(triangle[0], triangle[1], triangle[2])
		}

		// Display vertex information summary. Hover to get all triangles drawn in wire-frame
		ImFormatString(buf, IM_ARRAYSIZE(buf), "Mesh: ElemCount: %d, VtxOffset: +%d, IdxOffset: +%d, Area: ~%0.f px", pcmd.ElemCount, pcmd.VtxOffset, pcmd.IdxOffset, total_area)
		Selectable(buf)
		if IsItemHovered() && fg_draw_list { DebugNodeDrawCmdShowMeshAndBoundingBox(fg_draw_list, draw_list, pcmd, true, false) }

		// Display individual triangles/vertices. Hover on to get the corresponding triangle highlighted.
		clipper : ImGuiListClipper
		Begin(&clipper, pcmd.ElemCount / 3); // Manually coarse clip our print out of individual vertices to save CPU, only items that may be visible.
		for Step(&clipper) { for prim, idx_i : i32 = clipper.DisplayStart, pcmd.IdxOffset + clipper.DisplayStart * 3; prim < clipper.DisplayEnd; post_incr(&prim) {
	buf_p : ^u8 = buf; buf_end : ^^u8 = buf + IM_ARRAYSIZE(buf)
	triangle : [3]ImVec2
	for n : i32 = 0; n < 3; n, idx_i = n + 1, idx_i + 1 {
		v : ^ImDrawVert = vtx_buffer[idx_buffer ? idx_buffer[idx_i] : idx_i]
		triangle[n] = v.pos
		buf_p += ImFormatString(buf_p, buf_end - buf_p, "%s %04d: pos (%8.2f,%8.2f), uv (%.6f,%.6f), col %08X\n", (n == 0) ? "Vert:" : "     ", idx_i, v.pos.x, v.pos.y, v.uv.x, v.uv.y, v.col)
	}

	Selectable(buf, false)
	if fg_draw_list && IsItemHovered() {
		backup_flags : ImDrawListFlags = fg_draw_list.Flags
		fg_draw_list.Flags &= !ImDrawListFlags_.ImDrawListFlags_AntiAliasedLines; // Disable AA on triangle outlines is more readable for very large and thin triangles.
		AddPolyline(fg_draw_list, triangle, 3, IM_COL32(255, 255, 0, 255), ImDrawFlags_.ImDrawFlags_Closed, 1.0)
		fg_draw_list.Flags = backup_flags
	}
} }

		TreePop()
	}

	TreePop()
}

// [DEBUG] Display mesh/aabb of a ImDrawCmd
DebugNodeDrawCmdShowMeshAndBoundingBox :: proc(out_draw_list : ^ImDrawList, draw_list : ^ImDrawList, draw_cmd : ^ImDrawCmd, show_mesh : bool, show_aabb : bool)
{
	IM_ASSERT(show_mesh || show_aabb)

	// Draw wire-frame version of all triangles
	clip_rect : ImRect = draw_cmd.ClipRect
	vtxs_rect : ImRect; init(&vtxs_rect, FLT_MAX, FLT_MAX, -FLT_MAX, -FLT_MAX)
	backup_flags : ImDrawListFlags = out_draw_list.Flags
	out_draw_list.Flags &= !ImDrawListFlags_.ImDrawListFlags_AntiAliasedLines; // Disable AA on triangle outlines is more readable for very large and thin triangles.
	for idx_n, idx_end : u32 = draw_cmd.IdxOffset, draw_cmd.IdxOffset + draw_cmd.ElemCount; idx_n < idx_end;  {
		idx_buffer : ^ImDrawIdx = (draw_list.IdxBuffer.Size > 0) ? draw_list.IdxBuffer.Data : nil; // We don't hold on those pointers past iterations as ->AddPolyline() may invalidate them if out_draw_list==draw_list
		vtx_buffer : ^ImDrawVert = draw_list.VtxBuffer.Data + draw_cmd.VtxOffset

		triangle : [3]ImVec2
		for n : i32 = 0; n < 3; n, idx_n = n + 1, idx_n + 1 {
			triangle[n] = vtx_buffer[idx_buffer ? idx_buffer[idx_n] : idx_n].pos
			Add(&vtxs_rect, triangle[n])
		}

		if show_mesh {
			// In yellow: mesh triangles
			AddPolyline(out_draw_list, triangle, 3, IM_COL32(255, 255, 0, 255), ImDrawFlags_.ImDrawFlags_Closed, 1.0)
		}
	}

	// Draw bounding boxes
	if show_aabb {
		AddRect(out_draw_list, ImTrunc(clip_rect.Min), ImTrunc(clip_rect.Max), IM_COL32(255, 0, 255, 255)); // In pink: clipping rectangle submitted to GPU
		AddRect(out_draw_list, ImTrunc(vtxs_rect.Min), ImTrunc(vtxs_rect.Max), IM_COL32(0, 255, 255, 255)); // In cyan: bounding box of triangles
	}
	out_draw_list.Flags = backup_flags
}

// [DEBUG] Display details for a single font, called by ShowStyleEditor().
DebugNodeFont :: proc(font : ^ImFont)
{
	opened : bool = TreeNode(font, "Font: \"%s\"\n%.2f px, %d glyphs, %d file(s)", font.ConfigData ? font.ConfigData[0].Name : "", font.FontSize, font.Glyphs.Size, font.ConfigDataCount)
	SameLine()
	if SmallButton("Set as default") { GetIO().FontDefault = font }
	if !opened { return }

	// Display preview text
	PushFont(font)
	Text("The quick brown fox jumps over the lazy dog")
	PopFont()

	// Display details
	SetNextItemWidth(GetFontSize() * 8)
	DragFloat("Font scale", &font.Scale, 0.005, 0.3, 2.0, "%.1f")
	SameLine(); MetricsHelpMarker("(Glimmer of hope: the atlas system will be rewritten in the future to make scaling more flexible.)")
	Text("Ascent: %f, Descent: %f, Height: %f", font.Ascent, font.Descent, font.Ascent - font.Descent)
	c_str : [5]u8
	Text("Fallback character: '%s' (U+%04X)", ImTextCharToUtf8(c_str, font.FallbackChar), font.FallbackChar)
	Text("Ellipsis character: '%s' (U+%04X)", ImTextCharToUtf8(c_str, font.EllipsisChar), font.EllipsisChar)
	surface_sqrt : i32 = cast(i32) ImSqrt(cast(f32) font.MetricsTotalSurface)
	Text("Texture Area: about %d px ~%dx%d px", font.MetricsTotalSurface, surface_sqrt, surface_sqrt)
	for config_i : i32 = 0; config_i < font.ConfigDataCount; post_incr(&config_i) { if font.ConfigData { if cfg : ^ImFontConfig = &font.ConfigData[config_i]; cfg { BulletText("Input %d: \'%s\', Oversample: (%d,%d), PixelSnapH: %d, Offset: (%.1f,%.1f)", config_i, cfg.Name, cfg.OversampleH, cfg.OversampleV, cfg.PixelSnapH, cfg.GlyphOffset.x, cfg.GlyphOffset.y) } } }

	// Display all glyphs of the fonts in separate pages of 256 characters
	if TreeNode("Glyphs", "Glyphs (%d)", font.Glyphs.Size) {
		draw_list : ^ImDrawList = GetWindowDrawList()
		glyph_col : ImU32 = GetColorU32(ImGuiCol_.ImGuiCol_Text)
		cell_size : f32 = font.FontSize * 1
		cell_spacing : f32 = GetStyle().ItemSpacing.y
		for base : u32 = 0; base <= IM_UNICODE_CODEPOINT_MAX; base += 256 {
			// Skip ahead if a large bunch of glyphs are not present in the font (test in chunks of 4k)
			// This is only a small optimization to reduce the number of iterations when IM_UNICODE_MAX_CODEPOINT
			// is large // (if ImWchar==ImWchar32 we will do at least about 272 queries here)
			if !(base & 4095) && IsGlyphRangeUnused(font, base, base + 4095) {
				base += 4096 - 256
				continue
			}

			count : i32 = 0
			for n : u32 = 0; n < 256; post_incr(&n) { if FindGlyphNoFallback(font, cast(ImWchar) (base + n)) { post_incr(&count) } }

			if count <= 0 { continue }
			if !TreeNode(cast(rawptr) cast(intptr_t) base, "U+%04X..U+%04X (%d %s)", base, base + 255, count, count > 1 ? "glyphs" : "glyph") { continue }

			// Draw a 16x16 grid of glyphs
			base_pos : ImVec2 = GetCursorScreenPos()
			for n : u32 = 0; n < 256; post_incr(&n) {
				// We use ImFont::RenderChar as a shortcut because we don't have UTF-8 conversion functions
				// available here and thus cannot easily generate a zero-terminated UTF-8 encoded string.
				cell_p1 : ImVec2; init(&cell_p1, base_pos.x + (n % 16) * (cell_size + cell_spacing), base_pos.y + (n / 16) * (cell_size + cell_spacing))
				cell_p2 : ImVec2; init(&cell_p2, cell_p1.x + cell_size, cell_p1.y + cell_size)
				glyph : ^ImFontGlyph = FindGlyphNoFallback(font, cast(ImWchar) (base + n))
				AddRect(draw_list, cell_p1, cell_p2, glyph ? IM_COL32(255, 255, 255, 100) : IM_COL32(255, 255, 255, 50))
				if !glyph { continue }
				RenderChar(font, draw_list, cell_size, cell_p1, glyph_col, cast(ImWchar) (base + n))
				if IsMouseHoveringRect(cell_p1, cell_p2) && BeginTooltip() {
					DebugNodeFontGlyph(font, glyph)
					EndTooltip()
				}
			}

			Dummy(ImVec2((cell_size + cell_spacing) * 16, (cell_size + cell_spacing) * 16))
			TreePop()
		}

		TreePop()
	}
	TreePop()
}

DebugNodeFontGlyph :: proc(_ : ^ImFont, glyph : ^ImFontGlyph)
{
	Text("Codepoint: U+%04X", glyph.Codepoint)
	Separator()
	Text("Visible: %d", glyph.Visible)
	Text("AdvanceX: %.1f", glyph.AdvanceX)
	Text("Pos: (%.2f,%.2f)->(%.2f,%.2f)", glyph.X0, glyph.Y0, glyph.X1, glyph.Y1)
	Text("UV: (%.3f,%.3f)->(%.3f,%.3f)", glyph.U0, glyph.V0, glyph.U1, glyph.V1)
}

// [DEBUG] Display contents of ImGuiStorage
DebugNodeStorage :: proc(storage : ^ImGuiStorage, label : ^u8)
{
	if !TreeNode(label, "%s: %d entries, %d bytes", label, storage.Data.Size, size_in_bytes(&storage.Data)) { return }
	for p in storage.Data {
		BulletText("Key 0x%08X Value { i: %d }", p.key, p.val_i); // Important: we currently don't store a type, real value may not be integer.
		DebugLocateItemOnHover(p.key)
	}

	TreePop()
}

// [DEBUG] Display contents of ImGuiTabBar
DebugNodeTabBar :: proc(tab_bar : ^ImGuiTabBar, label : ^u8)
{
	// Standalone tab bars (not associated to docking/windows functionality) currently hold no discernible strings.
	buf : [256]u8
	p : ^u8 = buf
	buf_end : ^u8 = buf + IM_ARRAYSIZE(buf)
	is_active : bool = (tab_bar.PrevFrameVisible >= GetFrameCount() - 2)
	p += ImFormatString(p, buf_end - p, "%s 0x%08X (%d tabs)%s  {", label, tab_bar.ID, tab_bar.Tabs.Size, is_active ? "" : " *Inactive*")
	for tab_n : i32 = 0; tab_n < ImMin(tab_bar.Tabs.Size, 3); post_incr(&tab_n) {
		tab : ^ImGuiTabItem = &tab_bar.Tabs[tab_n]
		p += ImFormatString(p, buf_end - p, "%s'%s'", tab_n > 0 ? ", " : "", TabBarGetTabName(tab_bar, tab))
	}

	p += ImFormatString(p, buf_end - p, (tab_bar.Tabs.Size > 3) ? " ... }" : " } ")
	if !is_active { PushStyleColor(ImGuiCol_.ImGuiCol_Text, GetStyleColorVec4(ImGuiCol_.ImGuiCol_TextDisabled)) }
	open : bool = TreeNode(label, "%s", buf)
	if !is_active { PopStyleColor() }
	if is_active && IsItemHovered() {
		draw_list : ^ImDrawList = GetForegroundDrawList()
		AddRect(draw_list, tab_bar.BarRect.Min, tab_bar.BarRect.Max, IM_COL32(255, 255, 0, 255))
		AddLine(draw_list, ImVec2(tab_bar.ScrollingRectMinX, tab_bar.BarRect.Min.y), ImVec2(tab_bar.ScrollingRectMinX, tab_bar.BarRect.Max.y), IM_COL32(0, 255, 0, 255))
		AddLine(draw_list, ImVec2(tab_bar.ScrollingRectMaxX, tab_bar.BarRect.Min.y), ImVec2(tab_bar.ScrollingRectMaxX, tab_bar.BarRect.Max.y), IM_COL32(0, 255, 0, 255))
	}
	if open {
		for tab_n : i32 = 0; tab_n < tab_bar.Tabs.Size; post_incr(&tab_n) {
			tab : ^ImGuiTabItem = &tab_bar.Tabs[tab_n]
			PushID(tab)
			if SmallButton("<") { TabBarQueueReorder(tab_bar, tab, -1) }; SameLine(0, 2)
			if SmallButton(">") { TabBarQueueReorder(tab_bar, tab, +1) }; SameLine()
			Text("%02d%c Tab 0x%08X '%s' Offset: %.2f, Width: %.2f/%.2f", tab_n, (tab.ID == tab_bar.SelectedTabId) ? '*' : ' ', tab.ID, TabBarGetTabName(tab_bar, tab), tab.Offset, tab.Width, tab.ContentWidth)
			PopID()
		}

		TreePop()
	}
}

DebugNodeViewport :: proc(viewport : ^ImGuiViewportP)
{
	g : ^ImGuiContext = GImGui^
	SetNextItemOpen(true, ImGuiCond_.ImGuiCond_Once)
	open : bool = TreeNode(cast(rawptr) cast(intptr_t) viewport.ID, "Viewport #%d, ID: 0x%08X, Parent: 0x%08X, Window: \"%s\"", viewport.Idx, viewport.ID, viewport.ParentViewportId, viewport.Window ? viewport.Window.Name : "N/A")
	if IsItemHovered() { g.DebugMetricsConfig.HighlightViewportID = viewport.ID }
	if open {
		flags : ImGuiWindowFlags = viewport.Flags
		BulletText("Main Pos: (%.0f,%.0f), Size: (%.0f,%.0f)\nWorkArea Inset Left: %.0f Top: %.0f, Right: %.0f, Bottom: %.0f\nMonitor: %d, DpiScale: %.0f%%", viewport.Pos.x, viewport.Pos.y, viewport.Size.x, viewport.Size.y, viewport.WorkInsetMin.x, viewport.WorkInsetMin.y, viewport.WorkInsetMax.x, viewport.WorkInsetMax.y, viewport.PlatformMonitor, viewport.DpiScale * 100.0)
		if viewport.Idx > 0 {SameLine(); if SmallButton("Reset Pos") {viewport.Pos = ImVec2(200, 200); UpdateWorkRect(viewport); if viewport.Window { viewport.Window.Pos = viewport.Pos }
			}
		}
		BulletText("Flags: 0x%04X =%s%s%s%s%s%s%s%s%s%s%s%s%s", viewport.Flags, (flags & ImGuiViewportFlags_.ImGuiViewportFlags_IsPlatformMonitor) ? " IsPlatformMonitor" : "", (flags & ImGuiViewportFlags_.ImGuiViewportFlags_IsMinimized) ? " IsMinimized" : "", (flags & ImGuiViewportFlags_.ImGuiViewportFlags_IsFocused) ? " IsFocused" : "", (flags & ImGuiViewportFlags_.ImGuiViewportFlags_OwnedByApp) ? " OwnedByApp" : "", (flags & ImGuiViewportFlags_.ImGuiViewportFlags_NoDecoration) ? " NoDecoration" : "", (flags & ImGuiViewportFlags_.ImGuiViewportFlags_NoTaskBarIcon) ? " NoTaskBarIcon" : "", (flags & ImGuiViewportFlags_.ImGuiViewportFlags_NoFocusOnAppearing) ? " NoFocusOnAppearing" : "", (flags & ImGuiViewportFlags_.ImGuiViewportFlags_NoFocusOnClick) ? " NoFocusOnClick" : "", (flags & ImGuiViewportFlags_.ImGuiViewportFlags_NoInputs) ? " NoInputs" : "", (flags & ImGuiViewportFlags_.ImGuiViewportFlags_NoRendererClear) ? " NoRendererClear" : "", (flags & ImGuiViewportFlags_.ImGuiViewportFlags_NoAutoMerge) ? " NoAutoMerge" : "", (flags & ImGuiViewportFlags_.ImGuiViewportFlags_TopMost) ? " TopMost" : "", (flags & ImGuiViewportFlags_.ImGuiViewportFlags_CanHostOtherWindows) ? " CanHostOtherWindows" : "")
		for draw_list in viewport.DrawDataP.CmdLists { DebugNodeDrawList(nil, viewport, draw_list, "DrawList") }

		TreePop()
	}
}

DebugNodePlatformMonitor :: proc(monitor : ^ImGuiPlatformMonitor, label : ^u8, idx : i32)
{
	BulletText("%s %d: DPI %.0f%%\n MainMin (%.0f,%.0f), MainMax (%.0f,%.0f), MainSize (%.0f,%.0f)\n WorkMin (%.0f,%.0f), WorkMax (%.0f,%.0f), WorkSize (%.0f,%.0f)", label, idx, monitor.DpiScale * 100.0, monitor.MainPos.x, monitor.MainPos.y, monitor.MainPos.x + monitor.MainSize.x, monitor.MainPos.y + monitor.MainSize.y, monitor.MainSize.x, monitor.MainSize.y, monitor.WorkPos.x, monitor.WorkPos.y, monitor.WorkPos.x + monitor.WorkSize.x, monitor.WorkPos.y + monitor.WorkSize.y, monitor.WorkSize.x, monitor.WorkSize.y)
}

DebugNodeWindow :: proc(window : ^ImGuiWindow, label : ^u8)
{
	if window == nil {
		BulletText("%s: NULL", label)
		return
	}

	g : ^ImGuiContext = GImGui^
	is_active : bool = window.WasActive
	tree_node_flags : ImGuiTreeNodeFlags = (window == g.NavWindow) ? ImGuiTreeNodeFlags_.ImGuiTreeNodeFlags_Selected : ImGuiTreeNodeFlags_.ImGuiTreeNodeFlags_None
	if !is_active { PushStyleColor(ImGuiCol_.ImGuiCol_Text, GetStyleColorVec4(ImGuiCol_.ImGuiCol_TextDisabled)) }
	open : bool = TreeNodeEx(label, tree_node_flags, "%s '%s'%s", label, window.Name, is_active ? "" : " *Inactive*")
	if !is_active { PopStyleColor() }
	if IsItemHovered() && is_active { AddRect(GetForegroundDrawList(window), window.Pos, window.Pos + window.Size, IM_COL32(255, 255, 0, 255)) }
	if !open { return }

	if window.MemoryCompacted { TextDisabled("Note: some memory buffers have been compacted/freed.") }

	if g.IO.ConfigDebugIsDebuggerPresent && DebugBreakButton("**DebugBreak**", "in Begin()") { g.DebugBreakInWindow = window.ID }

	flags : ImGuiWindowFlags = window.Flags
	DebugNodeDrawList(window, window.Viewport, window.DrawList, "DrawList")
	BulletText("Pos: (%.1f,%.1f), Size: (%.1f,%.1f), ContentSize (%.1f,%.1f) Ideal (%.1f,%.1f)", window.Pos.x, window.Pos.y, window.Size.x, window.Size.y, window.ContentSize.x, window.ContentSize.y, window.ContentSizeIdeal.x, window.ContentSizeIdeal.y)
	BulletText("Flags: 0x%08X (%s%s%s%s%s%s%s%s%s..)", flags, (flags & ImGuiWindowFlags_.ImGuiWindowFlags_ChildWindow) ? "Child " : "", (flags & ImGuiWindowFlags_.ImGuiWindowFlags_Tooltip) ? "Tooltip " : "", (flags & ImGuiWindowFlags_.ImGuiWindowFlags_Popup) ? "Popup " : "", (flags & ImGuiWindowFlags_.ImGuiWindowFlags_Modal) ? "Modal " : "", (flags & ImGuiWindowFlags_.ImGuiWindowFlags_ChildMenu) ? "ChildMenu " : "", (flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoSavedSettings) ? "NoSavedSettings " : "", (flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoMouseInputs) ? "NoMouseInputs" : "", (flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoNavInputs) ? "NoNavInputs" : "", (flags & ImGuiWindowFlags_.ImGuiWindowFlags_AlwaysAutoResize) ? "AlwaysAutoResize" : "")
	if ImGuiWindowFlags_ChildWindow : ^flags; ImGuiWindowFlags_ChildWindow { BulletText("ChildFlags: 0x%08X (%s%s%s%s..)", window.ChildFlags, (window.ChildFlags & ImGuiChildFlags_.ImGuiChildFlags_Borders) ? "Borders " : "", (window.ChildFlags & ImGuiChildFlags_.ImGuiChildFlags_ResizeX) ? "ResizeX " : "", (window.ChildFlags & ImGuiChildFlags_.ImGuiChildFlags_ResizeY) ? "ResizeY " : "", (window.ChildFlags & ImGuiChildFlags_.ImGuiChildFlags_NavFlattened) ? "NavFlattened " : "") }
	BulletText("WindowClassId: 0x%08X", window.WindowClass.ClassId)
	BulletText("Scroll: (%.2f/%.2f,%.2f/%.2f) Scrollbar:%s%s", window.Scroll.x, window.ScrollMax.x, window.Scroll.y, window.ScrollMax.y, window.ScrollbarX ? "X" : "", window.ScrollbarY ? "Y" : "")
	BulletText("Active: %d/%d, WriteAccessed: %d, BeginOrderWithinContext: %d", window.Active, window.WasActive, window.WriteAccessed, (window.Active || window.WasActive) ? window.BeginOrderWithinContext : -1)
	BulletText("Appearing: %d, Hidden: %d (CanSkip %d Cannot %d), SkipItems: %d", window.Appearing, window.Hidden, window.HiddenFramesCanSkipItems, window.HiddenFramesCannotSkipItems, window.SkipItems)
	for layer : i32 = 0; layer < ImGuiNavLayer.ImGuiNavLayer_COUNT; post_incr(&layer) {
		r : ImRect = window.NavRectRel[layer]
		if r.Min.x >= r.Max.x && r.Min.y >= r.Max.y { BulletText("NavLastIds[%d]: 0x%08X", layer, window.NavLastIds[layer]) }
		else { BulletText("NavLastIds[%d]: 0x%08X at +(%.1f,%.1f)(%.1f,%.1f)", layer, window.NavLastIds[layer], r.Min.x, r.Min.y, r.Max.x, r.Max.y) }
		DebugLocateItemOnHover(window.NavLastIds[layer])
	}

	pr : ^ImVec2 = window.NavPreferredScoringPosRel
	for layer : i32 = 0; layer < ImGuiNavLayer.ImGuiNavLayer_COUNT; post_incr(&layer) { BulletText("NavPreferredScoringPosRel[%d] = {%.1f,%.1f)", layer, (pr[layer].x == FLT_MAX ? -99999.0 : pr[layer].x), (pr[layer].y == FLT_MAX ? -99999.0 : pr[layer].y)) }; 

// Display as 99999.0f so it looks neater.
	BulletText("NavLayersActiveMask: %X, NavLastChildNavWindow: %s", window.DC.NavLayersActiveMask, window.NavLastChildNavWindow ? window.NavLastChildNavWindow.Name : "NULL")

	BulletText("Viewport: %d%s, ViewportId: 0x%08X, ViewportPos: (%.1f,%.1f)", window.Viewport ? window.Viewport.Idx : -1, window.ViewportOwned ? " (Owned)" : "", window.ViewportId, window.ViewportPos.x, window.ViewportPos.y)
	BulletText("ViewportMonitor: %d", window.Viewport ? window.Viewport.PlatformMonitor : -1)
	BulletText("DockId: 0x%04X, DockOrder: %d, Act: %d, Vis: %d", window.DockId, window.DockOrder, window.DockIsActive, window.DockTabIsVisible)
	if window.DockNode || window.DockNodeAsHost { DebugNodeDockNode(window.DockNodeAsHost ? window.DockNodeAsHost : window.DockNode, window.DockNodeAsHost ? "DockNodeAsHost" : "DockNode") }

	if window.RootWindow != window { DebugNodeWindow(window.RootWindow, "RootWindow") }
	if window.RootWindowDockTree != window.RootWindow { DebugNodeWindow(window.RootWindowDockTree, "RootWindowDockTree") }
	if window.ParentWindow != nil { DebugNodeWindow(window.ParentWindow, "ParentWindow") }
	if window.ParentWindowForFocusRoute != nil { DebugNodeWindow(window.ParentWindowForFocusRoute, "ParentWindowForFocusRoute") }
	if window.DC.ChildWindows.Size > 0 { DebugNodeWindowsList(&window.DC.ChildWindows, "ChildWindows") }
	if window.ColumnsStorage.Size > 0 && TreeNode("Columns", "Columns sets (%d)", window.ColumnsStorage.Size) {
		for columns in window.ColumnsStorage { DebugNodeColumns(&columns) }

		TreePop()
	}
	DebugNodeStorage(&window.StateStorage, "Storage")
	TreePop()
}

DebugNodeWindowSettings :: proc(settings : ^ImGuiWindowSettings)
{
	if settings.WantDelete { BeginDisabled() }
	Text("0x%08X \"%s\" Pos (%d,%d) Size (%d,%d) Collapsed=%d", settings.ID, GetName(settings), settings.Pos.x, settings.Pos.y, settings.Size.x, settings.Size.y, settings.Collapsed)
	if settings.WantDelete { EndDisabled() }
}

DebugNodeWindowsList :: proc(windows : ^ImVector(^ImGuiWindow), label : ^u8)
{
	if !TreeNode(label, "%s (%d)", label, windows.Size) { return }
	for i : i32 = windows.Size - 1; i >= 0; post_decr(&i) {
		PushID((windows^)[i])
		DebugNodeWindow((windows^)[i], "Window")
		PopID()
	}

	TreePop()
}

// FIXME-OPT: This is technically suboptimal, but it is simpler this way.
DebugNodeWindowsListByBeginStackParent :: proc(windows : ^^ImGuiWindow, windows_size : i32, parent_in_begin_stack : ^ImGuiWindow)
{
	for i : i32 = 0; i < windows_size; post_incr(&i) {
		window : ^ImGuiWindow = windows[i]
		if window.ParentWindowInBeginStack != parent_in_begin_stack { continue }
		buf : [20]u8
		ImFormatString(buf, IM_ARRAYSIZE(buf), "[%04d] Window", window.BeginOrderWithinContext)
		//BulletText("[%04d] Window '%s'", window->BeginOrderWithinContext, window->Name);
		DebugNodeWindow(window, buf)
		Indent()
		DebugNodeWindowsListByBeginStackParent(windows + i + 1, windows_size - i - 1, window)
		Unindent()
	}
}

// Call via IMGUI_DEBUG_LOG() for maximum stripping in caller code!
//-----------------------------------------------------------------------------
// [SECTION] DEBUG LOG WINDOW
//-----------------------------------------------------------------------------

DebugLog :: proc(fmt : ^u8, args : ..[]any)
{
	args : []any
	va_start(args, fmt)
	DebugLogV(fmt, args)
	va_end(args)
}

DebugLogV :: proc(fmt : ^u8, args : []any)
{
	g : ^ImGuiContext = GImGui^
	old_size : i32 = size(&g.DebugLogBuf)
	if g.ContextName[0] != 0 { appendf(&g.DebugLogBuf, "[%s] [%05d] ", g.ContextName, g.FrameCount) }
	else { appendf(&g.DebugLogBuf, "[%05d] ", g.FrameCount) }
	appendfv(&g.DebugLogBuf, fmt, args)
	append(&g.DebugLogIndex, c_str(&g.DebugLogBuf), old_size, size(&g.DebugLogBuf))
	if g.DebugLogFlags & ImGuiDebugLogFlags_.ImGuiDebugLogFlags_OutputToTTY { IMGUI_DEBUG_PRINTF("%s", begin(&g.DebugLogBuf) + old_size) }
	when IMGUI_ENABLE_TEST_ENGINE { // @gen ifdef
	// IMGUI_TEST_ENGINE_LOG() adds a trailing \n automatically
	new_size : i32 = size(&g.DebugLogBuf)
	trailing_carriage_return : bool = (g.DebugLogBuf[new_size - 1] == '\n')
	if g.DebugLogFlags & ImGuiDebugLogFlags_.ImGuiDebugLogFlags_OutputToTestEngine { IMGUI_TEST_ENGINE_LOG("%.*s", new_size - old_size - (trailing_carriage_return ? 1 : 0), begin(&g.DebugLogBuf) + old_size) }
	} // preproc endif
}

// FIXME-LAYOUT: To be done automatically via layout mode once we rework ItemSize/ItemAdd into ItemLayout.
SameLineOrWrap :: proc(size : ^ImVec2)
{
	g : ^ImGuiContext = GImGui^
	window : ^ImGuiWindow = g.CurrentWindow
	pos : ImVec2; init(&pos, window.DC.CursorPosPrevLine.x + g.Style.ItemSpacing.x, window.DC.CursorPosPrevLine.y)
	if Contains(&window.WorkRect, ImRect(pos, pos + size)) { SameLine() }
}

ShowDebugLogFlag :: proc(name : ^u8, flags : ImGuiDebugLogFlags)
{
	g : ^ImGuiContext = GImGui^
	size : ImVec2; init(&size, GetFrameHeight() + g.Style.ItemInnerSpacing.x + CalcTextSize(name).x, GetFrameHeight())
	SameLineOrWrap(size); // FIXME-LAYOUT: To be done automatically once we rework ItemSize/ItemAdd into ItemLayout.

	highlight_errors : bool = (flags == ImGuiDebugLogFlags_.ImGuiDebugLogFlags_EventError && g.DebugLogSkippedErrors > 0)
	if highlight_errors { PushStyleColor(ImGuiCol_.ImGuiCol_Text, ImLerp(g.Style.Colors[ImGuiCol_.ImGuiCol_Text], ImVec4(1.0, 0.0, 0.0, 1.0), 0.30)) }
	if CheckboxFlags(name, &g.DebugLogFlags, flags) && g.IO.KeyShift && (g.DebugLogFlags & flags) != 0 {
		g.DebugLogAutoDisableFrames = 2
		g.DebugLogAutoDisableFlags |= flags
	}
	if highlight_errors {
		PopStyleColor()
		SetItemTooltip("%d past errors skipped.", g.DebugLogSkippedErrors)
	}
	else {
		SetItemTooltip("Hold SHIFT when clicking to enable for 2 frames only (useful for spammy log entries)")
	}
}

// create Debug Log window. display a simplified log of important dear imgui events.
ShowDebugLogWindow :: proc(p_open : ^bool)
{
	g : ^ImGuiContext = GImGui^
	if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_.ImGuiNextWindowDataFlags_HasSize) == 0 { SetNextWindowSize(ImVec2(0.0, GetFontSize() * 12.0), ImGuiCond_.ImGuiCond_FirstUseEver) }
	if !Begin("Dear ImGui Debug Log", p_open) || GetCurrentWindow().BeginCount > 1 {
		End()
		return
	}

	all_enable_flags : ImGuiDebugLogFlags = ImGuiDebugLogFlags_.ImGuiDebugLogFlags_EventMask_ & !ImGuiDebugLogFlags_.ImGuiDebugLogFlags_EventInputRouting
	CheckboxFlags("All", &g.DebugLogFlags, all_enable_flags)
	SetItemTooltip("(except InputRouting which is spammy)")

	ShowDebugLogFlag("Errors", ImGuiDebugLogFlags_.ImGuiDebugLogFlags_EventError)
	ShowDebugLogFlag("ActiveId", ImGuiDebugLogFlags_.ImGuiDebugLogFlags_EventActiveId)
	ShowDebugLogFlag("Clipper", ImGuiDebugLogFlags_.ImGuiDebugLogFlags_EventClipper)
	ShowDebugLogFlag("Docking", ImGuiDebugLogFlags_.ImGuiDebugLogFlags_EventDocking)
	ShowDebugLogFlag("Focus", ImGuiDebugLogFlags_.ImGuiDebugLogFlags_EventFocus)
	ShowDebugLogFlag("IO", ImGuiDebugLogFlags_.ImGuiDebugLogFlags_EventIO)
	//ShowDebugLogFlag("Font", ImGuiDebugLogFlags_EventFont);
	ShowDebugLogFlag("Nav", ImGuiDebugLogFlags_.ImGuiDebugLogFlags_EventNav)
	ShowDebugLogFlag("Popup", ImGuiDebugLogFlags_.ImGuiDebugLogFlags_EventPopup)
	ShowDebugLogFlag("Selection", ImGuiDebugLogFlags_.ImGuiDebugLogFlags_EventSelection)
	ShowDebugLogFlag("Viewport", ImGuiDebugLogFlags_.ImGuiDebugLogFlags_EventViewport)
	ShowDebugLogFlag("InputRouting", ImGuiDebugLogFlags_.ImGuiDebugLogFlags_EventInputRouting)

	if SmallButton("Clear") {
		clear(&g.DebugLogBuf)
		clear(&g.DebugLogIndex)
		g.DebugLogSkippedErrors = 0
	}
	SameLine()
	if SmallButton("Copy") { SetClipboardText(c_str(&g.DebugLogBuf)) }
	SameLine()
	if SmallButton("Configure Outputs..") { OpenPopup("Outputs") }
	if BeginPopup("Outputs") {
		CheckboxFlags("OutputToTTY", &g.DebugLogFlags, ImGuiDebugLogFlags_.ImGuiDebugLogFlags_OutputToTTY)
		when ! IMGUI_ENABLE_TEST_ENGINE { /* @gen ifndef */
		BeginDisabled()
		} // preproc endif
		CheckboxFlags("OutputToTestEngine", &g.DebugLogFlags, ImGuiDebugLogFlags_.ImGuiDebugLogFlags_OutputToTestEngine)
		when ! IMGUI_ENABLE_TEST_ENGINE { /* @gen ifndef */
		EndDisabled()
		} // preproc endif
		EndPopup()
	}

	BeginChild("##log", ImVec2(0.0, 0.0), ImGuiChildFlags_.ImGuiChildFlags_Borders, ImGuiWindowFlags_.ImGuiWindowFlags_AlwaysVerticalScrollbar | ImGuiWindowFlags_.ImGuiWindowFlags_AlwaysHorizontalScrollbar)

	backup_log_flags : ImGuiDebugLogFlags = g.DebugLogFlags
	g.DebugLogFlags &= !ImGuiDebugLogFlags_.ImGuiDebugLogFlags_EventClipper

	clipper : ImGuiListClipper
	Begin(&clipper, size(&g.DebugLogIndex))
	for Step(&clipper) { for line_no : i32 = clipper.DisplayStart; line_no < clipper.DisplayEnd; post_incr(&line_no) { DebugTextUnformattedWithLocateItem(get_line_begin(&g.DebugLogIndex, c_str(&g.DebugLogBuf), line_no), get_line_end(&g.DebugLogIndex, c_str(&g.DebugLogBuf), line_no)) } }

	g.DebugLogFlags = backup_log_flags
	if GetScrollY() >= GetScrollMaxY() { SetScrollHereY(1.0) }
	EndChild()

	End()
}

// Display line, search for 0xXXXXXXXX identifiers and call DebugLocateItemOnHover() when hovered.
DebugTextUnformattedWithLocateItem :: proc(line_begin : ^u8, line_end : ^u8)
{
	TextUnformatted(line_begin, line_end)
	if !IsItemHovered(ImGuiHoveredFlags_.ImGuiHoveredFlags_AllowWhenBlockedByPopup | ImGuiHoveredFlags_.ImGuiHoveredFlags_AllowWhenBlockedByActiveItem) { return }
	g : ^ImGuiContext = GImGui^
	text_rect : ImRect = g.LastItemData.Rect
	for p : ^u8 = line_begin; p <= line_end - 10; post_incr(&p) {
		id : ImGuiID = 0
		if p[0] != '0' || (p[1] != 'x' && p[1] != 'X') || sscanf(p + 2, "%X", &id) != 1 || ImCharIsXdigitA(p[10]) { continue }
		p0 : ImVec2 = CalcTextSize(line_begin, p)
		p1 : ImVec2 = CalcTextSize(p, p + 10)
		g.LastItemData.Rect = ImRect(text_rect.Min + ImVec2(p0.x, 0.0), text_rect.Min + ImVec2(p0.x + p1.x, p1.y))
		if IsMouseHoveringRect(g.LastItemData.Rect.Min, g.LastItemData.Rect.Max, true) { DebugLocateItemOnHover(id) }
		p += 10
	}
}

//-----------------------------------------------------------------------------
// [SECTION] OTHER DEBUG TOOLS (ITEM PICKER, ID STACK TOOL)
//-----------------------------------------------------------------------------

// Draw a small cross at current CursorPos in current window's DrawList
DebugDrawCursorPos :: proc(col : ImU32)
{
	g : ^ImGuiContext = GImGui^
	window : ^ImGuiWindow = g.CurrentWindow
	pos : ImVec2 = window.DC.CursorPos
	AddLine(window.DrawList, ImVec2(pos.x, pos.y - 3.0), ImVec2(pos.x, pos.y + 4.0), col, 1.0)
	AddLine(window.DrawList, ImVec2(pos.x - 3.0, pos.y), ImVec2(pos.x + 4.0, pos.y), col, 1.0)
}

// Draw a 10px wide rectangle around CurposPos.x using Line Y1/Y2 in current window's DrawList
DebugDrawLineExtents :: proc(col : ImU32)
{
	g : ^ImGuiContext = GImGui^
	window : ^ImGuiWindow = g.CurrentWindow
	curr_x : f32 = window.DC.CursorPos.x
	line_y1 : f32 = (window.DC.IsSameLine ? window.DC.CursorPosPrevLine.y : window.DC.CursorPos.y)
	line_y2 : f32 = line_y1 + (window.DC.IsSameLine ? window.DC.PrevLineSize.y : window.DC.CurrLineSize.y)
	AddLine(window.DrawList, ImVec2(curr_x - 5.0, line_y1), ImVec2(curr_x + 5.0, line_y1), col, 1.0)
	AddLine(window.DrawList, ImVec2(curr_x - 0.5, line_y1), ImVec2(curr_x - 0.5, line_y2), col, 1.0)
	AddLine(window.DrawList, ImVec2(curr_x - 5.0, line_y2), ImVec2(curr_x + 5.0, line_y2), col, 1.0)
}

// Draw last item rect in ForegroundDrawList (so it is always visible)
DebugDrawItemRect :: proc(col : ImU32)
{
	g : ^ImGuiContext = GImGui^
	window : ^ImGuiWindow = g.CurrentWindow
	AddRect(GetForegroundDrawList(window), g.LastItemData.Rect.Min, g.LastItemData.Rect.Max, col)
}

// [DEBUG] Locate item position/rectangle given an ID.
DEBUG_LOCATE_ITEM_COLOR : ImU32 = IM_COL32(0, 255, 0, 255); // Call sparingly: only 1 at the same time!
// Green

DebugLocateItem :: proc(target_id : ImGuiID)
{
	g : ^ImGuiContext = GImGui^
	g.DebugLocateId = target_id
	g.DebugLocateFrames = 2
	g.DebugBreakInLocateId = false
}

// Only call on reaction to a mouse Hover: because only 1 at the same time!
// FIXME: Doesn't work over through a modal window, because they clear HoveredWindow.
DebugLocateItemOnHover :: proc(target_id : ImGuiID)
{
	if target_id == 0 || !IsItemHovered(ImGuiHoveredFlags_.ImGuiHoveredFlags_AllowWhenBlockedByActiveItem | ImGuiHoveredFlags_.ImGuiHoveredFlags_AllowWhenBlockedByPopup) { return }
	g : ^ImGuiContext = GImGui^
	DebugLocateItem(target_id)
	AddRect(GetForegroundDrawList(g.CurrentWindow), g.LastItemData.Rect.Min - ImVec2(3.0, 3.0), g.LastItemData.Rect.Max + ImVec2(3.0, 3.0), DEBUG_LOCATE_ITEM_COLOR)

	// Can't easily use a context menu here because it will mess with focus, active id etc.
	if g.IO.ConfigDebugIsDebuggerPresent && g.MouseStationaryTimer > 1.0 {
		DebugBreakButtonTooltip(false, "in ItemAdd()")
		if IsKeyChordPressed(g.DebugBreakKeyChord) { g.DebugBreakInLocateId = true }
	}
}

DebugLocateItemResolveWithLastItem :: proc()
{
	g : ^ImGuiContext = GImGui^

	// [DEBUG] Debug break requested by user
	if g.DebugBreakInLocateId { IM_DEBUG_BREAK() }

	item_data : ImGuiLastItemData = g.LastItemData
	g.DebugLocateId = 0
	draw_list : ^ImDrawList = GetForegroundDrawList(g.CurrentWindow)
	r : ImRect = item_data.Rect
	Expand(&r, 3.0)
	p1 : ImVec2 = g.IO.MousePos
	p2 : ImVec2 = ImVec2((p1.x < r.Min.x) ? r.Min.x : (p1.x > r.Max.x) ? r.Max.x : p1.x, (p1.y < r.Min.y) ? r.Min.y : (p1.y > r.Max.y) ? r.Max.y : p1.y)
	AddRect(draw_list, r.Min, r.Max, DEBUG_LOCATE_ITEM_COLOR)
	AddLine(draw_list, p1, p2, DEBUG_LOCATE_ITEM_COLOR)
}

DebugStartItemPicker :: proc()
{
	g : ^ImGuiContext = GImGui^
	g.DebugItemPickerActive = true
}

// [DEBUG] Item picker tool - start with DebugStartItemPicker() - useful to visually select an item and break into its call-stack.
UpdateDebugToolItemPicker :: proc()
{
	g : ^ImGuiContext = GImGui^
	g.DebugItemPickerBreakId = 0
	if !g.DebugItemPickerActive { return }

	hovered_id : ImGuiID = g.HoveredIdPreviousFrame
	SetMouseCursor(ImGuiMouseCursor_.ImGuiMouseCursor_Hand)
	if IsKeyPressed(ImGuiKey.ImGuiKey_Escape) { g.DebugItemPickerActive = false }
	change_mapping : bool = g.IO.KeyMods == (ImGuiKey.ImGuiMod_Ctrl | ImGuiKey.ImGuiMod_Shift)
	if !change_mapping && IsMouseClicked(g.DebugItemPickerMouseButton) && hovered_id {
		g.DebugItemPickerBreakId = hovered_id
		g.DebugItemPickerActive = false
	}
	for mouse_button : i32 = 0; mouse_button < 3; post_incr(&mouse_button) { if change_mapping && IsMouseClicked(mouse_button) { g.DebugItemPickerMouseButton = cast(ImU8) mouse_button } }

	SetNextWindowBgAlpha(0.70)
	if !BeginTooltip() { return }
	Text("HoveredId: 0x%08X", hovered_id)
	Text("Press ESC to abort picking.")
	mouse_button_names : [^]^u8 = {"Left", "Right", "Middle"}
	if change_mapping { Text("Remap w/ Ctrl+Shift: click anywhere to select new mouse button.") }
	else { TextColored(GetStyleColorVec4(hovered_id ? ImGuiCol_.ImGuiCol_Text : ImGuiCol_.ImGuiCol_TextDisabled), "Click %s Button to break in debugger! (remap w/ Ctrl+Shift)", mouse_button_names[g.DebugItemPickerMouseButton]) }
	EndTooltip()
}

// [DEBUG] ID Stack Tool: update queries. Called by NewFrame()
UpdateDebugToolStackQueries :: proc()
{
	g : ^ImGuiContext = GImGui^
	tool : ^ImGuiIDStackTool = &g.DebugIDStackTool

	// Clear hook when id stack tool is not visible
	g.DebugHookIdInfo = 0
	if g.FrameCount != tool.LastActiveFrame + 1 { return }

	// Update queries. The steps are: -1: query Stack, >= 0: query each stack item
	// We can only perform 1 ID Info query every frame. This is designed so the GetID() tests are cheap and constant-time
	query_id : ImGuiID = g.HoveredIdPreviousFrame ? g.HoveredIdPreviousFrame : g.ActiveId
	if tool.QueryId != query_id {
		tool.QueryId = query_id
		tool.StackLevel = -1
		resize(&tool.Results, 0)
	}
	if query_id == 0 { return }

	// Advance to next stack level when we got our result, or after 2 frames (in case we never get a result)
	stack_level : i32 = tool.StackLevel
	if stack_level >= 0 && stack_level < tool.Results.Size { if tool.Results[stack_level].QuerySuccess || tool.Results[stack_level].QueryFrameCount > 2 { post_incr(&tool.StackLevel) } }

	// Update hook
	stack_level = tool.StackLevel
	if stack_level == -1 { g.DebugHookIdInfo = query_id }
	if stack_level >= 0 && stack_level < tool.Results.Size {
		g.DebugHookIdInfo = tool.Results[stack_level].ID
		post_incr(&tool.Results[stack_level].QueryFrameCount)
	}
}

// [DEBUG] ID Stack tool: hooks called by GetID() family functions
DebugHookIdInfo :: proc(id : ImGuiID, data_type : ImGuiDataType, data_id : rawptr, data_id_end : rawptr)
{
	g : ^ImGuiContext = GImGui^
	window : ^ImGuiWindow = g.CurrentWindow
	tool : ^ImGuiIDStackTool = &g.DebugIDStackTool

	// Step 0: stack query
	// This assumes that the ID was computed with the current ID stack, which tends to be the case for our widget.
	if tool.StackLevel == -1 {
		post_incr(&tool.StackLevel)
		resize(&tool.Results, window.IDStack.Size + 1, ImGuiStackLevelInfo())
		for n : i32 = 0; n < window.IDStack.Size + 1; post_incr(&n) { tool.Results[n].ID = (n < window.IDStack.Size) ? window.IDStack[n] : id }

		return
	}

	// Step 1+: query for individual level
	IM_ASSERT(tool.StackLevel >= 0)
	if tool.StackLevel != window.IDStack.Size { return }
	info : ^ImGuiStackLevelInfo = &tool.Results[tool.StackLevel]
	IM_ASSERT(info.ID == id && info.QueryFrameCount > 0)

	switch data_type {
		case ImGuiDataType_.ImGuiDataType_S32:
			ImFormatString(info.Desc, IM_ARRAYSIZE(info.Desc), "%d", cast(i32) cast(intptr_t) data_id)
			break

		case ImGuiDataType_.ImGuiDataType_String:
			ImFormatString(info.Desc, IM_ARRAYSIZE(info.Desc), "%.*s", data_id_end ? cast(i32) (cast(^u8) data_id_end - cast(^u8) data_id) : cast(i32) strlen(cast(^u8) data_id), cast(^u8) data_id)
			break

		case ImGuiDataTypePrivate_.ImGuiDataType_Pointer:
			ImFormatString(info.Desc, IM_ARRAYSIZE(info.Desc), "(void*)0x%p", data_id)
			break

		case ImGuiDataTypePrivate_.ImGuiDataType_ID:
			if info.Desc[0] != 0 {
				// PushOverrideID() is often used to avoid hashing twice, which would lead to 2 calls to DebugHookIdInfo(). We prioritize the first one.return
			}
			ImFormatString(info.Desc, IM_ARRAYSIZE(info.Desc), "0x%08X [override]", id)
			break

		case:
			IM_ASSERT(0)
	}
	info.QuerySuccess = true
	info.DataType = data_type
}

StackToolFormatLevelInfo :: proc(tool : ^ImGuiIDStackTool, n : i32, format_for_ui : bool, buf : ^u8, buf_size : uint) -> i32
{
	info : ^ImGuiStackLevelInfo = &tool.Results[n]
	window : ^ImGuiWindow = (info.Desc[0] == 0 && n == 0) ? FindWindowByID(info.ID) : nil
	if window {
		// Source: window name (because the root ID don't call GetID() and so doesn't get hooked)return ImFormatString(buf, buf_size, format_for_ui ? "\"%s\" [window]" : "%s", window.Name)
	}
	if info.QuerySuccess {
		// Source: GetID() hooks (prioritize over ItemInfo() because we frequently use patterns like: PushID(str), Button("") where they both have same id)return ImFormatString(buf, buf_size, (format_for_ui && info.DataType == ImGuiDataType_.ImGuiDataType_String) ? "\"%s\"" : "%s", info.Desc)
	}
	if tool.StackLevel < tool.Results.Size {
		// Only start using fallback below when all queries are done, so during queries we don't flickering ??? markers.return (buf^ = 0)
	}
	when IMGUI_ENABLE_TEST_ENGINE { // @gen ifdef
	if label : ^u8 = ImGuiTestEngine_FindItemDebugLabel(GImGui, info.ID); label {
		// Source: ImGuiTestEngine's ItemInfo()return ImFormatString(buf, buf_size, format_for_ui ? "??? \"%s\"" : "%s", label)
	}
	} // preproc endif
	return ImFormatString(buf, buf_size, "???")
}

// create Stack Tool window. hover items with mouse to query information about the source of their unique ID.
// ID Stack Tool: Display UI
ShowIDStackToolWindow :: proc(p_open : ^bool)
{
	g : ^ImGuiContext = GImGui
	if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_.ImGuiNextWindowDataFlags_HasSize) == 0 { SetNextWindowSize(ImVec2(0.0, GetFontSize() * 8.0), ImGuiCond_.ImGuiCond_FirstUseEver) }
	if !Begin("Dear ImGui ID Stack Tool", p_open) || GetCurrentWindow().BeginCount > 1 {
		End()
		return
	}

	// Display hovered/active status
	tool : ^ImGuiIDStackTool = &g.DebugIDStackTool
	hovered_id : ImGuiID = g.HoveredIdPreviousFrame
	active_id : ImGuiID = g.ActiveId
	when IMGUI_ENABLE_TEST_ENGINE { /* @gen ifdef */
	Text("HoveredId: 0x%08X (\"%s\"), ActiveId:  0x%08X (\"%s\")", hovered_id, hovered_id ? ImGuiTestEngine_FindItemDebugLabel(&g, hovered_id) : "", active_id, active_id ? ImGuiTestEngine_FindItemDebugLabel(&g, active_id) : "")
	} else { // preproc else
	Text("HoveredId: 0x%08X, ActiveId:  0x%08X", hovered_id, active_id)
	} // preproc endif
	SameLine()
	MetricsHelpMarker("Hover an item with the mouse to display elements of the ID Stack leading to the item's final ID.\nEach level of the stack correspond to a PushID() call.\nAll levels of the stack are hashed together to make the final ID of a widget (ID displayed at the bottom level of the stack).\nRead FAQ entry about the ID stack for details.")

	// CTRL+C to copy path
	time_since_copy : f32 = cast(f32) g.Time - tool.CopyToClipboardLastTime
	Checkbox("Ctrl+C: copy path to clipboard", &tool.CopyToClipboardOnCtrlC)
	SameLine()
	TextColored((time_since_copy >= 0.0 && time_since_copy < 0.75 && ImFmod(time_since_copy, 0.25) < 0.25 * 0.5) ? ImVec4(1., 1., 0.3, 1.) : ImVec4(), "*COPIED*")
	if tool.CopyToClipboardOnCtrlC && Shortcut(ImGuiKey.ImGuiMod_Ctrl | ImGuiKey.ImGuiKey_C, ImGuiInputFlags_.ImGuiInputFlags_RouteGlobal | ImGuiInputFlags_.ImGuiInputFlags_RouteOverFocused) {
		tool.CopyToClipboardLastTime = cast(f32) g.Time
		p : ^u8 = g.TempBuffer.Data
		p_end : ^u8 = p + g.TempBuffer.Size
		for stack_n : i32 = 0; stack_n < tool.Results.Size && p + 3 < p_end; post_incr(&stack_n) {
			post_incr(&p)^ = '/'
			level_desc : [256]u8
			StackToolFormatLevelInfo(tool, stack_n, false, level_desc, IM_ARRAYSIZE(level_desc))
			for n : i32 = 0; level_desc[n] && p + 2 < p_end; post_incr(&n) {
				if level_desc[n] == '/' { post_incr(&p)^ = '\\' }
				post_incr(&p)^ = level_desc[n]
			}
		}

		p^ = 0
		SetClipboardText(g.TempBuffer.Data)
	}

	// Display decorated stack
	tool.LastActiveFrame = g.FrameCount
	if tool.Results.Size > 0 && BeginTable("##table", 3, ImGuiTableFlags_.ImGuiTableFlags_Borders) {
		id_width : f32 = CalcTextSize("0xDDDDDDDD").x
		TableSetupColumn("Seed", ImGuiTableColumnFlags_.ImGuiTableColumnFlags_WidthFixed, id_width)
		TableSetupColumn("PushID", ImGuiTableColumnFlags_.ImGuiTableColumnFlags_WidthStretch)
		TableSetupColumn("Result", ImGuiTableColumnFlags_.ImGuiTableColumnFlags_WidthFixed, id_width)
		TableHeadersRow()
		for n : i32 = 0; n < tool.Results.Size; post_incr(&n) {
			info : ^ImGuiStackLevelInfo = &tool.Results[n]
			TableNextColumn()
			Text("0x%08X", (n > 0) ? tool.Results[n - 1].ID : 0)
			TableNextColumn()
			StackToolFormatLevelInfo(tool, n, true, g.TempBuffer.Data, g.TempBuffer.Size)
			TextUnformatted(g.TempBuffer.Data)
			TableNextColumn()
			Text("0x%08X", info.ID)
			if n == tool.Results.Size - 1 { TableSetBgColor(ImGuiTableBgTarget_.ImGuiTableBgTarget_CellBg, GetColorU32(ImGuiCol_.ImGuiCol_Header)) }
		}

		EndTable()
	}
	End()
}

} else { // preproc else

// create Metrics/Debugger window. display Dear ImGui internals: windows, draw commands, various internal state, etc.
ShowMetricsWindow :: proc(_ : ^bool) { }
ShowFontAtlas :: proc(_ : ^ImFontAtlas) { }
DebugNodeColumns :: proc(_ : ^ImGuiOldColumns) { }
DebugNodeDrawList :: proc(_ : ^ImGuiWindow, _ : ^ImGuiViewportP, _ : ^ImDrawList, _ : ^u8) { }
DebugNodeDrawCmdShowMeshAndBoundingBox :: proc(_ : ^ImDrawList, _ : ^ImDrawList, _ : ^ImDrawCmd, _ : bool, _ : bool) { }
DebugNodeFont :: proc(_ : ^ImFont) { }
DebugNodeStorage :: proc(_ : ^ImGuiStorage, _ : ^u8) { }
DebugNodeTabBar :: proc(_ : ^ImGuiTabBar, _ : ^u8) { }
DebugNodeWindow :: proc(_ : ^ImGuiWindow, _ : ^u8) { }
DebugNodeWindowSettings :: proc(_ : ^ImGuiWindowSettings) { }
DebugNodeWindowsList :: proc(_ : ^ImVector(^ImGuiWindow), _ : ^u8) { }
DebugNodeViewport :: proc(_ : ^ImGuiViewportP) { }

// create Debug Log window. display a simplified log of important dear imgui events.
ShowDebugLogWindow :: proc(_ : ^bool) { }
// create Stack Tool window. hover items with mouse to query information about the source of their unique ID.
ShowIDStackToolWindow :: proc(_ : ^bool) { }
DebugStartItemPicker :: proc() { }
DebugHookIdInfo :: proc(_ : ImGuiID, _ : ImGuiDataType, _ : rawptr, _ : rawptr) { }

} // preproc endif// #ifndef IMGUI_DISABLE_DEBUG_TOOLS

//-----------------------------------------------------------------------------
