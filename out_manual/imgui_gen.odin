package test

import win32 "core:sys/windows"
import win32imm "../win32/imm"
import win32shell "../win32/shell"
import "base:runtime"
import "base:intrinsics"
import "base:builtin"
import "core:math"
import "core:strconv"
import "core:os"
import "core:mem"
import "core:slice"
import "core:fmt"
import str "core:strings"
import simd_x86 "core:simd/x86"
import stbsp "vendor:stb/sprintf"
import stbtt "vendor:stb/truetype"
import stbrp "vendor:stb/rect_pack"

import fmt_ "core:fmt"

has_target_feature :: intrinsics.has_target_feature
type_elem_type :: intrinsics.type_elem_type

// dear imgui, v1.91.7 WIP
// (main code and documentation)

// Help:
// - See links below.
// - Call and read ImGui::ShowDemoWindow() in imgui_demo.cpp. All applications in examples/ are doing that.
// - Read top of imgui.cpp for more details, links and comments.

// Resources:
// - FAQ ........................ https://dearimgui.com/faq (in repository as docs/FAQ.md)
// - Homepage ................... https://github.com/ocornut/imgui
// - Releases & changelog ....... https://github.com/ocornut/imgui/releases
// - Gallery .................... https://github.com/ocornut/imgui/issues?q=label%3Agallery (please post your screenshots/video there!)
// - Wiki ....................... https://github.com/ocornut/imgui/wiki (lots of good stuff there)
//   - Getting Started            https://github.com/ocornut/imgui/wiki/Getting-Started (how to integrate in an existing app by adding ~25 lines of code)
//   - Third-party Extensions     https://github.com/ocornut/imgui/wiki/Useful-Extensions (ImPlot & many more)
//   - Bindings/Backends          https://github.com/ocornut/imgui/wiki/Bindings (language bindings, backends for various tech/engines)
//   - Glossary                   https://github.com/ocornut/imgui/wiki/Glossary
//   - Debug Tools                https://github.com/ocornut/imgui/wiki/Debug-Tools
//   - Software using Dear ImGui  https://github.com/ocornut/imgui/wiki/Software-using-dear-imgui
// - Issues & support ........... https://github.com/ocornut/imgui/issues
// - Test Engine & Automation ... https://github.com/ocornut/imgui_test_engine (test suite, test engine to automate your apps)

// For first-time users having issues compiling/linking/running/loading fonts:
// please post in https://github.com/ocornut/imgui/discussions if you cannot find a solution in resources above.
// Everything else should be asked in 'Issues'! We are building a database of cross-linked knowledge there.

// Copyright (c) 2014-2025 Omar Cornut
// Developed by Omar Cornut and every direct or indirect contributors to the GitHub.
// See LICENSE.txt for copyright and licensing details (standard MIT License).
// This library is free but needs your support to sustain development and maintenance.
// Businesses: you can support continued development via B2B invoiced technical support, maintenance and sponsoring contracts.
// PLEASE reach out at omar AT dearimgui DOT com. See https://github.com/ocornut/imgui/wiki/Funding
// Businesses: you can also purchase licenses for the Dear ImGui Automation/Test Engine.

// It is recommended that you don't modify imgui.cpp! It will become difficult for you to update the library.
// Note that 'ImGui::' being a namespace, you can add functions into the namespace from your own source files, without
// modifying imgui.h or imgui.cpp. You may include imgui_internal.h to access internal data structures, but it doesn't
// come with any guarantee of forward compatibility. Discussing your changes on the GitHub Issue Tracker may lead you
// to a better solution or official support for them.

/*

Index of this file:

DOCUMENTATION

- MISSION STATEMENT
- CONTROLS GUIDE
- PROGRAMMER GUIDE
  - READ FIRST
  - HOW TO UPDATE TO A NEWER VERSION OF DEAR IMGUI
  - GETTING STARTED WITH INTEGRATING DEAR IMGUI IN YOUR CODE/ENGINE
  - HOW A SIMPLE APPLICATION MAY LOOK LIKE
  - HOW A SIMPLE RENDERING FUNCTION MAY LOOK LIKE
- API BREAKING CHANGES (read me when you update!)
- FREQUENTLY ASKED QUESTIONS (FAQ)
  - Read all answers online: https://www.dearimgui.com/faq, or in docs/FAQ.md (with a Markdown viewer)

CODE
(search for "[SECTION]" in the code to find them)

// [SECTION] INCLUDES
// [SECTION] FORWARD DECLARATIONS
// [SECTION] CONTEXT AND MEMORY ALLOCATORS
// [SECTION] USER FACING STRUCTURES (ImGuiStyle, ImGuiIO, ImGuiPlatformIO)
// [SECTION] MISC HELPERS/UTILITIES (Geometry functions)
// [SECTION] MISC HELPERS/UTILITIES (String, Format, Hash functions)
// [SECTION] MISC HELPERS/UTILITIES (File functions)
// [SECTION] MISC HELPERS/UTILITIES (ImText* functions)
// [SECTION] MISC HELPERS/UTILITIES (Color functions)
// [SECTION] ImGuiStorage
// [SECTION] ImGuiTextFilter
// [SECTION] ImGuiTextBuffer, ImGuiTextIndex
// [SECTION] ImGuiListClipper
// [SECTION] STYLING
// [SECTION] RENDER HELPERS
// [SECTION] INITIALIZATION, SHUTDOWN
// [SECTION] MAIN CODE (most of the code! lots of stuff, needs tidying up!)
// [SECTION] ID STACK
// [SECTION] INPUTS
// [SECTION] ERROR CHECKING, STATE RECOVERY
// [SECTION] ITEM SUBMISSION
// [SECTION] LAYOUT
// [SECTION] SCROLLING
// [SECTION] TOOLTIPS
// [SECTION] POPUPS
// [SECTION] WINDOW FOCUS
// [SECTION] KEYBOARD/GAMEPAD NAVIGATION
// [SECTION] DRAG AND DROP
// [SECTION] LOGGING/CAPTURING
// [SECTION] SETTINGS
// [SECTION] LOCALIZATION
// [SECTION] VIEWPORTS, PLATFORM WINDOWS
// [SECTION] DOCKING
// [SECTION] PLATFORM DEPENDENT HELPERS
// [SECTION] METRICS/DEBUGGER WINDOW
// [SECTION] DEBUG LOG WINDOW
// [SECTION] OTHER DEBUG TOOLS (ITEM PICKER, ID STACK TOOL)

*/

//-----------------------------------------------------------------------------
// DOCUMENTATION
//-----------------------------------------------------------------------------

/*

 MISSION STATEMENT
 =================

 - Easy to use to create code-driven and data-driven tools.
 - Easy to use to create ad hoc short-lived tools and long-lived, more elaborate tools.
 - Easy to hack and improve.
 - Minimize setup and maintenance.
 - Minimize state storage on user side.
 - Minimize state synchronization.
 - Portable, minimize dependencies, run on target (consoles, phones, etc.).
 - Efficient runtime and memory consumption.

 Designed primarily for developers and content-creators, not the typical end-user!
 Some of the current weaknesses (which we aim to address in the future) includes:

 - Doesn't look fancy.
 - Limited layout features, intricate layouts are typically crafted in code.


 CONTROLS GUIDE
 ==============

 - MOUSE CONTROLS
   - Mouse wheel:                   Scroll vertically.
   - SHIFT+Mouse wheel:             Scroll horizontally.
   - Click [X]:                     Close a window, available when 'bool* p_open' is passed to ImGui::Begin().
   - Click ^, Double-Click title:   Collapse window.
   - Drag on corner/border:         Resize window (double-click to auto fit window to its contents).
   - Drag on any empty space:       Move window (unless io.ConfigWindowsMoveFromTitleBarOnly = true).
   - Left-click outside popup:      Close popup stack (right-click over underlying popup: Partially close popup stack).

 - TEXT EDITOR
   - Hold SHIFT or Drag Mouse:      Select text.
   - CTRL+Left/Right:               Word jump.
   - CTRL+Shift+Left/Right:         Select words.
   - CTRL+A or Double-Click:        Select All.
   - CTRL+X, CTRL+C, CTRL+V:        Use OS clipboard.
   - CTRL+Z, CTRL+Y:                Undo, Redo.
   - ESCAPE:                        Revert text to its original value.
   - On OSX, controls are automatically adjusted to match standard OSX text editing 2ts and behaviors.

 - KEYBOARD CONTROLS
   - Basic:
     - Tab, SHIFT+Tab               Cycle through text editable fields.
     - CTRL+Tab, CTRL+Shift+Tab     Cycle through windows.
     - CTRL+Click                   Input text into a Slider or Drag widget.
   - Extended features with `io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard`:
     - Tab, SHIFT+Tab:              Cycle through every items.
     - Arrow keys                   Move through items using directional navigation. Tweak value.
     - Arrow keys + Alt, Shift      Tweak slower, tweak faster (when using arrow keys).
     - Enter                        Activate item (prefer text input when possible).
     - Space                        Activate item (prefer tweaking with arrows when possible).
     - Escape                       Deactivate item, leave child window, close popup.
     - Page Up, Page Down           Previous page, next page.
     - Home, End                    Scroll to top, scroll to bottom.
     - Alt                          Toggle between scrolling layer and menu layer.
     - CTRL+Tab then Ctrl+Arrows    Move window. Hold SHIFT to resize instead of moving.
   - Output when ImGuiConfigFlags_NavEnableKeyboard set,
     - io.WantCaptureKeyboard flag is set when keyboard is claimed.
     - io.NavActive: true when a window is focused and it doesn't have the ImGuiWindowFlags_NoNavInputs flag set.
     - io.NavVisible: true when the navigation cursor is visible (usually goes to back false when mouse is used).

 - GAMEPAD CONTROLS
   - Enable with 'io.ConfigFlags |= ImGuiConfigFlags_NavEnableGamepad'.
   - Particularly useful to use Dear ImGui on a console system (e.g. PlayStation, Switch, Xbox) without a mouse!
   - Download controller mapping PNG/PSD at http://dearimgui.com/controls_sheets
   - Backend support: backend needs to:
      - Set 'io.BackendFlags |= ImGuiBackendFlags_HasGamepad' + call io.AddKeyEvent/AddKeyAnalogEvent() with ImGuiKey_Gamepad_XXX keys.
      - For analog values (0.0f to 1.0f), backend is responsible to handling a dead-zone and rescaling inputs accordingly.
        Backend code will probably need to transform your raw inputs (such as e.g. remapping your 0.2..0.9 raw input range to 0.0..1.0 imgui range, etc.).
   - If you need to share inputs between your game and the Dear ImGui interface, the easiest approach is to go all-or-nothing,
     with a buttons combo to toggle the target. Please reach out if you think the game vs navigation input sharing could be improved.

 - REMOTE INPUTS SHARING & MOUSE EMULATION
   - PS4/PS5 users: Consider emulating a mouse cursor with DualShock touch pad or a spare analog stick as a mouse-emulation fallback.
   - Consoles/Tablet/Phone users: Consider using a Synergy 1.x server (on your PC) + run examples/libs/synergy/uSynergy.c (on your console/tablet/phone app)
     in order to share your PC mouse/keyboard.
   - See https://github.com/ocornut/imgui/wiki/Useful-Extensions#remoting for other remoting solutions.
   - On a TV/console system where readability may be lower or mouse inputs may be awkward, you may want to set the io.ConfigNavMoveSetMousePos flag.
     Enabling io.ConfigNavMoveSetMousePos + ImGuiBackendFlags_HasSetMousePos instructs Dear ImGui to move your mouse cursor along with navigation movements.
     When enabled, the NewFrame() function may alter 'io.MousePos' and set 'io.WantSetMousePos' to notify you that it wants the mouse cursor to be moved.
     When that happens your backend NEEDS to move the OS or underlying mouse cursor on the next frame. Some of the backends in examples/ do that.
     (If you set the NavEnableSetMousePos flag but don't honor 'io.WantSetMousePos' properly, Dear ImGui will misbehave as it will see your mouse moving back & forth!)
     (In a setup when you may not have easy control over the mouse cursor, e.g. uSynergy.c doesn't expose moving remote mouse cursor, you may want
     to set a boolean to ignore your other external mouse positions until the external source is moved again.)


 PROGRAMMER GUIDE
 ================

 READ FIRST
 ----------
 - Remember to check the wonderful Wiki (https://github.com/ocornut/imgui/wiki)
 - Your code creates the UI every frame of your application loop, if your code doesn't run the UI is gone!
   The UI can be highly dynamic, there are no construction or destruction steps, less superfluous
   data retention on your side, less state duplication, less state synchronization, fewer bugs.
 - Call and read ImGui::ShowDemoWindow() for demo code demonstrating most features.
   Or browse https://pthom.github.io/imgui_manual_online/manual/imgui_manual.html for interactive web version.
 - The library is designed to be built from sources. Avoid pre-compiled binaries and packaged versions. See imconfig.h to configure your build.
 - Dear ImGui is an implementation of the IMGUI paradigm (immediate-mode graphical user interface, a term coined by Casey Muratori).
   You can learn about IMGUI principles at http://www.johno.se/book/imgui.html, http://mollyrocket.com/861 & more links in Wiki.
 - Dear ImGui is a "single pass" rasterizing implementation of the IMGUI paradigm, aimed at ease of use and high-performances.
   For every application frame, your UI code will be called only once. This is in contrast to e.g. Unity's implementation of an IMGUI,
   where the UI code is called multiple times ("multiple passes") from a single entry point. There are pros and cons to both approaches.
 - Our origin is on the top-left. In axis aligned bounding boxes, Min = top-left, Max = bottom-right.
 - Please make sure you have asserts enabled (IM_ASSERT redirects to assert() by default, but can be redirected).
   If you get an assert, read the messages and comments around the assert.
 - This codebase aims to be highly optimized:
   - A typical idle frame should never call malloc/free.
   - We rely on a maximum of constant-time or O(N) algorithms. Limiting searches/scans as much as possible.
   - We put particular energy in making sure performances are decent with typical "Debug" build settings as well.
     Which mean we tend to avoid over-relying on "zero-cost abstraction" as they aren't zero-cost at all.
 - This codebase aims to be both highly opinionated and highly flexible:
   - This code works because of the things it choose to solve or not solve.
   - C++: this is a pragmatic C-ish codebase: we don't use fancy C++ features, we don't include C++ headers,
     and ImGui:: is a namespace. We rarely use member functions (and when we did, I am mostly regretting it now).
     This is to increase compatibility, increase maintainability and facilitate use from other languages.
   - C++: ImVec2/ImVec4 do not expose math operators by default, because it is expected that you use your own math types.
     See FAQ "How can I use my own math types instead of ImVec2/ImVec4?" for details about setting up imconfig.h for that.
     We can can optionally export math operators for ImVec2/ImVec4 using IMGUI_DEFINE_MATH_OPERATORS, which we use internally.
   - C++: pay attention that ImVector<> manipulates plain-old-data and does not honor construction/destruction
     (so don't use ImVector in your code or at our own risk!).
   - Building: We don't use nor mandate a build system for the main library.
     This is in an effort to ensure that it works in the real world aka with any esoteric build setup.
     This is also because providing a build system for the main library would be of little-value.
     The build problems are almost never coming from the main library but from specific backends.


 HOW TO UPDATE TO A NEWER VERSION OF DEAR IMGUI
 ----------------------------------------------
 - Update submodule or copy/overwrite every file.
 - About imconfig.h:
   - You may modify your copy of imconfig.h, in this case don't overwrite it.
   - or you may locally branch to modify imconfig.h and merge/rebase latest.
   - or you may '#define IMGUI_USER_CONFIG "my_config_file.h"' globally from your build system to
     specify a custom path for your imconfig.h file and instead not have to modify the default one.

 - Overwrite all the sources files except for imconfig.h (if you have modified your copy of imconfig.h)
 - Or maintain your own branch where you have imconfig.h modified as a top-most commit which you can regularly rebase over "master".
 - You can also use '#define IMGUI_USER_CONFIG "my_config_file.h" to redirect configuration to your own file.
 - Read the "API BREAKING CHANGES" section (below). This is where we list occasional API breaking changes.
   If a function/type has been renamed / or marked obsolete, try to fix the name in your code before it is permanently removed
   from the public API. If you have a problem with a missing function/symbols, search for its name in the code, there will
   likely be a comment about it. Please report any issue to the GitHub page!
 - To find out usage of old API, you can add '#define IMGUI_DISABLE_OBSOLETE_FUNCTIONS' in your configuration file.
 - Try to keep your copy of Dear ImGui reasonably up to date!


 GETTING STARTED WITH INTEGRATING DEAR IMGUI IN YOUR CODE/ENGINE
 ---------------------------------------------------------------
 - See https://github.com/ocornut/imgui/wiki/Getting-Started.
 - Run and study the examples and demo in imgui_demo.cpp to get acquainted with the library.
 - In the majority of cases you should be able to use unmodified backends files available in the backends/ folder.
 - Add the Dear ImGui source files + selected backend source files to your projects or using your preferred build system.
   It is recommended you build and statically link the .cpp files as part of your project and NOT as a shared library (DLL).
 - You can later customize the imconfig.h file to tweak some compile-time behavior, such as integrating Dear ImGui types with your own maths types.
 - When using Dear ImGui, your programming IDE is your friend: follow the declaration of variables, functions and types to find comments about them.
 - Dear ImGui never touches or knows about your GPU state. The only function that knows about GPU is the draw function that you provide.
   Effectively it means you can create widgets at any time in your code, regardless of considerations of being in "update" vs "render"
   phases of your own application. All rendering information is stored into command-lists that you will retrieve after calling ImGui::Render().
 - Refer to the backends and demo applications in the examples/ folder for instruction on how to setup your code.
 - If you are running over a standard OS with a common graphics API, you should be able to use unmodified imgui_impl_*** files from the examples/ folder.


 HOW A SIMPLE APPLICATION MAY LOOK LIKE
 --------------------------------------
 EXHIBIT 1: USING THE EXAMPLE BACKENDS (= imgui_impl_XXX.cpp files from the backends/ folder).
 The sub-folders in examples/ contain examples applications following this structure.

     // Application init: create a dear imgui context, setup some options, load fonts
     ImGui::CreateContext();
     ImGuiIO& io = ImGui::GetIO();
     // TODO: Set optional io.ConfigFlags values, e.g. 'io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard' to enable keyboard controls.
     // TODO: Fill optional fields of the io structure later.
     // TODO: Load TTF/OTF fonts if you don't want to use the default font.

     // Initialize helper Platform and Renderer backends (here we are using imgui_impl_win32.cpp and imgui_impl_dx11.cpp)
     ImGui_ImplWin32_Init(hwnd);
     ImGui_ImplDX11_Init(g_pd3dDevice, g_pd3dDeviceContext);

     // Application main loop
     while (true)
     {
         // Feed inputs to dear imgui, start new frame
         ImGui_ImplDX11_NewFrame();
         ImGui_ImplWin32_NewFrame();
         ImGui::NewFrame();

         // Any application code here
         ImGui::Text("Hello, world!");

         // Render dear imgui into screen
         ImGui::Render();
         ImGui_ImplDX11_RenderDrawData(ImGui::GetDrawData());
         g_pSwapChain->Present(1, 0);
     }

     // Shutdown
     ImGui_ImplDX11_Shutdown();
     ImGui_ImplWin32_Shutdown();
     ImGui::DestroyContext();

 EXHIBIT 2: IMPLEMENTING CUSTOM BACKEND / CUSTOM ENGINE

     // Application init: create a dear imgui context, setup some options, load fonts
     ImGui::CreateContext();
     ImGuiIO& io = ImGui::GetIO();
     // TODO: Set optional io.ConfigFlags values, e.g. 'io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard' to enable keyboard controls.
     // TODO: Fill optional fields of the io structure later.
     // TODO: Load TTF/OTF fonts if you don't want to use the default font.

     // Build and load the texture atlas into a texture
     // (In the examples/ app this is usually done within the ImGui_ImplXXX_Init() function from one of the demo Renderer)
     int width, height;
     unsigned char* pixels = nullptr;
     io.Fonts->GetTexDataAsRGBA32(&pixels, &width, &height);

     // At this point you've got the texture data and you need to upload that to your graphic system:
     // After we have created the texture, store its pointer/identifier (_in whichever format your engine uses_) in 'io.Fonts->TexID'.
     // This will be passed back to your via the renderer. Basically ImTextureID == void*. Read FAQ for details about ImTextureID.
     MyTexture* texture = MyEngine::CreateTextureFromMemoryPixels(pixels, width, height, TEXTURE_TYPE_RGBA32)
     io.Fonts->SetTexID((void*)texture);

     // Application main loop
     while (true)
     {
        // Setup low-level inputs, e.g. on Win32: calling GetKeyboardState(), or write to those fields from your Windows message handlers, etc.
        // (In the examples/ app this is usually done within the ImGui_ImplXXX_NewFrame() function from one of the demo Platform Backends)
        io.DeltaTime = 1.0f/60.0f;              // set the time elapsed since the previous frame (in seconds)
        io.DisplaySize.x = 1920.0f;             // set the current display width
        io.DisplaySize.y = 1280.0f;             // set the current display height here
        io.AddMousePosEvent(mouse_x, mouse_y);  // update mouse position
        io.AddMouseButtonEvent(0, mouse_b[0]);  // update mouse button states
        io.AddMouseButtonEvent(1, mouse_b[1]);  // update mouse button states

        // Call NewFrame(), after this point you can use ImGui::* functions anytime
        // (So you want to try calling NewFrame() as early as you can in your main loop to be able to use Dear ImGui everywhere)
        ImGui::NewFrame();

        // Most of your application code here
        ImGui::Text("Hello, world!");
        MyGameUpdate(); // may use any Dear ImGui functions, e.g. ImGui::Begin("My window"); ImGui::Text("Hello, world!"); ImGui::End();
        MyGameRender(); // may use any Dear ImGui functions as well!

        // Render dear imgui, swap buffers
        // (You want to try calling EndFrame/Render as late as you can, to be able to use Dear ImGui in your own game rendering code)
        ImGui::EndFrame();
        ImGui::Render();
        ImDrawData* draw_data = ImGui::GetDrawData();
        MyImGuiRenderFunction(draw_data);
        SwapBuffers();
     }

     // Shutdown
     ImGui::DestroyContext();

 To decide whether to dispatch mouse/keyboard inputs to Dear ImGui to the rest of your application,
 you should read the 'io.WantCaptureMouse', 'io.WantCaptureKeyboard' and 'io.WantTextInput' flags!
 Please read the FAQ entry "How can I tell whether to dispatch mouse/keyboard to Dear ImGui or my application?" about this.


 HOW A SIMPLE RENDERING FUNCTION MAY LOOK LIKE
 ---------------------------------------------
 The backends in impl_impl_XXX.cpp files contain many working implementations of a rendering function.

    void MyImGuiRenderFunction(ImDrawData* draw_data)
    {
       // TODO: Setup render state: alpha-blending enabled, no face culling, no depth testing, scissor enabled
       // TODO: Setup texture sampling state: sample with bilinear filtering (NOT point/nearest filtering). Use 'io.Fonts->Flags |= ImFontAtlasFlags_NoBakedLines;' to allow point/nearest filtering.
       // TODO: Setup viewport covering draw_data->DisplayPos to draw_data->DisplayPos + draw_data->DisplaySize
       // TODO: Setup orthographic projection matrix cover draw_data->DisplayPos to draw_data->DisplayPos + draw_data->DisplaySize
       // TODO: Setup shader: vertex { float2 pos, float2 uv, u32 color }, fragment shader sample color from 1 texture, multiply by vertex color.
       ImVec2 clip_off = draw_data->DisplayPos;
       for (int n = 0; n < draw_data->CmdListsCount; n++)
       {
          const ImDrawList* cmd_list = draw_data->CmdLists[n];
          const ImDrawVert* vtx_buffer = cmd_list->VtxBuffer.Data;  // vertex buffer generated by Dear ImGui
          const ImDrawIdx* idx_buffer = cmd_list->IdxBuffer.Data;   // index buffer generated by Dear ImGui
          for (int cmd_i = 0; cmd_i < cmd_list->CmdBuffer.Size; cmd_i++)
          {
             const ImDrawCmd* pcmd = &cmd_list->CmdBuffer[cmd_i];
             if (pcmd->UserCallback)
             {
                 pcmd->UserCallback(cmd_list, pcmd);
             }
             else
             {
                 // Project scissor/clipping rectangles into framebuffer space
                 ImVec2 clip_min(pcmd->ClipRect.x - clip_off.x, pcmd->ClipRect.y - clip_off.y);
                 ImVec2 clip_max(pcmd->ClipRect.z - clip_off.x, pcmd->ClipRect.w - clip_off.y);
                 if (clip_max.x <= clip_min.x || clip_max.y <= clip_min.y)
                     continue;

                 // We are using scissoring to clip some objects. All low-level graphics API should support it.
                 // - If your engine doesn't support scissoring yet, you may ignore this at first. You will get some small glitches
                 //   (some elements visible outside their bounds) but you can fix that once everything else works!
                 // - Clipping coordinates are provided in imgui coordinates space:
                 //   - For a given viewport, draw_data->DisplayPos == viewport->Pos and draw_data->DisplaySize == viewport->Size
                 //   - In a single viewport application, draw_data->DisplayPos == (0,0) and draw_data->DisplaySize == io.DisplaySize, but always use GetMainViewport()->Pos/Size instead of hardcoding those values.
                 //   - In the interest of supporting multi-viewport applications (see 'docking' branch on github),
                 //     always subtract draw_data->DisplayPos from clipping bounds to convert them to your viewport space.
                 // - Note that pcmd->ClipRect contains Min+Max bounds. Some graphics API may use Min+Max, other may use Min+Size (size being Max-Min)
                 MyEngineSetScissor(clip_min.x, clip_min.y, clip_max.x, clip_max.y);

                 // The texture for the draw call is specified by pcmd->GetTexID().
                 // The vast majority of draw calls will use the Dear ImGui texture atlas, which value you have set yourself during initialization.
                 MyEngineBindTexture((MyTexture*)pcmd->GetTexID());

                 // Render 'pcmd->ElemCount/3' indexed triangles.
                 // By default the indices ImDrawIdx are 16-bit, you can change them to 32-bit in imconfig.h if your engine doesn't support 16-bit indices.
                 MyEngineDrawIndexedTriangles(pcmd->ElemCount, sizeof(ImDrawIdx) == 2 ? GL_UNSIGNED_SHORT : GL_UNSIGNED_INT, idx_buffer + pcmd->IdxOffset, vtx_buffer, pcmd->VtxOffset);
             }
          }
       }
    }


 API BREAKING CHANGES
 ====================

 Occasionally introducing changes that are breaking the API. We try to make the breakage minor and easy to fix.
 Below is a change-log of API breaking changes only. If you are using one of the functions listed, expect to have to fix some code.
 When you are not sure about an old symbol or function name, try using the Search/Find function of your IDE to look for comments or references in all imgui files.
 You can read releases logs https://github.com/ocornut/imgui/releases for more details.

(Docking/Viewport Branch)
 - 2024/XX/XX (1.XXXX) - when multi-viewports are enabled, all positions will be in your natural OS coordinates space. It means that:
                          - reference to hard-coded positions such as in SetNextWindowPos(ImVec2{0,0}) are probably not what you want anymore.
                            you may use GetMainViewport()->Pos to offset hard-coded positions, e.g. SetNextWindowPos(GetMainViewport()->Pos)
                          - likewise io.MousePos and GetMousePos() will use OS coordinates.
                            If you query mouse positions to interact with non-imgui coordinates you will need to offset them, e.g. subtract GetWindowViewport()->Pos.

 - 2024/11/27 (1.91.6) - changed CRC32 table from CRC32-adler to CRC32c polynomial in order to be compatible with the result of SSE 4.2 instructions.
                         As a result, old .ini data may be partially lost (docking and tables information particularly).
                         Because some users have crafted and storing .ini data as a way to workaround limitations of the docking API, we are providing a '#define IMGUI_USE_LEGACY_CRC32_ADLER' compile-time option to keep using old CRC32 tables if you cannot afford invalidating old .ini data.
 - 2024/11/06 (1.91.5) - commented/obsoleted out pre-1.87 IO system (equivalent to using IMGUI_DISABLE_OBSOLETE_KEYIO or IMGUI_DISABLE_OBSOLETE_FUNCTIONS before)
                            - io.KeyMap[] and io.KeysDown[] are removed (obsoleted February 2022).
                            - io.NavInputs[] and ImGuiNavInput are removed (obsoleted July 2022).
                            - pre-1.87 backends are not supported:
                               - backends need to call io.AddKeyEvent(), io.AddMouseEvent() instead of writing to io.KeysDown[], io.MouseDown[] fields.
                               - backends need to call io.AddKeyAnalogEvent() for gamepad values instead of writing to io.NavInputs[] fields.
                            - for more reference:
                              - read 1.87 and 1.88 part of this section or read Changelog for 1.87 and 1.88.
                              - read https://github.com/ocornut/imgui/issues/4921
                            - if you have trouble updating a very old codebase using legacy backend-specific key codes: consider updating to 1.91.4 first, then #define IMGUI_DISABLE_OBSOLETE_KEYIO, then update to latest.
                       - obsoleted ImGuiKey_COUNT (it is unusually error-prone/misleading since valid keys don't start at 0). probably use ImGuiKey_NamedKey_BEGIN/ImGuiKey_NamedKey_END?
                       - fonts: removed const qualifiers from most font functions in prevision for upcoming font improvements.
 - 2024/10/18 (1.91.4) - renamed ImGuiCol_NavHighlight to ImGuiCol_NavCursor (for consistency with newly exposed and reworked features). Kept inline redirection enum (will obsolete).
 - 2024/10/14 (1.91.4) - moved ImGuiConfigFlags_NavEnableSetMousePos to standalone io.ConfigNavMoveSetMousePos bool.
                         moved ImGuiConfigFlags_NavNoCaptureKeyboard to standalone io.ConfigNavCaptureKeyboard bool (note the inverted value!).
                         kept legacy names (will obsolete) + code that copies settings once the first time. Dynamically changing the old value won't work. Switch to using the new value!
 - 2024/10/10 (1.91.4) - the typedef for ImTextureID now defaults to ImU64 instead of void*. (#1641)
                         this removes the requirement to redefine it for backends which are e.g. storing descriptor sets or other 64-bits structures when building on 32-bits archs. It therefore simplify various building scripts/helpers.
                         you may have compile-time issues if you were casting to 'void*' instead of 'ImTextureID' when passing your types to functions taking ImTextureID values, e.g. ImGui::Image().
                         in doubt it is almost always better to do an intermediate intptr_t cast, since it allows casting any pointer/integer type without warning:
                            - May warn:    ImGui::Image((void*)MyTextureData, ...);
                            - May warn:    ImGui::Image((void*)(intptr_t)MyTextureData, ...);
                            - Won't warn:  ImGui::Image((ImTextureID)(intptr_t)MyTextureData), ...);
  -                      note that you can always define ImTextureID to be your own high-level structures (with dedicated constructors) if you like.
 - 2024/10/03 (1.91.3) - drags: treat v_min==v_max as a valid clamping range when != 0.0f. Zero is a still special value due to legacy reasons, unless using ImGuiSliderFlags_ClampZeroRange. (#7968, #3361, #76)
                       - drags: extended behavior of ImGuiSliderFlags_AlwaysClamp to include _ClampZeroRange. It considers v_min==v_max==0.0f as a valid clamping range (aka edits not allowed).
                         although unlikely, it you wish to only clamp on text input but want v_min==v_max==0.0f to mean unclamped drags, you can use _ClampOnInput instead of _AlwaysClamp. (#7968, #3361, #76)
 - 2024/09/10 (1.91.2) - internals: using multiple overlayed ButtonBehavior() with same ID will now have io.ConfigDebugHighlightIdConflicts=true feature emit a warning. (#8030)
                         it was one of the rare case where using same ID is legal. workarounds: (1) use single ButtonBehavior() call with multiple _MouseButton flags, or (2) surround the calls with PushItemFlag(ImGuiItemFlags_AllowDuplicateId, true); ... PopItemFlag()
 - 2024/08/23 (1.91.1) - renamed ImGuiChildFlags_Border to ImGuiChildFlags_Borders for consistency. kept inline redirection flag.
 - 2024/08/22 (1.91.1) - moved some functions from ImGuiIO to ImGuiPlatformIO structure:
                            - io.GetClipboardTextFn         -> platform_io.Platform_GetClipboardTextFn + changed 'void* user_data' to 'ImGuiContext* ctx'. Pull your user data from platform_io.ClipboardUserData.
                            - io.SetClipboardTextFn         -> platform_io.Platform_SetClipboardTextFn + same as above line.
                            - io.PlatformOpenInShellFn      -> platform_io.Platform_OpenInShellFn (#7660)
                            - io.PlatformSetImeDataFn       -> platform_io.Platform_SetImeDataFn
                            - io.PlatformLocaleDecimalPoint -> platform_io.Platform_LocaleDecimalPoint (#7389, #6719, #2278)
                            - access those via GetPlatformIO() instead of GetIO().
                         some were introduced very recently and often automatically setup by core library and backends, so for those we are exceptionally not maintaining a legacy redirection symbol.
                       - commented the old ImageButton() signature obsoleted in 1.89 (~August 2022). As a reminder:
                            - old ImageButton() before 1.89 used ImTextureId as item id (created issue with e.g. multiple buttons in same scope, transient texture id values, opaque computation of ID)
                            - new ImageButton() since 1.89 requires an explicit 'const char* str_id'
                            - old ImageButton() before 1.89 had frame_padding' override argument.
                            - new ImageButton() since 1.89 always use style.FramePadding, which you can freely override with PushStyleVar()/PopStyleVar().
 - 2024/07/25 (1.91.0) - obsoleted GetContentRegionMax(), GetWindowContentRegionMin() and GetWindowContentRegionMax(). (see #7838 on GitHub for more info)
                         you should never need those functions. you can do everything with GetCursorScreenPos() and GetContentRegionAvail() in a more simple way.
                            - instead of:  GetWindowContentRegionMax().x - GetCursorPos().x
                            - you can use: GetContentRegionAvail().x
                            - instead of:  GetWindowContentRegionMax().x + GetWindowPos().x
                            - you can use: GetCursorScreenPos().x + GetContentRegionAvail().x // when called from left edge of window
                            - instead of:  GetContentRegionMax()
                            - you can use: GetContentRegionAvail() + GetCursorScreenPos() - GetWindowPos() // right edge in local coordinates
                            - instead of:  GetWindowContentRegionMax().x - GetWindowContentRegionMin().x
                            - you can use: GetContentRegionAvail() // when called from left edge of window
 - 2024/07/15 (1.91.0) - renamed ImGuiSelectableFlags_DontClosePopups to ImGuiSelectableFlags_NoAutoClosePopups. (#1379, #1468, #2200, #4936, #5216, #7302, #7573)
                         (internals: also renamed ImGuiItemFlags_SelectableDontClosePopup into ImGuiItemFlags_AutoClosePopups with inverted behaviors)
 - 2024/07/15 (1.91.0) - obsoleted PushButtonRepeat()/PopButtonRepeat() in favor of using new PushItemFlag(ImGuiItemFlags_ButtonRepeat, ...)/PopItemFlag().
 - 2024/07/02 (1.91.0) - commented out obsolete ImGuiModFlags (renamed to ImGuiKeyChord in 1.89). (#4921, #456)
                       - commented out obsolete ImGuiModFlags_XXX values (renamed to ImGuiMod_XXX in 1.89). (#4921, #456)
                            - ImGuiModFlags_Ctrl -> ImGuiMod_Ctrl, ImGuiModFlags_Shift -> ImGuiMod_Shift etc.
 - 2024/07/02 (1.91.0) - IO, IME: renamed platform IME hook and added explicit context for consistency and future-proofness.
                            - old: io.SetPlatformImeDataFn(ImGuiViewport* viewport, ImGuiPlatformImeData* data);
                            - new: io.PlatformSetImeDataFn(ImGuiContext* ctx, ImGuiViewport* viewport, ImGuiPlatformImeData* data);
 - 2024/06/21 (1.90.9) - BeginChild: added ImGuiChildFlags_NavFlattened as a replacement for the window flag ImGuiWindowFlags_NavFlattened: the feature only ever made sense for BeginChild() anyhow.
                            - old: BeginChild("Name", size, 0, ImGuiWindowFlags_NavFlattened);
                            - new: BeginChild("Name", size, ImGuiChildFlags_NavFlattened, 0);
 - 2024/06/21 (1.90.9) - io: ClearInputKeys() (first exposed in 1.89.8) doesn't clear mouse data, newly added ClearInputMouse() does.
 - 2024/06/20 (1.90.9) - renamed ImGuiDragDropFlags_SourceAutoExpirePayload to ImGuiDragDropFlags_PayloadAutoExpire.
 - 2024/06/18 (1.90.9) - style: renamed ImGuiCol_TabActive -> ImGuiCol_TabSelected, ImGuiCol_TabUnfocused -> ImGuiCol_TabDimmed, ImGuiCol_TabUnfocusedActive -> ImGuiCol_TabDimmedSelected.
 - 2024/06/10 (1.90.9) - removed old nested structure: renaming ImGuiStorage::ImGuiStoragePair type to ImGuiStoragePair (simpler for many languages).
 - 2024/06/06 (1.90.8) - reordered ImGuiInputTextFlags values. This should not be breaking unless you are using generated headers that have values not matching the main library.
 - 2024/06/06 (1.90.8) - removed 'ImGuiButtonFlags_MouseButtonDefault_ = ImGuiButtonFlags_MouseButtonLeft', was mostly unused and misleading.
 - 2024/05/27 (1.90.7) - commented out obsolete symbols marked obsolete in 1.88 (May 2022):
                            - old: CaptureKeyboardFromApp(bool)
                            - new: SetNextFrameWantCaptureKeyboard(bool)
                            - old: CaptureMouseFromApp(bool)
                            - new: SetNextFrameWantCaptureMouse(bool)
 - 2024/05/22 (1.90.7) - inputs (internals): renamed ImGuiKeyOwner_None to ImGuiKeyOwner_NoOwner, to make use more explicit and reduce confusion with the default it is a non-zero value and cannot be the default value (never made public, but disclosing as I expect a few users caught on owner-aware inputs).
                       - inputs (internals): renamed ImGuiInputFlags_RouteGlobalLow -> ImGuiInputFlags_RouteGlobal, ImGuiInputFlags_RouteGlobal -> ImGuiInputFlags_RouteGlobalOverFocused, ImGuiInputFlags_RouteGlobalHigh -> ImGuiInputFlags_RouteGlobalHighest.
                       - inputs (internals): Shortcut(), SetShortcutRouting(): swapped last two parameters order in function signatures:
                            - old: Shortcut(ImGuiKeyChord key_chord, ImGuiID owner_id = 0, ImGuiInputFlags Flags = {});
                            - new: Shortcut(ImGuiKeyChord key_chord, ImGuiInputFlags Flags = {}, ImGuiID owner_id = 0);
                       - inputs (internals): owner-aware versions of IsKeyPressed(), IsKeyChordPressed(), IsMouseClicked(): swapped last two parameters order in function signatures.
                            - old: IsKeyPressed(ImGuiKey key, ImGuiID owner_id, ImGuiInputFlags Flags = {});
                            - new: IsKeyPressed(ImGuiKey key, ImGuiInputFlags flags, ImGuiID owner_id = 0);
                            - old: IsMouseClicked(ImGuiMouseButton button, ImGuiID owner_id, ImGuiInputFlags Flags = {});
                            - new: IsMouseClicked(ImGuiMouseButton button, ImGuiInputFlags flags, ImGuiID owner_id = 0);
                         for various reasons those changes makes sense. They are being made because making some of those API public.
                         only past users of imgui_internal.h with the extra parameters will be affected. Added asserts for valid flags in various functions to detect _some_ misuses, BUT NOT ALL.
 - 2024/05/21 (1.90.7) - docking: changed signature of DockSpaceOverViewport() to add explicit dockspace id if desired. pass 0 to use old behavior. (#7611)
                           - old: DockSpaceOverViewport(const ImGuiViewport* viewport = NULL, ImGuiDockNodeFlags Flags = {}, ...);
                           - new: DockSpaceOverViewport(ImGuiID dockspace_id = 0, const ImGuiViewport* viewport = NULL, ImGuiDockNodeFlags Flags = {}, ...);
 - 2024/05/16 (1.90.7) - inputs: on macOS X, Cmd and Ctrl keys are now automatically swapped by io.AddKeyEvent() as this naturally align with how macOS X uses those keys.
                           - it shouldn't really affect you unless you had custom shortcut swapping in place for macOS X apps.
                           - removed ImGuiMod_Shortcut which was previously dynamically remapping to Ctrl or Cmd/Super. It is now unnecessary to specific cross-platform idiomatic shortcuts. (#2343, #4084, #5923, #456)
 - 2024/05/14 (1.90.7) - backends: SDL_Renderer2 and SDL_Renderer3 backend now take a SDL_Renderer* in their RenderDrawData() functions.
 - 2024/04/18 (1.90.6) - TreeNode: Fixed a layout inconsistency when using an empty/hidden label followed by a SameLine() call. (#7505, #282)
                           - old: TreeNode("##Hidden"); SameLine(); Text("Hello");     // <-- This was actually incorrect! BUT appeared to look ok with the default style where ItemSpacing.x == FramePadding.x * 2 (it didn't look aligned otherwise).
                           - new: TreeNode("##Hidden"); SameLine(0, 0); Text("Hello"); // <-- This is correct for all styles values.
                         with the fix, IF you were successfully using TreeNode("")+SameLine(); you will now have extra spacing between your TreeNode and the following item.
                         You'll need to change the SameLine() call to SameLine(0,0) to remove this extraneous spacing. This seemed like the more sensible fix that's not making things less consistent.
                         (Note: when using this idiom you are likely to also use ImGuiTreeNodeFlags_SpanAvailWidth).
 - 2024/03/18 (1.90.5) - merged the radius_x/radius_y parameters in ImDrawList::AddEllipse(), AddEllipseFilled() and PathEllipticalArcTo() into a single ImVec2 parameter. Exceptionally, because those functions were added in 1.90, we are not adding inline redirection functions. The transition is easy and should affect few users. (#2743, #7417)
 - 2024/03/08 (1.90.5) - inputs: more formally obsoleted GetKeyIndex() when IMGUI_DISABLE_OBSOLETE_FUNCTIONS is set. It has been unnecessary and a no-op since 1.87 (it returns the same value as passed when used with a 1.87+ backend using io.AddKeyEvent() function). (#4921)
                           - IsKeyPressed(GetKeyIndex(ImGuiKey_XXX)) -> use IsKeyPressed(ImGuiKey_XXX)
 - 2024/01/15 (1.90.2) - commented out obsolete ImGuiIO::ImeWindowHandle marked obsolete in 1.87, favor of writing to 'void* ImGuiViewport::PlatformHandleRaw'.
 - 2023/12/19 (1.90.1) - commented out obsolete ImGuiKey_KeyPadEnter redirection to ImGuiKey_KeypadEnter.
 - 2023/11/06 (1.90.1) - removed CalcListClipping() marked obsolete in 1.86. Prefer using ImGuiListClipper which can return non-contiguous ranges.
 - 2023/11/05 (1.90.1) - imgui_freetype: commented out ImGuiFreeType::BuildFontAtlas() obsoleted in 1.81. prefer using #define IMGUI_ENABLE_FREETYPE or see commented code for manual calls.
 - 2023/11/05 (1.90.1) - internals,columns: commented out legacy ImGuiColumnsFlags_XXX symbols redirecting to ImGuiOldColumnsFlags_XXX, obsoleted from imgui_internal.h in 1.80.
 - 2023/11/09 (1.90.0) - removed IM_OFFSETOF() macro in favor of using offsetof() available in C++11. Kept redirection define (will obsolete).
 - 2023/11/07 (1.90.0) - removed BeginChildFrame()/EndChildFrame() in favor of using BeginChild() with the ImGuiChildFlags_FrameStyle flag. kept inline redirection function (will obsolete).
                         those functions were merely PushStyle/PopStyle helpers, the removal isn't so much motivated by needing to add the feature in BeginChild(), but by the necessity to avoid BeginChildFrame() signature mismatching BeginChild() signature and features.
 - 2023/11/02 (1.90.0) - BeginChild: upgraded 'bool border = true' parameter to 'ImGuiChildFlags flags' type, added ImGuiChildFlags_Border equivalent. As with our prior "bool-to-flags" API updates, the ImGuiChildFlags_Border value is guaranteed to be == true forever to ensure a smoother transition, meaning all existing calls will still work.
                           - old: BeginChild("Name", size, true)
                           - new: BeginChild("Name", size, ImGuiChildFlags_Border)
                           - old: BeginChild("Name", size, false)
                           - new: BeginChild("Name", size) or BeginChild("Name", 0) or BeginChild("Name", size, ImGuiChildFlags_None)
                         **AMEND FROM THE FUTURE: from 1.91.1, 'ImGuiChildFlags_Border' is called 'ImGuiChildFlags_Borders'**
 - 2023/11/02 (1.90.0) - BeginChild: added child-flag ImGuiChildFlags_AlwaysUseWindowPadding as a replacement for the window-flag ImGuiWindowFlags_AlwaysUseWindowPadding: the feature only ever made sense for BeginChild() anyhow.
                           - old: BeginChild("Name", size, 0, ImGuiWindowFlags_AlwaysUseWindowPadding);
                           - new: BeginChild("Name", size, ImGuiChildFlags_AlwaysUseWindowPadding, 0);
 - 2023/09/27 (1.90.0) - io: removed io.MetricsActiveAllocations introduced in 1.63. Same as 'g.DebugMemAllocCount - g.DebugMemFreeCount' (still displayed in Metrics, unlikely to be accessed by end-user).
 - 2023/09/26 (1.90.0) - debug tools: Renamed ShowStackToolWindow() ("Stack Tool") to ShowIDStackToolWindow() ("ID Stack Tool"), as earlier name was misleading. Kept inline redirection function. (#4631)
 - 2023/09/15 (1.90.0) - ListBox, Combo: changed signature of "name getter" callback in old one-liner ListBox()/Combo() apis. kept inline redirection function (will obsolete).
                           - old: bool Combo(const char* label, int* current_item, bool (*getter)(void* user_data, int idx, const char** out_text), ...)
                           - new: bool Combo(const char* label, int* current_item, const char* (*getter)(void* user_data, int idx), ...);
                           - old: bool ListBox(const char* label, int* current_item, bool (*getting)(void* user_data, int idx, const char** out_text), ...);
                           - new: bool ListBox(const char* label, int* current_item, const char* (*getter)(void* user_data, int idx), ...);
 - 2023/09/08 (1.90.0) - commented out obsolete redirecting functions:
                           - GetWindowContentRegionWidth()  -> use GetWindowContentRegionMax().x - GetWindowContentRegionMin().x. Consider that generally 'GetContentRegionAvail().x' is more useful.
                           - ImDrawCornerFlags_XXX          -> use ImDrawFlags_RoundCornersXXX flags. Read 1.82 Changelog for details + grep commented names in sources.
                       - commented out runtime support for hardcoded ~0 or 0x01..0x0F rounding flags values for AddRect()/AddRectFilled()/PathRect()/AddImageRounded() -> use ImDrawFlags_RoundCornersXXX flags. Read 1.82 Changelog for details
 - 2023/08/25 (1.89.9) - clipper: Renamed IncludeRangeByIndices() (also called ForceDisplayRangeByIndices() before 1.89.6) to IncludeItemsByIndex(). Kept inline redirection function. Sorry!
 - 2023/07/12 (1.89.8) - ImDrawData: CmdLists now owned, changed from ImDrawList** to ImVector<ImDrawList*>. Majority of users shouldn't be affected, but you cannot compare to NULL nor reassign manually anymore. Instead use AddDrawList(). (#6406, #4879, #1878)
 - 2023/06/28 (1.89.7) - overlapping items: obsoleted 'SetItemAllowOverlap()' (called after item) in favor of calling 'SetNextItemAllowOverlap()' (called before item). 'SetItemAllowOverlap()' didn't and couldn't work reliably since 1.89 (2022-11-15).
 - 2023/06/28 (1.89.7) - overlapping items: renamed 'ImGuiTreeNodeFlags_AllowItemOverlap' to 'ImGuiTreeNodeFlags_AllowOverlap', 'ImGuiSelectableFlags_AllowItemOverlap' to 'ImGuiSelectableFlags_AllowOverlap'. Kept redirecting enums (will obsolete).
 - 2023/06/28 (1.89.7) - overlapping items: IsItemHovered() now by default return false when querying an item using AllowOverlap mode which is being overlapped. Use ImGuiHoveredFlags_AllowWhenOverlappedByItem to revert to old behavior.
 - 2023/06/28 (1.89.7) - overlapping items: Selectable and TreeNode don't allow overlap when active so overlapping widgets won't appear as hovered. While this fixes a common small visual issue, it also means that calling IsItemHovered() after a non-reactive elements - e.g. Text() - overlapping an active one may fail if you don't use IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByActiveItem). (#6610)
 - 2023/06/20 (1.89.7) - moved io.HoverDelayShort/io.HoverDelayNormal to style.HoverDelayShort/style.HoverDelayNormal. As the fields were added in 1.89 and expected to be left unchanged by most users, or only tweaked once during app initialization, we are exceptionally accepting the breakage.
 - 2023/05/30 (1.89.6) - backends: renamed "imgui_impl_sdlrenderer.cpp" to "imgui_impl_sdlrenderer2.cpp" and "imgui_impl_sdlrenderer.h" to "imgui_impl_sdlrenderer2.h". This is in prevision for the future release of SDL3.
 - 2023/05/22 (1.89.6) - listbox: commented out obsolete/redirecting functions that were marked obsolete more than two years ago:
                           - ListBoxHeader()  -> use BeginListBox() (note how two variants of ListBoxHeader() existed. Check commented versions in imgui.h for reference)
                           - ListBoxFooter()  -> use EndListBox()
 - 2023/05/15 (1.89.6) - clipper: commented out obsolete redirection constructor 'ImGuiListClipper(int items_count, float items_height = -1.0f)' that was marked obsolete in 1.79. Use default constructor + clipper.Begin().
 - 2023/05/15 (1.89.6) - clipper: renamed ImGuiListClipper::ForceDisplayRangeByIndices() to ImGuiListClipper::IncludeRangeByIndices().
 - 2023/03/14 (1.89.4) - commented out redirecting enums/functions names that were marked obsolete two years ago:
                           - ImGuiSliderFlags_ClampOnInput        -> use ImGuiSliderFlags_AlwaysClamp
                           - ImGuiInputTextFlags_AlwaysInsertMode -> use ImGuiInputTextFlags_AlwaysOverwrite
                           - ImDrawList::AddBezierCurve()         -> use ImDrawList::AddBezierCubic()
                           - ImDrawList::PathBezierCurveTo()      -> use ImDrawList::PathBezierCubicCurveTo()
 - 2023/03/09 (1.89.4) - renamed PushAllowKeyboardFocus()/PopAllowKeyboardFocus() to PushTabStop()/PopTabStop(). Kept inline redirection functions (will obsolete).
 - 2023/03/09 (1.89.4) - tooltips: Added 'bool' return value to BeginTooltip() for API consistency. Please only submit contents and call EndTooltip() if BeginTooltip() returns true. In reality the function will _currently_ always return true, but further changes down the line may change this, best to clarify API sooner.
 - 2023/02/15 (1.89.4) - moved the optional "courtesy maths operators" implementation from imgui_internal.h in imgui.h.
                         Even though we encourage using your own maths types and operators by setting up IM_VEC2_CLASS_EXTRA,
                         it has been frequently requested by people to use our own. We had an opt-in define which was
                         previously fulfilled in imgui_internal.h. It is now fulfilled in imgui.h. (#6164)
                           - OK:     #define IMGUI_DEFINE_MATH_OPERATORS / #include "imgui.h" / #include "imgui_internal.h"
                           - Error:  #include "imgui.h" / #define IMGUI_DEFINE_MATH_OPERATORS / #include "imgui_internal.h"
 - 2023/02/07 (1.89.3) - backends: renamed "imgui_impl_sdl.cpp" to "imgui_impl_sdl2.cpp" and "imgui_impl_sdl.h" to "imgui_impl_sdl2.h". (#6146) This is in prevision for the future release of SDL3.
 - 2022/10/26 (1.89)   - commented out redirecting OpenPopupContextItem() which was briefly the name of OpenPopupOnItemClick() from 1.77 to 1.79.
 - 2022/10/12 (1.89)   - removed runtime patching of invalid "%f"/"%0.f" format strings for DragInt()/SliderInt(). This was obsoleted in 1.61 (May 2018). See 1.61 changelog for details.
 - 2022/09/26 (1.89)   - renamed and merged keyboard modifiers key enums and flags into a same set. Kept inline redirection enums (will obsolete).
                           - ImGuiKey_ModCtrl  and ImGuiModFlags_Ctrl  -> ImGuiMod_Ctrl
                           - ImGuiKey_ModShift and ImGuiModFlags_Shift -> ImGuiMod_Shift
                           - ImGuiKey_ModAlt   and ImGuiModFlags_Alt   -> ImGuiMod_Alt
                           - ImGuiKey_ModSuper and ImGuiModFlags_Super -> ImGuiMod_Super
                         the ImGuiKey_ModXXX were introduced in 1.87 and mostly used by backends.
                         the ImGuiModFlags_XXX have been exposed in imgui.h but not really used by any public api only by third-party extensions.
                         exceptionally commenting out the older ImGuiKeyModFlags_XXX names ahead of obsolescence schedule to reduce confusion and because they were not meant to be used anyway.
 - 2022/09/20 (1.89)   - ImGuiKey is now a typed enum, allowing ImGuiKey_XXX symbols to be named in debuggers.
                         this will require uses of legacy backend-dependent indices to be casted, e.g.
                            - with imgui_impl_glfw:  IsKeyPressed(GLFW_KEY_A) -> IsKeyPressed((ImGuiKey)GLFW_KEY_A);
                            - with imgui_impl_win32: IsKeyPressed('A')        -> IsKeyPressed((ImGuiKey)'A')
                            - etc. However if you are upgrading code you might well use the better, backend-agnostic IsKeyPressed(ImGuiKey_A) now!
 - 2022/09/12 (1.89) - removed the bizarre legacy default argument for 'TreePush(const void* ptr = NULL)', always pass a pointer value explicitly. NULL/nullptr is ok but require cast, e.g. TreePush((void*)nullptr);
 - 2022/09/05 (1.89) - commented out redirecting functions/enums names that were marked obsolete in 1.77 and 1.78 (June 2020):
                         - DragScalar(), DragScalarN(), DragFloat(), DragFloat2(), DragFloat3(), DragFloat4(): For old signatures ending with (..., const char* format, float power = 1.0f) -> use (..., format ImGuiSliderFlags_Logarithmic) if power != 1.0f.
                         - SliderScalar(), SliderScalarN(), SliderFloat(), SliderFloat2(), SliderFloat3(), SliderFloat4(): For old signatures ending with (..., const char* format, float power = 1.0f) -> use (..., format ImGuiSliderFlags_Logarithmic) if power != 1.0f.
                         - BeginPopupContextWindow(const char*, ImGuiMouseButton, bool) -> use BeginPopupContextWindow(const char*, ImGuiPopupFlags)
 - 2022/09/02 (1.89) - obsoleted using SetCursorPos()/SetCursorScreenPos() to extend parent window/cell boundaries.
                       this relates to when moving the cursor position beyond current boundaries WITHOUT submitting an item.
                         - previously this would make the window content size ~200x200:
                              Begin(...) + SetCursorScreenPos(GetCursorScreenPos() + ImVec2{200,200}) + End();
                         - instead, please submit an item:
                              Begin(...) + SetCursorScreenPos(GetCursorScreenPos() + ImVec2{200,200}) + Dummy(ImVec2{0,0}) + End();
                         - alternative:
                              Begin(...) + Dummy(ImVec2{200,200}) + End();
                         - content size is now only extended when submitting an item!
                         - with '#define IMGUI_DISABLE_OBSOLETE_FUNCTIONS' this will now be detected and assert.
                         - without '#define IMGUI_DISABLE_OBSOLETE_FUNCTIONS' this will silently be fixed until we obsolete it.
 - 2022/08/03 (1.89) - changed signature of ImageButton() function. Kept redirection function (will obsolete).
                        - added 'const char* str_id' parameter + removed 'int frame_padding = -1' parameter.
                        - old signature: bool ImageButton(ImTextureID tex_id, ImVec2 size, ImVec2 uv0 = ImVec2{0,0}, ImVec2 uv1 = ImVec2{1,1}, int frame_padding = -1, ImVec4 bg_col = ImVec4{0,0,0,0}, ImVec4 tint_col = ImVec4{1,1,1,1});
                          - used the ImTextureID value to create an ID. This was inconsistent with other functions, led to ID conflicts, and caused problems with engines using transient ImTextureID values.
                          - had a FramePadding override which was inconsistent with other functions and made the already-long signature even longer.
                        - new signature: bool ImageButton(const char* str_id, ImTextureID tex_id, ImVec2 size, ImVec2 uv0 = ImVec2{0,0}, ImVec2 uv1 = ImVec2{1,1}, ImVec4 bg_col = ImVec4{0,0,0,0}, ImVec4 tint_col = ImVec4{1,1,1,1});
                          - requires an explicit identifier. You may still use e.g. PushID() calls and then pass an empty identifier.
                          - always uses style.FramePadding for padding, to be consistent with other buttons. You may use PushStyleVar() to alter this.
 - 2022/07/08 (1.89) - inputs: removed io.NavInputs[] and ImGuiNavInput enum (following 1.87 changes).
                        - Official backends from 1.87+                  -> no issue.
                        - Official backends from 1.60 to 1.86           -> will build and convert gamepad inputs, unless IMGUI_DISABLE_OBSOLETE_KEYIO is defined. Need updating!
                        - Custom backends not writing to io.NavInputs[] -> no issue.
                        - Custom backends writing to io.NavInputs[]     -> will build and convert gamepad inputs, unless IMGUI_DISABLE_OBSOLETE_KEYIO is defined. Need fixing!
                        - TL;DR: Backends should call io.AddKeyEvent()/io.AddKeyAnalogEvent() with ImGuiKey_GamepadXXX values instead of filling io.NavInput[].
 - 2022/06/15 (1.88) - renamed IMGUI_DISABLE_METRICS_WINDOW to IMGUI_DISABLE_DEBUG_TOOLS for correctness. kept support for old define (will obsolete).
 - 2022/05/03 (1.88) - backends: osx: removed ImGui_ImplOSX_HandleEvent() from backend API in favor of backend automatically handling event capture. All ImGui_ImplOSX_HandleEvent() calls should be removed as they are now unnecessary.
 - 2022/04/05 (1.88) - inputs: renamed ImGuiKeyModFlags to ImGuiModFlags. Kept inline redirection enums (will obsolete). This was never used in public API functions but technically present in imgui.h and ImGuiIO.
 - 2022/01/20 (1.87) - inputs: reworded gamepad IO.
                        - Backend writing to io.NavInputs[]            -> backend should call io.AddKeyEvent()/io.AddKeyAnalogEvent() with ImGuiKey_GamepadXXX values.
 - 2022/01/19 (1.87) - sliders, drags: removed support for legacy arithmetic operators (+,+-,*,/) when inputing text. This doesn't break any api/code but a feature that used to be accessible by end-users (which seemingly no one used).
 - 2022/01/17 (1.87) - inputs: reworked mouse IO.
                        - Backend writing to io.MousePos               -> backend should call io.AddMousePosEvent()
                        - Backend writing to io.MouseDown[]            -> backend should call io.AddMouseButtonEvent()
                        - Backend writing to io.MouseWheel             -> backend should call io.AddMouseWheelEvent()
                        - Backend writing to io.MouseHoveredViewport   -> backend should call io.AddMouseViewportEvent() [Docking branch w/ multi-viewports only]
                       note: for all calls to IO new functions, the Dear ImGui context should be bound/current.
                       read https://github.com/ocornut/imgui/issues/4921 for details.
 - 2022/01/10 (1.87) - inputs: reworked keyboard IO. Removed io.KeyMap[], io.KeysDown[] in favor of calling io.AddKeyEvent(). Removed GetKeyIndex(), now unnecessary. All IsKeyXXX() functions now take ImGuiKey values. All features are still functional until IMGUI_DISABLE_OBSOLETE_KEYIO is defined. Read Changelog and Release Notes for details.
                        - IsKeyPressed(MY_NATIVE_KEY_XXX)              -> use IsKeyPressed(ImGuiKey_XXX)
                        - IsKeyPressed(GetKeyIndex(ImGuiKey_XXX))      -> use IsKeyPressed(ImGuiKey_XXX)
                        - Backend writing to io.KeyMap[],io.KeysDown[] -> backend should call io.AddKeyEvent() (+ call io.SetKeyEventNativeData() if you want legacy user code to stil function with legacy key codes).
                        - Backend writing to io.KeyCtrl, io.KeyShift.. -> backend should call io.AddKeyEvent() with ImGuiMod_XXX values. *IF YOU PULLED CODE BETWEEN 2021/01/10 and 2021/01/27: We used to have a io.AddKeyModsEvent() function which was now replaced by io.AddKeyEvent() with ImGuiMod_XXX values.*
                     - one case won't work with backward compatibility: if your custom backend used ImGuiKey as mock native indices (e.g. "io.KeyMap[ImGuiKey_A] = ImGuiKey_A") because those values are now larger than the legacy KeyDown[] array. Will assert.
                     - inputs: added ImGuiKey_ModCtrl/ImGuiKey_ModShift/ImGuiKey_ModAlt/ImGuiKey_ModSuper values to submit keyboard modifiers using io.AddKeyEvent(), instead of writing directly to io.KeyCtrl, io.KeyShift, io.KeyAlt, io.KeySuper.
 - 2022/01/05 (1.87) - inputs: renamed ImGuiKey_KeyPadEnter to ImGuiKey_KeypadEnter to align with new symbols. Kept redirection enum.
 - 2022/01/05 (1.87) - removed io.ImeSetInputScreenPosFn() in favor of more flexible io.SetPlatformImeDataFn(). Removed 'void* io.ImeWindowHandle' in favor of writing to 'void* ImGuiViewport::PlatformHandleRaw'.
 - 2022/01/01 (1.87) - commented out redirecting functions/enums names that were marked obsolete in 1.69, 1.70, 1.71, 1.72 (March-July 2019)
                        - ImGui::SetNextTreeNodeOpen()        -> use ImGui::SetNextItemOpen()
                        - ImGui::GetContentRegionAvailWidth() -> use ImGui::GetContentRegionAvail().x
                        - ImGui::TreeAdvanceToLabelPos()      -> use ImGui::SetCursorPosX(ImGui::GetCursorPosX() + ImGui::GetTreeNodeToLabelSpacing());
                        - ImFontAtlas::CustomRect             -> use ImFontAtlasCustomRect
                        - ImGuiColorEditFlags_RGB/HSV/HEX     -> use ImGuiColorEditFlags_DisplayRGB/HSV/Hex
 - 2021/12/20 (1.86) - backends: removed obsolete Marmalade backend (imgui_impl_marmalade.cpp) + example. Find last supported version at https://github.com/ocornut/imgui/wiki/Bindings
 - 2021/11/04 (1.86) - removed CalcListClipping() function. Prefer using ImGuiListClipper which can return non-contiguous ranges. Please open an issue if you think you really need this function.
 - 2021/08/23 (1.85) - removed GetWindowContentRegionWidth() function. keep inline redirection helper. can use 'GetWindowContentRegionMax().x - GetWindowContentRegionMin().x' instead for generally 'GetContentRegionAvail().x' is more useful.
 - 2021/07/26 (1.84) - commented out redirecting functions/enums names that were marked obsolete in 1.67 and 1.69 (March 2019):
                        - ImGui::GetOverlayDrawList() -> use ImGui::GetForegroundDrawList()
                        - ImFont::GlyphRangesBuilder  -> use ImFontGlyphRangesBuilder
 - 2021/05/19 (1.83) - backends: obsoleted direct access to ImDrawCmd::TextureId in favor of calling ImDrawCmd::GetTexID().
                        - if you are using official backends from the source tree: you have nothing to do.
                        - if you have copied old backend code or using your own: change access to draw_cmd->TextureId to draw_cmd->GetTexID().
 - 2021/03/12 (1.82) - upgraded ImDrawList::AddRect(), AddRectFilled(), PathRect() to use ImDrawFlags instead of ImDrawCornersFlags.
                        - ImDrawCornerFlags_TopLeft  -> use ImDrawFlags_RoundCornersTopLeft
                        - ImDrawCornerFlags_BotRight -> use ImDrawFlags_RoundCornersBottomRight
                        - ImDrawCornerFlags_None     -> use ImDrawFlags_RoundCornersNone etc.
                       flags now sanely defaults to 0 instead of 0x0F, consistent with all other flags in the API.
                       breaking: the default with rounding > 0.0f is now "round all corners" vs old implicit "round no corners":
                        - rounding == 0.0f + flags == 0 --> meant no rounding  --> unchanged (common use)
                        - rounding  > 0.0f + flags != 0 --> meant rounding     --> unchanged (common use)
                        - rounding == 0.0f + flags != 0 --> meant no rounding  --> unchanged (unlikely use)
                        - rounding  > 0.0f + flags == 0 --> meant no rounding  --> BREAKING (unlikely use): will now round all corners --> use ImDrawFlags_RoundCornersNone or rounding == 0.0f.
                       this ONLY matters for hard coded use of 0 + rounding > 0.0f. Use of named ImDrawFlags_RoundCornersNone (new) or ImDrawCornerFlags_None (old) are ok.
                       the old ImDrawCornersFlags used awkward default values of ~0 or 0xF (4 lower bits set) to signify "round all corners" and we sometimes encouraged using them as shortcuts.
                       legacy path still support use of hard coded ~0 or any value from 0x1 or 0xF. They will behave the same with legacy paths enabled (will assert otherwise).
 - 2021/03/11 (1.82) - removed redirecting functions/enums names that were marked obsolete in 1.66 (September 2018):
                        - ImGui::SetScrollHere()              -> use ImGui::SetScrollHereY()
 - 2021/03/11 (1.82) - clarified that ImDrawList::PathArcTo(), ImDrawList::PathArcToFast() won't render with radius < 0.0f. Previously it sorts of accidentally worked but would generally lead to counter-clockwise paths and have an effect on anti-aliasing.
 - 2021/03/10 (1.82) - upgraded ImDrawList::AddPolyline() and PathStroke() "bool closed" parameter to "ImDrawFlags flags". The matching ImDrawFlags_Closed value is guaranteed to always stay == 1 in the future.
 - 2021/02/22 (1.82) - (*undone in 1.84*) win32+mingw: Re-enabled IME functions by default even under MinGW. In July 2016, issue #738 had me incorrectly disable those default functions for MinGW. MinGW users should: either link with -limm32, either set their imconfig file  with '#define IMGUI_DISABLE_WIN32_DEFAULT_IME_FUNCTIONS'.
 - 2021/02/17 (1.82) - renamed rarely used style.CircleSegmentMaxError (old default = 1.60f) to style.CircleTessellationMaxError (new default = 0.30f) as the meaning of the value changed.
 - 2021/02/03 (1.81) - renamed ListBoxHeader(const char* label, ImVec2 size) to BeginListBox(). Kept inline redirection function (will obsolete).
                     - removed ListBoxHeader(const char* label, int items_count, int height_in_items = -1) in favor of specifying size. Kept inline redirection function (will obsolete).
                     - renamed ListBoxFooter() to EndListBox(). Kept inline redirection function (will obsolete).
 - 2021/01/26 (1.81) - removed ImGuiFreeType::BuildFontAtlas(). Kept inline redirection function. Prefer using '#define IMGUI_ENABLE_FREETYPE', but there's a runtime selection path available too. The shared extra flags parameters (very rarely used) are now stored in ImFontAtlas::FontBuilderFlags.
                     - renamed ImFontConfig::RasterizerFlags (used by FreeType) to ImFontConfig::FontBuilderFlags.
                     - renamed ImGuiFreeType::XXX flags to ImGuiFreeTypeBuilderFlags_XXX for consistency with other API.
 - 2020/10/12 (1.80) - removed redirecting functions/enums that were marked obsolete in 1.63 (August 2018):
                        - ImGui::IsItemDeactivatedAfterChange() -> use ImGui::IsItemDeactivatedAfterEdit().
                        - ImGuiCol_ModalWindowDarkening       -> use ImGuiCol_ModalWindowDimBg
                        - ImGuiInputTextCallback              -> use ImGuiTextEditCallback
                        - ImGuiInputTextCallbackData          -> use ImGuiTextEditCallbackData
 - 2020/12/21 (1.80) - renamed ImDrawList::AddBezierCurve() to AddBezierCubic(), and PathBezierCurveTo() to PathBezierCubicCurveTo(). Kept inline redirection function (will obsolete).
 - 2020/12/04 (1.80) - added imgui_tables.cpp file! Manually constructed project files will need the new file added!
 - 2020/11/18 (1.80) - renamed undocumented/internals ImGuiColumnsFlags_* to ImGuiOldColumnFlags_* in prevision of incoming Tables API.
 - 2020/11/03 (1.80) - renamed io.ConfigWindowsMemoryCompactTimer to io.ConfigMemoryCompactTimer as the feature will apply to other data structures
 - 2020/10/14 (1.80) - backends: moved all backends files (imgui_impl_XXXX.cpp, imgui_impl_XXXX.h) from examples/ to backends/.
 - 2020/10/12 (1.80) - removed redirecting functions/enums that were marked obsolete in 1.60 (April 2018):
                        - io.RenderDrawListsFn pointer        -> use ImGui::GetDrawData() value and call the render function of your backend
                        - ImGui::IsAnyWindowFocused()         -> use ImGui::IsWindowFocused(ImGuiFocusedFlags_AnyWindow)
                        - ImGui::IsAnyWindowHovered()         -> use ImGui::IsWindowHovered(ImGuiHoveredFlags_AnyWindow)
                        - ImGuiStyleVar_Count_                -> use ImGuiStyleVar_COUNT
                        - ImGuiMouseCursor_Count_             -> use ImGuiMouseCursor_COUNT
                      - removed redirecting functions names that were marked obsolete in 1.61 (May 2018):
                        - InputFloat (... int decimal_precision ...) -> use InputFloat (... const char* format ...) with format = "%.Xf" where X is your value for decimal_precision.
                        - same for InputFloat2()/InputFloat3()/InputFloat4() variants taking a `int decimal_precision` parameter.
 - 2020/10/05 (1.79) - removed ImGuiListClipper: Renamed constructor parameters which created an ambiguous alternative to using the ImGuiListClipper::Begin() function, with misleading edge cases (note: imgui_memory_editor <0.40 from imgui_club/ used this old clipper API. Update your copy if needed).
 - 2020/09/25 (1.79) - renamed ImGuiSliderFlags_ClampOnInput to ImGuiSliderFlags_AlwaysClamp. Kept redirection enum (will obsolete sooner because previous name was added recently).
 - 2020/09/25 (1.79) - renamed style.TabMinWidthForUnselectedCloseButton to style.TabMinWidthForCloseButton.
 - 2020/09/21 (1.79) - renamed OpenPopupContextItem() back to OpenPopupOnItemClick(), reverting the change from 1.77. For varieties of reason this is more self-explanatory.
 - 2020/09/21 (1.79) - removed return value from OpenPopupOnItemClick() - returned true on mouse release on an item - because it is inconsistent with other popup APIs and makes others misleading. It's also and unnecessary: you can use IsWindowAppearing() after BeginPopup() for a similar result.
 - 2020/09/17 (1.79) - removed ImFont::DisplayOffset in favor of ImFontConfig::GlyphOffset. DisplayOffset was applied after scaling and not very meaningful/useful outside of being needed by the default ProggyClean font. If you scaled this value after calling AddFontDefault(), this is now done automatically. It was also getting in the way of better font scaling, so let's get rid of it now!
 - 2020/08/17 (1.78) - obsoleted use of the trailing 'float power=1.0f' parameter for DragFloat(), DragFloat2(), DragFloat3(), DragFloat4(), DragFloatRange2(), DragScalar(), DragScalarN(), SliderFloat(), SliderFloat2(), SliderFloat3(), SliderFloat4(), SliderScalar(), SliderScalarN(), VSliderFloat() and VSliderScalar().
                       replaced the 'float power=1.0f' argument with integer-based flags defaulting to 0 (as with all our flags).
                       worked out a backward-compatibility scheme so hopefully most C++ codebase should not be affected. in short, when calling those functions:
                       - if you omitted the 'power' parameter (likely!), you are not affected.
                       - if you set the 'power' parameter to 1.0f (same as previous default value): 1/ your compiler may warn on float>int conversion, 2/ everything else will work. 3/ you can replace the 1.0f value with 0 to fix the warning, and be technically correct.
                       - if you set the 'power' parameter to >1.0f (to enable non-linear editing): 1/ your compiler may warn on float>int conversion, 2/ code will assert at runtime, 3/ in case asserts are disabled, the code will not crash and enable the _Logarithmic flag. 4/ you can replace the >1.0f value with ImGuiSliderFlags_Logarithmic to fix the warning/assert and get a _similar_ effect as previous uses of power >1.0f.
                       see https://github.com/ocornut/imgui/issues/3361 for all details.
                       kept inline redirection functions (will obsolete) apart for: DragFloatRange2(), VSliderFloat(), VSliderScalar(). For those three the 'float power=1.0f' version was removed directly as they were most unlikely ever used.
                       for shared code, you can version check at compile-time with `#if IMGUI_VERSION_NUM >= 17704`.
                     - obsoleted use of v_min > v_max in DragInt, DragFloat, DragScalar to lock edits (introduced in 1.73, was not demoed nor documented very), will be replaced by a more generic ReadOnly feature. You may use the ImGuiSliderFlags_ReadOnly internal flag in the meantime.
 - 2020/06/23 (1.77) - removed BeginPopupContextWindow(const char*, int mouse_button, bool also_over_items) in favor of BeginPopupContextWindow(const char*, ImGuiPopupFlags flags) with ImGuiPopupFlags_NoOverItems.
 - 2020/06/15 (1.77) - renamed OpenPopupOnItemClick() to OpenPopupContextItem(). Kept inline redirection function (will obsolete). [NOTE: THIS WAS REVERTED IN 1.79]
 - 2020/06/15 (1.77) - removed CalcItemRectClosestPoint() entry point which was made obsolete and asserting in December 2017.
 - 2020/04/23 (1.77) - removed unnecessary ID (first arg) of ImFontAtlas::AddCustomRectRegular().
 - 2020/01/22 (1.75) - ImDrawList::AddCircle()/AddCircleFilled() functions don't accept negative radius any more.
 - 2019/12/17 (1.75) - [undid this change in 1.76] made Columns() limited to 64 columns by asserting above that limit. While the current code technically supports it, future code may not so we're putting the restriction ahead.
 - 2019/12/13 (1.75) - [imgui_internal.h] changed ImRect{} default constructor initializes all fields to 0.0f instead of (FLT_MAX,FLT_MAX,-FLT_MAX,-FLT_MAX). If you used ImRect::Add() to create bounding boxes by adding multiple points into it, you may need to fix your initial value.
 - 2019/12/08 (1.75) - removed redirecting functions/enums that were marked obsolete in 1.53 (December 2017):
                       - ShowTestWindow()                    -> use ShowDemoWindow()
                       - IsRootWindowFocused()               -> use IsWindowFocused(ImGuiFocusedFlags_RootWindow)
                       - IsRootWindowOrAnyChildFocused()     -> use IsWindowFocused(ImGuiFocusedFlags_RootAndChildWindows)
                       - SetNextWindowContentWidth(w)        -> use SetNextWindowContentSize(ImVec2{w, 0.0f}
                       - GetItemsLineHeightWithSpacing()     -> use GetFrameHeightWithSpacing()
                       - ImGuiCol_ChildWindowBg              -> use ImGuiCol_ChildBg
                       - ImGuiStyleVar_ChildWindowRounding   -> use ImGuiStyleVar_ChildRounding
                       - ImGuiTreeNodeFlags_AllowOverlapMode -> use ImGuiTreeNodeFlags_AllowItemOverlap
                       - IMGUI_DISABLE_TEST_WINDOWS          -> use IMGUI_DISABLE_DEMO_WINDOWS
 - 2019/12/08 (1.75) - obsoleted calling ImDrawList::PrimReserve() with a negative count (which was vaguely documented and rarely if ever used). Instead, we added an explicit PrimUnreserve() API.
 - 2019/12/06 (1.75) - removed implicit default parameter to IsMouseDragging(int button = 0) to be consistent with other mouse functions (none of the other functions have it).
 - 2019/11/21 (1.74) - ImFontAtlas::AddCustomRectRegular() now requires an ID larger than 0x110000 (instead of 0x10000) to conform with supporting Unicode planes 1-16 in a future update. ID below 0x110000 will now assert.
 - 2019/11/19 (1.74) - renamed IMGUI_DISABLE_FORMAT_STRING_FUNCTIONS to IMGUI_DISABLE_DEFAULT_FORMAT_FUNCTIONS for consistency.
 - 2019/11/19 (1.74) - renamed IMGUI_DISABLE_MATH_FUNCTIONS to IMGUI_DISABLE_DEFAULT_MATH_FUNCTIONS for consistency.
 - 2019/10/22 (1.74) - removed redirecting functions/enums that were marked obsolete in 1.52 (October 2017):
                       - Begin() [old 5 args version]        -> use Begin() [3 args], use SetNextWindowSize() SetNextWindowBgAlpha() if needed
                       - IsRootWindowOrAnyChildHovered()     -> use IsWindowHovered(ImGuiHoveredFlags_RootAndChildWindows)
                       - AlignFirstTextHeightToWidgets()     -> use AlignTextToFramePadding()
                       - SetNextWindowPosCenter()            -> use SetNextWindowPos() with a pivot of (0.5f, 0.5f)
                       - ImFont::Glyph                       -> use ImFontGlyph
 - 2019/10/14 (1.74) - inputs: Fixed a miscalculation in the keyboard/mouse "typematic" repeat delay/rate calculation, used by keys and e.g. repeating mouse buttons as well as the GetKeyPressedAmount() function.
                       if you were using a non-default value for io.KeyRepeatRate (previous default was 0.250), you can add +io.KeyRepeatDelay to it to compensate for the fix.
                       The function was triggering on: 0.0 and (delay+rate*N) where (N>=1). Fixed formula responds to (N>=0). Effectively it made io.KeyRepeatRate behave like it was set to (io.KeyRepeatRate + io.KeyRepeatDelay).
                       If you never altered io.KeyRepeatRate nor used GetKeyPressedAmount() this won't affect you.
 - 2019/07/15 (1.72) - removed TreeAdvanceToLabelPos() which is rarely used and only does SetCursorPosX(GetCursorPosX() + GetTreeNodeToLabelSpacing()). Kept redirection function (will obsolete).
 - 2019/07/12 (1.72) - renamed ImFontAtlas::CustomRect to ImFontAtlasCustomRect. Kept redirection typedef (will obsolete).
 - 2019/06/14 (1.72) - removed redirecting functions/enums names that were marked obsolete in 1.51 (June 2017): ImGuiCol_Column*, ImGuiSetCond_*, IsItemHoveredRect(), IsPosHoveringAnyWindow(), IsMouseHoveringAnyWindow(), IsMouseHoveringWindow(), IMGUI_ONCE_UPON_A_FRAME. Grep this log for details and new names, or see how they were implemented until 1.71.
 - 2019/06/07 (1.71) - rendering of child window outer decorations (bg color, border, scrollbars) is now performed as part of the parent window. If you have
                       overlapping child windows in a same parent, and relied on their relative z-order to be mapped to their submission order, this will affect your rendering.
                       This optimization is disabled if the parent window has no visual output, because it appears to be the most common situation leading to the creation of overlapping child windows.
                       Please reach out if you are affected.
 - 2019/05/13 (1.71) - renamed SetNextTreeNodeOpen() to SetNextItemOpen(). Kept inline redirection function (will obsolete).
 - 2019/05/11 (1.71) - changed io.AddInputCharacter(unsigned short c) signature to io.AddInputCharacter(unsigned int c).
 - 2019/04/29 (1.70) - improved ImDrawList thick strokes (>1.0f) preserving correct thickness up to 90 degrees angles (e.g. rectangles). If you have custom rendering using thick lines, they will appear thicker now.
 - 2019/04/29 (1.70) - removed GetContentRegionAvailWidth(), use GetContentRegionAvail().x instead. Kept inline redirection function (will obsolete).
 - 2019/03/04 (1.69) - renamed GetOverlayDrawList() to GetForegroundDrawList(). Kept redirection function (will obsolete).
 - 2019/02/26 (1.69) - renamed ImGuiColorEditFlags_RGB/ImGuiColorEditFlags_HSV/ImGuiColorEditFlags_HEX to ImGuiColorEditFlags_DisplayRGB/ImGuiColorEditFlags_DisplayHSV/ImGuiColorEditFlags_DisplayHex. Kept redirection enums (will obsolete).
 - 2019/02/14 (1.68) - made it illegal/assert when io.DisplayTime == 0.0f (with an exception for the first frame). If for some reason your time step calculation gives you a zero value, replace it with an arbitrarily small value!
 - 2019/02/01 (1.68) - removed io.DisplayVisibleMin/DisplayVisibleMax (which were marked obsolete and removed from viewport/docking branch already).
 - 2019/01/06 (1.67) - renamed io.InputCharacters[], marked internal as was always intended. Please don't access directly, and use AddInputCharacter() instead!
 - 2019/01/06 (1.67) - renamed ImFontAtlas::GlyphRangesBuilder to ImFontGlyphRangesBuilder. Kept redirection typedef (will obsolete).
 - 2018/12/20 (1.67) - made it illegal to call Begin("") with an empty string. This somehow half-worked before but had various undesirable side-effects.
 - 2018/12/10 (1.67) - renamed io.ConfigResizeWindowsFromEdges to io.ConfigWindowsResizeFromEdges as we are doing a large pass on configuration flags.
 - 2018/10/12 (1.66) - renamed misc/stl/imgui_stl.* to misc/cpp/imgui_stdlib.* in prevision for other C++ helper files.
 - 2018/09/28 (1.66) - renamed SetScrollHere() to SetScrollHereY(). Kept redirection function (will obsolete).
 - 2018/09/06 (1.65) - renamed stb_truetype.h to imstb_truetype.h, stb_textedit.h to imstb_textedit.h, and stb_rect_pack.h to imstb_rectpack.h.
                       If you were conveniently using the imgui copy of those STB headers in your project you will have to update your include paths.
 - 2018/09/05 (1.65) - renamed io.OptCursorBlink/io.ConfigCursorBlink to io.ConfigInputTextCursorBlink. (#1427)
 - 2018/08/31 (1.64) - added imgui_widgets.cpp file, extracted and moved widgets code out of imgui.cpp into imgui_widgets.cpp. Re-ordered some of the code remaining in imgui.cpp.
                       NONE OF THE FUNCTIONS HAVE CHANGED. THE CODE IS SEMANTICALLY 100% IDENTICAL, BUT _EVERY_ FUNCTION HAS BEEN MOVED.
                       Because of this, any local modifications to imgui.cpp will likely conflict when you update. Read docs/CHANGELOG.txt for suggestions.
 - 2018/08/22 (1.63) - renamed IsItemDeactivatedAfterChange() to IsItemDeactivatedAfterEdit() for consistency with new IsItemEdited() API. Kept redirection function (will obsolete soonish as IsItemDeactivatedAfterChange() is very recent).
 - 2018/08/21 (1.63) - renamed ImGuiTextEditCallback to ImGuiInputTextCallback, ImGuiTextEditCallbackData to ImGuiInputTextCallbackData for consistency. Kept redirection types (will obsolete).
 - 2018/08/21 (1.63) - removed ImGuiInputTextCallbackData::ReadOnly since it is a duplication of (ImGuiInputTextCallbackData::Flags & ImGuiInputTextFlags_ReadOnly).
 - 2018/08/01 (1.63) - removed per-window ImGuiWindowFlags_ResizeFromAnySide beta flag in favor of a global io.ConfigResizeWindowsFromEdges [update 1.67 renamed to ConfigWindowsResizeFromEdges] to enable the feature.
 - 2018/08/01 (1.63) - renamed io.OptCursorBlink to io.ConfigCursorBlink [-> io.ConfigInputTextCursorBlink in 1.65], io.OptMacOSXBehaviors to ConfigMacOSXBehaviors for consistency.
 - 2018/07/22 (1.63) - changed ImGui::GetTime() return value from float to double to avoid accumulating floating point imprecisions over time.
 - 2018/07/08 (1.63) - style: renamed ImGuiCol_ModalWindowDarkening to ImGuiCol_ModalWindowDimBg for consistency with other features. Kept redirection enum (will obsolete).
 - 2018/06/08 (1.62) - examples: the imgui_impl_XXX files have been split to separate platform (Win32, GLFW, SDL2, etc.) from renderer (DX11, OpenGL, Vulkan,  etc.).
                       old backends will still work as is, however prefer using the separated backends as they will be updated to support multi-viewports.
                       when adopting new backends follow the main.cpp code of your preferred examples/ folder to know which functions to call.
                       in particular, note that old backends called ImGui::NewFrame() at the end of their ImGui_ImplXXXX_NewFrame() function.
 - 2018/06/06 (1.62) - renamed GetGlyphRangesChinese() to GetGlyphRangesChineseFull() to distinguish other variants and discourage using the full set.
 - 2018/06/06 (1.62) - TreeNodeEx()/TreeNodeBehavior(): the ImGuiTreeNodeFlags_CollapsingHeader helper now include the ImGuiTreeNodeFlags_NoTreePushOnOpen flag. See Changelog for details.
 - 2018/05/03 (1.61) - DragInt(): the default compile-time format string has been changed from "%.0f" to "%d", as we are not using integers internally any more.
                       If you used DragInt() with custom format strings, make sure you change them to use %d or an integer-compatible format.
                       To honor backward-compatibility, the DragInt() code will currently parse and modify format strings to replace %*f with %d, giving time to users to upgrade their code.
                       If you have IMGUI_DISABLE_OBSOLETE_FUNCTIONS enabled, the code will instead assert! You may run a reg-exp search on your codebase for e.g. "DragInt.*%f" to help you find them.
 - 2018/04/28 (1.61) - obsoleted InputFloat() functions taking an optional "int decimal_precision" in favor of an equivalent and more flexible "const char* format",
                       consistent with other functions. Kept redirection functions (will obsolete).
 - 2018/04/09 (1.61) - IM_DELETE() helper function added in 1.60 doesn't clear the input _pointer_ reference, more consistent with expectation and allows passing r-value.
 - 2018/03/20 (1.60) - renamed io.WantMoveMouse to io.WantSetMousePos for consistency and ease of understanding (was added in 1.52, _not_ used by core and only honored by some backend ahead of merging the Nav branch).
 - 2018/03/12 (1.60) - removed ImGuiCol_CloseButton, ImGuiCol_CloseButtonActive, ImGuiCol_CloseButtonHovered as the closing cross uses regular button colors now.
 - 2018/03/08 (1.60) - changed ImFont::DisplayOffset.y to default to 0 instead of +1. Fixed rounding of Ascent/Descent to match TrueType renderer. If you were adding or subtracting to ImFont::DisplayOffset check if your fonts are correctly aligned vertically.
 - 2018/03/03 (1.60) - renamed ImGuiStyleVar_Count_ to ImGuiStyleVar_COUNT and ImGuiMouseCursor_Count_ to ImGuiMouseCursor_COUNT for consistency with other public enums.
 - 2018/02/18 (1.60) - BeginDragDropSource(): temporarily removed the optional mouse_button=0 parameter because it is not really usable in many situations at the moment.
 - 2018/02/16 (1.60) - obsoleted the io.RenderDrawListsFn callback, you can call your graphics engine render function after ImGui::Render(). Use ImGui::GetDrawData() to retrieve the ImDrawData* to display.
 - 2018/02/07 (1.60) - reorganized context handling to be more explicit,
                       - YOU NOW NEED TO CALL ImGui::CreateContext() AT THE BEGINNING OF YOUR APP, AND CALL ImGui::DestroyContext() AT THE END.
                       - removed Shutdown() function, as DestroyContext() serve this purpose.
                       - you may pass a ImFontAtlas* pointer to CreateContext() to share a font atlas between contexts. Otherwise CreateContext() will create its own font atlas instance.
                       - removed allocator parameters from CreateContext(), they are now setup with SetAllocatorFunctions(), and shared by all contexts.
                       - removed the default global context and font atlas instance, which were confusing for users of DLL reloading and users of multiple contexts.
 - 2018/01/31 (1.60) - moved sample TTF files from extra_fonts/ to misc/fonts/. If you loaded files directly from the imgui repo you may need to update your paths.
 - 2018/01/11 (1.60) - obsoleted IsAnyWindowHovered() in favor of IsWindowHovered(ImGuiHoveredFlags_AnyWindow). Kept redirection function (will obsolete).
 - 2018/01/11 (1.60) - obsoleted IsAnyWindowFocused() in favor of IsWindowFocused(ImGuiFocusedFlags_AnyWindow). Kept redirection function (will obsolete).
 - 2018/01/03 (1.60) - renamed ImGuiSizeConstraintCallback to ImGuiSizeCallback, ImGuiSizeConstraintCallbackData to ImGuiSizeCallbackData.
 - 2017/12/29 (1.60) - removed CalcItemRectClosestPoint() which was weird and not really used by anyone except demo code. If you need it it's easy to replicate on your side.
 - 2017/12/24 (1.53) - renamed the emblematic ShowTestWindow() function to ShowDemoWindow(). Kept redirection function (will obsolete).
 - 2017/12/21 (1.53) - ImDrawList: renamed style.AntiAliasedShapes to style.AntiAliasedFill for consistency and as a way to explicitly break code that manipulate those flag at runtime. You can now manipulate ImDrawList::Flags
 - 2017/12/21 (1.53) - ImDrawList: removed 'bool anti_aliased = true' final parameter of ImDrawList::AddPolyline() and ImDrawList::AddConvexPolyFilled(). Prefer manipulating ImDrawList::Flags if you need to toggle them during the frame.
 - 2017/12/14 (1.53) - using the ImGuiWindowFlags_NoScrollWithMouse flag on a child window forwards the mouse wheel event to the parent window, unless either ImGuiWindowFlags_NoInputs or ImGuiWindowFlags_NoScrollbar are also set.
 - 2017/12/13 (1.53) - renamed GetItemsLineHeightWithSpacing() to GetFrameHeightWithSpacing(). Kept redirection function (will obsolete).
 - 2017/12/13 (1.53) - obsoleted IsRootWindowFocused() in favor of using IsWindowFocused(ImGuiFocusedFlags_RootWindow). Kept redirection function (will obsolete).
                     - obsoleted IsRootWindowOrAnyChildFocused() in favor of using IsWindowFocused(ImGuiFocusedFlags_RootAndChildWindows). Kept redirection function (will obsolete).
 - 2017/12/12 (1.53) - renamed ImGuiTreeNodeFlags_AllowOverlapMode to ImGuiTreeNodeFlags_AllowItemOverlap. Kept redirection enum (will obsolete).
 - 2017/12/10 (1.53) - removed SetNextWindowContentWidth(), prefer using SetNextWindowContentSize(). Kept redirection function (will obsolete).
 - 2017/11/27 (1.53) - renamed ImGuiTextBuffer::append() helper to appendf(), appendv() to appendfv(). If you copied the 'Log' demo in your code, it uses appendv() so that needs to be renamed.
 - 2017/11/18 (1.53) - Style, Begin: removed ImGuiWindowFlags_ShowBorders window flag. Borders are now fully set up in the ImGuiStyle structure (see e.g. style.FrameBorderSize, style.WindowBorderSize). Use ImGui::ShowStyleEditor() to look them up.
                       Please note that the style system will keep evolving (hopefully stabilizing in Q1 2018), and so custom styles will probably subtly break over time. It is recommended you use the StyleColorsClassic(), StyleColorsDark(), StyleColorsLight() functions.
 - 2017/11/18 (1.53) - Style: removed ImGuiCol_ComboBg in favor of combo boxes using ImGuiCol_PopupBg for consistency.
 - 2017/11/18 (1.53) - Style: renamed ImGuiCol_ChildWindowBg to ImGuiCol_ChildBg.
 - 2017/11/18 (1.53) - Style: renamed style.ChildWindowRounding to style.ChildRounding, ImGuiStyleVar_ChildWindowRounding to ImGuiStyleVar_ChildRounding.
 - 2017/11/02 (1.53) - obsoleted IsRootWindowOrAnyChildHovered() in favor of using IsWindowHovered(ImGuiHoveredFlags_RootAndChildWindows);
 - 2017/10/24 (1.52) - renamed IMGUI_DISABLE_WIN32_DEFAULT_CLIPBOARD_FUNCS/IMGUI_DISABLE_WIN32_DEFAULT_IME_FUNCS to IMGUI_DISABLE_WIN32_DEFAULT_CLIPBOARD_FUNCTIONS/IMGUI_DISABLE_WIN32_DEFAULT_IME_FUNCTIONS for consistency.
 - 2017/10/20 (1.52) - changed IsWindowHovered() default parameters behavior to return false if an item is active in another window (e.g. click-dragging item from another window to this window). You can use the newly introduced IsWindowHovered() flags to requests this specific behavior if you need it.
 - 2017/10/20 (1.52) - marked IsItemHoveredRect()/IsMouseHoveringWindow() as obsolete, in favor of using the newly introduced flags for IsItemHovered() and IsWindowHovered(). See https://github.com/ocornut/imgui/issues/1382 for details.
                       removed the IsItemRectHovered()/IsWindowRectHovered() names introduced in 1.51 since they were merely more consistent names for the two functions we are now obsoleting.
                         IsItemHoveredRect()        --> IsItemHovered(ImGuiHoveredFlags_RectOnly)
                         IsMouseHoveringAnyWindow() --> IsWindowHovered(ImGuiHoveredFlags_AnyWindow)
                         IsMouseHoveringWindow()    --> IsWindowHovered(ImGuiHoveredFlags_AllowWhenBlockedByPopup | ImGuiHoveredFlags_AllowWhenBlockedByActiveItem) [weird, old behavior]
 - 2017/10/17 (1.52) - marked the old 5-parameters version of Begin() as obsolete (still available). Use SetNextWindowSize()+Begin() instead!
 - 2017/10/11 (1.52) - renamed AlignFirstTextHeightToWidgets() to AlignTextToFramePadding(). Kept inline redirection function (will obsolete).
 - 2017/09/26 (1.52) - renamed ImFont::Glyph to ImFontGlyph. Kept redirection typedef (will obsolete).
 - 2017/09/25 (1.52) - removed SetNextWindowPosCenter() because SetNextWindowPos() now has the optional pivot information to do the same and more. Kept redirection function (will obsolete).
 - 2017/08/25 (1.52) - io.MousePos needs to be set to ImVec2{-FLT_MAX,-FLT_MAX} when mouse is unavailable/missing. Previously ImVec2{-1,-1} was enough but we now accept negative mouse coordinates. In your backend if you need to support unavailable mouse, make sure to replace "io.MousePos = ImVec2{-1,-1}" with "io.MousePos = ImVec2{-FLT_MAX,-FLT_MAX}".
 - 2017/08/22 (1.51) - renamed IsItemHoveredRect() to IsItemRectHovered(). Kept inline redirection function (will obsolete). -> (1.52) use IsItemHovered(ImGuiHoveredFlags_RectOnly)!
                     - renamed IsMouseHoveringAnyWindow() to IsAnyWindowHovered() for consistency. Kept inline redirection function (will obsolete).
                     - renamed IsMouseHoveringWindow() to IsWindowRectHovered() for consistency. Kept inline redirection function (will obsolete).
 - 2017/08/20 (1.51) - renamed GetStyleColName() to GetStyleColorName() for consistency.
 - 2017/08/20 (1.51) - added PushStyleColor(ImGuiCol idx, ImU32 col) overload, which _might_ cause an "ambiguous call" compilation error if you are using ImColor() with implicit cast. Cast to ImU32 or ImVec4 explicily to fix.
 - 2017/08/15 (1.51) - marked the weird IMGUI_ONCE_UPON_A_FRAME helper macro as obsolete. prefer using the more explicit ImGuiOnceUponAFrame type.
 - 2017/08/15 (1.51) - changed parameter order for BeginPopupContextWindow() from (const char*,int buttons,bool also_over_items) to (const char*,int buttons,bool also_over_items). Note that most calls relied on default parameters completely.
 - 2017/08/13 (1.51) - renamed ImGuiCol_Column to ImGuiCol_Separator, ImGuiCol_ColumnHovered to ImGuiCol_SeparatorHovered, ImGuiCol_ColumnActive to ImGuiCol_SeparatorActive. Kept redirection enums (will obsolete).
 - 2017/08/11 (1.51) - renamed ImGuiSetCond_Always to ImGuiCond_Always, ImGuiSetCond_Once to ImGuiCond_Once, ImGuiSetCond_FirstUseEver to ImGuiCond_FirstUseEver, ImGuiSetCond_Appearing to ImGuiCond_Appearing. Kept redirection enums (will obsolete).
 - 2017/08/09 (1.51) - removed ValueColor() helpers, they are equivalent to calling Text(label) + SameLine() + ColorButton().
 - 2017/08/08 (1.51) - removed ColorEditMode() and ImGuiColorEditMode in favor of ImGuiColorEditFlags and parameters to the various Color*() functions. The SetColorEditOptions() allows to initialize default but the user can still change them with right-click context menu.
                     - changed prototype of 'ColorEdit4(const char* label, float col[4], bool show_alpha = true)' to 'ColorEdit4(const char* label, float col[4], ImGuiColorEditFlags Flags = {})', where passing Flags = {}x01 is a safe no-op (hello dodgy backward compatibility!). - check and run the demo window, under "Color/Picker Widgets", to understand the various new options.
                     - changed prototype of rarely used 'ColorButton(ImVec4 col, bool small_height = false, bool outline_border = true)' to 'ColorButton(const char* desc_id, ImVec4 col, ImGuiColorEditFlags Flags = {}, ImVec2 size = ImVec2{0, 0})'
 - 2017/07/20 (1.51) - removed IsPosHoveringAnyWindow(ImVec2), which was partly broken and misleading. ASSERT + redirect user to io.WantCaptureMouse
 - 2017/05/26 (1.50) - removed ImFontConfig::MergeGlyphCenterV in favor of a more multipurpose ImFontConfig::GlyphOffset.
 - 2017/05/01 (1.50) - renamed ImDrawList::PathFill() (rarely used directly) to ImDrawList::PathFillConvex() for clarity.
 - 2016/11/06 (1.50) - BeginChild(const char*) now applies the stack id to the provided label, consistently with other functions as it should always have been. It shouldn't affect you unless (extremely unlikely) you were appending multiple times to a same child from different locations of the stack id. If that's the case, generate an id with GetID() and use it instead of passing string to BeginChild().
 - 2016/10/15 (1.50) - avoid 'void* user_data' parameter to io.SetClipboardTextFn/io.GetClipboardTextFn pointers. We pass io.ClipboardUserData to it.
 - 2016/09/25 (1.50) - style.WindowTitleAlign is now a ImVec2 (ImGuiAlign enum was removed). set to (0.5f,0.5f) for horizontal+vertical centering, (0.0f,0.0f) for upper-left, etc.
 - 2016/07/30 (1.50) - SameLine(x) with x>0.0f is now relative to left of column/group if any, and not always to left of window. This was sort of always the intent and hopefully, breakage should be minimal.
 - 2016/05/12 (1.49) - title bar (using ImGuiCol_TitleBg/ImGuiCol_TitleBgActive colors) isn't rendered over a window background (ImGuiCol_WindowBg color) anymore.
                       If your TitleBg/TitleBgActive alpha was 1.0f or you are using the default theme it will not affect you, otherwise if <1.0f you need to tweak your custom theme to readjust for the fact that we don't draw a WindowBg background behind the title bar.
                       This helper function will convert an old TitleBg/TitleBgActive color into a new one with the same visual output, given the OLD color and the OLD WindowBg color:
                       ImVec4 ConvertTitleBgCol(const ImVec4& win_bg_col, const ImVec4& title_bg_col) { float new_a = 1.0f - ((1.0f - win_bg_col.w) * (1.0f - title_bg_col.w)), k = title_bg_col.w / new_a; return ImVec4{(win_bg_col.x * win_bg_col.w + title_bg_col.x) * k, (win_bg_col.y * win_bg_col.w + title_bg_col.y) * k, (win_bg_col.z * win_bg_col.w + title_bg_col.z) * k, new_a}; }
                       If this is confusing, pick the RGB value from title bar from an old screenshot and apply this as TitleBg/TitleBgActive. Or you may just create TitleBgActive from a tweaked TitleBg color.
 - 2016/05/07 (1.49) - removed confusing set of GetInternalState(), GetInternalStateSize(), SetInternalState() functions. Now using CreateContext(), DestroyContext(), GetCurrentContext(), SetCurrentContext().
 - 2016/05/02 (1.49) - renamed SetNextTreeNodeOpened() to SetNextTreeNodeOpen(), no redirection.
 - 2016/05/01 (1.49) - obsoleted old signature of CollapsingHeader(const char* label, const char* str_id = NULL, bool display_frame = true, bool default_open = false) as extra parameters were badly designed and rarely used. You can replace the "default_open = true" flag in new API with CollapsingHeader(label, ImGuiTreeNodeFlags_DefaultOpen).
 - 2016/04/26 (1.49) - changed ImDrawList::PushClipRect(ImVec4 rect) to ImDrawList::PushClipRect(Imvec2 min,ImVec2 max,bool intersect_with_current_clip_rect=false). Note that higher-level ImGui::PushClipRect() is preferable because it will clip at logic/widget level, whereas ImDrawList::PushClipRect() only affect your renderer.
 - 2016/04/03 (1.48) - removed style.WindowFillAlphaDefault setting which was redundant. Bake default BG alpha inside style.Colors[ImGuiCol_WindowBg] and all other Bg color values. (ref GitHub issue #337).
 - 2016/04/03 (1.48) - renamed ImGuiCol_TooltipBg to ImGuiCol_PopupBg, used by popups/menus and tooltips. popups/menus were previously using ImGuiCol_WindowBg. (ref github issue #337)
 - 2016/03/21 (1.48) - renamed GetWindowFont() to GetFont(), GetWindowFontSize() to GetFontSize(). Kept inline redirection function (will obsolete).
 - 2016/03/02 (1.48) - InputText() completion/history/always callbacks: if you modify the text buffer manually (without using DeleteChars()/InsertChars() helper) you need to maintain the BufTextLen field. added an assert.
 - 2016/01/23 (1.48) - fixed not honoring exact width passed to PushItemWidth(), previously it would add extra FramePadding.x*2 over that width. if you had manual pixel-perfect alignment in place it might affect you.
 - 2015/12/27 (1.48) - fixed ImDrawList::AddRect() which used to render a rectangle 1 px too large on each axis.
 - 2015/12/04 (1.47) - renamed Color() helpers to ValueColor() - dangerously named, rarely used and probably to be made obsolete.
 - 2015/08/29 (1.45) - with the addition of horizontal scrollbar we made various fixes to inconsistencies with dealing with cursor position.
                       GetCursorPos()/SetCursorPos() functions now include the scrolled amount. It shouldn't affect the majority of users, but take note that SetCursorPosX(100.0f) puts you at +100 from the starting x position which may include scrolling, not at +100 from the window left side.
                       GetContentRegionMax()/GetWindowContentRegionMin()/GetWindowContentRegionMax() functions allow include the scrolled amount. Typically those were used in cases where no scrolling would happen so it may not be a problem, but watch out!
 - 2015/08/29 (1.45) - renamed style.ScrollbarWidth to style.ScrollbarSize
 - 2015/08/05 (1.44) - split imgui.cpp into extra files: imgui_demo.cpp imgui_draw.cpp imgui_internal.h that you need to add to your project.
 - 2015/07/18 (1.44) - fixed angles in ImDrawList::PathArcTo(), PathArcToFast() (introduced in 1.43) being off by an extra PI for no justifiable reason
 - 2015/07/14 (1.43) - add new ImFontAtlas::AddFont() API. For the old AddFont***, moved the 'font_no' parameter of ImFontAtlas::AddFont** functions to the ImFontConfig structure.
                       you need to render your textured triangles with bilinear filtering to benefit from sub-pixel positioning of text.
 - 2015/07/08 (1.43) - switched rendering data to use indexed rendering. this is saving a fair amount of CPU/GPU and enables us to get anti-aliasing for a marginal cost.
                       this necessary change will break your rendering function! the fix should be very easy. sorry for that :(
                     - if you are using a vanilla copy of one of the imgui_impl_XXX.cpp provided in the example, you just need to update your copy and you can ignore the rest.
                     - the signature of the io.RenderDrawListsFn handler has changed!
                       old: ImGui_XXXX_RenderDrawLists(ImDrawList** const cmd_lists, int cmd_lists_count)
                       new: ImGui_XXXX_RenderDrawLists(ImDrawData* draw_data).
                         parameters: 'cmd_lists' becomes 'draw_data->CmdLists', 'cmd_lists_count' becomes 'draw_data->CmdListsCount'
                         ImDrawList: 'commands' becomes 'CmdBuffer', 'vtx_buffer' becomes 'VtxBuffer', 'IdxBuffer' is new.
                         ImDrawCmd:  'vtx_count' becomes 'ElemCount', 'clip_rect' becomes 'ClipRect', 'user_callback' becomes 'UserCallback', 'texture_id' becomes 'TextureId'.
                     - each ImDrawList now contains both a vertex buffer and an index buffer. For each command, render ElemCount/3 triangles using indices from the index buffer.
                     - if you REALLY cannot render indexed primitives, you can call the draw_data->DeIndexAllBuffers() method to de-index the buffers. This is slow and a waste of CPU/GPU. Prefer using indexed rendering!
                     - refer to code in the examples/ folder or ask on the GitHub if you are unsure of how to upgrade. please upgrade!
 - 2015/07/10 (1.43) - changed SameLine() parameters from int to float.
 - 2015/07/02 (1.42) - renamed SetScrollPosHere() to SetScrollFromCursorPos(). Kept inline redirection function (will obsolete).
 - 2015/07/02 (1.42) - renamed GetScrollPosY() to GetScrollY(). Necessary to reduce confusion along with other scrolling functions, because positions (e.g. cursor position) are not equivalent to scrolling amount.
 - 2015/06/14 (1.41) - changed ImageButton() default bg_col parameter from (0,0,0,1) (black) to (0,0,0,0) (transparent) - makes a difference when texture have transparence
 - 2015/06/14 (1.41) - changed Selectable() API from (label, selected, size) to (label, selected, flags, size). Size override should have been rarely used. Sorry!
 - 2015/05/31 (1.40) - renamed GetWindowCollapsed() to IsWindowCollapsed() for consistency. Kept inline redirection function (will obsolete).
 - 2015/05/31 (1.40) - renamed IsRectClipped() to IsRectVisible() for consistency. Note that return value is opposite! Kept inline redirection function (will obsolete).
 - 2015/05/27 (1.40) - removed the third 'repeat_if_held' parameter from Button() - sorry! it was rarely used and inconsistent. Use PushButtonRepeat(true) / PopButtonRepeat() to enable repeat on desired buttons.
 - 2015/05/11 (1.40) - changed BeginPopup() API, takes a string identifier instead of a bool. ImGui needs to manage the open/closed state of popups. Call OpenPopup() to actually set the "open" state of a popup. BeginPopup() returns true if the popup is opened.
 - 2015/05/03 (1.40) - removed style.AutoFitPadding, using style.WindowPadding makes more sense (the default values were already the same).
 - 2015/04/13 (1.38) - renamed IsClipped() to IsRectClipped(). Kept inline redirection function until 1.50.
 - 2015/04/09 (1.38) - renamed ImDrawList::AddArc() to ImDrawList::AddArcFast() for compatibility with future API
 - 2015/04/03 (1.38) - removed ImGuiCol_CheckHovered, ImGuiCol_CheckActive, replaced with the more general ImGuiCol_FrameBgHovered, ImGuiCol_FrameBgActive.
 - 2014/04/03 (1.38) - removed support for passing -FLT_MAX..+FLT_MAX as the range for a SliderFloat(). Use DragFloat() or Inputfloat() instead.
 - 2015/03/17 (1.36) - renamed GetItemBoxMin()/GetItemBoxMax()/IsMouseHoveringBox() to GetItemRectMin()/GetItemRectMax()/IsMouseHoveringRect(). Kept inline redirection function until 1.50.
 - 2015/03/15 (1.36) - renamed style.TreeNodeSpacing to style.IndentSpacing, ImGuiStyleVar_TreeNodeSpacing to ImGuiStyleVar_IndentSpacing
 - 2015/03/13 (1.36) - renamed GetWindowIsFocused() to IsWindowFocused(). Kept inline redirection function until 1.50.
 - 2015/03/08 (1.35) - renamed style.ScrollBarWidth to style.ScrollbarWidth (casing)
 - 2015/02/27 (1.34) - renamed OpenNextNode(bool) to SetNextTreeNodeOpened(bool, ImGuiSetCond). Kept inline redirection function until 1.50.
 - 2015/02/27 (1.34) - renamed ImGuiSetCondition_*** to ImGuiSetCond_***, and _FirstUseThisSession becomes _Once.
 - 2015/02/11 (1.32) - changed text input callback ImGuiTextEditCallback return type from void-->int. reserved for future use, return 0 for now.
 - 2015/02/10 (1.32) - renamed GetItemWidth() to CalcItemWidth() to clarify its evolving behavior
 - 2015/02/08 (1.31) - renamed GetTextLineSpacing() to GetTextLineHeightWithSpacing()
 - 2015/02/01 (1.31) - removed IO.MemReallocFn (unused)
 - 2015/01/19 (1.30) - renamed ImGuiStorage::GetIntPtr()/GetFloatPtr() to GetIntRef()/GetIntRef() because Ptr was conflicting with actual pointer storage functions.
 - 2015/01/11 (1.30) - big font/image API change! now loads TTF file. allow for multiple fonts. no need for a PNG loader.
 - 2015/01/11 (1.30) - removed GetDefaultFontData(). uses io.Fonts->GetTextureData*() API to retrieve uncompressed pixels.
                       - old:  const void* png_data; unsigned int png_size; ImGui::GetDefaultFontData(NULL, NULL, &png_data, &png_size); [..Upload texture to GPU..];
                       - new:  unsigned char* pixels; int width, height; io.Fonts->GetTexDataAsRGBA32(&pixels, &width, &height); [..Upload texture to GPU..]; io.Fonts->SetTexID(YourTexIdentifier);
                       you now have more flexibility to load multiple TTF fonts and manage the texture buffer for internal needs. It is now recommended that you sample the font texture with bilinear interpolation.
 - 2015/01/11 (1.30) - added texture identifier in ImDrawCmd passed to your render function (we can now render images). make sure to call io.Fonts->SetTexID()
 - 2015/01/11 (1.30) - removed IO.PixelCenterOffset (unnecessary, can be handled in user projection matrix)
 - 2015/01/11 (1.30) - removed ImGui::IsItemFocused() in favor of ImGui::IsItemActive() which handles all widgets
 - 2014/12/10 (1.18) - removed SetNewWindowDefaultPos() in favor of new generic API SetNextWindowPos(pos, ImGuiSetCondition_FirstUseEver)
 - 2014/11/28 (1.17) - moved IO.Font*** options to inside the IO.Font-> structure (FontYOffset, FontTexUvForWhite, FontBaseScale, FontFallbackGlyph)
 - 2014/11/26 (1.17) - reworked syntax of IMGUI_ONCE_UPON_A_FRAME helper macro to increase compiler compatibility
 - 2014/11/07 (1.15) - renamed IsHovered() to IsItemHovered()
 - 2014/10/02 (1.14) - renamed IMGUI_INCLUDE_IMGUI_USER_CPP to IMGUI_INCLUDE_IMGUI_USER_INL and imgui_user.cpp to imgui_user.inl (more IDE friendly)
 - 2014/09/25 (1.13) - removed 'text_end' parameter from IO.SetClipboardTextFn (the string is now always zero-terminated for simplicity)
 - 2014/09/24 (1.12) - renamed SetFontScale() to SetWindowFontScale()
 - 2014/09/24 (1.12) - moved IM_MALLOC/IM_REALLOC/IM_FREE preprocessor defines to IO.MemAllocFn/IO.MemReallocFn/IO.MemFreeFn
 - 2014/08/30 (1.09) - removed IO.FontHeight (now computed automatically)
 - 2014/08/30 (1.09) - moved IMGUI_FONT_TEX_UV_FOR_WHITE preprocessor define to IO.FontTexUvForWhite
 - 2014/08/28 (1.09) - changed the behavior of IO.PixelCenterOffset following various rendering fixes


 FREQUENTLY ASKED QUESTIONS (FAQ)
 ================================

 Read all answers online:
   https://www.dearimgui.com/faq or https://github.com/ocornut/imgui/blob/master/docs/FAQ.md (same url)
 Read all answers locally (with a text editor or ideally a Markdown viewer):
   docs/FAQ.md
 Some answers are copied down here to facilitate searching in code.

 Q&A: Basics
 ===========

 Q: Where is the documentation?
 A: This library is poorly documented at the moment and expects the user to be acquainted with C/C++.
    - Run the examples/ applications and explore them.
    - Read Getting Started (https://github.com/ocornut/imgui/wiki/Getting-Started) guide.
    - See demo code in imgui_demo.cpp and particularly the ImGui::ShowDemoWindow() function.
    - The demo covers most features of Dear ImGui, so you can read the code and see its output.
    - See documentation and comments at the top of imgui.cpp + effectively imgui.h.
    - 20+ standalone example applications using e.g. OpenGL/DirectX are provided in the
      examples/ folder to explain how to integrate Dear ImGui with your own engine/application.
    - The Wiki (https://github.com/ocornut/imgui/wiki) has many resources and links.
    - The Glossary (https://github.com/ocornut/imgui/wiki/Glossary) page also may be useful.
    - Your programming IDE is your friend, find the type or function declaration to find comments
      associated with it.

 Q: What is this library called?
 Q: Which version should I get?
 >> This library is called "Dear ImGui", please don't call it "ImGui" :)
 >> See https://www.dearimgui.com/faq for details.

 Q&A: Integration
 ================

 Q: How to get started?
 A: Read https://github.com/ocornut/imgui/wiki/Getting-Started. Read 'PROGRAMMER GUIDE' above. Read examples/README.txt.

 Q: How can I tell whether to dispatch mouse/keyboard to Dear ImGui or my application?
 A: You should read the 'io.WantCaptureMouse', 'io.WantCaptureKeyboard' and 'io.WantTextInput' flags!
 >> See https://www.dearimgui.com/faq for a fully detailed answer. You really want to read this.

 Q. How can I enable keyboard or gamepad controls?
 Q: How can I use this on a machine without mouse, keyboard or screen? (input share, remote display)
 Q: I integrated Dear ImGui in my engine and little squares are showing instead of text...
 Q: I integrated Dear ImGui in my engine and some elements are clipping or disappearing when I move windows around...
 Q: I integrated Dear ImGui in my engine and some elements are displaying outside their expected windows boundaries...
 >> See https://www.dearimgui.com/faq

 Q&A: Usage
 ----------

 Q: About the ID Stack system..
   - Why is my widget not reacting when I click on it?
   - How can I have widgets with an empty label?
   - How can I have multiple widgets with the same label?
   - How can I have multiple windows with the same label?
 Q: How can I display an image? What is ImTextureID, how does it work?
 Q: How can I use my own math types instead of ImVec2?
 Q: How can I interact with standard C++ types (such as std::string and std::vector)?
 Q: How can I display custom shapes? (using low-level ImDrawList API)
 >> See https://www.dearimgui.com/faq

 Q&A: Fonts, Text
 ================

 Q: How should I handle DPI in my application?
 Q: How can I load a different font than the default?
 Q: How can I easily use icons in my application?
 Q: How can I load multiple fonts?
 Q: How can I display and input non-Latin characters such as Chinese, Japanese, Korean, Cyrillic?
 >> See https://www.dearimgui.com/faq and https://github.com/ocornut/imgui/blob/master/docs/FONTS.md

 Q&A: Concerns
 =============

 Q: Who uses Dear ImGui?
 Q: Can you create elaborate/serious tools with Dear ImGui?
 Q: Can you reskin the look of Dear ImGui?
 Q: Why using C++ (as opposed to C)?
 >> See https://www.dearimgui.com/faq

 Q&A: Community
 ==============

 Q: How can I help?
 A: - Businesses: please reach out to "omar AT dearimgui DOT com" if you work in a place using Dear ImGui!
      We can discuss ways for your company to fund development via invoiced technical support, maintenance or sponsoring contacts.
      This is among the most useful thing you can do for Dear ImGui. With increased funding, we sustain and grow work on this project.
      >>> See https://github.com/ocornut/imgui/wiki/Funding
    - Businesses: you can also purchase licenses for the Dear ImGui Automation/Test Engine.
    - If you are experienced with Dear ImGui and C++, look at the GitHub issues, look at the Wiki, and see how you want to help and can help!
    - Disclose your usage of Dear ImGui via a dev blog post, a tweet, a screenshot, a mention somewhere etc.
      You may post screenshot or links in the gallery threads. Visuals are ideal as they inspire other programmers.
      But even without visuals, disclosing your use of dear imgui helps the library grow credibility, and help other teams and programmers with taking decisions.
    - If you have issues or if you need to hack into the library, even if you don't expect any support it is useful that you share your issues (on GitHub or privately).

*/

//-------------------------------------------------------------------------
// [SECTION] INCLUDES
//-------------------------------------------------------------------------

// dear imgui, v1.91.7 WIP
// (headers)

// Help:
// - See links below.
// - Call and read ImGui::ShowDemoWindow() in imgui_demo.cpp. All applications in examples/ are doing that.
// - Read top of imgui.cpp for more details, links and comments.

// Resources:
// - FAQ ........................ https://dearimgui.com/faq (in repository as docs/FAQ.md)
// - Homepage ................... https://github.com/ocornut/imgui
// - Releases & changelog ....... https://github.com/ocornut/imgui/releases
// - Gallery .................... https://github.com/ocornut/imgui/issues?q=label%3Agallery (please post your screenshots/video there!)
// - Wiki ....................... https://github.com/ocornut/imgui/wiki (lots of good stuff there)
//   - Getting Started            https://github.com/ocornut/imgui/wiki/Getting-Started (how to integrate in an existing app by adding ~25 lines of code)
//   - Third-party Extensions     https://github.com/ocornut/imgui/wiki/Useful-Extensions (ImPlot & many more)
//   - Bindings/Backends          https://github.com/ocornut/imgui/wiki/Bindings (language bindings, backends for various tech/engines)
//   - Glossary                   https://github.com/ocornut/imgui/wiki/Glossary
//   - Debug Tools                https://github.com/ocornut/imgui/wiki/Debug-Tools
//   - Software using Dear ImGui  https://github.com/ocornut/imgui/wiki/Software-using-dear-imgui
// - Issues & support ........... https://github.com/ocornut/imgui/issues
// - Test Engine & Automation ... https://github.com/ocornut/imgui_test_engine (test suite, test engine to automate your apps)

// For first-time users having issues compiling/linking/running/loading fonts:
// please post in https://github.com/ocornut/imgui/discussions if you cannot find a solution in resources above.
// Everything else should be asked in 'Issues'! We are building a database of cross-linked knowledge there.

// Library Version
// (Integer encoded as XYYZZ for use in #if preprocessor conditionals, e.g. '#if IMGUI_VERSION_NUM >= 12345')
IMGUI_VERSION :: "1.91.7 WIP"
IMGUI_VERSION_NUM :: 19164
IMGUI_HAS_TABLE :: true
IMGUI_HAS_VIEWPORT :: true// Viewport WIP branch
IMGUI_HAS_DOCK :: true// Docking WIP branch

/*

Index of this file:
// [SECTION] Header mess
// [SECTION] Forward declarations and basic types
// [SECTION] Dear ImGui end-user API functions
// [SECTION] Flags & Enumerations
// [SECTION] Tables API flags and structures (ImGuiTableFlags, ImGuiTableColumnFlags, ImGuiTableRowFlags, ImGuiTableBgTarget, ImGuiTableSortSpecs, ImGuiTableColumnSortSpecs)
// [SECTION] Helpers: Debug log, Memory allocations macros, ImVector<>
// [SECTION] ImGuiStyle
// [SECTION] ImGuiIO
// [SECTION] Misc data structures (ImGuiInputTextCallbackData, ImGuiSizeCallbackData, ImGuiWindowClass, ImGuiPayload)
// [SECTION] Helpers (ImGuiOnceUponAFrame, ImGuiTextFilter, ImGuiTextBuffer, ImGuiStorage, ImGuiListClipper, Math Operators, ImColor)
// [SECTION] Multi-Select API flags and structures (ImGuiMultiSelectFlags, ImGuiMultiSelectIO, ImGuiSelectionRequest, ImGuiSelectionBasicStorage, ImGuiSelectionExternalStorage)
// [SECTION] Drawing API (ImDrawCallback, ImDrawCmd, ImDrawIdx, ImDrawVert, ImDrawChannel, ImDrawListSplitter, ImDrawFlags, ImDrawListFlags, ImDrawList, ImDrawData)
// [SECTION] Font API (ImFontConfig, ImFontGlyph, ImFontGlyphRangesBuilder, ImFontAtlasFlags, ImFontAtlas, ImFont)
// [SECTION] Viewports (ImGuiViewportFlags, ImGuiViewport)
// [SECTION] ImGuiPlatformIO + other Platform Dependent Interfaces (ImGuiPlatformMonitor, ImGuiPlatformImeData)
// [SECTION] Obsolete functions and types

*/





//-----------------------------------------------------------------------------
// [SECTION] Header mess
//-----------------------------------------------------------------------------

// Helper Macros
IM_ASSERT :: #force_inline proc(_EXPR : bool, _e := #caller_expression(_EXPR), loc := #caller_location)
{
	assert(_EXPR, _e, loc)// You can override the default assert handler by editing imconfig.h
}

IM_ARRAYSIZE :: #force_inline proc "contextless" (_ARR : $T0) -> int where intrinsics.type_is_sliceable(T0) & !intrinsics.type_is_multi_pointer(T0)
{
	return len(_ARR)
}

IM_UNUSED :: #force_inline proc "contextless" (_VAR : $T0)
{
	_ = _VAR
}


// Check that version and structures layouts are matching between compiled imgui code and caller. Read comments above DebugCheckVersionAndDataLayout() for details.
CHECKVERSION :: #force_inline proc()
{
	DebugCheckVersionAndDataLayout(IMGUI_VERSION,size_of(ImGuiIO),size_of(ImGuiStyle),size_of(ImVec2),size_of(ImVec4),size_of(ImDrawVert),size_of(ImDrawIdx))
}


//-----------------------------------------------------------------------------
// [SECTION] Forward declarations and basic types
//-----------------------------------------------------------------------------

FLT_MAX :: max(f32)
FLT_MIN :: min(f32)
DBL_MAX :: max(f64)
DBL_MIN :: min(f64)
INT_MAX :: max(i32)
INT_MIN :: min(i32)

// Scalar data types
ImGuiID :: u32// A unique ID used by widgets (typically the result of hashing a stack of string)
ImS8 :: i8// 8-bit signed integer
ImU8 :: u8// 8-bit unsigned integer
ImS16 :: i16// 16-bit signed integer
ImU16 :: u16// 16-bit unsigned integer
ImS32 :: i32// 32-bit signed integer == int
ImU32 :: u32// 32-bit unsigned integer (often used to store packed colors)
ImS64 :: i64// 64-bit signed integer
ImU64 :: u64// 64-bit unsigned integer

ImGuiCol :: ImGuiCol_// -> enum ImGuiCol_             // Enum: A color identifier for styling
ImGuiCond :: ImGuiCond_// -> enum ImGuiCond_            // Enum: A condition for many Set*() functions
ImGuiDataType :: ImGuiDataType_// -> enum ImGuiDataType_        // Enum: A primary data type
ImGuiMouseButton :: ImGuiMouseButton_// -> enum ImGuiMouseButton_     // Enum: A mouse button identifier (0=left, 1=right, 2=middle)
ImGuiMouseCursor :: ImGuiMouseCursor_// -> enum ImGuiMouseCursor_     // Enum: A mouse cursor shape
ImGuiStyleVar :: ImGuiStyleVar_// -> enum ImGuiStyleVar_        // Enum: A variable identifier for styling
ImGuiTableBgTarget :: ImGuiTableBgTarget_// -> enum ImGuiTableBgTarget_   // Enum: A color target for TableSetBgColor()

// Flags (declared as int to allow using as flags without overhead, and to not pollute the top of this file)
// - Tip: Use your programming IDE navigation facilities on the names in the _central column_ below to find the actual flags/enum lists!
//   - In Visual Studio: CTRL+comma ("Edit.GoToAll") can follow symbols inside comments, whereas CTRL+F12 ("Edit.GoToImplementation") cannot.
//   - In Visual Studio w/ Visual Assist installed: ALT+G ("VAssistX.GoToImplementation") can also follow symbols inside comments.
//   - In VS Code, CLion, etc.: CTRL+click can follow symbols inside comments.
ImDrawFlags :: ImDrawFlags_// -> enum ImDrawFlags_          // Flags: for ImDrawList functions
ImDrawListFlags :: ImDrawListFlags_ // -> enum ImDrawListFlags_      // Flags: for ImDrawList instance
ImFontAtlasFlags :: ImFontAtlasFlags_// -> enum ImFontAtlasFlags_     // Flags: for ImFontAtlas build
ImGuiBackendFlags :: ImGuiBackendFlags_// -> enum ImGuiBackendFlags_    // Flags: for io.BackendFlags
ImGuiButtonFlags :: ImGuiButtonFlags_// -> enum ImGuiButtonFlags_     // Flags: for InvisibleButton()
ImGuiChildFlags :: ImGuiChildFlags_// -> enum ImGuiChildFlags_      // Flags: for BeginChild()
ImGuiColorEditFlags :: ImGuiColorEditFlags_// -> enum ImGuiColorEditFlags_  // Flags: for ColorEdit4(), ColorPicker4() etc.
ImGuiConfigFlags :: ImGuiConfigFlags_// -> enum ImGuiConfigFlags_     // Flags: for io.ConfigFlags
ImGuiComboFlags :: ImGuiComboFlags_ // -> enum ImGuiComboFlags_      // Flags: for BeginCombo()
ImGuiDockNodeFlags :: ImGuiDockNodeFlags_// -> enum ImGuiDockNodeFlags_   // Flags: for DockSpace()
ImGuiDragDropFlags :: ImGuiDragDropFlags_// -> enum ImGuiDragDropFlags_   // Flags: for BeginDragDropSource(), AcceptDragDropPayload()
ImGuiFocusedFlags :: ImGuiFocusedFlags_// -> enum ImGuiFocusedFlags_    // Flags: for IsWindowFocused()
ImGuiHoveredFlags :: ImGuiHoveredFlags_// -> enum ImGuiHoveredFlags_    // Flags: for IsItemHovered(), IsWindowHovered() etc.
ImGuiInputFlags :: ImGuiInputFlags_// -> enum ImGuiInputFlags_      // Flags: for Shortcut(), SetNextItemShortcut()
ImGuiInputTextFlags :: ImGuiInputTextFlags_// -> enum ImGuiInputTextFlags_  // Flags: for InputText(), InputTextMultiline()
ImGuiItemFlags :: ImGuiItemFlags_ // -> enum ImGuiItemFlags_       // Flags: for PushItemFlag(), shared by all items
ImGuiKeyChord :: ImGuiKey // -> ImGuiKey | ImGuiMod_XXX    // Flags: for IsKeyChordPressed(), Shortcut() etc. an ImGuiKey optionally OR-ed with one or more ImGuiMod_XXX values.
ImGuiPopupFlags :: ImGuiPopupFlags_// -> enum ImGuiPopupFlags_      // Flags: for OpenPopup*(), BeginPopupContext*(), IsPopupOpen()
ImGuiMultiSelectFlags :: ImGuiMultiSelectFlags_// -> enum ImGuiMultiSelectFlags_// Flags: for BeginMultiSelect()
ImGuiSelectableFlags :: ImGuiSelectableFlags_// -> enum ImGuiSelectableFlags_ // Flags: for Selectable()
ImGuiSliderFlags :: ImGuiSliderFlags_// -> enum ImGuiSliderFlags_     // Flags: for DragFloat(), DragInt(), SliderFloat(), SliderInt() etc.
ImGuiTabBarFlags :: ImGuiTabBarFlags_// -> enum ImGuiTabBarFlags_     // Flags: for BeginTabBar()
ImGuiTabItemFlags :: ImGuiTabItemFlags_// -> enum ImGuiTabItemFlags_    // Flags: for BeginTabItem()
ImGuiTableFlags :: ImGuiTableFlags_// -> enum ImGuiTableFlags_      // Flags: For BeginTable()
ImGuiTableColumnFlags :: ImGuiTableColumnFlags_// -> enum ImGuiTableColumnFlags_// Flags: For TableSetupColumn()
ImGuiTableRowFlags :: ImGuiTableRowFlags_// -> enum ImGuiTableRowFlags_   // Flags: For TableNextRow()
ImGuiTreeNodeFlags :: ImGuiTreeNodeFlags_ // -> enum ImGuiTreeNodeFlags_   // Flags: for TreeNode(), TreeNodeEx(), CollapsingHeader()
ImGuiViewportFlags :: ImGuiViewportFlags_// -> enum ImGuiViewportFlags_   // Flags: for ImGuiViewport
ImGuiWindowFlags :: ImGuiWindowFlags_ // -> enum ImGuiWindowFlags_     // Flags: for Begin(), BeginChild()

// ImTexture: user data for renderer backend to identify a texture [Compile-time configurable type]
// - To use something else than an opaque void* pointer: override with e.g. '#define ImTextureID MyTextureType*' in your imconfig.h file.
// - This can be whatever to you want it to be! read the FAQ about ImTextureID for details.
// - You can make this a structure with various constructors if you need. You will have to implement ==/!= operators.
// - (note: before v1.91.4 (2024/10/08) the default type for ImTextureID was void*. Use intermediary intptr_t cast and read FAQ if you have casting warnings)
//when ! defined ( ImTextureID ) {
ImTextureID :: ImU64// Default: store a pointer or an integer fitting in a pointer (most renderer backends are ok with that)
//} // preproc endif

// ImDrawIdx: vertex index. [Compile-time configurable type]
// - To use 16-bit indices + allow large meshes: backend need to set 'io.BackendFlags |= ImGuiBackendFlags_RendererHasVtxOffset' and handle ImDrawCmd::VtxOffset (recommended).
// - To use 32-bit indices: override with '#define ImDrawIdx unsigned int' in your imconfig.h file.
//when ! defined ( ImDrawIdx ) {
ImDrawIdx :: u16// Default: 16-bit (for maximum compatibility with renderer backends)
//} // preproc endif

// Character types
// (we generally use UTF-8 encoded string in the API. This is storage specifically for a decoded character used for keyboard input and display)
ImWchar32 :: u32// A single decoded U32 character/code point. We encode them as multi bytes UTF-8 when used in strings.
ImWchar16 :: u16// A single decoded U16 character/code point. We encode them as multi bytes UTF-8 when used in strings.
when IMGUI_USE_WCHAR32 { // ImWchar [configurable type: override in imconfig.h with '#define IMGUI_USE_WCHAR32' to support Unicode planes 1-16]
ImWchar :: ImWchar32
} else { // preproc else
ImWchar :: ImWchar16
} // preproc endif

// Multi-Selection item index or identifier when using BeginMultiSelect()
// - Used by SetNextItemSelectionUserData() + and inside ImGuiMultiSelectIO structure.
// - Most users are likely to use this store an item INDEX but this may be used to store a POINTER/ID as well. Read comments near ImGuiMultiSelectIO for details.
ImGuiSelectionUserData :: ImS64

// Callback and functions types
ImGuiInputTextCallback :: proc(data : ^ImGuiInputTextCallbackData) -> i32// Callback function for ImGui::InputText()
ImGuiSizeCallback :: proc(data : ^ImGuiSizeCallbackData)// Callback function for ImGui::SetNextWindowSizeConstraints()
ImGuiMemAllocFunc :: proc(sz : uint, user_data : rawptr) -> rawptr// Function signature for ImGui::SetAllocatorFunctions()
ImGuiMemFreeFunc :: proc(ptr : rawptr, user_data : rawptr)// Function signature for ImGui::SetAllocatorFunctions()

// ImVec2: 2D vector used to store positions, sizes etc. [Compile-time configurable type]

ImVec2 :: [2]f32

// ImVec4: 4D vector used to store clipping rectangles, colors etc. [Compile-time configurable type]
ImVec4 :: [4]f32

//-----------------------------------------------------------------------------
// [SECTION] Dear ImGui end-user API functions
// (Note that ImGui:: being a namespace, you can add extra ImGui:: functions in your own separate file. Please don't modify imgui source files!)
//-----------------------------------------------------------------------------

// namespace ImGui

//-----------------------------------------------------------------------------
// [SECTION] Flags & Enumerations
//-----------------------------------------------------------------------------

// Flags for ImGui::Begin()
// (Those are per-window flags. There are shared flags in ImGuiIO: io.ConfigWindowsResizeFromEdges and io.ConfigWindowsMoveFromTitleBarOnly)
ImGuiWindowFlags_ :: enum i32 {
	ImGuiWindowFlags_None = 0,
	ImGuiWindowFlags_NoTitleBar = 1 << 0, // Disable title-bar
	ImGuiWindowFlags_NoResize = 1 << 1, // Disable user resizing with the lower-right grip
	ImGuiWindowFlags_NoMove = 1 << 2, // Disable user moving the window
	ImGuiWindowFlags_NoScrollbar = 1 << 3, // Disable scrollbars (window can still scroll with mouse or programmatically)
	ImGuiWindowFlags_NoScrollWithMouse = 1 << 4, // Disable user vertically scrolling with mouse wheel. On child window, mouse wheel will be forwarded to the parent unless NoScrollbar is also set.
	ImGuiWindowFlags_NoCollapse = 1 << 5, // Disable user collapsing window by double-clicking on it. Also referred to as Window Menu Button (e.g. within a docking node).
	ImGuiWindowFlags_AlwaysAutoResize = 1 << 6, // Resize every window to its content every frame
	ImGuiWindowFlags_NoBackground = 1 << 7, // Disable drawing background color (WindowBg, etc.) and outside border. Similar as using SetNextWindowBgAlpha(0.0f).
	ImGuiWindowFlags_NoSavedSettings = 1 << 8, // Never load/save settings in .ini file
	ImGuiWindowFlags_NoMouseInputs = 1 << 9, // Disable catching mouse, hovering test with pass through.
	ImGuiWindowFlags_MenuBar = 1 << 10, // Has a menu-bar
	ImGuiWindowFlags_HorizontalScrollbar = 1 << 11, // Allow horizontal scrollbar to appear (off by default). You may use SetNextWindowContentSize(ImVec2{width,0.0f}); prior to calling Begin() to specify width. Read code in imgui_demo in the "Horizontal Scrolling" section.
	ImGuiWindowFlags_NoFocusOnAppearing = 1 << 12, // Disable taking focus when transitioning from hidden to visible state
	ImGuiWindowFlags_NoBringToFrontOnFocus = 1 << 13, // Disable bringing window to front when taking focus (e.g. clicking on it or programmatically giving it focus)
	ImGuiWindowFlags_AlwaysVerticalScrollbar = 1 << 14, // Always show vertical scrollbar (even if ContentSize.y < Size.y)
	ImGuiWindowFlags_AlwaysHorizontalScrollbar = 1 << 15, // Always show horizontal scrollbar (even if ContentSize.x < Size.x)
	ImGuiWindowFlags_NoNavInputs = 1 << 16, // No keyboard/gamepad navigation within the window
	ImGuiWindowFlags_NoNavFocus = 1 << 17, // No focusing toward this window with keyboard/gamepad navigation (e.g. skipped by CTRL+TAB)
	ImGuiWindowFlags_UnsavedDocument = 1 << 18, // Display a dot next to the title. When used in a tab/docking context, tab is selected when clicking the X + closure is not assumed (will wait for user to stop submitting the tab). Otherwise closure is assumed when pressing the X, so if you keep submitting the tab may reappear at end of tab bar.
	ImGuiWindowFlags_NoDocking = 1 << 19, // Disable docking of this window
	ImGuiWindowFlags_NoNav = ImGuiWindowFlags_NoNavInputs | ImGuiWindowFlags_NoNavFocus,
	ImGuiWindowFlags_NoDecoration = ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_NoCollapse,
	ImGuiWindowFlags_NoInputs = ImGuiWindowFlags_NoMouseInputs | ImGuiWindowFlags_NoNavInputs | ImGuiWindowFlags_NoNavFocus,

	// [Internal]
	ImGuiWindowFlags_ChildWindow = 1 << 24, // Don't use! For internal use by BeginChild()
	ImGuiWindowFlags_Tooltip = 1 << 25, // Don't use! For internal use by BeginTooltip()
	ImGuiWindowFlags_Popup = 1 << 26, // Don't use! For internal use by BeginPopup()
	ImGuiWindowFlags_Modal = 1 << 27, // Don't use! For internal use by BeginPopupModal()
	ImGuiWindowFlags_ChildMenu = 1 << 28, // Don't use! For internal use by BeginMenu()
	ImGuiWindowFlags_DockNodeHost = 1 << 29, // Don't use! For internal use by Begin()/NewFrame()
}

// Flags for ImGui::BeginChild()
// (Legacy: bit 0 must always correspond to ImGuiChildFlags_Borders to be backward compatible with old API using 'bool border = false'.
// About using AutoResizeX/AutoResizeY flags:
// - May be combined with SetNextWindowSizeConstraints() to set a min/max size for each axis (see "Demo->Child->Auto-resize with Constraints").
// - Size measurement for a given axis is only performed when the child window is within visible boundaries, or is just appearing.
//   - This allows BeginChild() to return false when not within boundaries (e.g. when scrolling), which is more optimal. BUT it won't update its auto-size while clipped.
//     While not perfect, it is a better default behavior as the always-on performance gain is more valuable than the occasional "resizing after becoming visible again" glitch.
//   - You may also use ImGuiChildFlags_AlwaysAutoResize to force an update even when child window is not in view.
//     HOWEVER PLEASE UNDERSTAND THAT DOING SO WILL PREVENT BeginChild() FROM EVER RETURNING FALSE, disabling benefits of coarse clipping.
ImGuiChildFlags_ :: enum i32 {
	ImGuiChildFlags_None = 0,
	ImGuiChildFlags_Borders = 1 << 0, // Show an outer border and enable WindowPadding. (IMPORTANT: this is always == 1 == true for legacy reason)
	ImGuiChildFlags_AlwaysUseWindowPadding = 1 << 1, // Pad with style.WindowPadding even if no border are drawn (no padding by default for non-bordered child windows because it makes more sense)
	ImGuiChildFlags_ResizeX = 1 << 2, // Allow resize from right border (layout direction). Enable .ini saving (unless ImGuiWindowFlags_NoSavedSettings passed to window flags)
	ImGuiChildFlags_ResizeY = 1 << 3, // Allow resize from bottom border (layout direction). "
	ImGuiChildFlags_AutoResizeX = 1 << 4, // Enable auto-resizing width. Read "IMPORTANT: Size measurement" details above.
	ImGuiChildFlags_AutoResizeY = 1 << 5, // Enable auto-resizing height. Read "IMPORTANT: Size measurement" details above.
	ImGuiChildFlags_AlwaysAutoResize = 1 << 6, // Combined with AutoResizeX/AutoResizeY. Always measure size even when child is hidden, always return true, always disable clipping optimization! NOT RECOMMENDED.
	ImGuiChildFlags_FrameStyle = 1 << 7, // Style the child window like a framed item: use FrameBg, FrameRounding, FrameBorderSize, FramePadding instead of ChildBg, ChildRounding, ChildBorderSize, WindowPadding.
	ImGuiChildFlags_NavFlattened = 1 << 8, // [BETA] Share focus scope, allow keyboard/gamepad navigation to cross over parent border to this child or between sibling child windows.
}

// Flags for ImGui::PushItemFlag()
// (Those are shared by all items)
ImGuiItemFlags_ :: enum i32 {
	ImGuiItemFlags_None = 0, // (Default)
	ImGuiItemFlags_NoTabStop = 1 << 0, // false    // Disable keyboard tabbing. This is a "lighter" version of ImGuiItemFlags_NoNav.
	ImGuiItemFlags_NoNav = 1 << 1, // false    // Disable any form of focusing (keyboard/gamepad directional navigation and SetKeyboardFocusHere() calls).
	ImGuiItemFlags_NoNavDefaultFocus = 1 << 2, // false    // Disable item being a candidate for default focus (e.g. used by title bar items).
	ImGuiItemFlags_ButtonRepeat = 1 << 3, // false    // Any button-like behavior will have repeat mode enabled (based on io.KeyRepeatDelay and io.KeyRepeatRate values). Note that you can also call IsItemActive() after any button to tell if it is being held.
	ImGuiItemFlags_AutoClosePopups = 1 << 4, // true     // MenuItem()/Selectable() automatically close their parent popup window.
	ImGuiItemFlags_AllowDuplicateId = 1 << 5, // false    // Allow submitting an item with the same identifier as an item already submitted this frame without triggering a warning tooltip if io.ConfigDebugHighlightIdConflicts is set.
}

// Flags for ImGui::InputText()
// (Those are per-item flags. There are shared flags in ImGuiIO: io.ConfigInputTextCursorBlink and io.ConfigInputTextEnterKeepActive)
ImGuiInputTextFlags_ :: enum i32 {
	// Basic filters (also see ImGuiInputTextFlags_CallbackCharFilter)
	ImGuiInputTextFlags_None = 0,
	ImGuiInputTextFlags_CharsDecimal = 1 << 0, // Allow 0123456789.+-*/
	ImGuiInputTextFlags_CharsHexadecimal = 1 << 1, // Allow 0123456789ABCDEFabcdef
	ImGuiInputTextFlags_CharsScientific = 1 << 2, // Allow 0123456789.+-*/eE (Scientific notation input)
	ImGuiInputTextFlags_CharsUppercase = 1 << 3, // Turn a..z into A..Z
	ImGuiInputTextFlags_CharsNoBlank = 1 << 4, // Filter out spaces, tabs

	// Inputs
	ImGuiInputTextFlags_AllowTabInput = 1 << 5, // Pressing TAB input a '\t' character into the text field
	ImGuiInputTextFlags_EnterReturnsTrue = 1 << 6, // Return 'true' when Enter is pressed (as opposed to every time the value was modified). Consider using IsItemDeactivatedAfterEdit() instead!
	ImGuiInputTextFlags_EscapeClearsAll = 1 << 7, // Escape key clears content if not empty, and deactivate otherwise (contrast to default behavior of Escape to revert)
	ImGuiInputTextFlags_CtrlEnterForNewLine = 1 << 8, // In multi-line mode, validate with Enter, add new line with Ctrl+Enter (default is opposite: validate with Ctrl+Enter, add line with Enter).

	// Other options
	ImGuiInputTextFlags_ReadOnly = 1 << 9, // Read-only mode
	ImGuiInputTextFlags_Password = 1 << 10, // Password mode, display all characters as '*', disable copy
	ImGuiInputTextFlags_AlwaysOverwrite = 1 << 11, // Overwrite mode
	ImGuiInputTextFlags_AutoSelectAll = 1 << 12, // Select entire text when first taking mouse focus
	ImGuiInputTextFlags_ParseEmptyRefVal = 1 << 13, // InputFloat(), InputInt(), InputScalar() etc. only: parse empty string as zero value.
	ImGuiInputTextFlags_DisplayEmptyRefVal = 1 << 14, // InputFloat(), InputInt(), InputScalar() etc. only: when value is zero, do not display it. Generally used with ImGuiInputTextFlags_ParseEmptyRefVal.
	ImGuiInputTextFlags_NoHorizontalScroll = 1 << 15, // Disable following the cursor horizontally
	ImGuiInputTextFlags_NoUndoRedo = 1 << 16, // Disable undo/redo. Note that input text owns the text data while active, if you want to provide your own undo/redo stack you need e.g. to call ClearActiveID().

	// Elide display / Alignment
	ImGuiInputTextFlags_ElideLeft = 1 << 17, // When text doesn't fit, elide left side to ensure right side stays visible. Useful for path/filenames. Single-line only!

	// Callback features
	ImGuiInputTextFlags_CallbackCompletion = 1 << 18, // Callback on pressing TAB (for completion handling)
	ImGuiInputTextFlags_CallbackHistory = 1 << 19, // Callback on pressing Up/Down arrows (for history handling)
	ImGuiInputTextFlags_CallbackAlways = 1 << 20, // Callback on each iteration. User code may query cursor position, modify text buffer.
	ImGuiInputTextFlags_CallbackCharFilter = 1 << 21, // Callback on character inputs to replace or discard them. Modify 'EventChar' to replace or discard, or return 1 in callback to discard.
	ImGuiInputTextFlags_CallbackResize = 1 << 22, // Callback on buffer capacity changes request (beyond 'buf_size' parameter value), allowing the string to grow. Notify when the string wants to be resized (for string types which hold a cache of their Size). You will be provided a new BufSize in the callback and NEED to honor it. (see misc/cpp/imgui_stdlib.h for an example of using this)
	ImGuiInputTextFlags_CallbackEdit = 1 << 23, // Callback on any edit (note that InputText() already returns true on edit, the callback is useful mainly to manipulate the underlying buffer while focus is active)

	// Obsolete names
	//ImGuiInputTextFlags_AlwaysInsertMode  = ImGuiInputTextFlags_AlwaysOverwrite   // [renamed in 1.82] name was not matching behavior
}

// Flags for ImGui::TreeNodeEx(), ImGui::CollapsingHeader*()
ImGuiTreeNodeFlags_ :: enum i32 {
	ImGuiTreeNodeFlags_None = 0,
	ImGuiTreeNodeFlags_Selected = 1 << 0, // Draw as selected
	ImGuiTreeNodeFlags_Framed = 1 << 1, // Draw frame with background (e.g. for CollapsingHeader)
	ImGuiTreeNodeFlags_AllowOverlap = 1 << 2, // Hit testing to allow subsequent widgets to overlap this one
	ImGuiTreeNodeFlags_NoTreePushOnOpen = 1 << 3, // Don't do a TreePush() when open (e.g. for CollapsingHeader) = no extra indent nor pushing on ID stack
	ImGuiTreeNodeFlags_NoAutoOpenOnLog = 1 << 4, // Don't automatically and temporarily open node when Logging is active (by default logging will automatically open tree nodes)
	ImGuiTreeNodeFlags_DefaultOpen = 1 << 5, // Default node to be open
	ImGuiTreeNodeFlags_OpenOnDoubleClick = 1 << 6, // Open on double-click instead of simple click (default for multi-select unless any _OpenOnXXX behavior is set explicitly). Both behaviors may be combined.
	ImGuiTreeNodeFlags_OpenOnArrow = 1 << 7, // Open when clicking on the arrow part (default for multi-select unless any _OpenOnXXX behavior is set explicitly). Both behaviors may be combined.
	ImGuiTreeNodeFlags_Leaf = 1 << 8, // No collapsing, no arrow (use as a convenience for leaf nodes).
	ImGuiTreeNodeFlags_Bullet = 1 << 9, // Display a bullet instead of arrow. IMPORTANT: node can still be marked open/close if you don't set the _Leaf flag!
	ImGuiTreeNodeFlags_FramePadding = 1 << 10, // Use FramePadding (even for an unframed text node) to vertically align text baseline to regular widget height. Equivalent to calling AlignTextToFramePadding() before the node.
	ImGuiTreeNodeFlags_SpanAvailWidth = 1 << 11, // Extend hit box to the right-most edge, even if not framed. This is not the default in order to allow adding other items on the same line without using AllowOverlap mode.
	ImGuiTreeNodeFlags_SpanFullWidth = 1 << 12, // Extend hit box to the left-most and right-most edges (cover the indent area).
	ImGuiTreeNodeFlags_SpanTextWidth = 1 << 13, // Narrow hit box + narrow hovering highlight, will only cover the label text.
	ImGuiTreeNodeFlags_SpanAllColumns = 1 << 14, // Frame will span all columns of its container table (text will still fit in current column)
	ImGuiTreeNodeFlags_NavLeftJumpsBackHere = 1 << 15, // (WIP) Nav: left direction may move to this TreeNode() from any of its child (items submitted between TreeNode and TreePop)
	//ImGuiTreeNodeFlags_NoScrollOnOpen     = 1 << 16,  // FIXME: TODO: Disable automatic scroll on TreePop() if node got just open and contents is not visible
	ImGuiTreeNodeFlags_CollapsingHeader = ImGuiTreeNodeFlags_Framed | ImGuiTreeNodeFlags_NoTreePushOnOpen | ImGuiTreeNodeFlags_NoAutoOpenOnLog,
}

// Flags for OpenPopup*(), BeginPopupContext*(), IsPopupOpen() functions.
// - To be backward compatible with older API which took an 'int mouse_button = 1' argument instead of 'ImGuiPopupFlags flags',
//   we need to treat small flags values as a mouse button index, so we encode the mouse button in the first few bits of the flags.
//   It is therefore guaranteed to be legal to pass a mouse button index in ImGuiPopupFlags.
// - For the same reason, we exceptionally default the ImGuiPopupFlags argument of BeginPopupContextXXX functions to 1 instead of 0.
//   IMPORTANT: because the default parameter is 1 (==ImGuiPopupFlags_MouseButtonRight), if you rely on the default parameter
//   and want to use another flag, you need to pass in the ImGuiPopupFlags_MouseButtonRight flag explicitly.
// - Multiple buttons currently cannot be combined/or-ed in those functions (we could allow it later).
ImGuiPopupFlags_ :: enum i32 {
	ImGuiPopupFlags_None = 0,
	ImGuiPopupFlags_MouseButtonLeft = 0, // For BeginPopupContext*(): open on Left Mouse release. Guaranteed to always be == 0 (same as ImGuiMouseButton_Left)
	ImGuiPopupFlags_MouseButtonRight = 1, // For BeginPopupContext*(): open on Right Mouse release. Guaranteed to always be == 1 (same as ImGuiMouseButton_Right)
	ImGuiPopupFlags_MouseButtonMiddle = 2, // For BeginPopupContext*(): open on Middle Mouse release. Guaranteed to always be == 2 (same as ImGuiMouseButton_Middle)
	ImGuiPopupFlags_MouseButtonMask_ = 0x1F,
	ImGuiPopupFlags_MouseButtonDefault_ = 1,
	ImGuiPopupFlags_NoReopen = 1 << 5, // For OpenPopup*(), BeginPopupContext*(): don't reopen same popup if already open (won't reposition, won't reinitialize navigation)
	//ImGuiPopupFlags_NoReopenAlwaysNavInit = 1 << 6,   // For OpenPopup*(), BeginPopupContext*(): focus and initialize navigation even when not reopening.
	ImGuiPopupFlags_NoOpenOverExistingPopup = 1 << 7, // For OpenPopup*(), BeginPopupContext*(): don't open if there's already a popup at the same level of the popup stack
	ImGuiPopupFlags_NoOpenOverItems = 1 << 8, // For BeginPopupContextWindow(): don't return true when hovering items, only when hovering empty space
	ImGuiPopupFlags_AnyPopupId = 1 << 10, // For IsPopupOpen(): ignore the ImGuiID parameter and test for any popup.
	ImGuiPopupFlags_AnyPopupLevel = 1 << 11, // For IsPopupOpen(): search/test at any level of the popup stack (default test in the current level)
	ImGuiPopupFlags_AnyPopup = ImGuiPopupFlags_AnyPopupId | ImGuiPopupFlags_AnyPopupLevel,
}

// Flags for ImGui::Selectable()
ImGuiSelectableFlags_ :: enum i32 {
	ImGuiSelectableFlags_None = 0,
	ImGuiSelectableFlags_NoAutoClosePopups = 1 << 0, // Clicking this doesn't close parent popup window (overrides ImGuiItemFlags_AutoClosePopups)
	ImGuiSelectableFlags_SpanAllColumns = 1 << 1, // Frame will span all columns of its container table (text will still fit in current column)
	ImGuiSelectableFlags_AllowDoubleClick = 1 << 2, // Generate press events on double clicks too
	ImGuiSelectableFlags_Disabled = 1 << 3, // Cannot be selected, display grayed out text
	ImGuiSelectableFlags_AllowOverlap = 1 << 4, // (WIP) Hit testing to allow subsequent widgets to overlap this one
	ImGuiSelectableFlags_Highlight = 1 << 5, // Make the item be displayed as if it is hovered
}

// Flags for ImGui::BeginCombo()
ImGuiComboFlags_ :: enum i32 {
	ImGuiComboFlags_None = 0,
	ImGuiComboFlags_PopupAlignLeft = 1 << 0, // Align the popup toward the left by default
	ImGuiComboFlags_HeightSmall = 1 << 1, // Max ~4 items visible. Tip: If you want your combo popup to be a specific size you can use SetNextWindowSizeConstraints() prior to calling BeginCombo()
	ImGuiComboFlags_HeightRegular = 1 << 2, // Max ~8 items visible (default)
	ImGuiComboFlags_HeightLarge = 1 << 3, // Max ~20 items visible
	ImGuiComboFlags_HeightLargest = 1 << 4, // As many fitting items as possible
	ImGuiComboFlags_NoArrowButton = 1 << 5, // Display on the preview box without the square arrow button
	ImGuiComboFlags_NoPreview = 1 << 6, // Display only a square arrow button
	ImGuiComboFlags_WidthFitPreview = 1 << 7, // Width dynamically calculated from preview contents
	ImGuiComboFlags_HeightMask_ = ImGuiComboFlags_HeightSmall | ImGuiComboFlags_HeightRegular | ImGuiComboFlags_HeightLarge | ImGuiComboFlags_HeightLargest,
}

// Flags for ImGui::BeginTabBar()
ImGuiTabBarFlags_ :: enum i32 {
	ImGuiTabBarFlags_None = 0,
	ImGuiTabBarFlags_Reorderable = 1 << 0, // Allow manually dragging tabs to re-order them + New tabs are appended at the end of list
	ImGuiTabBarFlags_AutoSelectNewTabs = 1 << 1, // Automatically select new tabs when they appear
	ImGuiTabBarFlags_TabListPopupButton = 1 << 2, // Disable buttons to open the tab list popup
	ImGuiTabBarFlags_NoCloseWithMiddleMouseButton = 1 << 3, // Disable behavior of closing tabs (that are submitted with p_open != NULL) with middle mouse button. You may handle this behavior manually on user's side with if (IsItemHovered() && IsMouseClicked(cast(ImGuiMouseButton) 2)) *p_open = false.
	ImGuiTabBarFlags_NoTabListScrollingButtons = 1 << 4, // Disable scrolling buttons (apply when fitting policy is ImGuiTabBarFlags_FittingPolicyScroll)
	ImGuiTabBarFlags_NoTooltip = 1 << 5, // Disable tooltips when hovering a tab
	ImGuiTabBarFlags_DrawSelectedOverline = 1 << 6, // Draw selected overline markers over selected tab
	ImGuiTabBarFlags_FittingPolicyResizeDown = 1 << 7, // Resize tabs when they don't fit
	ImGuiTabBarFlags_FittingPolicyScroll = 1 << 8, // Add scroll buttons when tabs don't fit
	ImGuiTabBarFlags_FittingPolicyMask_ = ImGuiTabBarFlags_FittingPolicyResizeDown | ImGuiTabBarFlags_FittingPolicyScroll,
	ImGuiTabBarFlags_FittingPolicyDefault_ = ImGuiTabBarFlags_FittingPolicyResizeDown,
}

// Flags for ImGui::BeginTabItem()
ImGuiTabItemFlags_ :: enum i32 {
	ImGuiTabItemFlags_None = 0,
	ImGuiTabItemFlags_UnsavedDocument = 1 << 0, // Display a dot next to the title + set ImGuiTabItemFlags_NoAssumedClosure.
	ImGuiTabItemFlags_SetSelected = 1 << 1, // Trigger flag to programmatically make the tab selected when calling BeginTabItem()
	ImGuiTabItemFlags_NoCloseWithMiddleMouseButton = 1 << 2, // Disable behavior of closing tabs (that are submitted with p_open != NULL) with middle mouse button. You may handle this behavior manually on user's side with if (IsItemHovered() && IsMouseClicked(cast(ImGuiMouseButton) 2)) *p_open = false.
	ImGuiTabItemFlags_NoPushId = 1 << 3, // Don't call PushID()/PopID() on BeginTabItem()/EndTabItem()
	ImGuiTabItemFlags_NoTooltip = 1 << 4, // Disable tooltip for the given tab
	ImGuiTabItemFlags_NoReorder = 1 << 5, // Disable reordering this tab or having another tab cross over this tab
	ImGuiTabItemFlags_Leading = 1 << 6, // Enforce the tab position to the left of the tab bar (after the tab list popup button)
	ImGuiTabItemFlags_Trailing = 1 << 7, // Enforce the tab position to the right of the tab bar (before the scrolling buttons)
	ImGuiTabItemFlags_NoAssumedClosure = 1 << 8, // Tab is selected when trying to close + closure is not immediately assumed (will wait for user to stop submitting the tab). Otherwise closure is assumed when pressing the X, so if you keep submitting the tab may reappear at end of tab bar.
}

// Flags for ImGui::IsWindowFocused()
ImGuiFocusedFlags_ :: enum i32 {
	ImGuiFocusedFlags_None = 0,
	ImGuiFocusedFlags_ChildWindows = 1 << 0, // Return true if any children of the window is focused
	ImGuiFocusedFlags_RootWindow = 1 << 1, // Test from root window (top most parent of the current hierarchy)
	ImGuiFocusedFlags_AnyWindow = 1 << 2, // Return true if any window is focused. Important: If you are trying to tell how to dispatch your low-level inputs, do NOT use this. Use 'io.WantCaptureMouse' instead! Please read the FAQ!
	ImGuiFocusedFlags_NoPopupHierarchy = 1 << 3, // Do not consider popup hierarchy (do not treat popup emitter as parent of popup) (when used with _ChildWindows or _RootWindow)
	ImGuiFocusedFlags_DockHierarchy = 1 << 4, // Consider docking hierarchy (treat dockspace host as parent of docked window) (when used with _ChildWindows or _RootWindow)
	ImGuiFocusedFlags_RootAndChildWindows = ImGuiFocusedFlags_RootWindow | ImGuiFocusedFlags_ChildWindows,
}

// Flags for ImGui::IsItemHovered(), ImGui::IsWindowHovered()
// Note: if you are trying to check whether your mouse should be dispatched to Dear ImGui or to your app, you should use 'io.WantCaptureMouse' instead! Please read the FAQ!
// Note: windows with the ImGuiWindowFlags_NoInputs flag are ignored by IsWindowHovered() calls.
ImGuiHoveredFlags_ :: enum i32 {
	ImGuiHoveredFlags_None = 0, // Return true if directly over the item/window, not obstructed by another window, not obstructed by an active popup or modal blocking inputs under them.
	ImGuiHoveredFlags_ChildWindows = 1 << 0, // IsWindowHovered() only: Return true if any children of the window is hovered
	ImGuiHoveredFlags_RootWindow = 1 << 1, // IsWindowHovered() only: Test from root window (top most parent of the current hierarchy)
	ImGuiHoveredFlags_AnyWindow = 1 << 2, // IsWindowHovered() only: Return true if any window is hovered
	ImGuiHoveredFlags_NoPopupHierarchy = 1 << 3, // IsWindowHovered() only: Do not consider popup hierarchy (do not treat popup emitter as parent of popup) (when used with _ChildWindows or _RootWindow)
	ImGuiHoveredFlags_DockHierarchy = 1 << 4, // IsWindowHovered() only: Consider docking hierarchy (treat dockspace host as parent of docked window) (when used with _ChildWindows or _RootWindow)
	ImGuiHoveredFlags_AllowWhenBlockedByPopup = 1 << 5, // Return true even if a popup window is normally blocking access to this item/window
	//ImGuiHoveredFlags_AllowWhenBlockedByModal     = 1 << 6,   // Return true even if a modal popup window is normally blocking access to this item/window. FIXME-TODO: Unavailable yet.
	ImGuiHoveredFlags_AllowWhenBlockedByActiveItem = 1 << 7, // Return true even if an active item is blocking access to this item/window. Useful for Drag and Drop patterns.
	ImGuiHoveredFlags_AllowWhenOverlappedByItem = 1 << 8, // IsItemHovered() only: Return true even if the item uses AllowOverlap mode and is overlapped by another hoverable item.
	ImGuiHoveredFlags_AllowWhenOverlappedByWindow = 1 << 9, // IsItemHovered() only: Return true even if the position is obstructed or overlapped by another window.
	ImGuiHoveredFlags_AllowWhenDisabled = 1 << 10, // IsItemHovered() only: Return true even if the item is disabled
	ImGuiHoveredFlags_NoNavOverride = 1 << 11, // IsItemHovered() only: Disable using keyboard/gamepad navigation state when active, always query mouse
	ImGuiHoveredFlags_AllowWhenOverlapped = ImGuiHoveredFlags_AllowWhenOverlappedByItem | ImGuiHoveredFlags_AllowWhenOverlappedByWindow,
	ImGuiHoveredFlags_RectOnly = ImGuiHoveredFlags_AllowWhenBlockedByPopup | ImGuiHoveredFlags_AllowWhenBlockedByActiveItem | ImGuiHoveredFlags_AllowWhenOverlapped,
	ImGuiHoveredFlags_RootAndChildWindows = ImGuiHoveredFlags_RootWindow | ImGuiHoveredFlags_ChildWindows,

	// Tooltips mode
	// - typically used in IsItemHovered() + SetTooltip() sequence.
	// - this is a shortcut to pull flags from 'style.HoverFlagsForTooltipMouse' or 'style.HoverFlagsForTooltipNav' where you can reconfigure desired behavior.
	//   e.g. 'TooltipHoveredFlagsForMouse' defaults to 'ImGuiHoveredFlags_Stationary | ImGuiHoveredFlags_DelayShort'.
	// - for frequently actioned or hovered items providing a tooltip, you want may to use ImGuiHoveredFlags_ForTooltip (stationary + delay) so the tooltip doesn't show too often.
	// - for items which main purpose is to be hovered, or items with low affordance, or in less consistent apps, prefer no delay or shorter delay.
	ImGuiHoveredFlags_ForTooltip = 1 << 12, // Shortcut for standard flags when using IsItemHovered() + SetTooltip() sequence.

	// (Advanced) Mouse Hovering delays.
	// - generally you can use ImGuiHoveredFlags_ForTooltip to use application-standardized flags.
	// - use those if you need specific overrides.
	ImGuiHoveredFlags_Stationary = 1 << 13, // Require mouse to be stationary for style.HoverStationaryDelay (~0.15 sec) _at least one time_. After this, can move on same item/window. Using the stationary test tends to reduces the need for a long delay.
	ImGuiHoveredFlags_DelayNone = 1 << 14, // IsItemHovered() only: Return true immediately (default). As this is the default you generally ignore this.
	ImGuiHoveredFlags_DelayShort = 1 << 15, // IsItemHovered() only: Return true after style.HoverDelayShort elapsed (~0.15 sec) (shared between items) + requires mouse to be stationary for style.HoverStationaryDelay (once per item).
	ImGuiHoveredFlags_DelayNormal = 1 << 16, // IsItemHovered() only: Return true after style.HoverDelayNormal elapsed (~0.40 sec) (shared between items) + requires mouse to be stationary for style.HoverStationaryDelay (once per item).
	ImGuiHoveredFlags_NoSharedDelay = 1 << 17, // IsItemHovered() only: Disable shared delay system where moving from one item to the next keeps the previous timer for a short time (standard for tooltips with long delays)
}

// Flags for ImGui::DockSpace(), shared/inherited by child nodes.
// (Some flags can be applied to individual nodes directly)
// FIXME-DOCK: Also see ImGuiDockNodeFlagsPrivate_ which may involve using the WIP and internal DockBuilder api.
ImGuiDockNodeFlags_ :: enum i32 {
	ImGuiDockNodeFlags_None = 0,
	ImGuiDockNodeFlags_KeepAliveOnly = 1 << 0, //       // Don't display the dockspace node but keep it alive. Windows docked into this dockspace node won't be undocked.
	//ImGuiDockNodeFlags_NoCentralNode              = 1 << 1,   //       // Disable Central Node (the node which can stay empty)
	ImGuiDockNodeFlags_NoDockingOverCentralNode = 1 << 2, //       // Disable docking over the Central Node, which will be always kept empty.
	ImGuiDockNodeFlags_PassthruCentralNode = 1 << 3, //       // Enable passthru dockspace: 1) DockSpace() will render a ImGuiCol_WindowBg background covering everything excepted the Central Node when empty. Meaning the host window should probably use SetNextWindowBgAlpha(0.0f) prior to Begin() when using this. 2) When Central Node is empty: let inputs pass-through + won't display a DockingEmptyBg background. See demo for details.
	ImGuiDockNodeFlags_NoDockingSplit = 1 << 4, //       // Disable other windows/nodes from splitting this node.
	ImGuiDockNodeFlags_NoResize = 1 << 5, // Saved // Disable resizing node using the splitter/separators. Useful with programmatically setup dockspaces.
	ImGuiDockNodeFlags_AutoHideTabBar = 1 << 6, //       // Tab bar will automatically hide when there is a single window in the dock node.
	ImGuiDockNodeFlags_NoUndocking = 1 << 7, //       // Disable undocking this node.
}

// Flags for ImGui::BeginDragDropSource(), ImGui::AcceptDragDropPayload()
ImGuiDragDropFlags_ :: enum i32 {
	ImGuiDragDropFlags_None = 0,
	// BeginDragDropSource() flags
	ImGuiDragDropFlags_SourceNoPreviewTooltip = 1 << 0, // Disable preview tooltip. By default, a successful call to BeginDragDropSource opens a tooltip so you can display a preview or description of the source contents. This flag disables this behavior.
	ImGuiDragDropFlags_SourceNoDisableHover = 1 << 1, // By default, when dragging we clear data so that IsItemHovered() will return false, to avoid subsequent user code submitting tooltips. This flag disables this behavior so you can still call IsItemHovered() on the source item.
	ImGuiDragDropFlags_SourceNoHoldToOpenOthers = 1 << 2, // Disable the behavior that allows to open tree nodes and collapsing header by holding over them while dragging a source item.
	ImGuiDragDropFlags_SourceAllowNullID = 1 << 3, // Allow items such as Text(), Image() that have no unique identifier to be used as drag source, by manufacturing a temporary identifier based on their window-relative position. This is extremely unusual within the dear imgui ecosystem and so we made it explicit.
	ImGuiDragDropFlags_SourceExtern = 1 << 4, // External source (from outside of dear imgui), won't attempt to read current item/window info. Will always return true. Only one Extern source can be active simultaneously.
	ImGuiDragDropFlags_PayloadAutoExpire = 1 << 5, // Automatically expire the payload if the source cease to be submitted (otherwise payloads are persisting while being dragged)
	ImGuiDragDropFlags_PayloadNoCrossContext = 1 << 6, // Hint to specify that the payload may not be copied outside current dear imgui context.
	ImGuiDragDropFlags_PayloadNoCrossProcess = 1 << 7, // Hint to specify that the payload may not be copied outside current process.
	// AcceptDragDropPayload() flags
	ImGuiDragDropFlags_AcceptBeforeDelivery = 1 << 10, // AcceptDragDropPayload() will returns true even before the mouse button is released. You can then call IsDelivery() to test if the payload needs to be delivered.
	ImGuiDragDropFlags_AcceptNoDrawDefaultRect = 1 << 11, // Do not draw the default highlight rectangle when hovering over target.
	ImGuiDragDropFlags_AcceptNoPreviewTooltip = 1 << 12, // Request hiding the BeginDragDropSource tooltip from the BeginDragDropTarget site.
	ImGuiDragDropFlags_AcceptPeekOnly = ImGuiDragDropFlags_AcceptBeforeDelivery | ImGuiDragDropFlags_AcceptNoDrawDefaultRect, // For peeking ahead and inspecting the payload before delivery.
}

// Standard Drag and Drop payload types. You can define you own payload types using short strings. Types starting with '_' are defined by Dear ImGui.
IMGUI_PAYLOAD_TYPE_COLOR_3F :: "_COL3F"// float[3]: Standard type for colors, without alpha. User code may use this type.
IMGUI_PAYLOAD_TYPE_COLOR_4F :: "_COL4F"// float[4]: Standard type for colors. User code may use this type.

// A primary data type
ImGuiDataType_ :: enum i32 {
	ImGuiDataType_S8, // signed char / char (with sensible compilers)
	ImGuiDataType_U8, // unsigned char
	ImGuiDataType_S16, // short
	ImGuiDataType_U16, // unsigned short
	ImGuiDataType_S32, // int
	ImGuiDataType_U32, // unsigned int
	ImGuiDataType_S64, // long long / __int64
	ImGuiDataType_U64, // unsigned long long / unsigned __int64
	ImGuiDataType_Float, // float
	ImGuiDataType_Double, // double
	ImGuiDataType_Bool, // bool (provided for user convenience, not supported by scalar widgets)
	ImGuiDataType_String, // char* (provided for user convenience, not supported by scalar widgets)
	ImGuiDataType_COUNT,
}

// Enumerations
// - We don't use strongly typed enums much because they add constraints (can't extend in private code, can't store typed in bit fields, extra casting on iteration)
// - Tip: Use your programming IDE navigation facilities on the names in the _central column_ below to find the actual flags/enum lists!
//   - In Visual Studio: CTRL+comma ("Edit.GoToAll") can follow symbols inside comments, whereas CTRL+F12 ("Edit.GoToImplementation") cannot.
//   - In Visual Studio w/ Visual Assist installed: ALT+G ("VAssistX.GoToImplementation") can also follow symbols inside comments.
//   - In VS Code, CLion, etc.: CTRL+click can follow symbols inside comments.
// A cardinal direction
ImGuiDir :: enum i32 {
	ImGuiDir_None = -1,
	ImGuiDir_Left = 0,
	ImGuiDir_Right = 1,
	ImGuiDir_Up = 2,
	ImGuiDir_Down = 3,
	ImGuiDir_COUNT,
}

// A sorting direction
ImGuiSortDirection :: enum ImU8 {
	ImGuiSortDirection_None = 0,
	ImGuiSortDirection_Ascending = 1, // Ascending = 0->9, A->Z etc.
	ImGuiSortDirection_Descending = 2,
}

// A key identifier (ImGuiKey_XXX or ImGuiMod_XXX value): can represent Keyboard, Mouse and Gamepad values.
// All our named keys are >= 512. Keys value 0 to 511 are left unused and were legacy native/opaque key values (< 1.87).
// Support for legacy keys was completely removed in 1.91.5.
// Read details about the 1.87+ transition : https://github.com/ocornut/imgui/issues/4921
// Note that "Keys" related to physical keys and are not the same concept as input "Characters", the later are submitted via io.AddInputCharacter().
// The keyboard key enum values are named after the keys on a standard US keyboard, and on other keyboard types the keys reported may not match the keycaps.
ImGuiKey :: enum i32 {
	// Keyboard
	ImGuiKey_None = 0,
	ImGuiKey_NamedKey_BEGIN = 512, // First valid key value (other than 0)

	ImGuiKey_Tab = 512, // == ImGuiKey_NamedKey_BEGIN
	ImGuiKey_LeftArrow,
	ImGuiKey_RightArrow,
	ImGuiKey_UpArrow,
	ImGuiKey_DownArrow,
	ImGuiKey_PageUp,
	ImGuiKey_PageDown,
	ImGuiKey_Home,
	ImGuiKey_End,
	ImGuiKey_Insert,
	ImGuiKey_Delete,
	ImGuiKey_Backspace,
	ImGuiKey_Space,
	ImGuiKey_Enter,
	ImGuiKey_Escape,
	ImGuiKey_LeftCtrl, ImGuiKey_LeftShift, ImGuiKey_LeftAlt, ImGuiKey_LeftSuper,
	ImGuiKey_RightCtrl, ImGuiKey_RightShift, ImGuiKey_RightAlt, ImGuiKey_RightSuper,
	ImGuiKey_Menu,
	ImGuiKey_0, ImGuiKey_1, ImGuiKey_2, ImGuiKey_3, ImGuiKey_4, ImGuiKey_5, ImGuiKey_6, ImGuiKey_7, ImGuiKey_8, ImGuiKey_9,
	ImGuiKey_A, ImGuiKey_B, ImGuiKey_C, ImGuiKey_D, ImGuiKey_E, ImGuiKey_F, ImGuiKey_G, ImGuiKey_H, ImGuiKey_I, ImGuiKey_J,
	ImGuiKey_K, ImGuiKey_L, ImGuiKey_M, ImGuiKey_N, ImGuiKey_O, ImGuiKey_P, ImGuiKey_Q, ImGuiKey_R, ImGuiKey_S, ImGuiKey_T,
	ImGuiKey_U, ImGuiKey_V, ImGuiKey_W, ImGuiKey_X, ImGuiKey_Y, ImGuiKey_Z,
	ImGuiKey_F1, ImGuiKey_F2, ImGuiKey_F3, ImGuiKey_F4, ImGuiKey_F5, ImGuiKey_F6,
	ImGuiKey_F7, ImGuiKey_F8, ImGuiKey_F9, ImGuiKey_F10, ImGuiKey_F11, ImGuiKey_F12,
	ImGuiKey_F13, ImGuiKey_F14, ImGuiKey_F15, ImGuiKey_F16, ImGuiKey_F17, ImGuiKey_F18,
	ImGuiKey_F19, ImGuiKey_F20, ImGuiKey_F21, ImGuiKey_F22, ImGuiKey_F23, ImGuiKey_F24,
	ImGuiKey_Apostrophe, // '
	ImGuiKey_Comma, // ,
	ImGuiKey_Minus, // -
	ImGuiKey_Period, // .
	ImGuiKey_Slash, // /
	ImGuiKey_Semicolon, // ;
	ImGuiKey_Equal, // =
	ImGuiKey_LeftBracket, // [
	ImGuiKey_Backslash, // \ (this text inhibit multiline comment caused by backslash)
	ImGuiKey_RightBracket, // ]
	ImGuiKey_GraveAccent, // `
	ImGuiKey_CapsLock,
	ImGuiKey_ScrollLock,
	ImGuiKey_NumLock,
	ImGuiKey_PrintScreen,
	ImGuiKey_Pause,
	ImGuiKey_Keypad0, ImGuiKey_Keypad1, ImGuiKey_Keypad2, ImGuiKey_Keypad3, ImGuiKey_Keypad4,
	ImGuiKey_Keypad5, ImGuiKey_Keypad6, ImGuiKey_Keypad7, ImGuiKey_Keypad8, ImGuiKey_Keypad9,
	ImGuiKey_KeypadDecimal,
	ImGuiKey_KeypadDivide,
	ImGuiKey_KeypadMultiply,
	ImGuiKey_KeypadSubtract,
	ImGuiKey_KeypadAdd,
	ImGuiKey_KeypadEnter,
	ImGuiKey_KeypadEqual,
	ImGuiKey_AppBack, // Available on some keyboard/mouses. Often referred as "Browser Back"
	ImGuiKey_AppForward,

	// Gamepad (some of those are analog values, 0.0f to 1.0f)                          // NAVIGATION ACTION
	// (download controller mapping PNG/PSD at http://dearimgui.com/controls_sheets)
	ImGuiKey_GamepadStart, // Menu (Xbox)      + (Switch)   Start/Options (PS)
	ImGuiKey_GamepadBack, // View (Xbox)      - (Switch)   Share (PS)
	ImGuiKey_GamepadFaceLeft, // X (Xbox)         Y (Switch)   Square (PS)        // Tap: Toggle Menu. Hold: Windowing mode (Focus/Move/Resize windows)
	ImGuiKey_GamepadFaceRight, // B (Xbox)         A (Switch)   Circle (PS)        // Cancel / Close / Exit
	ImGuiKey_GamepadFaceUp, // Y (Xbox)         X (Switch)   Triangle (PS)      // Text Input / On-screen Keyboard
	ImGuiKey_GamepadFaceDown, // A (Xbox)         B (Switch)   Cross (PS)         // Activate / Open / Toggle / Tweak
	ImGuiKey_GamepadDpadLeft, // D-pad Left                                       // Move / Tweak / Resize Window (in Windowing mode)
	ImGuiKey_GamepadDpadRight, // D-pad Right                                      // Move / Tweak / Resize Window (in Windowing mode)
	ImGuiKey_GamepadDpadUp, // D-pad Up                                         // Move / Tweak / Resize Window (in Windowing mode)
	ImGuiKey_GamepadDpadDown, // D-pad Down                                       // Move / Tweak / Resize Window (in Windowing mode)
	ImGuiKey_GamepadL1, // L Bumper (Xbox)  L (Switch)   L1 (PS)            // Tweak Slower / Focus Previous (in Windowing mode)
	ImGuiKey_GamepadR1, // R Bumper (Xbox)  R (Switch)   R1 (PS)            // Tweak Faster / Focus Next (in Windowing mode)
	ImGuiKey_GamepadL2, // L Trig. (Xbox)   ZL (Switch)  L2 (PS) [Analog]
	ImGuiKey_GamepadR2, // R Trig. (Xbox)   ZR (Switch)  R2 (PS) [Analog]
	ImGuiKey_GamepadL3, // L Stick (Xbox)   L3 (Switch)  L3 (PS)
	ImGuiKey_GamepadR3, // R Stick (Xbox)   R3 (Switch)  R3 (PS)
	ImGuiKey_GamepadLStickLeft, // [Analog]                                         // Move Window (in Windowing mode)
	ImGuiKey_GamepadLStickRight, // [Analog]                                         // Move Window (in Windowing mode)
	ImGuiKey_GamepadLStickUp, // [Analog]                                         // Move Window (in Windowing mode)
	ImGuiKey_GamepadLStickDown, // [Analog]                                         // Move Window (in Windowing mode)
	ImGuiKey_GamepadRStickLeft, // [Analog]
	ImGuiKey_GamepadRStickRight, // [Analog]
	ImGuiKey_GamepadRStickUp, // [Analog]
	ImGuiKey_GamepadRStickDown, // [Analog]

	// Aliases: Mouse Buttons (auto-submitted from AddMouseButtonEvent() calls)
	// - This is mirroring the data also written to io.MouseDown[], io.MouseWheel, in a format allowing them to be accessed via standard key API.
	ImGuiKey_MouseLeft, ImGuiKey_MouseRight, ImGuiKey_MouseMiddle, ImGuiKey_MouseX1, ImGuiKey_MouseX2, ImGuiKey_MouseWheelX, ImGuiKey_MouseWheelY,

	// [Internal] Reserved for mod storage
	ImGuiKey_ReservedForModCtrl, ImGuiKey_ReservedForModShift, ImGuiKey_ReservedForModAlt, ImGuiKey_ReservedForModSuper,
	ImGuiKey_NamedKey_END,

	// Keyboard Modifiers (explicitly submitted by backend via AddKeyEvent() calls)
	// - This is mirroring the data also written to io.KeyCtrl, io.KeyShift, io.KeyAlt, io.KeySuper, in a format allowing
	//   them to be accessed via standard key API, allowing calls such as IsKeyPressed(), IsKeyReleased(), querying duration etc.
	// - Code polling every key (e.g. an interface to detect a key press for input mapping) might want to ignore those
	//   and prefer using the real keys (e.g. ImGuiKey_LeftCtrl, ImGuiKey_RightCtrl instead of ImGuiMod_Ctrl).
	// - In theory the value of keyboard modifiers should be roughly equivalent to a logical or of the equivalent left/right keys.
	//   In practice: it's complicated; mods are often provided from different sources. Keyboard layout, IME, sticky keys and
	//   backends tend to interfere and break that equivalence. The safer decision is to relay that ambiguity down to the end-user...
	// - On macOS, we swap Cmd(Super) and Ctrl keys at the time of the io.AddKeyEvent() call.
	ImGuiMod_None = 0,
	ImGuiMod_Ctrl = 1 << 12, // Ctrl (non-macOS), Cmd (macOS)
	ImGuiMod_Shift = 1 << 13, // Shift
	ImGuiMod_Alt = 1 << 14, // Option/Menu
	ImGuiMod_Super = 1 << 15, // Windows/Super (non-macOS), Ctrl (macOS)
	ImGuiMod_Mask_ = 0xF000, // 4-bits

	// [Internal] If you need to iterate all keys (for e.g. an input mapper) you may use ImGuiKey_NamedKey_BEGIN..ImGuiKey_NamedKey_END.
	ImGuiKey_NamedKey_COUNT = ImGuiKey_NamedKey_END - ImGuiKey_NamedKey_BEGIN,
	//ImGuiKey_KeysData_SIZE        = ImGuiKey_NamedKey_COUNT,  // Size of KeysData[]: only hold named keys
	//ImGuiKey_KeysData_OFFSET      = ImGuiKey_NamedKey_BEGIN,  // Accesses to io.KeysData[] must use (key - ImGuiKey_NamedKey_BEGIN) index.
}

// Flags for Shortcut(), SetNextItemShortcut(),
// (and for upcoming extended versions of IsKeyPressed(), IsMouseClicked(), Shortcut(), SetKeyOwner(), SetItemKeyOwner() that are still in imgui_internal.h)
// Don't mistake with ImGuiInputTextFlags! (which is for ImGui::InputText() function)
ImGuiInputFlags_ :: enum i32 {
	ImGuiInputFlags_None = 0,
	ImGuiInputFlags_Repeat = 1 << 0, // Enable repeat. Return true on successive repeats. Default for legacy IsKeyPressed(). NOT Default for legacy IsMouseClicked(). MUST BE == 1.

	// Flags for Shortcut(), SetNextItemShortcut()
	// - Routing policies: RouteGlobal+OverActive >> RouteActive or RouteFocused (if owner is active item) >> RouteGlobal+OverFocused >> RouteFocused (if in focused window stack) >> RouteGlobal.
	// - Default policy is RouteFocused. Can select only 1 policy among all available.
	ImGuiInputFlags_RouteActive = 1 << 10, // Route to active item only.
	ImGuiInputFlags_RouteFocused = 1 << 11, // Route to windows in the focus stack (DEFAULT). Deep-most focused window takes inputs. Active item takes inputs over deep-most focused window.
	ImGuiInputFlags_RouteGlobal = 1 << 12, // Global route (unless a focused window or active item registered the route).
	ImGuiInputFlags_RouteAlways = 1 << 13, // Do not register route, poll keys directly.
	// - Routing options
	ImGuiInputFlags_RouteOverFocused = 1 << 14, // Option: global route: higher priority than focused route (unless active item in focused route).
	ImGuiInputFlags_RouteOverActive = 1 << 15, // Option: global route: higher priority than active item. Unlikely you need to use that: will interfere with every active items, e.g. CTRL+A registered by InputText will be overridden by this. May not be fully honored as user/internal code is likely to always assume they can access keys when active.
	ImGuiInputFlags_RouteUnlessBgFocused = 1 << 16, // Option: global route: will not be applied if underlying background/void is focused (== no Dear ImGui windows are focused). Useful for overlay applications.
	ImGuiInputFlags_RouteFromRootWindow = 1 << 17, // Option: route evaluated from the point of view of root window rather than current window.

	// Flags for SetNextItemShortcut()
	ImGuiInputFlags_Tooltip = 1 << 18, // Automatically display a tooltip when hovering item [BETA] Unsure of right api (opt-in/opt-out)
}

// Configuration flags stored in io.ConfigFlags. Set by user/application.
ImGuiConfigFlags_ :: enum i32 {
	ImGuiConfigFlags_None = 0,
	ImGuiConfigFlags_NavEnableKeyboard = 1 << 0, // Master keyboard navigation enable flag. Enable full Tabbing + directional arrows + space/enter to activate.
	ImGuiConfigFlags_NavEnableGamepad = 1 << 1, // Master gamepad navigation enable flag. Backend also needs to set ImGuiBackendFlags_HasGamepad.
	ImGuiConfigFlags_NoMouse = 1 << 4, // Instruct dear imgui to disable mouse inputs and interactions.
	ImGuiConfigFlags_NoMouseCursorChange = 1 << 5, // Instruct backend to not alter mouse cursor shape and visibility. Use if the backend cursor changes are interfering with yours and you don't want to use SetMouseCursor() to change mouse cursor. You may want to honor requests from imgui by reading GetMouseCursor() yourself instead.
	ImGuiConfigFlags_NoKeyboard = 1 << 6, // Instruct dear imgui to disable keyboard inputs and interactions. This is done by ignoring keyboard events and clearing existing states.

	// [BETA] Docking
	ImGuiConfigFlags_DockingEnable = 1 << 7, // Docking enable flags.

	// [BETA] Viewports
	// When using viewports it is recommended that your default value for ImGuiCol_WindowBg is opaque (Alpha=1.0) so transition to a viewport won't be noticeable.
	ImGuiConfigFlags_ViewportsEnable = 1 << 10, // Viewport enable flags (require both ImGuiBackendFlags_PlatformHasViewports + ImGuiBackendFlags_RendererHasViewports set by the respective backends)
	ImGuiConfigFlags_DpiEnableScaleViewports = 1 << 14, // [BETA: Don't use] FIXME-DPI: Reposition and resize imgui windows when the DpiScale of a viewport changed (mostly useful for the main viewport hosting other window). Note that resizing the main window itself is up to your application.
	ImGuiConfigFlags_DpiEnableScaleFonts = 1 << 15, // [BETA: Don't use] FIXME-DPI: Request bitmap-scaled fonts to match DpiScale. This is a very low-quality workaround. The correct way to handle DPI is _currently_ to replace the atlas and/or fonts in the Platform_OnChangedViewport callback, but this is all early work in progress.

	// User storage (to allow your backend/engine to communicate to code that may be shared between multiple projects. Those flags are NOT used by core Dear ImGui)
	ImGuiConfigFlags_IsSRGB = 1 << 20, // Application is SRGB-aware.
	ImGuiConfigFlags_IsTouchScreen = 1 << 21, // Application is using a touch screen instead of a mouse.
}

// Backend capabilities flags stored in io.BackendFlags. Set by imgui_impl_xxx or custom backend.
ImGuiBackendFlags_ :: enum i32 {
	ImGuiBackendFlags_None = 0,
	ImGuiBackendFlags_HasGamepad = 1 << 0, // Backend Platform supports gamepad and currently has one connected.
	ImGuiBackendFlags_HasMouseCursors = 1 << 1, // Backend Platform supports honoring GetMouseCursor() value to change the OS cursor shape.
	ImGuiBackendFlags_HasSetMousePos = 1 << 2, // Backend Platform supports io.WantSetMousePos requests to reposition the OS mouse position (only used if io.ConfigNavMoveSetMousePos is set).
	ImGuiBackendFlags_RendererHasVtxOffset = 1 << 3, // Backend Renderer supports ImDrawCmd::VtxOffset. This enables output of large meshes (64K+ vertices) while still using 16-bit indices.

	// [BETA] Viewports
	ImGuiBackendFlags_PlatformHasViewports = 1 << 10, // Backend Platform supports multiple viewports.
	ImGuiBackendFlags_HasMouseHoveredViewport = 1 << 11, // Backend Platform supports calling io.AddMouseViewportEvent() with the viewport under the mouse. IF POSSIBLE, ignore viewports with the ImGuiViewportFlags_NoInputs flag (Win32 backend, GLFW 3.30+ backend can do this, SDL backend cannot). If this cannot be done, Dear ImGui needs to use a flawed heuristic to find the viewport under.
	ImGuiBackendFlags_RendererHasViewports = 1 << 12, // Backend Renderer supports multiple viewports.
}

// Enumeration for PushStyleColor() / PopStyleColor()
ImGuiCol_ :: enum i32 {
	ImGuiCol_Text,
	ImGuiCol_TextDisabled,
	ImGuiCol_WindowBg, // Background of normal windows
	ImGuiCol_ChildBg, // Background of child windows
	ImGuiCol_PopupBg, // Background of popups, menus, tooltips windows
	ImGuiCol_Border,
	ImGuiCol_BorderShadow,
	ImGuiCol_FrameBg, // Background of checkbox, radio button, plot, slider, text input
	ImGuiCol_FrameBgHovered,
	ImGuiCol_FrameBgActive,
	ImGuiCol_TitleBg, // Title bar
	ImGuiCol_TitleBgActive, // Title bar when focused
	ImGuiCol_TitleBgCollapsed, // Title bar when collapsed
	ImGuiCol_MenuBarBg,
	ImGuiCol_ScrollbarBg,
	ImGuiCol_ScrollbarGrab,
	ImGuiCol_ScrollbarGrabHovered,
	ImGuiCol_ScrollbarGrabActive,
	ImGuiCol_CheckMark, // Checkbox tick and RadioButton circle
	ImGuiCol_SliderGrab,
	ImGuiCol_SliderGrabActive,
	ImGuiCol_Button,
	ImGuiCol_ButtonHovered,
	ImGuiCol_ButtonActive,
	ImGuiCol_Header, // Header* colors are used for CollapsingHeader, TreeNode, Selectable, MenuItem
	ImGuiCol_HeaderHovered,
	ImGuiCol_HeaderActive,
	ImGuiCol_Separator,
	ImGuiCol_SeparatorHovered,
	ImGuiCol_SeparatorActive,
	ImGuiCol_ResizeGrip, // Resize grip in lower-right and lower-left corners of windows.
	ImGuiCol_ResizeGripHovered,
	ImGuiCol_ResizeGripActive,
	ImGuiCol_TabHovered, // Tab background, when hovered
	ImGuiCol_Tab, // Tab background, when tab-bar is focused & tab is unselected
	ImGuiCol_TabSelected, // Tab background, when tab-bar is focused & tab is selected
	ImGuiCol_TabSelectedOverline, // Tab horizontal overline, when tab-bar is focused & tab is selected
	ImGuiCol_TabDimmed, // Tab background, when tab-bar is unfocused & tab is unselected
	ImGuiCol_TabDimmedSelected, // Tab background, when tab-bar is unfocused & tab is selected
	ImGuiCol_TabDimmedSelectedOverline, //..horizontal overline, when tab-bar is unfocused & tab is selected
	ImGuiCol_DockingPreview, // Preview overlay color when about to docking something
	ImGuiCol_DockingEmptyBg, // Background color for empty node (e.g. CentralNode with no window docked into it)
	ImGuiCol_PlotLines,
	ImGuiCol_PlotLinesHovered,
	ImGuiCol_PlotHistogram,
	ImGuiCol_PlotHistogramHovered,
	ImGuiCol_TableHeaderBg, // Table header background
	ImGuiCol_TableBorderStrong, // Table outer and header borders (prefer using Alpha=1.0 here)
	ImGuiCol_TableBorderLight, // Table inner borders (prefer using Alpha=1.0 here)
	ImGuiCol_TableRowBg, // Table row background (even rows)
	ImGuiCol_TableRowBgAlt, // Table row background (odd rows)
	ImGuiCol_TextLink, // Hyperlink color
	ImGuiCol_TextSelectedBg,
	ImGuiCol_DragDropTarget, // Rectangle highlighting a drop target
	ImGuiCol_NavCursor, // Color of keyboard/gamepad navigation cursor/rectangle, when visible
	ImGuiCol_NavWindowingHighlight, // Highlight window when using CTRL+TAB
	ImGuiCol_NavWindowingDimBg, // Darken/colorize entire screen behind the CTRL+TAB window list, when active
	ImGuiCol_ModalWindowDimBg, // Darken/colorize entire screen behind a modal window, when one is active
	ImGuiCol_COUNT,
}

// Enumeration for PushStyleVar() / PopStyleVar() to temporarily modify the ImGuiStyle structure.
// - The enum only refers to fields of ImGuiStyle which makes sense to be pushed/popped inside UI code.
//   During initialization or between frames, feel free to just poke into ImGuiStyle directly.
// - Tip: Use your programming IDE navigation facilities on the names in the _second column_ below to find the actual members and their description.
//   - In Visual Studio: CTRL+comma ("Edit.GoToAll") can follow symbols inside comments, whereas CTRL+F12 ("Edit.GoToImplementation") cannot.
//   - In Visual Studio w/ Visual Assist installed: ALT+G ("VAssistX.GoToImplementation") can also follow symbols inside comments.
//   - In VS Code, CLion, etc.: CTRL+click can follow symbols inside comments.
// - When changing this enum, you need to update the associated internal table GStyleVarInfo[] accordingly. This is where we link enum values to members offset/type.
ImGuiStyleVar_ :: enum i32 {
	// Enum name -------------------------- // Member in ImGuiStyle structure (see ImGuiStyle for descriptions)
	ImGuiStyleVar_Alpha, // float     Alpha
	ImGuiStyleVar_DisabledAlpha, // float     DisabledAlpha
	ImGuiStyleVar_WindowPadding, // ImVec2    WindowPadding
	ImGuiStyleVar_WindowRounding, // float     WindowRounding
	ImGuiStyleVar_WindowBorderSize, // float     WindowBorderSize
	ImGuiStyleVar_WindowMinSize, // ImVec2    WindowMinSize
	ImGuiStyleVar_WindowTitleAlign, // ImVec2    WindowTitleAlign
	ImGuiStyleVar_ChildRounding, // float     ChildRounding
	ImGuiStyleVar_ChildBorderSize, // float     ChildBorderSize
	ImGuiStyleVar_PopupRounding, // float     PopupRounding
	ImGuiStyleVar_PopupBorderSize, // float     PopupBorderSize
	ImGuiStyleVar_FramePadding, // ImVec2    FramePadding
	ImGuiStyleVar_FrameRounding, // float     FrameRounding
	ImGuiStyleVar_FrameBorderSize, // float     FrameBorderSize
	ImGuiStyleVar_ItemSpacing, // ImVec2    ItemSpacing
	ImGuiStyleVar_ItemInnerSpacing, // ImVec2    ItemInnerSpacing
	ImGuiStyleVar_IndentSpacing, // float     IndentSpacing
	ImGuiStyleVar_CellPadding, // ImVec2    CellPadding
	ImGuiStyleVar_ScrollbarSize, // float     ScrollbarSize
	ImGuiStyleVar_ScrollbarRounding, // float     ScrollbarRounding
	ImGuiStyleVar_GrabMinSize, // float     GrabMinSize
	ImGuiStyleVar_GrabRounding, // float     GrabRounding
	ImGuiStyleVar_TabRounding, // float     TabRounding
	ImGuiStyleVar_TabBorderSize, // float     TabBorderSize
	ImGuiStyleVar_TabBarBorderSize, // float     TabBarBorderSize
	ImGuiStyleVar_TabBarOverlineSize, // float     TabBarOverlineSize
	ImGuiStyleVar_TableAngledHeadersAngle, // float     TableAngledHeadersAngle
	ImGuiStyleVar_TableAngledHeadersTextAlign, // ImVec2  TableAngledHeadersTextAlign
	ImGuiStyleVar_ButtonTextAlign, // ImVec2    ButtonTextAlign
	ImGuiStyleVar_SelectableTextAlign, // ImVec2    SelectableTextAlign
	ImGuiStyleVar_SeparatorTextBorderSize, // float     SeparatorTextBorderSize
	ImGuiStyleVar_SeparatorTextAlign, // ImVec2    SeparatorTextAlign
	ImGuiStyleVar_SeparatorTextPadding, // ImVec2    SeparatorTextPadding
	ImGuiStyleVar_DockingSeparatorSize, // float     DockingSeparatorSize
	ImGuiStyleVar_COUNT,
}

// Flags for InvisibleButton() [extended in imgui_internal.h]
ImGuiButtonFlags_ :: enum i32 {
	ImGuiButtonFlags_None = 0,
	ImGuiButtonFlags_MouseButtonLeft = 1 << 0, // React on left mouse button (default)
	ImGuiButtonFlags_MouseButtonRight = 1 << 1, // React on right mouse button
	ImGuiButtonFlags_MouseButtonMiddle = 1 << 2, // React on center mouse button
	ImGuiButtonFlags_MouseButtonMask_ = ImGuiButtonFlags_MouseButtonLeft | ImGuiButtonFlags_MouseButtonRight | ImGuiButtonFlags_MouseButtonMiddle, // [Internal]
	ImGuiButtonFlags_EnableNav = 1 << 3, // InvisibleButton(): do not disable navigation/tabbing. Otherwise disabled by default.
}

// Flags for ColorEdit3() / ColorEdit4() / ColorPicker3() / ColorPicker4() / ColorButton()
ImGuiColorEditFlags_ :: enum i32 {
	ImGuiColorEditFlags_None = 0,
	ImGuiColorEditFlags_NoAlpha = 1 << 1, //              // ColorEdit, ColorPicker, ColorButton: ignore Alpha component (will only read 3 components from the input pointer).
	ImGuiColorEditFlags_NoPicker = 1 << 2, //              // ColorEdit: disable picker when clicking on color square.
	ImGuiColorEditFlags_NoOptions = 1 << 3, //              // ColorEdit: disable toggling options menu when right-clicking on inputs/small preview.
	ImGuiColorEditFlags_NoSmallPreview = 1 << 4, //              // ColorEdit, ColorPicker: disable color square preview next to the inputs. (e.g. to show only the inputs)
	ImGuiColorEditFlags_NoInputs = 1 << 5, //              // ColorEdit, ColorPicker: disable inputs sliders/text widgets (e.g. to show only the small preview color square).
	ImGuiColorEditFlags_NoTooltip = 1 << 6, //              // ColorEdit, ColorPicker, ColorButton: disable tooltip when hovering the preview.
	ImGuiColorEditFlags_NoLabel = 1 << 7, //              // ColorEdit, ColorPicker: disable display of inline text label (the label is still forwarded to the tooltip and picker).
	ImGuiColorEditFlags_NoSidePreview = 1 << 8, //              // ColorPicker: disable bigger color preview on right side of the picker, use small color square preview instead.
	ImGuiColorEditFlags_NoDragDrop = 1 << 9, //              // ColorEdit: disable drag and drop target. ColorButton: disable drag and drop source.
	ImGuiColorEditFlags_NoBorder = 1 << 10, //              // ColorButton: disable border (which is enforced by default)

	// User Options (right-click on widget to change some of them).
	ImGuiColorEditFlags_AlphaBar = 1 << 16, //              // ColorEdit, ColorPicker: show vertical alpha bar/gradient in picker.
	ImGuiColorEditFlags_AlphaPreview = 1 << 17, //              // ColorEdit, ColorPicker, ColorButton: display preview as a transparent color over a checkerboard, instead of opaque.
	ImGuiColorEditFlags_AlphaPreviewHalf = 1 << 18, //              // ColorEdit, ColorPicker, ColorButton: display half opaque / half checkerboard, instead of opaque.
	ImGuiColorEditFlags_HDR = 1 << 19, //              // (WIP) ColorEdit: Currently only disable 0.0f..1.0f limits in RGBA edition (note: you probably want to use ImGuiColorEditFlags_Float flag as well).
	ImGuiColorEditFlags_DisplayRGB = 1 << 20, // [Display]    // ColorEdit: override _display_ type among RGB/HSV/Hex. ColorPicker: select any combination using one or more of RGB/HSV/Hex.
	ImGuiColorEditFlags_DisplayHSV = 1 << 21, // [Display]    // "
	ImGuiColorEditFlags_DisplayHex = 1 << 22, // [Display]    // "
	ImGuiColorEditFlags_Uint8 = 1 << 23, // [DataType]   // ColorEdit, ColorPicker, ColorButton: _display_ values formatted as 0..255.
	ImGuiColorEditFlags_Float = 1 << 24, // [DataType]   // ColorEdit, ColorPicker, ColorButton: _display_ values formatted as 0.0f..1.0f floats instead of 0..255 integers. No round-trip of value via integers.
	ImGuiColorEditFlags_PickerHueBar = 1 << 25, // [Picker]     // ColorPicker: bar for Hue, rectangle for Sat/Value.
	ImGuiColorEditFlags_PickerHueWheel = 1 << 26, // [Picker]     // ColorPicker: wheel for Hue, triangle for Sat/Value.
	ImGuiColorEditFlags_InputRGB = 1 << 27, // [Input]      // ColorEdit, ColorPicker: input and output data in RGB format.
	ImGuiColorEditFlags_InputHSV = 1 << 28, // [Input]      // ColorEdit, ColorPicker: input and output data in HSV format.

	// Defaults Options. You can set application defaults using SetColorEditOptions(). The intent is that you probably don't want to
	// override them in most of your calls. Let the user choose via the option menu and/or call SetColorEditOptions() once during startup.
	ImGuiColorEditFlags_DefaultOptions_ = ImGuiColorEditFlags_Uint8 | ImGuiColorEditFlags_DisplayRGB | ImGuiColorEditFlags_InputRGB | ImGuiColorEditFlags_PickerHueBar,

	// [Internal] Masks
	ImGuiColorEditFlags_DisplayMask_ = ImGuiColorEditFlags_DisplayRGB | ImGuiColorEditFlags_DisplayHSV | ImGuiColorEditFlags_DisplayHex,
	ImGuiColorEditFlags_DataTypeMask_ = ImGuiColorEditFlags_Uint8 | ImGuiColorEditFlags_Float,
	ImGuiColorEditFlags_PickerMask_ = ImGuiColorEditFlags_PickerHueWheel | ImGuiColorEditFlags_PickerHueBar,
	ImGuiColorEditFlags_InputMask_ = ImGuiColorEditFlags_InputRGB | ImGuiColorEditFlags_InputHSV,

	// Obsolete names
	//ImGuiColorEditFlags_RGB = ImGuiColorEditFlags_DisplayRGB, ImGuiColorEditFlags_HSV = ImGuiColorEditFlags_DisplayHSV, ImGuiColorEditFlags_HEX = ImGuiColorEditFlags_DisplayHex  // [renamed in 1.69]
}

// Flags for DragFloat(), DragInt(), SliderFloat(), SliderInt() etc.
// We use the same sets of flags for DragXXX() and SliderXXX() functions as the features are the same and it makes it easier to swap them.
// (Those are per-item flags. There is shared behavior flag too: ImGuiIO: io.ConfigDragClickToInputText)
ImGuiSliderFlags_ :: enum i32 {
	ImGuiSliderFlags_None = 0,
	ImGuiSliderFlags_Logarithmic = 1 << 5, // Make the widget logarithmic (linear otherwise). Consider using ImGuiSliderFlags_NoRoundToFormat with this if using a format-string with small amount of digits.
	ImGuiSliderFlags_NoRoundToFormat = 1 << 6, // Disable rounding underlying value to match precision of the display format string (e.g. %.3f values are rounded to those 3 digits).
	ImGuiSliderFlags_NoInput = 1 << 7, // Disable CTRL+Click or Enter key allowing to input text directly into the widget.
	ImGuiSliderFlags_WrapAround = 1 << 8, // Enable wrapping around from max to min and from min to max. Only supported by DragXXX() functions for now.
	ImGuiSliderFlags_ClampOnInput = 1 << 9, // Clamp value to min/max bounds when input manually with CTRL+Click. By default CTRL+Click allows going out of bounds.
	ImGuiSliderFlags_ClampZeroRange = 1 << 10, // Clamp even if min==max==0.0f. Otherwise due to legacy reason DragXXX functions don't clamp with those values. When your clamping limits are dynamic you almost always want to use it.
	ImGuiSliderFlags_NoSpeedTweaks = 1 << 11, // Disable keyboard modifiers altering tweak speed. Useful if you want to alter tweak speed yourself based on your own logic.
	ImGuiSliderFlags_AlwaysClamp = ImGuiSliderFlags_ClampOnInput | ImGuiSliderFlags_ClampZeroRange,
	ImGuiSliderFlags_InvalidMask_ = 0x7000000F, // [Internal] We treat using those bits as being potentially a 'float power' argument from the previous API that has got miscast to this enum, and will trigger an assert if needed.
}

// Identify a mouse button.
// Those values are guaranteed to be stable and we frequently use 0/1 directly. Named enums provided for convenience.
ImGuiMouseButton_ :: enum i32 {
	ImGuiMouseButton_Left = 0,
	ImGuiMouseButton_Right = 1,
	ImGuiMouseButton_Middle = 2,
	ImGuiMouseButton_COUNT = 5,
}

// Enumeration for GetMouseCursor()
// User code may request backend to display given cursor by calling SetMouseCursor(), which is why we have some cursors that are marked unused here
ImGuiMouseCursor_ :: enum i32 {
	ImGuiMouseCursor_None = -1,
	ImGuiMouseCursor_Arrow = 0,
	ImGuiMouseCursor_TextInput, // When hovering over InputText, etc.
	ImGuiMouseCursor_ResizeAll, // (Unused by Dear ImGui functions)
	ImGuiMouseCursor_ResizeNS, // When hovering over a horizontal border
	ImGuiMouseCursor_ResizeEW, // When hovering over a vertical border or a column
	ImGuiMouseCursor_ResizeNESW, // When hovering over the bottom-left corner of a window
	ImGuiMouseCursor_ResizeNWSE, // When hovering over the bottom-right corner of a window
	ImGuiMouseCursor_Hand, // (Unused by Dear ImGui functions. Use for e.g. hyperlinks)
	ImGuiMouseCursor_NotAllowed, // When hovering something with disallowed interaction. Usually a crossed circle.
	ImGuiMouseCursor_COUNT,
}

// Enumeration for AddMouseSourceEvent() actual source of Mouse Input data.
// Historically we use "Mouse" terminology everywhere to indicate pointer data, e.g. MousePos, IsMousePressed(), io.AddMousePosEvent()
// But that "Mouse" data can come from different source which occasionally may be useful for application to know about.
// You can submit a change of pointer type using io.AddMouseSourceEvent().
ImGuiMouseSource :: enum i32 {
	ImGuiMouseSource_Mouse = 0, // Input is coming from an actual mouse.
	ImGuiMouseSource_TouchScreen, // Input is coming from a touch screen (no hovering prior to initial press, less precise initial press aiming, dual-axis wheeling possible).
	ImGuiMouseSource_Pen, // Input is coming from a pressure/magnetic pen (often used in conjunction with high-sampling rates).
	ImGuiMouseSource_COUNT,
}

// Enumeration for ImGui::SetNextWindow***(), SetWindow***(), SetNextItem***() functions
// Represent a condition.
// Important: Treat as a regular enum! Do NOT combine multiple values using binary operators! All the functions above treat 0 as a shortcut to ImGuiCond_Always.
ImGuiCond_ :: enum i32 {
	ImGuiCond_None = 0, // No condition (always set the variable), same as _Always
	ImGuiCond_Always = 1 << 0, // No condition (always set the variable), same as _None
	ImGuiCond_Once = 1 << 1, // Set the variable once per runtime session (only the first call will succeed)
	ImGuiCond_FirstUseEver = 1 << 2, // Set the variable if the object/window has no persistently saved data (no entry in .ini file)
	ImGuiCond_Appearing = 1 << 3, // Set the variable if the object/window is appearing after being hidden/inactive (or the first time)
}

//-----------------------------------------------------------------------------
// [SECTION] Tables API flags and structures (ImGuiTableFlags, ImGuiTableColumnFlags, ImGuiTableRowFlags, ImGuiTableBgTarget, ImGuiTableSortSpecs, ImGuiTableColumnSortSpecs)
//-----------------------------------------------------------------------------

// Flags for ImGui::BeginTable()
// - Important! Sizing policies have complex and subtle side effects, much more so than you would expect.
//   Read comments/demos carefully + experiment with live demos to get acquainted with them.
// - The DEFAULT sizing policies are:
//    - Default to ImGuiTableFlags_SizingFixedFit    if ScrollX is on, or if host window has ImGuiWindowFlags_AlwaysAutoResize.
//    - Default to ImGuiTableFlags_SizingStretchSame if ScrollX is off.
// - When ScrollX is off:
//    - Table defaults to ImGuiTableFlags_SizingStretchSame -> all Columns defaults to ImGuiTableColumnFlags_WidthStretch with same weight.
//    - Columns sizing policy allowed: Stretch (default), Fixed/Auto.
//    - Fixed Columns (if any) will generally obtain their requested width (unless the table cannot fit them all).
//    - Stretch Columns will share the remaining width according to their respective weight.
//    - Mixed Fixed/Stretch columns is possible but has various side-effects on resizing behaviors.
//      The typical use of mixing sizing policies is: any number of LEADING Fixed columns, followed by one or two TRAILING Stretch columns.
//      (this is because the visible order of columns have subtle but necessary effects on how they react to manual resizing).
// - When ScrollX is on:
//    - Table defaults to ImGuiTableFlags_SizingFixedFit -> all Columns defaults to ImGuiTableColumnFlags_WidthFixed
//    - Columns sizing policy allowed: Fixed/Auto mostly.
//    - Fixed Columns can be enlarged as needed. Table will show a horizontal scrollbar if needed.
//    - When using auto-resizing (non-resizable) fixed columns, querying the content width to use item right-alignment e.g. SetNextItemWidth(-FLT_MIN) doesn't make sense, would create a feedback loop.
//    - Using Stretch columns OFTEN DOES NOT MAKE SENSE if ScrollX is on, UNLESS you have specified a value for 'inner_width' in BeginTable().
//      If you specify a value for 'inner_width' then effectively the scrolling space is known and Stretch or mixed Fixed/Stretch columns become meaningful again.
// - Read on documentation at the top of imgui_tables.cpp for details.
ImGuiTableFlags_ :: enum i32 {
	// Features
	ImGuiTableFlags_None = 0,
	ImGuiTableFlags_Resizable = 1 << 0, // Enable resizing columns.
	ImGuiTableFlags_Reorderable = 1 << 1, // Enable reordering columns in header row (need calling TableSetupColumn() + TableHeadersRow() to display headers)
	ImGuiTableFlags_Hideable = 1 << 2, // Enable hiding/disabling columns in context menu.
	ImGuiTableFlags_Sortable = 1 << 3, // Enable sorting. Call TableGetSortSpecs() to obtain sort specs. Also see ImGuiTableFlags_SortMulti and ImGuiTableFlags_SortTristate.
	ImGuiTableFlags_NoSavedSettings = 1 << 4, // Disable persisting columns order, width and sort settings in the .ini file.
	ImGuiTableFlags_ContextMenuInBody = 1 << 5, // Right-click on columns body/contents will display table context menu. By default it is available in TableHeadersRow().
	// Decorations
	ImGuiTableFlags_RowBg = 1 << 6, // Set each RowBg color with ImGuiCol_TableRowBg or ImGuiCol_TableRowBgAlt (equivalent of calling TableSetBgColor with ImGuiTableBgFlags_RowBg0 on each row manually)
	ImGuiTableFlags_BordersInnerH = 1 << 7, // Draw horizontal borders between rows.
	ImGuiTableFlags_BordersOuterH = 1 << 8, // Draw horizontal borders at the top and bottom.
	ImGuiTableFlags_BordersInnerV = 1 << 9, // Draw vertical borders between columns.
	ImGuiTableFlags_BordersOuterV = 1 << 10, // Draw vertical borders on the left and right sides.
	ImGuiTableFlags_BordersH = ImGuiTableFlags_BordersInnerH | ImGuiTableFlags_BordersOuterH, // Draw horizontal borders.
	ImGuiTableFlags_BordersV = ImGuiTableFlags_BordersInnerV | ImGuiTableFlags_BordersOuterV, // Draw vertical borders.
	ImGuiTableFlags_BordersInner = ImGuiTableFlags_BordersInnerV | ImGuiTableFlags_BordersInnerH, // Draw inner borders.
	ImGuiTableFlags_BordersOuter = ImGuiTableFlags_BordersOuterV | ImGuiTableFlags_BordersOuterH, // Draw outer borders.
	ImGuiTableFlags_Borders = ImGuiTableFlags_BordersInner | ImGuiTableFlags_BordersOuter, // Draw all borders.
	ImGuiTableFlags_NoBordersInBody = 1 << 11, // [ALPHA] Disable vertical borders in columns Body (borders will always appear in Headers). -> May move to style
	ImGuiTableFlags_NoBordersInBodyUntilResize = 1 << 12, // [ALPHA] Disable vertical borders in columns Body until hovered for resize (borders will always appear in Headers). -> May move to style
	// Sizing Policy (read above for defaults)
	ImGuiTableFlags_SizingFixedFit = 1 << 13, // Columns default to _WidthFixed or _WidthAuto (if resizable or not resizable), matching contents width.
	ImGuiTableFlags_SizingFixedSame = 2 << 13, // Columns default to _WidthFixed or _WidthAuto (if resizable or not resizable), matching the maximum contents width of all columns. Implicitly enable ImGuiTableFlags_NoKeepColumnsVisible.
	ImGuiTableFlags_SizingStretchProp = 3 << 13, // Columns default to _WidthStretch with default weights proportional to each columns contents widths.
	ImGuiTableFlags_SizingStretchSame = 4 << 13, // Columns default to _WidthStretch with default weights all equal, unless overridden by TableSetupColumn().
	// Sizing Extra Options
	ImGuiTableFlags_NoHostExtendX = 1 << 16, // Make outer width auto-fit to columns, overriding outer_size.x value. Only available when ScrollX/ScrollY are disabled and Stretch columns are not used.
	ImGuiTableFlags_NoHostExtendY = 1 << 17, // Make outer height stop exactly at outer_size.y (prevent auto-extending table past the limit). Only available when ScrollX/ScrollY are disabled. Data below the limit will be clipped and not visible.
	ImGuiTableFlags_NoKeepColumnsVisible = 1 << 18, // Disable keeping column always minimally visible when ScrollX is off and table gets too small. Not recommended if columns are resizable.
	ImGuiTableFlags_PreciseWidths = 1 << 19, // Disable distributing remainder width to stretched columns (width allocation on a 100-wide table with 3 columns: Without this flag: 33,33,34. With this flag: 33,33,33). With larger number of columns, resizing will appear to be less smooth.
	// Clipping
	ImGuiTableFlags_NoClip = 1 << 20, // Disable clipping rectangle for every individual columns (reduce draw command count, items will be able to overflow into other columns). Generally incompatible with TableSetupScrollFreeze().
	// Padding
	ImGuiTableFlags_PadOuterX = 1 << 21, // Default if BordersOuterV is on. Enable outermost padding. Generally desirable if you have headers.
	ImGuiTableFlags_NoPadOuterX = 1 << 22, // Default if BordersOuterV is off. Disable outermost padding.
	ImGuiTableFlags_NoPadInnerX = 1 << 23, // Disable inner padding between columns (double inner padding if BordersOuterV is on, single inner padding if BordersOuterV is off).
	// Scrolling
	ImGuiTableFlags_ScrollX = 1 << 24, // Enable horizontal scrolling. Require 'outer_size' parameter of BeginTable() to specify the container size. Changes default sizing policy. Because this creates a child window, ScrollY is currently generally recommended when using ScrollX.
	ImGuiTableFlags_ScrollY = 1 << 25, // Enable vertical scrolling. Require 'outer_size' parameter of BeginTable() to specify the container size.
	// Sorting
	ImGuiTableFlags_SortMulti = 1 << 26, // Hold shift when clicking headers to sort on multiple column. TableGetSortSpecs() may return specs where (SpecsCount > 1).
	ImGuiTableFlags_SortTristate = 1 << 27, // Allow no sorting, disable default sorting. TableGetSortSpecs() may return specs where (SpecsCount == 0).
	// Miscellaneous
	ImGuiTableFlags_HighlightHoveredColumn = 1 << 28, // Highlight column headers when hovered (may evolve into a fuller highlight)

	// [Internal] Combinations and masks
	ImGuiTableFlags_SizingMask_ = ImGuiTableFlags_SizingFixedFit | ImGuiTableFlags_SizingFixedSame | ImGuiTableFlags_SizingStretchProp | ImGuiTableFlags_SizingStretchSame,
}

// Flags for ImGui::TableSetupColumn()
ImGuiTableColumnFlags_ :: enum i32 {
	// Input configuration flags
	ImGuiTableColumnFlags_None = 0,
	ImGuiTableColumnFlags_Disabled = 1 << 0, // Overriding/master disable flag: hide column, won't show in context menu (unlike calling TableSetColumnEnabled() which manipulates the user accessible state)
	ImGuiTableColumnFlags_DefaultHide = 1 << 1, // Default as a hidden/disabled column.
	ImGuiTableColumnFlags_DefaultSort = 1 << 2, // Default as a sorting column.
	ImGuiTableColumnFlags_WidthStretch = 1 << 3, // Column will stretch. Preferable with horizontal scrolling disabled (default if table sizing policy is _SizingStretchSame or _SizingStretchProp).
	ImGuiTableColumnFlags_WidthFixed = 1 << 4, // Column will not stretch. Preferable with horizontal scrolling enabled (default if table sizing policy is _SizingFixedFit and table is resizable).
	ImGuiTableColumnFlags_NoResize = 1 << 5, // Disable manual resizing.
	ImGuiTableColumnFlags_NoReorder = 1 << 6, // Disable manual reordering this column, this will also prevent other columns from crossing over this column.
	ImGuiTableColumnFlags_NoHide = 1 << 7, // Disable ability to hide/disable this column.
	ImGuiTableColumnFlags_NoClip = 1 << 8, // Disable clipping for this column (all NoClip columns will render in a same draw command).
	ImGuiTableColumnFlags_NoSort = 1 << 9, // Disable ability to sort on this field (even if ImGuiTableFlags_Sortable is set on the table).
	ImGuiTableColumnFlags_NoSortAscending = 1 << 10, // Disable ability to sort in the ascending direction.
	ImGuiTableColumnFlags_NoSortDescending = 1 << 11, // Disable ability to sort in the descending direction.
	ImGuiTableColumnFlags_NoHeaderLabel = 1 << 12, // TableHeadersRow() will submit an empty label for this column. Convenient for some small columns. Name will still appear in context menu or in angled headers. You may append into this cell by calling TableSetColumnIndex() right after the TableHeadersRow() call.
	ImGuiTableColumnFlags_NoHeaderWidth = 1 << 13, // Disable header text width contribution to automatic column width.
	ImGuiTableColumnFlags_PreferSortAscending = 1 << 14, // Make the initial sort direction Ascending when first sorting on this column (default).
	ImGuiTableColumnFlags_PreferSortDescending = 1 << 15, // Make the initial sort direction Descending when first sorting on this column.
	ImGuiTableColumnFlags_IndentEnable = 1 << 16, // Use current Indent value when entering cell (default for column 0).
	ImGuiTableColumnFlags_IndentDisable = 1 << 17, // Ignore current Indent value when entering cell (default for columns > 0). Indentation changes _within_ the cell will still be honored.
	ImGuiTableColumnFlags_AngledHeader = 1 << 18, // TableHeadersRow() will submit an angled header row for this column. Note this will add an extra row.

	// Output status flags, read-only via TableGetColumnFlags()
	ImGuiTableColumnFlags_IsEnabled = 1 << 24, // Status: is enabled == not hidden by user/api (referred to as "Hide" in _DefaultHide and _NoHide) flags.
	ImGuiTableColumnFlags_IsVisible = 1 << 25, // Status: is visible == is enabled AND not clipped by scrolling.
	ImGuiTableColumnFlags_IsSorted = 1 << 26, // Status: is currently part of the sort specs
	ImGuiTableColumnFlags_IsHovered = 1 << 27, // Status: is hovered by mouse

	// [Internal] Combinations and masks
	ImGuiTableColumnFlags_WidthMask_ = ImGuiTableColumnFlags_WidthStretch | ImGuiTableColumnFlags_WidthFixed,
	ImGuiTableColumnFlags_IndentMask_ = ImGuiTableColumnFlags_IndentEnable | ImGuiTableColumnFlags_IndentDisable,
	ImGuiTableColumnFlags_StatusMask_ = ImGuiTableColumnFlags_IsEnabled | ImGuiTableColumnFlags_IsVisible | ImGuiTableColumnFlags_IsSorted | ImGuiTableColumnFlags_IsHovered,
	ImGuiTableColumnFlags_NoDirectResize_ = 1 << 30, // [Internal] Disable user resizing this column directly (it may however we resized indirectly from its left edge)
}

// Flags for ImGui::TableNextRow()
ImGuiTableRowFlags_ :: enum i32 {
	ImGuiTableRowFlags_None = 0,
	ImGuiTableRowFlags_Headers = 1 << 0, // Identify header row (set default background color + width of its contents accounted differently for auto column width)
}

// Enum for ImGui::TableSetBgColor()
// Background colors are rendering in 3 layers:
//  - Layer 0: draw with RowBg0 color if set, otherwise draw with ColumnBg0 if set.
//  - Layer 1: draw with RowBg1 color if set, otherwise draw with ColumnBg1 if set.
//  - Layer 2: draw with CellBg color if set.
// The purpose of the two row/columns layers is to let you decide if a background color change should override or blend with the existing color.
// When using ImGuiTableFlags_RowBg on the table, each row has the RowBg0 color automatically set for odd/even rows.
// If you set the color of RowBg0 target, your color will override the existing RowBg0 color.
// If you set the color of RowBg1 or ColumnBg1 target, your color will blend over the RowBg0 color.
ImGuiTableBgTarget_ :: enum i32 {
	ImGuiTableBgTarget_None = 0,
	ImGuiTableBgTarget_RowBg0 = 1, // Set row background color 0 (generally used for background, automatically set when ImGuiTableFlags_RowBg is used)
	ImGuiTableBgTarget_RowBg1 = 2, // Set row background color 1 (generally used for selection marking)
	ImGuiTableBgTarget_CellBg = 3, // Set cell background color (top-most color)
}

// Sorting specifications for a table (often handling sort specs for a single column, occasionally more)
// Obtained by calling TableGetSortSpecs().
// When 'SpecsDirty == true' you can sort your data. It will be true with sorting specs have changed since last call, or the first time.
// Make sure to set 'SpecsDirty = false' after sorting, else you may wastefully sort your data every frame!
ImGuiTableSortSpecs :: struct {
	Specs : ^ImGuiTableColumnSortSpecs, // Pointer to sort spec array.
	SpecsCount : i32, // Sort spec count. Most often 1. May be > 1 when ImGuiTableFlags_SortMulti is enabled. May be == 0 when ImGuiTableFlags_SortTristate is enabled.
	SpecsDirty : bool, // Set to true when specs have changed since last time! Use this to sort again, then clear the flag.
}


// Sorting specification for one column of a table (sizeof == 12 bytes)
ImGuiTableColumnSortSpecs :: struct {
	ColumnUserID : ImGuiID, // User id of the column (if specified by a TableSetupColumn() call)
	ColumnIndex : ImS16, // Index of the column
	SortOrder : ImS16, // Index within parent ImGuiTableSortSpecs (always stored in order starting from 0, tables sorted on a single criteria will always have a 0 here)
	SortDirection : ImGuiSortDirection, // ImGuiSortDirection_Ascending or ImGuiSortDirection_Descending
}

//-----------------------------------------------------------------------------
// [SECTION] Helpers: Debug log, memory allocations macros, ImVector<>
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// Debug Logging into ShowDebugLogWindow(), tty and more.
//-----------------------------------------------------------------------------

when !IMGUI_DISABLE_DEBUG_TOOLS {
IMGUI_DEBUG_LOG :: #force_inline proc (fmt : string, args : ..any) //TODO @gen: Validate the parameters were not passed by reference.
{
	DebugLog(fmt, ..args)
}

} else { // preproc else
IMGUI_DEBUG_LOG :: #force_inline proc "contextless" (args : ..any) //TODO @gen: Validate the parameters were not passed by reference.
{
	_ = args
}

} // preproc endif

//-----------------------------------------------------------------------------
// IM_MALLOC(), IM_FREE(), IM_NEW(), IM_PLACEMENT_NEW(), IM_DELETE()
// We call C++ constructor on own allocated memory via the placement "new(ptr) Type()" syntax.
// Defining a custom placement new() with a custom parameter allows us to bypass including <new> which on some platforms complains when user has disabled exceptions.
//-----------------------------------------------------------------------------

ImNewWrapper :: struct { }
// This is only required so we can use the symmetrical new()
IM_ALLOC :: #force_inline proc (#any_int _SIZE : uint) -> rawptr
{
	return MemAlloc(_SIZE)
}

IM_FREE :: #force_inline proc (_PTR : rawptr) { MemFree(_PTR) }

IM_NEW_MEM :: #force_inline proc ($_TYPE : typeid)  -> ^_TYPE
{
	return transmute(^_TYPE)MemAlloc(size_of(_TYPE))
}

IM_NEW :: #force_inline proc ($_TYPE : typeid)  -> ^_TYPE
{
	ptr := transmute(^_TYPE)MemAlloc(size_of(_TYPE))
	
	init(ptr)
	return ptr
}

IM_DELETE :: proc(p : ^$T) { if p != nil { deinit(p); MemFree(p) } }

//-----------------------------------------------------------------------------
// ImVector<>
// Lightweight std::vector<>-like class to avoid dragging dependencies (also, some implementations of STL with debug enabled are absurdly slow, we bypass it so our code runs fast in debug).
//-----------------------------------------------------------------------------
// - You generally do NOT need to care or use this ever. But we need to make it available in imgui.h because some of our public structures are relying on it.
// - We use std-like naming convention here, which is a little unusual for this codebase.
// - Important: clear() frees memory, resize(0) keep the allocated buffer. We use resize(0) a lot to intentionally recycle allocated buffers across frames and amortize our costs.
// - Important: our implementation does NOT call C++ constructors/destructors, we treat everything as raw data! This is intentional but be extra mindful of that,
//   Do NOT use this class as a std::vector replacement in your own code! Many of the structures used by dear imgui can be safely initialized by a zero-memset.
//-----------------------------------------------------------------------------


ImVector :: struct($T : typeid) {
	Size : i32,
	Capacity : i32,
	Data : [^]T,
}

ImVector_deinit :: proc(this : ^ImVector($T)) { if this.Data != nil { IM_FREE(this.Data) } }

// Constructors, destructor
ImVector_init_0 :: #force_inline proc(this : ^ImVector($T))
{
	this.Capacity = 0; this.Size = this.Capacity; this.Data = nil
}

// Constructors, destructor
ImVector_init_1 :: #force_inline proc(this : ^ImVector($T), src : ^ImVector(T))
{
	this.Capacity = 0; this.Size = this.Capacity; this.Data = nil; operator_Assign(src)
}

// Important: does not destruct anything
ImVector_clear :: #force_inline proc(this : ^ImVector($T)) { if this.Data != nil {this.Capacity = 0; this.Size = this.Capacity; IM_FREE(this.Data); this.Data = nil
} }

// Important: never called automatically! always explicit.
ImVector_clear_delete :: #force_inline proc(this : ^ImVector($T))
{
	for n : i32 = 0; n < this.Size; n += 1 { IM_DELETE(this.Data[n]) }; ImVector_clear(this)
}

// Important: never called automatically! always explicit.
ImVector_clear_destruct :: #force_inline proc(this : ^ImVector($T))
{
	for n : i32 = 0; n < this.Size; n += 1 { deinit(&this.Data[n]) }; ImVector_clear(this)
}

ImVector_empty :: #force_inline proc(this : ^ImVector($T)) -> bool { return this.Size == 0 }

ImVector_size :: #force_inline proc(this : ^ImVector($T)) -> i32 { return this.Size }

ImVector_size_in_bytes :: #force_inline proc(this : ^ImVector($T)) -> i32 { return this.Size * cast(i32) size_of(T) }

ImVector_max_size :: #force_inline proc(this : ^ImVector($T)) -> i32 { return 0x7FFFFFFF / cast(i32) size_of(T) }

ImVector_capacity :: #force_inline proc(this : ^ImVector($T)) -> i32 { return this.Capacity }

ImVector_begin :: #force_inline proc(this : ^ImVector($T)) -> [^]T
{
	return this.Data
}

ImVector_end :: #force_inline proc(this : ^ImVector($T)) -> ^T
{
	return &this.Data[this.Size]
}

ImVector_front :: #force_inline proc(this : ^ImVector($T)) -> ^T
{
	IM_ASSERT(this.Size > 0); return &this.Data[0]
}

ImVector_back :: #force_inline proc(this : ^ImVector($T)) -> ^T
{
	IM_ASSERT(this.Size > 0); return &this.Data[this.Size - 1]
}

ImVector_swap :: #force_inline proc(this : ^ImVector($T), rhs : ^ImVector(T))
{
	rhs_size : i32 = rhs.Size; rhs.Size = this.Size; this.Size = rhs_size; rhs_cap : i32 = rhs.Capacity; rhs.Capacity = this.Capacity; this.Capacity = rhs_cap; rhs_data : ^T = rhs.Data; rhs.Data = this.Data; this.Data = rhs_data
}

ImVector__grow_capacity :: #force_inline proc(this : ^ImVector($T), sz : i32) -> i32
{
	new_capacity : i32 = this.Capacity != 0 ? (this.Capacity + this.Capacity / 2) : 8;
	return new_capacity > sz ? new_capacity : sz
}

ImVector_resize_0 :: #force_inline proc(this : ^ImVector($T), new_size : i32)
{
	if new_size > this.Capacity { reserve(this, ImVector__grow_capacity(this, new_size)) };
	this.Size = new_size
}

ImVector_resize_1 :: #force_inline proc(this : ^ImVector($T), new_size : i32, v : T)
{
	if new_size > this.Capacity { reserve(this, ImVector__grow_capacity(this, new_size)) };
	if new_size > this.Size {
		for n : i32 = this.Size; n < new_size; n += 1 {
			this.Data[n] = v
		}
	};
	this.Size = new_size
}

// Resize a vector to a smaller size, guaranteed not to cause a reallocation
ImVector_shrink :: #force_inline proc(this : ^ImVector($T), new_size : i32)
{
	IM_ASSERT(new_size <= this.Size); this.Size = new_size
}

ImVector_reserve :: #force_inline proc(this : ^ImVector($T), new_capacity : i32)
{
	if new_capacity <= this.Capacity { return }
	new_data : ^T = cast(^T) IM_ALLOC(cast(uint) new_capacity * size_of(T))
	if this.Data != nil {
		memcpy(new_data, this.Data, cast(int) this.Size * size_of(T))
		IM_FREE(this.Data)
	}
	this.Data = new_data
	this.Capacity = new_capacity
}

ImVector_reserve_discard :: #force_inline proc(this : ^ImVector($T), new_capacity : i32)
{
	if new_capacity <= this.Capacity { return }
	if this.Data != nil { IM_FREE(this.Data) }
	this.Data = cast(^T) IM_ALLOC(cast(uint) new_capacity * size_of(T))
	this.Capacity = new_capacity
}

// NB: It is illegal to call push_back/push_front/insert with a reference pointing inside the ImVector data itself! e.g. v.push_back(v[10]) is forbidden.
ImVector_push_back :: #force_inline proc(this : ^ImVector($T), v : T)
{
	if this.Size == this.Capacity { ImVector_reserve(this, ImVector__grow_capacity(this, this.Size + 1)) }
	this.Data[this.Size] = v
	post_incr(&this.Size)
}

ImVector_pop_back :: #force_inline proc(this : ^ImVector($T))
{
	IM_ASSERT(this.Size > 0); post_decr(&this.Size)
}

ImVector_push_front :: #force_inline proc(this : ^ImVector($T), v : T) { if this.Size == 0 { ImVector_push_back(this, v) }
else { ImVector_insert(this, this.Data, v) } }

ImVector_erase_0 :: #force_inline proc(this : ^ImVector($T), it : ^T) -> ^T
{
	IM_ASSERT(it >= this.Data && it < &this.Data[this.Size])
	off : int = mem.ptr_sub(it, &this.Data[0])
	memmove(&this.Data[off], &this.Data[off + 1], (cast(int) this.Size - off - 1) * size_of(T))
	post_decr(&this.Size)
	return &this.Data[off]
}

ImVector_erase_1 :: #force_inline proc(this : ^ImVector($T), it : ^T, it_last : ^T) -> ^T
{
	IM_ASSERT(it >= this.Data && it < this.Data[this.Size:] && it_last >= it && it_last <= this.Data[this.Size:])
	count : int = mem.ptr_sub(it_last, it)
	off : int = mem.ptr_sub(it, cast(^T)this.Data)
	memmove(&this.Data[off], &this.Data[off + count], (cast(int) this.Size - off - count) * size_of(T))
	this.Size -= cast(i32) count
	return &this.Data[off]
}

ImVector_erase_unsorted :: #force_inline proc(this : ^ImVector($T), it : ^T) -> ^T
{
	IM_ASSERT(it >= this.Data && it < this.Data[this.Size])
	off : int = mem.ptr_sub(it, this.Data)
	if it < this.Data[this.Size - 1] { memcpy(&this.Data[off], &this.Data[this.Size - 1], size_of(T)) }
	post_decr(&this.Size)
	return &this.Data[off]
}

ImVector_insert :: #force_inline proc(this : ^ImVector($T), it : ^T, v : T) -> ^T
{
	IM_ASSERT(it >= this.Data && it <= &this.Data[this.Size])
	off := mem.ptr_sub(it, cast(^T) this.Data)
	if this.Size == this.Capacity { ImVector_reserve(this, ImVector__grow_capacity(this, this.Size + 1)) }
	if cast(i32) off < this.Size { memmove(&this.Data[off + 1], &this.Data[off], (cast(int) this.Size - off) * size_of(T)) }
	this.Data[off] = v
	post_incr(&this.Size)
	return &this.Data[off]
}

ImVector_contains :: #force_inline proc(this : ImVector($T), v : T) -> bool
{
	data : ^T = this.Data; data_end : ^T = &this.Data[this.Size]; for data < data_end { if post_incr(&data)^ == v { return true } }; return false
}

ImVector_find :: #force_inline proc(this : ^ImVector($T), v : T) -> ^T
{
	data : ^T = this.Data; data_end : ^T = &this.Data[this.Size]; for data < data_end { if data^ == v { break }
else { pre_incr(&data) } }; return data
}

ImVector_find_index :: #force_inline proc(this : ^ImVector($T), v : T) -> i32
{
	data_end : ^T = &this.Data[this.Size]; it : ^T = ImVector_find(this, v); if it == data_end { return -1 }; off : int = mem.ptr_sub(it, &this.Data[0]); return cast(i32) off
}

ImVector_find_erase :: #force_inline proc(this : ^ImVector($T), v : T) -> bool
{
	it : ^T = ImVector_find(this, v); if it < &this.Data[this.Size] {erase(this, it); return true
	}; return false
}

ImVector_find_erase_unsorted :: #force_inline proc(this : ^ImVector($T), v : T) -> bool
{
	it : ^T = ImVector_find(this, v); if it < &this.Data[this.Size] {ImVector_erase_unsorted(this, it); return true
	}; return false
}

ImVector_index_from_ptr :: #force_inline proc(this : ^ImVector($T), it : ^T) -> i32
{
	IM_ASSERT(it >= this.Data && it < &this.Data[this.Size]); off : int = mem.ptr_sub(it, &this.Data[0]); return cast(i32) off
}


// Runtime data for styling/colors
//-----------------------------------------------------------------------------
// [SECTION] ImGuiStyle
//-----------------------------------------------------------------------------
// You may modify the ImGui::GetStyle() main instance during initialization and before NewFrame().
// During the frame, use ImGui::PushStyleVar(ImGuiStyleVar_XXXX)/PopStyleVar() to alter the main style values,
// and ImGui::PushStyleColor(ImGuiCol_XXX)/PopStyleColor() for colors.
//-----------------------------------------------------------------------------

ImGuiStyle :: struct {
	Alpha : f32, // Global alpha applies to everything in Dear ImGui.
	DisabledAlpha : f32, // Additional alpha multiplier applied by BeginDisabled(). Multiply over current value of Alpha.
	WindowPadding : ImVec2, // Padding within a window.
	WindowRounding : f32, // Radius of window corners rounding. Set to 0.0f to have rectangular windows. Large values tend to lead to variety of artifacts and are not recommended.
	WindowBorderSize : f32, // Thickness of border around windows. Generally set to 0.0f or 1.0f. (Other values are not well tested and more CPU/GPU costly).
	WindowMinSize : ImVec2, // Minimum window size. This is a global setting. If you want to constrain individual windows, use SetNextWindowSizeConstraints().
	WindowTitleAlign : ImVec2, // Alignment for title bar text. Defaults to (0.0f,0.5f) for left-aligned,vertically centered.
	WindowMenuButtonPosition : ImGuiDir, // Side of the collapsing/docking button in the title bar (None/Left/Right). Defaults to ImGuiDir_Left.
	ChildRounding : f32, // Radius of child window corners rounding. Set to 0.0f to have rectangular windows.
	ChildBorderSize : f32, // Thickness of border around child windows. Generally set to 0.0f or 1.0f. (Other values are not well tested and more CPU/GPU costly).
	PopupRounding : f32, // Radius of popup window corners rounding. (Note that tooltip windows use WindowRounding)
	PopupBorderSize : f32, // Thickness of border around popup/tooltip windows. Generally set to 0.0f or 1.0f. (Other values are not well tested and more CPU/GPU costly).
	FramePadding : ImVec2, // Padding within a framed rectangle (used by most widgets).
	FrameRounding : f32, // Radius of frame corners rounding. Set to 0.0f to have rectangular frame (used by most widgets).
	FrameBorderSize : f32, // Thickness of border around frames. Generally set to 0.0f or 1.0f. (Other values are not well tested and more CPU/GPU costly).
	ItemSpacing : ImVec2, // Horizontal and vertical spacing between widgets/lines.
	ItemInnerSpacing : ImVec2, // Horizontal and vertical spacing between within elements of a composed widget (e.g. a slider and its label).
	CellPadding : ImVec2, // Padding within a table cell. Cellpadding.x is locked for entire table. CellPadding.y may be altered between different rows.
	TouchExtraPadding : ImVec2, // Expand reactive bounding box for touch-based system where touch position is not accurate enough. Unfortunately we don't sort widgets so priority on overlap will always be given to the first widget. So don't grow this too much!
	IndentSpacing : f32, // Horizontal indentation when e.g. entering a tree node. Generally == (FontSize + FramePadding.x*2).
	ColumnsMinSpacing : f32, // Minimum horizontal spacing between two columns. Preferably > (FramePadding.x + 1).
	ScrollbarSize : f32, // Width of the vertical scrollbar, Height of the horizontal scrollbar.
	ScrollbarRounding : f32, // Radius of grab corners for scrollbar.
	GrabMinSize : f32, // Minimum width/height of a grab box for slider/scrollbar.
	GrabRounding : f32, // Radius of grabs corners rounding. Set to 0.0f to have rectangular slider grabs.
	LogSliderDeadzone : f32, // The size in pixels of the dead-zone around zero on logarithmic sliders that cross zero.
	TabRounding : f32, // Radius of upper corners of a tab. Set to 0.0f to have rectangular tabs.
	TabBorderSize : f32, // Thickness of border around tabs.
	TabMinWidthForCloseButton : f32, // Minimum width for close button to appear on an unselected tab when hovered. Set to 0.0f to always show when hovering, set to FLT_MAX to never show close button unless selected.
	TabBarBorderSize : f32, // Thickness of tab-bar separator, which takes on the tab active color to denote focus.
	TabBarOverlineSize : f32, // Thickness of tab-bar overline, which highlights the selected tab-bar.
	TableAngledHeadersAngle : f32, // Angle of angled headers (supported values range from -50.0f degrees to +50.0f degrees).
	TableAngledHeadersTextAlign : ImVec2, // Alignment of angled headers within the cell
	ColorButtonPosition : ImGuiDir, // Side of the color button in the ColorEdit4 widget (left/right). Defaults to ImGuiDir_Right.
	ButtonTextAlign : ImVec2, // Alignment of button text when button is larger than text. Defaults to (0.5f, 0.5f) (centered).
	SelectableTextAlign : ImVec2, // Alignment of selectable text. Defaults to (0.0f, 0.0f) (top-left aligned). It's generally important to keep this left-aligned if you want to lay multiple items on a same line.
	SeparatorTextBorderSize : f32, // Thickness of border in SeparatorText()
	SeparatorTextAlign : ImVec2, // Alignment of text within the separator. Defaults to (0.0f, 0.5f) (left aligned, center).
	SeparatorTextPadding : ImVec2, // Horizontal offset of text from each edge of the separator + spacing on other axis. Generally small values. .y is recommended to be == FramePadding.y.
	DisplayWindowPadding : ImVec2, // Apply to regular windows: amount which we enforce to keep visible when moving near edges of your screen.
	DisplaySafeAreaPadding : ImVec2, // Apply to every windows, menus, popups, tooltips: amount where we avoid displaying contents. Adjust if you cannot see the edges of your screen (e.g. on a TV where scaling has not been configured).
	DockingSeparatorSize : f32, // Thickness of resizing border between docked windows
	MouseCursorScale : f32, // Scale software rendered mouse cursor (when io.MouseDrawCursor is enabled). We apply per-monitor DPI scaling over this scale. May be removed later.
	AntiAliasedLines : bool, // Enable anti-aliased lines/borders. Disable if you are really tight on CPU/GPU. Latched at the beginning of the frame (copied to ImDrawList).
	AntiAliasedLinesUseTex : bool, // Enable anti-aliased lines/borders using textures where possible. Require backend to render with bilinear filtering (NOT point/nearest filtering). Latched at the beginning of the frame (copied to ImDrawList).
	AntiAliasedFill : bool, // Enable anti-aliased edges around filled shapes (rounded rectangles, circles, etc.). Disable if you are really tight on CPU/GPU. Latched at the beginning of the frame (copied to ImDrawList).
	CurveTessellationTol : f32, // Tessellation tolerance when using PathBezierCurveTo() without a specific number of segments. Decrease for highly tessellated curves (higher quality, more polygons), increase to reduce quality.
	CircleTessellationMaxError : f32, // Maximum error (in pixels) allowed when using AddCircle()/AddCircleFilled() or drawing rounded corner rectangles with no explicit segment count specified. Decrease for higher quality but more geometry.
	Colors : [ImGuiCol_.ImGuiCol_COUNT]ImVec4,

	// Behaviors
	// (It is possible to modify those fields mid-frame if specific behavior need it, unlike e.g. configuration fields in ImGuiIO)
	HoverStationaryDelay : f32, // Delay for IsItemHovered(ImGuiHoveredFlags_Stationary). Time required to consider mouse stationary.
	HoverDelayShort : f32, // Delay for IsItemHovered(ImGuiHoveredFlags_DelayShort). Usually used along with HoverStationaryDelay.
	HoverDelayNormal : f32, // Delay for IsItemHovered(ImGuiHoveredFlags_DelayNormal). "
	HoverFlagsForTooltipMouse : ImGuiHoveredFlags, // Default flags when using IsItemHovered(ImGuiHoveredFlags_ForTooltip) or BeginItemTooltip()/SetItemTooltip() while using mouse.
	HoverFlagsForTooltipNav : ImGuiHoveredFlags, // Default flags when using IsItemHovered(ImGuiHoveredFlags_ForTooltip) or BeginItemTooltip()/SetItemTooltip() while using keyboard/gamepad.
}

// Storage for ImGuiIO and IsKeyDown(), IsKeyPressed() etc functions.
//-----------------------------------------------------------------------------
// [SECTION] ImGuiIO
//-----------------------------------------------------------------------------
// Communicate most settings and inputs/outputs to Dear ImGui using this structure.
// Access via ImGui::GetIO(). Read 'Programmer guide' section in .cpp file for general usage.
// It is generally expected that:
// - initialization: backends and user code writes to ImGuiIO.
// - main loop: backends writes to ImGuiIO, user code and imgui code reads from ImGuiIO.
//-----------------------------------------------------------------------------
// Also see ImGui::GetPlatformIO() and ImGuiPlatformIO struct for OS/platform related functions: clipboard, IME etc.
//-----------------------------------------------------------------------------

// [Internal] Storage used by IsKeyDown(), IsKeyPressed() etc functions.
// If prior to 1.87 you used io.KeysDownDuration[] (which was marked as internal), you should use GetKeyData(key)->DownDuration and *NOT* io.KeysData[key]->DownDuration.
ImGuiKeyData :: struct {
	Down : bool, // True for if key is down
	DownDuration : f32, // Duration the key has been down (<0.0f: not pressed, 0.0f: just pressed, >0.0f: time held)
	DownDurationPrev : f32, // Last frame duration the key has been down
	AnalogValue : f32, // 0.0f..1.0f for gamepad values
}

// Main configuration and I/O between your application and ImGui (also see: ImGuiPlatformIO)
ImGuiIO :: struct {
	//------------------------------------------------------------------
	// Configuration                            // Default value
	//------------------------------------------------------------------

	ConfigFlags : ImGuiConfigFlags, // = 0              // See ImGuiConfigFlags_ enum. Set by user/application. Keyboard/Gamepad navigation options, etc.
	BackendFlags : ImGuiBackendFlags, // = 0              // See ImGuiBackendFlags_ enum. Set by backend (imgui_impl_xxx files or custom backend) to communicate features supported by the backend.
	DisplaySize : ImVec2, // <unset>          // Main display size, in pixels (generally == GetMainViewport()->Size). May change every frame.
	DeltaTime : f32, // = 1.0f/60.0f     // Time elapsed since last frame, in seconds. May change every frame.
	IniSavingRate : f32, // = 5.0f           // Minimum time between saving positions/sizes to .ini file, in seconds.
	IniFilename : string, // = "imgui.ini"    // Path to .ini file (important: default "imgui.ini" is relative to current working dir!). Set NULL to disable automatic .ini loading/saving or if you want to manually call LoadIniSettingsXXX() / SaveIniSettingsXXX() functions.
	LogFilename : string, // = "imgui_log.txt"// Path to .log file (default parameter to ImGui::LogToFile when no file is specified).
	UserData : rawptr, // = NULL           // Store your own data.

	// Font system
	Fonts : ^ImFontAtlas, // <auto>           // Font atlas: load, rasterize and pack one or more fonts into a single texture.
	FontGlobalScale : f32, // = 1.0f           // Global scale all fonts
	FontAllowUserScaling : bool, // = false          // [OBSOLETE] Allow user scaling text of individual window with CTRL+Wheel.
	FontDefault : ^ImFont, // = NULL           // Font to use on NewFrame(). Use NULL to uses Fonts->Fonts.Data[0].
	DisplayFramebufferScale : ImVec2, // = (1, 1)         // For retina display or other situations where window coordinates are different from framebuffer coordinates. This generally ends up in ImDrawData::FramebufferScale.

	// Keyboard/Gamepad Navigation options
	ConfigNavSwapGamepadButtons : bool, // = false          // Swap Activate<>Cancel (A<>B) buttons, matching typical "Nintendo/Japanese style" gamepad layout.
	ConfigNavMoveSetMousePos : bool, // = false          // Directional/tabbing navigation teleports the mouse cursor. May be useful on TV/console systems where moving a virtual mouse is difficult. Will update io.MousePos and set io.WantSetMousePos=true.
	ConfigNavCaptureKeyboard : bool, // = true           // Sets io.WantCaptureKeyboard when io.NavActive is set.
	ConfigNavEscapeClearFocusItem : bool, // = true           // Pressing Escape can clear focused item + navigation id/highlight. Set to false if you want to always keep highlight on.
	ConfigNavEscapeClearFocusWindow : bool, // = false          // Pressing Escape can clear focused window as well (super set of io.ConfigNavEscapeClearFocusItem).
	ConfigNavCursorVisibleAuto : bool, // = true           // Using directional navigation key makes the cursor visible. Mouse click hides the cursor.
	ConfigNavCursorVisibleAlways : bool, // = false          // Navigation cursor is always visible.

	// Docking options (when ImGuiConfigFlags_DockingEnable is set)
	ConfigDockingNoSplit : bool, // = false          // Simplified docking mode: disable window splitting, so docking is limited to merging multiple windows together into tab-bars.
	ConfigDockingWithShift : bool, // = false          // Enable docking with holding Shift key (reduce visual noise, allows dropping in wider space)
	ConfigDockingAlwaysTabBar : bool, // = false          // [BETA] [FIXME: This currently creates regression with auto-sizing and general overhead] Make every single floating window display within a docking node.
	ConfigDockingTransparentPayload : bool, // = false          // [BETA] Make window or viewport transparent when docking and only display docking boxes on the target viewport. Useful if rendering of multiple viewport cannot be synced. Best used with ConfigViewportsNoAutoMerge.

	// Viewport options (when ImGuiConfigFlags_ViewportsEnable is set)
	ConfigViewportsNoAutoMerge : bool, // = false;         // Set to make all floating imgui windows always create their own viewport. Otherwise, they are merged into the main host viewports when overlapping it. May also set ImGuiViewportFlags_NoAutoMerge on individual viewport.
	ConfigViewportsNoTaskBarIcon : bool, // = false          // Disable default OS task bar icon flag for secondary viewports. When a viewport doesn't want a task bar icon, ImGuiViewportFlags_NoTaskBarIcon will be set on it.
	ConfigViewportsNoDecoration : bool, // = true           // Disable default OS window decoration flag for secondary viewports. When a viewport doesn't want window decorations, ImGuiViewportFlags_NoDecoration will be set on it. Enabling decoration can create subsequent issues at OS levels (e.g. minimum window size).
	ConfigViewportsNoDefaultParent : bool, // = false          // Disable default OS parenting to main viewport for secondary viewports. By default, viewports are marked with ParentViewportId = <main_viewport>, expecting the platform backend to setup a parent/child relationship between the OS windows (some backend may ignore this). Set to true if you want the default to be 0, then all viewports will be top-level OS windows.

	// Miscellaneous options
	// (you can visualize and interact with all options in 'Demo->Configuration')
	MouseDrawCursor : bool, // = false          // Request ImGui to draw a mouse cursor for you (if you are on a platform without a mouse cursor). Cannot be easily renamed to 'io.ConfigXXX' because this is frequently used by backend implementations.
	ConfigMacOSXBehaviors : bool, // = defined(__APPLE__) // Swap Cmd<>Ctrl keys + OS X style text editing cursor movement using Alt instead of Ctrl, Shortcuts using Cmd/Super instead of Ctrl, Line/Text Start and End using Cmd+Arrows instead of Home/End, Double click selects by word instead of selecting whole text, Multi-selection in lists uses Cmd/Super instead of Ctrl.
	ConfigInputTrickleEventQueue : bool, // = true           // Enable input queue trickling: some types of events submitted during the same frame (e.g. button down + up) will be spread over multiple frames, improving interactions with low framerates.
	ConfigInputTextCursorBlink : bool, // = true           // Enable blinking cursor (optional as some users consider it to be distracting).
	ConfigInputTextEnterKeepActive : bool, // = false          // [BETA] Pressing Enter will keep item active and select contents (single-line only).
	ConfigDragClickToInputText : bool, // = false          // [BETA] Enable turning DragXXX widgets into text input with a simple mouse click-release (without moving). Not desirable on devices without a keyboard.
	ConfigWindowsResizeFromEdges : bool, // = true           // Enable resizing of windows from their edges and from the lower-left corner. This requires ImGuiBackendFlags_HasMouseCursors for better mouse cursor feedback. (This used to be a per-window ImGuiWindowFlags_ResizeFromAnySide flag)
	ConfigWindowsMoveFromTitleBarOnly : bool, // = false      // Enable allowing to move windows only when clicking on their title bar. Does not apply to windows without a title bar.
	ConfigWindowsCopyContentsWithCtrlC : bool, // = false      // [EXPERIMENTAL] CTRL+C copy the contents of focused window into the clipboard. Experimental because: (1) has known issues with nested Begin/End pairs (2) text output quality varies (3) text output is in submission order rather than spatial order.
	ConfigScrollbarScrollByPage : bool, // = true           // Enable scrolling page by page when clicking outside the scrollbar grab. When disabled, always scroll to clicked location. When enabled, Shift+Click scrolls to clicked location.
	ConfigMemoryCompactTimer : f32, // = 60.0f          // Timer (in seconds) to free transient windows/tables memory buffers when unused. Set to -1.0f to disable.

	// Inputs Behaviors
	// (other variables, ones which are expected to be tweaked within UI code, are exposed in ImGuiStyle)
	MouseDoubleClickTime : f32, // = 0.30f          // Time for a double-click, in seconds.
	MouseDoubleClickMaxDist : f32, // = 6.0f           // Distance threshold to stay in to validate a double-click, in pixels.
	MouseDragThreshold : f32, // = 6.0f           // Distance threshold before considering we are dragging.
	KeyRepeatDelay : f32, // = 0.275f         // When holding a key/button, time before it starts repeating, in seconds (for buttons in Repeat mode, etc.).
	KeyRepeatRate : f32, // = 0.050f         // When holding a key/button, rate at which it repeats, in seconds.

	//------------------------------------------------------------------
	// Debug options
	//------------------------------------------------------------------

	// Options to configure Error Handling and how we handle recoverable errors [EXPERIMENTAL]
	// - Error recovery is provided as a way to facilitate:
	//    - Recovery after a programming error (native code or scripting language - the later tends to facilitate iterating on code while running).
	//    - Recovery after running an exception handler or any error processing which may skip code after an error has been detected.
	// - Error recovery is not perfect nor guaranteed! It is a feature to ease development.
	//   You not are not supposed to rely on it in the course of a normal application run.
	// - Functions that support error recovery are using IM_ASSERT_USER_ERROR() instead of IM_ASSERT().
	// - By design, we do NOT allow error recovery to be 100% silent. One of the three options needs to be checked!
	// - Always ensure that on programmers seats you have at minimum Asserts or Tooltips enabled when making direct imgui API calls!
	//   Otherwise it would severely hinder your ability to catch and correct mistakes!
	// Read https://github.com/ocornut/imgui/wiki/Error-Handling for details.
	// - Programmer seats: keep asserts (default), or disable asserts and keep error tooltips (new and nice!)
	// - Non-programmer seats: maybe disable asserts, but make sure errors are resurfaced (tooltips, visible log entries, use callback etc.)
	// - Recovery after error/exception: record stack sizes with ErrorRecoveryStoreState(), disable assert, set log callback (to e.g. trigger high-level breakpoint), recover with ErrorRecoveryTryToRecoverState(), restore settings.
	ConfigErrorRecovery : bool, // = true       // Enable error recovery support. Some errors won't be detected and lead to direct crashes if recovery is disabled.
	ConfigErrorRecoveryEnableAssert : bool, // = true       // Enable asserts on recoverable error. By default call IM_ASSERT() when returning from a failing IM_ASSERT_USER_ERROR()
	ConfigErrorRecoveryEnableDebugLog : bool, // = true       // Enable debug log output on recoverable errors.
	ConfigErrorRecoveryEnableTooltip : bool, // = true       // Enable tooltip on recoverable errors. The tooltip include a way to enable asserts if they were disabled.

	// Option to enable various debug tools showing buttons that will call the IM_DEBUG_BREAK() macro.
	// - The Item Picker tool will be available regardless of this being enabled, in order to maximize its discoverability.
	// - Requires a debugger being attached, otherwise IM_DEBUG_BREAK() options will appear to crash your application.
	//   e.g. io.ConfigDebugIsDebuggerPresent = ::IsDebuggerPresent() on Win32, or refer to ImOsIsDebuggerPresent() imgui_test_engine/imgui_te_utils.cpp for a Unix compatible version).
	ConfigDebugIsDebuggerPresent : bool, // = false          // Enable various tools calling IM_DEBUG_BREAK().

	// Tools to detect code submitting items with conflicting/duplicate IDs
	// - Code should use PushID()/PopID() in loops, or append "##xx" to same-label identifiers.
	// - Empty label e.g. Button("") == same ID as parent widget/node. Use Button("##xx") instead!
	// - See FAQ https://github.com/ocornut/imgui/blob/master/docs/FAQ.md#q-about-the-id-stack-system
	ConfigDebugHighlightIdConflicts : bool, // = true           // Highlight and show an error message when multiple items have conflicting identifiers.

	// Tools to test correct Begin/End and BeginChild/EndChild behaviors.
	// - Presently Begin()/End() and BeginChild()/EndChild() needs to ALWAYS be called in tandem, regardless of return value of BeginXXX()
	// - This is inconsistent with other BeginXXX functions and create confusion for many users.
	// - We expect to update the API eventually. In the meanwhile we provide tools to facilitate checking user-code behavior.
	ConfigDebugBeginReturnValueOnce : bool, // = false          // First-time calls to Begin()/BeginChild() will return false. NEEDS TO BE SET AT APPLICATION BOOT TIME if you don't want to miss windows.
	ConfigDebugBeginReturnValueLoop : bool, // = false          // Some calls to Begin()/BeginChild() will return false. Will cycle through window depths then repeat. Suggested use: add "io.ConfigDebugBeginReturnValue = io.KeyShift" in your main loop then occasionally press SHIFT. Windows should be flickering while running.

	// Option to deactivate io.AddFocusEvent(false) handling.
	// - May facilitate interactions with a debugger when focus loss leads to clearing inputs data.
	// - Backends may have other side-effects on focus loss, so this will reduce side-effects but not necessary remove all of them.
	ConfigDebugIgnoreFocusLoss : bool, // = false          // Ignore io.AddFocusEvent(false), consequently not calling io.ClearInputKeys()/io.ClearInputMouse() in input processing.

	// Option to audit .ini data
	ConfigDebugIniSettings : bool, // = false          // Save .ini data with extra comments (particularly helpful for Docking, but makes saving slower)

	//------------------------------------------------------------------
	// Platform Identifiers
	// (the imgui_impl_xxxx backend files are setting those up for you)
	//------------------------------------------------------------------

	// Nowadays those would be stored in ImGuiPlatformIO but we are leaving them here for legacy reasons.
	// Optional: Platform/Renderer backend name (informational only! will be displayed in About Window) + User data for backend/wrappers to store their own stuff.
	BackendPlatformName : string, // = NULL
	BackendRendererName : string, // = NULL
	BackendPlatformUserData : rawptr, // = NULL           // User data for platform backend
	BackendRendererUserData : rawptr, // = NULL           // User data for renderer backend
	BackendLanguageUserData : rawptr, // = NULL           // User data for non C++ programming language backend

	//------------------------------------------------------------------
	// Output - Updated by NewFrame() or EndFrame()/Render()
	// (when reading from the io.WantCaptureMouse, io.WantCaptureKeyboard flags to dispatch your inputs, it is
	//  generally easier and more correct to use their state BEFORE calling NewFrame(). See FAQ for details!)
	//------------------------------------------------------------------

	WantCaptureMouse : bool, // Set when Dear ImGui will use mouse inputs, in this case do not dispatch them to your main game/application (either way, always pass on mouse inputs to imgui). (e.g. unclicked mouse is hovering over an imgui window, widget is active, mouse was clicked over an imgui window, etc.).
	WantCaptureKeyboard : bool, // Set when Dear ImGui will use keyboard inputs, in this case do not dispatch them to your main game/application (either way, always pass keyboard inputs to imgui). (e.g. InputText active, or an imgui window is focused and navigation is enabled, etc.).
	WantTextInput : bool, // Mobile/console: when set, you may display an on-screen keyboard. This is set by Dear ImGui when it wants textual keyboard input to happen (e.g. when a InputText widget is active).
	WantSetMousePos : bool, // MousePos has been altered, backend should reposition mouse on next frame. Rarely used! Set only when io.ConfigNavMoveSetMousePos is enabled.
	WantSaveIniSettings : bool, // When manual .ini load/save is active (io.IniFilename == NULL), this will be set to notify your application that you can call SaveIniSettingsToMemory() and save yourself. Important: clear io.WantSaveIniSettings yourself after saving!
	NavActive : bool, // Keyboard/Gamepad navigation is currently allowed (will handle ImGuiKey_NavXXX events) = a window is focused and it doesn't use the ImGuiWindowFlags_NoNavInputs flag.
	NavVisible : bool, // Keyboard/Gamepad navigation highlight is visible and allowed (will handle ImGuiKey_NavXXX events).
	Framerate : f32, // Estimate of application framerate (rolling average over 60 frames, based on io.DeltaTime), in frame per second. Solely for convenience. Slow applications may not want to use a moving average or may want to reset underlying buffers occasionally.
	MetricsRenderVertices : i32, // Vertices output during last call to Render()
	MetricsRenderIndices : i32, // Indices output during last call to Render() = number of triangles * 3
	MetricsRenderWindows : i32, // Number of visible windows
	MetricsActiveWindows : i32, // Number of active windows
	MouseDelta : ImVec2, // Mouse delta. Note that this is zero if either current or previous position are invalid (-FLT_MAX,-FLT_MAX), so a disappearing/reappearing mouse won't have a huge delta.

	//------------------------------------------------------------------
	// [Internal] Dear ImGui will maintain those fields. Forward compatibility not guaranteed!
	//------------------------------------------------------------------

	Ctx : ^ImGuiContext, // Parent UI context (needs to be set explicitly by parent).

	// Main Input State
	// (this block used to be written by backend, since 1.87 it is best to NOT write to those directly, call the AddXXX functions above instead)
	// (reading from those variables is fair game, as they are extremely unlikely to be moving anywhere)
	MousePos : ImVec2, // Mouse position, in pixels. Set to ImVec2{-FLT_MAX, -FLT_MAX} if mouse is unavailable (on another screen, etc.)
	MouseDown : [5]bool, // Mouse buttons: 0=left, 1=right, 2=middle + extras (ImGuiMouseButton_COUNT == 5). Dear ImGui mostly uses left and right buttons. Other buttons allow us to track if the mouse is being used by your application + available to user as a convenience via IsMouse** API.
	MouseWheel : f32, // Mouse wheel Vertical: 1 unit scrolls about 5 lines text. >0 scrolls Up, <0 scrolls Down. Hold SHIFT to turn vertical scroll into horizontal scroll.
	MouseWheelH : f32, // Mouse wheel Horizontal. >0 scrolls Left, <0 scrolls Right. Most users don't have a mouse with a horizontal wheel, may not be filled by all backends.
	MouseSource : ImGuiMouseSource, // Mouse actual input peripheral (Mouse/TouchScreen/Pen).
	MouseHoveredViewport : ImGuiID, // (Optional) Modify using io.AddMouseViewportEvent(). With multi-viewports: viewport the OS mouse is hovering. If possible _IGNORING_ viewports with the ImGuiViewportFlags_NoInputs flag is much better (few backends can handle that). Set io.BackendFlags |= ImGuiBackendFlags_HasMouseHoveredViewport if you can provide this info. If you don't imgui will infer the value using the rectangles and last focused time of the viewports it knows about (ignoring other OS windows).
	KeyCtrl : bool, // Keyboard modifier down: Control
	KeyShift : bool, // Keyboard modifier down: Shift
	KeyAlt : bool, // Keyboard modifier down: Alt
	KeySuper : bool, // Keyboard modifier down: Cmd/Super/Windows

	// Other state maintained from data above + IO function calls
	KeyMods : ImGuiKeyChord, // Key mods flags (any of ImGuiMod_Ctrl/ImGuiMod_Shift/ImGuiMod_Alt/ImGuiMod_Super flags, same as io.KeyCtrl/KeyShift/KeyAlt/KeySuper but merged into flags. Read-only, updated by NewFrame()
	KeysData : [ImGuiKey.ImGuiKey_NamedKey_COUNT]ImGuiKeyData, // Key state for all known keys. Use IsKeyXXX() functions to access this.
	WantCaptureMouseUnlessPopupClose : bool, // Alternative to WantCaptureMouse: (WantCaptureMouse == true && WantCaptureMouseUnlessPopupClose == false) when a click over void is expected to close a popup.
	MousePosPrev : ImVec2, // Previous mouse position (note that MouseDelta is not necessary == MousePos-MousePosPrev, in case either position is invalid)
	MouseClickedPos : [5]ImVec2, // Position at time of clicking
	MouseClickedTime : [5]f64, // Time of last click (used to figure out double-click)
	MouseClicked : [5]bool, // Mouse button went from !Down to Down (same as MouseClickedCount[x] != 0)
	MouseDoubleClicked : [5]bool, // Has mouse button been double-clicked? (same as MouseClickedCount[x] == 2)
	MouseClickedCount : [5]ImU16, // == 0 (not clicked), == 1 (same as MouseClicked[]), == 2 (double-clicked), == 3 (triple-clicked) etc. when going from !Down to Down
	MouseClickedLastCount : [5]ImU16, // Count successive number of clicks. Stays valid after mouse release. Reset after another click is done.
	MouseReleased : [5]bool, // Mouse button went from Down to !Down
	MouseDownOwned : [5]bool, // Track if button was clicked inside a dear imgui window or over void blocked by a popup. We don't request mouse capture from the application if click started outside ImGui bounds.
	MouseDownOwnedUnlessPopupClose : [5]bool, // Track if button was clicked inside a dear imgui window.
	MouseWheelRequestAxisSwap : bool, // On a non-Mac system, holding SHIFT requests WheelY to perform the equivalent of a WheelX event. On a Mac system this is already enforced by the system.
	MouseCtrlLeftAsRightClick : bool, // (OSX) Set to true when the current click was a ctrl-click that spawned a simulated right click
	MouseDownDuration : [5]f32, // Duration the mouse button has been down (0.0f == just clicked)
	MouseDownDurationPrev : [5]f32, // Previous time the mouse button has been down
	MouseDragMaxDistanceAbs : [5]ImVec2, // Maximum distance, absolute, on each axis, of how much mouse has traveled from the clicking point
	MouseDragMaxDistanceSqr : [5]f32, // Squared maximum distance of how much mouse has traveled from the clicking point (used for moving thresholds)
	PenPressure : f32, // Touch/Pen pressure (0.0f to 1.0f, should be >0.0f only when MouseDown[0] == true). Helper storage currently unused by Dear ImGui.
	AppFocusLost : bool, // Only modify via AddFocusEvent()
	AppAcceptingEvents : bool, // Only modify via SetAppAcceptingEvents()
	InputQueueSurrogate : ImWchar16, // For AddInputCharacterUTF16()
	InputQueueCharacters : ImVector(ImWchar), // Queue of _characters_ input (obtained by platform backend). Fill using AddInputCharacter() helper.
}

ImGuiIO_deinit :: proc(this : ^ImGuiIO)
{
	deinit(&this.InputQueueCharacters)
}

// Shared state of InputText() when using custom ImGuiInputTextCallback (rare/advanced use)
//-----------------------------------------------------------------------------
// [SECTION] Misc data structures (ImGuiInputTextCallbackData, ImGuiSizeCallbackData, ImGuiPayload)
//-----------------------------------------------------------------------------

// Shared state of InputText(), passed as an argument to your callback when a ImGuiInputTextFlags_Callback* flag is used.
// The callback function should return 0 by default.
// Callbacks (follow a flag name and see comments in ImGuiInputTextFlags_ declarations for more details)
// - ImGuiInputTextFlags_CallbackEdit:        Callback on buffer edit (note that InputText() already returns true on edit, the callback is useful mainly to manipulate the underlying buffer while focus is active)
// - ImGuiInputTextFlags_CallbackAlways:      Callback on each iteration
// - ImGuiInputTextFlags_CallbackCompletion:  Callback on pressing TAB
// - ImGuiInputTextFlags_CallbackHistory:     Callback on pressing Up/Down arrows
// - ImGuiInputTextFlags_CallbackCharFilter:  Callback on character inputs to replace or discard them. Modify 'EventChar' to replace or discard, or return 1 in callback to discard.
// - ImGuiInputTextFlags_CallbackResize:      Callback on buffer capacity changes request (beyond 'buf_size' parameter value), allowing the string to grow.
ImGuiInputTextCallbackData :: struct {
	Ctx : ^ImGuiContext, // Parent UI context
	EventFlag : ImGuiInputTextFlags, // One ImGuiInputTextFlags_Callback*    // Read-only
	Flags : ImGuiInputTextFlags, // What user passed to InputText()      // Read-only
	UserData : rawptr, // What user passed to InputText()      // Read-only

	// Arguments for the different callback events
	// - During Resize callback, Buf will be same as your input buffer.
	// - However, during Completion/History/Always callback, Buf always points to our own internal data (it is not the same as your buffer)! Changes to it will be reflected into your own buffer shortly after the callback.
	// - To modify the text buffer in a callback, prefer using the InsertChars() / DeleteChars() function. InsertChars() will take care of calling the resize callback if necessary.
	// - If you know your edits are not going to resize the underlying buffer allocation, you may modify the contents of 'Buf.Data[]' directly. You need to update 'BufTextLen' accordingly (0 <= BufTextLen < BufSize) and set 'BufDirty'' to true so InputText can update its internal state.
	EventChar : ImWchar, // Character input                      // Read-write   // [CharFilter] Replace character with another one, or set to zero to drop. return 1 is equivalent to setting EventChar=0;
	EventKey : ImGuiKey, // Key pressed (Up/Down/TAB)            // Read-only    // [Completion,History]
	Buf : [^]u8, // Text buffer                          // Read-write   // [Resize] Can replace pointer / [Completion,History,Always] Only write to pointed data, don't replace the actual pointer!
	BufTextLen : i32, // Text length (in bytes)               // Read-write   // [Resize,Completion,History,Always] Exclude zero-terminator storage. In C land: == strlen(some_text), in C++ land: string.length()
	BufSize : i32, // Buffer size (in bytes) = capacity+1  // Read-only    // [Resize,Completion,History,Always] Include zero-terminator storage. In C land == ARRAYSIZE(my_char_array), in C++ land: string.capacity()+1
	BufDirty : bool, // Set if you modify Buf/BufTextLen!    // Write        // [Completion,History,Always]
	CursorPos : i32, //                                      // Read-write   // [Completion,History,Always]
	SelectionStart : i32, //                                      // Read-write   // [Completion,History,Always] == to SelectionEnd when no selection)
	SelectionEnd : i32, //                                      // Read-write   // [Completion,History,Always]
}

ImGuiInputTextCallbackData_SelectAll :: proc(this : ^ImGuiInputTextCallbackData)
{
	this.SelectionStart = 0; this.SelectionEnd = this.BufTextLen
}

ImGuiInputTextCallbackData_ClearSelection :: proc(this : ^ImGuiInputTextCallbackData) { this.SelectionEnd = this.BufTextLen; this.SelectionStart = this.SelectionEnd }

ImGuiInputTextCallbackData_HasSelection :: proc(this : ^ImGuiInputTextCallbackData) -> bool { return this.SelectionStart != this.SelectionEnd }

// Callback data when using SetNextWindowSizeConstraints() (rare/advanced use)
// Resizing callback data to apply custom constraint. As enabled by SetNextWindowSizeConstraints(). Callback is called during the next Begin().
// NB: For basic min/max size constraint on each axis you don't need to use the callback! The SetNextWindowSizeConstraints() parameters are enough.
ImGuiSizeCallbackData :: struct {
	UserData : rawptr, // Read-only.   What user passed to SetNextWindowSizeConstraints(). Generally store an integer or float in here (need reinterpret_cast<>).
	Pos : ImVec2, // Read-only.   Window position, for reference.
	CurrentSize : ImVec2, // Read-only.   Current window size.
	DesiredSize : ImVec2, // Read-write.  Desired size, based on user's mouse position. Write to this field to restrain resizing.
}

// Window class (rare/advanced uses: provide hints to the platform backend via altered viewport flags and parent/child info)
// [ALPHA] Rarely used / very advanced uses only. Use with SetNextWindowClass() and DockSpace() functions.
// Important: the content of this class is still highly WIP and likely to change and be refactored
// before we stabilize Docking features. Please be mindful if using this.
// Provide hints:
// - To the platform backend via altered viewport flags (enable/disable OS decoration, OS task bar icons, etc.)
// - To the platform backend for OS level parent/child relationships of viewport.
// - To the docking system for various options and filtering.
ImGuiWindowClass :: struct {
	ClassId : ImGuiID, // User data. 0 = Default class (unclassed). Windows of different classes cannot be docked with each others.
	ParentViewportId : ImGuiID, // Hint for the platform backend. -1: use default. 0: request platform backend to not parent the platform. != 0: request platform backend to create a parent<>child relationship between the platform windows. Not conforming backends are free to e.g. parent every viewport to the main viewport or not.
	FocusRouteParentWindowId : ImGuiID, // ID of parent window for shortcut focus route evaluation, e.g. Shortcut() call from Parent Window will succeed when this window is focused.
	ViewportFlagsOverrideSet : ImGuiViewportFlags, // Viewport flags to set when a window of this class owns a viewport. This allows you to enforce OS decoration or task bar icon, override the defaults on a per-window basis.
	ViewportFlagsOverrideClear : ImGuiViewportFlags, // Viewport flags to clear when a window of this class owns a viewport. This allows you to enforce OS decoration or task bar icon, override the defaults on a per-window basis.
	TabItemFlagsOverrideSet : ImGuiTabItemFlags, // [EXPERIMENTAL] TabItem flags to set when a window of this class gets submitted into a dock node tab bar. May use with ImGuiTabItemFlags_Leading or ImGuiTabItemFlags_Trailing.
	DockNodeFlagsOverrideSet : ImGuiDockNodeFlags, // [EXPERIMENTAL] Dock node flags to set when a window of this class is hosted by a dock node (it doesn't have to be selected!)
	DockingAlwaysTabBar : bool, // Set to true to enforce single floating windows of this class always having their own docking node (equivalent of setting the global io.ConfigDockingAlwaysTabBar)
	DockingAllowUnclassed : bool, // Set to true to allow windows of this class to be docked/merged with an unclassed window. // FIXME-DOCK: Move to DockNodeFlags override?
}

ImGuiWindowClass_init :: proc(this : ^ImGuiWindowClass)
{
	this^ = {}; this.ParentViewportId = ~ImGuiID(0); this.DockingAllowUnclassed = true
}

// User data payload for drag and drop operations
// Data payload for Drag and Drop operations: AcceptDragDropPayload(), GetDragDropPayload()
ImGuiPayload :: struct {
	// Members
	Data : rawptr, // Data (copied and owned by dear imgui)
	DataSize : i32, // Data size

	// [Internal]
	SourceId : ImGuiID, // Source item id
	SourceParentId : ImGuiID, // Source parent id (if available)
	DataFrameCount : i32, // Data timestamp
	DataType : [32 + 1]u8, // Data type tag (short user-supplied string, 32 characters max)
	Preview : bool, // Set when AcceptDragDropPayload() was called and mouse has been hovering the target item (nb: handle overlapping drag targets)
	Delivery : bool, // Set when AcceptDragDropPayload() was called and mouse button is released over the target item.
}

ImGuiPayload_init :: proc(this : ^ImGuiPayload) { Clear(this) }

ImGuiPayload_Clear :: proc(this : ^ImGuiPayload)
{
	this.SourceParentId = 0
	this.SourceId = this.SourceParentId
	this.Data = nil
	this.DataSize = 0
	this.DataType = {}
	this.DataFrameCount = -1
	this.Delivery = false
	this.Preview = this.Delivery
}

ImGuiPayload_IsDataType :: proc(this : ^ImGuiPayload, type : string) -> bool {
	return this.DataFrameCount != -1 && type == string_from_slice(this.DataType[:])
}

ImGuiPayload_IsPreview :: proc(this : ^ImGuiPayload) -> bool { return this.Preview }

ImGuiPayload_IsDelivery :: proc(this : ^ImGuiPayload) -> bool { return this.Delivery }

//-----------------------------------------------------------------------------
// [SECTION] Helpers (ImGuiOnceUponAFrame, ImGuiTextFilter, ImGuiTextBuffer, ImGuiStorage, ImGuiListClipper, Math Operators, ImColor)
//-----------------------------------------------------------------------------

// Helper: Unicode defines
IM_UNICODE_CODEPOINT_INVALID :: 0xFFFD// Invalid Unicode code point (standard value).
when IMGUI_USE_WCHAR32 { /* @gen ifdef */
IM_UNICODE_CODEPOINT_MAX :: 0x10FFFF// Maximum Unicode code point supported by this build.
} else { // preproc else
IM_UNICODE_CODEPOINT_MAX :: 0xFFFF// Maximum Unicode code point supported by this build.
} // preproc endif

// Helper for running a block of code not more than once a frame
// Helper: Execute a block of code at maximum once a frame. Convenient if you want to quickly create a UI within deep-nested code that runs multiple times every frame.
// Usage: static ImGuiOnceUponAFrame oaf; if (oaf) ImGui::Text("This will be called only once per frame");
ImGuiOnceUponAFrame :: struct {
	RefFrame : i32,
}

ImGuiOnceUponAFrame_init :: proc(this : ^ImGuiOnceUponAFrame) { this.RefFrame = -1 }

// Helper to parse and apply text filters (e.g. "aaaaa[,bbbbb][,ccccc]")
// Helper: Parse and apply text filters. In format "aaaaa[,bbbb][,ccccc]"
ImGuiTextFilter :: struct {
	InputBuf : [256]u8,
	Filters : ImVector(ImGuiTextFilter_ImGuiTextRange),
	CountGrep : i32,
}

ImGuiTextFilter_deinit :: proc(this : ^ImGuiTextFilter)
{
	deinit(&this.Filters)
}

ImGuiTextFilter_Clear :: proc(this : ^ImGuiTextFilter)
{
	this.InputBuf[0] = 0; ImGuiTextFilter_Build(this)
}

ImGuiTextFilter_IsActive :: proc(this : ^ImGuiTextFilter) -> bool { return !empty(&this.Filters) }

// [Internal]
// [Internal]
ImGuiTextFilter_ImGuiTextRange :: struct {
	b : [^]u8,
	e : ^u8,
}

ImGuiTextFilter_ImGuiTextRange_init_1 :: proc(this : ^ImGuiTextFilter_ImGuiTextRange, _b : [^]u8, _e : ^u8)
{
	this.b = _b; this.e = _e
}

ImGuiTextFilter_ImGuiTextRange_empty :: proc(this : ^ImGuiTextFilter_ImGuiTextRange) -> bool { return this.b == this.e }

// Helper to hold and append into a text buffer (~string builder)
// Helper: Growable text buffer for logging/accumulating text
// (this could be called 'ImGuiTextBuilder' / 'ImGuiStringBuilder')
ImGuiTextBuffer :: struct {
	Buf : ImVector(u8),
}

ImGuiTextBuffer_EmptyString : [1]u8

ImGuiTextBuffer_deinit :: proc(this : ^ImGuiTextBuffer) { deinit(&this.Buf) }

ImGuiTextBuffer_init :: proc(this : ^ImGuiTextBuffer) { init(&this.Buf) }

ImGuiTextBuffer_begin :: proc(this : ^ImGuiTextBuffer) -> [^]u8 { return this.Buf.Data != nil ? front(&this.Buf) : raw_data(&ImGuiTextBuffer_EmptyString) }

// Buf is zero-terminated, so end() will point on the zero-terminator
ImGuiTextBuffer_end :: proc(this : ^ImGuiTextBuffer) -> ^u8 { return this.Buf.Data != nil ? back(&this.Buf) : raw_data(&ImGuiTextBuffer_EmptyString) }

ImGuiTextBuffer_size :: proc(this : ^ImGuiTextBuffer) -> i32 { return this.Buf.Size != 0 ? this.Buf.Size - 1 : 0 }

ImGuiTextBuffer_empty :: proc(this : ^ImGuiTextBuffer) -> bool { return this.Buf.Size <= 1 }

ImGuiTextBuffer_clear :: proc(this : ^ImGuiTextBuffer) { clear(&this.Buf) }

ImGuiTextBuffer_reserve :: proc(this : ^ImGuiTextBuffer, capacity : i32) { reserve(&this.Buf, capacity) }

ImGuiTextBuffer_c_str :: proc(this : ^ImGuiTextBuffer) -> [^]u8 { return this.Buf.Data != nil ? this.Buf.Data : raw_data(&ImGuiTextBuffer_EmptyString) }

// Helper for key->value storage (pair)
// [Internal] Key+Value for ImGuiStorage
ImGuiStoragePair :: struct {
	key : ImGuiID,
	using _0 : struct #raw_union { val_i : i32, val_f : f32, val_p : rawptr, },
}

ImGuiStoragePair_init_0 :: proc(this : ^ImGuiStoragePair, _key : ImGuiID, _val : i32)
{
	this.key = _key; this.val_i = _val
}

ImGuiStoragePair_init_1 :: proc(this : ^ImGuiStoragePair, _key : ImGuiID, _val : f32)
{
	this.key = _key; this.val_f = _val
}

ImGuiStoragePair_init_2 :: proc(this : ^ImGuiStoragePair, _key : ImGuiID, _val : rawptr)
{
	this.key = _key; this.val_p = _val
}

// Helper for key->value storage (container sorted by key)
// Helper: Key->Value storage
// Typically you don't have to worry about this since a storage is held within each Window.
// We use it to e.g. store collapse state for a tree (Int 0/1)
// This is optimized for efficient lookup (dichotomy into a contiguous buffer) and rare insertion (typically tied to user interactions aka max once a frame)
// You can use it as custom user storage for temporary values. Declare your own storage if, for example:
// - You want to manipulate the open/close state of a particular sub-tree in your interface (tree node uses Int 0/1 to store their state).
// - You want to store custom debug data easily without adding or editing structures in your code (probably not efficient, but convenient)
// Types are NOT stored, so it is up to you to make sure your Key don't collide with different types.
ImGuiStorage :: struct {
	// [Internal]
	Data : ImVector(ImGuiStoragePair),
}

ImGuiStorage_deinit :: proc(this : ^ImGuiStorage) { deinit(&this.Data) }

// - Get***() functions find pair, never add/allocate. Pairs are sorted so a query is O(log N)
// - Set***() functions find pair, insertion on demand if missing.
// - Sorted insertion is costly, paid once. A typical frame shouldn't need to insert any new pair.
ImGuiStorage_Clear :: proc(this : ^ImGuiStorage) { clear(&this.Data) }

ImGuiStorage_init :: proc(this : ^ImGuiStorage) { init(&this.Data) }

// Helper to manually clip large list of items
// Helper: Manually clip large list of items.
// If you have lots evenly spaced items and you have random access to the list, you can perform coarse
// clipping based on visibility to only submit items that are in view.
// The clipper calculates the range of visible items and advance the cursor to compensate for the non-visible items we have skipped.
// (Dear ImGui already clip items based on their bounds but: it needs to first layout the item to do so, and generally
//  fetching/submitting your own data incurs additional cost. Coarse clipping using ImGuiListClipper allows you to easily
//  scale using lists with tens of thousands of items without a problem)
// Usage:
//   ImGuiListClipper clipper;
//   clipper.Begin(1000);         // We have 1000 elements, evenly spaced.
//   while (clipper.Step())
//       for (int i = clipper.DisplayStart; i < clipper.DisplayEnd; i++)
//           ImGui::Text("line number %d", i);
// Generally what happens is:
// - Clipper lets you process the first element (DisplayStart = 0, DisplayEnd = 1) regardless of it being visible or not.
// - User code submit that one element.
// - Clipper can measure the height of the first element
// - Clipper calculate the actual range of elements to display based on the current clipping rectangle, position the cursor before the first visible element.
// - User code submit visible elements.
// - The clipper also handles various subtleties related to keyboard/gamepad navigation, wrapping etc.
ImGuiListClipper :: struct {
	Ctx : ^ImGuiContext, // Parent UI context
	DisplayStart : i32, // First item to display, updated by each call to Step()
	DisplayEnd : i32, // End of items to display (exclusive)
	ItemsCount : i32, // [Internal] Number of items
	ItemsHeight : f32, // [Internal] Height of item after a first step and item submission can calculate it
	StartPosY : f32, // [Internal] Cursor position at the time of Begin() or after table frozen rows are all processed
	StartSeekOffsetY : f64, // [Internal] Account for frozen rows in a table and initial loss of precision in very large windows.
	TempData : rawptr, // [Internal] Internal data
}

// Call IncludeItemByIndex() or IncludeItemsByIndex() *BEFORE* first call to Step() if you need a range of items to not be clipped, regardless of their visibility.
// (Due to alignment / padding of certain items it is possible that an extra item may be included on either end of the display range).
ImGuiListClipper_IncludeItemByIndex :: #force_inline proc(this : ^ImGuiListClipper, item_index : i32) { IncludeItemsByIndex(this, item_index, item_index + 1) }

// Helpers macros to generate 32-bit encoded colors
// - User can declare their own format by #defining the 5 _SHIFT/_MASK macros in their imconfig file.
// - Any setting other than the default will need custom backend support. The only standard backend that supports anything else than the default is DirectX9.
when IMGUI_USE_BGRA_PACKED_COLOR {
IM_COL32_R_SHIFT :: 16
IM_COL32_G_SHIFT :: 8
IM_COL32_B_SHIFT :: 0
IM_COL32_A_SHIFT :: 24
IM_COL32_A_MASK :: 0xFF000000
} else { // preproc else
IM_COL32_R_SHIFT :: 0
IM_COL32_G_SHIFT :: 8
IM_COL32_B_SHIFT :: 16
IM_COL32_A_SHIFT :: 24
IM_COL32_A_MASK :: 0xFF000000
} // preproc endif
IM_COL32 :: #force_inline proc "contextless" (R : $T0, G : $T1, B : $T2, A : $T3) -> ImU32
{
	return (cast(ImU32)(A) << IM_COL32_A_SHIFT)|(cast(ImU32)(B) << IM_COL32_B_SHIFT)|(cast(ImU32)(G) << IM_COL32_G_SHIFT)|(cast(ImU32)(R) << IM_COL32_R_SHIFT)
}

IM_COL32_WHITE       : ImU32 : (255 << IM_COL32_R_SHIFT)|(255 << IM_COL32_G_SHIFT)|(255 << IM_COL32_B_SHIFT)|(255 << IM_COL32_A_SHIFT) // Opaque white = 0xFFFFFFFF
IM_COL32_BLACK       : ImU32 : (0   << IM_COL32_R_SHIFT)|(0   << IM_COL32_G_SHIFT)|(0   << IM_COL32_B_SHIFT)|(255 << IM_COL32_A_SHIFT) // Opaque black
IM_COL32_BLACK_TRANS : ImU32 : (0   << IM_COL32_R_SHIFT)|(0   << IM_COL32_G_SHIFT)|(0   << IM_COL32_B_SHIFT)|(0   << IM_COL32_A_SHIFT) // Transparent black = 0x00000000

// Helper: ImColor() implicitly converts colors to either ImU32 (packed 4x1 byte) or ImVec4 (4x1 float)
// Prefer using IM_COL32() macros if you want a guaranteed compile-time ImU32 for usage with ImDrawList API.
// **Avoid storing ImColor! Store either u32 of ImVec4. This is not a full-featured color class. MAY OBSOLETE.
// **None of the ImGui API are using ImColor directly but you can use it as a convenience to pass colors in either ImU32 or ImVec4 formats. Explicitly cast to ImU32 or ImVec4 if needed.
ImColor :: struct {
	using Value : ImVec4,
}

ImColor_init_1 :: proc(this : ^ImColor, r : f32, g : f32, b : f32, a : f32 = 1.0)
{
	this.Value.rgba = {r, g, b, a}
}

ImColor_init_2 :: proc(this : ^ImColor, col : ^ImVec4)
{
	this.Value = col^
}

ImColor_init_3 :: proc(this : ^ImColor, r : i32, g : i32, b : i32, a : i32 = 255)
{
	this.Value.rgba = {cast(f32)r, cast(f32)g, cast(f32)b, cast(f32)a} * 1.0/255.0
}

ImColor_init_4 :: proc(this : ^ImColor, rgba : ImU32)
{
	this.Value = {cast(f32) ((rgba >> IM_COL32_R_SHIFT) & 0xFF) * (1.0 / 255.0), cast(f32) ((rgba >> IM_COL32_G_SHIFT) & 0xFF) * (1.0 / 255.0), cast(f32) ((rgba >> IM_COL32_B_SHIFT) & 0xFF) * (1.0 / 255.0), cast(f32) ((rgba >> IM_COL32_A_SHIFT) & 0xFF) * (1.0 / 255.0)}
}

// FIXME-OBSOLETE: May need to obsolete/cleanup those helpers.
ImColor_SetHSV :: #force_inline proc(this : ^ImColor, h : f32, s : f32, v : f32, a : f32 = 1.0)
{
	ColorConvertHSVtoRGB(h, s, v, &this.Value.x, &this.Value.y, &this.Value.z); this.Value.w = a
}

ImColor_HSV :: proc(this : ^ImColor, h : f32, s : f32, v : f32, a : f32 = 1.0) -> ImColor
{
	r : f32; g : f32; b : f32; ColorConvertHSVtoRGB(h, s, v, &r, &g, &b); return ImColor{{r, g, b, a}}
}

//-----------------------------------------------------------------------------
// [SECTION] Multi-Select API flags and structures (ImGuiMultiSelectFlags, ImGuiSelectionRequestType, ImGuiSelectionRequest, ImGuiMultiSelectIO, ImGuiSelectionBasicStorage)
//-----------------------------------------------------------------------------

// Multi-selection system
// Documentation at: https://github.com/ocornut/imgui/wiki/Multi-Select
// - Refer to 'Demo->Widgets->Selection State & Multi-Select' for demos using this.
// - This system implements standard multi-selection idioms (CTRL+Mouse/Keyboard, SHIFT+Mouse/Keyboard, etc)
//   with support for clipper (skipping non-visible items), box-select and many other details.
// - Selectable(), Checkbox() are supported but custom widgets may use it as well.
// - TreeNode() is technically supported but... using this correctly is more complicated: you need some sort of linear/random access to your tree,
//   which is suited to advanced trees setups also implementing filters and clipper. We will work toward simplifying and demoing it.
// - In the spirit of Dear ImGui design, your code owns actual selection data.
//   This is designed to allow all kinds of selection storage you may use in your application e.g. set/map/hash.
// About ImGuiSelectionBasicStorage:
// - This is an optional helper to store a selection state and apply selection requests.
// - It is used by our demos and provided as a convenience to quickly implement multi-selection.
// Usage:
// - Identify submitted items with SetNextItemSelectionUserData(), most likely using an index into your current data-set.
// - Store and maintain actual selection data using persistent object identifiers.
// - Usage flow:
//     BEGIN - (1) Call BeginMultiSelect() and retrieve the ImGuiMultiSelectIO* result.
//           - (2) Honor request list (SetAll/SetRange requests) by updating your selection data. Same code as Step 6.
//           - (3) [If using clipper] You need to make sure RangeSrcItem is always submitted. Calculate its index and pass to clipper.IncludeItemByIndex(). If storing indices in ImGuiSelectionUserData, a simple clipper.IncludeItemByIndex(ms_io->RangeSrcItem) call will work.
//     LOOP  - (4) Submit your items with SetNextItemSelectionUserData() + Selectable()/TreeNode() calls.
//     END   - (5) Call EndMultiSelect() and retrieve the ImGuiMultiSelectIO* result.
//           - (6) Honor request list (SetAll/SetRange requests) by updating your selection data. Same code as Step 2.
//     If you submit all items (no clipper), Step 2 and 3 are optional and will be handled by each item themselves. It is fine to always honor those steps.
// About ImGuiSelectionUserData:
// - This can store an application-defined identifier (e.g. index or pointer) submitted via SetNextItemSelectionUserData().
// - In return we store them into RangeSrcItem/RangeFirstItem/RangeLastItem and other fields in ImGuiMultiSelectIO.
// - Most applications will store an object INDEX, hence the chosen name and type. Storing an index is natural, because
//   SetRange requests will give you two end-points and you will need to iterate/interpolate between them to update your selection.
// - However it is perfectly possible to store a POINTER or another IDENTIFIER inside ImGuiSelectionUserData.
//   Our system never assume that you identify items by indices, it never attempts to interpolate between two values.
// - If you enable ImGuiMultiSelectFlags_NoRangeSelect then it is guaranteed that you will never have to interpolate
//   between two ImGuiSelectionUserData, which may be a convenient way to use part of the feature with less code work.
// - As most users will want to store an index, for convenience and to reduce confusion we use ImS64 instead of void*,
//   being syntactically easier to downcast. Feel free to reinterpret_cast and store a pointer inside.

// Flags for BeginMultiSelect()
ImGuiMultiSelectFlags_ :: enum i32 {
	ImGuiMultiSelectFlags_None = 0,
	ImGuiMultiSelectFlags_SingleSelect = 1 << 0, // Disable selecting more than one item. This is available to allow single-selection code to share same code/logic if desired. It essentially disables the main purpose of BeginMultiSelect() tho!
	ImGuiMultiSelectFlags_NoSelectAll = 1 << 1, // Disable CTRL+A shortcut to select all.
	ImGuiMultiSelectFlags_NoRangeSelect = 1 << 2, // Disable Shift+selection mouse/keyboard support (useful for unordered 2D selection). With BoxSelect is also ensure contiguous SetRange requests are not combined into one. This allows not handling interpolation in SetRange requests.
	ImGuiMultiSelectFlags_NoAutoSelect = 1 << 3, // Disable selecting items when navigating (useful for e.g. supporting range-select in a list of checkboxes).
	ImGuiMultiSelectFlags_NoAutoClear = 1 << 4, // Disable clearing selection when navigating or selecting another one (generally used with ImGuiMultiSelectFlags_NoAutoSelect. useful for e.g. supporting range-select in a list of checkboxes).
	ImGuiMultiSelectFlags_NoAutoClearOnReselect = 1 << 5, // Disable clearing selection when clicking/selecting an already selected item.
	ImGuiMultiSelectFlags_BoxSelect1d = 1 << 6, // Enable box-selection with same width and same x pos items (e.g. full row Selectable()). Box-selection works better with little bit of spacing between items hit-box in order to be able to aim at empty space.
	ImGuiMultiSelectFlags_BoxSelect2d = 1 << 7, // Enable box-selection with varying width or varying x pos items support (e.g. different width labels, or 2D layout/grid). This is slower: alters clipping logic so that e.g. horizontal movements will update selection of normally clipped items.
	ImGuiMultiSelectFlags_BoxSelectNoScroll = 1 << 8, // Disable scrolling when box-selecting near edges of scope.
	ImGuiMultiSelectFlags_ClearOnEscape = 1 << 9, // Clear selection when pressing Escape while scope is focused.
	ImGuiMultiSelectFlags_ClearOnClickVoid = 1 << 10, // Clear selection when clicking on empty location within scope.
	ImGuiMultiSelectFlags_ScopeWindow = 1 << 11, // Scope for _BoxSelect and _ClearOnClickVoid is whole window (Default). Use if BeginMultiSelect() covers a whole window or used a single time in same window.
	ImGuiMultiSelectFlags_ScopeRect = 1 << 12, // Scope for _BoxSelect and _ClearOnClickVoid is rectangle encompassing BeginMultiSelect()/EndMultiSelect(). Use if BeginMultiSelect() is called multiple times in same window.
	ImGuiMultiSelectFlags_SelectOnClick = 1 << 13, // Apply selection on mouse down when clicking on unselected item. (Default)
	ImGuiMultiSelectFlags_SelectOnClickRelease = 1 << 14, // Apply selection on mouse release when clicking an unselected item. Allow dragging an unselected item without altering selection.
	//ImGuiMultiSelectFlags_RangeSelect2d       = 1 << 15,  // Shift+Selection uses 2d geometry instead of linear sequence, so possible to use Shift+up/down to select vertically in grid. Analogous to what BoxSelect does.
	ImGuiMultiSelectFlags_NavWrapX = 1 << 16, // [Temporary] Enable navigation wrapping on X axis. Provided as a convenience because we don't have a design for the general Nav API for this yet. When the more general feature be public we may obsolete this flag in favor of new one.
}

// Structure to interact with a BeginMultiSelect()/EndMultiSelect() block
// Main IO structure returned by BeginMultiSelect()/EndMultiSelect().
// This mainly contains a list of selection requests.
// - Use 'Demo->Tools->Debug Log->Selection' to see requests as they happen.
// - Some fields are only useful if your list is dynamic and allows deletion (getting post-deletion focus/state right is shown in the demo)
// - Below: who reads/writes each fields? 'r'=read, 'w'=write, 'ms'=multi-select code, 'app'=application/user code.
ImGuiMultiSelectIO :: struct {
	//------------------------------------------// BeginMultiSelect / EndMultiSelect
	Requests : ImVector(ImGuiSelectionRequest), //  ms:w, app:r     /  ms:w  app:r   // Requests to apply to your selection data.
	RangeSrcItem : ImGuiSelectionUserData, //  ms:w  app:r     /                // (If using clipper) Begin: Source item (often the first selected item) must never be clipped: use clipper.IncludeItemByIndex() to ensure it is submitted.
	NavIdItem : ImGuiSelectionUserData, //  ms:w, app:r     /                // (If using deletion) Last known SetNextItemSelectionUserData() value for NavId (if part of submitted items).
	NavIdSelected : bool, //  ms:w, app:r     /        app:r   // (If using deletion) Last known selection state for NavId (if part of submitted items).
	RangeSrcReset : bool, //        app:w     /  ms:r          // (If using deletion) Set before EndMultiSelect() to reset ResetSrcItem (e.g. if deleted selection).
	ItemsCount : i32, //  ms:w, app:r     /        app:r   // 'int items_count' parameter to BeginMultiSelect() is copied here for convenience, allowing simpler calls to your ApplyRequests handler. Not used internally.
}

ImGuiMultiSelectIO_deinit :: proc(this : ^ImGuiMultiSelectIO) { deinit(&this.Requests) }

ImGuiMultiSelectIO_init :: proc(this : ^ImGuiMultiSelectIO) { init(&this.Requests) }

// Selection request type
ImGuiSelectionRequestType :: enum i32 {
	ImGuiSelectionRequestType_None = 0,
	ImGuiSelectionRequestType_SetAll, // Request app to clear selection (if Selected==false) or select all items (if Selected==true). We cannot set RangeFirstItem/RangeLastItem as its contents is entirely up to user (not necessarily an index)
	ImGuiSelectionRequestType_SetRange, // Request app to select/unselect [RangeFirstItem..RangeLastItem] items (inclusive) based on value of Selected. Only EndMultiSelect() request this, app code can read after BeginMultiSelect() and it will always be false.
}

// A selection request (stored in ImGuiMultiSelectIO)
// Selection request item
ImGuiSelectionRequest :: struct {
	//------------------------------------------// BeginMultiSelect / EndMultiSelect
	Type : ImGuiSelectionRequestType, //  ms:w, app:r     /  ms:w, app:r   // Request type. You'll most often receive 1 Clear + 1 SetRange with a single-item range.
	Selected : bool, //  ms:w, app:r     /  ms:w, app:r   // Parameter for SetAll/SetRange requests (true = select, false = unselect)
	RangeDirection : ImS8, //                  /  ms:w  app:r   // Parameter for SetRange request: +1 when RangeFirstItem comes before RangeLastItem, -1 otherwise. Useful if you want to preserve selection order on a backward Shift+Click.
	RangeFirstItem : ImGuiSelectionUserData, //                  /  ms:w, app:r   // Parameter for SetRange request (this is generally == RangeSrcItem when shift selecting from top to bottom).
	RangeLastItem : ImGuiSelectionUserData, //                  /  ms:w, app:r   // Parameter for SetRange request (this is generally == RangeSrcItem when shift selecting from bottom to top). Inclusive!
}

// Optional helper to store multi-selection state + apply multi-selection requests.
// Optional helper to store multi-selection state + apply multi-selection requests.
// - Used by our demos and provided as a convenience to easily implement basic multi-selection.
// - Iterate selection with 'void* it = NULL; ImGuiID id; while (selection.GetNextSelectedItem(&it, &id)) { ... }'
//   Or you can check 'if (Contains(id)) { ... }' for each possible object if their number is not too high to iterate.
// - USING THIS IS NOT MANDATORY. This is only a helper and not a required API.
// To store a multi-selection, in your application you could:
// - Use this helper as a convenience. We use our simple key->value ImGuiStorage as a std::set<ImGuiID> replacement.
// - Use your own external storage: e.g. std::set<MyObjectId>, std::vector<MyObjectId>, interval trees, intrusively stored selection etc.
// In ImGuiSelectionBasicStorage we:
// - always use indices in the multi-selection API (passed to SetNextItemSelectionUserData(), retrieved in ImGuiMultiSelectIO)
// - use the AdapterIndexToStorageId() indirection layer to abstract how persistent selection data is derived from an index.
// - use decently optimized logic to allow queries and insertion of very large selection sets.
// - do not preserve selection order.
// Many combinations are possible depending on how you prefer to store your items and how you prefer to store your selection.
// Large applications are likely to eventually want to get rid of this indirection layer and do their own thing.
// See https://github.com/ocornut/imgui/wiki/Multi-Select for details and pseudo-code using this helper.
ImGuiSelectionBasicStorage :: struct {
	// Members
	Size : i32, //          // Number of selected items, maintained by this helper.
	PreserveOrder : bool, // = false  // GetNextSelectedItem() will return ordered selection (currently implemented by two additional sorts of selection. Could be improved)
	UserData : rawptr, // = NULL   // User data for use by adapter function        // e.g. selection.UserData = (void*)my_items;
	AdapterIndexToStorageId : proc(_self : ^ImGuiSelectionBasicStorage, _idx : i32) -> ImGuiID, // e.g. selection.AdapterIndexToStorageId = [](ImGuiSelectionBasicStorage* self, int idx) { return ((MyItems**)self->UserData)[idx]->ID; };
	_SelectionOrder : i32, // [Internal] Increasing counter to store selection order
	_Storage : ImGuiStorage, // [Internal] Selection set. Think of this as similar to e.g. std::set<ImGuiID>. Prefer not accessing directly: iterate with GetNextSelectedItem().
}

ImGuiSelectionBasicStorage_deinit :: proc(this : ^ImGuiSelectionBasicStorage) { deinit(&this._Storage) }

// Convert index to item id based on provided adapter.
ImGuiSelectionBasicStorage_GetStorageIdFromIndex :: #force_inline proc(this : ^ImGuiSelectionBasicStorage, idx : i32) -> ImGuiID { return this.AdapterIndexToStorageId(this, idx) }

//Optional helper to apply multi-selection requests to existing randomly accessible storage.
// Optional helper to apply multi-selection requests to existing randomly accessible storage.
// Convenient if you want to quickly wire multi-select API on e.g. an array of bool or items storing their own selection state.
ImGuiSelectionExternalStorage :: struct {
	// Members
	UserData : rawptr, // User data for use by adapter function                                // e.g. selection.UserData = (void*)my_items;
	AdapterSetItemSelected : proc(_self : ^ImGuiSelectionExternalStorage, _idx : i32, _selected : bool), // e.g. AdapterSetItemSelected = [](ImGuiSelectionExternalStorage* self, int idx, bool selected) { ((MyItems**)self->UserData)[idx]->Selected = selected; }
}

//-----------------------------------------------------------------------------
// [SECTION] Drawing API (ImDrawCmd, ImDrawIdx, ImDrawVert, ImDrawChannel, ImDrawListSplitter, ImDrawListFlags, ImDrawList, ImDrawData)
// Hold a series of drawing commands. The user provides a renderer for ImDrawData which essentially contains an array of ImDrawList.
//-----------------------------------------------------------------------------

// The maximum line width to bake anti-aliased textures for. Build atlas with ImFontAtlasFlags_NoBakedLines to disable baking.
//when ! defined ( IM_DRAWLIST_TEX_LINES_WIDTH_MAX ) {
IM_DRAWLIST_TEX_LINES_WIDTH_MAX :: (63)
//} // preproc endif

// ImDrawCallback: Draw callbacks for advanced uses [configurable type: override in imconfig.h]
// NB: You most likely do NOT need to use draw callbacks just to create your own widget or customized UI rendering,
// you can poke into the draw list for that! Draw callback may be useful for example to:
//  A) Change your GPU render state,
//  B) render a complex 3D scene inside a UI element without an intermediate texture/render target, etc.
// The expected behavior from your rendering function is 'if (cmd.UserCallback != NULL) { cmd.UserCallback(parent_list, cmd); } else { RenderTriangles() }'
// If you want to override the signature of ImDrawCallback, you can simply use e.g. '#define ImDrawCallback MyDrawCallback' (in imconfig.h) + update rendering backend accordingly.
//when ! defined ( ImDrawCallback ) {
ImDrawCallback :: proc(parent_list : ^ImDrawList, cmd : ^ImDrawCmd)
//} // preproc endif

// Special Draw callback value to request renderer backend to reset the graphics/render state.
// The renderer backend needs to handle this special value, otherwise it will crash trying to call a function at this address.
// This is useful, for example, if you submitted callbacks which you know have altered the render state and you want it to be restored.
// Render state is not reset by default because they are many perfectly useful way of altering render state (e.g. changing shader/blending settings before an Image call).
ImDrawCallback_ResetRenderState := transmute(ImDrawCallback)transmute(rawptr)transmute(uint)int(-8)

// A single draw command within a parent ImDrawList (generally maps to 1 GPU draw call, unless it is a callback)
// Typically, 1 command = 1 GPU draw call (unless command is a callback)
// - VtxOffset: When 'io.BackendFlags & ImGuiBackendFlags_RendererHasVtxOffset' is enabled,
//   this fields allow us to render meshes larger than 64K vertices while keeping 16-bit indices.
//   Backends made for <1.71. will typically ignore the VtxOffset fields.
// - The ClipRect/TextureId/VtxOffset fields must be contiguous as we memcmp() them together (this is asserted for).
ImDrawCmd :: struct {
	ClipRect : ImVec4, // 4*4  // Clipping rectangle (x1, y1, x2, y2). Subtract ImDrawData->DisplayPos to get clipping rectangle in "viewport" coordinates
	TextureId : ImTextureID, // 4-8  // User-provided texture ID. Set by user in ImfontAtlas::SetTexID() for fonts or passed to Image*() functions. Ignore if never using images or multiple fonts atlas.
	VtxOffset : u32, // 4    // Start offset in vertex buffer. ImGuiBackendFlags_RendererHasVtxOffset: always 0, otherwise may be >0 to support meshes larger than 64K vertices with 16-bit indices.
	IdxOffset : u32, // 4    // Start offset in index buffer.
	ElemCount : u32, // 4    // Number of indices (multiple of 3) to be rendered as triangles. Vertices are stored in the callee ImDrawList's vtx_buffer[] array, indices in idx_buffer[].
	UserCallback : ImDrawCallback, // 4-8  // If != NULL, call the function instead of rendering the vertices. clip_rect and texture_id will be set normally.
	UserCallbackData : rawptr, // 4-8  // Callback user data (when UserCallback != NULL). If called AddCallback() with size == 0, this is a copy of the AddCallback() argument. If called AddCallback() with size > 0, this is pointing to a buffer where data is stored.
	UserCallbackDataSize : i32, // 4 // Size of callback user data when using storage, otherwise 0.
	UserCallbackDataOffset : i32, // 4 // [Internal] Offset of callback user data when using storage, otherwise -1.
}

// Also ensure our padding fields are zeroed
ImDrawCmd_init :: proc(this : ^ImDrawCmd) { this^ = {} }

// Since 1.83: returns ImTextureID associated with this draw call. Warning: DO NOT assume this is always same as 'TextureId' (we will change this function for an upcoming feature)
ImDrawCmd_GetTexID :: #force_inline proc(this : ^ImDrawCmd) -> ImTextureID { return this.TextureId }

// Vertex layout
//when ! defined ( IMGUI_OVERRIDE_DRAWVERT_STRUCT_LAYOUT ) {
// A single vertex (pos + uv + col = 20 bytes by default. Override layout with IMGUI_OVERRIDE_DRAWVERT_STRUCT_LAYOUT)
ImDrawVert :: struct {
	pos : ImVec2,
	uv : ImVec2,
	col : ImU32,
}
//} else { // preproc else
// You can override the vertex format layout by defining IMGUI_OVERRIDE_DRAWVERT_STRUCT_LAYOUT in imconfig.h
// The code expect ImVec2 pos (8 bytes), ImVec2 uv (8 bytes), ImU32 col (4 bytes), but you can re-order them or add other fields as needed to simplify integration in your engine.
// The type has to be described within the macro (you can either declare the struct or use a typedef). This is because ImVec2/ImU32 are likely not declared at the time you'd want to set your type up.
// NOTE: IMGUI DOESN'T CLEAR THE STRUCTURE AND DOESN'T CALL A CONSTRUCTOR SO ANY CUSTOM FIELD WILL BE UNINITIALIZED. IF YOU ADD EXTRA FIELDS (SUCH AS A 'Z' COORDINATES) YOU WILL NEED TO CLEAR THEM DURING RENDER OR TO IGNORE THEM.
//IMGUI_OVERRIDE_DRAWVERT_STRUCT_LAYOUT;
//} // preproc endif

// [Internal] For use by ImDrawList
ImDrawCmdHeader :: struct {
	ClipRect : ImVec4,
	TextureId : ImTextureID,
	VtxOffset : u32,
}

// Forward declarations
// Temporary storage to output draw commands out of order, used by ImDrawListSplitter and ImDrawList::ChannelsSplit()
// [Internal] For use by ImDrawListSplitter
ImDrawChannel :: struct {
	_CmdBuffer : ImVector(ImDrawCmd),
	_IdxBuffer : ImVector(ImDrawIdx),
}

ImDrawChannel_deinit :: proc(this : ^ImDrawChannel)
{
	deinit(&this._CmdBuffer)
	deinit(&this._IdxBuffer)
}

ImDrawChannel_init :: proc(this : ^ImDrawChannel)
{
	init(&this._CmdBuffer)
	init(&this._IdxBuffer)
}


// Helper to split a draw list into different layers which can be drawn into out of order, then flattened back.
// Split/Merge functions are used to split the draw list into different layers which can be drawn into out of order.
// This is used by the Columns/Tables API, so items of each column can be batched together in a same draw call.
ImDrawListSplitter :: struct {
	_Current : i32, // Current channel number (0)
	_Count : i32, // Number of active channels (1+)
	_Channels : ImVector(ImDrawChannel), // Draw channels (not resized down so _Count might be < Channels.Size)
}

ImDrawListSplitter_deinit :: proc(this : ^ImDrawListSplitter) {
	deinit(&this._Channels)
	ImDrawListSplitter_ClearFreeMemory(this)
}

ImDrawListSplitter_init :: #force_inline proc(this : ^ImDrawListSplitter) { this^ = {} }

// Do not clear Channels[] so our allocations are reused next frame
ImDrawListSplitter_Clear :: #force_inline proc(this : ^ImDrawListSplitter)
{
	this._Current = 0; this._Count = 1
}

// Flags for ImDrawList functions
// (Legacy: bit 0 must always correspond to ImDrawFlags_Closed to be backward compatible with old API using a bool. Bits 1..3 must be unused)
ImDrawFlags_ :: enum i32 {
	ImDrawFlags_None = 0,
	ImDrawFlags_Closed = 1 << 0, // PathStroke(), AddPolyline(): specify that shape should be closed (Important: this is always == 1 for legacy reason)
	ImDrawFlags_RoundCornersTopLeft = 1 << 4, // AddRect(), AddRectFilled(), PathRect(): enable rounding top-left corner only (when rounding > 0.0f, we default to all corners). Was 0x01.
	ImDrawFlags_RoundCornersTopRight = 1 << 5, // AddRect(), AddRectFilled(), PathRect(): enable rounding top-right corner only (when rounding > 0.0f, we default to all corners). Was 0x02.
	ImDrawFlags_RoundCornersBottomLeft = 1 << 6, // AddRect(), AddRectFilled(), PathRect(): enable rounding bottom-left corner only (when rounding > 0.0f, we default to all corners). Was 0x04.
	ImDrawFlags_RoundCornersBottomRight = 1 << 7, // AddRect(), AddRectFilled(), PathRect(): enable rounding bottom-right corner only (when rounding > 0.0f, we default to all corners). Wax 0x08.
	ImDrawFlags_RoundCornersNone = 1 << 8, // AddRect(), AddRectFilled(), PathRect(): disable rounding on all corners (when rounding > 0.0f). This is NOT zero, NOT an implicit flag!
	ImDrawFlags_RoundCornersTop = ImDrawFlags_RoundCornersTopLeft | ImDrawFlags_RoundCornersTopRight,
	ImDrawFlags_RoundCornersBottom = ImDrawFlags_RoundCornersBottomLeft | ImDrawFlags_RoundCornersBottomRight,
	ImDrawFlags_RoundCornersLeft = ImDrawFlags_RoundCornersBottomLeft | ImDrawFlags_RoundCornersTopLeft,
	ImDrawFlags_RoundCornersRight = ImDrawFlags_RoundCornersBottomRight | ImDrawFlags_RoundCornersTopRight,
	ImDrawFlags_RoundCornersAll = ImDrawFlags_RoundCornersTopLeft | ImDrawFlags_RoundCornersTopRight | ImDrawFlags_RoundCornersBottomLeft | ImDrawFlags_RoundCornersBottomRight,
	ImDrawFlags_RoundCornersDefault_ = ImDrawFlags_RoundCornersAll, // Default to ALL corners if none of the _RoundCornersXX flags are specified.
	ImDrawFlags_RoundCornersMask_ = ImDrawFlags_RoundCornersAll | ImDrawFlags_RoundCornersNone,
}

// Flags for ImDrawList instance. Those are set automatically by ImGui:: functions from ImGuiIO settings, and generally not manipulated directly.
// It is however possible to temporarily alter flags between calls to ImDrawList:: functions.
ImDrawListFlags_ :: enum i32 {
	ImDrawListFlags_None = 0,
	ImDrawListFlags_AntiAliasedLines = 1 << 0, // Enable anti-aliased lines/borders (*2 the number of triangles for 1.0f wide line or lines thin enough to be drawn using textures, otherwise *3 the number of triangles)
	ImDrawListFlags_AntiAliasedLinesUseTex = 1 << 1, // Enable anti-aliased lines/borders using textures when possible. Require backend to render with bilinear filtering (NOT point/nearest filtering).
	ImDrawListFlags_AntiAliasedFill = 1 << 2, // Enable anti-aliased edge around filled shapes (rounded rectangles, circles).
	ImDrawListFlags_AllowVtxOffset = 1 << 3, // Can emit 'VtxOffset > 0' to allow large meshes. Set when 'ImGuiBackendFlags_RendererHasVtxOffset' is enabled.
}

// A single draw command list (generally one per window, conceptually you may see this as a dynamic "mesh" builder)
// Draw command list
// This is the low-level list of polygons that ImGui:: functions are filling. At the end of the frame,
// all command lists are passed to your ImGuiIO::RenderDrawListFn function for rendering.
// Each dear imgui window contains its own ImDrawList. You can use ImGui::GetWindowDrawList() to
// access the current window draw list and draw custom primitives.
// You can interleave normal ImGui:: calls and adding primitives to the current draw list.
// In single viewport mode, top-left is == GetMainViewport()->Pos (generally 0,0), bottom-right is == GetMainViewport()->Pos+Size (generally io.DisplaySize).
// You are totally free to apply whatever transformation matrix you want to the data (depending on the use of the transformation you may want to apply it to ClipRect as well!)
// Important: Primitives are always added to the list and not culled (culling is done at higher-level by ImGui:: functions), if you use this API a lot consider coarse culling your drawn objects.
ImDrawList :: struct {
	// This is what you have to render
	CmdBuffer : ImVector(ImDrawCmd), // Draw commands. Typically 1 command = 1 GPU draw call, unless the command is a callback.
	IdxBuffer : ImVector(ImDrawIdx), // Index buffer. Each command consume ImDrawCmd::ElemCount of those
	VtxBuffer : ImVector(ImDrawVert), // Vertex buffer.
	Flags : ImDrawListFlags, // Flags, you may poke into these to adjust anti-aliasing settings per-primitive.

	// [Internal, used while building lists]
	_VtxCurrentIdx : u32, // [Internal] generally == VtxBuffer.Size unless we are past 64K vertices, in which case this gets reset to 0.
	_Data : ^ImDrawListSharedData, // Pointer to shared draw data (you can use ImGui::GetDrawListSharedData() to get the one from current ImGui context)
	_VtxWritePtr : [^]ImDrawVert, // [Internal] point within VtxBuffer.Data after each add command (to avoid using the ImVector<> operators too much)
	_IdxWritePtr : [^]ImDrawIdx, // [Internal] point within IdxBuffer.Data after each add command (to avoid using the ImVector<> operators too much)
	_Path : ImVector(ImVec2), // [Internal] current path building
	_CmdHeader : ImDrawCmdHeader, // [Internal] template of active commands. Fields should match those of CmdBuffer.back().
	_Splitter : ImDrawListSplitter, // [Internal] for channels api (note: prefer using your own persistent instance of ImDrawListSplitter!)
	_ClipRectStack : ImVector(ImVec4), // [Internal]
	_TextureIdStack : ImVector(ImTextureID), // [Internal]
	_CallbacksDataBuf : ImVector(ImU8), // [Internal]
	_FringeScale : f32, // [Internal] anti-alias fringe is scaled by this value, this helps to keep things sharp while zooming at vertex buffer content
	_OwnerName : string, // Pointer to owner window's name for debugging
}

ImDrawList_GetClipRectMin :: #force_inline proc(this : ^ImDrawList) -> ImVec2
{
	cr : ^ImVec4 = back(&this._ClipRectStack); return ImVec2{cr.x, cr.y}
}

ImDrawList_GetClipRectMax :: #force_inline proc(this : ^ImDrawList) -> ImVec2
{
	cr : ^ImVec4 = back(&this._ClipRectStack); return ImVec2{cr.z, cr.w}
}

// Stateful path API, add points then finish with PathFillConvex() or PathStroke()
// - Important: filled shapes must always use clockwise winding order! The anti-aliasing fringe depends on it. Counter-clockwise shapes will have "inward" anti-aliasing.
//   so e.g. 'PathArcTo(center, radius, PI * -0.5f, PI)' is ok, whereas 'PathArcTo(center, radius, PI, PI * -0.5f)' won't have correct anti-aliasing when followed by PathFillConvex().
ImDrawList_PathClear :: #force_inline proc(this : ^ImDrawList) { this._Path.Size = 0 }

ImDrawList_PathLineTo :: #force_inline proc(this : ^ImDrawList, pos : ImVec2) { push_back(&this._Path, pos) }

ImDrawList_PathLineToMergeDuplicate :: #force_inline proc(this : ^ImDrawList, pos : ImVec2) {
	if this._Path.Size == 0 || this._Path.Data[this._Path.Size - 1] != pos { push_back(&this._Path, pos) }
}

ImDrawList_PathFillConvex :: #force_inline proc(this : ^ImDrawList, col : ImU32)
{
	ImDrawList_AddConvexPolyFilled(this, this._Path.Data, this._Path.Size, col); this._Path.Size = 0
}

ImDrawList_PathFillConcave :: #force_inline proc(this : ^ImDrawList, col : ImU32)
{
	ImDrawList_AddConcavePolyFilled(this, this._Path.Data[:this._Path.Size], col); this._Path.Size = 0
}

ImDrawList_PathStroke :: #force_inline proc(this : ^ImDrawList, col : ImU32, flags : ImDrawFlags = {}, thickness : f32 = 1.0)
{
	ImDrawList_AddPolyline(this, this._Path.Data[:this._Path.Size], col, flags, thickness); this._Path.Size = 0
}

// Advanced: Channels
// - Use to split render into layers. By switching channels to can render out-of-order (e.g. submit FG primitives before BG primitives)
// - Use to minimize draw calls (e.g. if going back-and-forth between multiple clipping rectangles, prefer to append into separate channels then merge at the end)
// - This API shouldn't have been in ImDrawList in the first place!
//   Prefer using your own persistent instance of ImDrawListSplitter as you can stack them.
//   Using the ImDrawList::ChannelsXXXX you cannot stack a split over another.
ImDrawList_ChannelsSplit :: #force_inline proc(this : ^ImDrawList, count : i32) { Split(&this._Splitter, this, count) }

ImDrawList_ChannelsMerge :: #force_inline proc(this : ^ImDrawList) { Merge(&this._Splitter, this) }

ImDrawList_ChannelsSetCurrent :: #force_inline proc(this : ^ImDrawList, n : i32) { SetCurrentChannel(&this._Splitter, this, n) }

ImDrawList_PrimWriteVtx :: #force_inline proc(this : ^ImDrawList, pos : ImVec2, uv : ImVec2, col : ImU32)
{
	this._VtxWritePtr[0].pos = pos; this._VtxWritePtr[0].uv = uv; this._VtxWritePtr[0].col = col; post_incr(&this._VtxWritePtr); post_incr(&this._VtxCurrentIdx)
}

ImDrawList_PrimWriteIdx :: #force_inline proc(this : ^ImDrawList, idx : ImDrawIdx)
{
	this._IdxWritePtr[0] = idx; post_incr(&this._IdxWritePtr)
}

// Write vertex with unique index
ImDrawList_PrimVtx :: #force_inline proc(this : ^ImDrawList, pos : ImVec2, uv : ImVec2, col : ImU32)
{
	ImDrawList_PrimWriteIdx(this, cast(ImDrawIdx) this._VtxCurrentIdx); ImDrawList_PrimWriteVtx(this, pos, uv, col)
}

// All draw command lists required to render the frame + pos/size coordinates to use for the projection matrix.
// All draw data to render a Dear ImGui frame
// (NB: the style and the naming convention here is a little inconsistent, we currently preserve them for backward compatibility purpose,
// as this is one of the oldest structure exposed by the library! Basically, ImDrawList == CmdList)
ImDrawData :: struct {
	Valid : bool, // Only valid after Render() is called and before the next NewFrame() is called.
	CmdListsCount : i32, // Number of ImDrawList* to render
	TotalIdxCount : i32, // For convenience, sum of all ImDrawList's IdxBuffer.Size
	TotalVtxCount : i32, // For convenience, sum of all ImDrawList's VtxBuffer.Size
	CmdLists : ImVector(^ImDrawList), // Array of ImDrawList* to render. The ImDrawLists are owned by ImGuiContext and only pointed to from here.
	DisplayPos : ImVec2, // Top-left position of the viewport to render (== top-left of the orthogonal projection matrix to use) (== GetMainViewport()->Pos for the main viewport, == (0.0) in most single-viewport applications)
	DisplaySize : ImVec2, // Size of the viewport to render (== GetMainViewport()->Size for the main viewport, == io.DisplaySize in most single-viewport applications)
	FramebufferScale : ImVec2, // Amount of pixels for each unit of DisplaySize. Based on io.DisplayFramebufferScale. Generally (1,1) on normal display, (2,2) on OSX with Retina display.
	OwnerViewport : ^ImGuiViewport, // Viewport carrying the ImDrawData instance, might be of use to the renderer (generally not).
}

ImDrawData_deinit :: proc(this : ^ImDrawData)
{
	deinit(&this.CmdLists)
}

// Functions
ImDrawData_init :: proc(this : ^ImDrawData) {
	init(&this.CmdLists)
	this.DisplayPos = {}
	this.DisplaySize = {}
	this.FramebufferScale = {}
	Clear(this)
}

// Configuration data when adding a font or merging fonts
//-----------------------------------------------------------------------------
// [SECTION] Font API (ImFontConfig, ImFontGlyph, ImFontAtlasFlags, ImFontAtlas, ImFontGlyphRangesBuilder, ImFont)
//-----------------------------------------------------------------------------

ImFontConfig :: struct {
	FontData : rawptr, //          // TTF/OTF data
	FontDataSize : i32, //          // TTF/OTF data size
	FontDataOwnedByAtlas : bool, // true     // TTF/OTF data ownership taken by the container ImFontAtlas (will delete memory itself).
	FontNo : i32, // 0        // Index of font within TTF/OTF file
	SizePixels : f32, //          // Size in pixels for rasterizer (more or less maps to the resulting font height).
	OversampleH : i32, // 2        // Rasterize at higher quality for sub-pixel positioning. Note the difference between 2 and 3 is minimal. You can reduce this to 1 for large glyphs save memory. Read https://github.com/nothings/stb/blob/master/tests/oversample/README.md for details.
	OversampleV : i32, // 1        // Rasterize at higher quality for sub-pixel positioning. This is not really useful as we don't use sub-pixel positions on the Y axis.
	PixelSnapH : bool, // false    // Align every glyph AdvanceX to pixel boundaries. Useful e.g. if you are merging a non-pixel aligned font with the default font. If enabled, you can set OversampleH/V to 1.
	GlyphExtraSpacing : ImVec2, // 0, 0     // Extra spacing (in pixels) between glyphs when rendered: essentially add to glyph->AdvanceX. Only X axis is supported for now.
	GlyphOffset : ImVec2, // 0, 0     // Offset all glyphs from this font input.
	GlyphRanges : ^ImWchar, // NULL     // THE ARRAY DATA NEEDS TO PERSIST AS LONG AS THE FONT IS ALIVE. Pointer to a user-provided list of Unicode range (2 value per range, values are inclusive, zero-terminated list).
	GlyphMinAdvanceX : f32, // 0        // Minimum AdvanceX for glyphs, set Min to align font icons, set both Min/Max to enforce mono-space font
	GlyphMaxAdvanceX : f32, // FLT_MAX  // Maximum AdvanceX for glyphs
	MergeMode : bool, // false    // Merge into previous ImFont, so you can combine multiple inputs font into one ImFont (e.g. ASCII font + icons + Japanese glyphs). You may want to use GlyphOffset.y when merge font of different heights.
	FontBuilderFlags : u32, // 0        // Settings for custom font builder. THIS IS BUILDER IMPLEMENTATION DEPENDENT. Leave as zero if unsure.
	RasterizerMultiply : f32, // 1.0f     // Linearly brighten (>1.0f) or darken (<1.0f) font output. Brightening small fonts may be a good workaround to make them more readable. This is a silly thing we may remove in the future.
	RasterizerDensity : f32, // 1.0f     // DPI scale for rasterization, not altering other font metrics: make it easy to swap between e.g. a 100% and a 400% fonts for a zooming display. IMPORTANT: If you increase this it is expected that you increase font scale accordingly, otherwise quality may look lowered.
	EllipsisChar : ImWchar, // 0        // Explicitly specify unicode codepoint of ellipsis character. When fonts are being merged first specified ellipsis will be used.

	// [Internal]
	Name : [40]u8, // Name (strictly to ease debugging)
	DstFont : ^ImFont,
}

// A single font glyph (code point + coordinates within in ImFontAtlas + offset)
// Hold rendering data for one glyph.
// (Note: some language parsers may fail to convert the 31+1 bitfield members, in this case maybe drop store a single u32 or we can rework this)
ImFontGlyph :: struct {
	using _0 : bit_field u32 {
		Colored : u32 | 1, // Flag to indicate glyph is colored and should generally ignore tinting (make it usable with no shift on little-endian as this is used in loops)
		Visible : u32 | 1, // Flag to indicate glyph has no visible pixels (e.g. space). Allow early out when rendering.
		Codepoint : u32 | 30, // 0x0000..0x10FFFF
	},
	AdvanceX : f32, // Distance to next character (= data from font + ImFontConfig::GlyphExtraSpacing.x baked in)
	X0 : f32, Y0 : f32, X1 : f32, Y1 : f32, // Glyph corners
	U0 : f32, V0 : f32, U1 : f32, V1 : f32, // Texture coordinates
}

// Helper to build glyph ranges from text/string data
// Helper to build glyph ranges from text/string data. Feed your application strings/characters to it then call BuildRanges().
// This is essentially a tightly packed of vector of 64k booleans = 8KB storage.
ImFontGlyphRangesBuilder :: struct {
	UsedChars : ImVector(ImU32), // Store 1-bit per Unicode code point (0=unused, 1=used)
}

ImFontGlyphRangesBuilder_deinit :: proc(this : ^ImFontGlyphRangesBuilder) { deinit(&this.UsedChars) }

ImFontGlyphRangesBuilder_init :: proc(this : ^ImFontGlyphRangesBuilder)
{
	init(&this.UsedChars)
	Clear(this)
}

ImFontGlyphRangesBuilder_Clear :: #force_inline proc(this : ^ImFontGlyphRangesBuilder)
{
	size_in_bytes := (IM_UNICODE_CODEPOINT_MAX + 1) / 8
	resize(&this.UsedChars, cast(i32) size_in_bytes / cast(i32) size_of(ImU32))
	mem.set(this.UsedChars.Data, 0, size_in_bytes)
}

// Get bit n in the array
ImFontGlyphRangesBuilder_GetBit :: #force_inline proc(this : ^ImFontGlyphRangesBuilder, n : uint) -> bool
{
	off : i32 = cast(i32) (n >> 5); mask : ImU32 = 1 << (n & 31); return (this.UsedChars.Data[off] & mask) != 0
}

// Set bit n in the array
ImFontGlyphRangesBuilder_SetBit :: #force_inline proc(this : ^ImFontGlyphRangesBuilder, #any_int n : uint)
{
	off : i32 = cast(i32) (n >> 5); mask : ImU32 = 1 << (n & 31); this.UsedChars.Data[off] |= mask
}

// Add character
ImFontGlyphRangesBuilder_AddChar :: #force_inline proc(this : ^ImFontGlyphRangesBuilder, c : ImWchar) { ImFontGlyphRangesBuilder_SetBit(this, c) }

// See ImFontAtlas::AddCustomRectXXX functions.
ImFontAtlasCustomRect :: struct {
	X : u16, Y : u16, // Output   // Packed position in Atlas

	// [Internal]
	Width : u16, Height : u16, // Input    // Desired rectangle dimension
	using _0 : bit_field u32 {
		GlyphID : u32 | 31, // Input    // For custom font glyphs only (ID < 0x110000)
		GlyphColored : u32 | 1, // Input  // For custom font glyphs only: glyph is colored, removed tinting.
	},
	GlyphAdvanceX : f32, // Input    // For custom font glyphs only: glyph xadvance
	GlyphOffset : ImVec2, // Input    // For custom font glyphs only: glyph display offset
	Font : ^ImFont, // Input    // For custom font glyphs only: target font
}

ImFontAtlasCustomRect_init :: proc(this : ^ImFontAtlasCustomRect)
{
	this.Y = 0xFFFF; this.X = this.Y; this.Height = 0; this.Width = this.Height; this.GlyphID = 0; this.GlyphColored = 0; this.GlyphAdvanceX = 0.0; this.GlyphOffset = ImVec2{0, 0}; this.Font = nil
}

ImFontAtlasCustomRect_IsPacked :: proc(this : ImFontAtlasCustomRect) -> bool { return this.X != 0xFFFF }

// Flags for ImFontAtlas build
ImFontAtlasFlags_ :: enum i32 {
	ImFontAtlasFlags_None = 0,
	ImFontAtlasFlags_NoPowerOfTwoHeight = 1 << 0, // Don't round the height to next power of two
	ImFontAtlasFlags_NoMouseCursors = 1 << 1, // Don't build software mouse cursors into the atlas (save a little texture memory)
	ImFontAtlasFlags_NoBakedLines = 1 << 2, // Don't build thick line textures into the atlas (save a little texture memory, allow support for point/nearest filtering). The AntiAliasedLinesUseTex features uses them, otherwise they will be rendered using polygons (more expensive for CPU/GPU).
}

// Runtime data for multiple fonts, bake multiple fonts into a single texture, TTF/OTF font loader
// Load and rasterize multiple TTF/OTF fonts into a same texture. The font atlas will build a single texture holding:
//  - One or more fonts.
//  - Custom graphics data needed to render the shapes needed by Dear ImGui.
//  - Mouse cursor shapes for software cursor rendering (unless setting 'Flags |= ImFontAtlasFlags_NoMouseCursors' in the font atlas).
// It is the user-code responsibility to setup/build the atlas, then upload the pixel data into a texture accessible by your graphics api.
//  - Optionally, call any of the AddFont*** functions. If you don't call any, the default font embedded in the code will be loaded for you.
//  - Call GetTexDataAsAlpha8() or GetTexDataAsRGBA32() to build and retrieve pixels data.
//  - Upload the pixels data into a texture within your graphics system (see imgui_impl_xxxx.cpp examples)
//  - Call SetTexID(my_tex_id); and pass the pointer/identifier to your texture in a format natural to your graphics API.
//    This value will be passed back to you during rendering to identify the texture. Read FAQ entry about ImTextureID for more details.
// Common pitfalls:
// - If you pass a 'glyph_ranges' array to AddFont*** functions, you need to make sure that your array persist up until the
//   atlas is build (when calling GetTexData*** or Build()). We only copy the pointer, not the data.
// - Important: By default, AddFontFromMemoryTTF() takes ownership of the data. Even though we are not writing to it, we will free the pointer on destruction.
//   You can set font_cfg->FontDataOwnedByAtlas=false to keep ownership of your data and it won't be freed,
// - Even though many functions are suffixed with "TTF", OTF data is supported just as well.
// - This is an old API and it is currently awkward for those and various other reasons! We will address them in the future!
ImFontAtlas :: struct {
	//-------------------------------------------
	// Members
	//-------------------------------------------

	Flags : ImFontAtlasFlags, // Build flags (see ImFontAtlasFlags_)
	TexID : ImTextureID, // User data to refer to the texture once it has been uploaded to user's graphic systems. It is passed back to you during rendering via the ImDrawCmd structure.
	TexDesiredWidth : i32, // Texture width desired by user before Build(). Must be a power-of-two. If have many glyphs your graphics API have texture size restrictions you may want to increase texture width to decrease height.
	TexGlyphPadding : i32, // FIXME: Should be called "TexPackPadding". Padding between glyphs within texture in pixels. Defaults to 1. If your rendering method doesn't rely on bilinear filtering you may set this to 0 (will also need to set AntiAliasedLinesUseTex = false).
	Locked : bool, // Marked as Locked by ImGui::NewFrame() so attempt to modify the atlas will assert.
	UserData : rawptr, // Store your own atlas related user-data (if e.g. you have multiple font atlas).

	// [Internal]
	// NB: Access texture data via GetTexData*() calls! Which will setup a default font for you.
	TexReady : bool, // Set when texture was built matching current font input
	TexPixelsUseColors : bool, // Tell whether our texture data is known to use colors (rather than just alpha channel), in order to help backend select a format.
	TexPixelsAlpha8 : [^]u8, // 1 component per pixel, each component is unsigned 8-bit. Total size = TexWidth * TexHeight
	TexPixelsRGBA32 : [^]u32, // 4 component per pixel, each component is unsigned 8-bit. Total size = TexWidth * TexHeight * 4
	TexWidth : i32, // Texture width calculated during Build().
	TexHeight : i32, // Texture height calculated during Build().
	TexUvScale : ImVec2, // = (1.0f/TexWidth, 1.0f/TexHeight)
	TexUvWhitePixel : ImVec2, // Texture coordinates to a white pixel
	Fonts : ImVector(^ImFont), // Hold all the fonts returned by AddFont*. Fonts.Data[0] is the default font upon calling ImGui::NewFrame(), use ImGui::PushFont()/PopFont() to change the current font.
	CustomRects : ImVector(ImFontAtlasCustomRect), // Rectangles for packing custom texture data into the atlas.
	ConfigData : ImVector(ImFontConfig), // Configuration data
	TexUvLines : [IM_DRAWLIST_TEX_LINES_WIDTH_MAX + 1]ImVec4, // UVs for baked anti-aliased lines

	// [Internal] Font builder
	FontBuilderIO : ^ImFontBuilderIO, // Opaque interface to a font builder (default to stb_truetype, can be changed to use FreeType by defining IMGUI_ENABLE_FREETYPE).
	FontBuilderFlags : u32, // Shared flags (for all fonts) for custom font builder. THIS IS BUILD IMPLEMENTATION DEPENDENT. Per-font override is also available in ImFontConfig.

	// [Internal] Packing data
	PackIdMouseCursors : i32, // Custom texture rectangle ID for white pixel and mouse cursors
	PackIdLines : i32, // Custom texture rectangle ID for baked anti-aliased lines

	// [Obsolete]
	//typedef ImFontAtlasCustomRect    CustomRect;         // OBSOLETED in 1.72+
	//typedef ImFontGlyphRangesBuilder GlyphRangesBuilder; // OBSOLETED in 1.67+
}

// Bit ambiguous: used to detect when user didn't build texture but effectively we should check TexID != 0 except that would be backend dependent...
ImFontAtlas_IsBuilt :: proc(this : ^ImFontAtlas) -> bool { return this.Fonts.Size > 0 && this.TexReady }

ImFontAtlas_SetTexID :: proc(this : ^ImFontAtlas, id : ImTextureID) { this.TexID = id }

ImFontAtlas_GetCustomRectByIndex :: proc(this : ^ImFontAtlas, index : i32) -> ^ImFontAtlasCustomRect
{
	IM_ASSERT(index >= 0); return &this.CustomRects.Data[index]
}

// Runtime data for a single font within a parent ImFontAtlas
// Font runtime data and rendering
// ImFontAtlas automatically loads a default embedded font for you when you call GetTexDataAsAlpha8() or GetTexDataAsRGBA32().
ImFont :: struct {
	// [Internal] Members: Hot ~20/24 bytes (for CalcTextSize)
	IndexAdvanceX : ImVector(f32), // 12-16 // out //            // Sparse. Glyphs->AdvanceX in a directly indexable way (cache-friendly for CalcTextSize functions which only this info, and are often bottleneck in large UI).
	FallbackAdvanceX : f32, // 4     // out // = FallbackGlyph->AdvanceX
	FontSize : f32, // 4     // in  //            // Height of characters/line, set during loading (don't change after loading)

	// [Internal] Members: Hot ~28/40 bytes (for RenderText loop)
	IndexLookup : ImVector(ImWchar), // 12-16 // out //            // Sparse. Index glyphs by Unicode code-point.
	Glyphs : ImVector(ImFontGlyph), // 12-16 // out //            // All glyphs.
	FallbackGlyph : ^ImFontGlyph, // 4-8   // out // = FindGlyph(FontFallbackChar)

	// [Internal] Members: Cold ~32/40 bytes
	// Conceptually ConfigData[] is the list of font sources merged to create this font.
	ContainerAtlas : ^ImFontAtlas, // 4-8   // out //            // What we has been loaded into
	ConfigData : [^]ImFontConfig, // 4-8   // in  //            // Pointer within ContainerAtlas->ConfigData to ConfigDataCount instances
	ConfigDataCount : i16, // 2     // in  // ~ 1        // Number of ImFontConfig involved in creating this font. Bigger than 1 when merging multiple font sources into one ImFont.
	EllipsisCharCount : i16, // 1     // out // 1 or 3
	EllipsisChar : ImWchar, // 2-4   // out // = '...'/'.'// Character used for ellipsis rendering.
	FallbackChar : ImWchar, // 2-4   // out // = FFFD/'?' // Character used if a glyph isn't found.
	EllipsisWidth : f32, // 4     // out               // Width
	EllipsisCharStep : f32, // 4     // out               // Step between characters when EllipsisCount > 0
	DirtyLookupTables : bool, // 1     // out //
	Scale : f32, // 4     // in  // = 1.f      // Base font scale, multiplied by the per-window font scale which you can adjust with SetWindowFontScale()
	Ascent : f32, Descent : f32, // 4+4   // out //            // Ascent: distance from top to bottom of e.g. 'A' [0..FontSize] (unscaled)
	MetricsTotalSurface : i32, // 4     // out //            // Total surface in pixels to get an idea of the font rasterization/texture cost (not exact, we approximate the cost of padding between glyphs)
	Used4kPagesMap : [(IM_UNICODE_CODEPOINT_MAX + 1) / 4096 / 8]ImU8, // 2 bytes if ImWchar=ImWchar16, 34 bytes if ImWchar==ImWchar32. Store 1-bit for each block of 4K codepoints that has one active glyph. This is mainly used to facilitate iterations across all used codepoints.
}

ImFont_GetCharAdvance :: proc(this : ^ImFont, c : ImWchar) -> f32 {
	return (cast(i32) c < this.IndexAdvanceX.Size) ? this.IndexAdvanceX.Data[cast(i32) c] : this.FallbackAdvanceX
}

ImFont_IsLoaded :: proc(this : ^ImFont) -> bool { return this.ContainerAtlas != nil }

ImFont_GetDebugName :: proc(this : ^ImFont) -> [^]u8 {
	uk := "unknown"
	return this.ConfigData != nil ? raw_data(&this.ConfigData[0].Name) : raw_data(uk)
}

//-----------------------------------------------------------------------------
// [SECTION] Viewports
//-----------------------------------------------------------------------------

// Flags stored in ImGuiViewport::Flags, giving indications to the platform backends.
ImGuiViewportFlags_ :: enum i32 {
	ImGuiViewportFlags_None = 0,
	ImGuiViewportFlags_IsPlatformWindow = 1 << 0, // Represent a Platform Window
	ImGuiViewportFlags_IsPlatformMonitor = 1 << 1, // Represent a Platform Monitor (unused yet)
	ImGuiViewportFlags_OwnedByApp = 1 << 2, // Platform Window: Is created/managed by the user application? (rather than our backend)
	ImGuiViewportFlags_NoDecoration = 1 << 3, // Platform Window: Disable platform decorations: title bar, borders, etc. (generally set all windows, but if ImGuiConfigFlags_ViewportsDecoration is set we only set this on popups/tooltips)
	ImGuiViewportFlags_NoTaskBarIcon = 1 << 4, // Platform Window: Disable platform task bar icon (generally set on popups/tooltips, or all windows if ImGuiConfigFlags_ViewportsNoTaskBarIcon is set)
	ImGuiViewportFlags_NoFocusOnAppearing = 1 << 5, // Platform Window: Don't take focus when created.
	ImGuiViewportFlags_NoFocusOnClick = 1 << 6, // Platform Window: Don't take focus when clicked on.
	ImGuiViewportFlags_NoInputs = 1 << 7, // Platform Window: Make mouse pass through so we can drag this window while peaking behind it.
	ImGuiViewportFlags_NoRendererClear = 1 << 8, // Platform Window: Renderer doesn't need to clear the framebuffer ahead (because we will fill it entirely).
	ImGuiViewportFlags_NoAutoMerge = 1 << 9, // Platform Window: Avoid merging this window into another host window. This can only be set via ImGuiWindowClass viewport flags override (because we need to now ahead if we are going to create a viewport in the first place!).
	ImGuiViewportFlags_TopMost = 1 << 10, // Platform Window: Display on top (for tooltips only).
	ImGuiViewportFlags_CanHostOtherWindows = 1 << 11, // Viewport can host multiple imgui windows (secondary viewports are associated to a single window). // FIXME: In practice there's still probably code making the assumption that this is always and only on the MainViewport. Will fix once we add support for "no main viewport".

	// Output status flags (from Platform)
	ImGuiViewportFlags_IsMinimized = 1 << 12, // Platform Window: Window is minimized, can skip render. When minimized we tend to avoid using the viewport pos/size for clipping window or testing if they are contained in the viewport.
	ImGuiViewportFlags_IsFocused = 1 << 13, // Platform Window: Window is focused (last call to Platform_GetWindowFocus() returned true)
}

// A Platform Window (always 1 unless multi-viewport are enabled. One per platform window to output to). In the future may represent Platform Monitor
// - Currently represents the Platform Window created by the application which is hosting our Dear ImGui windows.
// - With multi-viewport enabled, we extend this concept to have multiple active viewports.
// - In the future we will extend this concept further to also represent Platform Monitor and support a "no main platform window" operation mode.
// - About Main Area vs Work Area:
//   - Main Area = entire viewport.
//   - Work Area = entire viewport minus sections used by main menu bars (for platform windows), or by task bar (for platform monitor).
//   - Windows are generally trying to stay within the Work Area of their host viewport.
ImGuiViewport :: struct {
	ID : ImGuiID, // Unique identifier for the viewport
	Flags : ImGuiViewportFlags, // See ImGuiViewportFlags_
	Pos : ImVec2, // Main Area: Position of the viewport (Dear ImGui coordinates are the same as OS desktop/native coordinates)
	Size : ImVec2, // Main Area: Size of the viewport.
	WorkPos : ImVec2, // Work Area: Position of the viewport minus task bars, menus bars, status bars (>= Pos)
	WorkSize : ImVec2, // Work Area: Size of the viewport minus task bars, menu bars, status bars (<= Size)
	DpiScale : f32, // 1.0f = 96 DPI = No extra scale.
	ParentViewportId : ImGuiID, // (Advanced) 0: no parent. Instruct the platform backend to setup a parent/child relationship between platform windows.
	DrawData : ^ImDrawData, // The ImDrawData corresponding to this viewport. Valid after Render() and until the next call to NewFrame().

	// Platform/Backend Dependent Data
	// Our design separate the Renderer and Platform backends to facilitate combining default backends with each others.
	// When our create your own backend for a custom engine, it is possible that both Renderer and Platform will be handled
	// by the same system and you may not need to use all the UserData/Handle fields.
	// The library never uses those fields, they are merely storage to facilitate backend implementation.
	RendererUserData : rawptr, // void* to hold custom data structure for the renderer (e.g. swap chain, framebuffers etc.). generally set by your Renderer_CreateWindow function.
	PlatformUserData : rawptr, // void* to hold custom data structure for the OS / platform (e.g. windowing info, render context). generally set by your Platform_CreateWindow function.
	PlatformHandle : rawptr, // void* to hold higher-level, platform window handle (e.g. HWND, GLFWWindow*, SDL_Window*), for FindViewportByPlatformHandle().
	PlatformHandleRaw : rawptr, // void* to hold lower-level, platform-native window handle (under Win32 this is expected to be a HWND, unused for other platforms), when using an abstraction layer like GLFW or SDL (where PlatformHandle would be a SDL_Window*)
	PlatformWindowCreated : bool, // Platform window has been created (Platform_CreateWindow() has been called). This is false during the first frame where a viewport is being created.
	PlatformRequestMove : bool, // Platform window requested move (e.g. window was moved by the OS / host window manager, authoritative position will be OS window position)
	PlatformRequestResize : bool, // Platform window requested resize (e.g. window was resized by the OS / host window manager, authoritative size will be OS window size)
	PlatformRequestClose : bool, // Platform window requested closure (e.g. window was moved by the OS / host window manager, e.g. pressing ALT-F4)
}

ImGuiViewport_deinit :: proc(this : ^ImGuiViewport)
{IM_ASSERT(this.PlatformUserData == nil && this.RendererUserData == nil)}

ImGuiViewport_init :: proc(this : ^ImGuiViewport) { this^ = {} }

// Helpers
ImGuiViewport_GetCenter :: proc(this : ^ImGuiViewport) -> ImVec2 { return ImVec2{this.Pos.x + this.Size.x * 0.5, this.Pos.y + this.Size.y * 0.5} }

ImGuiViewport_GetWorkCenter :: proc(this : ^ImGuiViewport) -> ImVec2 { return ImVec2{this.WorkPos.x + this.WorkSize.x * 0.5, this.WorkPos.y + this.WorkSize.y * 0.5} }

// Interface between platform/renderer backends and ImGui (e.g. Clipboard, IME, Multi-Viewport support). Extends ImGuiIO.
//-----------------------------------------------------------------------------
// [SECTION] ImGuiPlatformIO + other Platform Dependent Interfaces (ImGuiPlatformMonitor, ImGuiPlatformImeData)
//-----------------------------------------------------------------------------

// [BETA] (Optional) Multi-Viewport Support!
// If you are new to Dear ImGui and trying to integrate it into your engine, you can probably ignore this for now.
//
// This feature allows you to seamlessly drag Dear ImGui windows outside of your application viewport.
// This is achieved by creating new Platform/OS windows on the fly, and rendering into them.
// Dear ImGui manages the viewport structures, and the backend create and maintain one Platform/OS window for each of those viewports.
//
// See Recap:   https://github.com/ocornut/imgui/wiki/Multi-Viewports
// See Glossary https://github.com/ocornut/imgui/wiki/Glossary for details about some of the terminology.
//
// About the coordinates system:
// - When multi-viewports are enabled, all Dear ImGui coordinates become absolute coordinates (same as OS coordinates!)
// - So e.g. ImGui::SetNextWindowPos(ImVec2{0,0}) will position a window relative to your primary monitor!
// - If you want to position windows relative to your main application viewport, use ImGui::GetMainViewport()->Pos as a base position.
//
// Steps to use multi-viewports in your application, when using a default backend from the examples/ folder:
// - Application:  Enable feature with 'io.ConfigFlags |= ImGuiConfigFlags_ViewportsEnable'.
// - Backend:      The backend initialization will setup all necessary ImGuiPlatformIO's functions and update monitors info every frame.
// - Application:  In your main loop, call ImGui::UpdatePlatformWindows(), ImGui::RenderPlatformWindowsDefault() after EndFrame() or Render().
// - Application:  Fix absolute coordinates used in ImGui::SetWindowPos() or ImGui::SetNextWindowPos() calls.
//
// Steps to use multi-viewports in your application, when using a custom backend:
// - Important:    THIS IS NOT EASY TO DO and comes with many subtleties not described here!
//                 It's also an experimental feature, so some of the requirements may evolve.
//                 Consider using default backends if you can. Either way, carefully follow and refer to examples/ backends for details.
// - Application:  Enable feature with 'io.ConfigFlags |= ImGuiConfigFlags_ViewportsEnable'.
// - Backend:      Hook ImGuiPlatformIO's Platform_* and Renderer_* callbacks (see below).
//                 Set 'io.BackendFlags |= ImGuiBackendFlags_PlatformHasViewports' and 'io.BackendFlags |= ImGuiBackendFlags_PlatformHasViewports'.
//                 Update ImGuiPlatformIO's Monitors list every frame.
//                 Update MousePos every frame, in absolute coordinates.
// - Application:  In your main loop, call ImGui::UpdatePlatformWindows(), ImGui::RenderPlatformWindowsDefault() after EndFrame() or Render().
//                 You may skip calling RenderPlatformWindowsDefault() if its API is not convenient for your needs. Read comments below.
// - Application:  Fix absolute coordinates used in ImGui::SetWindowPos() or ImGui::SetNextWindowPos() calls.
//
// About ImGui::RenderPlatformWindowsDefault():
// - This function is a mostly a _helper_ for the common-most cases, and to facilitate using default backends.
// - You can check its simple source code to understand what it does.
//   It basically iterates secondary viewports and call 4 functions that are setup in ImGuiPlatformIO, if available:
//     Platform_RenderWindow(), Renderer_RenderWindow(), Platform_SwapBuffers(), Renderer_SwapBuffers()
//   Those functions pointers exists only for the benefit of RenderPlatformWindowsDefault().
// - If you have very specific rendering needs (e.g. flipping multiple swap-chain simultaneously, unusual sync/threading issues, etc.),
//   you may be tempted to ignore RenderPlatformWindowsDefault() and write customized code to perform your renderingg.
//   You may decide to setup the platform_io's *RenderWindow and *SwapBuffers pointers and call your functions through those pointers,
//   or you may decide to never setup those pointers and call your code directly. They are a convenience, not an obligatory interface.
//-----------------------------------------------------------------------------

// Access via ImGui::GetPlatformIO()
ImGuiPlatformIO :: struct {
	//------------------------------------------------------------------
	// Interface with OS and Platform backend (basic)
	//------------------------------------------------------------------

	// Optional: Access OS clipboard
	// (default to use native Win32 clipboard on Windows, otherwise uses a private clipboard. Override to access OS clipboard on other architectures)
	Platform_GetClipboardTextFn : proc(_ctx : ^ImGuiContext) -> string,
	Platform_SetClipboardTextFn : proc(_ctx : ^ImGuiContext, _text : string),
	Platform_ClipboardUserData : rawptr,

	// Optional: Open link/folder/file in OS Shell
	// (default to use ShellExecuteA() on Windows, system() on Linux/Mac)
	Platform_OpenInShellFn : proc(_ctx : ^ImGuiContext, _path : string) -> bool,
	Platform_OpenInShellUserData : rawptr,

	// Optional: Notify OS Input Method Editor of the screen position of your cursor for text input position (e.g. when using Japanese/Chinese IME on Windows)
	// (default to use native imm32 api on Windows)
	Platform_SetImeDataFn : proc(_ctx : ^ImGuiContext, _viewport : ^ImGuiViewport, _data : ^ImGuiPlatformImeData),
	Platform_ImeUserData : rawptr,
	//void      (*SetPlatformImeDataFn)(ImGuiViewport* viewport, ImGuiPlatformImeData* data); // [Renamed to platform_io.PlatformSetImeDataFn in 1.91.1]

	// Optional: Platform locale
	// [Experimental] Configure decimal point e.g. '.' or ',' useful for some languages (e.g. German), generally pulled from *localeconv()->decimal_point
	Platform_LocaleDecimalPoint : ImWchar, // '.'

	//------------------------------------------------------------------
	// Interface with Renderer Backend
	//------------------------------------------------------------------

	// Written by some backends during ImGui_ImplXXXX_RenderDrawData() call to point backend_specific ImGui_ImplXXXX_RenderState* structure.
	Renderer_RenderState : rawptr,

	//------------------------------------------------------------------
	// Input - Interface with OS/backends (Multi-Viewport support!)
	//------------------------------------------------------------------

	// For reference, the second column shows which function are generally calling the Platform Functions:
	//   N = ImGui::NewFrame()                        ~ beginning of the dear imgui frame: read info from platform/OS windows (latest size/position)
	//   F = ImGui::Begin(), ImGui::EndFrame()        ~ during the dear imgui frame
	//   U = ImGui::UpdatePlatformWindows()           ~ after the dear imgui frame: create and update all platform/OS windows
	//   R = ImGui::RenderPlatformWindowsDefault()    ~ render
	//   D = ImGui::DestroyPlatformWindows()          ~ shutdown
	// The general idea is that NewFrame() we will read the current Platform/OS state, and UpdatePlatformWindows() will write to it.

	// The handlers are designed so we can mix and match two imgui_impl_xxxx files, one Platform backend and one Renderer backend.
	// Custom engine backends will often provide both Platform and Renderer interfaces together and so may not need to use all functions.
	// Platform functions are typically called _before_ their Renderer counterpart, apart from Destroy which are called the other way.

	// Platform Backend functions (e.g. Win32, GLFW, SDL) ------------------- Called by -----
	Platform_CreateWindow : proc(	_vp : ^ImGuiViewport), // . . U . .  // Create a new platform window for the given viewport
	Platform_DestroyWindow : proc(	_vp : ^ImGuiViewport), // N . U . D  //
	Platform_ShowWindow : proc(	_vp : ^ImGuiViewport), // . . U . .  // Newly created windows are initially hidden so SetWindowPos/Size/Title can be called on them before showing the window
	Platform_SetWindowPos : proc(	_vp : ^ImGuiViewport, 	_pos : ImVec2), // . . U . .  // Set platform window position (given the upper-left corner of client area)
	Platform_GetWindowPos : proc(	_vp : ^ImGuiViewport) -> ImVec2, // N . . . .  //
	Platform_SetWindowSize : proc(	_vp : ^ImGuiViewport, 	_size : ImVec2), // . . U . .  // Set platform window client area size (ignoring OS decorations such as OS title bar etc.)
	Platform_GetWindowSize : proc(	_vp : ^ImGuiViewport) -> ImVec2, // N . . . .  // Get platform window client area size
	Platform_SetWindowFocus : proc(	_vp : ^ImGuiViewport), // N . . . .  // Move window to front and set input focus
	Platform_GetWindowFocus : proc(	_vp : ^ImGuiViewport) -> bool, // . . U . .  //
	Platform_GetWindowMinimized : proc(	_vp : ^ImGuiViewport) -> bool, // N . . . .  // Get platform window minimized state. When minimized, we generally won't attempt to get/set size and contents will be culled more easily
	Platform_SetWindowTitle : proc(	_vp : ^ImGuiViewport, 	_str : string), // . . U . .  // Set platform window title (given an UTF-8 string) // strign has a null byte after when called
	Platform_SetWindowAlpha : proc(	_vp : ^ImGuiViewport, 	_alpha : f32), // . . U . .  // (Optional) Setup global transparency (not per-pixel transparency)
	Platform_UpdateWindow : proc(	_vp : ^ImGuiViewport), // . . U . .  // (Optional) Called by UpdatePlatformWindows(). Optional hook to allow the platform backend from doing general book-keeping every frame.
	Platform_RenderWindow : proc(	_vp : ^ImGuiViewport, 	_render_arg : rawptr), // . . . R .  // (Optional) Main rendering (platform side! This is often unused, or just setting a "current" context for OpenGL bindings). 'render_arg' is the value passed to RenderPlatformWindowsDefault().
	Platform_SwapBuffers : proc(	_vp : ^ImGuiViewport, 	_render_arg : rawptr), // . . . R .  // (Optional) Call Present/SwapBuffers (platform side! This is often unused!). 'render_arg' is the value passed to RenderPlatformWindowsDefault().
	Platform_GetWindowDpiScale : proc(	_vp : ^ImGuiViewport) -> f32, // N . . . .  // (Optional) [BETA] FIXME-DPI: DPI handling: Return DPI scale for this viewport. 1.0f = 96 DPI.
	Platform_OnChangedViewport : proc(	_vp : ^ImGuiViewport), // . F . . .  // (Optional) [BETA] FIXME-DPI: DPI handling: Called during Begin() every time the viewport we are outputting into changes, so backend has a chance to swap fonts to adjust style.
	Platform_GetWindowWorkAreaInsets : proc(	_vp : ^ImGuiViewport) -> ImVec4, // N . . . .  // (Optional) [BETA] Get initial work area inset for the viewport (won't be covered by main menu bar, dockspace over viewport etc.). Default to (0,0),(0,0). 'safeAreaInsets' in iOS land, 'DisplayCutout' in Android land.
	Platform_CreateVkSurface : proc(	_vp : ^ImGuiViewport, 	_vk_inst : ImU64, 	_vk_allocators : rawptr, 	_out_vk_surface : ^ImU64) -> i32, // (Optional) For a Vulkan Renderer to call into Platform code (since the surface creation needs to tie them both).

	// Renderer Backend functions (e.g. DirectX, OpenGL, Vulkan) ------------ Called by -----
	Renderer_CreateWindow : proc(	_vp : ^ImGuiViewport), // . . U . .  // Create swap chain, frame buffers etc. (called after Platform_CreateWindow)
	Renderer_DestroyWindow : proc(	_vp : ^ImGuiViewport), // N . U . D  // Destroy swap chain, frame buffers etc. (called before Platform_DestroyWindow)
	Renderer_SetWindowSize : proc(	_vp : ^ImGuiViewport, 	_size : ImVec2), // . . U . .  // Resize swap chain, frame buffers etc. (called after Platform_SetWindowSize)
	Renderer_RenderWindow : proc(	_vp : ^ImGuiViewport, 	_render_arg : rawptr), // . . . R .  // (Optional) Clear framebuffer, setup render target, then render the viewport->DrawData. 'render_arg' is the value passed to RenderPlatformWindowsDefault().
	Renderer_SwapBuffers : proc(	_vp : ^ImGuiViewport, 	_render_arg : rawptr), // . . . R .  // (Optional) Call Present/SwapBuffers. 'render_arg' is the value passed to RenderPlatformWindowsDefault().

	// (Optional) Monitor list
	// - Updated by: app/backend. Update every frame to dynamically support changing monitor or DPI configuration.
	// - Used by: dear imgui to query DPI info, clamp popups/tooltips within same monitor and not have them straddle monitors.
	Monitors : ImVector(ImGuiPlatformMonitor),

	//------------------------------------------------------------------
	// Output - List of viewports to render into platform windows
	//------------------------------------------------------------------

	// Viewports list (the list is updated by calling ImGui::EndFrame or ImGui::Render)
	// (in the future we will attempt to organize this feature to remove the need for a "main viewport")
	Viewports : ImVector(^ImGuiViewport), // Main viewports, followed by all secondary viewports.
}

ImGuiPlatformIO_deinit :: proc(this : ^ImGuiPlatformIO)
{
	deinit(&this.Monitors)
	deinit(&this.Viewports)
}

// Multi-viewport support: user-provided bounds for each connected monitor/display. Used when positioning popups and tooltips to avoid them straddling monitors
// (Optional) This is required when enabling multi-viewport. Represent the bounds of each connected monitor/display and their DPI.
// We use this information for multiple DPI support + clamping the position of popups and tooltips so they don't straddle multiple monitors.
ImGuiPlatformMonitor :: struct {
	MainPos : ImVec2, MainSize : ImVec2, // Coordinates of the area displayed on this monitor (Min = upper left, Max = bottom right)
	WorkPos : ImVec2, WorkSize : ImVec2, // Coordinates without task bars / side bars / menu bars. Used to avoid positioning popups/tooltips inside this region. If you don't have this info, please copy the value for MainPos/MainSize.
	DpiScale : f32, // 1.0f = 96 DPI
	PlatformHandle : rawptr, // Backend dependant data (e.g. HMONITOR, GLFWmonitor*, SDL Display Index, NSScreen*)
}

ImGuiPlatformMonitor_init :: proc(this : ^ImGuiPlatformMonitor)
{
	this.WorkSize = ImVec2{0, 0}; this.WorkPos = this.WorkSize; this.MainSize = this.WorkPos; this.MainPos = this.MainSize; this.DpiScale = 1.0; this.PlatformHandle = nil
}

// Platform IME data for io.PlatformSetImeDataFn() function.
// (Optional) Support for IME (Input Method Editor) via the platform_io.Platform_SetImeDataFn() function.
ImGuiPlatformImeData :: struct {
	WantVisible : bool, // A widget wants the IME to be visible
	InputPos : ImVec2, // Position of the input cursor
	InputLineHeight : f32, // Line height
}

ImGuiPlatformImeData_init :: proc(this : ^ImGuiPlatformImeData) { this^ = {} }



//-----------------------------------------------------------------------------

// dear imgui, v1.91.7 WIP
// (internal structures/api)

// You may use this file to debug, understand or extend Dear ImGui features but we don't provide any guarantee of forward compatibility.

/*

Index of this file:

// [SECTION] Header mess
// [SECTION] Forward declarations
// [SECTION] Context pointer
// [SECTION] STB libraries includes
// [SECTION] Macros
// [SECTION] Generic helpers
// [SECTION] ImDrawList support
// [SECTION] Data types support
// [SECTION] Widgets support: flags, enums, data structures
// [SECTION] Popup support
// [SECTION] Inputs support
// [SECTION] Clipper support
// [SECTION] Navigation support
// [SECTION] Typing-select support
// [SECTION] Columns support
// [SECTION] Box-select support
// [SECTION] Multi-select support
// [SECTION] Docking support
// [SECTION] Viewport support
// [SECTION] Settings support
// [SECTION] Localization support
// [SECTION] Error handling, State recovery support
// [SECTION] Metrics, Debug tools
// [SECTION] Generic context hooks
// [SECTION] ImGuiContext (main imgui context)
// [SECTION] ImGuiWindowTempData, ImGuiWindow
// [SECTION] Tab bar, Tab item support
// [SECTION] Table support
// [SECTION] ImGui internal API
// [SECTION] ImFontAtlas internal API
// [SECTION] Test Engine specific hooks (imgui_test_engine)

*/

//-----------------------------------------------------------------------------
// [SECTION] Header mess
//-----------------------------------------------------------------------------

// Enable SSE intrinsics if available
IMGUI_ENABLE_SSE :: has_target_feature("sse") && !IMGUI_DISABLE_SSE
IMGUI_ENABLE_SSE4_2 :: IMGUI_ENABLE_SSE && (has_target_feature("avx") || has_target_feature("sse4.2"))
// Emscripten has partial SSE 4.2 support where _mm_crc32_u32 is not available. See https://emscripten.org/docs/porting/simd.html#id11 and #8213
IMGUI_ENABLE_SSE4_2_CRC :: IMGUI_ENABLE_SSE4_2 && ! IMGUI_USE_LEGACY_CRC32_ADLER && ! (ODIN_OS == .JS)

// Enable stb_truetype by default unless FreeType is enabled.
// You can compile with both by defining both IMGUI_ENABLE_FREETYPE and IMGUI_ENABLE_STB_TRUETYPE together.
IMGUI_ENABLE_FREETYPE :: false 
IMGUI_ENABLE_STB_TRUETYPE :: true

ImGuiDataAuthority :: ImGuiDataAuthority_ // -> enum ImGuiDataAuthority_      // Enum: for storing the source authority (dock node vs window) of a field
ImGuiLayoutType :: ImGuiLayoutType_ // -> enum ImGuiLayoutType_         // Enum: Horizontal or vertical

// Flags
ImGuiActivateFlags :: ImGuiActivateFlags_ // -> enum ImGuiActivateFlags_      // Flags: for navigation/focus function (will be for ActivateItem() later)
ImGuiDebugLogFlags :: ImGuiDebugLogFlags_ // -> enum ImGuiDebugLogFlags_      // Flags: for ShowDebugLogWindow(), g.DebugLogFlags
ImGuiFocusRequestFlags :: ImGuiFocusRequestFlags_ // -> enum ImGuiFocusRequestFlags_  // Flags: for FocusWindow()
ImGuiItemStatusFlags :: ImGuiItemStatusFlags_ // -> enum ImGuiItemStatusFlags_    // Flags: for g.LastItemData.StatusFlags
ImGuiOldColumnFlags :: ImGuiOldColumnFlags_ // -> enum ImGuiOldColumnFlags_     // Flags: for BeginColumns()
ImGuiLogFlags :: ImGuiLogFlags_ // -> enum ImGuiLogFlags_           // Flags: for LogBegin() text capturing function
ImGuiNavRenderCursorFlags :: ImGuiNavRenderCursorFlags_ // -> enum ImGuiNavRenderCursorFlags_//Flags: for RenderNavCursor()
ImGuiNavMoveFlags :: ImGuiNavMoveFlags_ // -> enum ImGuiNavMoveFlags_       // Flags: for navigation requests
ImGuiNextItemDataFlags :: ImGuiNextItemDataFlags_ // -> enum ImGuiNextItemDataFlags_  // Flags: for SetNextItemXXX() functions
ImGuiNextWindowDataFlags :: ImGuiNextWindowDataFlags_ // -> enum ImGuiNextWindowDataFlags_// Flags: for SetNextWindowXXX() functions
ImGuiScrollFlags :: ImGuiScrollFlags_ // -> enum ImGuiScrollFlags_        // Flags: for ScrollToItem() and navigation requests
ImGuiSeparatorFlags :: ImGuiSeparatorFlags_ // -> enum ImGuiSeparatorFlags_     // Flags: for SeparatorEx()
ImGuiTextFlags :: ImGuiTextFlags_ // -> enum ImGuiTextFlags_          // Flags: for TextEx()
ImGuiTooltipFlags :: ImGuiTooltipFlags_ // -> enum ImGuiTooltipFlags_       // Flags: for BeginTooltipEx()
ImGuiTypingSelectFlags :: ImGuiTypingSelectFlags_ // -> enum ImGuiTypingSelectFlags_  // Flags: for GetTypingSelectRequest()
ImGuiWindowRefreshFlags :: ImGuiWindowRefreshFlags_ // -> enum ImGuiWindowRefreshFlags_ // Flags: for SetNextWindowRefreshPolicy()

//-----------------------------------------------------------------------------
// [SECTION] Macros
//-----------------------------------------------------------------------------

// Internal Drag and Drop payload types. String starting with '_' are reserved for Dear ImGui.
IMGUI_PAYLOAD_TYPE_WINDOW :: "_IMWINDOW"// Payload == ImGuiWindow*

// Debug Printing Into TTY
// (since IMGUI_VERSION_NUM >= 18729: IMGUI_DEBUG_LOG was reworked into IMGUI_DEBUG_PRINTF (and removed framecount from it). If you were using a #define IMGUI_DEBUG_LOG please rename)
IMGUI_DEBUG_PRINTF :: #force_inline proc (_FMT : $T0, args : ..any) //TODO @gen: Validate the parameters were not passed by reference.
{
	when !IMGUI_DISABLE_DEFAULT_FORMAT_FUNCTIONS  {
		fmt.print(fmt.caprintf(_FMT, ..args))
	}
}

// Debug Logging for ShowDebugLogWindow(). This is designed for relatively rare events so please don't spam.
IMGUI_DEBUG_LOG_ERROR :: #force_inline proc (fmt : string, args : ..any)
{
	g2 := GImGui;
	if (g2.DebugLogFlags & .ImGuiDebugLogFlags_EventError) != {} { IMGUI_DEBUG_LOG(fmt, args) }
	else { g2.DebugLogSkippedErrors += 1 }
}

IMGUI_DEBUG_LOG_ACTIVEID :: #force_inline proc (g : ^ImGuiContext, fmt : string, args : ..any)
{
	if (g.DebugLogFlags & .ImGuiDebugLogFlags_EventActiveId) != {} { IMGUI_DEBUG_LOG(fmt, args) }
}

IMGUI_DEBUG_LOG_FOCUS :: #force_inline proc (g : ^ImGuiContext, fmt : string, args : ..any)
{
	if (g.DebugLogFlags & .ImGuiDebugLogFlags_EventFocus) != {} { IMGUI_DEBUG_LOG(fmt, args) }
}

IMGUI_DEBUG_LOG_POPUP :: #force_inline proc (g : ^ImGuiContext, fmt : string, args : ..any)
{
	if (g.DebugLogFlags & .ImGuiDebugLogFlags_EventPopup) != {} { IMGUI_DEBUG_LOG(fmt, args) }
}

IMGUI_DEBUG_LOG_NAV :: #force_inline proc (g : ^ImGuiContext, fmt : string, args : ..any)
{
	if (g.DebugLogFlags & .ImGuiDebugLogFlags_EventNav) != {} { IMGUI_DEBUG_LOG(fmt, args) }
}

IMGUI_DEBUG_LOG_SELECTION :: #force_inline proc (g : ^ImGuiContext, fmt : string, args : ..any)
{
	if (g.DebugLogFlags & .ImGuiDebugLogFlags_EventSelection) != {} { IMGUI_DEBUG_LOG(fmt, args) }
}

IMGUI_DEBUG_LOG_CLIPPER :: #force_inline proc (g : ^ImGuiContext, fmt : string, args : ..any)
{
	if (g.DebugLogFlags & .ImGuiDebugLogFlags_EventClipper) != {} { IMGUI_DEBUG_LOG(fmt, args) }
}

IMGUI_DEBUG_LOG_IO :: #force_inline proc (g : ^ImGuiContext, fmt : string, args : ..any)
{
	if (g.DebugLogFlags & .ImGuiDebugLogFlags_EventIO) != {} { IMGUI_DEBUG_LOG(fmt, args) }
}

IMGUI_DEBUG_LOG_FONT :: #force_inline proc (g : ^ImGuiContext, fmt : string, args : ..any)
{
	if (g.DebugLogFlags & .ImGuiDebugLogFlags_EventFont) != {} { IMGUI_DEBUG_LOG(fmt, args) }
}

IMGUI_DEBUG_LOG_INPUTROUTING :: #force_inline proc (g : ^ImGuiContext, fmt : string, args : ..any)
{
	if (g.DebugLogFlags & .ImGuiDebugLogFlags_EventInputRouting) != {} { IMGUI_DEBUG_LOG(fmt, args) }
}

IMGUI_DEBUG_LOG_DOCKING :: #force_inline proc (g : ^ImGuiContext, fmt : string, args : ..any)
{
	if (g.DebugLogFlags & .ImGuiDebugLogFlags_EventDocking) != {} { IMGUI_DEBUG_LOG(fmt, args) }
}

IMGUI_DEBUG_LOG_VIEWPORT :: #force_inline proc (g : ^ImGuiContext, fmt : string, args : ..any)
{
	if (g.DebugLogFlags & .ImGuiDebugLogFlags_EventViewport) != {} { IMGUI_DEBUG_LOG(fmt, args) }
}


// "Paranoid" Debug Asserts are meant to only be enabled during specific debugging/work, otherwise would slow down the code too much.
// We currently don't have many of those so the effect is currently negligible, but onward intent to add more aggressive ones in the code.
//#define IMGUI_DEBUG_PARANOID
when IMGUI_DEBUG_PARANOID {
IM_ASSERT_PARANOID :: #force_inline proc (_EXPR : $T0, _e := #caller_expression(_EXPR))
{
	IM_ASSERT(_EXPR, _e)
}

} else { // preproc else
IM_ASSERT_PARANOID :: #force_inline proc "contextless" (_EXPR : $T0)
{
}

} // preproc endif

// Misc Macros
IM_PI :: 3.14159265358979323846
IM_NEWLINE :: "\n"
//when ! defined ( IM_TABSIZE ) { // Until we move this to runtime and/or add proper tab support, at least allow users to compile-time override
IM_TABSIZE :: (4)
//} // preproc endif
IM_MEMALIGN :: #force_inline proc "contextless" (_OFF : $T0, _ALIGN : T0) -> T0
{
	return (_OFF + (_ALIGN - 1)) & ~(_ALIGN - 1)// Memory align e.g. IM_ALIGN(0,4)=0, IM_ALIGN(1,4)=4, IM_ALIGN(4,4)=4, IM_ALIGN(5,4)=8
}

IM_F32_TO_INT8_UNBOUND :: #force_inline proc "contextless" (_VAL : f32) -> i32
{
	return cast(i32)(_VAL * 255.0 + (_VAL >= 0 ? 0.5 : -0.5)) // Unsaturated, for display purpose
}

IM_F32_TO_INT8_SAT :: #force_inline proc "contextless" (_VAL : f32) -> i32
{
	return cast(i32)(ImSaturate(_VAL) * 255.0 + 0.5) // Saturated, always output 0..255
}

IM_TRUNC :: math.trunc

IM_ROUND :: math.round

// Debug Tools
// Use 'Metrics/Debugger->Tools->Item Picker' to break into the call-stack of a specific item.
// This will call IM_DEBUG_BREAK() which you may redefine yourself. See https://github.com/scottt/debugbreak for more reference.
//when ! defined ( IM_DEBUG_BREAK ) {
IM_DEBUG_BREAK :: #force_inline proc "contextless" ()
{
	intrinsics.debug_trap()
}
//} // preproc endif// #ifndef IM_DEBUG_BREAK

// Format specifiers, printing 64-bit hasn't been decently standardized...
// In a real application you should be using PRId64 and PRIu64 from <inttypes.h> (non-windows) and on Windows define them yourself.
when true { // TODO(Rennorb) @cleanup
IM_PRId64 :: "I64d"
IM_PRIu64 :: "I64u"
IM_PRIX64 :: "I64X"
} else { // preproc else
IM_PRId64 :: "lld"
IM_PRIu64 :: "llu"
IM_PRIX64 :: "llX"
} // preproc endif

// Helpers: Sorting
ImQsort :: slice.sort_by_cmp

// Helpers: Bit manipulation
ImIsPowerOfTwo_0 :: #force_inline proc(v : u32) -> bool { return v != 0 && (v & (v - 1)) == 0 }
// Helpers: Bit manipulation
ImIsPowerOfTwo_1 :: #force_inline proc(v : ImU64) -> bool { return v != 0 && (v & (v - 1)) == 0 }
ImUpperPowerOfTwo :: #force_inline proc(v : i32) -> i32
{
	v := v - 1; v |= v >> 1; v |= v >> 2; v |= v >> 4; v |= v >> 8; v |= v >> 16; post_incr(&v); return v
}

ImToUpper :: #force_inline proc(c : u8) -> u8 { return (c >= 'a' && c <= 'z') ? c & ~u8(32) : c }
ImCharIsBlankA :: #force_inline proc(c : u8) -> bool { return c == ' ' || c == '\t' }
ImCharIsBlankW :: #force_inline proc(c : u32) -> bool { return c == ' ' || c == '\t' || c == 0x3000 }
ImCharIsXdigitA :: #force_inline proc(c : u8) -> bool { return (c >= '0' && c <= '9') || (c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f') }


// Helpers: File System
when IMGUI_DISABLE_FILE_FUNCTIONS {
ImFileHandle :: rawptr
ImFileOpen :: #force_inline proc(_ : ^u8, _ : ^u8) -> ImFileHandle { return nil }
ImFileClose :: #force_inline proc(_ : ImFileHandle) -> bool { return false }
ImFileGetSize :: #force_inline proc(_ : ImFileHandle) -> ImU64 { return cast(ImU64) -1 }
ImFileRead :: #force_inline proc(_ : rawptr, _ : ImU64, _ : ImU64, _ : ImFileHandle) -> ImU64 { return 0 }
ImFileWrite :: #force_inline proc(_ : rawptr, _ : ImU64, _ : ImU64, _ : ImFileHandle) -> ImU64 { return 0 }
} // preproc endif
when ! IMGUI_DISABLE_DEFAULT_FILE_FUNCTIONS {
ImFileHandle :: os.Handle
}
IMGUI_DISABLE_TTY_FUNCTIONS :: IMGUI_DISABLE_DEFAULT_FILE_FUNCTIONS // Can't use stdout, fflush if we are not using default file functions
// Helpers: Maths

// - Wrapper for standard libs functions. (Note that imgui_demo.cpp does _not_ use them to keep the code easy to copy)
ImFabs :: math.abs
ImSqrt :: math.sqrt
ImFmod :: math.mod
ImCos :: math.cos
ImSin :: math.sin
ImAcos :: math.acos
ImAtan2 :: math.atan2
ImAtof :: #force_inline proc(STR : string) -> f64 { f, ok := strconv.parse_f64(STR); return ok ? f : 0 }
ImCeil :: math.ceil
ImPow :: math.pow // DragBehaviorT/SliderBehaviorT uses ImPow with either float/double and need the precision
ImLog :: #force_inline proc(x : $F) -> F { return math.log(x, math.e) }// DragBehaviorT/SliderBehaviorT uses ImLog with either float/double and need the precision
ImAbs :: math.abs
ImSign :: math.sign // Sign operator - returns -1, 0 or 1 based on sign of argument
ImRsqrt :: #force_inline proc "contextless" (v : $V) -> V { return 1 / math.sqrt(v) }

// - ImMin/ImMax/ImClamp/ImLerp/ImSwap are used by widgets which support variety of types: signed/unsigned int/long long float/double
// (Exceptionally using templates here but we could also redefine them for those types)
ImMin :: proc{ ImMin_b, ImMin_v2 }
ImMax :: proc{ ImMax_b, ImMax_v2 }
ImClamp :: proc { ImClamp_b, ImClamp_v2 }
ImClamp_b :: #force_inline proc(v : $T, mn : T, mx : T) -> T where !intrinsics.type_is_array(T) { return (v < mn) ? mn : (v > mx) ? mx : v }
ImLerp :: proc { ImLerp_b, ImLerp_v2_f, ImLerp_v2_v2, ImLerp_v4 }
ImLerp_b :: #force_inline proc(a : $T, b : T, t : f32) -> T { return cast(T) (a + (b - a) * cast(T) t) }
ImSwap :: #force_inline proc(a : ^$T, b : ^T) { tmp : T = a^; a^ = b^; b^ = tmp }
ImAddClampOverflow :: #force_inline proc(a : $T, b : T, mn : T, mx : T) -> T
{
	if b < 0 && (a < mn - b) { return mn }; if b > 0 && (a > mx - b) { return mx }; return a + b
}
ImSubClampOverflow :: #force_inline proc(a : $T, b : T, mn : T, mx : T) -> T
{
	if b > 0 && (a < mn + b) { return mn }; if b < 0 && (a > mx + b) { return mx }; return a - b
}
// - ImMin/ImMax/ImClamp/ImLerp/ImSwap are used by widgets which support variety of types: signed/unsigned int/long long float/double
// (Exceptionally using templates here but we could also redefine them for those types)
// - Misc maths helpers
ImMin_b ::  #force_inline proc "contextless" (lhs, rhs : $T) -> T where T != ImVec2 { return lhs < rhs ? lhs : rhs }
ImMax_b ::  #force_inline proc "contextless" (lhs, rhs : $T) -> T where T != ImVec2 { return lhs >= rhs ? lhs : rhs }
ImMin_v2 :: #force_inline proc "contextless" (#no_broadcast lhs, #no_broadcast rhs : ImVec2) -> ImVec2 { return ImVec2{lhs.x < rhs.x ? lhs.x : rhs.x, lhs.y < rhs.y ? lhs.y : rhs.y} }
ImMax_v2 :: #force_inline proc "contextless" (#no_broadcast lhs, #no_broadcast rhs : ImVec2) -> ImVec2 { return ImVec2{lhs.x >= rhs.x ? lhs.x : rhs.x, lhs.y >= rhs.y ? lhs.y : rhs.y} }
ImClamp_v2 :: #force_inline proc "contextless" (#no_broadcast v, #no_broadcast mn, #no_broadcast mx : ImVec2) -> ImVec2 { return ImVec2{(v.x < mn.x) ? mn.x : (v.x > mx.x) ? mx.x : v.x, (v.y < mn.y) ? mn.y : (v.y > mx.y) ? mx.y : v.y} }
ImLerp_v2_f :: #force_inline proc "contextless" (#no_broadcast a, #no_broadcast b : ImVec2, t : f32) -> ImVec2 { return ImVec2{a.x + (b.x - a.x) * t, a.y + (b.y - a.y) * t} }
ImLerp_v2_v2 :: #force_inline proc "contextless" (#no_broadcast a, #no_broadcast b, #no_broadcast t : ImVec2) -> ImVec2 { return ImVec2{a.x + (b.x - a.x) * t.x, a.y + (b.y - a.y) * t.y} }
ImLerp_v4 :: #force_inline proc "contextless" (#no_broadcast a, #no_broadcast b : ImVec4, t : f32) -> ImVec4 { return ImVec4{a.x + (b.x - a.x) * t, a.y + (b.y - a.y) * t, a.z + (b.z - a.z) * t, a.w + (b.w - a.w) * t} }
ImSaturate :: #force_inline proc "contextless" (f : f32) -> f32 { return (f < 0.0) ? 0.0 : (f > 1.0) ? 1.0 : f }
ImLengthSqr :: proc { ImLengthSqr_v2, ImLengthSqr_v4 }
ImLengthSqr_v2 :: #force_inline proc "contextless" (lhs : ImVec2) -> f32 { return (lhs.x * lhs.x) + (lhs.y * lhs.y) }
ImLengthSqr_v4 :: #force_inline proc "contextless" (lhs : ImVec4) -> f32 { return (lhs.x * lhs.x) + (lhs.y * lhs.y) + (lhs.z * lhs.z) + (lhs.w * lhs.w) }
ImInvLength :: #force_inline proc "contextless" (lhs : ImVec2, fail_value : f32) -> f32
{
	d : f32 = (lhs.x * lhs.x) + (lhs.y * lhs.y); if d > 0.0 { return ImRsqrt(d) }; return fail_value
}
ImTrunc :: proc { ImTrunc_b, ImTrunc_v2 }
ImTrunc_b :: #force_inline proc "contextless" (f : f32) -> f32 { return cast(f32) cast(i32) (f) }
ImTrunc_v2 :: #force_inline proc "contextless" (v : ImVec2) -> ImVec2 { return ImVec2{cast(f32) cast(i32) (v.x), cast(f32) cast(i32) (v.y)} }
// Decent replacement for floorf()
ImFloor :: proc { ImFloor_b, ImFloor_v2 }
ImFloor_b :: #force_inline proc "contextless" (f : f32) -> f32 { return cast(f32) ((f >= 0 || cast(f32) cast(i32) f == f) ? cast(i32) f : cast(i32) f - 1) }// Decent replacement for floorf()
ImFloor_v2 :: #force_inline proc "contextless" (v : ImVec2) -> ImVec2 { return ImVec2{ImFloor(v.x), ImFloor(v.y)} }
ImModPositive :: #force_inline proc "contextless" (a : i32, b : i32) -> i32 { return (a + b) % b }
ImDot :: #force_inline proc "contextless" (a  : ImVec2, b : ImVec2) -> f32 { return a.x * b.x + a.y * b.y }
ImRotate :: #force_inline proc "contextless" (v : ImVec2, cos_a : f32, sin_a : f32) -> ImVec2 { return ImVec2{v.x * cos_a - v.y * sin_a, v.x * sin_a + v.y * cos_a} }
ImLinearSweep :: #force_inline proc "contextless" (current : f32, target : f32, speed : f32) -> f32
{
	if current < target { return ImMin(current + speed, target) }; if current > target { return ImMax(current - speed, target) }; return current
}
ImLinearRemapClamp :: #force_inline proc "contextless" (s0 : f32, s1 : f32, d0 : f32, d1 : f32, x : f32) -> f32 { return ImSaturate((x - s0) / (s1 - s0)) * (d1 - d0) + d0 }
ImMul :: #force_inline proc "contextless" (lhs : ImVec2, rhs : ImVec2) -> ImVec2 { return ImVec2{lhs.x * rhs.x, lhs.y * rhs.y} }
ImIsFloatAboveGuaranteedIntegerPrecision :: #force_inline proc "contextless" (f : f32) -> bool { return f <= -16777216 || f >= 16777216 }
ImExponentialMovingAverage :: #force_inline proc "contextless"(avg : f32, sample : f32, n : f32) -> f32
{
	avg := avg; avg -= avg / n; avg += sample / n; return avg
}


ImTriangleArea :: #force_inline proc "contextless" (a : ImVec2, b : ImVec2, c : ImVec2) -> f32 { return ImFabs((a.x * (b.y - c.y)) + (b.x * (c.y - a.y)) + (c.x * (a.y - b.y))) * 0.5 }
ImTriangleIsClockwise :: #force_inline proc "contextless" (a : ImVec2, b : ImVec2, c : ImVec2) -> bool { return ((b.x - a.x) * (c.y - b.y)) - ((c.x - b.x) * (b.y - a.y)) > 0.0 }

// Helper: ImVec1 (1D vector)
// (this odd construct is used to facilitate the transition between 1D and 2D, and the maintenance of some branches/patches)

ImVec1 :: [1]f32

// Helper: ImVec2ih (2D vector, half-size integer, for long-term packed storage)
ImVec2ih :: [2]i16

// An axis-aligned rectangle (2 points)
// Helper: ImRect (2D axis aligned bounding-box)
// NB: we can't rely on ImVec2 math operators being available here!
ImRect :: struct {
	Min : ImVec2, // Upper-left
	Max : ImVec2, // Lower-right
}

ImRect_init_1 :: proc(this : ^ImRect, min : ImVec2, max : ImVec2)
{
	this.Min = min
	this.Max = max
}

ImRect_init_2 :: proc(this : ^ImRect, v : ImVec4)
{
	this.Min.xy = v.xy
	this.Max.xy = v.zw
}

ImRect_init_3 :: proc(this : ^ImRect, x1 : f32, y1 : f32, x2 : f32, y2 : f32)
{
	this.Min.xy = { x1, y1 }
	this.Max.xy = { x2, y2 }
}

ImRect_GetCenter :: proc(this : ImRect) -> ImVec2 { return ImVec2{(this.Min.x + this.Max.x) * 0.5, (this.Min.y + this.Max.y) * 0.5} }

ImRect_GetSize :: proc(this : ImRect) -> ImVec2 { return ImVec2{this.Max.x - this.Min.x, this.Max.y - this.Min.y} }

ImRect_GetWidth :: proc(this : ImRect) -> f32 { return this.Max.x - this.Min.x }

ImRect_GetHeight :: proc(this : ImRect) -> f32 { return this.Max.y - this.Min.y }

ImRect_GetArea :: proc(this : ImRect) -> f32 { return (this.Max.x - this.Min.x) * (this.Max.y - this.Min.y) }

// Top-left
ImRect_GetTL :: proc(this : ImRect) -> ImVec2 { return this.Min }

// Top-right
ImRect_GetTR :: proc(this : ImRect) -> ImVec2 { return ImVec2{this.Max.x, this.Min.y} }

// Bottom-left
ImRect_GetBL :: proc(this : ImRect) -> ImVec2 { return ImVec2{this.Min.x, this.Max.y} }

// Bottom-right
ImRect_GetBR :: proc(this : ImRect) -> ImVec2 { return this.Max }

ImRect_Contains_0 :: proc(this : ImRect, p : ImVec2) -> bool { return p.x >= this.Min.x && p.y >= this.Min.y && p.x < this.Max.x && p.y < this.Max.y }

ImRect_Contains_1 :: proc(this : ImRect, r : ImRect) -> bool { return r.Min.x >= this.Min.x && r.Min.y >= this.Min.y && r.Max.x <= this.Max.x && r.Max.y <= this.Max.y }

ImRect_ContainsWithPad :: proc(this : ImRect, p : ImVec2, pad : ImVec2) -> bool { return p.x >= this.Min.x - pad.x && p.y >= this.Min.y - pad.y && p.x < this.Max.x + pad.x && p.y < this.Max.y + pad.y }

ImRect_Overlaps :: proc(this : ImRect, r : ImRect) -> bool { return r.Min.y < this.Max.y && r.Max.y > this.Min.y && r.Min.x < this.Max.x && r.Max.x > this.Min.x }

ImRect_Add_0 :: proc(this : ^ImRect, p : ImVec2)
{
	if this.Min.x > p.x { this.Min.x = p.x }; if this.Min.y > p.y { this.Min.y = p.y }; if this.Max.x < p.x { this.Max.x = p.x }; if this.Max.y < p.y { this.Max.y = p.y }
}

ImRect_Add_1 :: proc(this : ^ImRect, r : ImRect)
{
	if this.Min.x > r.Min.x { this.Min.x = r.Min.x }; if this.Min.y > r.Min.y { this.Min.y = r.Min.y }; if this.Max.x < r.Max.x { this.Max.x = r.Max.x }; if this.Max.y < r.Max.y { this.Max.y = r.Max.y }
}

ImRect_Expand_0 :: proc(this : ^ImRect, amount : f32)
{
	this.Min.x -= amount; this.Min.y -= amount; this.Max.x += amount; this.Max.y += amount
}

ImRect_Expand_1 :: proc(this : ^ImRect, amount : ImVec2)
{
	this.Min.x -= amount.x; this.Min.y -= amount.y; this.Max.x += amount.x; this.Max.y += amount.y
}

ImRect_Translate :: proc(this : ^ImRect, d : ImVec2)
{
	this.Min.x += d.x; this.Min.y += d.y; this.Max.x += d.x; this.Max.y += d.y
}

ImRect_TranslateX :: proc(this : ^ImRect, dx : f32)
{
	this.Min.x += dx; this.Max.x += dx
}

ImRect_TranslateY :: proc(this : ^ImRect, dy : f32)
{
	this.Min.y += dy; this.Max.y += dy
}

// Simple version, may lead to an inverted rectangle, which is fine for Contains/Overlaps test but not for display.
ImRect_ClipWith :: proc(this : ^ImRect, r : ImRect)
{
	this.Min = ImMax(this.Min, r.Min); this.Max = ImMin(this.Max, r.Max)
}

// Full version, ensure both points are fully clipped.
ImRect_ClipWithFull :: proc(this : ^ImRect, r : ImRect)
{
	this.Min = ImClamp(this.Min, r.Min, r.Max); this.Max = ImClamp(this.Max, r.Min, r.Max)
}

ImRect_Floor :: proc(this : ^ImRect)
{
	this.Min.x = IM_TRUNC(this.Min.x); this.Min.y = IM_TRUNC(this.Min.y); this.Max.x = IM_TRUNC(this.Max.x); this.Max.y = IM_TRUNC(this.Max.y)
}

ImRect_IsInverted :: proc(this : ImRect) -> bool { return this.Min.x > this.Max.x || this.Min.y > this.Max.y }

ImRect_ToVec4 :: proc(this : ImRect) -> ImVec4 { return ImVec4{this.Min.x, this.Min.y, this.Max.x, this.Max.y} }

// Helper: ImBitArray
IM_BITARRAY_TESTBIT :: #force_inline proc "contextless" (_ARRAY : [^]$T0, #any_int _N : u32) -> bool
{
	// Macro version of ImBitArrayTestBit(): ensure args have side-effect or are costly!
	return (_ARRAY[_N >> 5] & (1 << (_N & 31))) != 0
}

IM_BITARRAY_CLEARBIT :: #force_inline proc "contextless" (_ARRAY : [^]$T0, #any_int _N : u32)
{
	// Macro version of ImBitArrayClearBit(): ensure args have side-effect or are costly!
	_ARRAY[_N >> 5] &= ~(1 << (_N & 31))
}

ImBitArrayGetStorageSizeInBytes :: #force_inline proc(bitcount : i32) -> uint { return cast(uint) ((bitcount + 31) >> 5) << 2 }
ImBitArrayClearAllBits :: #force_inline proc(arr : [^]ImU32, bitcount : i32) { memset(arr, 0, cast(int) ImBitArrayGetStorageSizeInBytes(bitcount)) }
ImBitArrayTestBit :: #force_inline proc(arr : [^]ImU32, n : u32) -> bool
{
	mask : ImU32 = cast(ImU32) 1 << (n & 31); return (arr[n >> 5] & mask) != 0
}
ImBitArrayClearBit :: #force_inline proc(arr : [^]ImU32, n : u32)
{
	mask : ImU32 = cast(ImU32) 1 << (n & 31); arr[n >> 5] &= ~mask
}
ImBitArraySetBit :: #force_inline proc(arr : [^]ImU32, n : u32)
{
	mask : ImU32 = cast(ImU32) 1 << (n & 31); arr[n >> 5] |= mask
}
// Works on range [n..n2)
ImBitArraySetBitRange :: #force_inline proc(arr : [^]ImU32, n : u32, n2 : u32)
{
	n := n
	n2 := n2 - 1
	for n <= n2 {
		a_mod : u32 = (n & 31)
		b_mod : u32 = (n2 > (n | 31) ? 31 : (n2 & 31)) + 1
		mask : ImU32 = cast(ImU32) ((cast(ImU64) 1 << b_mod) - 1) & ~cast(ImU32) ((cast(ImU64) 1 << a_mod) - 1)
		arr[n >> 5] |= mask
		n = (n + 32) & ~u32(31)
	}
}

ImBitArrayPtr :: [^]ImU32// Name for use in structs

// Helper: ImBitArray class (wrapper over ImBitArray functions)
// Store 1-bit per value.
ImBitArray :: struct($BITCOUNT : u32, $OFFSET : i32 = 0) {
	Storage : [(BITCOUNT + 31) >> 5]ImU32,
}

ImBitArray_init :: proc(this : ^ImBitArray($BITCOUNT, $OFFSET)) { ClearAllBits() }

ImBitArray_ClearAllBits :: proc(this : ^ImBitArray($BITCOUNT, $OFFSET)) { memset(this.Storage, 0, size_of(Storage)) }

ImBitArray_SetAllBits :: proc(this : ^ImBitArray($BITCOUNT, $OFFSET)) { memset(this.Storage, 255, size_of(Storage)) }

ImBitArray_TestBit :: proc(this : ^ImBitArray($BITCOUNT, $OFFSET), n : u32) -> bool
{
	n := n + transmute(u32)OFFSET; IM_ASSERT(n >= 0 && n < BITCOUNT); return IM_BITARRAY_TESTBIT(raw_data(&this.Storage), n)
}

ImBitArray_SetBit :: proc(this : ^ImBitArray($BITCOUNT, $OFFSET), n : u32)
{
	n := n + transmute(u32)OFFSET; IM_ASSERT(n >= 0 && n < BITCOUNT); ImBitArraySetBit(raw_data(&this.Storage), n)
}

ImBitArray_ClearBit :: proc(this : ^ImBitArray($BITCOUNT, $OFFSET), n : u32)
{
	n := n + transmute(u32)OFFSET; IM_ASSERT(n >= 0 && n < BITCOUNT); ImBitArrayClearBit(raw_data(&this.Storage), n)
}

// Works on range [n..n2)
ImBitArray_SetBitRange :: proc(this : ^ImBitArray($BITCOUNT, $OFFSET), n : u32, n2 : u32)
{
	n := n + transmute(u32)OFFSET; n2 += OFFSET; IM_ASSERT(n >= 0 && n < BITCOUNT && n2 > n && n2 <= BITCOUNT); ImBitArraySetBitRange(raw_data(&this.Storage), n, n2)
}

//-----------------------------------------------------------------------------
// [SECTION] Forward declarations
//-----------------------------------------------------------------------------

// Store 1-bit per value
// Helper: ImBitVector
// Store 1-bit per value.
ImBitVector :: struct {
	Storage : ImVector(ImU32),
}

ImBitVector_deinit :: proc(this : ^ImBitVector)
{
	deinit(&this.Storage)
}

ImBitVector_Create :: proc(this : ^ImBitVector, sz : i32)
{
	resize(&this.Storage, (sz + 31) >> 5); memset(this.Storage.Data, 0, cast(int) this.Storage.Size * size_of(this.Storage.Data[0]))
}

ImBitVector_Clear :: proc(this : ^ImBitVector) { clear(&this.Storage) }

ImBitVector_TestBit :: proc(this : ^ImBitVector, n : u32) -> bool
{
	IM_ASSERT(n < u32(this.Storage.Size << 5)); return IM_BITARRAY_TESTBIT(this.Storage.Data, n)
}

ImBitVector_SetBit :: proc(this : ^ImBitVector, n : u32)
{
	IM_ASSERT(n < u32(this.Storage.Size << 5)); ImBitArraySetBit(this.Storage.Data, n)
}

ImBitVector_ClearBit :: proc(this : ^ImBitVector, n : u32)
{
	IM_ASSERT(n < u32(this.Storage.Size << 5)); ImBitArrayClearBit(this.Storage.Data, n)
}

ImBitVector_init :: proc(this : ^ImBitVector) { init(&this.Storage) }


// Helper: ImSpan<>
// Pointing to a span of data we don't own.
ImSpan :: struct($T : typeid) {
	Data : [^]T,
	DataEnd : ^T,
}

// Constructors, destructor
ImSpan_init_0 :: #force_inline proc(this : ^ImSpan($T)) { this.DataEnd = nil; this.Data = this.DataEnd }

ImSpan_init_1 :: #force_inline proc(this : ^ImSpan($T), data : ^T, size : i32)
{
	this.Data = data; this.DataEnd = data + size
}

ImSpan_init_2 :: #force_inline proc(this : ^ImSpan($T), data : ^T, data_end : ^T)
{
	this.Data = data; this.DataEnd = data_end
}

ImSpan_set_0 :: #force_inline proc(this : ^ImSpan($T), data : ^T, size : i32)
{
	this.Data = data; this.DataEnd = data + size
}

ImSpan_set_1 :: #force_inline proc(this : ^ImSpan($T), data : ^T, data_end : ^T)
{
	this.Data = data; this.DataEnd = data_end
}

ImSpan_size :: #force_inline proc(this : ^ImSpan($T)) -> i32 { return cast(i32) mem.ptr_sub(this.DataEnd, cast(^T) this.Data) }

ImSpan_size_in_bytes :: #force_inline proc(this : ^ImSpan($T)) -> i32 { return cast(i32) mem.ptr_sub(this.DataEnd, cast(^T) this.Data) * cast(i32) size_of(T) }

// Utilities
ImSpan_index_from_ptr :: #force_inline proc(this : ^ImSpan($T), it : ^T) -> i32
{
	IM_ASSERT(it >= this.Data && it < this.DataEnd); off : int = mem.ptr_sub(it,  cast(^T)this.Data); return cast(i32) off
}

// Helper: ImSpanAllocator<>
// Facilitate storing multiple chunks into a single large block (the "arena")
// - Usage: call Reserve() N times, allocate GetArenaSizeInBytes() worth, pass it to SetArenaBasePtr(), call GetSpan() N times to retrieve the aligned ranges.
ImSpanAllocator :: struct($CHUNKS : i32) {
	BasePtr : [^]u8,
	CurrOff : i32,
	CurrIdx : i32,
	Offsets : [CHUNKS]i32,
	Sizes : [CHUNKS]i32,
}

ImSpanAllocator_init :: proc(this : ^ImSpanAllocator($CHUNKS)) { this^ = {} }

ImSpanAllocator_Reserve :: #force_inline proc(this : ^ImSpanAllocator($CHUNKS), n : i32, #any_int sz : uint, a : i32 = 4)
{
	IM_ASSERT(n == this.CurrIdx && n < CHUNKS); this.CurrOff = IM_MEMALIGN(this.CurrOff, a); this.Offsets[n] = this.CurrOff; this.Sizes[n] = cast(i32) sz; post_incr(&this.CurrIdx); this.CurrOff += cast(i32) sz
}

ImSpanAllocator_GetArenaSizeInBytes :: #force_inline proc(this : ^ImSpanAllocator($CHUNKS)) -> i32 { return this.CurrOff }

ImSpanAllocator_SetArenaBasePtr :: #force_inline proc(this : ^ImSpanAllocator($CHUNKS), base_ptr : rawptr) { this.BasePtr = cast(^u8) base_ptr }

ImSpanAllocator_GetSpanPtrBegin :: #force_inline proc(this : ^ImSpanAllocator($CHUNKS), n : i32) -> rawptr
{
	IM_ASSERT(n >= 0 && n < CHUNKS && this.CurrIdx == CHUNKS); return cast(rawptr) (this.BasePtr[this.Offsets[n]:])
}

ImSpanAllocator_GetSpanPtrEnd :: #force_inline proc(this : ^ImSpanAllocator($CHUNKS), n : i32) -> rawptr
{
	IM_ASSERT(n >= 0 && n < CHUNKS && this.CurrIdx == CHUNKS); return cast(rawptr) (this.BasePtr[this.Offsets[n] + this.Sizes[n]:])
}

ImSpanAllocator_GetSpan :: #force_inline proc(this : ^ImSpanAllocator($CHUNKS), n : i32, span : ^ImSpan($T)) { set(span, cast(^T) ImSpanAllocator_GetSpanPtrBegin(this, n), cast(^T) ImSpanAllocator_GetSpanPtrEnd(this, n)) }

// Helper: ImPool<>
// Basic keyed storage for contiguous instances, slow/amortized insertion, O(1) indexable, O(Log N) queries by ID over a dense/hot buffer,
// Honor constructor/destructor. Add/remove invalidate all pointers. Indexes have the same lifetime as the associated object.
ImPoolIdx :: i32
ImPool :: struct($T : typeid) {
	Buf : ImVector(T), // Contiguous data
	Map : ImGuiStorage, // ID->Index
	FreeIdx : ImPoolIdx, // Next free idx to use
	AliveCount : ImPoolIdx, // Number of active/alive items (for display purpose)
}

ImPool_deinit :: proc(this : ^ImPool($T))
{
	deinit(&this.Buf)
	deinit(&this.Map)
	Clear(this)
}

ImPool_init :: proc(this : ^ImPool($T))
{
	init(&this.Buf)
	init(&this.Map)
	this.AliveCount = 0; this.FreeIdx = this.AliveCount
}

ImPool_GetByKey :: proc(this : ^ImPool($T), key : ImGuiID) -> ^T
{
	idx : i32 = GetInt(&this.Map, key, -1); return (idx != -1) ? &this.Buf.Data[idx] : nil
}

ImPool_GetByIndex :: proc(this : ^ImPool($T), n : ImPoolIdx) -> ^T { return &this.Buf.Data[n] }

ImPool_GetIndex :: proc(this : ^ImPool($T), p : ^T) -> ImPoolIdx
{
	IM_ASSERT(p >= this.Buf.Data && p < this.Buf.Data[this.Buf.Size:]); return cast(ImPoolIdx) mem.ptr_sub(p, cast(^T) this.Buf.Data)
}

ImPool_GetOrAddByKey :: proc(this : ^ImPool($T), key : ImGuiID) -> ^T
{
	p_idx : ^i32 = GetIntRef(&this.Map, key, -1); if p_idx^ != -1 { return &this.Buf.Data[p_idx^] }; p_idx^ = this.FreeIdx; return Add(this)
}

ImPool_Contains :: proc(this : ImPool($T), p : ^T) -> bool { return (p >= this.Buf.Data && p < this.Buf.Data[this.Buf.Size:]) }

ImPool_Clear :: proc(this : ^ImPool($T))
{
	for n : i32 = 0; n < this.Map.Data.Size; n += 1 {
		idx : i32 = this.Map.Data.Data[n].val_i; if idx != -1 { deinit(&this.Buf.Data[idx]) }
	}
	Clear(&this.Map)
	clear(&this.Buf)
	this.AliveCount = 0
	this.FreeIdx = this.AliveCount
}

ImPool_Add :: proc(this : ^ImPool($T)) -> ^T
{
	idx : i32 = this.FreeIdx;
	if idx == this.Buf.Size {
		resize(&this.Buf, this.Buf.Size + 1); post_incr(&this.FreeIdx)
	}
	else {
		this.FreeIdx = (cast(^i32) &this.Buf.Data[idx])^
	};
	init(&this.Buf.Data[idx])
	post_incr(&this.AliveCount)
	return &this.Buf.Data[idx]
}

ImPool_Remove_0 :: proc(this : ^ImPool($T), key : ImGuiID, p : ^T) { ImPool_Remove_1(this, key, ImPool_GetIndex(this, p)) }

ImPool_Remove_1 :: proc(this : ^ImPool($T), key : ImGuiID, idx : ImPoolIdx)
{
	deinit(&this.Buf.Data[idx]);
	(cast(^i32) &this.Buf.Data[idx])^ = this.FreeIdx;
	this.FreeIdx = idx;
	SetInt(&this.Map, key, -1);
	post_decr(&this.AliveCount)
}

ImPool_Reserve :: proc(this : ^ImPool($T), capacity : i32)
{
	reserve(&this.Buf, capacity); reserve(&this.Map.Data, capacity)
}

// To iterate a ImPool: for (int n = 0; n < pool.GetMapSize(); n++) if (T* t = pool.TryGetMapData(n)) { ... }
// Can be avoided if you know .Remove() has never been called on the pool, or AliveCount == GetMapSize()
// Number of active/alive items in the pool (for display purpose)
ImPool_GetAliveCount :: proc(this : ^ImPool($T)) -> i32 { return this.AliveCount }

ImPool_GetBufSize :: proc(this : ^ImPool($T)) -> i32 { return this.Buf.Size }

// It is the map we need iterate to find valid items, since we don't have "alive" storage anywhere
ImPool_GetMapSize :: proc(this : ^ImPool($T)) -> i32 { return this.Map.Data.Size }

ImPool_TryGetMapData :: proc(this : ^ImPool($T), n : ImPoolIdx) -> ^T
{
	idx : i32 = this.Map.Data.Data[n].val_i; if idx == -1 { return nil }; return ImPool_GetByIndex(this, idx)
}

// Helper: ImChunkStream<>
// Build and iterate a contiguous stream of variable-sized structures.
// This is used by Settings to store persistent data while reducing allocation count.
// We store the chunk size first, and align the final size on 4 bytes boundaries.
// The tedious/zealous amount of casting is to avoid -Wcast-align warnings.
ImChunkStream :: struct($T : typeid) {
	Buf : ImVector(u8),
}

ImChunkStream_deinit :: proc(this : ^ImChunkStream($T)) { deinit(&this.Buf) }

ImChunkStream_clear :: proc(this : ^ImChunkStream($T)) { clear(&this.Buf) }

ImChunkStream_empty :: proc(this : ^ImChunkStream($T)) -> bool { return this.Buf.Size == 0 }

ImChunkStream_size :: proc(this : ^ImChunkStream($T)) -> i32 { return this.Buf.Size }

ImChunkStream_alloc_chunk :: proc(this : ^ImChunkStream($T), sz : uint) -> ^T
{
	HDR_SZ :: 4
	sz := IM_MEMALIGN(HDR_SZ + sz, 4)
	off : i32 = this.Buf.Size
	resize(&this.Buf, off + cast(i32) sz)
	(cast(^i32) cast(rawptr) (&this.Buf.Data[off]))^ = cast(i32) sz
	return cast(^T) cast(rawptr) (&this.Buf.Data[off + cast(i32) HDR_SZ])
}

ImChunkStream_begin :: proc(this : ^ImChunkStream($T)) -> ^T
{
	HDR_SZ :: 4
	if this.Buf.Data == nil { return nil }
	return cast(^T) cast(rawptr) (&this.Buf.Data[HDR_SZ])
}

ImChunkStream_next_chunk :: proc(this : ^ImChunkStream($T), p : ^T) -> ^T
{
	HDR_SZ : uint : 4
	IM_ASSERT(p >= begin(this) && p < end(this));
	p := cast(^T) cast(rawptr) (mem.ptr_offset(cast(^u8)p, chunk_size(this, p)))
	if p == cast(^T) cast(rawptr) (mem.ptr_offset(cast(^u8) end(this), HDR_SZ)) { return nil }
	IM_ASSERT(p < end(this))
	return p
}

ImChunkStream_chunk_size :: proc(this : ^ImChunkStream($T), p : ^T) -> i32 { return (cast([^]i32) p)[-1] }

ImChunkStream_end :: proc(this : ^ImChunkStream($T)) -> ^T { return cast(^T) &this.Buf.Data[this.Buf.Size] }

ImChunkStream_offset_from_ptr :: proc(this : ^ImChunkStream($T), p : ^T) -> i32
{
	IM_ASSERT(p >= begin(this) && p < end(this)); off : int = mem.ptr_sub(cast(^u8) p, cast(^u8)this.Buf.Data); return cast(i32) off
}

ImChunkStream_ptr_from_offset :: proc(this : ^ImChunkStream($T), off : i32) -> ^T
{
	IM_ASSERT(off >= 4 && off < this.Buf.Size); return cast(^T) &this.Buf.Data[off]
}

ImChunkStream_swap :: proc(this : ^ImChunkStream($T), rhs : ^ImChunkStream(T)) { swap(&rhs.Buf, &this.Buf) }

ImChunkStream_init :: proc(this : ^ImChunkStream($T)) { init(&this.Buf) }

// Helper: ImGuiTextIndex
// Maintain a line index for a text buffer. This is a strong candidate to be moved into the public API.
ImGuiTextIndex :: struct {
	LineOffsets : ImVector(i32),
	EndOffset : i32, // Because we don't own text buffer we need to maintain EndOffset (may bake in LineOffsets?)
}

ImGuiTextIndex_deinit :: proc(this : ^ImGuiTextIndex) { deinit(&this.LineOffsets) }

ImGuiTextIndex_clear :: proc(this : ^ImGuiTextIndex)
{
	clear(&this.LineOffsets); this.EndOffset = 0
}

ImGuiTextIndex_size :: proc(this : ^ImGuiTextIndex) -> i32 { return this.LineOffsets.Size }

ImGuiTextIndex_get_line_begin :: proc(this : ^ImGuiTextIndex, base : [^]u8, n : i32) -> [^]u8 { return base[this.LineOffsets.Data[n]:] }

ImGuiTextIndex_get_line_end :: proc(this : ^ImGuiTextIndex, base : [^]u8, n : i32) -> ^u8 { return &base[(n + 1 < this.LineOffsets.Size ? (this.LineOffsets.Data[n + 1] - 1) : this.EndOffset)] }

ImGuiTextIndex_init :: proc(this : ^ImGuiTextIndex) {
	init(&this.LineOffsets)
	this.EndOffset = 0
}

//-----------------------------------------------------------------------------
// [SECTION] ImDrawList support
//-----------------------------------------------------------------------------

// ImDrawList: Helper function to calculate a circle's segment count given its radius and a "maximum error" value.
// Estimation of number of circle segment based on error is derived using method described in https://stackoverflow.com/a/2244088/15194693
// Number of segments (N) is calculated using equation:
//   N = ceil ( pi / acos(1 - error / r) )     where r > 0, error <= r
// Our equation is significantly simpler that one in the post thanks for choosing segment that is
// perpendicular to X axis. Follow steps in the article from this starting condition and you will
// will get this result.
//
// Rendering circles with an odd number of segments, while mathematically correct will produce
// asymmetrical results on the raster grid. Therefore we're rounding N to next even number (7->8, 8->8, 9->10 etc.)
IM_ROUNDUP_TO_EVEN :: #force_inline proc "contextless" (_V : $T0) -> T0
{
	return ((_V + 1) / 2) * 2
}

IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_MIN :: 4
IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_MAX :: 512
IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_CALC :: #force_inline proc (_RAD : $T0, _MAXERROR : $T1) -> int
{
	return ImClamp(IM_ROUNDUP_TO_EVEN(cast(int) ImCeil(IM_PI / ImAcos(1 - ImMin(_MAXERROR, _RAD) / _RAD))), IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_MIN, IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_MAX)
}


// Raw equation from IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_CALC rewritten for 'r' and 'error'.
IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_CALC_R :: #force_inline proc "contextless" (_N : $T0, _MAXERROR : $T1) -> T1
{
	return _MAXERROR / (1 - ImCos(IM_PI / ImMax(cast(f32)_N, IM_PI)))
}

IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_CALC_ERROR :: #force_inline proc "contextless" (_N : $T0, _RAD : $T1) -> T1
{
	return (1 - ImCos(IM_PI / ImMax(cast(f32)_N, IM_PI))) / _RAD
}


// ImDrawList: Lookup table size for adaptive arc drawing, cover full circle.
//when ! defined ( IM_DRAWLIST_ARCFAST_TABLE_SIZE ) {
IM_DRAWLIST_ARCFAST_TABLE_SIZE :: 48// Number of samples in lookup table.
//} // preproc endif
IM_DRAWLIST_ARCFAST_SAMPLE_MAX :: IM_DRAWLIST_ARCFAST_TABLE_SIZE// Sample index _PathArcToFastEx() for 360 angle.

// Data shared among multiple draw lists (typically owned by parent ImGui context, but you may create one yourself)
// Data shared between all ImDrawList instances
// Data shared between all ImDrawList instances
// Conceptually this could have been called e.g. ImDrawListSharedContext
// Typically one ImGui context would create and maintain one of this.
// You may want to create your own instance of you try to ImDrawList completely without ImGui. In that case, watch out for future changes to this structure.
ImDrawListSharedData :: struct {
	TexUvWhitePixel : ImVec2, // UV of white pixel in the atlas
	TexUvLines : [^]ImVec4, // UV of anti-aliased lines in the atlas
	Font : ^ImFont, // Current/default font (optional, for simplified AddText overload)
	FontSize : f32, // Current/default font size (optional, for simplified AddText overload)
	FontScale : f32, // Current/default font scale (== FontSize / Font->FontSize)
	CurveTessellationTol : f32, // Tessellation tolerance when using PathBezierCurveTo()
	CircleSegmentMaxError : f32, // Number of circle segments to use per pixel of radius for AddCircle() etc
	ClipRectFullscreen : ImVec4, // Value for PushClipRectFullscreen()
	InitialFlags : ImDrawListFlags, // Initial flags at the beginning of the frame (it is possible to alter flags on a per-drawlist basis afterwards)
	TempBuffer : ImVector(ImVec2), // Temporary write buffer

	// Lookup tables
	ArcFastVtx : [IM_DRAWLIST_ARCFAST_TABLE_SIZE]ImVec2, // Sample points on the quarter of the circle.
	ArcFastRadiusCutoff : f32, // Cutoff radius after which arc drawing will fallback to slower PathArcTo()
	CircleSegmentCounts : [64]ImU8, // Precomputed segment count for given radius before we calculate it dynamically (to avoid calculation overhead)
}

ImDrawListSharedData_deinit :: proc(this : ^ImDrawListSharedData) { deinit(&this.TempBuffer) }

// Helper to build a ImDrawData instance
ImDrawDataBuilder :: struct {
	Layers : [2]^ImVector(^ImDrawList), // Pointers to global layers for: regular, tooltip. LayersP[0] is owned by DrawData.
	LayerData1 : ImVector(^ImDrawList),
}

ImDrawDataBuilder_deinit :: proc(this : ^ImDrawDataBuilder) { deinit(&this.LayerData1) }

ImDrawDataBuilder_init :: proc(this : ^ImDrawDataBuilder) { this^ = {} }

// Variable information (e.g. to access style variables from an enum)
//-----------------------------------------------------------------------------
// [SECTION] Data types support
//-----------------------------------------------------------------------------

ImGuiDataVarInfo :: struct {
	Type : ImGuiDataType,
	Count : ImU32, // 1+
	Offset : ImU32, // Offset in parent structure
}

ImGuiDataVarInfo_GetVarPtr :: proc(this : ^ImGuiDataVarInfo, parent : rawptr) -> rawptr { return cast(rawptr) &(cast([^]u8) parent)[this.Offset] }

ImGuiDataTypeStorage :: struct {
	Data : [8]ImU8, // Opaque storage to fit any data up to ImGuiDataType_COUNT
}

// Type information associated to a ImGuiDataType enum
// Type information associated to one ImGuiDataType. Retrieve with DataTypeGetInfo().
ImGuiDataTypeInfo :: struct {
	Size : uint, // Size in bytes
	Name : string, // Short descriptive name for the type, for debugging
	PrintFmt : string, // Default printf format for the type
	ScanFmt : string, // Default scanf format for the type
}

// Extend ImGuiDataType_
ImGuiDataTypePrivate_ :: enum i32 {
	ImGuiDataType_Pointer = i32(ImGuiDataType_.ImGuiDataType_COUNT) + 1,
	ImGuiDataType_ID,
}

//-----------------------------------------------------------------------------
// [SECTION] Widgets support: flags, enums, data structures
//-----------------------------------------------------------------------------

// Extend ImGuiItemFlags
// - input: PushItemFlag() manipulates g.CurrentItemFlags, g.NextItemData.ItemFlags, ItemAdd() calls may add extra flags too.
// - output: stored in g.LastItemData.ItemFlags
ImGuiItemFlagsPrivate_ :: enum i32 {
	// Controlled by user
	ImGuiItemFlags_Disabled = 1 << 10, // false     // Disable interactions (DOES NOT affect visuals. DO NOT mix direct use of this with BeginDisabled(). See BeginDisabled()/EndDisabled() for full disable feature, and github #211).
	ImGuiItemFlags_ReadOnly = 1 << 11, // false     // [ALPHA] Allow hovering interactions but underlying value is not changed.
	ImGuiItemFlags_MixedValue = 1 << 12, // false     // [BETA] Represent a mixed/indeterminate value, generally multi-selection where values differ. Currently only supported by Checkbox() (later should support all sorts of widgets)
	ImGuiItemFlags_NoWindowHoverableCheck = 1 << 13, // false     // Disable hoverable check in ItemHoverable()
	ImGuiItemFlags_AllowOverlap = 1 << 14, // false     // Allow being overlapped by another widget. Not-hovered to Hovered transition deferred by a frame.
	ImGuiItemFlags_NoNavDisableMouseHover = 1 << 15, // false     // Nav keyboard/gamepad mode doesn't disable hover highlight (behave as if NavHighlightItemUnderNav==false).
	ImGuiItemFlags_NoMarkEdited = 1 << 16, // false     // Skip calling MarkItemEdited()

	// Controlled by widget code
	ImGuiItemFlags_Inputable = 1 << 20, // false     // [WIP] Auto-activate input mode when tab focused. Currently only used and supported by a few items before it becomes a generic feature.
	ImGuiItemFlags_HasSelectionUserData = 1 << 21, // false     // Set by SetNextItemSelectionUserData()
	ImGuiItemFlags_IsMultiSelect = 1 << 22, // false     // Set by SetNextItemSelectionUserData()

	ImGuiItemFlags_Default_ = i32(ImGuiItemFlags_.ImGuiItemFlags_AutoClosePopups), // Please don't change, use PushItemFlag() instead.

	// Obsolete
	//ImGuiItemFlags_SelectableDontClosePopup = !ImGuiItemFlags_AutoClosePopups, // Can't have a redirect as we inverted the behavior
}

when IMGUI_ENABLE_TEST_ENGINE {
// Status flags for an already submitted item
// - output: stored in g.LastItemData.StatusFlags
ImGuiItemStatusFlags_ :: enum i32 {
	ImGuiItemStatusFlags_None = 0,
	ImGuiItemStatusFlags_HoveredRect = 1 << 0, // Mouse position is within item rectangle (does NOT mean that the window is in correct z-order and can be hovered!, this is only one part of the most-common IsItemHovered test)
	ImGuiItemStatusFlags_HasDisplayRect = 1 << 1, // g.LastItemData.DisplayRect is valid
	ImGuiItemStatusFlags_Edited = 1 << 2, // Value exposed by item was edited in the current frame (should match the bool return value of most widgets)
	ImGuiItemStatusFlags_ToggledSelection = 1 << 3, // Set when Selectable(), TreeNode() reports toggling a selection. We can't report "Selected", only state changes, in order to easily handle clipping with less issues.
	ImGuiItemStatusFlags_ToggledOpen = 1 << 4, // Set when TreeNode() reports toggling their open state.
	ImGuiItemStatusFlags_HasDeactivated = 1 << 5, // Set if the widget/group is able to provide data for the ImGuiItemStatusFlags_Deactivated flag.
	ImGuiItemStatusFlags_Deactivated = 1 << 6, // Only valid if ImGuiItemStatusFlags_HasDeactivated is set.
	ImGuiItemStatusFlags_HoveredWindow = 1 << 7, // Override the HoveredWindow test to allow cross-window hover testing.
	ImGuiItemStatusFlags_Visible = 1 << 8, // [WIP] Set when item is overlapping the current clipping rectangle (Used internally. Please don't use yet: API/system will change as we refactor Itemadd()).
	ImGuiItemStatusFlags_HasClipRect = 1 << 9, // g.LastItemData.ClipRect is valid.
	ImGuiItemStatusFlags_HasShortcut = 1 << 10, // g.LastItemData.Shortcut valid. Set by SetNextItemShortcut() -> ItemAdd().

	// Additional status + semantic for ImGuiTestEngine
	ImGuiItemStatusFlags_Openable = 1 << 20, // Item is an openable (e.g. TreeNode)
	ImGuiItemStatusFlags_Opened = 1 << 21, // Opened status
	ImGuiItemStatusFlags_Checkable = 1 << 22, // Item is a checkable (e.g. CheckBox, MenuItem)
	ImGuiItemStatusFlags_Checked = 1 << 23, // Checked status
	ImGuiItemStatusFlags_Inputable = 1 << 24, // Item is a text-inputable (e.g. InputText, SliderXXX, DragXXX)
}
} else { // preproc else
// Status flags for an already submitted item
// - output: stored in g.LastItemData.StatusFlags
ImGuiItemStatusFlags_ :: enum i32 {
	ImGuiItemStatusFlags_None = 0,
	ImGuiItemStatusFlags_HoveredRect = 1 << 0, // Mouse position is within item rectangle (does NOT mean that the window is in correct z-order and can be hovered!, this is only one part of the most-common IsItemHovered test)
	ImGuiItemStatusFlags_HasDisplayRect = 1 << 1, // g.LastItemData.DisplayRect is valid
	ImGuiItemStatusFlags_Edited = 1 << 2, // Value exposed by item was edited in the current frame (should match the bool return value of most widgets)
	ImGuiItemStatusFlags_ToggledSelection = 1 << 3, // Set when Selectable(), TreeNode() reports toggling a selection. We can't report "Selected", only state changes, in order to easily handle clipping with less issues.
	ImGuiItemStatusFlags_ToggledOpen = 1 << 4, // Set when TreeNode() reports toggling their open state.
	ImGuiItemStatusFlags_HasDeactivated = 1 << 5, // Set if the widget/group is able to provide data for the ImGuiItemStatusFlags_Deactivated flag.
	ImGuiItemStatusFlags_Deactivated = 1 << 6, // Only valid if ImGuiItemStatusFlags_HasDeactivated is set.
	ImGuiItemStatusFlags_HoveredWindow = 1 << 7, // Override the HoveredWindow test to allow cross-window hover testing.
	ImGuiItemStatusFlags_Visible = 1 << 8, // [WIP] Set when item is overlapping the current clipping rectangle (Used internally. Please don't use yet: API/system will change as we refactor Itemadd()).
	ImGuiItemStatusFlags_HasClipRect = 1 << 9, // g.LastItemData.ClipRect is valid.
	ImGuiItemStatusFlags_HasShortcut = 1 << 10, // g.LastItemData.Shortcut valid. Set by SetNextItemShortcut() -> ItemAdd().
}
} // preproc endif

// Extend ImGuiHoveredFlags_
ImGuiHoveredFlagsPrivate_ :: enum i32 {
	ImGuiHoveredFlags_DelayMask_ = i32(ImGuiHoveredFlags_.ImGuiHoveredFlags_DelayNone | ImGuiHoveredFlags_.ImGuiHoveredFlags_DelayShort | ImGuiHoveredFlags_.ImGuiHoveredFlags_DelayNormal | ImGuiHoveredFlags_.ImGuiHoveredFlags_NoSharedDelay),
	ImGuiHoveredFlags_AllowedMaskForIsWindowHovered = i32(ImGuiHoveredFlags_.ImGuiHoveredFlags_ChildWindows | ImGuiHoveredFlags_.ImGuiHoveredFlags_RootWindow | ImGuiHoveredFlags_.ImGuiHoveredFlags_AnyWindow | ImGuiHoveredFlags_.ImGuiHoveredFlags_NoPopupHierarchy | ImGuiHoveredFlags_.ImGuiHoveredFlags_DockHierarchy | ImGuiHoveredFlags_.ImGuiHoveredFlags_AllowWhenBlockedByPopup | ImGuiHoveredFlags_.ImGuiHoveredFlags_AllowWhenBlockedByActiveItem | ImGuiHoveredFlags_.ImGuiHoveredFlags_ForTooltip | ImGuiHoveredFlags_.ImGuiHoveredFlags_Stationary),
	ImGuiHoveredFlags_AllowedMaskForIsItemHovered = i32(ImGuiHoveredFlags_.ImGuiHoveredFlags_AllowWhenBlockedByPopup | ImGuiHoveredFlags_.ImGuiHoveredFlags_AllowWhenBlockedByActiveItem | ImGuiHoveredFlags_.ImGuiHoveredFlags_AllowWhenOverlapped | ImGuiHoveredFlags_.ImGuiHoveredFlags_AllowWhenDisabled | ImGuiHoveredFlags_.ImGuiHoveredFlags_NoNavOverride | ImGuiHoveredFlags_.ImGuiHoveredFlags_ForTooltip | ImGuiHoveredFlags_.ImGuiHoveredFlags_Stationary) | i32(ImGuiHoveredFlags_DelayMask_),
}

// Extend ImGuiInputTextFlags_
ImGuiInputTextFlagsPrivate_ :: enum i32 {
	// [Internal]
	ImGuiInputTextFlags_Multiline = 1 << 26, // For internal use by InputTextMultiline()
	ImGuiInputTextFlags_MergedItem = 1 << 27, // For internal use by TempInputText(), will skip calling ItemAdd(). Require bounding-box to strictly match.
	ImGuiInputTextFlags_LocalizeDecimalPoint = 1 << 28, // For internal use by InputScalar() and TempInputScalar()
}

// Extend ImGuiButtonFlags_
ImGuiButtonFlagsPrivate_ :: enum i32 {
	ImGuiButtonFlags_PressedOnClick = 1 << 4, // return true on click (mouse down event)
	ImGuiButtonFlags_PressedOnClickRelease = 1 << 5, // [Default] return true on click + release on same item <-- this is what the majority of Button are using
	ImGuiButtonFlags_PressedOnClickReleaseAnywhere = 1 << 6, // return true on click + release even if the release event is not done while hovering the item
	ImGuiButtonFlags_PressedOnRelease = 1 << 7, // return true on release (default requires click+release)
	ImGuiButtonFlags_PressedOnDoubleClick = 1 << 8, // return true on double-click (default requires click+release)
	ImGuiButtonFlags_PressedOnDragDropHold = 1 << 9, // return true when held into while we are drag and dropping another item (used by e.g. tree nodes, collapsing headers)
	//ImGuiButtonFlags_Repeat               = 1 << 10,  // hold to repeat -> use ImGuiItemFlags_ButtonRepeat instead.
	ImGuiButtonFlags_FlattenChildren = 1 << 11, // allow interactions even if a child window is overlapping
	ImGuiButtonFlags_AllowOverlap = 1 << 12, // require previous frame HoveredId to either match id or be null before being usable.
	//ImGuiButtonFlags_DontClosePopups      = 1 << 13,  // disable automatically closing parent popup on press
	//ImGuiButtonFlags_Disabled             = 1 << 14,  // disable interactions -> use BeginDisabled() or ImGuiItemFlags_Disabled
	ImGuiButtonFlags_AlignTextBaseLine = 1 << 15, // vertically align button to match text baseline - ButtonEx() only // FIXME: Should be removed and handled by SmallButton(), not possible currently because of DC.CursorPosPrevLine
	ImGuiButtonFlags_NoKeyModsAllowed = 1 << 16, // disable mouse interaction if a key modifier is held
	ImGuiButtonFlags_NoHoldingActiveId = 1 << 17, // don't set ActiveId while holding the mouse (ImGuiButtonFlags_PressedOnClick only)
	ImGuiButtonFlags_NoNavFocus = 1 << 18, // don't override navigation focus when activated (FIXME: this is essentially used every time an item uses ImGuiItemFlags_NoNav, but because legacy specs don't requires LastItemData to be set ButtonBehavior(), we can't poll g.LastItemData.ItemFlags)
	ImGuiButtonFlags_NoHoveredOnFocus = 1 << 19, // don't report as hovered when nav focus is on this item
	ImGuiButtonFlags_NoSetKeyOwner = 1 << 20, // don't set key/input owner on the initial click (note: mouse buttons are keys! often, the key in question will be ImGuiKey_MouseLeft!)
	ImGuiButtonFlags_NoTestKeyOwner = 1 << 21, // don't test key/input owner when polling the key (note: mouse buttons are keys! often, the key in question will be ImGuiKey_MouseLeft!)
	ImGuiButtonFlags_PressedOnMask_ = ImGuiButtonFlags_PressedOnClick | ImGuiButtonFlags_PressedOnClickRelease | ImGuiButtonFlags_PressedOnClickReleaseAnywhere | ImGuiButtonFlags_PressedOnRelease | ImGuiButtonFlags_PressedOnDoubleClick | ImGuiButtonFlags_PressedOnDragDropHold,
	ImGuiButtonFlags_PressedOnDefault_ = ImGuiButtonFlags_PressedOnClickRelease,
}

// Extend ImGuiComboFlags_
ImGuiComboFlagsPrivate_ :: enum i32 {
	ImGuiComboFlags_CustomPreview = 1 << 20, // enable BeginComboPreview()
}

// Extend ImGuiSliderFlags_
ImGuiSliderFlagsPrivate_ :: enum i32 {
	ImGuiSliderFlags_Vertical = 1 << 20, // Should this slider be orientated vertically?
	ImGuiSliderFlags_ReadOnly = 1 << 21, // Consider using g.NextItemData.ItemFlags |= ImGuiItemFlags_ReadOnly instead.
}

// Extend ImGuiSelectableFlags_
ImGuiSelectableFlagsPrivate_ :: enum i32 {
	// NB: need to be in sync with last value of ImGuiSelectableFlags_
	ImGuiSelectableFlags_NoHoldingActiveID = 1 << 20,
	ImGuiSelectableFlags_SelectOnNav = 1 << 21, // (WIP) Auto-select when moved into. This is not exposed in public API as to handle multi-select and modifiers we will need user to explicitly control focus scope. May be replaced with a BeginSelection() API.
	ImGuiSelectableFlags_SelectOnClick = 1 << 22, // Override button behavior to react on Click (default is Click+Release)
	ImGuiSelectableFlags_SelectOnRelease = 1 << 23, // Override button behavior to react on Release (default is Click+Release)
	ImGuiSelectableFlags_SpanAvailWidth = 1 << 24, // Span all avail width even if we declared less for layout purpose. FIXME: We may be able to remove this (added in 6251d379, 2bcafc86 for menus)
	ImGuiSelectableFlags_SetNavIdOnHover = 1 << 25, // Set Nav/Focus ID on mouse hover (used by MenuItem)
	ImGuiSelectableFlags_NoPadWithHalfSpacing = 1 << 26, // Disable padding each side with ItemSpacing * 0.5f
	ImGuiSelectableFlags_NoSetKeyOwner = 1 << 27, // Don't set key/input owner on the initial click (note: mouse buttons are keys! often, the key in question will be ImGuiKey_MouseLeft!)
}

// Extend ImGuiTreeNodeFlags_
ImGuiTreeNodeFlagsPrivate_ :: enum i32 {
	ImGuiTreeNodeFlags_ClipLabelForTrailingButton = 1 << 28, // FIXME-WIP: Hard-coded for CollapsingHeader()
	ImGuiTreeNodeFlags_UpsideDownArrow = 1 << 29, // FIXME-WIP: Turn Down arrow into an Up arrow, for reversed trees (#6517)
	ImGuiTreeNodeFlags_OpenOnMask_ = i32(ImGuiTreeNodeFlags_.ImGuiTreeNodeFlags_OpenOnDoubleClick | ImGuiTreeNodeFlags_.ImGuiTreeNodeFlags_OpenOnArrow),
}

ImGuiSeparatorFlags_ :: enum i32 {
	ImGuiSeparatorFlags_None = 0,
	ImGuiSeparatorFlags_Horizontal = 1 << 0, // Axis default to current layout type, so generally Horizontal unless e.g. in a menu bar
	ImGuiSeparatorFlags_Vertical = 1 << 1,
	ImGuiSeparatorFlags_SpanAllColumns = 1 << 2, // Make separator cover all columns of a legacy Columns() set.
}

// Flags for FocusWindow(). This is not called ImGuiFocusFlags to avoid confusion with public-facing ImGuiFocusedFlags.
// FIXME: Once we finishing replacing more uses of GetTopMostPopupModal()+IsWindowWithinBeginStackOf()
// and FindBlockingModal() with this, we may want to change the flag to be opt-out instead of opt-in.
ImGuiFocusRequestFlags_ :: enum i32 {
	ImGuiFocusRequestFlags_None = 0,
	ImGuiFocusRequestFlags_RestoreFocusedChild = 1 << 0, // Find last focused child (if any) and focus it instead.
	ImGuiFocusRequestFlags_UnlessBelowModal = 1 << 1, // Do not set focus if the window is below a modal.
}

ImGuiTextFlags_ :: enum i32 {
	ImGuiTextFlags_None = 0,
	ImGuiTextFlags_NoWidthForLargeClippedText = 1 << 0,
}

ImGuiTooltipFlags_ :: enum i32 {
	ImGuiTooltipFlags_None = 0,
	ImGuiTooltipFlags_OverridePrevious = 1 << 1, // Clear/ignore previously submitted tooltip (defaults to append)
}

// FIXME: this is in development, not exposed/functional as a generic feature yet.
// Horizontal/Vertical enums are fixed to 0/1 so they may be used to index ImVec2
ImGuiLayoutType_ :: enum i32 {
	ImGuiLayoutType_Horizontal = 0,
	ImGuiLayoutType_Vertical = 1,
}

// Flags for LogBegin() text capturing function
ImGuiLogFlags_ :: enum i32 {
	ImGuiLogFlags_None = 0,

	ImGuiLogFlags_OutputTTY = 1 << 0,
	ImGuiLogFlags_OutputFile = 1 << 1,
	ImGuiLogFlags_OutputBuffer = 1 << 2,
	ImGuiLogFlags_OutputClipboard = 1 << 3,
	ImGuiLogFlags_OutputMask_ = ImGuiLogFlags_OutputTTY | ImGuiLogFlags_OutputFile | ImGuiLogFlags_OutputBuffer | ImGuiLogFlags_OutputClipboard,
}

// X/Y enums are fixed to 0/1 so they may be used to index ImVec2
ImGuiAxis :: enum i32 {
	ImGuiAxis_None = -1,
	ImGuiAxis_X = 0,
	ImGuiAxis_Y = 1,
}

ImGuiPlotType :: enum i32 {
	ImGuiPlotType_Lines,
	ImGuiPlotType_Histogram,
}

// Stacked color modifier, backup of modified data so we can restore it
// Stacked color modifier, backup of modified data so we can restore it
ImGuiColorMod :: struct {
	Col : ImGuiCol,
	BackupValue : ImVec4,
}

// Stacked style modifier, backup of modified data so we can restore it
// Stacked style modifier, backup of modified data so we can restore it. Data type inferred from the variable.
ImGuiStyleMod :: struct {
	VarIdx : ImGuiStyleVar,
	using _0 : struct #raw_union { BackupInt : [2]i32, BackupFloat : [2]f32, },
}

ImGuiStyleMod_init_0 :: proc(this : ^ImGuiStyleMod, idx : ImGuiStyleVar, v : i32)
{
	this.VarIdx = idx; this.BackupInt[0] = v
}

ImGuiStyleMod_init_1 :: proc(this : ^ImGuiStyleMod, idx : ImGuiStyleVar, v : f32)
{
	this.VarIdx = idx; this.BackupFloat[0] = v
}

ImGuiStyleMod_init_2 :: proc(this : ^ImGuiStyleMod, idx : ImGuiStyleVar, v : ImVec2)
{
	this.VarIdx = idx; this.BackupFloat[0] = v.x; this.BackupFloat[1] = v.y
}

// Storage data for BeginComboPreview()/EndComboPreview()
ImGuiComboPreviewData :: struct {
	PreviewRect : ImRect,
	BackupCursorPos : ImVec2,
	BackupCursorMaxPos : ImVec2,
	BackupCursorPosPrevLine : ImVec2,
	BackupPrevLineTextBaseOffset : f32,
	BackupLayout : ImGuiLayoutType,
}

ImGuiComboPreviewData_init :: proc(this : ^ImGuiComboPreviewData) { this^ = {} }

// Stacked storage data for BeginGroup()/EndGroup()
// Stacked storage data for BeginGroup()/EndGroup()
ImGuiGroupData :: struct {
	WindowID : ImGuiID,
	BackupCursorPos : ImVec2,
	BackupCursorMaxPos : ImVec2,
	BackupCursorPosPrevLine : ImVec2,
	BackupIndent : ImVec1,
	BackupGroupOffset : ImVec1,
	BackupCurrLineSize : ImVec2,
	BackupCurrLineTextBaseOffset : f32,
	BackupActiveIdIsAlive : ImGuiID,
	BackupActiveIdPreviousFrameIsAlive : bool,
	BackupHoveredIdIsAlive : bool,
	BackupIsSameLine : bool,
	EmitItem : bool,
}

// Simple column measurement, currently used for MenuItem() only
// Simple column measurement, currently used for MenuItem() only.. This is very short-sighted/throw-away code and NOT a generic helper.
ImGuiMenuColumns :: struct {
	TotalWidth : ImU32,
	NextTotalWidth : ImU32,
	Spacing : ImU16,
	OffsetIcon : ImU16, // Always zero for now
	OffsetLabel : ImU16, // Offsets are locked in Update()
	OffsetShortcut : ImU16,
	OffsetMark : ImU16,
	Widths : [4]ImU16, // Width of:   Icon, Label, Shortcut, Mark  (accumulators for current frame)
}

ImGuiMenuColumns_init :: proc(this : ^ImGuiMenuColumns) { this^ = {} }

// Internal temporary state for deactivating InputText() instances.
ImGuiInputTextDeactivatedState :: struct {
	ID : ImGuiID, // widget id owning the text state (which just got deactivated)
	TextA : ImVector(u8), // text buffer
}

ImGuiInputTextDeactivatedState_deinit :: proc(this : ^ImGuiInputTextDeactivatedState) { deinit(&this.TextA) }

ImGuiInputTextDeactivatedState_init :: proc(this : ^ImGuiInputTextDeactivatedState) { this^ = {} }

ImGuiInputTextDeactivatedState_ClearFreeMemory :: proc(this : ^ImGuiInputTextDeactivatedState)
{
	this.ID = 0; clear(&this.TextA)
}

// Forward declare imstb_textedit.h structure + make its main configuration define accessible
//TODO @gen: there was a '#undef %!(MISSING ARGUMENT)' here, that cannot be emulated in odin. Make sure everything works as expected.
//TODO @gen: there was a '#undef %!(MISSING ARGUMENT)' here, that cannot be emulated in odin. Make sure everything works as expected.
IMSTB_TEXTEDIT_STRING :: ImGuiInputTextState
IMSTB_TEXTEDIT_CHARTYPE :: u8
IMSTB_TEXTEDIT_POSITIONTYPE :: i32
IMSTB_TEXTEDIT_GETWIDTH_NEWLINE :: (-1.0)
IMSTB_TEXTEDIT_UNDOSTATECOUNT :: 99
IMSTB_TEXTEDIT_UNDOCHARCOUNT :: 999
ImStbTexteditState :: ImStb_STB_TexteditState

// Internal state of the currently focused/edited text input box
// Internal state of the currently focused/edited text input box
// For a given item ID, access with ImGui::GetInputTextState()
ImGuiInputTextState :: struct {
	Ctx : ^ImGuiContext, // parent UI context (needs to be set explicitly by parent).
	Stb : ^ImStbTexteditState, // State for stb_textedit.h
	Flags : ImGuiInputTextFlags, // copy of InputText() flags. may be used to check if e.g. ImGuiInputTextFlags_Password is set.
	ID : ImGuiID, // widget id owning the text state
	TextLen : i32, // UTF-8 length of the string in TextA (in bytes)
	TextSrc : [^]u8, // == TextA.Data unless read-only, in which case == buf passed to InputText(). Field only set and valid _inside_ the call InputText() call.
	TextA : ImVector(u8), // main UTF8 buffer. TextA.Size is a buffer size! Should always be >= buf_size passed by user (and of course >= CurLenA + 1).
	TextToRevertTo : ImVector(u8), // value to revert to when pressing Escape = backup of end-user buffer at the time of focus (in UTF-8, unaltered)
	CallbackTextBackup : ImVector(u8), // temporary storage for callback to support automatic reconcile of undo-stack
	BufCapacity : i32, // end-user buffer capacity (include zero terminator)
	Scroll : ImVec2, // horizontal offset (managed manually) + vertical scrolling (pulled from child window's own Scroll.y)
	CursorAnim : f32, // timer for cursor blink, reset on every user action so the cursor reappears immediately
	CursorFollow : bool, // set when we want scrolling to follow the current cursor position (not always!)
	SelectedAllMouseLock : bool, // after a double-click to select all, we ignore further mouse drags to update selection
	Edited : bool, // edited this frame
	WantReloadUserBuf : bool, // force a reload of user buf so it may be modified externally. may be automatic in future version.
	ReloadSelectionStart : i32,
	ReloadSelectionEnd : i32,
}

ImGuiInputTextState_ClearText :: proc(this : ^ImGuiInputTextState)
{
	this.TextLen = 0; this.TextA.Data[0] = 0; CursorClamp(this)
}

ImGuiInputTextState_ClearFreeMemory :: proc(this : ^ImGuiInputTextState)
{
	clear(&this.TextA); clear(&this.TextToRevertTo)
}

ImGuiWindowRefreshFlags_ :: enum i32 {
	ImGuiWindowRefreshFlags_None = 0,
	ImGuiWindowRefreshFlags_TryToAvoidRefresh = 1 << 0, // [EXPERIMENTAL] Try to keep existing contents, USER MUST NOT HONOR BEGIN() RETURNING FALSE AND NOT APPEND.
	ImGuiWindowRefreshFlags_RefreshOnHover = 1 << 1, // [EXPERIMENTAL] Always refresh on hover
	ImGuiWindowRefreshFlags_RefreshOnFocus = 1 << 2, // [EXPERIMENTAL] Always refresh on focus
	// Refresh policy/frequency, Load Balancing etc.
}

ImGuiNextWindowDataFlags_ :: enum i32 {
	ImGuiNextWindowDataFlags_None = 0,
	ImGuiNextWindowDataFlags_HasPos = 1 << 0,
	ImGuiNextWindowDataFlags_HasSize = 1 << 1,
	ImGuiNextWindowDataFlags_HasContentSize = 1 << 2,
	ImGuiNextWindowDataFlags_HasCollapsed = 1 << 3,
	ImGuiNextWindowDataFlags_HasSizeConstraint = 1 << 4,
	ImGuiNextWindowDataFlags_HasFocus = 1 << 5,
	ImGuiNextWindowDataFlags_HasBgAlpha = 1 << 6,
	ImGuiNextWindowDataFlags_HasScroll = 1 << 7,
	ImGuiNextWindowDataFlags_HasChildFlags = 1 << 8,
	ImGuiNextWindowDataFlags_HasRefreshPolicy = 1 << 9,
	ImGuiNextWindowDataFlags_HasViewport = 1 << 10,
	ImGuiNextWindowDataFlags_HasDock = 1 << 11,
	ImGuiNextWindowDataFlags_HasWindowClass = 1 << 12,
}

// Storage for SetNextWindow** functions
// Storage for SetNexWindow** functions
ImGuiNextWindowData :: struct {
	Flags : ImGuiNextWindowDataFlags,
	PosCond : ImGuiCond,
	SizeCond : ImGuiCond,
	CollapsedCond : ImGuiCond,
	DockCond : ImGuiCond,
	PosVal : ImVec2,
	PosPivotVal : ImVec2,
	SizeVal : ImVec2,
	ContentSizeVal : ImVec2,
	ScrollVal : ImVec2,
	ChildFlags : ImGuiChildFlags,
	PosUndock : bool,
	CollapsedVal : bool,
	SizeConstraintRect : ImRect,
	SizeCallback : ImGuiSizeCallback,
	SizeCallbackUserData : rawptr,
	BgAlphaVal : f32, // Override background alpha
	ViewportId : ImGuiID,
	DockId : ImGuiID,
	WindowClass : ImGuiWindowClass,
	MenuBarOffsetMinVal : ImVec2, // (Always on) This is not exposed publicly, so we don't clear it and it doesn't have a corresponding flag (could we? for consistency?)
	RefreshFlagsVal : ImGuiWindowRefreshFlags,
}

ImGuiNextWindowData_init :: proc(this : ^ImGuiNextWindowData) { this^ = {} }

ImGuiNextWindowData_ClearFlags :: #force_inline proc(this : ^ImGuiNextWindowData) { this.Flags = ImGuiNextWindowDataFlags_.ImGuiNextWindowDataFlags_None }

ImGuiNextItemDataFlags_ :: enum i32 {
	ImGuiNextItemDataFlags_None = 0,
	ImGuiNextItemDataFlags_HasWidth = 1 << 0,
	ImGuiNextItemDataFlags_HasOpen = 1 << 1,
	ImGuiNextItemDataFlags_HasShortcut = 1 << 2,
	ImGuiNextItemDataFlags_HasRefVal = 1 << 3,
	ImGuiNextItemDataFlags_HasStorageID = 1 << 4,
}

// Storage for SetNextItem** functions
ImGuiNextItemData :: struct {
	HasFlags : ImGuiNextItemDataFlags, // Called HasFlags instead of Flags to avoid mistaking this
	ItemFlags : ImGuiItemFlags, // Currently only tested/used for ImGuiItemFlags_AllowOverlap and ImGuiItemFlags_HasSelectionUserData.
	// Non-flags members are NOT cleared by ItemAdd() meaning they are still valid during NavProcessItem()
	FocusScopeId : ImGuiID, // Set by SetNextItemSelectionUserData()
	SelectionUserData : ImGuiSelectionUserData, // Set by SetNextItemSelectionUserData() (note that NULL/0 is a valid value, we use -1 == ImGuiSelectionUserData_Invalid to mark invalid values)
	Width : f32, // Set by SetNextItemWidth()
	Shortcut : ImGuiKeyChord, // Set by SetNextItemShortcut()
	ShortcutFlags : ImGuiInputFlags, // Set by SetNextItemShortcut()
	OpenVal : bool, // Set by SetNextItemOpen()
	OpenCond : ImU8, // Set by SetNextItemOpen()
	RefVal : ImGuiDataTypeStorage, // Not exposed yet, for ImGuiInputTextFlags_ParseEmptyAsRefVal
	StorageId : ImGuiID, // Set by SetNextItemStorageID()
}

ImGuiNextItemData_init :: proc(this : ^ImGuiNextItemData)
{
	this^ = {}; this.SelectionUserData = -1
}

// Also cleared manually by ItemAdd()!
ImGuiNextItemData_ClearFlags :: #force_inline proc(this : ^ImGuiNextItemData)
{
	this.HasFlags = ImGuiNextItemDataFlags_.ImGuiNextItemDataFlags_None; this.ItemFlags = ImGuiItemFlags_.ImGuiItemFlags_None
}

// Status storage for last submitted items
// Status storage for the last submitted item
ImGuiLastItemData :: struct {
	ID : ImGuiID,
	ItemFlags : ImGuiItemFlags, // See ImGuiItemFlags_
	StatusFlags : ImGuiItemStatusFlags, // See ImGuiItemStatusFlags_
	Rect : ImRect, // Full rectangle
	NavRect : ImRect, // Navigation scoring rectangle (not displayed)
	// Rarely used fields are not explicitly cleared, only valid when the corresponding ImGuiItemStatusFlags ar set.
	DisplayRect : ImRect, // Display rectangle. ONLY VALID IF (StatusFlags & ImGuiItemStatusFlags_HasDisplayRect) is set.
	ClipRect : ImRect, // Clip rectangle at the time of submitting item. ONLY VALID IF (StatusFlags & ImGuiItemStatusFlags_HasClipRect) is set..
	Shortcut : ImGuiKeyChord, // Shortcut at the time of submitting item. ONLY VALID IF (StatusFlags & ImGuiItemStatusFlags_HasShortcut) is set..
}

// Temporary storage for TreeNode().
// Store data emitted by TreeNode() for usage by TreePop()
// - To implement ImGuiTreeNodeFlags_NavLeftJumpsBackHere: store the minimum amount of data
//   which we can't infer in TreePop(), to perform the equivalent of NavApplyItemToResult().
//   Only stored when the node is a potential candidate for landing on a Left arrow jump.
ImGuiTreeNodeStackData :: struct {
	ID : ImGuiID,
	TreeFlags : ImGuiTreeNodeFlags,
	ItemFlags : ImGuiItemFlags, // Used for nav landing
	NavRect : ImRect, // Used for nav landing
}

// Storage of stack sizes for error handling and recovery
// sizeof() = 20
ImGuiErrorRecoveryState :: struct {
	SizeOfWindowStack : i16,
	SizeOfIDStack : i16,
	SizeOfTreeStack : i16,
	SizeOfColorStack : i16,
	SizeOfStyleVarStack : i16,
	SizeOfFontStack : i16,
	SizeOfFocusScopeStack : i16,
	SizeOfGroupStack : i16,
	SizeOfItemFlagsStack : i16,
	SizeOfBeginPopupStack : i16,
	SizeOfDisabledStack : i16,
}

ImGuiErrorRecoveryState_init :: proc(this : ^ImGuiErrorRecoveryState) { this^ = {} }

// Data saved for each window pushed into the stack
ImGuiWindowStackData :: struct {
	Window : ^ImGuiWindow,
	ParentLastItemDataBackup : ImGuiLastItemData,
	StackSizesInBegin : ImGuiErrorRecoveryState, // Store size of various stacks for asserting
	DisabledOverrideReenable : bool, // Non-child window override disabled flag
}

ImGuiWindowStackData_init :: proc(this : ^ImGuiWindowStackData)
{
	this.ParentLastItemDataBackup = {}
	this.StackSizesInBegin = {}
}


ImGuiShrinkWidthItem :: struct {
	Index : i32,
	Width : f32,
	InitialWidth : f32,
}

ImGuiPtrOrIndex :: struct {
	Ptr : rawptr, // Either field can be set, not both. e.g. Dock node tab bars are loose while BeginTabBar() ones are in a pool.
	Index : i32, // Usually index in a main pool.
}

ImGuiPtrOrIndex_init_0 :: proc(this : ^ImGuiPtrOrIndex, ptr : rawptr)
{
	this.Ptr = ptr; this.Index = -1
}

ImGuiPtrOrIndex_init_1 :: proc(this : ^ImGuiPtrOrIndex, index : i32)
{
	this.Ptr = nil; this.Index = index
}

//-----------------------------------------------------------------------------
// [SECTION] Popup support
//-----------------------------------------------------------------------------

ImGuiPopupPositionPolicy :: enum i32 {
	ImGuiPopupPositionPolicy_Default,
	ImGuiPopupPositionPolicy_ComboBox,
	ImGuiPopupPositionPolicy_Tooltip,
}

// Storage for current popup stack
// Storage for popup stacks (g.OpenPopupStack and g.BeginPopupStack)
ImGuiPopupData :: struct {
	PopupId : ImGuiID, // Set on OpenPopup()
	Window : ^ImGuiWindow, // Resolved on BeginPopup() - may stay unresolved if user never calls OpenPopup()
	RestoreNavWindow : ^ImGuiWindow, // Set on OpenPopup(), a NavWindow that will be restored on popup close
	ParentNavLayer : ImGuiNavLayer, // Resolved on BeginPopup(). Actually a ImGuiNavLayer type (declared down below), initialized to -1 which is not part of an enum, but serves well-enough as "not any of layers" value
	OpenFrameCount : i32, // Set on OpenPopup()
	OpenParentId : ImGuiID, // Set on OpenPopup(), we need this to differentiate multiple menu sets from each others (e.g. inside menu bar vs loose menu items)
	OpenPopupPos : ImVec2, // Set on OpenPopup(), preferred popup position (typically == OpenMousePos when using mouse)
	OpenMousePos : ImVec2, // Set on OpenPopup(), copy of mouse position at the time of opening popup
}

ImGuiPopupData_init :: proc(this : ^ImGuiPopupData)
{
	this^ = {}; this.OpenFrameCount = -1; this.ParentNavLayer = ImGuiNavLayer(this.OpenFrameCount)
}

//-----------------------------------------------------------------------------
// [SECTION] Inputs support
//-----------------------------------------------------------------------------

// Bit array for named keys
ImBitArrayForNamedKeys :: ImBitArray(u32(ImGuiKey.ImGuiKey_NamedKey_COUNT), -i32(ImGuiKey.ImGuiKey_NamedKey_BEGIN))

// [Internal] Key ranges
ImGuiKey_LegacyNativeKey_BEGIN :: ImGuiKey(0)
ImGuiKey_LegacyNativeKey_END :: ImGuiKey(512)
ImGuiKey_Keyboard_BEGIN :: ImGuiKey.ImGuiKey_NamedKey_BEGIN
ImGuiKey_Keyboard_END   :: ImGuiKey.ImGuiKey_GamepadStart
ImGuiKey_Gamepad_BEGIN  :: ImGuiKey.ImGuiKey_GamepadStart
ImGuiKey_Gamepad_END    :: ImGuiKey(i32(ImGuiKey.ImGuiKey_GamepadRStickDown) + 1)
ImGuiKey_Mouse_BEGIN    :: ImGuiKey.ImGuiKey_MouseLeft
ImGuiKey_Mouse_END      :: ImGuiKey(i32(ImGuiKey.ImGuiKey_MouseWheelY) + 1)
ImGuiKey_Aliases_BEGIN  :: ImGuiKey_Mouse_BEGIN
ImGuiKey_Aliases_END    :: ImGuiKey_Mouse_END

// [Internal] Named shortcuts for Navigation
ImGuiKey_NavKeyboardTweakSlow :: ImGuiKey.ImGuiMod_Ctrl
ImGuiKey_NavKeyboardTweakFast :: ImGuiKey.ImGuiMod_Shift
ImGuiKey_NavGamepadTweakSlow  :: ImGuiKey.ImGuiKey_GamepadL1
ImGuiKey_NavGamepadTweakFast  :: ImGuiKey.ImGuiKey_GamepadR1
ImGuiKey_NavGamepadActivate   :: #force_inline proc "contextless" (g : ^ImGuiContext) -> ImGuiKey { return g.IO.ConfigNavSwapGamepadButtons ? ImGuiKey.ImGuiKey_GamepadFaceRight : ImGuiKey.ImGuiKey_GamepadFaceDown }
ImGuiKey_NavGamepadCancel     :: #force_inline proc "contextless" (g : ^ImGuiContext) -> ImGuiKey { return g.IO.ConfigNavSwapGamepadButtons ? ImGuiKey.ImGuiKey_GamepadFaceDown  : ImGuiKey.ImGuiKey_GamepadFaceRight }
ImGuiKey_NavGamepadMenu       :: ImGuiKey.ImGuiKey_GamepadFaceLeft
ImGuiKey_NavGamepadInput      :: ImGuiKey.ImGuiKey_GamepadFaceUp

ImGuiInputEventType :: enum i32 {
	ImGuiInputEventType_None = 0,
	ImGuiInputEventType_MousePos,
	ImGuiInputEventType_MouseWheel,
	ImGuiInputEventType_MouseButton,
	ImGuiInputEventType_MouseViewport,
	ImGuiInputEventType_Key,
	ImGuiInputEventType_Text,
	ImGuiInputEventType_Focus,
	ImGuiInputEventType_COUNT,
}

ImGuiInputSource :: enum i32 {
	ImGuiInputSource_None = 0,
	ImGuiInputEventType_Mouse, // Note: may be Mouse or TouchScreen or Pen. See io.MouseSource to distinguish them.
	ImGuiInputSource_Keyboard,
	ImGuiInputSource_Gamepad,
	ImGuiInputSource_COUNT,
}

// FIXME: Structures in the union below need to be declared as anonymous unions appears to be an extension?
// Using ImVec2{} would fail on Clang 'union member 'MousePos' has a non-trivial default constructor'
ImGuiInputEventMousePos :: struct { PosX : f32, PosY : f32, MouseSource : ImGuiMouseSource, }
ImGuiInputEventMouseWheel :: struct { WheelX : f32, WheelY : f32, MouseSource : ImGuiMouseSource, }
ImGuiInputEventMouseButton :: struct { Button : ImGuiMouseButton, Down : bool, MouseSource : ImGuiMouseSource, }
ImGuiInputEventMouseViewport :: struct { HoveredViewportID : ImGuiID, }
ImGuiInputEventKey :: struct { Key : ImGuiKey, Down : bool, AnalogValue : f32, }
ImGuiInputEventText :: struct { Char : u32, }
ImGuiInputEventAppFocused :: struct { Focused : bool, }

ImGuiInputEvent :: struct {
	Type : ImGuiInputEventType,
	Source : ImGuiInputSource,
	EventId : ImU32, // Unique, sequential increasing integer to identify an event (if you need to correlate them to other data).
	using _0 : struct #raw_union {
		MousePos : ImGuiInputEventMousePos, // if Type == ImGuiInputEventType_MousePos
		MouseWheel : ImGuiInputEventMouseWheel, // if Type == ImGuiInputEventType_MouseWheel
		MouseButton : ImGuiInputEventMouseButton, // if Type ==ImGuiInputEventType_MouseButton
		MouseViewport : ImGuiInputEventMouseViewport, // if Type == ImGuiInputEventType_MouseViewport
		Key : ImGuiInputEventKey, // if Type == ImGuiInputEventType_Key
		Text : ImGuiInputEventText, // if Type == ImGuiInputEventType_Text
		AppFocused : ImGuiInputEventAppFocused, // if Type == ImGuiInputEventType_Focus
	},
	AddedByTestEngine : bool,
}

ImGuiInputEvent_init :: proc(this : ^ImGuiInputEvent) { this^ = {} }

// Input function taking an 'ImGuiID owner_id' argument defaults to (ImGuiKeyOwner_Any == 0) aka don't test ownership, which matches legacy behavior.
ImGuiKeyOwner_Any :: (ImGuiID(0))// Accept key that have an owner, UNLESS a call to SetKeyOwner() explicitly used ImGuiInputFlags_LockThisFrame or ImGuiInputFlags_LockUntilRelease.
ImGuiKeyOwner_NoOwner :: (transmute(ImGuiID)i32(-1))// Require key to have no owner.
//#define ImGuiKeyOwner_None ImGuiKeyOwner_NoOwner  // We previously called this 'ImGuiKeyOwner_None' but it was inconsistent with our pattern that _None values == 0 and quite dangerous. Also using _NoOwner makes the IsKeyPressed() calls more explicit.

ImGuiKeyRoutingIndex :: ImS16

// Routing table entry (sizeof() == 16 bytes)
ImGuiKeyRoutingData :: struct {
	NextEntryIndex : ImGuiKeyRoutingIndex,
	Mods : ImU16, // Technically we'd only need 4-bits but for simplify we store ImGuiMod_ values which need 16-bits.
	RoutingCurrScore : ImU8, // [DEBUG] For debug display
	RoutingNextScore : ImU8, // Lower is better (0: perfect score)
	RoutingCurr : ImGuiID,
	RoutingNext : ImGuiID,
}

ImGuiKeyRoutingData_init :: proc(this : ^ImGuiKeyRoutingData)
{
	this.NextEntryIndex = -1; this.Mods = 0; this.RoutingNextScore = 255; this.RoutingCurrScore = this.RoutingNextScore; this.RoutingNext = ImGuiKeyOwner_NoOwner; this.RoutingCurr = this.RoutingNext
}

// Routing table: maintain a desired owner for each possible key-chord (key + mods), and setup owner in NewFrame() when mods are matching.
// Stored in main context (1 instance)
ImGuiKeyRoutingTable :: struct {
	Index : [ImGuiKey.ImGuiKey_NamedKey_COUNT]ImGuiKeyRoutingIndex, // Index of first entry in Entries[]
	Entries : ImVector(ImGuiKeyRoutingData),
	EntriesNext : ImVector(ImGuiKeyRoutingData), // Double-buffer to avoid reallocation (could use a shared buffer)
}

ImGuiKeyRoutingTable_deinit :: proc(this : ^ImGuiKeyRoutingTable)
{
	deinit(&this.Entries)
	deinit(&this.EntriesNext)
}

ImGuiKeyRoutingTable_init :: proc(this : ^ImGuiKeyRoutingTable)
{
	init(&this.Entries)
	init(&this.EntriesNext)
	Clear(this)
}

ImGuiKeyRoutingTable_Clear :: proc(this : ^ImGuiKeyRoutingTable)
{
	for n := 0; n < IM_ARRAYSIZE(this.Index); n += 1 { this.Index[n] = -1 }
	clear(&this.Entries)
	clear(&this.EntriesNext)
}

// This extends ImGuiKeyData but only for named keys (legacy keys don't support the new features)
// Stored in main context (1 per named key). In the future it might be merged into ImGuiKeyData.
ImGuiKeyOwnerData :: struct {
	OwnerCurr : ImGuiID,
	OwnerNext : ImGuiID,
	LockThisFrame : bool, // Reading this key requires explicit owner id (until end of frame). Set by ImGuiInputFlags_LockThisFrame.
	LockUntilRelease : bool, // Reading this key requires explicit owner id (until key is released). Set by ImGuiInputFlags_LockUntilRelease. When this is true LockThisFrame is always true as well.
}

ImGuiKeyOwnerData_init :: proc(this : ^ImGuiKeyOwnerData)
{
	this.OwnerNext = ImGuiKeyOwner_NoOwner; this.OwnerCurr = this.OwnerNext; this.LockUntilRelease = false; this.LockThisFrame = this.LockUntilRelease
}

// Extend ImGuiInputFlags_
// Flags for extended versions of IsKeyPressed(), IsMouseClicked(), Shortcut(), SetKeyOwner(), SetItemKeyOwner()
// Don't mistake with ImGuiInputTextFlags! (which is for ImGui::InputText() function)
ImGuiInputFlagsPrivate_ :: enum i32 {
	// Flags for IsKeyPressed(), IsKeyChordPressed(), IsMouseClicked(), Shortcut()
	// - Repeat mode: Repeat rate selection
	ImGuiInputFlags_RepeatRateDefault = 1 << 1, // Repeat rate: Regular (default)
	ImGuiInputFlags_RepeatRateNavMove = 1 << 2, // Repeat rate: Fast
	ImGuiInputFlags_RepeatRateNavTweak = 1 << 3, // Repeat rate: Faster
	// - Repeat mode: Specify when repeating key pressed can be interrupted.
	// - In theory ImGuiInputFlags_RepeatUntilOtherKeyPress may be a desirable default, but it would break too many behavior so everything is opt-in.
	ImGuiInputFlags_RepeatUntilRelease = 1 << 4, // Stop repeating when released (default for all functions except Shortcut). This only exists to allow overriding Shortcut() default behavior.
	ImGuiInputFlags_RepeatUntilKeyModsChange = 1 << 5, // Stop repeating when released OR if keyboard mods are changed (default for Shortcut)
	ImGuiInputFlags_RepeatUntilKeyModsChangeFromNone = 1 << 6, // Stop repeating when released OR if keyboard mods are leaving the None state. Allows going from Mod+Key to Key by releasing Mod.
	ImGuiInputFlags_RepeatUntilOtherKeyPress = 1 << 7, // Stop repeating when released OR if any other keyboard key is pressed during the repeat

	// Flags for SetKeyOwner(), SetItemKeyOwner()
	// - Locking key away from non-input aware code. Locking is useful to make input-owner-aware code steal keys from non-input-owner-aware code. If all code is input-owner-aware locking would never be necessary.
	ImGuiInputFlags_LockThisFrame = 1 << 20, // Further accesses to key data will require EXPLICIT owner ID (ImGuiKeyOwner_Any/0 will NOT accepted for polling). Cleared at end of frame.
	ImGuiInputFlags_LockUntilRelease = 1 << 21, // Further accesses to key data will require EXPLICIT owner ID (ImGuiKeyOwner_Any/0 will NOT accepted for polling). Cleared when the key is released or at end of each frame if key is released.

	// - Condition for SetItemKeyOwner()
	ImGuiInputFlags_CondHovered = 1 << 22, // Only set if item is hovered (default to both)
	ImGuiInputFlags_CondActive = 1 << 23, // Only set if item is active (default to both)
	ImGuiInputFlags_CondDefault_ = ImGuiInputFlags_CondHovered | ImGuiInputFlags_CondActive,

	// [Internal] Mask of which function support which flags
	ImGuiInputFlags_RepeatRateMask_ = ImGuiInputFlags_RepeatRateDefault | ImGuiInputFlags_RepeatRateNavMove | ImGuiInputFlags_RepeatRateNavTweak,
	ImGuiInputFlags_RepeatUntilMask_ = ImGuiInputFlags_RepeatUntilRelease | ImGuiInputFlags_RepeatUntilKeyModsChange | ImGuiInputFlags_RepeatUntilKeyModsChangeFromNone | ImGuiInputFlags_RepeatUntilOtherKeyPress,
	ImGuiInputFlags_RepeatMask_ = i32(ImGuiInputFlags_.ImGuiInputFlags_Repeat) | i32(ImGuiInputFlags_RepeatRateMask_ | ImGuiInputFlags_RepeatUntilMask_),
	ImGuiInputFlags_CondMask_ = ImGuiInputFlags_CondHovered | ImGuiInputFlags_CondActive,
	ImGuiInputFlags_RouteTypeMask_ = i32(ImGuiInputFlags_.ImGuiInputFlags_RouteActive | ImGuiInputFlags_.ImGuiInputFlags_RouteFocused | ImGuiInputFlags_.ImGuiInputFlags_RouteGlobal | ImGuiInputFlags_.ImGuiInputFlags_RouteAlways),
	ImGuiInputFlags_RouteOptionsMask_ = i32(ImGuiInputFlags_.ImGuiInputFlags_RouteOverFocused | ImGuiInputFlags_.ImGuiInputFlags_RouteOverActive | ImGuiInputFlags_.ImGuiInputFlags_RouteUnlessBgFocused | ImGuiInputFlags_.ImGuiInputFlags_RouteFromRootWindow),
	ImGuiInputFlags_SupportedByIsKeyPressed = ImGuiInputFlags_RepeatMask_,
	ImGuiInputFlags_SupportedByIsMouseClicked = i32(ImGuiInputFlags_.ImGuiInputFlags_Repeat),
	ImGuiInputFlags_SupportedByShortcut = ImGuiInputFlags_RepeatMask_ | ImGuiInputFlags_RouteTypeMask_ | ImGuiInputFlags_RouteOptionsMask_,
	ImGuiInputFlags_SupportedBySetNextItemShortcut = i32(ImGuiInputFlags_RepeatMask_ | ImGuiInputFlags_RouteTypeMask_ | ImGuiInputFlags_RouteOptionsMask_) | i32(ImGuiInputFlags_.ImGuiInputFlags_Tooltip),
	ImGuiInputFlags_SupportedBySetKeyOwner = ImGuiInputFlags_LockThisFrame | ImGuiInputFlags_LockUntilRelease,
	ImGuiInputFlags_SupportedBySetItemKeyOwner = ImGuiInputFlags_SupportedBySetKeyOwner | ImGuiInputFlags_CondMask_,
}

//-----------------------------------------------------------------------------
// [SECTION] Clipper support
//-----------------------------------------------------------------------------

// Note that Max is exclusive, so perhaps should be using a Begin/End convention.
ImGuiListClipperRange :: struct {
	Min : i32,
	Max : i32,
	PosToIndexConvert : bool, // Begin/End are absolute position (will be converted to indices later)
	PosToIndexOffsetMin : ImS8, // Add to Min after converting to indices
	PosToIndexOffsetMax : ImS8, // Add to Min after converting to indices
}

ImGuiListClipperRange_FromIndices :: proc(min : i32, max : i32) -> ImGuiListClipperRange
{
	r : ImGuiListClipperRange = {min, max, false, 0, 0}; return r
}

ImGuiListClipperRange_FromPositions :: proc(y1 : f32, y2 : f32, off_min : i32, off_max : i32) -> ImGuiListClipperRange
{
	r : ImGuiListClipperRange = {cast(i32) y1, cast(i32) y2, true, cast(ImS8) off_min, cast(ImS8) off_max}; return r
}

// Temporary clipper data, buffers shared/reused between instances
ImGuiListClipperData :: struct {
	ListClipper : ^ImGuiListClipper,
	LossynessOffset : f32,
	StepNo : i32,
	ItemsFrozen : i32,
	Ranges : ImVector(ImGuiListClipperRange),
}

ImGuiListClipperData_deinit :: proc(this : ^ImGuiListClipperData) { deinit(&this.Ranges) }

ImGuiListClipperData_init :: proc(this : ^ImGuiListClipperData) { this^ = {} }

ImGuiListClipperData_Reset :: proc(this : ^ImGuiListClipperData, clipper : ^ImGuiListClipper)
{
	this.ListClipper = clipper; this.ItemsFrozen = 0; this.StepNo = this.ItemsFrozen; resize(&this.Ranges, 0)
}

//-----------------------------------------------------------------------------
// [SECTION] Navigation support
//-----------------------------------------------------------------------------

ImGuiActivateFlags_ :: enum i32 {
	ImGuiActivateFlags_None = 0,
	ImGuiActivateFlags_PreferInput = 1 << 0, // Favor activation that requires keyboard text input (e.g. for Slider/Drag). Default for Enter key.
	ImGuiActivateFlags_PreferTweak = 1 << 1, // Favor activation for tweaking with arrows or gamepad (e.g. for Slider/Drag). Default for Space key and if keyboard is not used.
	ImGuiActivateFlags_TryToPreserveState = 1 << 2, // Request widget to preserve state if it can (e.g. InputText will try to preserve cursor/selection)
	ImGuiActivateFlags_FromTabbing = 1 << 3, // Activation requested by a tabbing request
	ImGuiActivateFlags_FromShortcut = 1 << 4, // Activation requested by an item shortcut via SetNextItemShortcut() function.
}

// Early work-in-progress API for ScrollToItem()
ImGuiScrollFlags_ :: enum i32 {
	ImGuiScrollFlags_None = 0,
	ImGuiScrollFlags_KeepVisibleEdgeX = 1 << 0, // If item is not visible: scroll as little as possible on X axis to bring item back into view [default for X axis]
	ImGuiScrollFlags_KeepVisibleEdgeY = 1 << 1, // If item is not visible: scroll as little as possible on Y axis to bring item back into view [default for Y axis for windows that are already visible]
	ImGuiScrollFlags_KeepVisibleCenterX = 1 << 2, // If item is not visible: scroll to make the item centered on X axis [rarely used]
	ImGuiScrollFlags_KeepVisibleCenterY = 1 << 3, // If item is not visible: scroll to make the item centered on Y axis
	ImGuiScrollFlags_AlwaysCenterX = 1 << 4, // Always center the result item on X axis [rarely used]
	ImGuiScrollFlags_AlwaysCenterY = 1 << 5, // Always center the result item on Y axis [default for Y axis for appearing window)
	ImGuiScrollFlags_NoScrollParent = 1 << 6, // Disable forwarding scrolling to parent window if required to keep item/rect visible (only scroll window the function was applied to).
	ImGuiScrollFlags_MaskX_ = ImGuiScrollFlags_KeepVisibleEdgeX | ImGuiScrollFlags_KeepVisibleCenterX | ImGuiScrollFlags_AlwaysCenterX,
	ImGuiScrollFlags_MaskY_ = ImGuiScrollFlags_KeepVisibleEdgeY | ImGuiScrollFlags_KeepVisibleCenterY | ImGuiScrollFlags_AlwaysCenterY,
}

ImGuiNavRenderCursorFlags_ :: enum i32 {
	ImGuiNavRenderCursorFlags_None = 0,
	ImGuiNavRenderCursorFlags_Compact = 1 << 1, // Compact highlight, no padding/distance from focused item
	ImGuiNavRenderCursorFlags_AlwaysDraw = 1 << 2, // Draw rectangular highlight if (g.NavId == id) even when g.NavCursorVisible == false, aka even when using the mouse.
	ImGuiNavRenderCursorFlags_NoRounding = 1 << 3,
}

ImGuiNavMoveFlags_ :: enum i32 {
	ImGuiNavMoveFlags_None = 0,
	ImGuiNavMoveFlags_LoopX = 1 << 0, // On failed request, restart from opposite side
	ImGuiNavMoveFlags_LoopY = 1 << 1,
	ImGuiNavMoveFlags_WrapX = 1 << 2, // On failed request, request from opposite side one line down (when NavDir==right) or one line up (when NavDir==left)
	ImGuiNavMoveFlags_WrapY = 1 << 3, // This is not super useful but provided for completeness
	ImGuiNavMoveFlags_WrapMask_ = ImGuiNavMoveFlags_LoopX | ImGuiNavMoveFlags_LoopY | ImGuiNavMoveFlags_WrapX | ImGuiNavMoveFlags_WrapY,
	ImGuiNavMoveFlags_AllowCurrentNavId = 1 << 4, // Allow scoring and considering the current NavId as a move target candidate. This is used when the move source is offset (e.g. pressing PageDown actually needs to send a Up move request, if we are pressing PageDown from the bottom-most item we need to stay in place)
	ImGuiNavMoveFlags_AlsoScoreVisibleSet = 1 << 5, // Store alternate result in NavMoveResultLocalVisible that only comprise elements that are already fully visible (used by PageUp/PageDown)
	ImGuiNavMoveFlags_ScrollToEdgeY = 1 << 6, // Force scrolling to min/max (used by Home/End) // FIXME-NAV: Aim to remove or reword, probably unnecessary
	ImGuiNavMoveFlags_Forwarded = 1 << 7,
	ImGuiNavMoveFlags_DebugNoResult = 1 << 8, // Dummy scoring for debug purpose, don't apply result
	ImGuiNavMoveFlags_FocusApi = 1 << 9, // Requests from focus API can land/focus/activate items even if they are marked with _NoTabStop (see NavProcessItemForTabbingRequest() for details)
	ImGuiNavMoveFlags_IsTabbing = 1 << 10, // == Focus + Activate if item is Inputable + DontChangeNavHighlight
	ImGuiNavMoveFlags_IsPageMove = 1 << 11, // Identify a PageDown/PageUp request.
	ImGuiNavMoveFlags_Activate = 1 << 12, // Activate/select target item.
	ImGuiNavMoveFlags_NoSelect = 1 << 13, // Don't trigger selection by not setting g.NavJustMovedTo
	ImGuiNavMoveFlags_NoSetNavCursorVisible = 1 << 14, // Do not alter the nav cursor visible state
	ImGuiNavMoveFlags_NoClearActiveId = 1 << 15, // (Experimental) Do not clear active id when applying move result
}

ImGuiNavLayer :: enum i32 {
	ImGuiNavLayer_Main = 0, // Main scrolling layer
	ImGuiNavLayer_Menu = 1, // Menu layer (access with Alt)
	ImGuiNavLayer_COUNT,
}

// Result of a keyboard/gamepad directional navigation move query result
// Storage for navigation query/results
ImGuiNavItemData :: struct {
	Window : ^ImGuiWindow, // Init,Move    // Best candidate window (result->ItemWindow->RootWindowForNav == request->Window)
	ID : ImGuiID, // Init,Move    // Best candidate item ID
	FocusScopeId : ImGuiID, // Init,Move    // Best candidate focus scope ID
	RectRel : ImRect, // Init,Move    // Best candidate bounding box in window relative space
	ItemFlags : ImGuiItemFlags, // ????,Move    // Best candidate item flags
	DistBox : f32, //      Move    // Best candidate box distance to current NavId
	DistCenter : f32, //      Move    // Best candidate center distance to current NavId
	DistAxial : f32, //      Move    // Best candidate axial distance to current NavId
	SelectionUserData : ImGuiSelectionUserData, //I+Mov    // Best candidate SetNextItemSelectionUserData() value. Valid if (ItemFlags & ImGuiItemFlags_HasSelectionUserData)
}

ImGuiNavItemData_init :: proc(this : ^ImGuiNavItemData) { Clear(this) }

ImGuiNavItemData_Clear :: proc(this : ^ImGuiNavItemData)
{
	this.Window = nil; this.FocusScopeId = 0; this.ID = this.FocusScopeId; this.ItemFlags = {}; this.SelectionUserData = -1; this.DistAxial = FLT_MAX; this.DistCenter = this.DistAxial; this.DistBox = this.DistCenter
}

// Storage for PushFocusScope(), g.FocusScopeStack[], g.NavFocusRoute.Data[]
ImGuiFocusScopeData :: struct {
	ID : ImGuiID,
	WindowID : ImGuiID,
}

//-----------------------------------------------------------------------------
// [SECTION] Typing-select support
//-----------------------------------------------------------------------------

// Flags for GetTypingSelectRequest()
ImGuiTypingSelectFlags_ :: enum i32 {
	ImGuiTypingSelectFlags_None = 0,
	ImGuiTypingSelectFlags_AllowBackspace = 1 << 0, // Backspace to delete character inputs. If using: ensure GetTypingSelectRequest() is not called more than once per frame (filter by e.g. focus state)
	ImGuiTypingSelectFlags_AllowSingleCharMode = 1 << 1, // Allow "single char" search mode which is activated when pressing the same character multiple times.
}

// Storage for GetTypingSelectRequest() (aimed to be public)
// Returned by GetTypingSelectRequest(), designed to eventually be public.
ImGuiTypingSelectRequest :: struct {
	Flags : ImGuiTypingSelectFlags, // Flags passed to GetTypingSelectRequest()
	SearchBufferLen : i32,
	SearchBuffer : [^]u8, // Search buffer contents (use full string. unless SingleCharMode is set, in which case use SingleCharSize).
	SelectRequest : bool, // Set when buffer was modified this frame, requesting a selection.
	SingleCharMode : bool, // Notify when buffer contains same character repeated, to implement special mode. In this situation it preferred to not display any on-screen search indication.
	SingleCharSize : ImS8, // Length in bytes of first letter codepoint (1 for ascii, 2-4 for UTF-8). If (SearchBufferLen==RepeatCharSize) only 1 letter has been input.
}

// Storage for GetTypingSelectRequest()
// Storage for GetTypingSelectRequest()
ImGuiTypingSelectState :: struct {
	Request : ImGuiTypingSelectRequest, // User-facing data
	SearchBuffer : [64]u8, // Search buffer: no need to make dynamic as this search is very transient.
	FocusScope : ImGuiID,
	LastRequestFrame : i32,
	LastRequestTime : f32,
	SingleCharModeLock : bool, // After a certain single char repeat count we lock into SingleCharMode. Two benefits: 1) buffer never fill, 2) we can provide an immediate SingleChar mode without timer elapsing.
}

ImGuiTypingSelectState_init :: proc(this : ^ImGuiTypingSelectState)
{
this.LastRequestFrame = 0
this.LastRequestTime = 0.0
this.SingleCharModeLock = false
this^ = {}
}

// We preserve remaining data for easier debugging
ImGuiTypingSelectState_Clear :: proc(this : ^ImGuiTypingSelectState)
{
	this.SearchBuffer[0] = 0; this.SingleCharModeLock = false
}

//-----------------------------------------------------------------------------
// [SECTION] Columns support
//-----------------------------------------------------------------------------

// Flags for internal's BeginColumns(). This is an obsolete API. Prefer using BeginTable() nowadays!
ImGuiOldColumnFlags_ :: enum i32 {
	ImGuiOldColumnFlags_None = 0,
	ImGuiOldColumnFlags_NoBorder = 1 << 0, // Disable column dividers
	ImGuiOldColumnFlags_NoResize = 1 << 1, // Disable resizing columns when clicking on the dividers
	ImGuiOldColumnFlags_NoPreserveWidths = 1 << 2, // Disable column width preservation when adjusting columns
	ImGuiOldColumnFlags_NoForceWithinWindow = 1 << 3, // Disable forcing columns to fit within window
	ImGuiOldColumnFlags_GrowParentContentsSize = 1 << 4, // Restore pre-1.51 behavior of extending the parent window contents size but _without affecting the columns width at all_. Will eventually remove.
}

// Storage data for a single column for legacy Columns() api
ImGuiOldColumnData :: struct {
	OffsetNorm : f32, // Column start offset, normalized 0.0 (far left) -> 1.0 (far right)
	OffsetNormBeforeResize : f32,
	Flags : ImGuiOldColumnFlags, // Not exposed
	ClipRect : ImRect,
}

// Storage data for a columns set for legacy Columns() api
ImGuiOldColumns :: struct {
	ID : ImGuiID,
	Flags : ImGuiOldColumnFlags,
	IsFirstFrame : bool,
	IsBeingResized : bool,
	Current : i32,
	Count : i32,
	OffMinX : f32, OffMaxX : f32, // Offsets from HostWorkRect.Min.x
	LineMinY : f32, LineMaxY : f32,
	HostCursorPosY : f32, // Backup of CursorPos at the time of BeginColumns()
	HostCursorMaxPosX : f32, // Backup of CursorMaxPos at the time of BeginColumns()
	HostInitialClipRect : ImRect, // Backup of ClipRect at the time of BeginColumns()
	HostBackupClipRect : ImRect, // Backup of ClipRect during PushColumnsBackground()/PopColumnsBackground()
	HostBackupParentWorkRect : ImRect, //Backup of WorkRect at the time of BeginColumns()
	Columns : ImVector(ImGuiOldColumnData),
	Splitter : ImDrawListSplitter,
}

ImGuiOldColumns_deinit :: proc(this : ^ImGuiOldColumns)
{
	deinit(&this.Columns)
	deinit(&this.Splitter)
}

ImGuiOldColumns_init :: proc(this : ^ImGuiOldColumns)
{
	this.HostInitialClipRect = {}
	this.HostBackupClipRect = {}
	this.HostBackupParentWorkRect = {}
	init(&this.Columns)
	init(&this.Splitter)
	this^ = {}
}

// Box-selection state (currently used by multi-selection, could potentially be used by others)
//-----------------------------------------------------------------------------
// [SECTION] Box-select support
//-----------------------------------------------------------------------------

ImGuiBoxSelectState :: struct {
	// Active box-selection data (persistent, 1 active at a time)
	ID : ImGuiID,
	IsActive : bool,
	IsStarting : bool,
	IsStartedFromVoid : bool, // Starting click was not from an item.
	IsStartedSetNavIdOnce : bool,
	RequestClear : bool,
	using _0 : bit_field u16 {
		KeyMods : ImGuiKeyChord | 16, // Latched key-mods for box-select logic.
	},
	StartPosRel : ImVec2, // Start position in window-contents relative space (to support scrolling)
	EndPosRel : ImVec2, // End position in window-contents relative space
	ScrollAccum : ImVec2, // Scrolling accumulator (to behave at high-frame spaces)
	Window : ^ImGuiWindow,

	// Temporary/Transient data
	UnclipMode : bool, // (Temp/Transient, here in hot area). Set/cleared by the BeginMultiSelect()/EndMultiSelect() owning active box-select.
	UnclipRect : ImRect, // Rectangle where ItemAdd() clipping may be temporarily disabled. Need support by multi-select supporting widgets.
	BoxSelectRectPrev : ImRect, // Selection rectangle in absolute coordinates (derived every frame from BoxSelectStartPosRel and MousePos)
	BoxSelectRectCurr : ImRect,
}

//-----------------------------------------------------------------------------
// [SECTION] Multi-select support
//-----------------------------------------------------------------------------

// We always assume that -1 is an invalid value (which works for indices and pointers)
ImGuiSelectionUserData_Invalid :: cast(ImGuiSelectionUserData)(-1)

// Multi-selection temporary state (while traversing).
// Temporary storage for multi-select
ImGuiMultiSelectTempData :: struct {
	IO : ImGuiMultiSelectIO, // MUST BE FIRST FIELD. Requests are set and returned by BeginMultiSelect()/EndMultiSelect() + written to by user during the loop.
	Storage : ^ImGuiMultiSelectState,
	FocusScopeId : ImGuiID, // Copied from g.CurrentFocusScopeId (unless another selection scope was pushed manually)
	Flags : ImGuiMultiSelectFlags,
	ScopeRectMin : ImVec2,
	BackupCursorMaxPos : ImVec2,
	LastSubmittedItem : ImGuiSelectionUserData, // Copy of last submitted item data, used to merge output ranges.
	BoxSelectId : ImGuiID,
	KeyMods : ImGuiKeyChord,
	LoopRequestSetAll : ImS8, // -1: no operation, 0: clear all, 1: select all.
	IsEndIO : bool, // Set when switching IO from BeginMultiSelect() to EndMultiSelect() state.
	IsFocused : bool, // Set if currently focusing the selection scope (any item of the selection). May be used if you have custom shortcut associated to selection.
	IsKeyboardSetRange : bool, // Set by BeginMultiSelect() when using Shift+Navigation. Because scrolling may be affected we can't afford a frame of lag with Shift+Navigation.
	NavIdPassedBy : bool,
	RangeSrcPassedBy : bool, // Set by the item that matches RangeSrcItem.
	RangeDstPassedBy : bool, // Set by the item that matches NavJustMovedToId when IsSetRange is set.
}

ImGuiMultiSelectTempData_deinit :: proc(this : ^ImGuiMultiSelectTempData)
{
	deinit(&this.IO)
}

ImGuiMultiSelectTempData_init :: proc(this : ^ImGuiMultiSelectTempData)
{
	init(&this.IO)
	this.ScopeRectMin = {}
	this.BackupCursorMaxPos = {}
	Clear(this)
 }

// Zero-clear except IO as we preserve IO.Requests[] buffer allocation.
ImGuiMultiSelectTempData_Clear :: proc(this : ^ImGuiMultiSelectTempData)
{
	io_sz := size_of(this.IO); ImGuiMultiSelectTempData_ClearIO(this); memset(mem.ptr_offset(&this.IO, 1), 0, size_of(this^) - io_sz)
}

ImGuiMultiSelectTempData_ClearIO :: proc(this : ^ImGuiMultiSelectTempData)
{
	resize(&this.IO.Requests, 0); this.IO.NavIdItem = ImGuiSelectionUserData_Invalid; this.IO.RangeSrcItem = this.IO.NavIdItem; this.IO.RangeSrcReset = false; this.IO.NavIdSelected = this.IO.RangeSrcReset
}

// Multi-selection persistent state (for focused selection).
// Persistent storage for multi-select (as long as selection is alive)
ImGuiMultiSelectState :: struct {
	Window : ^ImGuiWindow,
	ID : ImGuiID,
	LastFrameActive : i32, // Last used frame-count, for GC.
	LastSelectionSize : i32, // Set by BeginMultiSelect() based on optional info provided by user. May be -1 if unknown.
	RangeSelected : ImS8, // -1 (don't have) or true/false
	NavIdSelected : ImS8, // -1 (don't have) or true/false
	RangeSrcItem : ImGuiSelectionUserData, //
	NavIdItem : ImGuiSelectionUserData, // SetNextItemSelectionUserData() value for NavId (if part of submitted items)
}

ImGuiMultiSelectState_init :: proc(this : ^ImGuiMultiSelectState)
{
	this.Window = nil; this.ID = 0; this.LastSelectionSize = 0; this.LastFrameActive = this.LastSelectionSize; this.NavIdSelected = -1; this.RangeSelected = this.NavIdSelected; this.NavIdItem = ImGuiSelectionUserData_Invalid; this.RangeSrcItem = this.NavIdItem
}

//-----------------------------------------------------------------------------
// [SECTION] Docking support
//-----------------------------------------------------------------------------

DOCKING_HOST_DRAW_CHANNEL_BG :: 0// Dock host: background fill
DOCKING_HOST_DRAW_CHANNEL_FG :: 1// Dock host: decorations and contents

when IMGUI_HAS_DOCK {

// Extend ImGuiDockNodeFlags_
ImGuiDockNodeFlagsPrivate_ :: enum i32 {
	// [Internal]
	ImGuiDockNodeFlags_DockSpace = 1 << 10, // Saved // A dockspace is a node that occupy space within an existing user window. Otherwise the node is floating and create its own window.
	ImGuiDockNodeFlags_CentralNode = 1 << 11, // Saved // The central node has 2 main properties: stay visible when empty, only use "remaining" spaces from its neighbor.
	ImGuiDockNodeFlags_NoTabBar = 1 << 12, // Saved // Tab bar is completely unavailable. No triangle in the corner to enable it back.
	ImGuiDockNodeFlags_HiddenTabBar = 1 << 13, // Saved // Tab bar is hidden, with a triangle in the corner to show it again (NB: actual tab-bar instance may be destroyed as this is only used for single-window tab bar)
	ImGuiDockNodeFlags_NoWindowMenuButton = 1 << 14, // Saved // Disable window/docking menu (that one that appears instead of the collapse button)
	ImGuiDockNodeFlags_NoCloseButton = 1 << 15, // Saved // Disable close button
	ImGuiDockNodeFlags_NoResizeX = 1 << 16, //       //
	ImGuiDockNodeFlags_NoResizeY = 1 << 17, //       //
	ImGuiDockNodeFlags_DockedWindowsInFocusRoute = 1 << 18, //       // Any docked window will be automatically be focus-route chained (window->ParentWindowForFocusRoute set to this) so Shortcut() in this window can run when any docked window is focused.

	// Disable docking/undocking actions in this dockspace or individual node (existing docked nodes will be preserved)
	// Those are not exposed in public because the desirable sharing/inheriting/copy-flag-on-split behaviors are quite difficult to design and understand.
	// The two public flags ImGuiDockNodeFlags_NoDockingOverCentralNode/ImGuiDockNodeFlags_NoDockingSplit don't have those issues.
	ImGuiDockNodeFlags_NoDockingSplitOther = 1 << 19, //       // Disable this node from splitting other windows/nodes.
	ImGuiDockNodeFlags_NoDockingOverMe = 1 << 20, //       // Disable other windows/nodes from being docked over this node.
	ImGuiDockNodeFlags_NoDockingOverOther = 1 << 21, //       // Disable this node from being docked over another window or non-empty node.
	ImGuiDockNodeFlags_NoDockingOverEmpty = 1 << 22, //       // Disable this node from being docked over an empty node (e.g. DockSpace with no other windows)
	ImGuiDockNodeFlags_NoDocking = i32(ImGuiDockNodeFlags_NoDockingOverMe | ImGuiDockNodeFlags_NoDockingOverOther | ImGuiDockNodeFlags_NoDockingOverEmpty) | i32(ImGuiDockNodeFlags_.ImGuiDockNodeFlags_NoDockingSplit) | i32(ImGuiDockNodeFlags_NoDockingSplitOther),

	// Masks
	ImGuiDockNodeFlags_SharedFlagsInheritMask_ = ~i32(0),
	ImGuiDockNodeFlags_NoResizeFlagsMask_ = cast(i32) ImGuiDockNodeFlags_.ImGuiDockNodeFlags_NoResize | i32(ImGuiDockNodeFlags_NoResizeX | ImGuiDockNodeFlags_NoResizeY),

	// When splitting, those local flags are moved to the inheriting child, never duplicated
	ImGuiDockNodeFlags_LocalFlagsTransferMask_ = cast(i32) ImGuiDockNodeFlags_.ImGuiDockNodeFlags_NoDockingSplit | i32(ImGuiDockNodeFlags_NoResizeFlagsMask_) | cast(i32) ImGuiDockNodeFlags_.ImGuiDockNodeFlags_AutoHideTabBar | i32(ImGuiDockNodeFlags_CentralNode | ImGuiDockNodeFlags_NoTabBar | ImGuiDockNodeFlags_HiddenTabBar | ImGuiDockNodeFlags_NoWindowMenuButton | ImGuiDockNodeFlags_NoCloseButton),
	ImGuiDockNodeFlags_SavedFlagsMask_ = ImGuiDockNodeFlags_NoResizeFlagsMask_ | ImGuiDockNodeFlags_DockSpace | ImGuiDockNodeFlags_CentralNode | ImGuiDockNodeFlags_NoTabBar | ImGuiDockNodeFlags_HiddenTabBar | ImGuiDockNodeFlags_NoWindowMenuButton | ImGuiDockNodeFlags_NoCloseButton,
}

// Store the source authority (dock node vs window) of a field
ImGuiDataAuthority_ :: enum i32 {
	ImGuiDataAuthority_Auto,
	ImGuiDataAuthority_DockNode,
	ImGuiDataAuthority_Window,
}

ImGuiDockNodeState :: enum i32 {
	ImGuiDockNodeState_Unknown,
	ImGuiDockNodeState_HostWindowHiddenBecauseSingleWindow,
	ImGuiDockNodeState_HostWindowHiddenBecauseWindowsAreResizing,
	ImGuiDockNodeState_HostWindowVisible,
}

// Docking system node (hold a list of Windows OR two child dock nodes)
// sizeof() 156~192
ImGuiDockNode :: struct {
	ID : ImGuiID,
	SharedFlags : ImGuiDockNodeFlags, // (Write) Flags shared by all nodes of a same dockspace hierarchy (inherited from the root node)
	LocalFlags : ImGuiDockNodeFlags, // (Write) Flags specific to this node
	LocalFlagsInWindows : ImGuiDockNodeFlags, // (Write) Flags specific to this node, applied from windows
	MergedFlags : ImGuiDockNodeFlags, // (Read)  Effective flags (== SharedFlags | LocalFlagsInNode | LocalFlagsInWindows)
	State : ImGuiDockNodeState,
	ParentNode : ^ImGuiDockNode,
	ChildNodes : [2]^ImGuiDockNode, // [Split node only] Child nodes (left/right or top/bottom). Consider switching to an array.
	Windows : ImVector(^ImGuiWindow), // Note: unordered list! Iterate TabBar->Tabs for user-order.
	TabBar : ^ImGuiTabBar,
	Pos : ImVec2, // Current position
	Size : ImVec2, // Current size
	SizeRef : ImVec2, // [Split node only] Last explicitly written-to size (overridden when using a splitter affecting the node), used to calculate Size.
	SplitAxis : ImGuiAxis, // [Split node only] Split axis (X or Y)
	WindowClass : ImGuiWindowClass, // [Root node only]
	LastBgColor : ImU32,

	HostWindow : ^ImGuiWindow,
	VisibleWindow : ^ImGuiWindow, // Generally point to window which is ID is == SelectedTabID, but when CTRL+Tabbing this can be a different window.
	CentralNode : ^ImGuiDockNode, // [Root node only] Pointer to central node.
	OnlyNodeWithWindows : ^ImGuiDockNode, // [Root node only] Set when there is a single visible node within the hierarchy.
	CountNodeWithWindows : i32, // [Root node only]
	LastFrameAlive : i32, // Last frame number the node was updated or kept alive explicitly with DockSpace() + ImGuiDockNodeFlags_KeepAliveOnly
	LastFrameActive : i32, // Last frame number the node was updated.
	LastFrameFocused : i32, // Last frame number the node was focused.
	LastFocusedNodeId : ImGuiID, // [Root node only] Which of our child docking node (any ancestor in the hierarchy) was last focused.
	SelectedTabId : ImGuiID, // [Leaf node only] Which of our tab/window is selected.
	WantCloseTabId : ImGuiID, // [Leaf node only] Set when closing a specific tab/window.
	RefViewportId : ImGuiID, // Reference viewport ID from visible window when HostWindow == NULL.
	using _0 : bit_field u32 {
		AuthorityForPos : ImGuiDataAuthority | 3,
		AuthorityForSize : ImGuiDataAuthority | 3,
		AuthorityForViewport : ImGuiDataAuthority | 3,
		IsVisible : bool | 1, // Set to false when the node is hidden (usually disabled as it has no active window)
		IsFocused : bool | 1,
		IsBgDrawnThisFrame : bool | 1,
		HasCloseButton : bool | 1, // Provide space for a close button (if any of the docked window has one). Note that button may be hidden on window without one.
		HasWindowMenuButton : bool | 1,
		HasCentralNodeChild : bool | 1,
		WantCloseAll : bool | 1, // Set when closing all tabs at once.
		WantLockSizeOnce : bool | 1,
		WantMouseMove : bool | 1, // After a node extraction we need to transition toward moving the newly created host window
		WantHiddenTabBarUpdate : bool | 1,
		WantHiddenTabBarToggle : bool | 1,
	},
}

ImGuiDockNode_IsRootNode :: proc(this : ^ImGuiDockNode) -> bool { return this.ParentNode == nil }

ImGuiDockNode_IsDockSpace :: proc(this : ^ImGuiDockNode) -> bool { return (this.MergedFlags & cast(ImGuiDockNodeFlags) ImGuiDockNodeFlagsPrivate_.ImGuiDockNodeFlags_DockSpace) != {} }

ImGuiDockNode_IsFloatingNode :: proc(this : ^ImGuiDockNode) -> bool { return this.ParentNode == nil && (this.MergedFlags & cast(ImGuiDockNodeFlags) ImGuiDockNodeFlagsPrivate_.ImGuiDockNodeFlags_DockSpace) == {} }

ImGuiDockNode_IsCentralNode :: proc(this : ^ImGuiDockNode) -> bool { return (this.MergedFlags & cast(ImGuiDockNodeFlags) ImGuiDockNodeFlagsPrivate_.ImGuiDockNodeFlags_CentralNode) != {} }

// Hidden tab bar can be shown back by clicking the small triangle
ImGuiDockNode_IsHiddenTabBar :: proc(this : ^ImGuiDockNode) -> bool { return (this.MergedFlags & cast(ImGuiDockNodeFlags) ImGuiDockNodeFlagsPrivate_.ImGuiDockNodeFlags_HiddenTabBar) != {} }

// Never show a tab bar
ImGuiDockNode_IsNoTabBar :: proc(this : ^ImGuiDockNode) -> bool { return (this.MergedFlags & cast(ImGuiDockNodeFlags) ImGuiDockNodeFlagsPrivate_.ImGuiDockNodeFlags_NoTabBar) != {} }

ImGuiDockNode_IsSplitNode :: proc(this : ^ImGuiDockNode) -> bool { return this.ChildNodes[0] != nil }

ImGuiDockNode_IsLeafNode :: proc(this : ^ImGuiDockNode) -> bool { return this.ChildNodes[0] == nil }

ImGuiDockNode_IsEmpty :: proc(this : ^ImGuiDockNode) -> bool { return this.ChildNodes[0] == nil && this.Windows.Size == 0 }

ImGuiDockNode_Rect :: proc(this : ^ImGuiDockNode) -> ImRect { return ImRect{{this.Pos.x, this.Pos.y}, {this.Pos.x + this.Size.x, this.Pos.y + this.Size.y} }}

ImGuiDockNode_SetLocalFlags :: proc(this : ^ImGuiDockNode, flags : ImGuiDockNodeFlags)
{
	this.LocalFlags = flags; UpdateMergedFlags(this)
}

ImGuiDockNode_UpdateMergedFlags :: proc(this : ^ImGuiDockNode) { this.MergedFlags = this.SharedFlags | this.LocalFlags | this.LocalFlagsInWindows }

// List of colors that are stored at the time of Begin() into Docked Windows.
// We currently store the packed colors in a simple array window->DockStyle.Colors[].
// A better solution may involve appending into a log of colors in ImGuiContext + store offsets into those arrays in ImGuiWindow,
// but it would be more complex as we'd need to double-buffer both as e.g. drop target may refer to window from last frame.
ImGuiWindowDockStyleCol :: enum i32 {
	ImGuiWindowDockStyleCol_Text,
	ImGuiWindowDockStyleCol_TabHovered,
	ImGuiWindowDockStyleCol_TabFocused,
	ImGuiWindowDockStyleCol_TabSelected,
	ImGuiWindowDockStyleCol_TabSelectedOverline,
	ImGuiWindowDockStyleCol_TabDimmed,
	ImGuiWindowDockStyleCol_TabDimmedSelected,
	ImGuiWindowDockStyleCol_TabDimmedSelectedOverline,
	ImGuiWindowDockStyleCol_COUNT,
}

// Storage for window-style data which needs to be stored for docking purpose
// We don't store style.Alpha: dock_node->LastBgColor embeds it and otherwise it would only affect the docking tab, which intuitively I would say we don't want to.
ImGuiWindowDockStyle :: struct {
	Colors : [ImGuiWindowDockStyleCol.ImGuiWindowDockStyleCol_COUNT]ImU32,
}

// Docking system context
ImGuiDockContext :: struct {
	Nodes : ImGuiStorage, // Map ID -> ImGuiDockNode*: Active nodes
	Requests : ImVector(ImGuiDockRequest),
	NodesSettings : ImVector(ImGuiDockNodeSettings),
	WantFullRebuild : bool,
}

ImGuiDockContext_deinit :: proc(this : ^ImGuiDockContext)
{
	deinit(&this.Nodes)
	deinit(&this.Requests)
	deinit(&this.NodesSettings)
}

ImGuiDockContext_init :: proc(this : ^ImGuiDockContext)
{
	this^ = {}
}

} // preproc endif// #ifdef IMGUI_HAS_DOCK

//-----------------------------------------------------------------------------
// [SECTION] Viewport support
//-----------------------------------------------------------------------------

// ImGuiViewport Private/Internals fields (cardinal sin: we are using inheritance!)
// Every instance of ImGuiViewport is in fact a ImGuiViewportP.
ImGuiViewportP :: struct {
	using __base_imguiviewport : ImGuiViewport,
	Window : ^ImGuiWindow, // Set when the viewport is owned by a window (and ImGuiViewportFlags_CanHostOtherWindows is NOT set)
	Idx : i32,
	LastFrameActive : i32, // Last frame number this viewport was activated by a window
	LastFocusedStampCount : i32, // Last stamp number from when a window hosted by this viewport was focused (by comparing this value between two viewport we have an implicit viewport z-order we use as fallback)
	LastNameHash : ImGuiID,
	LastPos : ImVec2,
	LastSize : ImVec2,
	Alpha : f32, // Window opacity (when dragging dockable windows/viewports we make them transparent)
	LastAlpha : f32,
	LastFocusedHadNavWindow : bool, // Instead of maintaining a LastFocusedWindow (which may harder to correctly maintain), we merely store weither NavWindow != NULL last time the viewport was focused.
	PlatformMonitor : i16,
	BgFgDrawListsLastFrame : [2]i32, // Last frame number the background (0) and foreground (1) draw lists were used
	BgFgDrawLists : [2]^ImDrawList, // Convenience background (0) and foreground (1) draw lists. We use them to draw software mouser cursor when io.MouseDrawCursor is set and to draw most debug overlays.
	DrawDataP : ImDrawData,
	DrawDataBuilder : ImDrawDataBuilder, // Temporary data while building final ImDrawData
	LastPlatformPos : ImVec2,
	LastPlatformSize : ImVec2,
	LastRendererSize : ImVec2,

	// Per-viewport work area
	// - Insets are >= 0.0f values, distance from viewport corners to work area.
	// - BeginMainMenuBar() and DockspaceOverViewport() tend to use work area to avoid stepping over existing contents.
	// - Generally 'safeAreaInsets' in iOS land, 'DisplayCutout' in Android land.
	WorkInsetMin : ImVec2, // Work Area inset locked for the frame. GetWorkRect() always fits within GetMainRect().
	WorkInsetMax : ImVec2, // "
	BuildWorkInsetMin : ImVec2, // Work Area inset accumulator for current frame, to become next frame's WorkInset
	BuildWorkInsetMax : ImVec2, // "
}

ImGuiViewportP_deinit :: proc(this : ^ImGuiViewportP)
{
	deinit(&this.DrawDataP)
	deinit(&this.DrawDataBuilder)
	if this.BgFgDrawLists[0] != nil { IM_DELETE(this.BgFgDrawLists[0]) }
	if this.BgFgDrawLists[1] != nil { IM_DELETE(this.BgFgDrawLists[1]) }
}

ImGuiViewportP_init :: proc(this : ^ImGuiViewportP)
{
	this^ = {}
	init(&this.DrawDataP)
	init(&this.DrawDataBuilder)
	this.Window = nil; this.Idx = -1; this.LastFocusedStampCount = -1; this.BgFgDrawListsLastFrame[1] = this.LastFocusedStampCount; this.BgFgDrawListsLastFrame[0] = this.BgFgDrawListsLastFrame[1]; this.LastFrameActive = this.BgFgDrawListsLastFrame[0]; this.LastNameHash = 0; this.LastAlpha = 1.0; this.Alpha = this.LastAlpha; this.LastFocusedHadNavWindow = false; this.PlatformMonitor = -1; this.BgFgDrawLists[1] = nil; this.BgFgDrawLists[0] = this.BgFgDrawLists[1]; this.LastRendererSize = ImVec2{FLT_MAX, FLT_MAX}; this.LastPlatformSize = this.LastRendererSize; this.LastPlatformPos = this.LastPlatformSize
}

ImGuiViewportP_ClearRequestFlags :: proc(this : ^ImGuiViewportP) { this.PlatformRequestResize = false; this.PlatformRequestMove = this.PlatformRequestResize; this.PlatformRequestClose = this.PlatformRequestMove }

// Calculate work rect pos/size given a set of offset (we have 1 pair of offset for rect locked from last frame data, and 1 pair for currently building rect)
ImGuiViewportP_CalcWorkRectPos :: proc(this : ^ImGuiViewportP, inset_min : ImVec2) -> ImVec2 { return ImVec2{this.Pos.x + inset_min.x, this.Pos.y + inset_min.y} }

ImGuiViewportP_CalcWorkRectSize :: proc(this : ^ImGuiViewportP, inset_min : ImVec2, inset_max : ImVec2) -> ImVec2 { return ImVec2{ImMax(f32(0.0), this.Size.x - inset_min.x - inset_max.x), ImMax(f32(0.0), this.Size.y - inset_min.y - inset_max.y)} }

// Update public fields
ImGuiViewportP_UpdateWorkRect :: proc(this : ^ImGuiViewportP)
{
	this.WorkPos = ImGuiViewportP_CalcWorkRectPos(this, this.WorkInsetMin); this.WorkSize = ImGuiViewportP_CalcWorkRectSize(this, this.WorkInsetMin, this.WorkInsetMax)
}

// Helpers to retrieve ImRect (we don't need to store BuildWorkRect as every access tend to change it, hence the code asymmetry)
ImGuiViewportP_GetMainRect :: proc(this : ^ImGuiViewportP) -> ImRect { return ImRect{{this.Pos.x, this.Pos.y}, {this.Pos.x + this.Size.x, this.Pos.y + this.Size.y}} }

ImGuiViewportP_GetWorkRect :: proc(this : ^ImGuiViewportP) -> ImRect { return ImRect{{this.WorkPos.x, this.WorkPos.y}, {this.WorkPos.x + this.WorkSize.x, this.WorkPos.y + this.WorkSize.y}} }

ImGuiViewportP_GetBuildWorkRect :: proc(this : ^ImGuiViewportP) -> ImRect
{
	pos : ImVec2 = ImGuiViewportP_CalcWorkRectPos(this, this.BuildWorkInsetMin); size : ImVec2 = ImGuiViewportP_CalcWorkRectSize(this, this.BuildWorkInsetMin, this.BuildWorkInsetMax); return ImRect{{pos.x, pos.y}, {pos.x + size.x, pos.y + size.y}}
}

// Storage for a window .ini settings (we keep one of those even if the actual window wasn't instanced during this session)
//-----------------------------------------------------------------------------
// [SECTION] Settings support
//-----------------------------------------------------------------------------

// Windows data saved in imgui.ini file
// Because we never destroy or rename ImGuiWindowSettings, we can store the names in a separate buffer easily.
// (this is designed to be stored in a ImChunkStream buffer, with the variable-length Name following our structure)
ImGuiWindowSettings :: struct {
	ID : ImGuiID,
	Pos : ImVec2ih, // NB: Settings position are stored RELATIVE to the viewport! Whereas runtime ones are absolute positions.
	Size : ImVec2ih,
	ViewportPos : ImVec2ih,
	ViewportId : ImGuiID,
	DockId : ImGuiID, // ID of last known DockNode (even if the DockNode is invisible because it has only 1 active window), or 0 if none.
	ClassId : ImGuiID, // ID of window class if specified
	DockOrder : i16, // Order of the last time the window was visible within its DockNode. This is used to reorder windows that are reappearing on the same frame. Same value between windows that were active and windows that were none are possible.
	Collapsed : bool,
	IsChild : bool,
	WantApply : bool, // Set when loaded from .ini data (to enable merging/loading .ini data into an already running context)
	WantDelete : bool, // Set to invalidate/delete the settings entry
}

ImGuiWindowSettings_init :: proc(this : ^ImGuiWindowSettings)
{
	this^ = {}; this.DockOrder = -1
}

ImGuiWindowSettings_GetName :: proc(this : ^ImGuiWindowSettings) -> [^]u8 { return cast([^]u8) mem.ptr_offset(this, 1) }

// Storage for one type registered in the .ini file
ImGuiSettingsHandler :: struct {
	TypeName : string, // Short description stored in .ini file. Disallowed characters: '[' ']'
	TypeHash : ImGuiID, // == ImHashStr(TypeName)
	ClearAllFn : proc(ctx : ^ImGuiContext, handler : ^ImGuiSettingsHandler), // Clear all settings data
	ReadInitFn : proc(ctx : ^ImGuiContext, handler : ^ImGuiSettingsHandler), // Read: Called before reading (in registration order)
	ReadOpenFn : proc(ctx : ^ImGuiContext, handler : ^ImGuiSettingsHandler, name : string) -> rawptr, // Read: Called when entering into a new ini entry e.g. "[Window][Name]"
	ReadLineFn : proc(ctx : ^ImGuiContext, handler : ^ImGuiSettingsHandler, entry : rawptr, line : string), // Read: Called for every line of text within an ini entry
	ApplyAllFn : proc(ctx : ^ImGuiContext, handler : ^ImGuiSettingsHandler), // Read: Called after reading (in registration order)
	WriteAllFn : proc(ctx : ^ImGuiContext, handler : ^ImGuiSettingsHandler, out_buf : ^ImGuiTextBuffer), // Write: Output every entries into 'out_buf'
	UserData : rawptr,
}

// Enumerations
// Use your programming IDE "Go to definition" facility on the names of the center columns to find the actual flags/enum lists.
// -> enum ImGuiLocKey              // Enum: a localization entry for translation.
//-----------------------------------------------------------------------------
// [SECTION] Localization support
//-----------------------------------------------------------------------------

// This is experimental and not officially supported, it'll probably fall short of features, if/when it does we may backtrack.
ImGuiLocKey :: enum i32 {
	ImGuiLocKey_VersionStr,
	ImGuiLocKey_TableSizeOne,
	ImGuiLocKey_TableSizeAllFit,
	ImGuiLocKey_TableSizeAllDefault,
	ImGuiLocKey_TableResetOrder,
	ImGuiLocKey_WindowingMainMenuBar,
	ImGuiLocKey_WindowingPopup,
	ImGuiLocKey_WindowingUntitled,
	ImGuiLocKey_OpenLink_s,
	ImGuiLocKey_CopyLink,
	ImGuiLocKey_DockingHideTabBar,
	ImGuiLocKey_DockingHoldShiftToDock,
	ImGuiLocKey_DockingDragToUndockOrMoveNode,
	ImGuiLocKey_COUNT,
}

// A localization entry.
ImGuiLocEntry :: struct {
	Key : ImGuiLocKey,
	Text : string,
}

//-----------------------------------------------------------------------------
// [SECTION] Error handling, State recovery support
//-----------------------------------------------------------------------------

// Macros used by Recoverable Error handling
// - Only dispatch error if _EXPR: evaluate as assert (similar to an assert macro).
// - The message will always be a string literal, in order to increase likelihood of being display by an assert handler.
// - See 'Demo->Configuration->Error Handling' and ImGuiIO definitions for details on error handling.
// - Read https://github.com/ocornut/imgui/wiki/Error-Handling for details on error handling.
//when ! defined ( IM_ASSERT_USER_ERROR ) {
IM_ASSERT_USER_ERROR :: #force_inline proc (_EXPR : bool, _MSG : $T1)
{
	// Recoverable User Error
	if(!_EXPR && ErrorLog(_MSG)) {
		IM_ASSERT(_EXPR, _MSG);
	}
}

//} // preproc endif

// The error callback is currently not public, as it is expected that only advanced users will rely on it.
ImGuiErrorCallback :: proc(ctx : ^ImGuiContext, user_data : rawptr, msg : string)// Function signature for g.ErrorCallback

//-----------------------------------------------------------------------------
// [SECTION] Metrics, Debug Tools
//-----------------------------------------------------------------------------

// See IMGUI_DEBUG_LOG() and IMGUI_DEBUG_LOG_XXX() macros.
ImGuiDebugLogFlags_ :: enum i32 {
	// Event types
	ImGuiDebugLogFlags_None = 0,
	ImGuiDebugLogFlags_EventError = 1 << 0, // Error submitted by IM_ASSERT_USER_ERROR()
	ImGuiDebugLogFlags_EventActiveId = 1 << 1,
	ImGuiDebugLogFlags_EventFocus = 1 << 2,
	ImGuiDebugLogFlags_EventPopup = 1 << 3,
	ImGuiDebugLogFlags_EventNav = 1 << 4,
	ImGuiDebugLogFlags_EventClipper = 1 << 5,
	ImGuiDebugLogFlags_EventSelection = 1 << 6,
	ImGuiDebugLogFlags_EventIO = 1 << 7,
	ImGuiDebugLogFlags_EventFont = 1 << 8,
	ImGuiDebugLogFlags_EventInputRouting = 1 << 9,
	ImGuiDebugLogFlags_EventDocking = 1 << 10,
	ImGuiDebugLogFlags_EventViewport = 1 << 11,

	ImGuiDebugLogFlags_EventMask_ = ImGuiDebugLogFlags_EventError | ImGuiDebugLogFlags_EventActiveId | ImGuiDebugLogFlags_EventFocus | ImGuiDebugLogFlags_EventPopup | ImGuiDebugLogFlags_EventNav | ImGuiDebugLogFlags_EventClipper | ImGuiDebugLogFlags_EventSelection | ImGuiDebugLogFlags_EventIO | ImGuiDebugLogFlags_EventFont | ImGuiDebugLogFlags_EventInputRouting | ImGuiDebugLogFlags_EventDocking | ImGuiDebugLogFlags_EventViewport,
	ImGuiDebugLogFlags_OutputToTTY = 1 << 20, // Also send output to TTY
	ImGuiDebugLogFlags_OutputToTestEngine = 1 << 21, // Also send output to Test Engine
}

ImGuiDebugAllocEntry :: struct {
	FrameCount : i32,
	AllocCount : ImS16,
	FreeCount : ImS16,
}

ImGuiDebugAllocInfo :: struct {
	TotalAllocCount : i32, // Number of call to MemAlloc().
	TotalFreeCount : i32,
	LastEntriesIdx : ImS16, // Current index in buffer
	LastEntriesBuf : [6]ImGuiDebugAllocEntry, // Track last 6 frames that had allocations
}

// Storage for ShowMetricsWindow() and DebugNodeXXX() functions
ImGuiMetricsConfig :: struct {
	ShowDebugLog : bool,
	ShowIDStackTool : bool,
	ShowWindowsRects : bool,
	ShowWindowsBeginOrder : bool,
	ShowTablesRects : bool,
	ShowDrawCmdMesh : bool,
	ShowDrawCmdBoundingBoxes : bool,
	ShowTextEncodingViewer : bool,
	ShowAtlasTintedWithTextColor : bool,
	ShowDockingNodes : bool,
	ShowWindowsRectsType : i32,
	ShowTablesRectsType : i32,
	HighlightMonitorIdx : i32,
	HighlightViewportID : ImGuiID,
}

ImGuiMetricsConfig_init :: proc(this : ^ImGuiMetricsConfig)
{
this.ShowDebugLog = false
this.ShowIDStackTool = false
this.ShowWindowsRects = false
this.ShowWindowsBeginOrder = false
this.ShowTablesRects = false
this.ShowDrawCmdMesh = true
this.ShowDrawCmdBoundingBoxes = true
this.ShowTextEncodingViewer = false
this.ShowAtlasTintedWithTextColor = false
this.ShowDockingNodes = false
this.ShowWindowsRectsType = -1
this.ShowTablesRectsType = -1
this.HighlightMonitorIdx = -1
this.HighlightViewportID = 0

}

ImGuiStackLevelInfo :: struct {
ID : ImGuiID,
	QueryFrameCount : ImS8, // >= 1: Query in progress
	QuerySuccess : bool, // Obtained result from DebugHookIdInfo()
	using _0 : bit_field u8 {
		DataType : ImGuiDataType | 8,
	},
	Desc : [57]u8, // Arbitrarily sized buffer to hold a result (FIXME: could replace Results[] with a chunk stream?) FIXME: Now that we added CTRL+C this should be fixed.
}

// State for ID Stack tool queries
ImGuiIDStackTool :: struct {
	LastActiveFrame : i32,
	StackLevel : i32, // -1: query stack and resize Results, >= 0: individual stack level
	QueryId : ImGuiID, // ID to query details for
	Results : ImVector(ImGuiStackLevelInfo),
	CopyToClipboardOnCtrlC : bool,
	CopyToClipboardLastTime : f32,
}

ImGuiIDStackTool_deinit :: proc(this : ^ImGuiIDStackTool) { deinit(&this.Results) }

ImGuiIDStackTool_init :: proc(this : ^ImGuiIDStackTool)
{
	this^ = {}; this.CopyToClipboardLastTime = -FLT_MAX
}

//-----------------------------------------------------------------------------
// [SECTION] Generic context hooks
//-----------------------------------------------------------------------------

ImGuiContextHookCallback :: proc(ctx : ^ImGuiContext, hook : ^ImGuiContextHook)
ImGuiContextHookType :: enum i32 { ImGuiContextHookType_NewFramePre, ImGuiContextHookType_NewFramePost, ImGuiContextHookType_EndFramePre, ImGuiContextHookType_EndFramePost, ImGuiContextHookType_RenderPre, ImGuiContextHookType_RenderPost, ImGuiContextHookType_Shutdown, ImGuiContextHookType_PendingRemoval_, }

// Hook for extensions like ImGuiTestEngine
ImGuiContextHook :: struct {
	HookId : ImGuiID, // A unique ID assigned by AddContextHook()
	Type : ImGuiContextHookType,
	Owner : ImGuiID,
	Callback : ImGuiContextHookCallback,
	UserData : rawptr,
}

// Dear ImGui context (opaque structure, unless including imgui_internal.h)
// Main Dear ImGui context
//-----------------------------------------------------------------------------
// [SECTION] ImGuiContext (main Dear ImGui context)
//-----------------------------------------------------------------------------

ImGuiContext :: struct {
	Initialized : bool,
	FontAtlasOwnedByContext : bool, // IO.Fonts-> is owned by the ImGuiContext and will be destructed along with it.
	IO : ImGuiIO,
	PlatformIO : ImGuiPlatformIO,
	Style : ImGuiStyle,
	ConfigFlagsCurrFrame : ImGuiConfigFlags, // = g.IO.ConfigFlags at the time of NewFrame()
	ConfigFlagsLastFrame : ImGuiConfigFlags,
	Font : ^ImFont, // (Shortcut) == FontStack.empty() ? IO.Font : FontStack.back()
	FontSize : f32, // (Shortcut) == FontBaseSize * g.CurrentWindow->FontWindowScale == window->FontSize(). Text height for current window.
	FontBaseSize : f32, // (Shortcut) == IO.FontGlobalScale * Font->Scale * Font->FontSize. Base text height.
	FontScale : f32, // == FontSize / Font->FontSize
	CurrentDpiScale : f32, // Current window/viewport DpiScale == CurrentViewport->DpiScale
	DrawListSharedData : ImDrawListSharedData,
	Time : f64,
	FrameCount : i32,
	FrameCountEnded : i32,
	FrameCountPlatformEnded : i32,
	FrameCountRendered : i32,
	WithinEndChildID : ImGuiID, // Set within EndChild()
	WithinFrameScope : bool, // Set by NewFrame(), cleared by EndFrame()
	WithinFrameScopeWithImplicitWindow : bool, // Set by NewFrame(), cleared by EndFrame() when the implicit debug window has been pushed
	GcCompactAll : bool, // Request full GC
	TestEngineHookItems : bool, // Will call test engine hooks: ImGuiTestEngineHook_ItemAdd(), ImGuiTestEngineHook_ItemInfo(), ImGuiTestEngineHook_Log()
	TestEngine : rawptr, // Test engine user data
	ContextName : [16]u8, // Storage for a context name (to facilitate debugging multi-context setups)

	// Inputs
	InputEventsQueue : ImVector(ImGuiInputEvent), // Input events which will be trickled/written into IO structure.
	InputEventsTrail : ImVector(ImGuiInputEvent), // Past input events processed in NewFrame(). This is to allow domain-specific application to access e.g mouse/pen trail.
	InputEventsNextMouseSource : ImGuiMouseSource,
	InputEventsNextEventId : ImU32,

	// Windows state
	Windows : ImVector(^ImGuiWindow), // Windows, sorted in display order, back to front
	WindowsFocusOrder : ImVector(^ImGuiWindow), // Root windows, sorted in focus order, back to front.
	WindowsTempSortBuffer : ImVector(^ImGuiWindow), // Temporary buffer used in EndFrame() to reorder windows so parents are kept before their child
	CurrentWindowStack : ImVector(ImGuiWindowStackData),
	WindowsById : ImGuiStorage, // Map window's ImGuiID to ImGuiWindow*
	WindowsActiveCount : i32, // Number of unique windows submitted by frame
	WindowsHoverPadding : ImVec2, // Padding around resizable windows for which hovering on counts as hovering the window == ImMax(style.TouchExtraPadding, WINDOWS_HOVER_PADDING).
	DebugBreakInWindow : ImGuiID, // Set to break in Begin() call.
	CurrentWindow : ^ImGuiWindow, // Window being drawn into
	HoveredWindow : ^ImGuiWindow, // Window the mouse is hovering. Will typically catch mouse inputs.
	HoveredWindowUnderMovingWindow : ^ImGuiWindow, // Hovered window ignoring MovingWindow. Only set if MovingWindow is set.
	HoveredWindowBeforeClear : ^ImGuiWindow, // Window the mouse is hovering. Filled even with _NoMouse. This is currently useful for multi-context compositors.
	MovingWindow : ^ImGuiWindow, // Track the window we clicked on (in order to preserve focus). The actual window that is moved is generally MovingWindow->RootWindowDockTree.
	WheelingWindow : ^ImGuiWindow, // Track the window we started mouse-wheeling on. Until a timer elapse or mouse has moved, generally keep scrolling the same window even if during the course of scrolling the mouse ends up hovering a child window.
	WheelingWindowRefMousePos : ImVec2,
	WheelingWindowStartFrame : i32, // This may be set one frame before WheelingWindow is != NULL
	WheelingWindowScrolledFrame : i32,
	WheelingWindowReleaseTimer : f32,
	WheelingWindowWheelRemainder : ImVec2,
	WheelingAxisAvg : ImVec2,

	// Item/widgets state and tracking information
	DebugDrawIdConflicts : ImGuiID, // Set when we detect multiple items with the same identifier
	DebugHookIdInfo : ImGuiID, // Will call core hooks: DebugHookIdInfo() from GetID functions, used by ID Stack Tool [next HoveredId/ActiveId to not pull in an extra cache-line]
	HoveredId : ImGuiID, // Hovered widget, filled during the frame
	HoveredIdPreviousFrame : ImGuiID,
	HoveredIdPreviousFrameItemCount : i32, // Count numbers of items using the same ID as last frame's hovered id
	HoveredIdTimer : f32, // Measure contiguous hovering time
	HoveredIdNotActiveTimer : f32, // Measure contiguous hovering time where the item has not been active
	HoveredIdAllowOverlap : bool,
	HoveredIdIsDisabled : bool, // At least one widget passed the rect test, but has been discarded by disabled flag or popup inhibit. May be true even if HoveredId == 0.
	ItemUnclipByLog : bool, // Disable ItemAdd() clipping, essentially a memory-locality friendly copy of LogEnabled
	ActiveId : ImGuiID, // Active widget
	ActiveIdIsAlive : ImGuiID, // Active widget has been seen this frame (we can't use a bool as the ActiveId may change within the frame)
	ActiveIdTimer : f32,
	ActiveIdIsJustActivated : bool, // Set at the time of activation for one frame
	ActiveIdAllowOverlap : bool, // Active widget allows another widget to steal active id (generally for overlapping widgets, but not always)
	ActiveIdNoClearOnFocusLoss : bool, // Disable losing active id if the active id window gets unfocused.
	ActiveIdHasBeenPressedBefore : bool, // Track whether the active id led to a press (this is to allow changing between PressOnClick and PressOnRelease without pressing twice). Used by range_select branch.
	ActiveIdHasBeenEditedBefore : bool, // Was the value associated to the widget Edited over the course of the Active state.
	ActiveIdHasBeenEditedThisFrame : bool,
	ActiveIdFromShortcut : bool,
	using _0 : bit_field u8 {
		ActiveIdMouseButton : ImGuiMouseButton | 8,
	},
	ActiveIdClickOffset : ImVec2, // Clicked offset from upper-left corner, if applicable (currently only set by ButtonBehavior)
	ActiveIdWindow : ^ImGuiWindow,
	ActiveIdSource : ImGuiInputSource, // Activating source: ImGuiInputEventType_Mouse OR ImGuiInputSource_Keyboard OR ImGuiInputSource_Gamepad
	ActiveIdPreviousFrame : ImGuiID,
	ActiveIdPreviousFrameIsAlive : bool,
	ActiveIdPreviousFrameHasBeenEditedBefore : bool,
	ActiveIdPreviousFrameWindow : ^ImGuiWindow,
	ActiveIdValueOnActivation : ImGuiDataTypeStorage, // Backup of initial value at the time of activation. ONLY SET BY SPECIFIC WIDGETS: DragXXX and SliderXXX.
	LastActiveId : ImGuiID, // Store the last non-zero ActiveId, useful for animation.
	LastActiveIdTimer : f32, // Store the last non-zero ActiveId timer since the beginning of activation, useful for animation.

	// Key/Input Ownership + Shortcut Routing system
	// - The idea is that instead of "eating" a given key, we can link to an owner.
	// - Input query can then read input by specifying ImGuiKeyOwner_Any (== 0), ImGuiKeyOwner_NoOwner (== -1) or a custom ID.
	// - Routing is requested ahead of time for a given chord (Key + Mods) and granted in NewFrame().
	LastKeyModsChangeTime : f64, // Record the last time key mods changed (affect repeat delay when using shortcut logic)
	LastKeyModsChangeFromNoneTime : f64, // Record the last time key mods changed away from being 0 (affect repeat delay when using shortcut logic)
	LastKeyboardKeyPressTime : f64, // Record the last time a keyboard key (ignore mouse/gamepad ones) was pressed.
	KeysMayBeCharInput : ImBitArrayForNamedKeys, // Lookup to tell if a key can emit char input, see IsKeyChordPotentiallyCharInput(). sizeof() = 20 bytes
	KeysOwnerData : [ImGuiKey.ImGuiKey_NamedKey_COUNT]ImGuiKeyOwnerData,
	KeysRoutingTable : ImGuiKeyRoutingTable,
	ActiveIdUsingNavDirMask : ImU32, // Active widget will want to read those nav move requests (e.g. can activate a button and move away from it)
	ActiveIdUsingAllKeyboardKeys : bool, // Active widget will want to read all keyboard keys inputs. (this is a shortcut for not taking ownership of 100+ keys, frequently used by drag operations)
	DebugBreakInShortcutRouting : ImGuiKeyChord, // Set to break in SetShortcutRouting()/Shortcut() calls.
	//ImU32                 ActiveIdUsingNavInputMask;          // [OBSOLETE] Since (IMGUI_VERSION_NUM >= 18804) : 'g.ActiveIdUsingNavInputMask |= (1 << ImGuiNavInput_Cancel);' becomes --> 'SetKeyOwner(ImGuiKey_Escape, g.ActiveId) and/or SetKeyOwner(ImGuiKey_NavGamepadCancel, g.ActiveId);'

	// Next window/item data
	CurrentFocusScopeId : ImGuiID, // Value for currently appending items == g.FocusScopeStack.back(). Not to be mistaken with g.NavFocusScopeId.
	CurrentItemFlags : ImGuiItemFlags, // Value for currently appending items == g.ItemFlagsStack.back()
	DebugLocateId : ImGuiID, // Storage for DebugLocateItemOnHover() feature: this is read by ItemAdd() so we keep it in a hot/cached location
	NextItemData : ImGuiNextItemData, // Storage for SetNextItem** functions
	LastItemData : ImGuiLastItemData, // Storage for last submitted item (setup by ItemAdd)
	NextWindowData : ImGuiNextWindowData, // Storage for SetNextWindow** functions
	DebugShowGroupRects : bool,

	// Shared stacks
	DebugFlashStyleColorIdx : ImGuiCol, // (Keep close to ColorStack to share cache line)
	ColorStack : ImVector(ImGuiColorMod), // Stack for PushStyleColor()/PopStyleColor() - inherited by Begin()
	StyleVarStack : ImVector(ImGuiStyleMod), // Stack for PushStyleVar()/PopStyleVar() - inherited by Begin()
	FontStack : ImVector(^ImFont), // Stack for PushFont()/PopFont() - inherited by Begin()
	FocusScopeStack : ImVector(ImGuiFocusScopeData), // Stack for PushFocusScope()/PopFocusScope() - inherited by BeginChild(), pushed into by Begin()
	ItemFlagsStack : ImVector(ImGuiItemFlags), // Stack for PushItemFlag()/PopItemFlag() - inherited by Begin()
	GroupStack : ImVector(ImGuiGroupData), // Stack for BeginGroup()/EndGroup() - not inherited by Begin()
	OpenPopupStack : ImVector(ImGuiPopupData), // Which popups are open (persistent)
	BeginPopupStack : ImVector(ImGuiPopupData), // Which level of BeginPopup() we are in (reset every frame)
	TreeNodeStack : ImVector(ImGuiTreeNodeStackData), // Stack for TreeNode()

	// Viewports
	Viewports : ImVector(^ImGuiViewportP), // Active viewports (always 1+, and generally 1 unless multi-viewports are enabled). Each viewports hold their copy of ImDrawData.
	CurrentViewport : ^ImGuiViewportP, // We track changes of viewport (happening in Begin) so we can call Platform_OnChangedViewport()
	MouseViewport : ^ImGuiViewportP,
	MouseLastHoveredViewport : ^ImGuiViewportP, // Last known viewport that was hovered by mouse (even if we are not hovering any viewport any more) + honoring the _NoInputs flag.
	PlatformLastFocusedViewportId : ImGuiID,
	FallbackMonitor : ImGuiPlatformMonitor, // Virtual monitor used as fallback if backend doesn't provide monitor information.
	PlatformMonitorsFullWorkRect : ImRect, // Bounding box of all platform monitors
	ViewportCreatedCount : i32, // Unique sequential creation counter (mostly for testing/debugging)
	PlatformWindowsCreatedCount : i32, // Unique sequential creation counter (mostly for testing/debugging)
	ViewportFocusedStampCount : i32, // Every time the front-most window changes, we stamp its viewport with an incrementing counter

	// Keyboard/Gamepad Navigation
	NavCursorVisible : bool, // Nav focus cursor/rectangle is visible? We hide it after a mouse click. We show it after a nav move.
	NavHighlightItemUnderNav : bool, // Disable mouse hovering highlight. Highlight navigation focused item instead of mouse hovered item.
	//bool                  NavDisableHighlight;                // Old name for !g.NavCursorVisible before 1.91.4 (2024/10/18). OPPOSITE VALUE (g.NavDisableHighlight == !g.NavCursorVisible)
	//bool                  NavDisableMouseHover;               // Old name for g.NavHighlightItemUnderNav before 1.91.1 (2024/10/18) this was called When user starts using keyboard/gamepad, we hide mouse hovering highlight until mouse is touched again.
	NavMousePosDirty : bool, // When set we will update mouse position if io.ConfigNavMoveSetMousePos is set (not enabled by default)
	NavIdIsAlive : bool, // Nav widget has been seen this frame ~~ NavRectRel is valid
	NavId : ImGuiID, // Focused item for navigation
	NavWindow : ^ImGuiWindow, // Focused window for navigation. Could be called 'FocusedWindow'
	NavFocusScopeId : ImGuiID, // Focused focus scope (e.g. selection code often wants to "clear other items" when landing on an item of the same scope)
	NavLayer : ImGuiNavLayer, // Focused layer (main scrolling layer, or menu/title bar layer)
	NavActivateId : ImGuiID, // ~~ (g.ActiveId == 0) && (IsKeyPressed(ImGuiKey_Space) || IsKeyDown(ImGuiKey_Enter) || IsKeyPressed(ImGuiKey_NavGamepadActivate)) ? NavId : 0, also set when calling ActivateItem()
	NavActivateDownId : ImGuiID, // ~~ IsKeyDown(ImGuiKey_Space) || IsKeyDown(ImGuiKey_Enter) || IsKeyDown(ImGuiKey_NavGamepadActivate) ? NavId : 0
	NavActivatePressedId : ImGuiID, // ~~ IsKeyPressed(ImGuiKey_Space) || IsKeyPressed(ImGuiKey_Enter) || IsKeyPressed(ImGuiKey_NavGamepadActivate) ? NavId : 0 (no repeat)
	NavActivateFlags : ImGuiActivateFlags,
	NavFocusRoute : ImVector(ImGuiFocusScopeData), // Reversed copy focus scope stack for NavId (should contains NavFocusScopeId). This essentially follow the window->ParentWindowForFocusRoute chain.
	NavHighlightActivatedId : ImGuiID,
	NavHighlightActivatedTimer : f32,
	NavNextActivateId : ImGuiID, // Set by ActivateItem(), queued until next frame.
	NavNextActivateFlags : ImGuiActivateFlags,
	NavInputSource : ImGuiInputSource, // Keyboard or Gamepad mode? THIS CAN ONLY BE ImGuiInputSource_Keyboard or ImGuiInputEventType_Mouse
	NavLastValidSelectionUserData : ImGuiSelectionUserData, // Last valid data passed to SetNextItemSelectionUser(), or -1. For current window. Not reset when focusing an item that doesn't have selection data.
	NavCursorHideFrames : ImS8,

	// Navigation: Init & Move Requests
	NavAnyRequest : bool, // ~~ NavMoveRequest || NavInitRequest this is to perform early out in ItemAdd()
	NavInitRequest : bool, // Init request for appearing window to select first item
	NavInitRequestFromMove : bool,
	NavInitResult : ImGuiNavItemData, // Init request result (first item of the window, or one for which SetItemDefaultFocus() was called)
	NavMoveSubmitted : bool, // Move request submitted, will process result on next NewFrame()
	NavMoveScoringItems : bool, // Move request submitted, still scoring incoming items
	NavMoveForwardToNextFrame : bool,
	NavMoveFlags : ImGuiNavMoveFlags,
	NavMoveScrollFlags : ImGuiScrollFlags,
	NavMoveKeyMods : ImGuiKeyChord,
	NavMoveDir : ImGuiDir, // Direction of the move request (left/right/up/down)
	NavMoveDirForDebug : ImGuiDir,
	NavMoveClipDir : ImGuiDir, // FIXME-NAV: Describe the purpose of this better. Might want to rename?
	NavScoringRect : ImRect, // Rectangle used for scoring, in screen space. Based of window->NavRectRel[], modified for directional navigation scoring.
	NavScoringNoClipRect : ImRect, // Some nav operations (such as PageUp/PageDown) enforce a region which clipper will attempt to always keep submitted
	NavScoringDebugCount : i32, // Metrics for debugging
	NavTabbingDir : i32, // Generally -1 or +1, 0 when tabbing without a nav id
	NavTabbingCounter : i32, // >0 when counting items for tabbing
	NavMoveResultLocal : ImGuiNavItemData, // Best move request candidate within NavWindow
	NavMoveResultLocalVisible : ImGuiNavItemData, // Best move request candidate within NavWindow that are mostly visible (when using ImGuiNavMoveFlags_AlsoScoreVisibleSet flag)
	NavMoveResultOther : ImGuiNavItemData, // Best move request candidate within NavWindow's flattened hierarchy (when using ImGuiWindowFlags_NavFlattened flag)
	NavTabbingResultFirst : ImGuiNavItemData, // First tabbing request candidate within NavWindow and flattened hierarchy

	// Navigation: record of last move request
	NavJustMovedFromFocusScopeId : ImGuiID, // Just navigated from this focus scope id (result of a successfully MoveRequest).
	NavJustMovedToId : ImGuiID, // Just navigated to this id (result of a successfully MoveRequest).
	NavJustMovedToFocusScopeId : ImGuiID, // Just navigated to this focus scope id (result of a successfully MoveRequest).
	NavJustMovedToKeyMods : ImGuiKeyChord,
	NavJustMovedToIsTabbing : bool, // Copy of ImGuiNavMoveFlags_IsTabbing. Maybe we should store whole flags.
	NavJustMovedToHasSelectionData : bool, // Copy of move result's ItemFlags & ImGuiItemFlags_HasSelectionUserData). Maybe we should just store ImGuiNavItemData.

	// Navigation: Windowing (CTRL+TAB for list, or Menu button + keys or directional pads to move/resize)
	ConfigNavWindowingKeyNext : ImGuiKeyChord, // = ImGuiMod_Ctrl | ImGuiKey_Tab (or ImGuiMod_Super | ImGuiKey_Tab on OS X). For reconfiguration (see #4828)
	ConfigNavWindowingKeyPrev : ImGuiKeyChord, // = ImGuiMod_Ctrl | ImGuiMod_Shift | ImGuiKey_Tab (or ImGuiMod_Super | ImGuiMod_Shift | ImGuiKey_Tab on OS X)
	NavWindowingTarget : ^ImGuiWindow, // Target window when doing CTRL+Tab (or Pad Menu + FocusPrev/Next), this window is temporarily displayed top-most!
	NavWindowingTargetAnim : ^ImGuiWindow, // Record of last valid NavWindowingTarget until DimBgRatio and NavWindowingHighlightAlpha becomes 0.0f, so the fade-out can stay on it.
	NavWindowingListWindow : ^ImGuiWindow, // Internal window actually listing the CTRL+Tab contents
	NavWindowingTimer : f32,
	NavWindowingHighlightAlpha : f32,
	NavWindowingToggleLayer : bool,
	NavWindowingToggleKey : ImGuiKey,
	NavWindowingAccumDeltaPos : ImVec2,
	NavWindowingAccumDeltaSize : ImVec2,

	// Render
	DimBgRatio : f32, // 0.0..1.0 animation when fading in a dimming background (for modal window and CTRL+TAB list)

	// Drag and Drop
	DragDropActive : bool,
	DragDropWithinSource : bool, // Set when within a BeginDragDropXXX/EndDragDropXXX block for a drag source.
	DragDropWithinTarget : bool, // Set when within a BeginDragDropXXX/EndDragDropXXX block for a drag target.
	DragDropSourceFlags : ImGuiDragDropFlags,
	DragDropSourceFrameCount : i32,
	DragDropMouseButton : ImGuiMouseButton,
	DragDropPayload : ImGuiPayload,
	DragDropTargetRect : ImRect, // Store rectangle of current target candidate (we favor small targets when overlapping)
	DragDropTargetClipRect : ImRect, // Store ClipRect at the time of item's drawing
	DragDropTargetId : ImGuiID,
	DragDropAcceptFlags : ImGuiDragDropFlags,
	DragDropAcceptIdCurrRectSurface : f32, // Target item surface (we resolve overlapping targets by prioritizing the smaller surface)
	DragDropAcceptIdCurr : ImGuiID, // Target item id (set at the time of accepting the payload)
	DragDropAcceptIdPrev : ImGuiID, // Target item id from previous frame (we need to store this to allow for overlapping drag and drop targets)
	DragDropAcceptFrameCount : i32, // Last time a target expressed a desire to accept the source
	DragDropHoldJustPressedId : ImGuiID, // Set when holding a payload just made ButtonBehavior() return a press.
	DragDropPayloadBufHeap : ImVector(u8), // We don't expose the ImVector<> directly, ImGuiPayload only holds pointer+size
	DragDropPayloadBufLocal : [16]u8, // Local buffer for small payloads

	// Clipper
	ClipperTempDataStacked : i32,
	ClipperTempData : ImVector(ImGuiListClipperData),

	// Tables
	CurrentTable : ^ImGuiTable,
	DebugBreakInTable : ImGuiID, // Set to break in BeginTable() call.
	TablesTempDataStacked : i32, // Temporary table data size (because we leave previous instances undestructed, we generally don't use TablesTempData.Size)
	TablesTempData : ImVector(ImGuiTableTempData), // Temporary table data (buffers reused/shared across instances, support nesting)
	Tables : ImPool(ImGuiTable), // Persistent table data
	TablesLastTimeActive : ImVector(f32), // Last used timestamp of each tables (SOA, for efficient GC)
	DrawChannelsTempMergeBuffer : ImVector(ImDrawChannel),

	// Tab bars
	CurrentTabBar : ^ImGuiTabBar,
	TabBars : ImPool(ImGuiTabBar),
	CurrentTabBarStack : ImVector(ImGuiPtrOrIndex),
	ShrinkWidthBuffer : ImVector(ImGuiShrinkWidthItem),

	// Multi-Select state
	BoxSelectState : ImGuiBoxSelectState,
	CurrentMultiSelect : ^ImGuiMultiSelectTempData,
	MultiSelectTempDataStacked : i32, // Temporary multi-select data size (because we leave previous instances undestructed, we generally don't use MultiSelectTempData.Size)
	MultiSelectTempData : ImVector(ImGuiMultiSelectTempData),
	MultiSelectStorage : ImPool(ImGuiMultiSelectState),

	// Hover Delay system
	HoverItemDelayId : ImGuiID,
	HoverItemDelayIdPreviousFrame : ImGuiID,
	HoverItemDelayTimer : f32, // Currently used by IsItemHovered()
	HoverItemDelayClearTimer : f32, // Currently used by IsItemHovered(): grace time before g.TooltipHoverTimer gets cleared.
	HoverItemUnlockedStationaryId : ImGuiID, // Mouse has once been stationary on this item. Only reset after departing the item.
	HoverWindowUnlockedStationaryId : ImGuiID, // Mouse has once been stationary on this window. Only reset after departing the window.

	// Mouse state
	MouseCursor : ImGuiMouseCursor,
	MouseStationaryTimer : f32, // Time the mouse has been stationary (with some loose heuristic)
	MouseLastValidPos : ImVec2,

	// Widget state
	InputTextState : ImGuiInputTextState,
	InputTextDeactivatedState : ImGuiInputTextDeactivatedState,
	InputTextPasswordFont : ImFont,
	TempInputId : ImGuiID, // Temporary text input when CTRL+clicking on a slider, etc.
	DataTypeZeroValue : ImGuiDataTypeStorage, // 0 for all data types
	BeginMenuDepth : i32,
	BeginComboDepth : i32,
	ColorEditOptions : ImGuiColorEditFlags, // Store user options for color edit widgets
	ColorEditCurrentID : ImGuiID, // Set temporarily while inside of the parent-most ColorEdit4/ColorPicker4 (because they call each others).
	ColorEditSavedID : ImGuiID, // ID we are saving/restoring HS for
	ColorEditSavedHue : f32, // Backup of last Hue associated to LastColor, so we can restore Hue in lossy RGB<>HSV round trips
	ColorEditSavedSat : f32, // Backup of last Saturation associated to LastColor, so we can restore Saturation in lossy RGB<>HSV round trips
	ColorEditSavedColor : ImU32, // RGB value with alpha set to 0.
	ColorPickerRef : ImVec4, // Initial/reference color at the time of opening the color picker.
	ComboPreviewData : ImGuiComboPreviewData,
	WindowResizeBorderExpectedRect : ImRect, // Expected border rect, switch to relative edit if moving
	WindowResizeRelativeMode : bool,
	ScrollbarSeekMode : i16, // 0: scroll to clicked location, -1/+1: prev/next page.
	ScrollbarClickDeltaToGrabCenter : f32, // When scrolling to mouse location: distance between mouse and center of grab box, normalized in parent space.
	SliderGrabClickOffset : f32,
	SliderCurrentAccum : f32, // Accumulated slider delta when using navigation controls.
	SliderCurrentAccumDirty : bool, // Has the accumulated slider delta changed since last time we tried to apply it?
	DragCurrentAccumDirty : bool,
	DragCurrentAccum : f32, // Accumulator for dragging modification. Always high-precision, not rounded by end-user precision settings
	DragSpeedDefaultRatio : f32, // If speed == 0.0f, uses (max-min) * DragSpeedDefaultRatio
	DisabledAlphaBackup : f32, // Backup for style.Alpha for BeginDisabled()
	DisabledStackSize : i16,
	TooltipOverrideCount : i16,
	TooltipPreviousWindow : ^ImGuiWindow, // Window of last tooltip submitted during the frame
	ClipboardHandlerData : ImVector(u8), // If no custom clipboard handler is defined
	MenusIdSubmittedThisFrame : ImVector(ImGuiID), // A list of menu IDs that were rendered at least once
	TypingSelectState : ImGuiTypingSelectState, // State for GetTypingSelectRequest()

	// Platform support
	PlatformImeData : ImGuiPlatformImeData, // Data updated by current frame
	PlatformImeDataPrev : ImGuiPlatformImeData, // Previous frame data. When changed we call the platform_io.Platform_SetImeDataFn() handler.
	PlatformImeViewport : ImGuiID,

	// Extensions
	// FIXME: We could provide an API to register one slot in an array held in ImGuiContext?
	DockContext : ImGuiDockContext,
	DockNodeWindowMenuHandler : proc(	_ctx : ^ImGuiContext, 	_node : ^ImGuiDockNode, 	_tab_bar : ^ImGuiTabBar),

	// Settings
	SettingsLoaded : bool,
	SettingsDirtyTimer : f32, // Save .ini Settings to memory when time reaches zero
	SettingsIniData : ImGuiTextBuffer, // In memory .ini settings
	SettingsHandlers : ImVector(ImGuiSettingsHandler), // List of .ini settings handlers
	SettingsWindows : ImChunkStream(ImGuiWindowSettings), // ImGuiWindow .ini settings entries
	SettingsTables : ImChunkStream(ImGuiTableSettings), // ImGuiTable .ini settings entries
	Hooks : ImVector(ImGuiContextHook), // Hooks for extensions (e.g. test engine)
	HookIdNext : ImGuiID, // Next available HookId

	// Localization
	LocalizationTable : [ImGuiLocKey.ImGuiLocKey_COUNT]string,

	// Capture/Logging
	LogEnabled : bool, // Currently capturing
	LogFlags : ImGuiLogFlags, // Capture flags/type
	LogWindow : ^ImGuiWindow,
	LogFile : ImFileHandle, // If != NULL log to stdout/ file
	LogBuffer : ImGuiTextBuffer, // Accumulation buffer when log to clipboard. This is pointer so our GImGui static constructor doesn't call heap allocators.
	LogNextPrefix : string,
	LogNextSuffix : string,
	LogLinePosY : f32,
	LogLineFirstItem : bool,
	LogDepthRef : i32,
	LogDepthToExpand : i32,
	LogDepthToExpandDefault : i32, // Default/stored value for LogDepthMaxExpand if not specified in the LogXXX function call.

	// Error Handling
	ErrorCallback : ImGuiErrorCallback, // = NULL. May be exposed in public API eventually.
	ErrorCallbackUserData : rawptr, // = NULL
	ErrorTooltipLockedPos : ImVec2,
	ErrorFirst : bool,
	ErrorCountCurrentFrame : i32, // [Internal] Number of errors submitted this frame.
	StackSizesInNewFrame : ImGuiErrorRecoveryState, // [Internal]
	StackSizesInBeginForCurrentWindow : ^ImGuiErrorRecoveryState, // [Internal]

	// Debug Tools
	// (some of the highly frequently used data are interleaved in other structures above: DebugBreakXXX fields, DebugHookIdInfo, DebugLocateId etc.)
	DebugDrawIdConflictsCount : i32, // Locked count (preserved when holding CTRL)
	DebugLogFlags : ImGuiDebugLogFlags,
	DebugLogBuf : ImGuiTextBuffer,
	DebugLogIndex : ImGuiTextIndex,
	DebugLogSkippedErrors : i32,
	DebugLogAutoDisableFlags : ImGuiDebugLogFlags,
	DebugLogAutoDisableFrames : ImU8,
	DebugLocateFrames : ImU8, // For DebugLocateItemOnHover(). This is used together with DebugLocateId which is in a hot/cached spot above.
	DebugBreakInLocateId : bool, // Debug break in ItemAdd() call for g.DebugLocateId.
	DebugBreakKeyChord : ImGuiKeyChord, // = ImGuiKey_Pause
	DebugBeginReturnValueCullDepth : ImS8, // Cycle between 0..9 then wrap around.
	DebugItemPickerActive : bool, // Item picker is active (started with DebugStartItemPicker())
	DebugItemPickerMouseButton : ImU8,
	DebugItemPickerBreakId : ImGuiID, // Will call IM_DEBUG_BREAK() when encountering this ID
	DebugFlashStyleColorTime : f32,
	DebugFlashStyleColorBackup : ImVec4,
	DebugMetricsConfig : ImGuiMetricsConfig,
	DebugIDStackTool : ImGuiIDStackTool,
	DebugAllocInfo : ImGuiDebugAllocInfo,
	DebugHoveredDockNode : ^ImGuiDockNode, // Hovered dock node.

	// Misc
	FramerateSecPerFrame : [60]f32, // Calculate estimate of framerate for user over the last 60 frames..
	FramerateSecPerFrameIdx : i32,
	FramerateSecPerFrameCount : i32,
	FramerateSecPerFrameAccum : f32,
	WantCaptureMouseNextFrame : i32, // Explicit capture override via SetNextFrameWantCaptureMouse()/SetNextFrameWantCaptureKeyboard(). Default to -1.
	WantCaptureKeyboardNextFrame : i32, // "
	WantTextInputNextFrame : i32,
	TempBuffer : ImVector(u8), // Temporary text buffer
	TempKeychordName : [64]u8,
}

ImGuiContext_deinit :: proc(this : ^ImGuiContext)
{
	deinit(&this.IO)
	deinit(&this.PlatformIO)
	deinit(&this.DrawListSharedData)
	deinit(&this.InputEventsQueue)
	deinit(&this.InputEventsTrail)
	deinit(&this.Windows)
	deinit(&this.WindowsFocusOrder)
	deinit(&this.WindowsTempSortBuffer)
	deinit(&this.CurrentWindowStack)
	deinit(&this.WindowsById)
	deinit(&this.KeysRoutingTable)
	deinit(&this.ColorStack)
	deinit(&this.StyleVarStack)
	deinit(&this.FontStack)
	deinit(&this.FocusScopeStack)
	deinit(&this.ItemFlagsStack)
	deinit(&this.GroupStack)
	deinit(&this.OpenPopupStack)
	deinit(&this.BeginPopupStack)
	deinit(&this.TreeNodeStack)
	deinit(&this.Viewports)
	deinit(&this.NavFocusRoute)
	deinit(&this.DragDropPayloadBufHeap)
	deinit(&this.ClipperTempData)
	deinit(&this.TablesTempData)
	deinit(&this.Tables)
	deinit(&this.TablesLastTimeActive)
	deinit(&this.DrawChannelsTempMergeBuffer)
	deinit(&this.TabBars)
	deinit(&this.CurrentTabBarStack)
	deinit(&this.ShrinkWidthBuffer)
	deinit(&this.MultiSelectTempData)
	deinit(&this.MultiSelectStorage)
	deinit(&this.InputTextState)
	deinit(&this.InputTextDeactivatedState)
	deinit(&this.InputTextPasswordFont)
	deinit(&this.ClipboardHandlerData)
	deinit(&this.MenusIdSubmittedThisFrame)
	deinit(&this.DockContext)
	deinit(&this.SettingsIniData)
	deinit(&this.SettingsHandlers)
	deinit(&this.SettingsWindows)
	deinit(&this.SettingsTables)
	deinit(&this.Hooks)
	deinit(&this.LogBuffer)
	deinit(&this.DebugLogBuf)
	deinit(&this.DebugLogIndex)
	deinit(&this.DebugIDStackTool)
	deinit(&this.TempBuffer)
}

// Temporary storage for one window (that's the data which in theory we could ditch at the end of the frame, in practice we currently keep it for each window)
//-----------------------------------------------------------------------------
// [SECTION] ImGuiWindowTempData, ImGuiWindow
//-----------------------------------------------------------------------------

// Transient per-window data, reset at the beginning of the frame. This used to be called ImGuiDrawContext, hence the DC variable name in ImGuiWindow.
// (That's theory, in practice the delimitation between ImGuiWindow and ImGuiWindowTempData is quite tenuous and could be reconsidered..)
// (This doesn't need a constructor because we zero-clear it as part of ImGuiWindow and all frame-temporary data are setup on Begin)
ImGuiWindowTempData :: struct {
	// Layout
	CursorPos : ImVec2, // Current emitting position, in absolute coordinates.
	CursorPosPrevLine : ImVec2,
	CursorStartPos : ImVec2, // Initial position after Begin(), generally ~ window position + WindowPadding.
	CursorMaxPos : ImVec2, // Used to implicitly calculate ContentSize at the beginning of next frame, for scrolling range and auto-resize. Always growing during the frame.
	IdealMaxPos : ImVec2, // Used to implicitly calculate ContentSizeIdeal at the beginning of next frame, for auto-resize only. Always growing during the frame.
	CurrLineSize : ImVec2,
	PrevLineSize : ImVec2,
	CurrLineTextBaseOffset : f32, // Baseline offset (0.0f by default on a new line, generally == style.FramePadding.y when a framed item has been added).
	PrevLineTextBaseOffset : f32,
	IsSameLine : bool,
	IsSetPos : bool,
	Indent : ImVec1, // Indentation / start position from left of window (increased by TreePush/TreePop, etc.)
	ColumnsOffset : ImVec1, // Offset to the current column (if ColumnsCurrent > 0). FIXME: This and the above should be a stack to allow use cases like Tree->Column->Tree. Need revamp columns API.
	GroupOffset : ImVec1,
	CursorStartPosLossyness : ImVec2, // Record the loss of precision of CursorStartPos due to really large scrolling amount. This is used by clipper to compensate and fix the most common use case of large scroll area.

	// Keyboard/Gamepad navigation
	NavLayerCurrent : ImGuiNavLayer, // Current layer, 0..31 (we currently only use 0..1)
	NavLayersActiveMask : i16, // Which layers have been written to (result from previous frame)
	NavLayersActiveMaskNext : i16, // Which layers have been written to (accumulator for current frame)
	NavIsScrollPushableX : bool, // Set when current work location may be scrolled horizontally when moving left / right. This is generally always true UNLESS within a column.
	NavHideHighlightOneFrame : bool,
	NavWindowHasScrollY : bool, // Set per window when scrolling can be used (== ScrollMax.y > 0.0f)

	// Miscellaneous
	MenuBarAppending : bool, // FIXME: Remove this
	MenuBarOffset : ImVec2, // MenuBarOffset.x is sort of equivalent of a per-layer CursorPos.x, saved/restored as we switch to the menu bar. The only situation when MenuBarOffset.y is > 0 if when (SafeAreaPadding.y > FramePadding.y), often used on TVs.
	MenuColumns : ImGuiMenuColumns, // Simplified columns storage for menu items measurement
	TreeDepth : i32, // Current tree depth.
	TreeHasStackDataDepthMask : ImU32, // Store whether given depth has ImGuiTreeNodeStackData data. Could be turned into a ImU64 if necessary.
	ChildWindows : ImVector(^ImGuiWindow),
	StateStorage : ^ImGuiStorage, // Current persistent per-window storage (store e.g. tree node open/close state)
	CurrentColumns : ^ImGuiOldColumns, // Current columns set
	CurrentTableIdx : i32, // Current table index (into g.Tables)
	LayoutType : ImGuiLayoutType,
	ParentLayoutType : ImGuiLayoutType, // Layout type of parent window at the time of Begin()
	ModalDimBgColor : ImU32,

	// Local parameters stacks
	// We store the current settings outside of the vectors to increase memory locality (reduce cache misses). The vectors are rarely modified. Also it allows us to not heap allocate for short-lived windows which are not using those settings.
	ItemWidth : f32, // Current item width (>0.0: width in pixels, <0.0: align xx pixels to the right of window).
	TextWrapPos : f32, // Current text wrap pos.
	ItemWidthStack : ImVector(f32), // Store item widths to restore (attention: .back() is not == ItemWidth)
	TextWrapPosStack : ImVector(f32), // Store text wrap pos to restore (attention: .back() is not == TextWrapPos)
}

ImGuiWindowTempData_deinit :: proc(this : ^ImGuiWindowTempData)
{
	deinit(&this.ChildWindows)
	deinit(&this.ItemWidthStack)
	deinit(&this.TextWrapPosStack)
}

ImGuiWindowTempData_init :: proc(this : ^ImGuiWindowTempData)
{
	this^ = {}
	init(&this.MenuColumns)
	init(&this.ChildWindows)
	init(&this.ItemWidthStack)
	init(&this.TextWrapPosStack)
}

// Storage for one window
// Storage for one window
ImGuiWindow :: struct {
	Ctx : ^ImGuiContext, // Parent UI context (needs to be set explicitly by parent).
	Name : string, // Window name, owned by the window.
	ID : ImGuiID, // == ImHashStr(Name)
	Flags : ImGuiWindowFlags, FlagsPreviousFrame : ImGuiWindowFlags, // See enum ImGuiWindowFlags_
	ChildFlags : ImGuiChildFlags, // Set when window is a child window. See enum ImGuiChildFlags_
	WindowClass : ImGuiWindowClass, // Advanced users only. Set with SetNextWindowClass()
	Viewport : ^ImGuiViewportP, // Always set in Begin(). Inactive windows may have a NULL value here if their viewport was discarded.
	ViewportId : ImGuiID, // We backup the viewport id (since the viewport may disappear or never be created if the window is inactive)
	ViewportPos : ImVec2, // We backup the viewport position (since the viewport may disappear or never be created if the window is inactive)
	ViewportAllowPlatformMonitorExtend : i32, // Reset to -1 every frame (index is guaranteed to be valid between NewFrame..EndFrame), only used in the Appearing frame of a tooltip/popup to enforce clamping to a given monitor
	Pos : ImVec2, // Position (always rounded-up to nearest pixel)
	Size : ImVec2, // Current size (==SizeFull or collapsed title bar size)
	SizeFull : ImVec2, // Size when non collapsed
	ContentSize : ImVec2, // Size of contents/scrollable client area (calculated from the extents reach of the cursor) from previous frame. Does not include window decoration or window padding.
	ContentSizeIdeal : ImVec2,
	ContentSizeExplicit : ImVec2, // Size of contents/scrollable client area explicitly request by the user via SetNextWindowContentSize().
	WindowPadding : ImVec2, // Window padding at the time of Begin().
	WindowRounding : f32, // Window rounding at the time of Begin(). May be clamped lower to avoid rendering artifacts with title bar, menu bar etc.
	WindowBorderSize : f32, // Window border size at the time of Begin().
	TitleBarHeight : f32, MenuBarHeight : f32, // Note that those used to be function before 2024/05/28. If you have old code calling TitleBarHeight() you can change it to TitleBarHeight.
	DecoOuterSizeX1 : f32, DecoOuterSizeY1 : f32, // Left/Up offsets. Sum of non-scrolling outer decorations (X1 generally == 0.0f. Y1 generally = TitleBarHeight + MenuBarHeight). Locked during Begin().
	DecoOuterSizeX2 : f32, DecoOuterSizeY2 : f32, // Right/Down offsets (X2 generally == ScrollbarSize.x, Y2 == ScrollbarSizes.y).
	DecoInnerSizeX1 : f32, DecoInnerSizeY1 : f32, // Applied AFTER/OVER InnerRect. Specialized for Tables as they use specialized form of clipping and frozen rows/columns are inside InnerRect (and not part of regular decoration sizes).
	NameBufLen : i32, // Size of buffer storing Name. May be larger than strlen(Name)!
	MoveId : ImGuiID, // == window->GetID("#MOVE")
	TabId : ImGuiID, // == window->GetID("#TAB")
	ChildId : ImGuiID, // ID of corresponding item in parent window (for navigation to return from child window to parent window)
	PopupId : ImGuiID, // ID in the popup stack when this window is used as a popup/menu (because we use generic Name/ID for recycling)
	Scroll : ImVec2,
	ScrollMax : ImVec2,
	ScrollTarget : ImVec2, // target scroll position. stored as cursor position with scrolling canceled out, so the highest point is always 0.0f. (FLT_MAX for no change)
	ScrollTargetCenterRatio : ImVec2, // 0.0f = scroll so that target position is at top, 0.5f = scroll so that target position is centered
	ScrollTargetEdgeSnapDist : ImVec2, // 0.0f = no snapping, >0.0f snapping threshold
	ScrollbarSizes : ImVec2, // Size taken by each scrollbars on their smaller axis. Pay attention! ScrollbarSizes.x == width of the vertical scrollbar, ScrollbarSizes.y = height of the horizontal scrollbar.
	ScrollbarX : bool, ScrollbarY : bool, // Are scrollbars visible?
	ViewportOwned : bool,
	Active : bool, // Set to true on Begin(), unless Collapsed
	WasActive : bool,
	WriteAccessed : bool, // Set to true when any widget access the current window
	Collapsed : bool, // Set when collapsing window to become only title-bar
	WantCollapseToggle : bool,
	SkipItems : bool, // Set when items can safely be all clipped (e.g. window not visible or collapsed)
	SkipRefresh : bool, // [EXPERIMENTAL] Reuse previous frame drawn contents, Begin() returns false.
	Appearing : bool, // Set during the frame where the window is appearing (or re-appearing)
	Hidden : bool, // Do not display (== HiddenFrames*** > 0)
	IsFallbackWindow : bool, // Set on the "Debug##Default" window.
	IsExplicitChild : bool, // Set when passed _ChildWindow, left to false by BeginDocked()
	HasCloseButton : bool, // Set when the window has a close button (p_open != NULL)
	ResizeBorderHovered : i8, // Current border being hovered for resize (-1: none, otherwise 0-3)
	ResizeBorderHeld : i8, // Current border being held for resize (-1: none, otherwise 0-3)
	BeginCount : i16, // Number of Begin() during the current frame (generally 0 or 1, 1+ if appending via multiple Begin/End pairs)
	BeginCountPreviousFrame : i16, // Number of Begin() during the previous frame
	BeginOrderWithinParent : i16, // Begin() order within immediate parent window, if we are a child window. Otherwise 0.
	BeginOrderWithinContext : i16, // Begin() order within entire imgui context. This is mostly used for debugging submission order related issues.
	FocusOrder : i16, // Order within WindowsFocusOrder[], altered when windows are focused.
	AutoFitFramesX : ImS8, AutoFitFramesY : ImS8,
	AutoFitOnlyGrows : bool,
	AutoPosLastDirection : ImGuiDir,
	HiddenFramesCanSkipItems : ImS8, // Hide the window for N frames
	HiddenFramesCannotSkipItems : ImS8, // Hide the window for N frames while allowing items to be submitted so we can measure their size
	HiddenFramesForRenderOnly : ImS8, // Hide the window until frame N at Render() time only
	DisableInputsFrames : ImS8, // Disable window interactions for N frames
	using _0 : bit_field u32 {
		SetWindowPosAllowFlags : ImGuiCond | 8, // store acceptable condition flags for SetNextWindowPos() use.
		SetWindowSizeAllowFlags : ImGuiCond | 8, // store acceptable condition flags for SetNextWindowSize() use.
		SetWindowCollapsedAllowFlags : ImGuiCond | 8, // store acceptable condition flags for SetNextWindowCollapsed() use.
		SetWindowDockAllowFlags : ImGuiCond | 8, // store acceptable condition flags for SetNextWindowDock() use.
	},
	SetWindowPosVal : ImVec2, // store window position when using a non-zero Pivot (position set needs to be processed when we know the window size)
	SetWindowPosPivot : ImVec2, // store window pivot for positioning. ImVec2{0, 0} when positioning from top-left corner; ImVec2{0.5f, 0.5f} for centering; ImVec2{1, 1} for bottom right.

	IDStack : ImVector(ImGuiID), // ID stack. ID are hashes seeded with the value at the top of the stack. (In theory this should be in the TempData structure)
	DC : ImGuiWindowTempData, // Temporary per-window data, reset at the beginning of the frame. This used to be called ImGuiDrawContext, hence the "DC" variable name.

	// The best way to understand what those rectangles are is to use the 'Metrics->Tools->Show Windows Rectangles' viewer.
	// The main 'OuterRect', omitted as a field, is window->Rect().
	OuterRectClipped : ImRect, // == Window->Rect() just after setup in Begin(). == window->Rect() for root window.
	InnerRect : ImRect, // Inner rectangle (omit title bar, menu bar, scroll bar)
	InnerClipRect : ImRect, // == InnerRect shrunk by WindowPadding*0.5f on each side, clipped within viewport or parent clip rect.
	WorkRect : ImRect, // Initially covers the whole scrolling region. Reduced by containers e.g columns/tables when active. Shrunk by WindowPadding*1.0f on each side. This is meant to replace ContentRegionRect over time (from 1.71+ onward).
	ParentWorkRect : ImRect, // Backup of WorkRect before entering a container such as columns/tables. Used by e.g. SpanAllColumns functions to easily access. Stacked containers are responsible for maintaining this. // FIXME-WORKRECT: Could be a stack?
	ClipRect : ImRect, // Current clipping/scissoring rectangle, evolve as we are using PushClipRect(), etc. == DrawList->clip_rect_stack.back().
	ContentRegionRect : ImRect, // FIXME: This is currently confusing/misleading. It is essentially WorkRect but not handling of scrolling. We currently rely on it as right/bottom aligned sizing operation need some size to rely on.
	HitTestHoleSize : ImVec2ih, // Define an optional rectangular hole where mouse will pass-through the window.
	HitTestHoleOffset : ImVec2ih,

	LastFrameActive : i32, // Last frame number the window was Active.
	LastFrameJustFocused : i32, // Last frame number the window was made Focused.
	LastTimeActive : f32, // Last timestamp the window was Active (using float as we don't need high precision there)
	ItemWidthDefault : f32,
	StateStorage : ImGuiStorage,
	ColumnsStorage : ImVector(ImGuiOldColumns),
	FontWindowScale : f32, // User scale multiplier per-window, via SetWindowFontScale()
	FontDpiScale : f32,
	SettingsOffset : i32, // Offset into SettingsWindows[] (offsets are always valid as we only grow the array from the back)

	DrawList : ^ImDrawList, // == &DrawListInst (for backward compatibility reason with code using imgui_internal.h we keep this a pointer)
	DrawListInst : ImDrawList,
	ParentWindow : ^ImGuiWindow, // If we are a child _or_ popup _or_ docked window, this is pointing to our parent. Otherwise NULL.
	ParentWindowInBeginStack : ^ImGuiWindow,
	RootWindow : ^ImGuiWindow, // Point to ourself or first ancestor that is not a child window. Doesn't cross through popups/dock nodes.
	RootWindowPopupTree : ^ImGuiWindow, // Point to ourself or first ancestor that is not a child window. Cross through popups parent<>child.
	RootWindowDockTree : ^ImGuiWindow, // Point to ourself or first ancestor that is not a child window. Cross through dock nodes.
	RootWindowForTitleBarHighlight : ^ImGuiWindow, // Point to ourself or first ancestor which will display TitleBgActive color when this window is active.
	RootWindowForNav : ^ImGuiWindow, // Point to ourself or first ancestor which doesn't have the NavFlattened flag.
	ParentWindowForFocusRoute : ^ImGuiWindow, // Set to manual link a window to its logical parent so that Shortcut() chain are honoerd (e.g. Tool linked to Document)

	NavLastChildNavWindow : ^ImGuiWindow, // When going to the menu bar, we remember the child window we came from. (This could probably be made implicit if we kept g.Windows sorted by last focused including child window.)
	NavLastIds : [ImGuiNavLayer.ImGuiNavLayer_COUNT]ImGuiID, // Last known NavId for this window, per layer (0/1)
	NavRectRel : [ImGuiNavLayer.ImGuiNavLayer_COUNT]ImRect, // Reference rectangle, in window relative space
	NavPreferredScoringPosRel : [ImGuiNavLayer.ImGuiNavLayer_COUNT]ImVec2, // Preferred X/Y position updated when moving on a given axis, reset to FLT_MAX.
	NavRootFocusScopeId : ImGuiID, // Focus Scope ID at the time of Begin()

	MemoryDrawListIdxCapacity : i32, // Backup of last idx/vtx count, so when waking up the window we can preallocate and avoid iterative alloc/copy
	MemoryDrawListVtxCapacity : i32,
	MemoryCompacted : bool, // Set when window extraneous data have been garbage collected

	// Docking
	using _1 : bit_field u8 {
		DockIsActive : bool | 1, // When docking artifacts are actually visible. When this is set, DockNode is guaranteed to be != NULL. ~~ (DockNode != NULL) && (DockNode->Windows.Size > 1).
		DockNodeIsVisible : bool | 1,
		DockTabIsVisible : bool | 1, // Is our window visible this frame? ~~ is the corresponding tab selected?
		DockTabWantClose : bool | 1,
	},
	DockOrder : i16, // Order of the last time the window was visible within its DockNode. This is used to reorder windows that are reappearing on the same frame. Same value between windows that were active and windows that were none are possible.
	DockStyle : ImGuiWindowDockStyle,
	DockNode : ^ImGuiDockNode, // Which node are we docked into. Important: Prefer testing DockIsActive in many cases as this will still be set when the dock node is hidden.
	DockNodeAsHost : ^ImGuiDockNode, // Which node are we owning (for parent windows)
	DockId : ImGuiID, // Backup of last valid DockNode->ID, so single window remember their dock node id even when they are not bound any more
	DockTabItemStatusFlags : ImGuiItemStatusFlags,
	DockTabItemRect : ImRect,
}

// We don't use g.FontSize because the window may be != g.CurrentWindow.
ImGuiWindow_Rect :: proc(this : ^ImGuiWindow) -> ImRect { return ImRect{{this.Pos.x, this.Pos.y}, {this.Pos.x + this.Size.x, this.Pos.y + this.Size.y}} }

ImGuiWindow_CalcFontSize :: proc(this : ^ImGuiWindow) -> f32
{
	g : ^ImGuiContext = this.Ctx; scale : f32 = g.FontBaseSize * this.FontWindowScale * this.FontDpiScale; if this.ParentWindow != nil { scale *= this.ParentWindow.FontWindowScale }; return scale
}

ImGuiWindow_TitleBarRect :: proc(this : ^ImGuiWindow) -> ImRect { return ImRect{this.Pos, ImVec2{this.Pos.x + this.SizeFull.x, this.Pos.y + this.TitleBarHeight}} }

ImGuiWindow_MenuBarRect :: proc(this : ^ImGuiWindow) -> ImRect
{
	y1 : f32 = this.Pos.y + this.TitleBarHeight; return ImRect{{this.Pos.x, y1}, {this.Pos.x + this.SizeFull.x, y1 + this.MenuBarHeight}}
}

//-----------------------------------------------------------------------------
// [SECTION] Tab bar, Tab item support
//-----------------------------------------------------------------------------

// Extend ImGuiTabBarFlags_
ImGuiTabBarFlagsPrivate_ :: enum i32 {
	ImGuiTabBarFlags_DockNode = 1 << 20, // Part of a dock node [we don't use this in the master branch but it facilitate branch syncing to keep this around]
	ImGuiTabBarFlags_IsFocused = 1 << 21,
	ImGuiTabBarFlags_SaveSettings = 1 << 22, // FIXME: Settings are handled by the docking system, this only request the tab bar to mark settings dirty when reordering tabs
}

// Extend ImGuiTabItemFlags_
ImGuiTabItemFlagsPrivate_ :: enum i32 {
	ImGuiTabItemFlags_SectionMask_ = i32(ImGuiTabItemFlags_.ImGuiTabItemFlags_Leading | ImGuiTabItemFlags_.ImGuiTabItemFlags_Trailing),
	ImGuiTabItemFlags_NoCloseButton = 1 << 20, // Track whether p_open was set or not (we'll need this info on the next frame to recompute ContentWidth during layout)
	ImGuiTabItemFlags_Button = 1 << 21, // Used by TabItemButton, change the tab item behavior to mimic a button
	ImGuiTabItemFlags_Unsorted = 1 << 22, // [Docking] Trailing tabs with the _Unsorted flag will be sorted based on the DockOrder of their Window.
}

// Storage for a tab item (within a tab bar)
// Storage for one active tab item (sizeof() 48 bytes)
ImGuiTabItem :: struct {
	ID : ImGuiID,
	Flags : ImGuiTabItemFlags,
	Window : ^ImGuiWindow, // When TabItem is part of a DockNode's TabBar, we hold on to a window.
	LastFrameVisible : i32,
	LastFrameSelected : i32, // This allows us to infer an ordered list of the last activated tabs with little maintenance
	Offset : f32, // Position relative to beginning of tab
	Width : f32, // Width currently displayed
	ContentWidth : f32, // Width of label, stored during BeginTabItem() call
	RequestedWidth : f32, // Width optionally requested by caller, -1.0f is unused
	NameOffset : ImS32, // When Window==NULL, offset to name within parent ImGuiTabBar::TabsNames
	BeginOrder : ImS16, // BeginTabItem() order, used to re-order tabs after toggling ImGuiTabBarFlags_Reorderable
	IndexDuringLayout : ImS16, // Index only used during TabBarLayout(). Tabs gets reordered so 'Tabs[n].IndexDuringLayout == n' but may mismatch during additions.
	WantClose : bool, // Marked as closed by SetTabItemClosed()
}

ImGuiTabItem_init :: proc(this : ^ImGuiTabItem)
{
	this^ = {}; this.LastFrameSelected = -1; this.LastFrameVisible = this.LastFrameSelected; this.RequestedWidth = -1.0; this.NameOffset = -1; this.IndexDuringLayout = -1; this.BeginOrder = this.IndexDuringLayout
}

// Storage for a tab bar
// Storage for a tab bar (sizeof() 160 bytes)
ImGuiTabBar :: struct {
	Window : ^ImGuiWindow,
	Tabs : ImVector(ImGuiTabItem),
	Flags : ImGuiTabBarFlags,
	ID : ImGuiID, // Zero for tab-bars used by docking
	SelectedTabId : ImGuiID, // Selected tab/window
	NextSelectedTabId : ImGuiID, // Next selected tab/window. Will also trigger a scrolling animation
	VisibleTabId : ImGuiID, // Can occasionally be != SelectedTabId (e.g. when previewing contents for CTRL+TAB preview)
	CurrFrameVisible : i32,
	PrevFrameVisible : i32,
	BarRect : ImRect,
	CurrTabsContentsHeight : f32,
	PrevTabsContentsHeight : f32, // Record the height of contents submitted below the tab bar
	WidthAllTabs : f32, // Actual width of all tabs (locked during layout)
	WidthAllTabsIdeal : f32, // Ideal width if all tabs were visible and not clipped
	ScrollingAnim : f32,
	ScrollingTarget : f32,
	ScrollingTargetDistToVisibility : f32,
	ScrollingSpeed : f32,
	ScrollingRectMinX : f32,
	ScrollingRectMaxX : f32,
	SeparatorMinX : f32,
	SeparatorMaxX : f32,
	ReorderRequestTabId : ImGuiID,
	ReorderRequestOffset : ImS16,
	BeginCount : ImS8,
	WantLayout : bool,
	VisibleTabWasSubmitted : bool,
	TabsAddedNew : bool, // Set to true when a new tab item or button has been added to the tab bar during last frame
	TabsActiveCount : ImS16, // Number of tabs submitted this frame.
	LastTabItemIdx : ImS16, // Index of last BeginTabItem() tab for use by EndTabItem()
	ItemSpacingY : f32,
	FramePadding : ImVec2, // style.FramePadding locked at the time of BeginTabBar()
	BackupCursorPos : ImVec2,
	TabsNames : ImGuiTextBuffer, // For non-docking tab bar we re-append names in a contiguous buffer.
}

ImGuiTabBar_deinit :: proc(this : ^ImGuiTabBar)
{
	deinit(&this.Tabs)
	deinit(&this.TabsNames)
}

//-----------------------------------------------------------------------------
// [SECTION] Table support
//-----------------------------------------------------------------------------

IM_COL32_DISABLE : ImU32 : (0 << IM_COL32_R_SHIFT)|(0 << IM_COL32_G_SHIFT)|(0 << IM_COL32_B_SHIFT)|(1 << IM_COL32_A_SHIFT) // Special sentinel code which cannot be used as a regular color.
IMGUI_TABLE_MAX_COLUMNS :: 512// May be further lifted

// Our current column maximum is 64 but we may raise that in the future.
ImGuiTableColumnIdx :: ImS16
ImGuiTableDrawChannelIdx :: ImU16

// Storage for one column of a table
// [Internal] sizeof() ~ 112
// We use the terminology "Enabled" to refer to a column that is not Hidden by user/api.
// We use the terminology "Clipped" to refer to a column that is out of sight because of scrolling/clipping.
// This is in contrast with some user-facing api such as IsItemVisible() / IsRectVisible() which use "Visible" to mean "not clipped".
ImGuiTableColumn :: struct {
	Flags : ImGuiTableColumnFlags, // Flags after some patching (not directly same as provided by user). See ImGuiTableColumnFlags_
	WidthGiven : f32, // Final/actual width visible == (MaxX - MinX), locked in TableUpdateLayout(). May be > WidthRequest to honor minimum width, may be < WidthRequest to honor shrinking columns down in tight space.
	MinX : f32, // Absolute positions
	MaxX : f32,
	WidthRequest : f32, // Master width absolute value when !(Flags & _WidthStretch). When Stretch this is derived every frame from StretchWeight in TableUpdateLayout()
	WidthAuto : f32, // Automatic width
	WidthMax : f32, // Maximum width (FIXME: overwritten by each instance)
	StretchWeight : f32, // Master width weight when (Flags & _WidthStretch). Often around ~1.0f initially.
	InitStretchWeightOrWidth : f32, // Value passed to TableSetupColumn(). For Width it is a content width (_without padding_).
	ClipRect : ImRect, // Clipping rectangle for the column
	UserID : ImGuiID, // Optional, value passed to TableSetupColumn()
	WorkMinX : f32, // Contents region min ~(MinX + CellPaddingX + CellSpacingX1) == cursor start position when entering column
	WorkMaxX : f32, // Contents region max ~(MaxX - CellPaddingX - CellSpacingX2)
	ItemWidth : f32, // Current item width for the column, preserved across rows
	ContentMaxXFrozen : f32, // Contents maximum position for frozen rows (apart from headers), from which we can infer content width.
	ContentMaxXUnfrozen : f32,
	ContentMaxXHeadersUsed : f32, // Contents maximum position for headers rows (regardless of freezing). TableHeader() automatically softclip itself + report ideal desired size, to avoid creating extraneous draw calls
	ContentMaxXHeadersIdeal : f32,
	NameOffset : ImS16, // Offset into parent ColumnsNames[]
	DisplayOrder : ImGuiTableColumnIdx, // Index within Table's IndexToDisplayOrder[] (column may be reordered by users)
	IndexWithinEnabledSet : ImGuiTableColumnIdx, // Index within enabled/visible set (<= IndexToDisplayOrder)
	PrevEnabledColumn : ImGuiTableColumnIdx, // Index of prev enabled/visible column within Columns[], -1 if first enabled/visible column
	NextEnabledColumn : ImGuiTableColumnIdx, // Index of next enabled/visible column within Columns[], -1 if last enabled/visible column
	SortOrder : ImGuiTableColumnIdx, // Index of this column within sort specs, -1 if not sorting on this column, 0 for single-sort, may be >0 on multi-sort
	DrawChannelCurrent : ImGuiTableDrawChannelIdx, // Index within DrawSplitter.Channels[]
	DrawChannelFrozen : ImGuiTableDrawChannelIdx, // Draw channels for frozen rows (often headers)
	DrawChannelUnfrozen : ImGuiTableDrawChannelIdx, // Draw channels for unfrozen rows
	IsEnabled : bool, // IsUserEnabled && (Flags & ImGuiTableColumnFlags_Disabled) == 0
	IsUserEnabled : bool, // Is the column not marked Hidden by the user? (unrelated to being off view, e.g. clipped by scrolling).
	IsUserEnabledNextFrame : bool,
	IsVisibleX : bool, // Is actually in view (e.g. overlapping the host window clipping rectangle, not scrolled).
	IsVisibleY : bool,
	IsRequestOutput : bool, // Return value for TableSetColumnIndex() / TableNextColumn(): whether we request user to output contents or not.
	IsSkipItems : bool, // Do we want item submissions to this column to be completely ignored (no layout will happen).
	IsPreserveWidthAuto : bool,
	NavLayerCurrent : ImS8, // ImGuiNavLayer in 1 byte
	AutoFitQueue : ImU8, // Queue of 8 values for the next 8 frames to request auto-fit
	CannotSkipItemsQueue : ImU8, // Queue of 8 values for the next 8 frames to disable Clipped/SkipItem
	using _0 : bit_field u8 {
		SortDirection : ImGuiSortDirection | 2, // ImGuiSortDirection_Ascending or ImGuiSortDirection_Descending
		SortDirectionsAvailCount : ImU8 | 2, // Number of available sort directions (0 to 3)
		SortDirectionsAvailMask : ImU8 | 4, // Mask of available sort directions (1-bit each)
	},
	SortDirectionsAvailList : ImU8, // Ordered list of available sort directions (2-bits each, total 8-bits)
}

ImGuiTableColumn_init :: proc(this : ^ImGuiTableColumn)
{
	this^ = {}
	this.WidthRequest = -1.0; this.StretchWeight = this.WidthRequest
	this.NameOffset = -1
	this.IndexWithinEnabledSet = -1; this.DisplayOrder = this.IndexWithinEnabledSet
	this.NextEnabledColumn = -1; this.PrevEnabledColumn = this.NextEnabledColumn
	this.SortOrder = -1
	this.SortDirection = ImGuiSortDirection.ImGuiSortDirection_None
	this.DrawChannelUnfrozen = cast(u16) ~cast(ImU8)(0); this.DrawChannelFrozen = this.DrawChannelUnfrozen; this.DrawChannelCurrent = this.DrawChannelFrozen
}

// Transient cell data stored per row.
// sizeof() ~ 6 bytes
ImGuiTableCellData :: struct {
	BgColor : ImU32, // Actual color
	Column : ImGuiTableColumnIdx, // Column number
}

// Storage for TableAngledHeadersRow()
// Parameters for TableAngledHeadersRowEx()
// This may end up being refactored for more general purpose.
// sizeof() ~ 12 bytes
ImGuiTableHeaderData :: struct {
	Index : ImGuiTableColumnIdx, // Column index
	TextColor : ImU32,
	BgColor0 : ImU32,
	BgColor1 : ImU32,
}

// Storage for one instance of a same table
// Per-instance data that needs preserving across frames (seemingly most others do not need to be preserved aside from debug needs. Does that means they could be moved to ImGuiTableTempData?)
// sizeof() ~ 24 bytes
ImGuiTableInstanceData :: struct {
	TableInstanceID : ImGuiID,
	LastOuterHeight : f32, // Outer height from last frame
	LastTopHeadersRowHeight : f32, // Height of first consecutive header rows from last frame (FIXME: this is used assuming consecutive headers are in same frozen set)
	LastFrozenHeight : f32, // Height of frozen section from last frame
	HoveredRowLast : i32, // Index of row which was hovered last frame.
	HoveredRowNext : i32, // Index of row hovered this frame, set after encountering it.
}

ImGuiTableInstanceData_init :: proc(this : ^ImGuiTableInstanceData)
{
	this.TableInstanceID = 0; this.LastFrozenHeight = 0.0; this.LastTopHeadersRowHeight = this.LastFrozenHeight; this.LastOuterHeight = this.LastTopHeadersRowHeight; this.HoveredRowNext = -1; this.HoveredRowLast = this.HoveredRowNext
}

// Storage for a table
// sizeof() ~ 592 bytes + heap allocs described in TableBeginInitMemory()
ImGuiTable :: struct {
	ID : ImGuiID,
	Flags : ImGuiTableFlags,
	RawData : rawptr, // Single allocation to hold Columns[], DisplayOrderToIndex[] and RowCellData[]
	TempData : ^ImGuiTableTempData, // Transient data while table is active. Point within g.CurrentTableStack[]
	Columns : ImSpan(ImGuiTableColumn), // Point within RawData[]
	DisplayOrderToIndex : ImSpan(ImGuiTableColumnIdx), // Point within RawData[]. Store display order of columns (when not reordered, the values are 0...Count-1)
	RowCellData : ImSpan(ImGuiTableCellData), // Point within RawData[]. Store cells background requests for current row.
	EnabledMaskByDisplayOrder : ImBitArrayPtr, // Column DisplayOrder -> IsEnabled map
	EnabledMaskByIndex : ImBitArrayPtr, // Column Index -> IsEnabled map (== not hidden by user/api) in a format adequate for iterating column without touching cold data
	VisibleMaskByIndex : ImBitArrayPtr, // Column Index -> IsVisibleX|IsVisibleY map (== not hidden by user/api && not hidden by scrolling/cliprect)
	SettingsLoadedFlags : ImGuiTableFlags, // Which data were loaded from the .ini file (e.g. when order is not altered we won't save order)
	SettingsOffset : i32, // Offset in g.SettingsTables
	LastFrameActive : i32,
	ColumnsCount : i32, // Number of columns declared in BeginTable()
	CurrentRow : i32,
	CurrentColumn : i32,
	InstanceCurrent : ImS16, // Count of BeginTable() calls with same ID in the same frame (generally 0). This is a little bit similar to BeginCount for a window, but multiple table with same ID look are multiple tables, they are just synched.
	InstanceInteracted : ImS16, // Mark which instance (generally 0) of the same ID is being interacted with
	RowPosY1 : f32,
	RowPosY2 : f32,
	RowMinHeight : f32, // Height submitted to TableNextRow()
	RowCellPaddingY : f32, // Top and bottom padding. Reloaded during row change.
	RowTextBaseline : f32,
	RowIndentOffsetX : f32,
	using _0 : bit_field u32 {
		RowFlags : ImGuiTableRowFlags | 16, // Current row flags, see ImGuiTableRowFlags_
		LastRowFlags : ImGuiTableRowFlags | 16,
	},
	RowBgColorCounter : i32, // Counter for alternating background colors (can be fast-forwarded by e.g clipper), not same as CurrentRow because header rows typically don't increase this.
	RowBgColor : [2]ImU32, // Background color override for current row.
	BorderColorStrong : ImU32,
	BorderColorLight : ImU32,
	BorderX1 : f32,
	BorderX2 : f32,
	HostIndentX : f32,
	MinColumnWidth : f32,
	OuterPaddingX : f32,
	CellPaddingX : f32, // Padding from each borders. Locked in BeginTable()/Layout.
	CellSpacingX1 : f32, // Spacing between non-bordered cells. Locked in BeginTable()/Layout.
	CellSpacingX2 : f32,
	InnerWidth : f32, // User value passed to BeginTable(), see comments at the top of BeginTable() for details.
	ColumnsGivenWidth : f32, // Sum of current column width
	ColumnsAutoFitWidth : f32, // Sum of ideal column width in order nothing to be clipped, used for auto-fitting and content width submission in outer window
	ColumnsStretchSumWeights : f32, // Sum of weight of all enabled stretching columns
	ResizedColumnNextWidth : f32,
	ResizeLockMinContentsX2 : f32, // Lock minimum contents width while resizing down in order to not create feedback loops. But we allow growing the table.
	RefScale : f32, // Reference scale to be able to rescale columns on font/dpi changes.
	AngledHeadersHeight : f32, // Set by TableAngledHeadersRow(), used in TableUpdateLayout()
	AngledHeadersSlope : f32, // Set by TableAngledHeadersRow(), used in TableUpdateLayout()
	OuterRect : ImRect, // Note: for non-scrolling table, OuterRect.Max.y is often FLT_MAX until EndTable(), unless a height has been specified in BeginTable().
	InnerRect : ImRect, // InnerRect but without decoration. As with OuterRect, for non-scrolling tables, InnerRect.Max.y is
	WorkRect : ImRect,
	InnerClipRect : ImRect,
	BgClipRect : ImRect, // We use this to cpu-clip cell background color fill, evolve during the frame as we cross frozen rows boundaries
	Bg0ClipRectForDrawCmd : ImRect, // Actual ImDrawCmd clip rect for BG0/1 channel. This tends to be == OuterWindow->ClipRect at BeginTable() because output in BG0/BG1 is cpu-clipped
	Bg2ClipRectForDrawCmd : ImRect, // Actual ImDrawCmd clip rect for BG2 channel. This tends to be a correct, tight-fit, because output to BG2 are done by widgets relying on regular ClipRect.
	HostClipRect : ImRect, // This is used to check if we can eventually merge our columns draw calls into the current draw call of the current window.
	HostBackupInnerClipRect : ImRect, // Backup of InnerWindow->ClipRect during PushTableBackground()/PopTableBackground()
	OuterWindow : ^ImGuiWindow, // Parent window for the table
	InnerWindow : ^ImGuiWindow, // Window holding the table data (== OuterWindow or a child window)
	ColumnsNames : ImGuiTextBuffer, // Contiguous buffer holding columns names
	DrawSplitter : ^ImDrawListSplitter, // Shortcut to TempData->DrawSplitter while in table. Isolate draw commands per columns to avoid switching clip rect constantly
	InstanceDataFirst : ImGuiTableInstanceData,
	InstanceDataExtra : ImVector(ImGuiTableInstanceData), // FIXME-OPT: Using a small-vector pattern would be good.
	SortSpecsSingle : ImGuiTableColumnSortSpecs,
	SortSpecsMulti : ImVector(ImGuiTableColumnSortSpecs), // FIXME-OPT: Using a small-vector pattern would be good.
	SortSpecs : ImGuiTableSortSpecs, // Public facing sorts specs, this is what we return in TableGetSortSpecs()
	SortSpecsCount : ImGuiTableColumnIdx,
	ColumnsEnabledCount : ImGuiTableColumnIdx, // Number of enabled columns (<= ColumnsCount)
	ColumnsEnabledFixedCount : ImGuiTableColumnIdx, // Number of enabled columns using fixed width (<= ColumnsCount)
	DeclColumnsCount : ImGuiTableColumnIdx, // Count calls to TableSetupColumn()
	AngledHeadersCount : ImGuiTableColumnIdx, // Count columns with angled headers
	HoveredColumnBody : ImGuiTableColumnIdx, // Index of column whose visible region is being hovered. Important: == ColumnsCount when hovering empty region after the right-most column!
	HoveredColumnBorder : ImGuiTableColumnIdx, // Index of column whose right-border is being hovered (for resizing).
	HighlightColumnHeader : ImGuiTableColumnIdx, // Index of column which should be highlighted.
	AutoFitSingleColumn : ImGuiTableColumnIdx, // Index of single column requesting auto-fit.
	ResizedColumn : ImGuiTableColumnIdx, // Index of column being resized. Reset when InstanceCurrent==0.
	LastResizedColumn : ImGuiTableColumnIdx, // Index of column being resized from previous frame.
	HeldHeaderColumn : ImGuiTableColumnIdx, // Index of column header being held.
	ReorderColumn : ImGuiTableColumnIdx, // Index of column being reordered. (not cleared)
	ReorderColumnDir : ImGuiTableColumnIdx, // -1 or +1
	LeftMostEnabledColumn : ImGuiTableColumnIdx, // Index of left-most non-hidden column.
	RightMostEnabledColumn : ImGuiTableColumnIdx, // Index of right-most non-hidden column.
	LeftMostStretchedColumn : ImGuiTableColumnIdx, // Index of left-most stretched column.
	RightMostStretchedColumn : ImGuiTableColumnIdx, // Index of right-most stretched column.
	ContextPopupColumn : ImGuiTableColumnIdx, // Column right-clicked on, of -1 if opening context menu from a neutral/empty spot
	FreezeRowsRequest : ImGuiTableColumnIdx, // Requested frozen rows count
	FreezeRowsCount : ImGuiTableColumnIdx, // Actual frozen row count (== FreezeRowsRequest, or == 0 when no scrolling offset)
	FreezeColumnsRequest : ImGuiTableColumnIdx, // Requested frozen columns count
	FreezeColumnsCount : ImGuiTableColumnIdx, // Actual frozen columns count (== FreezeColumnsRequest, or == 0 when no scrolling offset)
	RowCellDataCurrent : ImGuiTableColumnIdx, // Index of current RowCellData[] entry in current row
	DummyDrawChannel : ImGuiTableDrawChannelIdx, // Redirect non-visible columns here.
	Bg2DrawChannelCurrent : ImGuiTableDrawChannelIdx, // For Selectable() and other widgets drawing across columns after the freezing line. Index within DrawSplitter.Channels[]
	Bg2DrawChannelUnfrozen : ImGuiTableDrawChannelIdx,
	IsLayoutLocked : bool, // Set by TableUpdateLayout() which is called when beginning the first row.
	IsInsideRow : bool, // Set when inside TableBeginRow()/TableEndRow().
	IsInitializing : bool,
	IsSortSpecsDirty : bool,
	IsUsingHeaders : bool, // Set when the first row had the ImGuiTableRowFlags_Headers flag.
	IsContextPopupOpen : bool, // Set when default context menu is open (also see: ContextPopupColumn, InstanceInteracted).
	DisableDefaultContextMenu : bool, // Disable default context menu contents. You may submit your own using TableBeginContextMenuPopup()/EndPopup()
	IsSettingsRequestLoad : bool,
	IsSettingsDirty : bool, // Set when table settings have changed and needs to be reported into ImGuiTableSetttings data.
	IsDefaultDisplayOrder : bool, // Set when display order is unchanged from default (DisplayOrder contains 0...Count-1)
	IsResetAllRequest : bool,
	IsResetDisplayOrderRequest : bool,
	IsUnfrozenRows : bool, // Set when we got past the frozen row.
	IsDefaultSizingPolicy : bool, // Set if user didn't explicitly set a sizing policy in BeginTable()
	IsActiveIdAliveBeforeTable : bool,
	IsActiveIdInTable : bool,
	HasScrollbarYCurr : bool, // Whether ANY instance of this table had a vertical scrollbar during the current frame.
	HasScrollbarYPrev : bool, // Whether ANY instance of this table had a vertical scrollbar during the previous.
	MemoryCompacted : bool,
	HostSkipItems : bool, // Backup of InnerWindow->SkipItem at the end of BeginTable(), because we will overwrite InnerWindow->SkipItem on a per-column basis
}

ImGuiTable_deinit :: proc(this : ^ImGuiTable)
{
	deinit(&this.ColumnsNames)
	deinit(&this.InstanceDataExtra)
	deinit(&this.SortSpecsMulti)
	IM_FREE(this.RawData)
}

ImGuiTable_init :: proc(this : ^ImGuiTable)
{
	this^ = {}; this.LastFrameActive = -1
}

// Temporary storage for one table (one per table in the stack), shared between tables.
// Transient data that are only needed between BeginTable() and EndTable(), those buffers are shared (1 per level of stacked table).
// - Accessing those requires chasing an extra pointer so for very frequently used data we leave them in the main table structure.
// - We also leave out of this structure data that tend to be particularly useful for debugging/metrics.
// FIXME-TABLE: more transient data could be stored in a stacked ImGuiTableTempData: e.g. SortSpecs.
// sizeof() ~ 136 bytes.
ImGuiTableTempData :: struct {
	TableIndex : i32, // Index in g.Tables.Buf.Data[] pool
	LastTimeActive : f32, // Last timestamp this structure was used
	AngledHeadersExtraWidth : f32, // Used in EndTable()
	AngledHeadersRequests : ImVector(ImGuiTableHeaderData), // Used in TableAngledHeadersRow()

	UserOuterSize : ImVec2, // outer_size.x passed to BeginTable()
	DrawSplitter : ImDrawListSplitter,

	HostBackupWorkRect : ImRect, // Backup of InnerWindow->WorkRect at the end of BeginTable()
	HostBackupParentWorkRect : ImRect, // Backup of InnerWindow->ParentWorkRect at the end of BeginTable()
	HostBackupPrevLineSize : ImVec2, // Backup of InnerWindow->DC.PrevLineSize at the end of BeginTable()
	HostBackupCurrLineSize : ImVec2, // Backup of InnerWindow->DC.CurrLineSize at the end of BeginTable()
	HostBackupCursorMaxPos : ImVec2, // Backup of InnerWindow->DC.CursorMaxPos at the end of BeginTable()
	HostBackupColumnsOffset : ImVec1, // Backup of OuterWindow->DC.ColumnsOffset at the end of BeginTable()
	HostBackupItemWidth : f32, // Backup of OuterWindow->DC.ItemWidth at the end of BeginTable()
	HostBackupItemWidthStackSize : i32, //Backup of OuterWindow->DC.ItemWidthStack.Size at the end of BeginTable()
}

ImGuiTableTempData_deinit :: proc(this : ^ImGuiTableTempData)
{
	deinit(&this.AngledHeadersRequests)
	deinit(&this.DrawSplitter)
}

ImGuiTableTempData_init :: proc(this : ^ImGuiTableTempData)
{
	this^ = {}; this.LastTimeActive = -1.0
}

// sizeof() ~ 12
ImGuiTableColumnSettings :: struct {
	WidthOrWeight : f32,
	UserID : ImGuiID,
	Index : ImGuiTableColumnIdx,
	DisplayOrder : ImGuiTableColumnIdx,
	SortOrder : ImGuiTableColumnIdx,
	using _0 : bit_field u8 {
		SortDirection : ImGuiSortDirection | 2,
		IsEnabled : bool | 1, // "Visible" in ini file
		IsStretch : bool | 1,
	},
}

ImGuiTableColumnSettings_init :: proc(this : ^ImGuiTableColumnSettings)
{
	this.WidthOrWeight = 0.0
	this.UserID = 0
	this.Index = -1
	this.SortOrder = -1; this.DisplayOrder = this.SortOrder
	this.SortDirection = ImGuiSortDirection.ImGuiSortDirection_None
	this.IsEnabled = true
	this.IsStretch = false
}

// Storage for a table .ini settings
// This is designed to be stored in a single ImChunkStream (1 header followed by N ImGuiTableColumnSettings, etc.)
ImGuiTableSettings :: struct {
	ID : ImGuiID, // Set to 0 to invalidate/delete the setting
	SaveFlags : ImGuiTableFlags, // Indicate data we want to save using the Resizable/Reorderable/Sortable/Hideable flags (could be using its own flags..)
	RefScale : f32, // Reference scale to be able to rescale columns on font/dpi changes.
	ColumnsCount : ImGuiTableColumnIdx,
	ColumnsCountMax : ImGuiTableColumnIdx, // Maximum number of columns this settings instance can store, we can recycle a settings instance with lower number of columns but not higher
	WantApply : bool, // Set when loaded from .ini data (to enable merging/loading .ini data into an already running context)
}

ImGuiTableSettings_init :: proc(this : ^ImGuiTableSettings) { this^ = {} }

ImGuiTableSettings_GetColumnSettings :: proc(this : ^ImGuiTableSettings) -> [^]ImGuiTableColumnSettings { return cast([^]ImGuiTableColumnSettings) mem.ptr_offset(this, 1) }

//-----------------------------------------------------------------------------
// [SECTION] ImGui internal API
// No guarantee of forward compatibility here!
//-----------------------------------------------------------------------------

GetCurrentWindowRead :: #force_inline proc() -> ^ImGuiWindow
{
	g : ^ImGuiContext = GImGui; return g.CurrentWindow
}
GetCurrentWindow :: #force_inline proc() -> ^ImGuiWindow
{
	g : ^ImGuiContext = GImGui; g.CurrentWindow.WriteAccessed = true; return g.CurrentWindow
}
// You may also use SetNextWindowClass()'s FocusRouteParentWindowId field.
SetWindowParentWindowForFocusRoute :: #force_inline proc(window : ^ImGuiWindow, parent_window : ^ImGuiWindow) { window.ParentWindowForFocusRoute = parent_window }
WindowRectAbsToRel :: #force_inline proc(window : ^ImGuiWindow, r : ImRect) -> ImRect
{
	off : ImVec2 = window.DC.CursorStartPos; return ImRect{{r.Min.x - off.x, r.Min.y - off.y}, {r.Max.x - off.x, r.Max.y - off.y}}
}
WindowRectRelToAbs :: #force_inline proc(window : ^ImGuiWindow, r : ImRect) -> ImRect
{
	off : ImVec2 = window.DC.CursorStartPos; return ImRect{{r.Min.x + off.x, r.Min.y + off.y}, {r.Max.x + off.x, r.Max.y + off.y}}
}
WindowPosAbsToRel :: #force_inline proc(window : ^ImGuiWindow, p : ImVec2) -> ImVec2
{
	off : ImVec2 = window.DC.CursorStartPos; return ImVec2{p.x - off.x, p.y - off.y}
}
WindowPosRelToAbs :: #force_inline proc(window : ^ImGuiWindow, p : ImVec2) -> ImVec2
{
	off : ImVec2 = window.DC.CursorStartPos; return ImVec2{p.x + off.x, p.y + off.y}
}

GetDefaultFont :: #force_inline proc() -> ^ImFont
{
	g : ^ImGuiContext = GImGui; return g.IO.FontDefault != nil ? g.IO.FontDefault : g.IO.Fonts.Fonts.Data[0]
}
// get foreground draw list for the given viewport or viewport associated to the current window. this draw list will be the top-most rendered one. Useful to quickly draw shapes/text over dear imgui contents.
GetForegroundDrawList_w :: #force_inline proc(window : ^ImGuiWindow = nil) -> ^ImDrawList { return GetForegroundDrawList(window.Viewport) }
LocalizeGetMsg :: #force_inline proc(key : ImGuiLocKey) -> string
{
	g : ^ImGuiContext = GImGui; msg := g.LocalizationTable[key]; return msg != "" ? msg : "*Missing Text*"
}

//#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
ScrollToBringRectIntoView :: #force_inline proc(window : ^ImGuiWindow, rect : ImRect) { ScrollToRect(window, rect, ImGuiScrollFlags_.ImGuiScrollFlags_KeepVisibleEdgeY) }
//#endif

// Basic Accessors
GetItemStatusFlags :: #force_inline proc() -> ImGuiItemStatusFlags
{
	g : ^ImGuiContext = GImGui; return g.LastItemData.StatusFlags
}
GetItemFlags :: #force_inline proc() -> ImGuiItemFlags
{
	g : ^ImGuiContext = GImGui; return g.LastItemData.ItemFlags
}
GetActiveID :: #force_inline proc() -> ImGuiID
{
	g : ^ImGuiContext = GImGui; return g.ActiveId
}
GetFocusID :: #force_inline proc() -> ImGuiID
{
	g : ^ImGuiContext = GImGui; return g.NavId
}
// Basic Helpers for widget code
// FIXME: This is a misleading API since we expect CursorPos to be bb.Min.
ItemSize_0 :: #force_inline proc(bb : ImRect, text_baseline_y : f32 = -1.0) { ItemSize(GetSize(bb), text_baseline_y) }
// Inputs
// FIXME: Eventually we should aim to move e.g. IsActiveIdUsingKey() into IsKeyXXX functions.
IsNamedKey :: #force_inline proc(key : ImGuiKey) -> bool { return key >= ImGuiKey.ImGuiKey_NamedKey_BEGIN && key < ImGuiKey.ImGuiKey_NamedKey_END }
IsNamedKeyOrMod :: #force_inline proc(key : ImGuiKey) -> bool { return (key >= ImGuiKey.ImGuiKey_NamedKey_BEGIN && key < ImGuiKey.ImGuiKey_NamedKey_END) || key == ImGuiKey.ImGuiMod_Ctrl || key == ImGuiKey.ImGuiMod_Shift || key == ImGuiKey.ImGuiMod_Alt || key == ImGuiKey.ImGuiMod_Super }
IsLegacyKey :: #force_inline proc(key : ImGuiKey) -> bool { return key >= ImGuiKey_LegacyNativeKey_BEGIN && key < ImGuiKey_LegacyNativeKey_END }
IsKeyboardKey :: #force_inline proc(key : ImGuiKey) -> bool { return key >= ImGuiKey_Keyboard_BEGIN && key < ImGuiKey_Keyboard_END }
IsGamepadKey :: #force_inline proc(key : ImGuiKey) -> bool { return key >= ImGuiKey_Gamepad_BEGIN && key < ImGuiKey_Gamepad_END }
IsMouseKey :: #force_inline proc(key : ImGuiKey) -> bool { return key >= ImGuiKey_Mouse_BEGIN && key < ImGuiKey_Mouse_END }
IsAliasKey :: #force_inline proc(key : ImGuiKey) -> bool { return key >= ImGuiKey_Aliases_BEGIN && key < ImGuiKey_Aliases_END }
IsLRModKey :: #force_inline proc(key : ImGuiKey) -> bool { return key >= ImGuiKey.ImGuiKey_LeftCtrl && key <= ImGuiKey.ImGuiKey_RightSuper }
ConvertSingleModFlagToKey :: #force_inline proc(key : ImGuiKey) -> ImGuiKey
{
	if key == ImGuiKey.ImGuiMod_Ctrl { return ImGuiKey.ImGuiKey_ReservedForModCtrl }
	if key == ImGuiKey.ImGuiMod_Shift { return ImGuiKey.ImGuiKey_ReservedForModShift }
	if key == ImGuiKey.ImGuiMod_Alt { return ImGuiKey.ImGuiKey_ReservedForModAlt }
	if key == ImGuiKey.ImGuiMod_Super { return ImGuiKey.ImGuiKey_ReservedForModSuper }
	return key
}

GetKeyData_k :: #force_inline proc(key : ImGuiKey) -> ^ImGuiKeyData
{
	g : ^ImGuiContext = GImGui; return GetKeyData(g, key)
}
MouseButtonToKey :: #force_inline proc(button : ImGuiMouseButton) -> ImGuiKey
{
	IM_ASSERT(cast(i32) button >= 0 && button < ImGuiMouseButton_.ImGuiMouseButton_COUNT); return cast(ImGuiKey) (ImGuiKey.ImGuiKey_MouseLeft + cast(ImGuiKey) button)
}
IsActiveIdUsingNavDir :: #force_inline proc(dir : ImGuiDir) -> bool
{
	g : ^ImGuiContext = GImGui; return (g.ActiveIdUsingNavDirMask & (1 << cast(u32) dir)) != {}
}

GetKeyOwnerData :: #force_inline proc(ctx : ^ImGuiContext, key : ImGuiKey) -> ^ImGuiKeyOwnerData
{
	key := key
	if (key & ImGuiKey.ImGuiMod_Mask_) != {} { key = ConvertSingleModFlagToKey(key) }; IM_ASSERT(IsNamedKey(key)); return &ctx.KeysOwnerData[key - ImGuiKey.ImGuiKey_NamedKey_BEGIN]
}

DockNodeGetRootNode :: #force_inline proc(node : ^ImGuiDockNode) -> ^ImGuiDockNode
{
	node := node
	for node.ParentNode != nil { node = node.ParentNode }; return node
}
DockNodeIsInHierarchyOf :: #force_inline proc(node : ^ImGuiDockNode, parent : ^ImGuiDockNode) -> bool
{
	node := node
	for node != nil {if node == parent { return true }; node = node.ParentNode	}; return false
}
DockNodeGetDepth :: #force_inline proc(node : ^ImGuiDockNode) -> i32
{
	node := node
	depth : i32 = 0; for node.ParentNode != nil {node = node.ParentNode; post_incr(&depth)	}; return depth
}
DockNodeGetWindowMenuButtonId :: #force_inline proc(node : ^ImGuiDockNode) -> ImGuiID { return ImHashStr("#COLLAPSE", node.ID) }
GetWindowDockNode :: #force_inline proc() -> ^ImGuiDockNode
{
	g : ^ImGuiContext = GImGui; return g.CurrentWindow.DockNode
}
DockBuilderGetCentralNode :: #force_inline proc(node_id : ImGuiID) -> ^ImGuiDockNode
{
	node : ^ImGuiDockNode = DockBuilderGetNode(node_id); if node == nil { return nil }; return DockNodeGetRootNode(node).CentralNode
}
// Focus scope we are outputting into, set by PushFocusScope()
GetCurrentFocusScope :: #force_inline proc() -> ImGuiID
{
	g : ^ImGuiContext = GImGui; return g.CurrentFocusScopeId
}

GetBoxSelectState :: #force_inline proc(id : ImGuiID) -> ^ImGuiBoxSelectState
{
	g : ^ImGuiContext = GImGui; return (id != 0 && g.BoxSelectState.ID == id && g.BoxSelectState.IsActive) ? &g.BoxSelectState : nil
}
GetMultiSelectState :: #force_inline proc(id : ImGuiID) -> ^ImGuiMultiSelectState
{
	g : ^ImGuiContext = GImGui; return GetByKey(&g.MultiSelectStorage, id)
}

// Tables: Internals
GetCurrentTable :: #force_inline proc() -> ^ImGuiTable
{
	g : ^ImGuiContext = GImGui; return g.CurrentTable
}
TableGetInstanceData :: #force_inline proc(table : ^ImGuiTable, instance_no : i32) -> ^ImGuiTableInstanceData
{
	if instance_no == 0 { return &table.InstanceDataFirst }; return &table.InstanceDataExtra.Data[instance_no - 1]
}
TableGetInstanceID :: #force_inline proc(table : ^ImGuiTable, instance_no : i32) -> ImGuiID { return TableGetInstanceData(table, instance_no).TableInstanceID }
// Tab Bars
GetCurrentTabBar :: #force_inline proc() -> ^ImGuiTabBar
{
	g : ^ImGuiContext = GImGui; return g.CurrentTabBar
}
TabBarGetTabOrder :: #force_inline proc(tab_bar : ^ImGuiTabBar, tab : ^ImGuiTabItem) -> i32 { return index_from_ptr(&tab_bar.Tabs, tab) }

TempInputIsActive :: #force_inline proc(id : ImGuiID) -> bool
{
	g : ^ImGuiContext = GImGui; return (g.ActiveId == id && g.TempInputId == id)
}
// Get input text state if active
GetInputTextState :: #force_inline proc(id : ImGuiID) -> ^ImGuiInputTextState
{
	g : ^ImGuiContext = GImGui; return (id != 0 && g.InputTextState.ID == id) ? &g.InputTextState : nil
}


// namespace ImGui


// Opaque interface to a font builder (stb_truetype or FreeType).
//-----------------------------------------------------------------------------
// [SECTION] ImFontAtlas internal API
//-----------------------------------------------------------------------------

// This structure is likely to evolve as we add support for incremental atlas updates.
// Conceptually this could be in ImGuiPlatformIO, but we are far from ready to make this public.
ImFontBuilderIO :: struct {
	FontBuilder_Build : proc(atlas : ^ImFontAtlas) -> bool,
}

// Helper for font builder
when IMGUI_ENABLE_STB_TRUETYPE { /* @gen ifdef */
} // preproc endif
//-----------------------------------------------------------------------------
// [SECTION] Test Engine specific hooks (imgui_test_engine)
//-----------------------------------------------------------------------------

when IMGUI_ENABLE_TEST_ENGINE {
// In IMGUI_VERSION_NUM >= 18934: changed IMGUI_TEST_ENGINE_ITEM_ADD(bb,id) to IMGUI_TEST_ENGINE_ITEM_ADD(id,bb,item_data);
IMGUI_TEST_ENGINE_ITEM_ADD :: #force_inline proc "contextless" (g : ^ImGuiContext, _ID : $T0, _BB : $T1, _ITEM_DATA : $T2) //TODO @gen: Validate the parameters were not passed by reference.
{
	if(g.TestEngineHookItems) { ImGuiTestEngineHook_ItemAdd(g,_ID,_BB,_ITEM_DATA) } // Register item bounding box
}

IMGUI_TEST_ENGINE_ITEM_INFO :: #force_inline proc "contextless" (g : ^ImGuiContext, _ID : $T0, _LABEL : $T1, _FLAGS : $T2) //TODO @gen: Validate the parameters were not passed by reference.
{
	if(g.TestEngineHookItems) { ImGuiTestEngineHook_ItemInfo(g,_ID,_LABEL,_FLAGS) } // Register item label and status flags (optional)
}

IMGUI_TEST_ENGINE_LOG :: #force_inline proc "contextless" (g : ^ImGuiContext, _FMT : $T0, args : ..any) //TODO @gen: Validate the parameters were not passed by reference.
{
	ImGuiTestEngineHook_Log(g,_FMT,__VA_ARGS__)// Custom log entry from user land into test log
}

} else { // preproc else
IMGUI_TEST_ENGINE_ITEM_ADD :: #force_inline proc "contextless" (g : ^ImGuiContext, _BB : $T0, _ID : $T1)
{
	_ = _BB; _ = _ID
}

IMGUI_TEST_ENGINE_ITEM_INFO :: #force_inline proc "contextless" (g : ^ImGuiContext, _ID : $T0, _LABEL : $T1, _FLAGS : $T2) //TODO @gen: Validate the parameters were not passed by reference.
{
	_ = _ID ; _ = _LABEL ; _ = _FLAGS
}

} // preproc endif

//-----------------------------------------------------------------------------

// Debug options
IMGUI_DEBUG_NAV_SCORING :: false// Display navigation scoring preview when hovering items. Hold CTRL to display for all candidates. CTRL+Arrow to change last direction.
IMGUI_DEBUG_NAV_RECTS :: false// Display the reference navigation rectangle for each window

// When using CTRL+TAB (or Gamepad Square+L/R) we delay the visual a little in order to reduce visual noise doing a fast switch.
NAV_WINDOWING_HIGHLIGHT_DELAY : f32 = 0.20; // Time before the highlight and screen dimming starts fading in
NAV_WINDOWING_LIST_APPEAR_DELAY : f32 = 0.15; // Time before the window list starts to appear

NAV_ACTIVATE_HIGHLIGHT_TIMER : f32 = 0.10; // Time to highlight an item activated by a shortcut.

// Window resizing from edges (when io.ConfigWindowsResizeFromEdges = true and ImGuiBackendFlags_HasMouseCursors is set in io.BackendFlags by backend)
WINDOWS_HOVER_PADDING : f32 = 4.0; // Extend outside window for hovering/resizing (maxxed with TouchPadding) and inside windows for borders. Affect FindHoveredWindow().
WINDOWS_RESIZE_FROM_EDGES_FEEDBACK_TIMER : f32 = 0.04; // Reduce visual noise by only highlighting the border after a certain time.
WINDOWS_MOUSE_WHEEL_SCROLL_LOCK_TIMER : f32 = 0.70; // Lock scrolled window (so it doesn't pick child windows that are scrolling through) for a certain time, unless mouse moved.

// Tooltip offset
TOOLTIP_DEFAULT_OFFSET_MOUSE : ImVec2 = ImVec2{ 16 ,  10 }; // Multiplied by g.Style.MouseCursorScale
TOOLTIP_DEFAULT_OFFSET_TOUCH : ImVec2 = ImVec2{ 0  , -20 }; // Multiplied by g.Style.MouseCursorScale
TOOLTIP_DEFAULT_PIVOT_TOUCH  : ImVec2 = ImVec2{ 0.5, 1.0 }; // Multiplied by g.Style.MouseCursorScale

// Docking
DOCKING_TRANSPARENT_PAYLOAD_ALPHA : f32 = 0.50; // For use with io.ConfigDockingTransparentPayload. Apply to Viewport _or_ WindowBg in host viewport.

// Viewports
IMGUI_VIEWPORT_DEFAULT_ID : ImGuiID = 0x11111111; // Using an arbitrary constant instead of e.g. ImHashStr("ViewportDefault", 0); so it's easier to spot in the debugger. The exact value doesn't matter.
//-----------------------------------------------------------------------------
// [SECTION] CONTEXT AND MEMORY ALLOCATORS
//-----------------------------------------------------------------------------

// DLL users:
// - Heaps and globals are not shared across DLL boundaries!
// - You will need to call SetCurrentContext() + SetAllocatorFunctions() for each static/DLL boundary you are calling from.
// - Same applies for hot-reloading mechanisms that are reliant on reloading DLL (note that many hot-reloading mechanisms work without DLL).
// - Using Dear ImGui via a shared library is not recommended, because of function call overhead and because we don't guarantee backward nor forward ABI compatibility.
// - Confused? In a debugger: add GImGui to your watch window and notice how its value changes depending on your current location (which DLL boundary you are in).

// Current context pointer. Implicitly used by all Dear ImGui functions. Always assumed to be != NULL.
// - ImGui::CreateContext() will automatically set this pointer if it is NULL.
//   Change to a different context by calling ImGui::SetCurrentContext().
// - Important: Dear ImGui functions are not thread-safe because of this pointer.
//   If you want thread-safety to allow N threads to access N different contexts:
//   - Change this variable to use thread local storage so each thread can refer to a different context, in your imconfig.h:
//         struct ImGuiContext;
//         extern thread_local ImGuiContext* MyImGuiTLS;
//         #define GImGui MyImGuiTLS
//     And then define MyImGuiTLS in one of your cpp files. Note that thread_local is a C++11 keyword, earlier C++ uses compiler-specific keyword.
//   - Future development aims to make this context pointer explicit to all calls. Also read https://github.com/ocornut/imgui/issues/586
//   - If you need a finite number of contexts, you may compile and use multiple instances of the ImGui code from a different namespace.
// - DLL users: read comments above.
GImGui : ^ImGuiContext = nil

// Memory Allocator functions. Use SetAllocatorFunctions() to change them.
// - You probably don't want to modify that mid-program, and if you use global/static e.g. ImVector<> instances you may need to keep them accessible during program destruction.
// - DLL users: read comments above.
when ! IMGUI_DISABLE_DEFAULT_ALLOCATORS {
MallocWrapper :: proc(size : uint, user_data : rawptr) -> rawptr
{
	IM_UNUSED(user_data); d, e := runtime.mem_alloc_bytes(cast(int) size); return raw_data(d)
}
FreeWrapper :: proc(ptr : rawptr, user_data : rawptr)
{
	IM_UNUSED(user_data); free(ptr)
}
} else { // preproc else
MallocWrapper :: proc(size : uint, user_data : rawptr) -> rawptr
{
	IM_UNUSED(user_data); IM_UNUSED(size); IM_ASSERT(false); return nil
}
FreeWrapper :: proc(ptr : rawptr, user_data : rawptr)
{
	IM_UNUSED(user_data); IM_UNUSED(ptr); IM_ASSERT(false)
}
} // preproc endif
GImAllocatorAllocFunc : ImGuiMemAllocFunc = MallocWrapper
GImAllocatorFreeFunc : ImGuiMemFreeFunc = FreeWrapper
GImAllocatorUserData : rawptr = nil

//-----------------------------------------------------------------------------
// [SECTION] USER FACING STRUCTURES (ImGuiStyle, ImGuiIO, ImGuiPlatformIO)
//-----------------------------------------------------------------------------

ImGuiStyle_init :: proc(this : ^ImGuiStyle)
{
	this^ = {}
	this.Alpha = 1.0; // Global alpha applies to everything in Dear ImGui.
	this.DisabledAlpha = 0.60; // Additional alpha multiplier applied by BeginDisabled(). Multiply over current value of Alpha.
	this.WindowPadding = ImVec2{8, 8}; // Padding within a window
	this.WindowRounding = 0.0; // Radius of window corners rounding. Set to 0.0f to have rectangular windows. Large values tend to lead to variety of artifacts and are not recommended.
	this.WindowBorderSize = 1.0; // Thickness of border around windows. Generally set to 0.0f or 1.0f. Other values not well tested.
	this.WindowMinSize = ImVec2{32, 32}; // Minimum window size
	this.WindowTitleAlign = ImVec2{0.0, 0.5}; // Alignment for title bar text
	this.WindowMenuButtonPosition = ImGuiDir.ImGuiDir_Left; // Position of the collapsing/docking button in the title bar (left/right). Defaults to ImGuiDir_Left.
	this.ChildRounding = 0.0; // Radius of child window corners rounding. Set to 0.0f to have rectangular child windows
	this.ChildBorderSize = 1.0; // Thickness of border around child windows. Generally set to 0.0f or 1.0f. Other values not well tested.
	this.PopupRounding = 0.0; // Radius of popup window corners rounding. Set to 0.0f to have rectangular child windows
	this.PopupBorderSize = 1.0; // Thickness of border around popup or tooltip windows. Generally set to 0.0f or 1.0f. Other values not well tested.
	this.FramePadding = ImVec2{4, 3}; // Padding within a framed rectangle (used by most widgets)
	this.FrameRounding = 0.0; // Radius of frame corners rounding. Set to 0.0f to have rectangular frames (used by most widgets).
	this.FrameBorderSize = 0.0; // Thickness of border around frames. Generally set to 0.0f or 1.0f. Other values not well tested.
	this.ItemSpacing = ImVec2{8, 4}; // Horizontal and vertical spacing between widgets/lines
	this.ItemInnerSpacing = ImVec2{4, 4}; // Horizontal and vertical spacing between within elements of a composed widget (e.g. a slider and its label)
	this.CellPadding = ImVec2{4, 2}; // Padding within a table cell. Cellpadding.x is locked for entire table. CellPadding.y may be altered between different rows.
	this.TouchExtraPadding = ImVec2{0, 0}; // Expand reactive bounding box for touch-based system where touch position is not accurate enough. Unfortunately we don't sort widgets so priority on overlap will always be given to the first widget. So don't grow this too much!
	this.IndentSpacing = 21.0; // Horizontal spacing when e.g. entering a tree node. Generally == (FontSize + FramePadding.x*2).
	this.ColumnsMinSpacing = 6.0; // Minimum horizontal spacing between two columns. Preferably > (FramePadding.x + 1).
	this.ScrollbarSize = 14.0; // Width of the vertical scrollbar, Height of the horizontal scrollbar
	this.ScrollbarRounding = 9.0; // Radius of grab corners rounding for scrollbar
	this.GrabMinSize = 12.0; // Minimum width/height of a grab box for slider/scrollbar
	this.GrabRounding = 0.0; // Radius of grabs corners rounding. Set to 0.0f to have rectangular slider grabs.
	this.LogSliderDeadzone = 4.0; // The size in pixels of the dead-zone around zero on logarithmic sliders that cross zero.
	this.TabRounding = 4.0; // Radius of upper corners of a tab. Set to 0.0f to have rectangular tabs.
	this.TabBorderSize = 0.0; // Thickness of border around tabs.
	this.TabMinWidthForCloseButton = 0.0; // Minimum width for close button to appear on an unselected tab when hovered. Set to 0.0f to always show when hovering, set to FLT_MAX to never show close button unless selected.
	this.TabBarBorderSize = 1.0; // Thickness of tab-bar separator, which takes on the tab active color to denote focus.
	this.TabBarOverlineSize = 2.0; // Thickness of tab-bar overline, which highlights the selected tab-bar.
	this.TableAngledHeadersAngle = 35.0 * (IM_PI / 180.0); // Angle of angled headers (supported values range from -50 degrees to +50 degrees).
	this.TableAngledHeadersTextAlign = ImVec2{0.5, 0.0}; // Alignment of angled headers within the cell
	this.ColorButtonPosition = ImGuiDir.ImGuiDir_Right; // Side of the color button in the ColorEdit4 widget (left/right). Defaults to ImGuiDir_Right.
	this.ButtonTextAlign = ImVec2{0.5, 0.5}; // Alignment of button text when button is larger than text.
	this.SelectableTextAlign = ImVec2{0.0, 0.0}; // Alignment of selectable text. Defaults to (0.0f, 0.0f) (top-left aligned). It's generally important to keep this left-aligned if you want to lay multiple items on a same line.
	this.SeparatorTextBorderSize = 3.0; // Thickness of border in SeparatorText()
	this.SeparatorTextAlign = ImVec2{0.0, 0.5}; // Alignment of text within the separator. Defaults to (0.0f, 0.5f) (left aligned, center).
	this.SeparatorTextPadding = ImVec2{20.0, 3.}; // Horizontal offset of text from each edge of the separator + spacing on other axis. Generally small values. .y is recommended to be == FramePadding.y.
	this.DisplayWindowPadding = ImVec2{19, 19}; // Window position are clamped to be visible within the display area or monitors by at least this amount. Only applies to regular windows.
	this.DisplaySafeAreaPadding = ImVec2{3, 3}; // If you cannot see the edge of your screen (e.g. on a TV) increase the safe area padding. Covers popups/tooltips as well regular windows.
	this.DockingSeparatorSize = 2.0; // Thickness of resizing border between docked windows
	this.MouseCursorScale = 1.0; // Scale software rendered mouse cursor (when io.MouseDrawCursor is enabled). May be removed later.
	this.AntiAliasedLines = true; // Enable anti-aliased lines/borders. Disable if you are really tight on CPU/GPU.
	this.AntiAliasedLinesUseTex = true; // Enable anti-aliased lines/borders using textures where possible. Require backend to render with bilinear filtering (NOT point/nearest filtering).
	this.AntiAliasedFill = true; // Enable anti-aliased filled shapes (rounded rectangles, circles, etc.).
	this.CurveTessellationTol = 1.25; // Tessellation tolerance when using PathBezierCurveTo() without a specific number of segments. Decrease for highly tessellated curves (higher quality, more polygons), increase to reduce quality.
	this.CircleTessellationMaxError = 0.30; // Maximum error (in pixels) allowed when using AddCircle()/AddCircleFilled() or drawing rounded corner rectangles with no explicit segment count specified. Decrease for higher quality but more geometry.

	// Behaviors
	this.HoverStationaryDelay = 0.15; // Delay for IsItemHovered(ImGuiHoveredFlags_Stationary). Time required to consider mouse stationary.
	this.HoverDelayShort = 0.15; // Delay for IsItemHovered(ImGuiHoveredFlags_DelayShort). Usually used along with HoverStationaryDelay.
	this.HoverDelayNormal = 0.40; // Delay for IsItemHovered(ImGuiHoveredFlags_DelayNormal). "
	this.HoverFlagsForTooltipMouse = ImGuiHoveredFlags_.ImGuiHoveredFlags_Stationary | ImGuiHoveredFlags_.ImGuiHoveredFlags_DelayShort | ImGuiHoveredFlags_.ImGuiHoveredFlags_AllowWhenDisabled; // Default flags when using IsItemHovered(ImGuiHoveredFlags_ForTooltip) or BeginItemTooltip()/SetItemTooltip() while using mouse.
	this.HoverFlagsForTooltipNav = ImGuiHoveredFlags_.ImGuiHoveredFlags_NoSharedDelay | ImGuiHoveredFlags_.ImGuiHoveredFlags_DelayNormal | ImGuiHoveredFlags_.ImGuiHoveredFlags_AllowWhenDisabled; // Default flags when using IsItemHovered(ImGuiHoveredFlags_ForTooltip) or BeginItemTooltip()/SetItemTooltip() while using keyboard/gamepad.

	// Default theme
	StyleColorsDark(this)
}

// To scale your entire UI (e.g. if you want your app to use High DPI or generally be DPI aware) you may use this helper function. Scaling the fonts is done separately and is up to you.
// Important: This operation is lossy because we round all sizes to integer. If you need to change your scale multiples, call this over a freshly initialized ImGuiStyle structure rather than scaling multiple times.
ImGuiStyle_ScaleAllSizes :: proc(this : ^ImGuiStyle, scale_factor : f32)
{
	this.WindowPadding = ImTrunc(this.WindowPadding * scale_factor)
	this.WindowRounding = ImTrunc(this.WindowRounding * scale_factor)
	this.WindowMinSize = ImTrunc(this.WindowMinSize * scale_factor)
	this.ChildRounding = ImTrunc(this.ChildRounding * scale_factor)
	this.PopupRounding = ImTrunc(this.PopupRounding * scale_factor)
	this.FramePadding = ImTrunc(this.FramePadding * scale_factor)
	this.FrameRounding = ImTrunc(this.FrameRounding * scale_factor)
	this.ItemSpacing = ImTrunc(this.ItemSpacing * scale_factor)
	this.ItemInnerSpacing = ImTrunc(this.ItemInnerSpacing * scale_factor)
	this.CellPadding = ImTrunc(this.CellPadding * scale_factor)
	this.TouchExtraPadding = ImTrunc(this.TouchExtraPadding * scale_factor)
	this.IndentSpacing = ImTrunc(this.IndentSpacing * scale_factor)
	this.ColumnsMinSpacing = ImTrunc(this.ColumnsMinSpacing * scale_factor)
	this.ScrollbarSize = ImTrunc(this.ScrollbarSize * scale_factor)
	this.ScrollbarRounding = ImTrunc(this.ScrollbarRounding * scale_factor)
	this.GrabMinSize = ImTrunc(this.GrabMinSize * scale_factor)
	this.GrabRounding = ImTrunc(this.GrabRounding * scale_factor)
	this.LogSliderDeadzone = ImTrunc(this.LogSliderDeadzone * scale_factor)
	this.TabRounding = ImTrunc(this.TabRounding * scale_factor)
	this.TabMinWidthForCloseButton = (this.TabMinWidthForCloseButton != FLT_MAX) ? ImTrunc(this.TabMinWidthForCloseButton * scale_factor) : FLT_MAX
	this.TabBarOverlineSize = ImTrunc(this.TabBarOverlineSize * scale_factor)
	this.SeparatorTextPadding = ImTrunc(this.SeparatorTextPadding * scale_factor)
	this.DockingSeparatorSize = ImTrunc(this.DockingSeparatorSize * scale_factor)
	this.DisplayWindowPadding = ImTrunc(this.DisplayWindowPadding * scale_factor)
	this.DisplaySafeAreaPadding = ImTrunc(this.DisplaySafeAreaPadding * scale_factor)
	this.MouseCursorScale = ImTrunc(this.MouseCursorScale * scale_factor)
}

ImGuiIO_init :: proc(this : ^ImGuiIO)
{
	// Most fields are initialized with zero
	this^ = {}
	#assert(len(this.MouseDown) == cast(int) ImGuiMouseButton_.ImGuiMouseButton_COUNT && len(this.MouseClicked) == cast(int) ImGuiMouseButton_.ImGuiMouseButton_COUNT)

	// Settings
	this.ConfigFlags = ImGuiConfigFlags_.ImGuiConfigFlags_None
	this.BackendFlags = ImGuiBackendFlags_.ImGuiBackendFlags_None
	this.DisplaySize = ImVec2{-1.0, -1.0}
	this.DeltaTime = 1.0 / 60.0
	this.IniSavingRate = 5.0
	this.IniFilename = "imgui.ini"; // Important: "imgui.ini" is relative to current working dir, most apps will want to lock this to an absolute path (e.g. same path as executables).
	this.LogFilename = "imgui_log.txt"
	this.UserData = nil

	this.Fonts = nil
	this.FontGlobalScale = 1.0
	this.FontDefault = nil
	this.FontAllowUserScaling = false
	this.DisplayFramebufferScale = ImVec2{1.0, 1.0}

	// Keyboard/Gamepad Navigation options
	this.ConfigNavSwapGamepadButtons = false
	this.ConfigNavMoveSetMousePos = false
	this.ConfigNavCaptureKeyboard = true
	this.ConfigNavEscapeClearFocusItem = true
	this.ConfigNavEscapeClearFocusWindow = false
	this.ConfigNavCursorVisibleAuto = true
	this.ConfigNavCursorVisibleAlways = false

	// Docking options (when ImGuiConfigFlags_DockingEnable is set)
	this.ConfigDockingNoSplit = false
	this.ConfigDockingWithShift = false
	this.ConfigDockingAlwaysTabBar = false
	this.ConfigDockingTransparentPayload = false

	// Viewport options (when ImGuiConfigFlags_ViewportsEnable is set)
	this.ConfigViewportsNoAutoMerge = false
	this.ConfigViewportsNoTaskBarIcon = false
	this.ConfigViewportsNoDecoration = true
	this.ConfigViewportsNoDefaultParent = false

	// Miscellaneous options
	this.MouseDrawCursor = false
	this.ConfigMacOSXBehaviors = ODIN_OS == .Darwin; // Set Mac OS X style defaults based on __APPLE__ compile time flag
	this.ConfigInputTrickleEventQueue = true
	this.ConfigInputTextCursorBlink = true
	this.ConfigInputTextEnterKeepActive = false
	this.ConfigDragClickToInputText = false
	this.ConfigWindowsResizeFromEdges = true
	this.ConfigWindowsMoveFromTitleBarOnly = false
	this.ConfigWindowsCopyContentsWithCtrlC = false
	this.ConfigScrollbarScrollByPage = true
	this.ConfigMemoryCompactTimer = 60.0
	this.ConfigDebugIsDebuggerPresent = false
	this.ConfigDebugHighlightIdConflicts = true
	this.ConfigDebugBeginReturnValueOnce = false
	this.ConfigDebugBeginReturnValueLoop = false

	this.ConfigErrorRecovery = true
	this.ConfigErrorRecoveryEnableAssert = true
	this.ConfigErrorRecoveryEnableDebugLog = true
	this.ConfigErrorRecoveryEnableTooltip = true

	// Inputs Behaviors
	this.MouseDoubleClickTime = 0.30
	this.MouseDoubleClickMaxDist = 6.0
	this.MouseDragThreshold = 6.0
	this.KeyRepeatDelay = 0.275
	this.KeyRepeatRate = 0.050

	// Platform Functions
	// Note: Initialize() will setup default clipboard/ime handlers.
	this.BackendRendererName = ""; this.BackendPlatformName = this.BackendRendererName
	this.BackendLanguageUserData = nil; this.BackendRendererUserData = this.BackendLanguageUserData; this.BackendPlatformUserData = this.BackendRendererUserData

	// Input (NB: we already have memset zero the entire structure!)
	this.MousePos = ImVec2{-FLT_MAX, -FLT_MAX}
	this.MousePosPrev = ImVec2{-FLT_MAX, -FLT_MAX}
	this.MouseSource = ImGuiMouseSource.ImGuiMouseSource_Mouse
	for i : i32 = 0; i < len(this.MouseDownDuration); i += 1 { this.MouseDownDurationPrev[i] = -1.0; this.MouseDownDuration[i] = this.MouseDownDurationPrev[i] }

	for i : i32 = 0; i < len(this.KeysData); i += 1 { this.KeysData[i].DownDurationPrev = -1.0; this.KeysData[i].DownDuration = this.KeysData[i].DownDurationPrev }

	this.AppAcceptingEvents = true
}

// Queue a new character input
// Pass in translated ASCII characters for text input.
// - with glfw you can get those from the callback set in glfwSetCharCallback()
// - on Windows you can get those using ToAscii+keyboard state, or via the WM_CHAR message
// FIXME: Should in theory be called "AddCharacterEvent()" to be consistent with new API
ImGuiIO_AddInputCharacter :: proc(this : ^ImGuiIO, c : u32)
{
	IM_ASSERT(this.Ctx != nil)
	g : ^ImGuiContext = this.Ctx
	if c == 0 || !this.AppAcceptingEvents { return }

	e : ImGuiInputEvent
	e.Type = ImGuiInputEventType.ImGuiInputEventType_Text
	e.Source = ImGuiInputSource.ImGuiInputSource_Keyboard
	e.EventId = post_incr(&g.InputEventsNextEventId)
	e.Text.Char = c
	push_back(&g.InputEventsQueue, e)
}

// Queue a new character input from a UTF-16 character, it can be a surrogate
// UTF16 strings use surrogate pairs to encode codepoints >= 0x10000, so
// we should save the high surrogate.
ImGuiIO_AddInputCharacterUTF16 :: proc(this : ^ImGuiIO, c : ImWchar16)
{
	if (c == 0 && this.InputQueueSurrogate == 0) || !this.AppAcceptingEvents { return }

	if (c & 0xFC00) == 0xD800 {
		// High surrogate, must save
		if this.InputQueueSurrogate != 0 { ImGuiIO_AddInputCharacter(this, IM_UNICODE_CODEPOINT_INVALID) }
		this.InputQueueSurrogate = c
		return
	}

	cp : ImWchar = c
	if this.InputQueueSurrogate != 0 {
		if (c & 0xFC00) != 0xDC00 {
			// Invalid low surrogate
			ImGuiIO_AddInputCharacter(this, IM_UNICODE_CODEPOINT_INVALID)
		}
		else {
			when IM_UNICODE_CODEPOINT_MAX == 0xFFFF {
			cp = IM_UNICODE_CODEPOINT_INVALID; // Codepoint will not fit in ImWchar
			} else { // preproc else
			cp = cast(ImWchar) (((this.InputQueueSurrogate - 0xD800) << 10) + (c - 0xDC00) + 0x10000)
			} // preproc endif
		}

		this.InputQueueSurrogate = 0
	}
	ImGuiIO_AddInputCharacter(this, cast(u32) cp)
}

// Queue a new characters input from a UTF-8 string
ImGuiIO_AddInputCharactersUTF8 :: proc(this : ^ImGuiIO, utf8_chars : [^]u8)
{
	if !this.AppAcceptingEvents { return }
	utf8_chars := utf8_chars
	for utf8_chars[0] != 0 {
		c : u32 = 0
		utf8_chars = utf8_chars[ImTextCharFromUtf8(&c, utf8_chars, nil):]
		ImGuiIO_AddInputCharacter(this, c)
	}
}

// Clear all incoming events.
// Clear all incoming events.
ImGuiIO_ClearEventsQueue :: proc(this : ^ImGuiIO)
{
	IM_ASSERT(this.Ctx != nil)
	g : ^ImGuiContext = this.Ctx
	clear(&g.InputEventsQueue)
}

// Clear current keyboard/gamepad state + current frame text input buffer. Equivalent to releasing all keys/buttons.
// Clear current keyboard/gamepad state + current frame text input buffer. Equivalent to releasing all keys/buttons.
ImGuiIO_ClearInputKeys :: proc(this : ^ImGuiIO)
{
	g : ^ImGuiContext = this.Ctx
	for key := ImGuiKey.ImGuiKey_NamedKey_BEGIN; key < ImGuiKey.ImGuiKey_NamedKey_END; key += ImGuiKey(1) {
		if IsMouseKey(cast(ImGuiKey) key) { continue }
		key_data : ^ImGuiKeyData = &g.IO.KeysData[key - ImGuiKey.ImGuiKey_NamedKey_BEGIN]
		key_data.Down = false
		key_data.DownDuration = -1.0
		key_data.DownDurationPrev = -1.0
	}

	this.KeySuper = false; this.KeyAlt = this.KeySuper; this.KeyShift = this.KeyAlt; this.KeyCtrl = this.KeyShift
	this.KeyMods = ImGuiKey.ImGuiMod_None
	resize(&this.InputQueueCharacters, 0); // Behavior of old ClearInputCharacters().
}

// Clear current mouse state.
ImGuiIO_ClearInputMouse :: proc(this : ^ImGuiIO)
{
	for key : ImGuiKey = ImGuiKey_Mouse_BEGIN; key < ImGuiKey_Mouse_END; key += ImGuiKey(1) {
		key_data : ^ImGuiKeyData = &this.KeysData[key - ImGuiKey.ImGuiKey_NamedKey_BEGIN]
		key_data.Down = false
		key_data.DownDuration = -1.0
		key_data.DownDurationPrev = -1.0
	}

	this.MousePos = ImVec2{-FLT_MAX, -FLT_MAX}
	for n : i32 = 0; n < len(this.MouseDown); n += 1 {
		this.MouseDown[n] = false
		this.MouseDownDurationPrev[n] = -1.0; this.MouseDownDuration[n] = this.MouseDownDurationPrev[n]
	}

	this.MouseWheelH = 0.0; this.MouseWheel = this.MouseWheelH
}


FindLatestInputEvent :: proc(ctx : ^ImGuiContext, type : ImGuiInputEventType, arg : i32 = -1) -> ^ImGuiInputEvent
{
	g : ^ImGuiContext = ctx
	for n : i32 = g.InputEventsQueue.Size - 1; n >= 0; n -= 1 {
		e : ^ImGuiInputEvent = &g.InputEventsQueue.Data[n]
		if e.Type != type { continue }
		if type == ImGuiInputEventType.ImGuiInputEventType_Key && e.Key.Key != cast(ImGuiKey)arg { continue }
		if type == ImGuiInputEventType.ImGuiInputEventType_MouseButton && i32(e.MouseButton.Button) != arg { continue }
		return e
	}

	return nil
}

// Queue a new key down/up event for analog values (e.g. ImGuiKey_Gamepad_ values). Dead-zones should be handled by the backend.
// Queue a new key down/up event.
// - ImGuiKey key:       Translated key (as in, generally ImGuiKey_A matches the key end-user would use to emit an 'A' character)
// - bool down:          Is the key down? use false to signify a key release.
// - float analog_value: 0.0f..1.0f
// IMPORTANT: THIS FUNCTION AND OTHER "ADD" GRABS THE CONTEXT FROM OUR INSTANCE.
// WE NEED TO ENSURE THAT ALL FUNCTION CALLS ARE FULFILLING THIS, WHICH IS WHY GetKeyData() HAS AN EXPLICIT CONTEXT.
ImGuiIO_AddKeyAnalogEvent :: proc(this : ^ImGuiIO, key : ImGuiKey, down : bool, analog_value : f32)
{
	//if (e->Down) { IMGUI_DEBUG_LOG_IO(g, "AddKeyEvent() Key='%s' %d, NativeKeycode = %d, NativeScancode = %d\n", ImGui::GetKeyName(e->Key), e->Down, e->NativeKeycode, e->NativeScancode); }
	IM_ASSERT(this.Ctx != nil)
	if key == ImGuiKey.ImGuiKey_None || !this.AppAcceptingEvents { return }
	g : ^ImGuiContext = this.Ctx
	IM_ASSERT(IsNamedKeyOrMod(key)); // Backend needs to pass a valid ImGuiKey_ constant. 0..511 values are legacy native key codes which are not accepted by this API.
	IM_ASSERT(IsAliasKey(key) == false); // Backend cannot submit ImGuiKey_MouseXXX values they are automatically inferred from AddMouseXXX() events.

	key := key
	// MacOS: swap Cmd(Super) and Ctrl
	if g.IO.ConfigMacOSXBehaviors {
		if key == ImGuiKey.ImGuiMod_Super { key = ImGuiKey.ImGuiMod_Ctrl }
		else if key == ImGuiKey.ImGuiMod_Ctrl { key = ImGuiKey.ImGuiMod_Super }
		else if key == ImGuiKey.ImGuiKey_LeftSuper { key = ImGuiKey.ImGuiKey_LeftCtrl }
		else if key == ImGuiKey.ImGuiKey_RightSuper { key = ImGuiKey.ImGuiKey_RightCtrl }
		else if key == ImGuiKey.ImGuiKey_LeftCtrl { key = ImGuiKey.ImGuiKey_LeftSuper }
		else if key == ImGuiKey.ImGuiKey_RightCtrl { key = ImGuiKey.ImGuiKey_RightSuper }
	}

	// Filter duplicate (in particular: key mods and gamepad analog values are commonly spammed)
	latest_event : ^ImGuiInputEvent = FindLatestInputEvent(g, ImGuiInputEventType.ImGuiInputEventType_Key, cast(i32) key)
	key_data : ^ImGuiKeyData = GetKeyData(g, key)
	latest_key_down : bool = latest_event != nil ? latest_event.Key.Down : key_data.Down
	latest_key_analog : f32 = latest_event != nil ? latest_event.Key.AnalogValue : key_data.AnalogValue
	if latest_key_down == down && latest_key_analog == analog_value { return }

	// Add event
	e : ImGuiInputEvent
	e.Type = ImGuiInputEventType.ImGuiInputEventType_Key
	e.Source = IsGamepadKey(key) ? ImGuiInputSource.ImGuiInputSource_Gamepad : ImGuiInputSource.ImGuiInputSource_Keyboard
	e.EventId = post_incr(&g.InputEventsNextEventId)
	e.Key.Key = key
	e.Key.Down = down
	e.Key.AnalogValue = analog_value
	push_back(&g.InputEventsQueue, e)
}

//------------------------------------------------------------------
// Input - Call before calling NewFrame()
//------------------------------------------------------------------

// Input Functions
// Queue a new key down/up event. Key should be "translated" (as in, generally ImGuiKey_A matches the key end-user would use to emit an 'A' character)
ImGuiIO_AddKeyEvent :: proc(this : ^ImGuiIO, key : ImGuiKey, down : bool)
{
	if !this.AppAcceptingEvents { return }
	ImGuiIO_AddKeyAnalogEvent(this, key, down, down ? 1.0 : 0.0)
}

// [Optional] Specify index for legacy <1.87 IsKeyXXX() functions with native indices + specify native keycode, scancode.
// [Optional] Call after AddKeyEvent().
// Specify native keycode, scancode + Specify index for legacy <1.87 IsKeyXXX() functions with native indices.
// If you are writing a backend in 2022 or don't use IsKeyXXX() with native values that are not ImGuiKey values, you can avoid calling this.
ImGuiIO_SetKeyEventNativeData :: proc(this : ^ImGuiIO, key : ImGuiKey, native_keycode : i32, native_scancode : i32, native_legacy_index : i32 = -1)
{
	if key == ImGuiKey.ImGuiKey_None { return }
	IM_ASSERT(IsNamedKey(key)); // >= 512
	IM_ASSERT(native_legacy_index == -1 || IsLegacyKey(cast(ImGuiKey) native_legacy_index)); // >= 0 && <= 511
	IM_UNUSED(key); // Yet unused
	IM_UNUSED(native_keycode); // Yet unused
	IM_UNUSED(native_scancode); // Yet unused
	IM_UNUSED(native_legacy_index); // Yet unused
}

// Set master flag for accepting key/mouse/text events (default to true). Useful if you have native dialog boxes that are interrupting your application loop/refresh, and you want to disable events being queued while your app is frozen.
// Set master flag for accepting key/mouse/text events (default to true). Useful if you have native dialog boxes that are interrupting your application loop/refresh, and you want to disable events being queued while your app is frozen.
ImGuiIO_SetAppAcceptingEvents :: proc(this : ^ImGuiIO, accepting_events : bool)
{
	this.AppAcceptingEvents = accepting_events
}

// Queue a mouse position update. Use -FLT_MAX,-FLT_MAX to signify no mouse (e.g. app not focused and not hovered)
// Queue a mouse move event
ImGuiIO_AddMousePosEvent :: proc(this : ^ImGuiIO, x : f32, y : f32)
{
	IM_ASSERT(this.Ctx != nil)
	g : ^ImGuiContext = this.Ctx
	if !this.AppAcceptingEvents { return }

	// Apply same flooring as UpdateMouseInputs()
	pos := ImVec2{ (x > -FLT_MAX) ? ImFloor(x) : x, (y > -FLT_MAX) ? ImFloor(y) : y }

	// Filter duplicate
	latest_event : ^ImGuiInputEvent = FindLatestInputEvent(g, ImGuiInputEventType.ImGuiInputEventType_MousePos)
	latest_pos : ImVec2 = latest_event != nil ? ImVec2{latest_event.MousePos.PosX, latest_event.MousePos.PosY} : g.IO.MousePos
	if latest_pos.x == pos.x && latest_pos.y == pos.y { return }

	e : ImGuiInputEvent
	e.Type = ImGuiInputEventType.ImGuiInputEventType_MousePos
	e.Source = ImGuiInputSource.ImGuiInputEventType_Mouse
	e.EventId = post_incr(&g.InputEventsNextEventId)
	e.MousePos.PosX = pos.x
	e.MousePos.PosY = pos.y
	e.MousePos.MouseSource = g.InputEventsNextMouseSource
	push_back(&g.InputEventsQueue, e)
}

// Queue a mouse button change
ImGuiIO_AddMouseButtonEvent :: proc(this : ^ImGuiIO, mouse_button : ImGuiMouseButton, down : bool)
{
	IM_ASSERT(this.Ctx != nil)
	g : ^ImGuiContext = this.Ctx
	IM_ASSERT(mouse_button >= ImGuiMouseButton(0) && mouse_button < ImGuiMouseButton_.ImGuiMouseButton_COUNT)
	if !this.AppAcceptingEvents { return }

	mouse_button := mouse_button
	// On MacOS X: Convert Ctrl(Super)+Left click into Right-click: handle held button.
	if this.ConfigMacOSXBehaviors && mouse_button == ImGuiMouseButton(0) && this.MouseCtrlLeftAsRightClick {
		// Order of both statements matterns: this event will still release mouse button 1
		mouse_button = ImGuiMouseButton(1)
		if !down { this.MouseCtrlLeftAsRightClick = false }
	}

	// Filter duplicate
	latest_event : ^ImGuiInputEvent = FindLatestInputEvent(g, ImGuiInputEventType.ImGuiInputEventType_MouseButton, cast(i32) mouse_button)
	latest_button_down : bool = latest_event != nil ? latest_event.MouseButton.Down : g.IO.MouseDown[mouse_button]
	if latest_button_down == down { return }

	// On MacOS X: Convert Ctrl(Super)+Left click into Right-click.
	// - Note that this is actual physical Ctrl which is ImGuiMod_Super for us.
	// - At this point we want from !down to down, so this is handling the initial press.
	if this.ConfigMacOSXBehaviors && mouse_button == ImGuiMouseButton(0) && down {
		latest_super_event : ^ImGuiInputEvent = FindLatestInputEvent(g, ImGuiInputEventType.ImGuiInputEventType_Key, cast(i32) ImGuiKey.ImGuiMod_Super)
		if latest_super_event != nil ? latest_super_event.Key.Down : g.IO.KeySuper {
			IMGUI_DEBUG_LOG_IO(g, "[io] Super+Left Click aliased into Right Click\n")
			this.MouseCtrlLeftAsRightClick = true
			ImGuiIO_AddMouseButtonEvent(this, ImGuiMouseButton(1), true); // This is just quicker to write that passing through, as we need to filter duplicate again.
			return
		}
	}

	e : ImGuiInputEvent
	e.Type = ImGuiInputEventType.ImGuiInputEventType_MouseButton
	e.Source = ImGuiInputSource.ImGuiInputEventType_Mouse
	e.EventId = post_incr(&g.InputEventsNextEventId)
	e.MouseButton.Button = mouse_button
	e.MouseButton.Down = down
	e.MouseButton.MouseSource = g.InputEventsNextMouseSource
	push_back(&g.InputEventsQueue, e)
}

// Queue a mouse wheel update. wheel_y<0: scroll down, wheel_y>0: scroll up, wheel_x<0: scroll right, wheel_x>0: scroll left.
// Queue a mouse wheel event (some mouse/API may only have a Y component)
ImGuiIO_AddMouseWheelEvent :: proc(this : ^ImGuiIO, wheel_x : f32, wheel_y : f32)
{
	IM_ASSERT(this.Ctx != nil)
	g : ^ImGuiContext = this.Ctx

	// Filter duplicate (unlike most events, wheel values are relative and easy to filter)
	if !this.AppAcceptingEvents || (wheel_x == 0.0 && wheel_y == 0.0) { return }

	e : ImGuiInputEvent
	e.Type = ImGuiInputEventType.ImGuiInputEventType_MouseWheel
	e.Source = ImGuiInputSource.ImGuiInputEventType_Mouse
	e.EventId = post_incr(&g.InputEventsNextEventId)
	e.MouseWheel.WheelX = wheel_x
	e.MouseWheel.WheelY = wheel_y
	e.MouseWheel.MouseSource = g.InputEventsNextMouseSource
	push_back(&g.InputEventsQueue, e)
}

// Queue a mouse source change (Mouse/TouchScreen/Pen)
// This is not a real event, the data is latched in order to be stored in actual Mouse events.
// This is so that duplicate events (e.g. Windows sending extraneous WM_MOUSEMOVE) gets filtered and are not leading to actual source changes.
ImGuiIO_AddMouseSourceEvent :: proc(this : ^ImGuiIO, source : ImGuiMouseSource)
{
	IM_ASSERT(this.Ctx != nil)
	g : ^ImGuiContext = this.Ctx
	g.InputEventsNextMouseSource = source
}

// Queue a mouse hovered viewport. Requires backend to set ImGuiBackendFlags_HasMouseHoveredViewport to call this (for multi-viewport support).
ImGuiIO_AddMouseViewportEvent :: proc(this : ^ImGuiIO, viewport_id : ImGuiID)
{
	IM_ASSERT(this.Ctx != nil)
	g : ^ImGuiContext = this.Ctx
	//IM_ASSERT(g.IO.BackendFlags & ImGuiBackendFlags_HasMouseHoveredViewport);
	if !this.AppAcceptingEvents { return }

	// Filter duplicate
	latest_event : ^ImGuiInputEvent = FindLatestInputEvent(g, ImGuiInputEventType.ImGuiInputEventType_MouseViewport)
	latest_viewport_id : ImGuiID = latest_event != nil ? latest_event.MouseViewport.HoveredViewportID : g.IO.MouseHoveredViewport
	if latest_viewport_id == viewport_id { return }

	e : ImGuiInputEvent
	e.Type = ImGuiInputEventType.ImGuiInputEventType_MouseViewport
	e.Source = ImGuiInputSource.ImGuiInputEventType_Mouse
	e.MouseViewport.HoveredViewportID = viewport_id
	push_back(&g.InputEventsQueue, e)
}

// Queue a gain/loss of focus for the application (generally based on OS/platform focus of your window)
ImGuiIO_AddFocusEvent :: proc(this : ^ImGuiIO, focused : bool)
{
	IM_ASSERT(this.Ctx != nil)
	g : ^ImGuiContext = this.Ctx

	// Filter duplicate
	latest_event : ^ImGuiInputEvent = FindLatestInputEvent(g, ImGuiInputEventType.ImGuiInputEventType_Focus)
	latest_focused : bool = latest_event != nil ? latest_event.AppFocused.Focused : !g.IO.AppFocusLost
	if latest_focused == focused || (this.ConfigDebugIgnoreFocusLoss && !focused) { return }

	e : ImGuiInputEvent
	e.Type = ImGuiInputEventType.ImGuiInputEventType_Focus
	e.EventId = post_incr(&g.InputEventsNextEventId)
	e.AppFocused.Focused = focused
	push_back(&g.InputEventsQueue, e)
}

ImGuiPlatformIO_init :: proc(this : ^ImGuiPlatformIO)
{
	// Most fields are initialized with zero
	this^ = {}
	this.Platform_LocaleDecimalPoint = '.'
}

// For curves with explicit number of segments
//-----------------------------------------------------------------------------
// [SECTION] MISC HELPERS/UTILITIES (Geometry functions)
//-----------------------------------------------------------------------------

ImBezierCubicClosestPoint :: proc(p1 : ImVec2, p2 : ImVec2, p3 : ImVec2, p4 : ImVec2, p : ImVec2, num_segments : i32) -> ImVec2
{
	IM_ASSERT(num_segments > 0); // Use ImBezierCubicClosestPointCasteljau()
	p_last : ImVec2 = p1
	p_closest : ImVec2
	p_closest_dist2 : f32 = FLT_MAX
	t_step : f32 = 1.0 / cast(f32) num_segments
	for i_step : i32 = 1; i_step <= num_segments; i_step += 1 {
		p_current : ImVec2 = ImBezierCubicCalc(p1, p2, p3, p4, t_step * cast(f32) i_step)
		p_line : ImVec2 = ImLineClosestPoint(p_last, p_current, p)
		dist2 : f32 = ImLengthSqr(p - p_line)
		if dist2 < p_closest_dist2 {
			p_closest = p_line
			p_closest_dist2 = dist2
		}
		p_last = p_current
	}

	return p_closest
}

// Closely mimics PathBezierToCasteljau() in imgui_draw.cpp
ImBezierCubicClosestPointCasteljauStep :: proc(p : ImVec2, p_closest : ^ImVec2, p_last : ^ImVec2, p_closest_dist2 : ^f32, x1 : f32, y1 : f32, x2 : f32, y2 : f32, x3 : f32, y3 : f32, x4 : f32, y4 : f32, tess_tol : f32, level : i32)
{
	dx : f32 = x4 - x1
	dy : f32 = y4 - y1
	d2 : f32 = ((x2 - x4) * dy - (y2 - y4) * dx)
	d3 : f32 = ((x3 - x4) * dy - (y3 - y4) * dx)
	d2 = (d2 >= 0) ? d2 : -d2
	d3 = (d3 >= 0) ? d3 : -d3
	if (d2 + d3) * (d2 + d3) < tess_tol * (dx * dx + dy * dy) {
		p_current := ImVec2{ x4, y4 }
		p_line : ImVec2 = ImLineClosestPoint(p_last^, p_current, p)
		dist2 : f32 = ImLengthSqr(p - p_line)
		if dist2 < p_closest_dist2^ {
			p_closest^ = p_line
			p_closest_dist2^ = dist2
		}
		p_last^ = p_current
	}
	else if level < 10 {
		x12 : f32 = (x1 + x2) * 0.5; y12 : f32 = (y1 + y2) * 0.5
		x23 : f32 = (x2 + x3) * 0.5; y23 : f32 = (y2 + y3) * 0.5
		x34 : f32 = (x3 + x4) * 0.5; y34 : f32 = (y3 + y4) * 0.5
		x123 : f32 = (x12 + x23) * 0.5; y123 : f32 = (y12 + y23) * 0.5
		x234 : f32 = (x23 + x34) * 0.5; y234 : f32 = (y23 + y34) * 0.5
		x1234 : f32 = (x123 + x234) * 0.5; y1234 : f32 = (y123 + y234) * 0.5
		ImBezierCubicClosestPointCasteljauStep(p, p_closest, p_last, p_closest_dist2, x1, y1, x12, y12, x123, y123, x1234, y1234, tess_tol, level + 1)
		ImBezierCubicClosestPointCasteljauStep(p, p_closest, p_last, p_closest_dist2, x1234, y1234, x234, y234, x34, y34, x4, y4, tess_tol, level + 1)
	}
}

// For auto-tessellated curves you can use tess_tol = style.CurveTessellationTol
// tess_tol is generally the same value you would find in ImGui::GetStyle().CurveTessellationTol
// Because those ImXXX functions are lower-level than ImGui:: we cannot access this value automatically.
ImBezierCubicClosestPointCasteljau :: proc(p1 : ImVec2, p2 : ImVec2, p3 : ImVec2, p4 : ImVec2, p : ImVec2, tess_tol : f32) -> ImVec2
{
	IM_ASSERT(tess_tol > 0.0)
	p_last : ImVec2 = p1
	p_closest : ImVec2
	p_closest_dist2 : f32 = FLT_MAX
	ImBezierCubicClosestPointCasteljauStep(p, &p_closest, &p_last, &p_closest_dist2, p1.x, p1.y, p2.x, p2.y, p3.x, p3.y, p4.x, p4.y, tess_tol, 0)
	return p_closest
}

ImLineClosestPoint :: proc(a : ImVec2, b : ImVec2, p : ImVec2) -> ImVec2
{
	ap : ImVec2 = p - a
	ab_dir : ImVec2 = b - a
	dot : f32 = ap.x * ab_dir.x + ap.y * ab_dir.y
	if dot < 0.0 { return a }
	ab_len_sqr : f32 = ab_dir.x * ab_dir.x + ab_dir.y * ab_dir.y
	if dot > ab_len_sqr { return b }
	return a + ab_dir * dot / ab_len_sqr
}

ImTriangleContainsPoint :: proc(a : ImVec2, b : ImVec2, c : ImVec2, p : ImVec2) -> bool
{
	b1 : bool = ((p.x - b.x) * (a.y - b.y) - (p.y - b.y) * (a.x - b.x)) < 0.0
	b2 : bool = ((p.x - c.x) * (b.y - c.y) - (p.y - c.y) * (b.x - c.x)) < 0.0
	b3 : bool = ((p.x - a.x) * (c.y - a.y) - (p.y - a.y) * (c.x - a.x)) < 0.0
	return ((b1 == b2) && (b2 == b3))
}

ImTriangleBarycentricCoords :: proc(a : ImVec2, b : ImVec2, c : ImVec2, p : ImVec2, out_u : ^f32, out_v : ^f32, out_w : ^f32)
{
	v0 : ImVec2 = b - a
	v1 : ImVec2 = c - a
	v2 : ImVec2 = p - a
	denom : f32 = v0.x * v1.y - v1.x * v0.y
	out_v^ = (v2.x * v1.y - v1.x * v2.y) / denom
	out_w^ = (v0.x * v2.y - v2.x * v0.y) / denom
	out_u^ = 1.0 - out_v^ - out_w^
}

ImTriangleClosestPoint :: proc(a : ImVec2, b : ImVec2, c : ImVec2, p : ImVec2) -> ImVec2
{
	proj_ab : ImVec2 = ImLineClosestPoint(a, b, p)
	proj_bc : ImVec2 = ImLineClosestPoint(b, c, p)
	proj_ca : ImVec2 = ImLineClosestPoint(c, a, p)
	dist2_ab : f32 = ImLengthSqr(p - proj_ab)
	dist2_bc : f32 = ImLengthSqr(p - proj_bc)
	dist2_ca : f32 = ImLengthSqr(p - proj_ca)
	m : f32 = ImMin(dist2_ab, ImMin(dist2_bc, dist2_ca))
	if m == dist2_ab { return proj_ab }
	if m == dist2_bc { return proj_bc }
	return proj_ca
}

// Helpers: String
//-----------------------------------------------------------------------------
// [SECTION] MISC HELPERS/UTILITIES (String, Format, Hash functions)
//-----------------------------------------------------------------------------

// Case insensitive compare.
// Consider using _stricmp/_strnicmp under Windows or strcasecmp/strncasecmp. We don't actually use either ImStricmp/ImStrnicmp in the codebase any more.
ImStricmp :: proc(str1 : [^]u8, str2 : [^]u8) -> i32
{
	str1, str2 := str1, str2
	d : i32
	for {
		d = i32(ImToUpper(str2[0]) - ImToUpper(str1[0]))
		if !(d == 0 && str1[0] != 0) { break }
		post_incr(&str1); post_incr(&str2)
	}

	return d
}

// Case insensitive compare to a certain count.
ImStrnicmp :: proc(str1 : [^]u8, str2 : [^]u8, count : uint) -> i32
{
	str1, str2, count := str1, str2, count
	d : i32 = 0
	for count > 0 {
		d = i32(ImToUpper(str2[0]) - ImToUpper(str1[0]))
		if !(d == 0 && str1[0] != 0) { break }
		post_incr(&str1); post_incr(&str2); post_decr(&count)
	}

	return d
}

// Copy to a certain count and always zero terminate (strncpy doesn't).
ImStrncpy :: proc(dst : [^]u8, src : [^]u8, #any_int count : uint)
{
	if count < 1 { return }
	if count > 1 { strncpy(dst, src, count - 1) }
	dst[count - 1] = 0
}

// Duplicate a string.
ImStrdup :: proc(str : [^]u8) -> [^]u8
{
	len := cast(int) strlen(str)
	buf : rawptr = IM_ALLOC(cast(uint)len + 1)
	return cast([^]u8) memcpy(buf, str, len + 1)
}

ImStrdupcpy :: proc { ImStrdupcpy_s, ImStrdupcpy_p }

ImStrdupcpy_s :: proc(dst : string, p_dst_size : ^uint, src : string) -> string
{
	d := transmute(runtime.Raw_String) dst
	if len(src) > d.len {
		n, _ := runtime.non_zero_mem_resize(d.data, d.len, len(src))
		d.data = raw_data(n)
		d.len = len(n)
	}
	mem.copy(d.data, raw_data(src), len(src))
	return transmute(string)d
}

// Copy in provided buffer, recreate buffer if needed.
ImStrdupcpy_p :: proc(dst : [^]u8, p_dst_size : ^uint, src : [^]u8) -> [^]u8
{
	dst := dst
	dst_buf_size : uint = p_dst_size != nil ? p_dst_size^ : cast(uint) strlen(dst) + 1
	src_size : uint = cast(uint)strlen(src) + 1
	if dst_buf_size < src_size {
		IM_FREE(dst)
		dst = cast([^]u8) IM_ALLOC(src_size)
		if p_dst_size != nil { p_dst_size^ = src_size }
	}
	return cast([^]u8) memcpy(dst, src, cast(int)src_size)
}

// Find first occurrence of 'c' in string range.
ImStrchrRange :: proc(str : [^]u8, str_end : ^u8, c : u8) -> ^u8
{
	p, _ := ptr_to_first(slice.from_ptr(str, mem.ptr_sub(cast(^u8)str, str_end)), c)
	return p
}

// Computer string length (ImWchar string)
ImStrlenW :: proc(str : ^ImWchar) -> i32
{
	//return (int)wcslen((const wchar_t*)str);  // FIXME-OPT: Could use this when wchar_t are 16-bit
	n : i32 = 0
	str := str
	for post_incr(&str)^ != {} { post_incr(&n) }

	return n
}

// Find end-of-line. Return pointer will point to either first \n, either str_end.
ImStreolRange :: proc(str : [^]u8, str_end : ^u8) -> ^u8
{
	p, found := ptr_to_first(slice.from_ptr(str, mem.ptr_sub(cast(^u8) str, str_end)), '\n')
	return found ? p : str_end
}

// Find beginning-of-line
ImStrbol :: proc(buf_mid_line : ^u8, buf_begin : ^u8) -> ^u8
{
	buf_mid_line := buf_mid_line
	for buf_mid_line > buf_begin && mem.ptr_offset(buf_mid_line, -1)^ != '\n' { buf_mid_line = mem.ptr_offset(buf_mid_line, -1) }

	return buf_mid_line
}

// Find a substring in a string range.
ImStristr :: proc(haystack : []u8, needle : []u8) -> [^]u8
{
	haystack_end := raw_data(haystack)[len(haystack):]; haystack := raw_data(haystack)
	needle_end := raw_data(needle)[len(needle):]; needle := raw_data(needle)

	un0 : u8 = cast(u8) ImToUpper(needle[0])
	for (haystack_end == nil && haystack[0] != 0) || (haystack_end != nil && haystack < haystack_end) {
		if ImToUpper(haystack[0]) == un0 {
			b := needle[1:]
			for a := haystack[1:]; b < needle_end; a, b = a[1:], b[1:] { if ImToUpper(a[0]) != ImToUpper(b[0]) { break } }

			if b == needle_end { return haystack }
		}
		post_incr(&haystack)
	}

	return nil
}

// Remove leading and trailing blanks from a buffer.
// Trim str by offsetting contents when there's leading data + writing a \0 at the trailing position. We use this in situation where the cost is negligible.
ImStrTrimBlanks :: proc(buf : [^]u8) -> int
{
	p : [^]u8 = buf
	for p[0] == ' ' || p[0] == '\t' { post_incr(&p) }

	p_start : [^]u8 = p
	for p[0] != 0 { post_incr(&p) }

	for p > p_start && (p[-1] == ' ' || p[-1] == '\t') { post_decr(&p) }

	if p_start != buf {
		// Copy memory if we had leading blanks
		memmove(buf, p_start, mem.ptr_sub(p, p_start))
	}
	len := mem.ptr_sub(p, p_start)
	buf[len] = 0; // Zero terminate
	return len
}

// Find first non-blank character.
ImStrSkipBlank :: proc(str : string) -> string
{
	str := str
	for str[0] == ' ' || str[0] == '\t' { str = str[1:] }
	return str
}

// A) MSVC version appears to return -1 on overflow, whereas glibc appears to return total count (which may be >= buf_size).
// Ideally we would test for only one of those limits at runtime depending on the behavior the vsnprintf(), but trying to deduct it at compile time sounds like a pandora can of worm.
// B) When buf==NULL vsnprintf() will return the output size.
when ! IMGUI_DISABLE_DEFAULT_FORMAT_FUNCTIONS {

// We support stb_sprintf which is much faster (see: https://github.com/nothings/stb/blob/master/stb_sprintf.h)
// You may set IMGUI_USE_STB_SPRINTF to use our default wrapper, or set IMGUI_DISABLE_DEFAULT_FORMAT_FUNCTIONS
// and setup the wrapper yourself. (FIXME-OPT: Some of our high-level operations such as ImGuiTextBuffer::appendfv() are
// designed using two-passes worst case, which probably could be improved using the stbsp_vsprintfcb() function.)
when IMGUI_USE_STB_SPRINTF {
STB_SPRINTF_IMPLEMENTATION :: true
//#include "stb_sprintf.h"
} // preproc endif// #ifdef IMGUI_USE_STB_SPRINTF

vsnprintf :: proc(s : [^]u8, n : int, format : string, args : ..any) -> int
{
	return len(fmt.bprintf(slice.from_ptr(transmute(^byte)s, n), format, ..args))
}

// Helpers: Formatting
ImFormatString :: proc(buf : []u8, fmt : string, args : ..any) -> i32
{
	when IMGUI_USE_STB_SPRINTF {
	w : i32 = stbsp.vsnprintf(raw_data(buf), len(buf), fmt, args)
	} else { // preproc else
	w : i32 = cast(i32) vsnprintf(raw_data(buf), len(buf), fmt, ..args)
	} // preproc endif
	if buf == nil { return w }
	if w == -1 || w >= cast(i32) len(buf) { w = cast(i32) len(buf) - 1 }
	buf[w] = 0
	return w
}

ImFormatStringV :: #force_inline proc(buf : []u8, fmt : string, args : []any) -> i32
{
	return ImFormatString(buf, fmt, ..args)
}
} // preproc endif// #ifdef IMGUI_DISABLE_DEFAULT_FORMAT_FUNCTIONS

ImFormatStringToTempBufferV :: #force_inline proc(out_buf : ^[^]u8, out_buf_end : ^^u8, fmt : string, args : []any)
{
	ImFormatStringToTempBuffer(out_buf, out_buf_end, fmt, ..args)
}

// FIXME: Should rework API toward allowing multiple in-flight temp buffers (easier and safer for caller)
// by making the caller acquire a temp buffer token, with either explicit or destructor release, e.g.
//  ImGuiTempBufferToken token;
//  ImFormatStringToTempBuffer(token, ...);
ImFormatStringToTempBuffer :: proc(out_buf : ^[^]u8, out_buf_end : ^^u8, fmt : string, args : ..any)
{
	@(static) s_null_string := "(null)"

	g : ^ImGuiContext = GImGui
	if fmt == "%s" {
		buf := cast(^string) args[0].data // Skip formatting when using "%s"
		if buf == nil { buf = &s_null_string }
		out_buf^ = raw_data(buf^)
		if out_buf_end != nil { out_buf_end^ = &raw_data(buf^)[len(buf)] }
	}
	else if fmt == "%.*s" {
		buf_len : i32 = va_arg(args, i32, 0) // Skip formatting when using "%.*s"
		buf := cast(^string) args[1].data
		if buf == nil {
			buf = &s_null_string
			buf_len = ImMin(buf_len, 6)
		}
		out_buf^ = raw_data(buf^)
		out_buf_end^ = &raw_data(buf^)[buf_len]; // Disallow not passing 'out_buf_end' here. User is expected to use it.
	}
	else {
		buf_len : i32 = ImFormatStringV(g.TempBuffer.Data[:g.TempBuffer.Size], fmt, args)
		out_buf^ = g.TempBuffer.Data
		if out_buf_end != nil { out_buf_end^ = &g.TempBuffer.Data[buf_len] }
	}
}

when ! IMGUI_ENABLE_SSE4_2_CRC {
// CRC32 needs a 1KB lookup table (not cache friendly)
// Although the code to generate the table is simple and shorter than the table itself, using a const table allows us to easily:
// - avoid an unnecessary branch/memory tap, - keep the ImHashXXX functions usable by static constructors, - make it thread-safe.
GCrc32LookupTable : [256]ImU32 = {
	// Legacy CRC32-adler table used pre 1.91.6 (before 2024/11/27). Only use if you cannot afford invalidating old .ini data.
	0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA, 0x076DC419, 0x706AF48F, 0xE963A535, 0x9E6495A3, 0x0EDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988, 0x09B64C2B, 0x7EB17CBD, 0xE7B82D07, 0x90BF1D91,
	0x1DB71064, 0x6AB020F2, 0xF3B97148, 0x84BE41DE, 0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7, 0x136C9856, 0x646BA8C0, 0xFD62F97A, 0x8A65C9EC, 0x14015C4F, 0x63066CD9, 0xFA0F3D63, 0x8D080DF5,
	0x3B6E20C8, 0x4C69105E, 0xD56041E4, 0xA2677172, 0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B, 0x35B5A8FA, 0x42B2986C, 0xDBBBC9D6, 0xACBCF940, 0x32D86CE3, 0x45DF5C75, 0xDCD60DCF, 0xABD13D59,
	0x26D930AC, 0x51DE003A, 0xC8D75180, 0xBFD06116, 0x21B4F4B5, 0x56B3C423, 0xCFBA9599, 0xB8BDA50F, 0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924, 0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D,
	0x76DC4190, 0x01DB7106, 0x98D220BC, 0xEFD5102A, 0x71B18589, 0x06B6B51F, 0x9FBFE4A5, 0xE8B8D433, 0x7807C9A2, 0x0F00F934, 0x9609A88E, 0xE10E9818, 0x7F6A0DBB, 0x086D3D2D, 0x91646C97, 0xE6635C01,
	0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E, 0x6C0695ED, 0x1B01A57B, 0x8208F4C1, 0xF50FC457, 0x65B0D9C6, 0x12B7E950, 0x8BBEB8EA, 0xFCB9887C, 0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3, 0xFBD44C65,
	0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2, 0x4ADFA541, 0x3DD895D7, 0xA4D1C46D, 0xD3D6F4FB, 0x4369E96A, 0x346ED9FC, 0xAD678846, 0xDA60B8D0, 0x44042D73, 0x33031DE5, 0xAA0A4C5F, 0xDD0D7CC9,
	0x5005713C, 0x270241AA, 0xBE0B1010, 0xC90C2086, 0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F, 0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4, 0x59B33D17, 0x2EB40D81, 0xB7BD5C3B, 0xC0BA6CAD,
	0xEDB88320, 0x9ABFB3B6, 0x03B6E20C, 0x74B1D29A, 0xEAD54739, 0x9DD277AF, 0x04DB2615, 0x73DC1683, 0xE3630B12, 0x94643B84, 0x0D6D6A3E, 0x7A6A5AA8, 0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1,
	0xF00F9344, 0x8708A3D2, 0x1E01F268, 0x6906C2FE, 0xF762575D, 0x806567CB, 0x196C3671, 0x6E6B06E7, 0xFED41B76, 0x89D32BE0, 0x10DA7A5A, 0x67DD4ACC, 0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5,
	0xD6D6A3E8, 0xA1D1937E, 0x38D8C2C4, 0x4FDFF252, 0xD1BB67F1, 0xA6BC5767, 0x3FB506DD, 0x48B2364B, 0xD80D2BDA, 0xAF0A1B4C, 0x36034AF6, 0x41047A60, 0xDF60EFC3, 0xA867DF55, 0x316E8EEF, 0x4669BE79,
	0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236, 0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F, 0xC5BA3BBE, 0xB2BD0B28, 0x2BB45A92, 0x5CB36A04, 0xC2D7FFA7, 0xB5D0CF31, 0x2CD99E8B, 0x5BDEAE1D,
	0x9B64C2B0, 0xEC63F226, 0x756AA39C, 0x026D930A, 0x9C0906A9, 0xEB0E363F, 0x72076785, 0x05005713, 0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38, 0x92D28E9B, 0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21,
	0x86D3D2D4, 0xF1D4E242, 0x68DDB3F8, 0x1FDA836E, 0x81BE16CD, 0xF6B9265B, 0x6FB077E1, 0x18B74777, 0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C, 0x8F659EFF, 0xF862AE69, 0x616BFFD3, 0x166CCF45,
	0xA00AE278, 0xD70DD2EE, 0x4E048354, 0x3903B3C2, 0xA7672661, 0xD06016F7, 0x4969474D, 0x3E6E77DB, 0xAED16A4A, 0xD9D65ADC, 0x40DF0B66, 0x37D83BF0, 0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9,
	0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6, 0xBAD03605, 0xCDD70693, 0x54DE5729, 0x23D967BF, 0xB3667A2E, 0xC4614AB8, 0x5D681B02, 0x2A6F2B94, 0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B, 0x2D02EF8D,
	} when defined ( IMGUI_USE_LEGACY_CRC32_ADLER ) else { // preproc else
	// CRC32c table compatible with SSE 4.2 instructions
	0x00000000, 0xF26B8303, 0xE13B70F7, 0x1350F3F4, 0xC79A971F, 0x35F1141C, 0x26A1E7E8, 0xD4CA64EB, 0x8AD958CF, 0x78B2DBCC, 0x6BE22838, 0x9989AB3B, 0x4D43CFD0, 0xBF284CD3, 0xAC78BF27, 0x5E133C24,
	0x105EC76F, 0xE235446C, 0xF165B798, 0x030E349B, 0xD7C45070, 0x25AFD373, 0x36FF2087, 0xC494A384, 0x9A879FA0, 0x68EC1CA3, 0x7BBCEF57, 0x89D76C54, 0x5D1D08BF, 0xAF768BBC, 0xBC267848, 0x4E4DFB4B,
	0x20BD8EDE, 0xD2D60DDD, 0xC186FE29, 0x33ED7D2A, 0xE72719C1, 0x154C9AC2, 0x061C6936, 0xF477EA35, 0xAA64D611, 0x580F5512, 0x4B5FA6E6, 0xB93425E5, 0x6DFE410E, 0x9F95C20D, 0x8CC531F9, 0x7EAEB2FA,
	0x30E349B1, 0xC288CAB2, 0xD1D83946, 0x23B3BA45, 0xF779DEAE, 0x05125DAD, 0x1642AE59, 0xE4292D5A, 0xBA3A117E, 0x4851927D, 0x5B016189, 0xA96AE28A, 0x7DA08661, 0x8FCB0562, 0x9C9BF696, 0x6EF07595,
	0x417B1DBC, 0xB3109EBF, 0xA0406D4B, 0x522BEE48, 0x86E18AA3, 0x748A09A0, 0x67DAFA54, 0x95B17957, 0xCBA24573, 0x39C9C670, 0x2A993584, 0xD8F2B687, 0x0C38D26C, 0xFE53516F, 0xED03A29B, 0x1F682198,
	0x5125DAD3, 0xA34E59D0, 0xB01EAA24, 0x42752927, 0x96BF4DCC, 0x64D4CECF, 0x77843D3B, 0x85EFBE38, 0xDBFC821C, 0x2997011F, 0x3AC7F2EB, 0xC8AC71E8, 0x1C661503, 0xEE0D9600, 0xFD5D65F4, 0x0F36E6F7,
	0x61C69362, 0x93AD1061, 0x80FDE395, 0x72966096, 0xA65C047D, 0x5437877E, 0x4767748A, 0xB50CF789, 0xEB1FCBAD, 0x197448AE, 0x0A24BB5A, 0xF84F3859, 0x2C855CB2, 0xDEEEDFB1, 0xCDBE2C45, 0x3FD5AF46,
	0x7198540D, 0x83F3D70E, 0x90A324FA, 0x62C8A7F9, 0xB602C312, 0x44694011, 0x5739B3E5, 0xA55230E6, 0xFB410CC2, 0x092A8FC1, 0x1A7A7C35, 0xE811FF36, 0x3CDB9BDD, 0xCEB018DE, 0xDDE0EB2A, 0x2F8B6829,
	0x82F63B78, 0x709DB87B, 0x63CD4B8F, 0x91A6C88C, 0x456CAC67, 0xB7072F64, 0xA457DC90, 0x563C5F93, 0x082F63B7, 0xFA44E0B4, 0xE9141340, 0x1B7F9043, 0xCFB5F4A8, 0x3DDE77AB, 0x2E8E845F, 0xDCE5075C,
	0x92A8FC17, 0x60C37F14, 0x73938CE0, 0x81F80FE3, 0x55326B08, 0xA759E80B, 0xB4091BFF, 0x466298FC, 0x1871A4D8, 0xEA1A27DB, 0xF94AD42F, 0x0B21572C, 0xDFEB33C7, 0x2D80B0C4, 0x3ED04330, 0xCCBBC033,
	0xA24BB5A6, 0x502036A5, 0x4370C551, 0xB11B4652, 0x65D122B9, 0x97BAA1BA, 0x84EA524E, 0x7681D14D, 0x2892ED69, 0xDAF96E6A, 0xC9A99D9E, 0x3BC21E9D, 0xEF087A76, 0x1D63F975, 0x0E330A81, 0xFC588982,
	0xB21572C9, 0x407EF1CA, 0x532E023E, 0xA145813D, 0x758FE5D6, 0x87E466D5, 0x94B49521, 0x66DF1622, 0x38CC2A06, 0xCAA7A905, 0xD9F75AF1, 0x2B9CD9F2, 0xFF56BD19, 0x0D3D3E1A, 0x1E6DCDEE, 0xEC064EED,
	0xC38D26C4, 0x31E6A5C7, 0x22B65633, 0xD0DDD530, 0x0417B1DB, 0xF67C32D8, 0xE52CC12C, 0x1747422F, 0x49547E0B, 0xBB3FFD08, 0xA86F0EFC, 0x5A048DFF, 0x8ECEE914, 0x7CA56A17, 0x6FF599E3, 0x9D9E1AE0,
	0xD3D3E1AB, 0x21B862A8, 0x32E8915C, 0xC083125F, 0x144976B4, 0xE622F5B7, 0xF5720643, 0x07198540, 0x590AB964, 0xAB613A67, 0xB831C993, 0x4A5A4A90, 0x9E902E7B, 0x6CFBAD78, 0x7FAB5E8C, 0x8DC0DD8F,
	0xE330A81A, 0x115B2B19, 0x020BD8ED, 0xF0605BEE, 0x24AA3F05, 0xD6C1BC06, 0xC5914FF2, 0x37FACCF1, 0x69E9F0D5, 0x9B8273D6, 0x88D28022, 0x7AB90321, 0xAE7367CA, 0x5C18E4C9, 0x4F48173D, 0xBD23943E,
	0xF36E6F75, 0x0105EC76, 0x12551F82, 0xE03E9C81, 0x34F4F86A, 0xC69F7B69, 0xD5CF889D, 0x27A40B9E, 0x79B737BA, 0x8BDCB4B9, 0x988C474D, 0x6AE7C44E, 0xBE2DA0A5, 0x4C4623A6, 0x5F16D052, 0xAD7D5351,
	} // preproc endif
} // preproc endif

//-----------------------------------------------------------------------------
// [SECTION] Generic helpers
// Note that the ImXXX helpers functions are lower-level than ImGui functions.
// ImGui functions or the ImGui context are never called/used from other ImXXX functions.
//-----------------------------------------------------------------------------
// - Helpers: Hashing
// - Helpers: Sorting
// - Helpers: Bit manipulation
// - Helpers: String
// - Helpers: Formatting
// - Helpers: UTF-8 <> wchar conversions
// - Helpers: ImVec2/ImVec4 operators
// - Helpers: Maths
// - Helpers: Geometry
// - Helper: ImVec1
// - Helper: ImVec2ih
// - Helper: ImRect
// - Helper: ImBitArray
// - Helper: ImBitVector
// - Helper: ImSpan<>, ImSpanAllocator<>
// - Helper: ImPool<>
// - Helper: ImChunkStream<>
// - Helper: ImGuiTextIndex
// - Helper: ImGuiStorage
//-----------------------------------------------------------------------------

when IMGUI_ENABLE_SSE4_2_CRC {
// Helpers: Hashing
// Known size hash
// It is ok to call ImHashData on a string with known length but the ### operator won't be supported.
// FIXME-OPT: Replace with e.g. FNV1a hash? CRC32 pretty much randomly access 1KB. Need to do proper measurements.
@(enable_target_feature="sse4.2")
ImHashData :: proc(data_p : rawptr, data_size : uint, seed : ImGuiID = 0) -> ImGuiID
{
	crc : ImU32 = ~seed
	data := cast([^]u8) data_p
	data_end := (cast([^]u8) data_p)[data_size:]
	for data[4:] <= data_end {
		crc = simd_x86._mm_crc32_u32(crc, (cast(^ImU32) data)^)
		data = data[4:]
	}

	for data < data_end { crc = simd_x86._mm_crc32_u8(crc, post_incr(&data)^) }

	return ~crc
}

} else {

ImHashData :: proc(data_p : rawptr, data_size : uint, seed : ImGuiID = 0) -> ImGuiID
{
	crc : ImU32 = ~seed
	data := cast([^]u8) data_p
	data_end := (cast([^]u8) data_p)[data_size:]
	for data < data_end { crc = (crc >> 8) ~ GCrc32LookupTable[(crc & 0xFF) ~ post_incr(&data)^] }

	return ~crc
}

}

// Zero-terminated string hash, with support for ### to reset back to seed value
// We support a syntax of "label###id" where only "###id" is included in the hash, and only "label" gets displayed.
// Because this syntax is rarely used we are optimizing for the common case.
// - If we reach ### in the string we discard the hash so far and reset to the seed.
// - We don't do 'current += 2; continue;' after handling ### to keep the code smaller/faster (measured ~10% diff in Debug build)
// FIXME-OPT: Replace with e.g. FNV1a hash? CRC32 pretty much randomly access 1KB. Need to do proper measurements.

ImHashStr :: proc{ ImHashStr_s, ImHashStr_p }

ImHashStr_s :: #force_inline proc(data : string, seed : ImGuiID = 0) -> ImGuiID
{
	return ImHashStr_p(raw_data(data), len(data), seed)
}

when IMGUI_ENABLE_SSE4_2_CRC { // NOTe(Rennorb): fix for enable_target_feeature incopmpatability is dumplicating the fn
@(enable_target_feature="sse4.2")
ImHashStr_p :: proc(data_p : [^]u8, data_size : uint = 0, seed : ImGuiID = 0) -> ImGuiID
{
	seed := ~seed
	crc : ImU32 = seed
	data := data_p

	@(enable_target_feature="sse4.2")
	step :: #force_inline proc(crc : ImU32, c : u8) -> ImU32 { return simd_x86._mm_crc32_u8(crc, c) }

	if data_size != 0 {
		data_size := data_size
		for post_decr(&data_size) != 0 {
			c : u8 = post_incr(&data)^
			if c == '#' && data_size >= 2 && data[0] == '#' && data[1] == '#' { crc = seed }
			crc = step(crc, c)
		}
	}
	else {
		for {
			c : u8 = post_incr(&data)^
			if c == 0 { break }

			if c == '#' && data[0] == '#' && data[1] == '#' { crc = seed }
			crc = step(crc, c)
		}
	}
	return ~crc
}
} else {
ImHashStr_p :: proc(data_p : [^]u8, data_size : uint = 0, seed : ImGuiID = 0) -> ImGuiID
{
	seed := ~seed
	crc : ImU32 = seed
	data := data_p

	step :: #force_inline proc(crc : ImU32, c : u8) -> ImU32 { return (crc >> 8) ~ GCrc32LookupTable[(crc & 0xFF) ~ u32(c)] }

	if data_size != 0 {
		data_size := data_size
		for post_decr(&data_size) != 0 {
			c : u8 = post_incr(&data)^
			if c == '#' && data_size >= 2 && data[0] == '#' && data[1] == '#' { crc = seed }
			crc = step(crc, c)
		}
	}
	else {
		for {
			c : u8 = post_incr(&data)^
			if c == 0 { break }

			if c == '#' && data[0] == '#' && data[1] == '#' { crc = seed }
			crc = step(crc, c)
		}
	}
	return ~crc
}
}

//-----------------------------------------------------------------------------
// [SECTION] MISC HELPERS/UTILITIES (File functions)
//-----------------------------------------------------------------------------

// Default file functions
when ! IMGUI_DISABLE_DEFAULT_FILE_FUNCTIONS {

ImFileOpen :: proc(filename : string, mode : string) -> ImFileHandle
{
	m : int
	switch mode {
		case "r": m = os.O_RDONLY
		case "w": m = os.O_WRONLY
		case "rw", "wr": m = os.O_RDWR
		case "a": m = os.O_APPEND
	}
	h, err := os.open(filename, m)
	return err == nil ? h : os.INVALID_HANDLE
}

// We should in theory be using fseeko()/ftello() with off_t and _fseeki64()/_ftelli64() with __int64, waiting for the PR that does that in a very portable pre-C++11 zero-warnings way.
ImFileClose :: proc(f : ImFileHandle) -> bool { return os.close(f) == nil }
ImFileGetSize :: proc(f : ImFileHandle) -> ImU64
{
	s, err := os.file_size(f)
	return err == nil ? u64(s) : ~u64(0)
}
ImFileRead :: proc(data : rawptr, sz : ImU64, count : ImU64, f : ImFileHandle) -> ImU64 { return cast(u64) fread(data, cast(uint) sz, cast(uint) count, f) }
ImFileWrite :: proc(data : rawptr, sz : ImU64, count : ImU64, f : ImFileHandle) -> ImU64 { return cast(u64) fwrite(data, cast(uint) sz, cast(uint) count, f) }
} // preproc endif// #ifndef IMGUI_DISABLE_DEFAULT_FILE_FUNCTIONS

// Helper: Load file content into memory
// Memory allocated with IM_ALLOC(), must be freed by user using IM_FREE() == ImGui::MemFree()
// This can't really be used with "rt" because fseek size won't match read size.
ImFileLoadToMemory :: proc(filename : string, mode : string, out_file_size : ^uint = nil, padding_bytes : i32 = 0) -> rawptr
{
	IM_ASSERT(filename != "" && mode != "")
	if out_file_size != nil { out_file_size^ = 0 }

	f : ImFileHandle = ImFileOpen(filename, mode)
	if f == {} { return nil }

	file_size : uint = cast(uint) ImFileGetSize(f)
	if file_size == ~cast(uint)(0) {
		ImFileClose(f)
		return nil
	}

	file_data : rawptr = IM_ALLOC(file_size + cast(uint)padding_bytes)
	if file_data == nil {
		ImFileClose(f)
		return nil
	}
	if ImFileRead(file_data, 1, cast(u64)file_size, f) != cast(u64)file_size {
		ImFileClose(f)
		IM_FREE(file_data)
		return nil
	}
	if padding_bytes > 0 { memset(cast(rawptr) (cast([^]u8) file_data)[file_size:], 0, cast(int) padding_bytes) }

	ImFileClose(f)
	if out_file_size != nil { out_file_size^ = file_size }

	return file_data
}

// read one character. return input UTF-8 bytes count
//-----------------------------------------------------------------------------
// [SECTION] MISC HELPERS/UTILITIES (ImText* functions)
//-----------------------------------------------------------------------------



// Convert UTF-8 to 32-bit character, process single character input.
// A nearly-branchless UTF-8 decoder, based on work of Christopher Wellons (https://github.com/skeeto/branchless-utf8).
// We handle UTF-8 decoding error by skipping forward.
ImTextCharFromUtf8 :: proc(out_char : ^u32, in_text : [^]u8, in_text_end : ^u8) -> i32
{
	lengths : [32]u8 = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 3, 3, 4, 0}
	masks : [5]u8 = {0x00, 0x7f, 0x1f, 0x0f, 0x07}
	mins : [5]u32 = {0x400000, 0, 0x80, 0x800, 0x10000}
	shiftc : [5]u32 = {0, 18, 12, 6, 0}
	shifte : [5]u32 = {0, 6, 4, 2, 0}
	len : i32 = cast(i32) lengths[in_text[0] >> 3]
	wanted : i32 = len + (len != 0 ? 0 : 1)

	in_text_end := in_text_end
	if in_text_end == nil {
		// Max length, nulls will be taken into account.
		in_text_end = &in_text[wanted]
	}

	// Copy at most 'len' bytes, stop copying at 0 or past in_text_end. Branch predictor does a good job here,
	// so it is fast even with excessive branching.
	s : [4]u8
	s[0] = in_text[0:] < in_text_end ? in_text[0] : 0
	s[1] = in_text[1:] < in_text_end ? in_text[1] : 0
	s[2] = in_text[2:] < in_text_end ? in_text[2] : 0
	s[3] = in_text[3:] < in_text_end ? in_text[3] : 0

	// Assume a four-byte character and load four bytes. Unused bits are shifted out.
	out_char^  = cast(u32) (s[0] & masks[len]) << 18
	out_char^ |= cast(u32) (s[1] & 0x3f) << 12
	out_char^ |= cast(u32) (s[2] & 0x3f) << 6
	out_char^ |= cast(u32) (s[3] & 0x3f) << 0
	out_char^ >>= shiftc[len]

	// Accumulate the various error conditions.
	e : i32 = 0
	e = (out_char^ < mins[len] ? 1 : 0) << 6; // non-canonical encoding
	e |= ((out_char^ >> 11) == 0x1b ? 1 : 0) << 7; // surrogate half?
	e |= (out_char^ > IM_UNICODE_CODEPOINT_MAX ? 1 : 0) << 8; // out of range?
	e |= (cast(i32) s[1] & 0xc0) >> 2
	e |= (cast(i32) s[2] & 0xc0) >> 4
	e |= (cast(i32) s[3]) >> 6
	e ~= 0x2a; // top two bits of each tail byte correct?
	e >>= shifte[len]

	if e != 0 {
		// No bytes are consumed when *in_text == 0 || in_text == in_text_end.
		// One byte is consumed in case of invalid first byte of in_text.
		// All available bytes (at most `len` bytes) are consumed on incomplete/invalid second to last bytes.
		// Invalid or incomplete input may consume less bytes than wanted, therefore every byte has to be inspected in s.
		wanted = ImMin(wanted, (s[0] != 0 ? 1 : 0) + (s[1] != 0 ? 1 : 0) + (s[2] != 0 ? 1 : 0) + (s[3] != 0 ? 1 : 0))
		out_char^ = IM_UNICODE_CODEPOINT_INVALID
	}

	return wanted
}

// return input UTF-8 bytes count
ImTextStrFromUtf8 :: proc(buf : []ImWchar, in_text : []u8, in_text_remaining : ^[^]u8 = nil) -> i32
{
	in_text_end := raw_data(in_text)[len(in_text):]
	in_text := raw_data(in_text)

	buf_out := raw_data(buf)
	buf_end := raw_data(buf)[len(buf):]

	for buf_out < buf_end[-1:] && (in_text_end == nil || in_text < in_text_end) && in_text[0] != 0 {
		c : u32
		in_text = in_text[ImTextCharFromUtf8(&c, in_text, in_text_end):]
		post_incr(&buf_out)^ = cast(ImWchar) c
	}

	buf_out[0] = 0
	if in_text_remaining != nil { in_text_remaining^ = in_text }
	return cast(i32) mem.ptr_sub(buf_out, raw_data(buf))
}

// return number of UTF-8 code-points (NOT bytes count)
ImTextCountCharsFromUtf8 :: proc(in_text : []u8) -> i32
{
	in_text_end := raw_data(in_text)[len(in_text):]
	in_text := raw_data(in_text)
	char_count : i32 = 0
	for in_text < in_text_end && in_text[0] != 0 {
		c : u32
		in_text = in_text[ImTextCharFromUtf8(&c, in_text, in_text_end):]
		post_incr(&char_count)
	}

	return char_count
}

// Based on stb_to_utf8() from github.com/nothings/stb/
ImTextCharToUtf8_inline :: #force_inline proc(buf : []u8, c : u32) -> i32
{
	if c < 0x80 {
		buf[0] = cast(u8) c
		return 1
	}
	if c < 0x800 {
		if len(buf) < 2 { return 0 }
		buf[0] = cast(u8) (0xc0 + (c >> 6))
		buf[1] = cast(u8) (0x80 + (c & 0x3f))
		return 2
	}
	if c < 0x10000 {
		if len(buf) < 3 { return 0 }
		buf[0] = cast(u8) (0xe0 + (c >> 12))
		buf[1] = cast(u8) (0x80 + ((c >> 6) & 0x3f))
		buf[2] = cast(u8) (0x80 + ((c) & 0x3f))
		return 3
	}
	if c <= 0x10FFFF {
		if len(buf) < 4 { return 0 }
		buf[0] = cast(u8) (0xf0 + (c >> 18))
		buf[1] = cast(u8) (0x80 + ((c >> 12) & 0x3f))
		buf[2] = cast(u8) (0x80 + ((c >> 6) & 0x3f))
		buf[3] = cast(u8) (0x80 + ((c) & 0x3f))
		return 4
	}
	// Invalid code point, the max unicode is 0x10FFFF
	return 0
}

// Helpers: UTF-8 <> wchar conversions
// return out_buf
ImTextCharToUtf8 :: proc(out_buf : ^[5]u8, c : u32) -> [^]u8
{
	count : i32 = ImTextCharToUtf8_inline(out_buf[:], c)
	out_buf[count] = 0
	return raw_data(out_buf)
}

// return number of bytes to express one char in UTF-8
// Not optimal but we very rarely use this function.
ImTextCountUtf8BytesFromChar_0 :: proc(in_text : [^]u8, in_text_end : ^u8) -> i32
{
	unused : u32 = 0
	return ImTextCharFromUtf8(&unused, in_text, in_text_end)
}

ImTextCountUtf8BytesFromChar_1 :: #force_inline proc(c : u32) -> i32
{
	if c < 0x80 { return 1 }
	if c < 0x800 { return 2 }
	if c < 0x10000 { return 3 }
	if c <= 0x10FFFF { return 4 }
	return 3
}

// return output UTF-8 bytes count
ImTextStrToUtf8 :: proc(out_buf : []u8, in_text : []ImWchar) -> i32
{
	in_text_end := raw_data(in_text)[len(in_text):]
	in_text := raw_data(in_text)

	buf_p := raw_data(out_buf)
	buf_end := raw_data(out_buf)[len(out_buf):]
	for buf_p < buf_end[-1:] && (in_text_end == nil || in_text < in_text_end) && in_text[0] != 0 {
		c : u32 = cast(u32) (post_incr(&in_text)^)
		if c < 0x80 { post_incr(&buf_p)^ = cast(u8) c }
		else { buf_p = buf_p[ImTextCharToUtf8_inline(buf_p[:mem.ptr_sub(buf_end, buf_p[-1:])], c):] }
	}

	buf_p[0] = 0
	return cast(i32) mem.ptr_sub(buf_p, raw_data(out_buf))
}

// return number of bytes to express string in UTF-8
ImTextCountUtf8BytesFromStr :: proc(in_text : []ImWchar) -> i32
{
	in_text_end := raw_data(in_text)[len(in_text):]
	in_text := raw_data(in_text)
	bytes_count : i32 = 0
	for (in_text_end == nil || in_text < in_text_end) && in_text[0] != 0 {
		c : u32 = cast(u32) (post_incr(&in_text)^)
		if c < 0x80 { post_incr(&bytes_count) }
		else { bytes_count += ImTextCountUtf8BytesFromChar(c) }
	}

	return bytes_count
}

// return previous UTF-8 code-point.
ImTextFindPreviousUtf8Codepoint :: proc(in_text_start : [^]u8, in_text_curr : [^]u8) -> [^]u8
{
	in_text_curr := in_text_curr
	for in_text_curr > in_text_start {
		post_decr(&in_text_curr)
		if (in_text_curr[0] & 0xC0) != 0x80 { return in_text_curr }
	}

	return in_text_start
}

// return number of lines taken by text. trailing carriage return doesn't count as an extra line.
ImTextCountLines :: proc(in_text : [^]u8, in_text_end : ^u8) -> i32
{
	in_text := in_text; in_text_end := in_text_end

	if in_text_end == nil {
		// FIXME-OPT: Not optimal approach, discourage use for now.
		in_text_end = &in_text[strlen(in_text)]
	}
	count : i32 = 0
	for in_text < in_text_end {
		line_end : ^u8 = cast(^u8) memchr(in_text, '\n', mem.ptr_sub(in_text_end, cast(^u8)in_text))
		in_text = line_end != nil ? mem.ptr_offset(line_end, 1) : in_text_end
		post_incr(&count)
	}

	return count
}



// Helpers: Color Blending
//-----------------------------------------------------------------------------
// [SECTION] MISC HELPERS/UTILITIES (Color functions)
// Note: The Convert functions are early design which are not consistent with other API.
//-----------------------------------------------------------------------------

ImAlphaBlendColors :: proc(col_a : ImU32, col_b : ImU32) -> ImU32
{
	t : f32 = f32((col_b >> IM_COL32_A_SHIFT) & 0xFF) / 255.0
	r : i32 = ImLerp(cast(i32) (col_a >> IM_COL32_R_SHIFT) & 0xFF, cast(i32) (col_b >> IM_COL32_R_SHIFT) & 0xFF, t)
	g : i32 = ImLerp(cast(i32) (col_a >> IM_COL32_G_SHIFT) & 0xFF, cast(i32) (col_b >> IM_COL32_G_SHIFT) & 0xFF, t)
	b : i32 = ImLerp(cast(i32) (col_a >> IM_COL32_B_SHIFT) & 0xFF, cast(i32) (col_b >> IM_COL32_B_SHIFT) & 0xFF, t)
	return IM_COL32(r, g, b, 0xFF)
}

ColorConvertU32ToFloat4 :: proc(_in : ImU32) -> ImVec4
{
	s : f32 = 1.0 / 255.0
	return ImVec4{f32((_in >> IM_COL32_R_SHIFT) & 0xFF), f32((_in >> IM_COL32_G_SHIFT) & 0xFF), f32((_in >> IM_COL32_B_SHIFT) & 0xFF), f32((_in >> IM_COL32_A_SHIFT) & 0xFF)} * s
}

ColorConvertFloat4ToU32 :: proc(_in : ImVec4) -> ImU32
{
	out : ImU32
	out = (cast(ImU32) IM_F32_TO_INT8_SAT(_in.x)) << IM_COL32_R_SHIFT
	out |= (cast(ImU32) IM_F32_TO_INT8_SAT(_in.y)) << IM_COL32_G_SHIFT
	out |= (cast(ImU32) IM_F32_TO_INT8_SAT(_in.z)) << IM_COL32_B_SHIFT
	out |= (cast(ImU32) IM_F32_TO_INT8_SAT(_in.w)) << IM_COL32_A_SHIFT
	return out
}

// Convert rgb floats ([0-1],[0-1],[0-1]) to hsv floats ([0-1],[0-1],[0-1]), from Foley & van Dam p592
// Optimized http://lolengine.net/blog/2013/01/13/fast-rgb-to-hsv
ColorConvertRGBtoHSV :: proc(r : f32, g : f32, b : f32, out_h : ^f32, out_s : ^f32, out_v : ^f32)
{
	g := g; b := b; r := r
	K : f32 = 0.0
	if g < b {
		ImSwap(&g, &b)
		K = -1.0
	}
	if r < g {
		ImSwap(&r, &g)
		K = -2.0 / 6.0 - K
	}

	chroma : f32 = r - (g < b ? g : b)
	out_h^ = ImFabs(K + (g - b) / (6.0 * chroma + 1e-20))
	out_s^ = chroma / (r + 1e-20)
	out_v^ = r
}

// Convert hsv floats ([0-1],[0-1],[0-1]) to rgb floats ([0-1],[0-1],[0-1]), from Foley & van Dam p593
// also http://en.wikipedia.org/wiki/HSL_and_HSV
ColorConvertHSVtoRGB :: proc(h : f32, s : f32, v : f32, out_r : ^f32, out_g : ^f32, out_b : ^f32)
{
	out_g := out_g; out_r := out_r; 

	if s == 0.0 {
		// gray
		out_g = out_b; out_r = out_g
		out_b^ = v
		return
	}

	h := ImFmod(h, 1.0) / (60.0 / 360.0)
	i : i32 = cast(i32) h
	f : f32 = h - cast(f32) i
	p : f32 = v * (1.0 - s)
	q : f32 = v * (1.0 - s * f)
	t : f32 = v * (1.0 - s * (1.0 - f))

	switch i {
		case 0: out_r^ = v; out_g^ = t; out_b^ = p; break
		case 1: out_r^ = q; out_g^ = v; out_b^ = p; break
		case 2: out_r^ = p; out_g^ = v; out_b^ = t; break
		case 3: out_r^ = p; out_g^ = q; out_b^ = v; break
		case 4: out_r^ = t; out_g^ = p; out_b^ = v; break
		case 5: fallthrough
		case  : out_r^ = v; out_g^ = p; out_b^ = q; break
	}
}

// Helper: ImGuiStorage
//-----------------------------------------------------------------------------
// [SECTION] ImGuiStorage
// Helper: Key->value storage
//-----------------------------------------------------------------------------

// std::lower_bound but without the bullshit
ImLowerBound :: proc(in_begin : [^]ImGuiStoragePair, in_end : ^ImGuiStoragePair, key : ImGuiID) -> ^ImGuiStoragePair
{
	in_p : [^]ImGuiStoragePair = in_begin
	for count : uint = cast(uint) mem.ptr_sub(in_end, cast(^ImGuiStoragePair) in_p); count > 0;  {
		count2 : uint = count >> 1
		mid := in_p[count2:]
		if mid[0].key < key {
			in_p = pre_incr(&mid)
			count -= count2 + 1
		}
		else {
			count = count2
		}
	}

	return in_p
}


PairComparerByID :: proc(lhs, rhs : ImGuiStoragePair) -> slice.Ordering
{
	// We can't just do a subtraction because qsort uses signed integers and subtracting our ID doesn't play well with that.
	lhs_v : ImGuiID = lhs.key
	rhs_v : ImGuiID = rhs.key
	return lhs_v > rhs_v ? .Greater : lhs_v < rhs_v ? .Less : .Equal
}

// Advanced: for quicker full rebuild of a storage (instead of an incremental one), you may add all your contents and then sort once.
// For quicker full rebuild of a storage (instead of an incremental one), you may add all your contents and then sort once.
ImGuiStorage_BuildSortByKey :: proc(this : ^ImGuiStorage)
{
	ImQsort(this.Data.Data[:this.Data.Size], PairComparerByID)
}

ImGuiStorage_GetInt :: proc(this : ^ImGuiStorage, key : ImGuiID, default_val : i32 = 0) -> i32
{
	it : ^ImGuiStoragePair = ImLowerBound(transmute(^ImGuiStoragePair) this.Data.Data, transmute(^ImGuiStoragePair) &this.Data.Data[this.Data.Size], key)
	if it == &this.Data.Data[this.Data.Size] || it.key != key { return default_val }
	return it.val_i
}

ImGuiStorage_GetBool :: proc(this : ^ImGuiStorage, key : ImGuiID, default_val : bool = false) -> bool
{
	return ImGuiStorage_GetInt(this, key, default_val ? 1 : 0) != 0
}

ImGuiStorage_GetFloat :: proc(this : ^ImGuiStorage, key : ImGuiID, default_val : f32 = 0.0) -> f32
{
	it : ^ImGuiStoragePair = ImLowerBound(transmute(^ImGuiStoragePair) this.Data.Data, transmute(^ImGuiStoragePair) &this.Data.Data[this.Data.Size], key)
	if it == &this.Data.Data[this.Data.Size] || it.key != key { return default_val }
	return it.val_f
}

// default_val is NULL
ImGuiStorage_GetVoidPtr :: proc(this : ^ImGuiStorage, key : ImGuiID) -> rawptr
{
	it : ^ImGuiStoragePair = ImLowerBound(transmute(^ImGuiStoragePair) this.Data.Data, transmute(^ImGuiStoragePair) &this.Data.Data[this.Data.Size], key)
	if it == &this.Data.Data[this.Data.Size] || it.key != key { return nil }
	return it.val_p
}

// - Get***Ref() functions finds pair, insert on demand if missing, return pointer. Useful if you intend to do Get+Set.
// - References are only valid until a new value is added to the storage. Calling a Set***() function or a Get***Ref() function invalidates the pointer.
// - A typical use case where this is convenient for quick hacking (e.g. add storage during a live Edit&Continue session if you can't modify existing struct)
//      float* pvar = ImGui::GetFloatRef(key); ImGui::SliderFloat("var", pvar, 0, 100.0f); some_var += *pvar;
// References are only valid until a new value is added to the storage. Calling a Set***() function or a Get***Ref() function invalidates the pointer.
ImGuiStorage_GetIntRef :: proc(this : ^ImGuiStorage, key : ImGuiID, default_val : i32 = 0) -> ^i32
{
	it : ^ImGuiStoragePair = ImLowerBound(this.Data.Data, &this.Data.Data[this.Data.Size], key)
	if it == &this.Data.Data[this.Data.Size] || it.key != key { it = insert(&this.Data, it, ImGuiStoragePair{key = key, val_i = default_val}) }
	return &it.val_i
}

ImGuiStorage_GetBoolRef :: proc(this : ^ImGuiStorage, key : ImGuiID, default_val : bool = false) -> ^bool
{
	return cast(^bool) ImGuiStorage_GetIntRef(this, key, default_val ? 1 : 0)
}

ImGuiStorage_GetFloatRef :: proc(this : ^ImGuiStorage, key : ImGuiID, default_val : f32 = 0.0) -> ^f32
{
	it : ^ImGuiStoragePair = ImLowerBound(this.Data.Data, &this.Data.Data[this.Data.Size], key)
	if it == &this.Data.Data[this.Data.Size] || it.key != key { it = insert(&this.Data, it, ImGuiStoragePair{key = key, val_f = default_val}) }
	return &it.val_f
}

ImGuiStorage_GetVoidPtrRef :: proc(this : ^ImGuiStorage, key : ImGuiID, default_val : rawptr = nil) -> ^rawptr
{
	it : ^ImGuiStoragePair = ImLowerBound(this.Data.Data, &this.Data.Data[this.Data.Size], key)
	if it == &this.Data.Data[this.Data.Size] || it.key != key { it = insert(&this.Data, it, ImGuiStoragePair{key = key, val_p = default_val}) }
	return &it.val_p
}

// FIXME-OPT: Need a way to reuse the result of lower_bound when doing GetInt()/SetInt() - not too bad because it only happens on explicit interaction (maximum one a frame)
ImGuiStorage_SetInt :: proc(this : ^ImGuiStorage, key : ImGuiID, val : i32)
{
	it : ^ImGuiStoragePair = ImLowerBound(this.Data.Data, &this.Data.Data[this.Data.Size], key)
	if it == &this.Data.Data[this.Data.Size] || it.key != key { insert(&this.Data, it, ImGuiStoragePair{key = key, val_i = val}) }
	else { it.val_i = val }
}

ImGuiStorage_SetBool :: proc(this : ^ImGuiStorage, key : ImGuiID, val : bool)
{
	ImGuiStorage_SetInt(this, key, val ? 1 : 0)
}

ImGuiStorage_SetFloat :: proc(this : ^ImGuiStorage, key : ImGuiID, val : f32)
{
	it : ^ImGuiStoragePair = ImLowerBound(this.Data.Data, &this.Data.Data[this.Data.Size], key)
	if it == &this.Data.Data[this.Data.Size] || it.key != key { insert(&this.Data, it, ImGuiStoragePair{key = key, val_f = val}) }
	else { it.val_f = val }
}

ImGuiStorage_SetVoidPtr :: proc(this : ^ImGuiStorage, key : ImGuiID, val : rawptr)
{
	it : ^ImGuiStoragePair = ImLowerBound(this.Data.Data, &this.Data.Data[this.Data.Size], key)
	if it == &this.Data.Data[this.Data.Size] || it.key != key { insert(&this.Data, it, ImGuiStoragePair{key = key, val_p = val}) }
	else { it.val_p = val }
}

// Obsolete: use on your own storage if you know only integer are being stored (open/close all tree nodes)
ImGuiStorage_SetAllInt :: proc(this : ^ImGuiStorage, v : i32)
{
	for i : i32 = 0; i < this.Data.Size; i += 1 { this.Data.Data[i].val_i = v }
}


//-V1077//-----------------------------------------------------------------------------
// [SECTION] ImGuiTextFilter
//-----------------------------------------------------------------------------

// Helper: Parse and apply text filters. In format "aaaaa[,bbbb][,ccccc]"
ImGuiTextFilter_init :: proc(this : ^ImGuiTextFilter, default_filter : string = "")
{
	init(&this.Filters)
	this.InputBuf[0] = 0
	this.CountGrep = 0
	if default_filter != "" {
		ImStrncpy(raw_data(&this.InputBuf), raw_data(default_filter), cast(uint) IM_ARRAYSIZE(this.InputBuf))
		ImGuiTextFilter_Build(this)
	}
}

// Helper calling InputText+Build
ImGuiTextFilter_Draw :: proc(this : ^ImGuiTextFilter, label : string = "Filter (inc,-exc)", width : f32 = 0.0) -> bool
{
	if width != 0.0 { SetNextItemWidth(width) }
	value_changed : bool = InputText(label, this.InputBuf[:])
	if value_changed { ImGuiTextFilter_Build(this) }
	return value_changed
}

ImGuiTextFilter_ImGuiTextRange_split :: proc(this : ^ImGuiTextFilter_ImGuiTextRange, separator : u8, out : ^ImVector(ImGuiTextFilter_ImGuiTextRange))
{
	resize(out, 0)
	wb : [^]u8 = this.b
	we : ^u8 = wb
	for we < this.e {
		if we^ == separator {
			push_back(out, ImGuiTextFilter_ImGuiTextRange{wb, we})
			wb = mem.ptr_offset(we, 1)
		}
		post_incr(&we)
	}
	if wb != we { push_back(out, ImGuiTextFilter_ImGuiTextRange{wb, we}) }
}

ImGuiTextFilter_Build :: proc(this : ^ImGuiTextFilter)
{
	resize(&this.Filters, 0)
	input_range : ImGuiTextFilter_ImGuiTextRange; init(&input_range, raw_data(&this.InputBuf), &this.InputBuf[strlen(raw_data(&this.InputBuf))])
	split(&input_range, ',', &this.Filters)

	this.CountGrep = 0
	for &f in this.Filters.Data[:this.Filters.Size] {
		for f.b < f.e && ImCharIsBlankA(f.b[0]) { post_incr(&f.b) }

		for f.e > f.b && ImCharIsBlankA(mem.ptr_offset(f.e, -1)^) { post_decr(&f.e) }

		if empty(&f) { continue }
		if f.b[0] != '-' { this.CountGrep += 1 }
	}
}

ImGuiTextFilter_PassFilter :: proc(this : ^ImGuiTextFilter, text : string) -> bool
{
	if this.Filters.Size == 0 { return true }

	for f in this.Filters.Data[:this.Filters.Size] {
		if f.b == f.e { continue }
		if f.b[0] == '-' {
			// Subtract
			if ImStristr(transmute([]u8) text, slice_from_se(f.b[1:], f.e)) != nil { return false }
		}
		else {
			// Grep
			if ImStristr(transmute([]u8) text, slice_from_se(f.b, f.e)) != nil { return true }
		}
	}

	// Implicit * grep
	if this.CountGrep == 0 { return true }

	return false
}

//-----------------------------------------------------------------------------
// [SECTION] ImGuiTextBuffer, ImGuiTextIndex
//-----------------------------------------------------------------------------


//char ImGuiTextBuffer::EmptyString[1] = { 0 };

ImGuiTextBuffer_append2 :: proc(this : ^ImGuiTextBuffer, str : string)
{
	ImGuiTextBuffer_append(this, raw_data(str), &raw_data(str)[len(str)])
}

ImGuiTextBuffer_append :: proc(this : ^ImGuiTextBuffer, str : [^]u8, str_end : ^u8 = nil)
{
	len : i32 = str_end != nil ? cast(i32) mem.ptr_sub(str_end, cast(^u8)str) : cast(i32) strlen(str)

	// Add zero-terminator the first time
	write_off : i32 = (this.Buf.Size != 0) ? this.Buf.Size : 1
	needed_sz : i32 = write_off + len
	if write_off + len >= this.Buf.Capacity {
		new_capacity : i32 = this.Buf.Capacity * 2
		reserve(&this.Buf, needed_sz > new_capacity ? needed_sz : new_capacity)
	}

	resize(&this.Buf, needed_sz)
	memcpy(&this.Buf.Data[write_off - 1], str, cast(int) len)
	this.Buf.Data[write_off - 1 + len] = 0
}

ImGuiTextBuffer_appendf :: proc(this : ^ImGuiTextBuffer, fmt : string, args : ..any)
{
	ImGuiTextBuffer_appendfv(this, fmt, args)
}

// Helper: Text buffer for logging/accumulating text
ImGuiTextBuffer_appendfv :: proc(this : ^ImGuiTextBuffer, fmt : string, args : []any)
{
	args_copy := args

	len : i32 = ImFormatStringV({}, fmt, args); // FIXME-OPT: could do a first pass write attempt, likely successful on first pass.
	if len <= 0 {
		return
	}

	// Add zero-terminator the first time
	write_off : i32 = (this.Buf.Size != 0) ? this.Buf.Size : 1
	needed_sz : i32 = write_off + len
	if write_off + len >= this.Buf.Capacity {
		new_capacity : i32 = this.Buf.Capacity * 2
		reserve(&this.Buf, needed_sz > new_capacity ? needed_sz : new_capacity)
	}

	resize(&this.Buf, needed_sz)
	ImFormatStringV(this.Buf.Data[write_off - 1:][:len + 1], fmt, args_copy)
}

ImGuiTextIndex_append :: proc(this : ^ImGuiTextIndex, base : [^]u8, old_size : i32, new_size : i32)
{
	IM_ASSERT(old_size >= 0 && new_size >= old_size && new_size >= this.EndOffset)
	if old_size == new_size { return }
	if this.EndOffset == 0 || base[this.EndOffset - 1] == '\n' { push_back(&this.LineOffsets, this.EndOffset) }
	base_end : ^u8 = base[new_size:]
	p : ^u8 = base[old_size:]
	for {
		p = cast(^u8) memchr(p, '\n', mem.ptr_sub(base_end, p))
		if p == nil { break }
		if pre_incr(&p) < base_end {
			// Don't push a trailing offset on last \n
			push_back(&this.LineOffsets, cast(i32) mem.ptr_sub(p, cast(^u8) base))
		}
	}

	this.EndOffset = ImMax(this.EndOffset, new_size)
}

//-----------------------------------------------------------------------------
// [SECTION] ImGuiListClipper
//-----------------------------------------------------------------------------

// FIXME-TABLE: This prevents us from using ImGuiListClipper _inside_ a table cell.
// The problem we have is that without a Begin/End scheme for rows using the clipper is ambiguous.
GetSkipItemForListClipping :: proc() -> bool
{
	g : ^ImGuiContext = GImGui
	return (g.CurrentTable != nil ? g.CurrentTable.HostSkipItems : g.CurrentWindow.SkipItems)
}

ImGuiListClipper_SortAndFuseRanges :: proc(ranges : ^ImVector(ImGuiListClipperRange), offset : i32 = 0)
{
	if ranges.Size - offset <= 1 { return }

	// Helper to order ranges and fuse them together if possible (bubble sort is fine as we are only sorting 2-3 entries)
	for sort_end : i32 = ranges.Size - offset - 1; sort_end > 0; sort_end -= 1 {
		for i : i32 = offset; i < sort_end + offset; i += 1 {
			if ranges.Data[i].Min > ranges.Data[i + 1].Min { ImSwap(&ranges.Data[i], &ranges.Data[i + 1]) }
		}
	}

	// Now fuse ranges together as much as possible.
	for i : i32 = 1 + offset; i < ranges.Size; i += 1 {
		IM_ASSERT(!ranges.Data[i].PosToIndexConvert && !ranges.Data[i - 1].PosToIndexConvert)
		if ranges.Data[i - 1].Max < ranges.Data[i].Min { continue }
		ranges.Data[i - 1].Min = ImMin(ranges.Data[i - 1].Min, ranges.Data[i].Min)
		ranges.Data[i - 1].Max = ImMax(ranges.Data[i - 1].Max, ranges.Data[i].Max)
		erase(ranges, &ranges.Data[i])
		post_decr(&i)
	}
}

ImGuiListClipper_SeekCursorAndSetupPrevLine :: proc(pos_y : f32, line_height : f32)
{
	// Set cursor position and a few other things so that SetScrollHereY() and Columns() can work when seeking cursor.
	// FIXME: It is problematic that we have to do that here, because custom/equivalent end-user code would stumble on the same issue.
	// The clipper should probably have a final step to display the last item in a regular manner, maybe with an opt-out flag for data sets which may have costly seek?
	g : ^ImGuiContext = GImGui
	window : ^ImGuiWindow = g.CurrentWindow
	off_y : f32 = pos_y - window.DC.CursorPos.y
	window.DC.CursorPos.y = pos_y
	window.DC.CursorMaxPos.y = ImMax(window.DC.CursorMaxPos.y, pos_y - g.Style.ItemSpacing.y)
	window.DC.CursorPosPrevLine.y = window.DC.CursorPos.y - line_height; // Setting those fields so that SetScrollHereY() can properly function after the end of our clipper usage.
	window.DC.PrevLineSize.y = (line_height - g.Style.ItemSpacing.y); // If we end up needing more accurate data (to e.g. use SameLine) we may as well make the clipper have a fourth step to let user process and display the last item in their list.
	if columns : ^ImGuiOldColumns = window.DC.CurrentColumns; columns != nil {
		// Setting this so that cell Y position are set properly
		columns.LineMinY = window.DC.CursorPos.y
	}
	if table : ^ImGuiTable = g.CurrentTable; table != nil {
		if table.IsInsideRow { TableEndRow(table) }
		table.RowPosY2 = window.DC.CursorPos.y
		row_increase : i32 = cast(i32) ((off_y / line_height) + 0.5)
		//table->CurrentRow += row_increase; // Can't do without fixing TableEndRow()
		table.RowBgColorCounter += row_increase
	}
}

ImGuiListClipper_deinit :: proc(this : ^ImGuiListClipper)
{
	ImGuiListClipper_End(this)
}

ImGuiListClipper_Begin :: proc(this : ^ImGuiListClipper, #any_int items_count : i32, items_height : f32 = -1.0)
{
	if this.Ctx == nil { this.Ctx = GetCurrentContext() }

	g : ^ImGuiContext = this.Ctx
	window : ^ImGuiWindow = g.CurrentWindow
	IMGUI_DEBUG_LOG_CLIPPER(g, "Clipper: Begin(%d,%.2f) in '%s'\n", items_count, items_height, window.Name)

	if table : ^ImGuiTable = g.CurrentTable; table != nil { if table.IsInsideRow { TableEndRow(table) } }

	this.StartPosY = window.DC.CursorPos.y
	this.ItemsHeight = items_height
	this.ItemsCount = items_count
	this.DisplayStart = -1
	this.DisplayEnd = 0

	// Acquire temporary buffer
	if pre_incr(&g.ClipperTempDataStacked) > g.ClipperTempData.Size { resize(&g.ClipperTempData, g.ClipperTempDataStacked, ImGuiListClipperData{}) }
	data : ^ImGuiListClipperData = &g.ClipperTempData.Data[g.ClipperTempDataStacked - 1]
	Reset(data, this)
	data.LossynessOffset = window.DC.CursorStartPosLossyness.y
	this.TempData = data
	this.StartSeekOffsetY = cast(f64) data.LossynessOffset
}

// Automatically called on the last call of Step() that returns false.
ImGuiListClipper_End :: proc(this : ^ImGuiListClipper)
{
	if data : ^ImGuiListClipperData = cast(^ImGuiListClipperData) this.TempData; data != nil {
		// In theory here we should assert that we are already at the right position, but it seems saner to just seek at the end and not assert/crash the user.
		g : ^ImGuiContext = this.Ctx
		IMGUI_DEBUG_LOG_CLIPPER(g, "Clipper: End() in '%s'\n", g.CurrentWindow.Name)
		if this.ItemsCount >= 0 && this.ItemsCount < INT_MAX && this.DisplayStart >= 0 { ImGuiListClipper_SeekCursorForItem(this, this.ItemsCount) }

		// Restore temporary buffer and fix back pointers which may be invalidated when nesting
		IM_ASSERT(data.ListClipper == this)
		data.StepNo = data.Ranges.Size
		if pre_decr(&g.ClipperTempDataStacked) > 0 {
			data = &g.ClipperTempData.Data[g.ClipperTempDataStacked - 1]
			data.ListClipper.TempData = data
		}
		this.TempData = nil
	}
	this.ItemsCount = -1
}

// item_end is exclusive e.g. use (42, 42+1) to make item 42 never clipped.
ImGuiListClipper_IncludeItemsByIndex :: proc(this : ^ImGuiListClipper, item_begin : i32, item_end : i32)
{
	data : ^ImGuiListClipperData = cast(^ImGuiListClipperData) this.TempData
	IM_ASSERT(this.DisplayStart < 0); // Only allowed after Begin() and if there has not been a specified range yet.
	IM_ASSERT(item_begin <= item_end)
	if item_begin < item_end { push_back(&data.Ranges, ImGuiListClipperRange_FromIndices(item_begin, item_end)) }
}

// Seek cursor toward given item. This is automatically called while stepping.
// - The only reason to call this is: you can use ImGuiListClipper::Begin(INT_MAX) if you don't know item count ahead of time.
// - In this case, after all steps are done, you'll want to call SeekCursorForItem(item_count).
// This is already called while stepping.
// The ONLY reason you may want to call this is if you passed INT_MAX to ImGuiListClipper::Begin() because you couldn't step item count beforehand.
ImGuiListClipper_SeekCursorForItem :: proc(this : ^ImGuiListClipper, item_n : i32)
{
	// - Perform the add and multiply with double to allow seeking through larger ranges.
	// - StartPosY starts from ItemsFrozen, by adding SeekOffsetY we generally cancel that out (SeekOffsetY == LossynessOffset - ItemsFrozen * ItemsHeight).
	// - The reason we store SeekOffsetY instead of inferring it, is because we want to allow user to perform Seek after the last step, where ImGuiListClipperData is already done.
	pos_y : f32 = cast(f32) (cast(f64) this.StartPosY + this.StartSeekOffsetY + cast(f64) item_n * cast(f64) this.ItemsHeight)
	ImGuiListClipper_SeekCursorAndSetupPrevLine(pos_y, this.ItemsHeight)
}

ImGuiListClipper_StepInternal :: proc(clipper : ^ImGuiListClipper) -> bool
{
	g : ^ImGuiContext = clipper.Ctx
	window : ^ImGuiWindow = g.CurrentWindow
	data : ^ImGuiListClipperData = cast(^ImGuiListClipperData) clipper.TempData
	IM_ASSERT(data != nil, "Called ImGuiListClipper::Step() too many times, or before ImGuiListClipper::Begin() ?")

	table : ^ImGuiTable = g.CurrentTable
	if table != nil && table.IsInsideRow { TableEndRow(table) }

	// No items
	if clipper.ItemsCount == 0 || GetSkipItemForListClipping() { return false }

	// While we are in frozen row state, keep displaying items one by one, unclipped
	// FIXME: Could be stored as a table-agnostic state.
	if data.StepNo == 0 && table != nil && !table.IsUnfrozenRows {
		clipper.DisplayStart = data.ItemsFrozen
		clipper.DisplayEnd = ImMin(data.ItemsFrozen + 1, clipper.ItemsCount)
		if clipper.DisplayStart < clipper.DisplayEnd { post_incr(&data.ItemsFrozen) }
		return true
	}

	// Step 0: Let you process the first element (regardless of it being visible or not, so we can measure the element height)
	calc_clipping : bool = false
	if data.StepNo == 0 {
		clipper.StartPosY = window.DC.CursorPos.y
		if clipper.ItemsHeight <= 0.0 {
			// Submit the first item (or range) so we can measure its height (generally the first range is 0..1)
			push_front(&data.Ranges, ImGuiListClipperRange_FromIndices(data.ItemsFrozen, data.ItemsFrozen + 1))
			clipper.DisplayStart = ImMax(data.Ranges.Data[0].Min, data.ItemsFrozen)
			clipper.DisplayEnd = ImMin(data.Ranges.Data[0].Max, clipper.ItemsCount)
			data.StepNo = 1
			return true
		}
		calc_clipping = true; // If on the first step with known item height, calculate clipping.
	}

	// Step 1: Let the clipper infer height from first range
	if clipper.ItemsHeight <= 0.0 {
		IM_ASSERT(data.StepNo == 1)
		if table != nil { IM_ASSERT(table.RowPosY1 == clipper.StartPosY && table.RowPosY2 == window.DC.CursorPos.y) }

		clipper.ItemsHeight = (window.DC.CursorPos.y - clipper.StartPosY) / cast(f32) (clipper.DisplayEnd - clipper.DisplayStart)
		affected_by_floating_point_precision : bool = ImIsFloatAboveGuaranteedIntegerPrecision(clipper.StartPosY) || ImIsFloatAboveGuaranteedIntegerPrecision(window.DC.CursorPos.y)
		if affected_by_floating_point_precision {
			// FIXME: Technically wouldn't allow multi-line entries.
			clipper.ItemsHeight = window.DC.PrevLineSize.y + g.Style.ItemSpacing.y
		}
		if clipper.ItemsHeight == 0.0 && clipper.ItemsCount == INT_MAX {
			// Accept that no item have been submitted if in indeterminate mode.
			return false
		}
		IM_ASSERT(clipper.ItemsHeight > 0.0, "Unable to calculate item height! First item hasn't moved the cursor vertically!")
		calc_clipping = true; // If item height had to be calculated, calculate clipping afterwards.
	}

	// Step 0 or 1: Calculate the actual ranges of visible elements.
	already_submitted : i32 = clipper.DisplayEnd
	if calc_clipping {
		// Record seek offset, this is so ImGuiListClipper::Seek() can be called after ImGuiListClipperData is done
		clipper.StartSeekOffsetY = cast(f64) data.LossynessOffset - cast(f64) data.ItemsFrozen * cast(f64) clipper.ItemsHeight

		if g.LogEnabled {
			// If logging is active, do not perform any clipping
			push_back(&data.Ranges, ImGuiListClipperRange_FromIndices(0, clipper.ItemsCount))
		}
		else {
			// Add range selected to be included for navigation
			is_nav_request : bool = (g.NavMoveScoringItems && g.NavWindow != nil && g.NavWindow.RootWindowForNav == window.RootWindowForNav)
			if is_nav_request { push_back(&data.Ranges, ImGuiListClipperRange_FromPositions(g.NavScoringNoClipRect.Min.y, g.NavScoringNoClipRect.Max.y, 0, 0)) }
			if is_nav_request && (g.NavMoveFlags & ImGuiNavMoveFlags_.ImGuiNavMoveFlags_IsTabbing) != {} && g.NavTabbingDir == -1 { push_back(&data.Ranges, ImGuiListClipperRange_FromIndices(clipper.ItemsCount - 1, clipper.ItemsCount)) }

			// Add focused/active item
			nav_rect_abs : ImRect = WindowRectRelToAbs(window, window.NavRectRel[0])
			if g.NavId != 0 && window.NavLastIds[0] == g.NavId { push_back(&data.Ranges, ImGuiListClipperRange_FromPositions(nav_rect_abs.Min.y, nav_rect_abs.Max.y, 0, 0)) }

			// Add visible range
			min_y : f32 = window.ClipRect.Min.y
			max_y : f32 = window.ClipRect.Max.y

			// Add box selection range
			bs : ^ImGuiBoxSelectState = &g.BoxSelectState
			if bs.IsActive && bs.Window == window {
				// FIXME: Selectable() use of half-ItemSpacing isn't consistent in matter of layout, as ItemAdd(bb) stray above ItemSize()'s CursorPos.
				// RangeSelect's BoxSelect relies on comparing overlap of previous and current rectangle and is sensitive to that.
				// As a workaround we currently half ItemSpacing worth on each side.
				min_y -= g.Style.ItemSpacing.y
				max_y += g.Style.ItemSpacing.y

				// Box-select on 2D area requires different clipping.
				if bs.UnclipMode { push_back(&data.Ranges, ImGuiListClipperRange_FromPositions(bs.UnclipRect.Min.y, bs.UnclipRect.Max.y, 0, 0)) }
			}

			off_min : i32 = (is_nav_request && g.NavMoveClipDir == ImGuiDir.ImGuiDir_Up) ? -1 : 0
			off_max : i32 = (is_nav_request && g.NavMoveClipDir == ImGuiDir.ImGuiDir_Down) ? 1 : 0
			push_back(&data.Ranges, ImGuiListClipperRange_FromPositions(min_y, max_y, off_min, off_max))
		}

		// Convert position ranges to item index ranges
		// - Very important: when a starting position is after our maximum item, we set Min to (ItemsCount - 1). This allows us to handle most forms of wrapping.
		// - Due to how Selectable extra padding they tend to be "unaligned" with exact unit in the item list,
		//   which with the flooring/ceiling tend to lead to 2 items instead of one being submitted.
		for &range in data.Ranges.Data[:data.Ranges.Size] {
			if range.PosToIndexConvert {
				m1 : i32 = cast(i32) ((cast(f32) range.Min - window.DC.CursorPos.y - data.LossynessOffset) / clipper.ItemsHeight)
				m2 : i32 = cast(i32) (((cast(f32) range.Max - window.DC.CursorPos.y - data.LossynessOffset) / clipper.ItemsHeight) + 0.999999)
				range.Min = ImClamp(already_submitted + m1 + cast(i32) range.PosToIndexOffsetMin, already_submitted, clipper.ItemsCount - 1)
				range.Max = ImClamp(already_submitted + m2 + cast(i32) range.PosToIndexOffsetMax, range.Min + 1, clipper.ItemsCount)
				range.PosToIndexConvert = false
			}
		}

		ImGuiListClipper_SortAndFuseRanges(&data.Ranges, data.StepNo)
	}

	// Step 0+ (if item height is given in advance) or 1+: Display the next range in line.
	for data.StepNo < data.Ranges.Size {
		clipper.DisplayStart = ImMax(data.Ranges.Data[data.StepNo].Min, already_submitted)
		clipper.DisplayEnd = ImMin(data.Ranges.Data[data.StepNo].Max, clipper.ItemsCount)
		if clipper.DisplayStart > already_submitted {
			//-V1051
			SeekCursorForItem(clipper, clipper.DisplayStart)
		}
		post_incr(&data.StepNo)
		if clipper.DisplayStart == clipper.DisplayEnd && data.StepNo < data.Ranges.Size { continue }
		return true
	}

	// After the last step: Let the clipper validate that we have reached the expected Y position (corresponding to element DisplayEnd),
	// Advance the cursor to the end of the list and then returns 'false' to end the loop.
	if clipper.ItemsCount < INT_MAX { SeekCursorForItem(clipper, clipper.ItemsCount) }

	return false
}

// Call until it returns false. The DisplayStart/DisplayEnd fields will be set and you can process/draw those items.
ImGuiListClipper_Step :: proc(this : ^ImGuiListClipper) -> bool
{
	g : ^ImGuiContext = this.Ctx
	need_items_height : bool = (this.ItemsHeight <= 0.0)
	ret : bool = ImGuiListClipper_StepInternal(this)
	if ret && (this.DisplayStart == this.DisplayEnd) { ret = false }
	if g.CurrentTable != nil && g.CurrentTable.IsUnfrozenRows == false { IMGUI_DEBUG_LOG_CLIPPER(g, "Clipper: Step(): inside frozen table row.\n") }
	if need_items_height && this.ItemsHeight > 0.0 { IMGUI_DEBUG_LOG_CLIPPER(g, "Clipper: Step(): computed ItemsHeight: %.2f.\n", this.ItemsHeight) }
	if ret {
		IMGUI_DEBUG_LOG_CLIPPER(g, "Clipper: Step(): display %d to %d.\n", this.DisplayStart, this.DisplayEnd)
	}
	else {
		IMGUI_DEBUG_LOG_CLIPPER(g, "Clipper: Step(): End.\n")
		ImGuiListClipper_End(this)
	}
	return ret
}

//-----------------------------------------------------------------------------
// [SECTION] STYLING
//-----------------------------------------------------------------------------

GetStyle :: proc() -> ^ImGuiStyle
{
	IM_ASSERT(GImGui != nil, "No current context. Did you call ImGui::CreateContext() and ImGui::SetCurrentContext() ?")
	return &GImGui.Style
}

GetColorU32_0 :: proc(idx : ImGuiCol, alpha_mul : f32 = 1) -> ImU32
{
	style : ^ImGuiStyle = &GImGui.Style
	c : ImVec4 = style.Colors[idx]
	c.w *= style.Alpha * alpha_mul
	return ColorConvertFloat4ToU32(c)
}

GetColorU32_1 :: proc(col : ImVec4) -> ImU32
{
	style : ^ImGuiStyle = &GImGui.Style
	c : ImVec4 = col
	c.w *= style.Alpha
	return ColorConvertFloat4ToU32(c)
}

GetStyleColorVec4 :: proc(idx : ImGuiCol) -> ImVec4
{
	style : ^ImGuiStyle = &GImGui.Style
	return style.Colors[idx]
}

GetColorU32_2 :: proc(col : ImU32, alpha_mul : f32 = 1) -> ImU32
{
	style : ^ImGuiStyle = &GImGui.Style
	alpha_mul := alpha_mul * style.Alpha
	if alpha_mul >= 1.0 { return col }
	a : ImU32 = (col & IM_COL32_A_MASK) >> IM_COL32_A_SHIFT
	a = cast(ImU32) (cast(f32) a * alpha_mul); // We don't need to clamp 0..255 because alpha is in 0..1 range.
	return (col & ~ImU32(IM_COL32_A_MASK)) | (a << IM_COL32_A_SHIFT)
}

// FIXME: This may incur a round-trip (if the end user got their data from a float4) but eventually we aim to store the in-flight colors as ImU32
PushStyleColor_0 :: proc(idx : ImGuiCol, col : ImU32)
{
	g : ^ImGuiContext = GImGui
	backup : ImGuiColorMod
	backup.Col = idx
	backup.BackupValue = g.Style.Colors[idx]
	push_back(&g.ColorStack, backup)
	if g.DebugFlashStyleColorIdx != idx { g.Style.Colors[idx] = ColorConvertU32ToFloat4(col) }
}

PushStyleColor_1 :: proc(idx : ImGuiCol, col : ImVec4)
{
	g : ^ImGuiContext = GImGui
	backup : ImGuiColorMod
	backup.Col = idx
	backup.BackupValue = g.Style.Colors[idx]
	push_back(&g.ColorStack, backup)
	if g.DebugFlashStyleColorIdx != idx { g.Style.Colors[idx] = col }
}

PopStyleColor :: proc(count : i32 = 1)
{
	g : ^ImGuiContext = GImGui
	count := count
	if g.ColorStack.Size < count {
		IM_ASSERT_USER_ERROR(false, "Calling PopStyleColor() too many times!")
		count = g.ColorStack.Size
	}
	for count > 0 {
		backup : ^ImGuiColorMod = back(&g.ColorStack)
		g.Style.Colors[backup.Col] = backup.BackupValue
		pop_back(&g.ColorStack)
		post_decr(&count)
	}
}

GWindowDockStyleColors : [ImGuiWindowDockStyleCol.ImGuiWindowDockStyleCol_COUNT]ImGuiCol_ = {
	ImGuiCol_.ImGuiCol_Text, ImGuiCol_.ImGuiCol_TabHovered, ImGuiCol_.ImGuiCol_Tab, ImGuiCol_.ImGuiCol_TabSelected, ImGuiCol_.ImGuiCol_TabSelectedOverline, ImGuiCol_.ImGuiCol_TabDimmed, ImGuiCol_.ImGuiCol_TabDimmedSelected, ImGuiCol_.ImGuiCol_TabDimmedSelectedOverline,
}

GStyleVarInfo := [?]ImGuiDataVarInfo{
	{ImGuiDataType_.ImGuiDataType_Float, 1, cast(ImU32) offset_of(ImGuiStyle, Alpha)}, // ImGuiStyleVar_Alpha
	{ImGuiDataType_.ImGuiDataType_Float, 1, cast(ImU32) offset_of(ImGuiStyle, DisabledAlpha)}, // ImGuiStyleVar_DisabledAlpha
	{ImGuiDataType_.ImGuiDataType_Float, 2, cast(ImU32) offset_of(ImGuiStyle, WindowPadding)}, // ImGuiStyleVar_WindowPadding
	{ImGuiDataType_.ImGuiDataType_Float, 1, cast(ImU32) offset_of(ImGuiStyle, WindowRounding)}, // ImGuiStyleVar_WindowRounding
	{ImGuiDataType_.ImGuiDataType_Float, 1, cast(ImU32) offset_of(ImGuiStyle, WindowBorderSize)}, // ImGuiStyleVar_WindowBorderSize
	{ImGuiDataType_.ImGuiDataType_Float, 2, cast(ImU32) offset_of(ImGuiStyle, WindowMinSize)}, // ImGuiStyleVar_WindowMinSize
	{ImGuiDataType_.ImGuiDataType_Float, 2, cast(ImU32) offset_of(ImGuiStyle, WindowTitleAlign)}, // ImGuiStyleVar_WindowTitleAlign
	{ImGuiDataType_.ImGuiDataType_Float, 1, cast(ImU32) offset_of(ImGuiStyle, ChildRounding)}, // ImGuiStyleVar_ChildRounding
	{ImGuiDataType_.ImGuiDataType_Float, 1, cast(ImU32) offset_of(ImGuiStyle, ChildBorderSize)}, // ImGuiStyleVar_ChildBorderSize
	{ImGuiDataType_.ImGuiDataType_Float, 1, cast(ImU32) offset_of(ImGuiStyle, PopupRounding)}, // ImGuiStyleVar_PopupRounding
	{ImGuiDataType_.ImGuiDataType_Float, 1, cast(ImU32) offset_of(ImGuiStyle, PopupBorderSize)}, // ImGuiStyleVar_PopupBorderSize
	{ImGuiDataType_.ImGuiDataType_Float, 2, cast(ImU32) offset_of(ImGuiStyle, FramePadding)}, // ImGuiStyleVar_FramePadding
	{ImGuiDataType_.ImGuiDataType_Float, 1, cast(ImU32) offset_of(ImGuiStyle, FrameRounding)}, // ImGuiStyleVar_FrameRounding
	{ImGuiDataType_.ImGuiDataType_Float, 1, cast(ImU32) offset_of(ImGuiStyle, FrameBorderSize)}, // ImGuiStyleVar_FrameBorderSize
	{ImGuiDataType_.ImGuiDataType_Float, 2, cast(ImU32) offset_of(ImGuiStyle, ItemSpacing)}, // ImGuiStyleVar_ItemSpacing
	{ImGuiDataType_.ImGuiDataType_Float, 2, cast(ImU32) offset_of(ImGuiStyle, ItemInnerSpacing)}, // ImGuiStyleVar_ItemInnerSpacing
	{ImGuiDataType_.ImGuiDataType_Float, 1, cast(ImU32) offset_of(ImGuiStyle, IndentSpacing)}, // ImGuiStyleVar_IndentSpacing
	{ImGuiDataType_.ImGuiDataType_Float, 2, cast(ImU32) offset_of(ImGuiStyle, CellPadding)}, // ImGuiStyleVar_CellPadding
	{ImGuiDataType_.ImGuiDataType_Float, 1, cast(ImU32) offset_of(ImGuiStyle, ScrollbarSize)}, // ImGuiStyleVar_ScrollbarSize
	{ImGuiDataType_.ImGuiDataType_Float, 1, cast(ImU32) offset_of(ImGuiStyle, ScrollbarRounding)}, // ImGuiStyleVar_ScrollbarRounding
	{ImGuiDataType_.ImGuiDataType_Float, 1, cast(ImU32) offset_of(ImGuiStyle, GrabMinSize)}, // ImGuiStyleVar_GrabMinSize
	{ImGuiDataType_.ImGuiDataType_Float, 1, cast(ImU32) offset_of(ImGuiStyle, GrabRounding)}, // ImGuiStyleVar_GrabRounding
	{ImGuiDataType_.ImGuiDataType_Float, 1, cast(ImU32) offset_of(ImGuiStyle, TabRounding)}, // ImGuiStyleVar_TabRounding
	{ImGuiDataType_.ImGuiDataType_Float, 1, cast(ImU32) offset_of(ImGuiStyle, TabBorderSize)}, // ImGuiStyleVar_TabBorderSize
	{ImGuiDataType_.ImGuiDataType_Float, 1, cast(ImU32) offset_of(ImGuiStyle, TabBarBorderSize)}, // ImGuiStyleVar_TabBarBorderSize
	{ImGuiDataType_.ImGuiDataType_Float, 1, cast(ImU32) offset_of(ImGuiStyle, TabBarOverlineSize)}, // ImGuiStyleVar_TabBarOverlineSize
	{ImGuiDataType_.ImGuiDataType_Float, 1, cast(ImU32) offset_of(ImGuiStyle, TableAngledHeadersAngle)}, // ImGuiStyleVar_TableAngledHeadersAngle
	{ImGuiDataType_.ImGuiDataType_Float, 2, cast(ImU32) offset_of(ImGuiStyle, TableAngledHeadersTextAlign)}, // ImGuiStyleVar_TableAngledHeadersTextAlign
	{ImGuiDataType_.ImGuiDataType_Float, 2, cast(ImU32) offset_of(ImGuiStyle, ButtonTextAlign)}, // ImGuiStyleVar_ButtonTextAlign
	{ImGuiDataType_.ImGuiDataType_Float, 2, cast(ImU32) offset_of(ImGuiStyle, SelectableTextAlign)}, // ImGuiStyleVar_SelectableTextAlign
	{ImGuiDataType_.ImGuiDataType_Float, 1, cast(ImU32) offset_of(ImGuiStyle, SeparatorTextBorderSize)}, // ImGuiStyleVar_SeparatorTextBorderSize
	{ImGuiDataType_.ImGuiDataType_Float, 2, cast(ImU32) offset_of(ImGuiStyle, SeparatorTextAlign)}, // ImGuiStyleVar_SeparatorTextAlign
	{ImGuiDataType_.ImGuiDataType_Float, 2, cast(ImU32) offset_of(ImGuiStyle, SeparatorTextPadding)}, // ImGuiStyleVar_SeparatorTextPadding
	{ImGuiDataType_.ImGuiDataType_Float, 1, cast(ImU32) offset_of(ImGuiStyle, DockingSeparatorSize)}, // ImGuiStyleVar_DockingSeparatorSize
}

GetStyleVarInfo :: proc(idx : ImGuiStyleVar) -> ^ImGuiDataVarInfo
{
	IM_ASSERT(idx >= {} && idx < ImGuiStyleVar_.ImGuiStyleVar_COUNT)
	#assert(len(GStyleVarInfo) == cast(int) ImGuiStyleVar_.ImGuiStyleVar_COUNT)
	return &GStyleVarInfo[idx]
}

PushStyleVar_f :: proc(idx : ImGuiStyleVar, val : f32)
{
	g : ^ImGuiContext = GImGui
	var_info : ^ImGuiDataVarInfo = GetStyleVarInfo(idx)
	if var_info.Type != ImGuiDataType_.ImGuiDataType_Float || var_info.Count != 1 {
		IM_ASSERT_USER_ERROR(false, "Calling PushStyleVar() variant with wrong type!")
		return
	}
	pvar : ^f32 = cast(^f32) GetVarPtr(var_info, &g.Style)
	mod : ImGuiStyleMod; init(&mod, idx, pvar^)
	push_back(&g.StyleVarStack, mod)
	pvar^ = val
}

// modify X component of a style ImVec2 variable. "
PushStyleVarX :: proc(idx : ImGuiStyleVar, val_x : f32)
{
	g : ^ImGuiContext = GImGui
	var_info : ^ImGuiDataVarInfo = GetStyleVarInfo(idx)
	if var_info.Type != ImGuiDataType_.ImGuiDataType_Float || var_info.Count != 2 {
		IM_ASSERT_USER_ERROR(false, "Calling PushStyleVar() variant with wrong type!")
	}
	pvar : ^ImVec2 = cast(^ImVec2) GetVarPtr(var_info, &g.Style)
	mod : ImGuiStyleMod; init(&mod, idx, pvar^)
	push_back(&g.StyleVarStack, mod)
	pvar.x = val_x
}

// modify Y component of a style ImVec2 variable. "
PushStyleVarY :: proc(idx : ImGuiStyleVar, val_y : f32)
{
	g : ^ImGuiContext = GImGui
	var_info : ^ImGuiDataVarInfo = GetStyleVarInfo(idx)
	if var_info.Type != ImGuiDataType_.ImGuiDataType_Float || var_info.Count != 2 {
		IM_ASSERT_USER_ERROR(false, "Calling PushStyleVar() variant with wrong type!")
		return
	}
	pvar : ^ImVec2 = cast(^ImVec2) GetVarPtr(var_info, &g.Style)
	mod : ImGuiStyleMod; init(&mod, idx, pvar^)
	push_back(&g.StyleVarStack, mod)
	pvar.y = val_y
}

// modify a style float variable. always use this if you modify the style after NewFrame()!
PushStyleVar_v2 :: proc(idx : ImGuiStyleVar, val : ImVec2)
{
	g : ^ImGuiContext = GImGui
	var_info : ^ImGuiDataVarInfo = GetStyleVarInfo(idx)
	if var_info.Type != ImGuiDataType_.ImGuiDataType_Float || var_info.Count != 2 {
		IM_ASSERT_USER_ERROR(false, "Calling PushStyleVar() variant with wrong type!")
		return
	}
	pvar : ^ImVec2 = cast(^ImVec2) GetVarPtr(var_info, &g.Style)
	mod : ImGuiStyleMod; init(&mod, idx, pvar^)
	push_back(&g.StyleVarStack, mod)
	pvar^ = val
}

PopStyleVar :: proc(count : i32 = 1)
{
	g : ^ImGuiContext = GImGui
	count := count
	if g.StyleVarStack.Size < count {
		IM_ASSERT_USER_ERROR(false, "Calling PopStyleVar() too many times!")
		count = g.StyleVarStack.Size
	}
	for count > 0 {
		// We avoid a generic memcpy(data, &backup.Backup.., GDataTypeSize[info->Type] * info->Count), the overhead in Debug is not worth it.
		backup : ^ImGuiStyleMod = back(&g.StyleVarStack)
		info : ^ImGuiDataVarInfo = GetStyleVarInfo(backup.VarIdx)
		data : rawptr = GetVarPtr(info, &g.Style)
		if info.Type == ImGuiDataType_.ImGuiDataType_Float && info.Count == 1 { (cast([^]f32) data)[0] = backup.BackupFloat[0] }
		else if info.Type == ImGuiDataType_.ImGuiDataType_Float && info.Count == 2 {(cast([^]f32) data)[0] = backup.BackupFloat[0]; (cast([^]f32) data)[1] = backup.BackupFloat[1]
		}
		pop_back(&g.StyleVarStack)
		post_decr(&count)
	}
}

// get a string corresponding to the enum value (for display, saving, etc.).
GetStyleColorName :: proc(idx : ImGuiCol) -> string
{
	// Create switch-case from enum with regexp: ImGuiCol_{.*}, --> case ImGuiCol_\1: return "\1";
	switch idx {
		case .ImGuiCol_Text:                     return "Text"
		case .ImGuiCol_TextDisabled:             return "TextDisabled"
		case .ImGuiCol_WindowBg:                 return "WindowBg"
		case .ImGuiCol_ChildBg:                  return "ChildBg"
		case .ImGuiCol_PopupBg:                  return "PopupBg"
		case .ImGuiCol_Border:                   return "Border"
		case .ImGuiCol_BorderShadow:             return "BorderShadow"
		case .ImGuiCol_FrameBg:                  return "FrameBg"
		case .ImGuiCol_FrameBgHovered:           return "FrameBgHovered"
		case .ImGuiCol_FrameBgActive:            return "FrameBgActive"
		case .ImGuiCol_TitleBg:                  return "TitleBg"
		case .ImGuiCol_TitleBgActive:            return "TitleBgActive"
		case .ImGuiCol_TitleBgCollapsed:         return "TitleBgCollapsed"
		case .ImGuiCol_MenuBarBg:                return "MenuBarBg"
		case .ImGuiCol_ScrollbarBg:              return "ScrollbarBg"
		case .ImGuiCol_ScrollbarGrab:            return "ScrollbarGrab"
		case .ImGuiCol_ScrollbarGrabHovered:     return "ScrollbarGrabHovered"
		case .ImGuiCol_ScrollbarGrabActive:      return "ScrollbarGrabActive"
		case .ImGuiCol_CheckMark:                return "CheckMark"
		case .ImGuiCol_SliderGrab:               return "SliderGrab"
		case .ImGuiCol_SliderGrabActive:         return "SliderGrabActive"
		case .ImGuiCol_Button:                   return "Button"
		case .ImGuiCol_ButtonHovered:            return "ButtonHovered"
		case .ImGuiCol_ButtonActive:             return "ButtonActive"
		case .ImGuiCol_Header:                   return "Header"
		case .ImGuiCol_HeaderHovered:            return "HeaderHovered"
		case .ImGuiCol_HeaderActive:             return "HeaderActive"
		case .ImGuiCol_Separator:                return "Separator"
		case .ImGuiCol_SeparatorHovered:         return "SeparatorHovered"
		case .ImGuiCol_SeparatorActive:          return "SeparatorActive"
		case .ImGuiCol_ResizeGrip:               return "ResizeGrip"
		case .ImGuiCol_ResizeGripHovered:        return "ResizeGripHovered"
		case .ImGuiCol_ResizeGripActive:         return "ResizeGripActive"
		case .ImGuiCol_TabHovered:               return "TabHovered"
		case .ImGuiCol_Tab:                      return "Tab"
		case .ImGuiCol_TabSelected:              return "TabSelected"
		case .ImGuiCol_TabSelectedOverline:      return "TabSelectedOverline"
		case .ImGuiCol_TabDimmed:                return "TabDimmed"
		case .ImGuiCol_TabDimmedSelected:        return "TabDimmedSelected"
		case .ImGuiCol_TabDimmedSelectedOverline:return "TabDimmedSelectedOverline"
		case .ImGuiCol_DockingPreview:           return "DockingPreview"
		case .ImGuiCol_DockingEmptyBg:           return "DockingEmptyBg"
		case .ImGuiCol_PlotLines:                return "PlotLines"
		case .ImGuiCol_PlotLinesHovered:         return "PlotLinesHovered"
		case .ImGuiCol_PlotHistogram:            return "PlotHistogram"
		case .ImGuiCol_PlotHistogramHovered:     return "PlotHistogramHovered"
		case .ImGuiCol_TableHeaderBg:            return "TableHeaderBg"
		case .ImGuiCol_TableBorderStrong:        return "TableBorderStrong"
		case .ImGuiCol_TableBorderLight:         return "TableBorderLight"
		case .ImGuiCol_TableRowBg:               return "TableRowBg"
		case .ImGuiCol_TableRowBgAlt:            return "TableRowBgAlt"
		case .ImGuiCol_TextLink:                 return "TextLink"
		case .ImGuiCol_TextSelectedBg:           return "TextSelectedBg"
		case .ImGuiCol_DragDropTarget:           return "DragDropTarget"
		case .ImGuiCol_NavCursor:                return "NavCursor"
		case .ImGuiCol_NavWindowingHighlight:    return "NavWindowingHighlight"
		case .ImGuiCol_NavWindowingDimBg:        return "NavWindowingDimBg"
		case .ImGuiCol_ModalWindowDimBg:         return "ModalWindowDimBg"
		case .ImGuiCol_COUNT:
	}
	IM_ASSERT(false)
	return "Unknown"
}

//-----------------------------------------------------------------------------
// [SECTION] RENDER HELPERS
// Some of those (internal) functions are currently quite a legacy mess - their signature and behavior will change,
// we need a nicer separation between low-level functions and high-level functions relying on the ImGui context.
// Also see imgui_draw.cpp for some more which have been reworked to not rely on ImGui:: context.
//-----------------------------------------------------------------------------

// Find the optional ## from which we stop displaying text.
FindRenderedTextEnd :: proc(text : string) -> int
{
	for i in 0..<len(text)-1 {
		if text[i] == '#' && text[i + 1] == '#' {
			return i
		}
	}
	return len(text)
}

// Render helpers
// AVOID USING OUTSIDE OF IMGUI.CPP! NOT FOR PUBLIC CONSUMPTION. THOSE FUNCTIONS ARE A MESS. THEIR SIGNATURE AND BEHAVIOR WILL CHANGE, THEY NEED TO BE REFACTORED INTO SOMETHING DECENT.
// NB: All position are in absolute pixels coordinates (we are never using window coordinates internally)
// Internal ImGui functions to render text
// RenderText***() functions calls ImDrawList::AddText() calls ImBitmapFont::RenderText()
RenderText :: proc(pos : ImVec2, text : string, hide_text_after_hash : bool = true)
{
	g : ^ImGuiContext = GImGui
	window : ^ImGuiWindow = g.CurrentWindow

	// Hide anything after a '##' string
	text := text
	if hide_text_after_hash {
		text = text[:FindRenderedTextEnd(text)]
	}

	if len(text) != 0 {
		AddText(window.DrawList, g.Font, g.FontSize, pos, GetColorU32(ImGuiCol_.ImGuiCol_Text), text)
		pos := pos
		if g.LogEnabled { LogRenderedText(&pos, text, false) }
	}
}

RenderTextWrapped :: proc(pos : ImVec2, text : string, wrap_width : f32)
{
	g : ^ImGuiContext = GImGui
	window : ^ImGuiWindow = g.CurrentWindow

	if text != "" {
		AddText(window.DrawList, g.Font, g.FontSize, pos, GetColorU32(ImGuiCol_.ImGuiCol_Text), text, wrap_width)
		pos := pos
		if g.LogEnabled { LogRenderedText(&pos, text, false) }
	}
}

// Default clip_rect uses (pos_min,pos_max)
// Handle clipping on CPU immediately (vs typically let the GPU clip the triangles that are overlapping the clipping rectangle edges)
// FIXME-OPT: Since we have or calculate text_size we could coarse clip whole block immediately, especally for text above draw_list->DrawList.
// Effectively as this is called from widget doing their own coarse clipping it's not very valuable presently. Next time function will take
// better advantage of the render function taking size into account for coarse clipping.
RenderTextClippedEx :: proc(draw_list : ^ImDrawList, pos_min : ImVec2, pos_max : ImVec2, text : string, text_size_if_known : ^ImVec2, align : ^ImVec2 = &{}, clip_rect : ^ImRect = nil)
{
	// Perform CPU side clipping for single clipped element to avoid using scissor state
	pos : ImVec2 = pos_min
	text_size : ImVec2 = text_size_if_known != nil ? text_size_if_known^ : CalcTextSize(text, false, 0.0)

	clip_min : ImVec2 = clip_rect != nil ? clip_rect.Min : pos_min
	clip_max : ImVec2 = clip_rect != nil ? clip_rect.Max : pos_max
	need_clipping : bool = (pos.x + text_size.x >= clip_max.x) || (pos.y + text_size.y >= clip_max.y)
	if clip_rect != nil {
		// If we had no explicit clipping rectangle then pos==clip_min
		need_clipping |= (pos.x < clip_min.x) || (pos.y < clip_min.y)
	}

	// Align whole block. We should defer that to the better rendering function when we'll have support for individual line alignment.
	if align.x > 0.0 { pos.x = ImMax(pos.x, pos.x + (pos_max.x - pos.x - text_size.x) * align.x) }
	if align.y > 0.0 { pos.y = ImMax(pos.y, pos.y + (pos_max.y - pos.y - text_size.y) * align.y) }

	// Render
	if need_clipping {
		fine_clip_rect : ImVec4 = { clip_min.x, clip_min.y, clip_max.x, clip_max.y }
		AddText(draw_list, nil, 0.0, pos, GetColorU32(ImGuiCol_.ImGuiCol_Text), text, 0.0, &fine_clip_rect)
	}
	else {
		AddText(draw_list, nil, 0.0, pos, GetColorU32(ImGuiCol_.ImGuiCol_Text), text, 0.0, nil)
	}
}

RenderTextClipped :: proc(pos_min : ImVec2, pos_max : ImVec2, text : string, text_size_if_known : ^ImVec2, align : ^ImVec2 = &{}, clip_rect : ^ImRect = nil)
{
	// Hide anything after a '##' string
	text_display_end := FindRenderedTextEnd(text)
	if text_display_end == 0 { return }

	g : ^ImGuiContext = GImGui
	window : ^ImGuiWindow = g.CurrentWindow
	RenderTextClippedEx(window.DrawList, pos_min, pos_max, text[:text_display_end], text_size_if_known, align, clip_rect)
	if g.LogEnabled { pos_min := pos_min; LogRenderedText(&pos_min, text[:text_display_end], false) }
}

// Another overly complex function until we reorganize everything into a nice all-in-one helper.
// This is made more complex because we have dissociated the layout rectangle (pos_min..pos_max) which define _where_ the ellipsis is, from actual clipping of text and limit of the ellipsis display.
// This is because in the context of tabs we selectively hide part of the text when the Close Button appears, but we don't want the ellipsis to move.
RenderTextEllipsis :: proc(draw_list : ^ImDrawList, pos_min : ImVec2, pos_max : ImVec2, clip_max_x : f32, ellipsis_max_x : f32, text : string, text_end_full : int, text_size_if_known : ^ImVec2)
{
	g : ^ImGuiContext = GImGui
	text_end_full := text_end_full
	if text_end_full == 0 { text_end_full = FindRenderedTextEnd(text) }
	text_size : ImVec2 = text_size_if_known != nil ? text_size_if_known^ : CalcTextSize(text[:text_end_full], false, 0.0)

	//draw_list->AddLine(ImVec2{pos_max.x, pos_min.y - 4}, ImVec2{pos_max.x, pos_max.y + 4}, IM_COL32(0, 0, 255, 255));
	//draw_list->AddLine(ImVec2{ellipsis_max_x, pos_min.y-2}, ImVec2{ellipsis_max_x, pos_max.y+2}, IM_COL32(0, 255, 0, 255));
	//draw_list->AddLine(ImVec2{clip_max_x, pos_min.y}, ImVec2{clip_max_x, pos_max.y}, IM_COL32(255, 0, 0, 255));
	// FIXME: We could technically remove (last_glyph->AdvanceX - last_glyph->X1) from text_size.x here and save a few pixels.
	if text_size.x > pos_max.x - pos_min.x {
		// Hello wo...
		// |       |   |
		// min   max   ellipsis_max
		//          <-> this is generally some padding value

		font : ^ImFont = draw_list._Data.Font
		font_size : f32 = draw_list._Data.FontSize
		font_scale : f32 = draw_list._Data.FontScale
		text_end_ellipsis : int
		ellipsis_width : f32 = font.EllipsisWidth * font_scale

		// We can now claim the space between pos_max.x and ellipsis_max.x
		text_avail_width : f32 = ImMax((ImMax(pos_max.x, ellipsis_max_x) - ellipsis_width) - pos_min.x, 1.0)
		text_size_clipped_x : f32 = CalcTextSizeA(font, font_size, text_avail_width, 0.0, raw_data(text), &raw_data(text)[text_end_full], &text_end_ellipsis).x
		if text_end_ellipsis == 0 && text_end_ellipsis < text_end_full {
			// Always display at least 1 character if there's no room for character + ellipsis
			text_end_ellipsis = cast(int) ImTextCountUtf8BytesFromChar(raw_data(text), &raw_data(text)[text_end_full])
			text_size_clipped_x = CalcTextSizeA(font, font_size, FLT_MAX, 0.0, raw_data(text), &raw_data(text)[text_end_ellipsis]).x
		}
		for text_end_ellipsis > 0 && ImCharIsBlankA(text[text_end_ellipsis - 1]) {
			// Trim trailing space before ellipsis (FIXME: Supporting non-ascii blanks would be nice, for this we need a function to backtrack in UTF-8 text)
			post_decr(&text_end_ellipsis)
			text_size_clipped_x -= CalcTextSizeA(font, font_size, FLT_MAX, 0.0, raw_data(text)[text_end_ellipsis:], &raw_data(text)[text_end_ellipsis + 1]).x; // Ascii blanks are always 1 byte
		}

		// Render text, render ellipsis
		RenderTextClippedEx(draw_list, pos_min, ImVec2{clip_max_x, pos_max.y}, text[:text_end_ellipsis], &text_size, &ImVec2{0.0, 0.0})
		ellipsis_pos : ImVec2 = ImTrunc(ImVec2{pos_min.x + text_size_clipped_x, pos_min.y})
		if ellipsis_pos.x + ellipsis_width <= ellipsis_max_x { for i : i16 = 0; i < font.EllipsisCharCount; i, ellipsis_pos.x = i + 1, ellipsis_pos.x + font.EllipsisCharStep * font_scale { RenderChar(font, draw_list, font_size, ellipsis_pos, GetColorU32(ImGuiCol_.ImGuiCol_Text), font.EllipsisChar) } }
	}
	else {
		RenderTextClippedEx(draw_list, pos_min, ImVec2{clip_max_x, pos_max.y}, text[:text_end_full], &text_size, &ImVec2{0.0, 0.0})
	}

	if g.LogEnabled { pos_min := pos_min; LogRenderedText(&pos_min, text[:text_end_full], false) }
}

// Render a rectangle shaped with optional rounding and borders
RenderFrame :: proc(p_min : ImVec2, p_max : ImVec2, fill_col : ImU32, borders : bool, rounding : f32 = 0)
{
	g : ^ImGuiContext = GImGui
	window : ^ImGuiWindow = g.CurrentWindow
	AddRectFilled(window.DrawList, p_min, p_max, fill_col, rounding)
	border_size : f32 = g.Style.FrameBorderSize
	if borders && border_size > 0.0 {
		AddRect(window.DrawList, p_min + ImVec2{1, 1}, p_max + ImVec2{1, 1}, GetColorU32(ImGuiCol_.ImGuiCol_BorderShadow), rounding, {}, border_size)
		AddRect(window.DrawList, p_min, p_max, GetColorU32(ImGuiCol_.ImGuiCol_Border), rounding, {}, border_size)
	}
}

RenderFrameBorder :: proc(p_min : ImVec2, p_max : ImVec2, rounding : f32 = 0)
{
	g : ^ImGuiContext = GImGui
	window : ^ImGuiWindow = g.CurrentWindow
	border_size : f32 = g.Style.FrameBorderSize
	if border_size > 0.0 {
		AddRect(window.DrawList, p_min + ImVec2{1, 1}, p_max + ImVec2{1, 1}, GetColorU32(ImGuiCol_.ImGuiCol_BorderShadow), rounding, {}, border_size)
		AddRect(window.DrawList, p_min, p_max, GetColorU32(ImGuiCol_.ImGuiCol_Border), rounding, {}, border_size)
	}
}

// Navigation highlight
RenderNavCursor :: proc(bb : ImRect, id : ImGuiID, flags : ImGuiNavRenderCursorFlags = {})
{
	g : ^ImGuiContext = GImGui
	if id != g.NavId { return }
	if !g.NavCursorVisible && (flags & ImGuiNavRenderCursorFlags_.ImGuiNavRenderCursorFlags_AlwaysDraw) == {} { return }
	if id == g.LastItemData.ID && (g.LastItemData.ItemFlags & ImGuiItemFlags_.ImGuiItemFlags_NoNav) != {} { return }
	window : ^ImGuiWindow = g.CurrentWindow
	if window.DC.NavHideHighlightOneFrame { return }

	rounding : f32 = (flags & ImGuiNavRenderCursorFlags_.ImGuiNavRenderCursorFlags_NoRounding) != {} ? 0.0 : g.Style.FrameRounding
	display_rect : ImRect = bb
	ClipWith(&display_rect, window.ClipRect)
	thickness : f32 = 2.0
	if (flags & ImGuiNavRenderCursorFlags_.ImGuiNavRenderCursorFlags_Compact) != {} {
		AddRect(window.DrawList, display_rect.Min, display_rect.Max, GetColorU32(ImGuiCol_.ImGuiCol_NavCursor), rounding, {}, thickness)
	}
	else {
		distance : f32 = 3.0 + thickness * 0.5
		Expand(&display_rect, ImVec2{distance, distance})
		fully_visible : bool = Contains(window.ClipRect, display_rect)
		if !fully_visible { PushClipRect(window.DrawList, display_rect.Min, display_rect.Max) }
		AddRect(window.DrawList, display_rect.Min, display_rect.Max, GetColorU32(ImGuiCol_.ImGuiCol_NavCursor), rounding, {}, thickness)
		if !fully_visible { PopClipRect(window.DrawList) }
	}
}

RenderMouseCursor :: proc(base_pos : ImVec2, base_scale : f32, mouse_cursor : ImGuiMouseCursor, col_fill : ImU32, col_border : ImU32, col_shadow : ImU32)
{
	g : ^ImGuiContext = GImGui
	mouse_cursor := mouse_cursor
	if mouse_cursor <= ImGuiMouseCursor_.ImGuiMouseCursor_None || mouse_cursor >= ImGuiMouseCursor_.ImGuiMouseCursor_COUNT {
		// We intentionally accept out of bound values.
		mouse_cursor = .ImGuiMouseCursor_Arrow
	}
	font_atlas : ^ImFontAtlas = g.DrawListSharedData.Font.ContainerAtlas
	for viewport in g.Viewports.Data[:g.Viewports.Size] {
		// We scale cursor with current viewport/monitor, however Windows 10 for its own hardware cursor seems to be using a different scale factor.
		offset : ImVec2; size : ImVec2; uv : [4]ImVec2
		if !GetMouseCursorTexData(font_atlas, mouse_cursor, &offset, &size, cast(^[2]ImVec2)&uv[0], cast(^[2]ImVec2)&uv[2]) { continue }
		pos : ImVec2 = base_pos - offset
		scale : f32 = base_scale * viewport.DpiScale
		if !Overlaps(GetMainRect(viewport), ImRect{pos, pos + ImVec2{size.x + 2, size.y + 2} * scale}) { continue }
		draw_list : ^ImDrawList = GetForegroundDrawList(viewport)
		tex_id : ImTextureID = font_atlas.TexID
		PushTextureID(draw_list, tex_id)
		AddImage(draw_list, tex_id, pos + ImVec2{1, 0} * scale, pos + (ImVec2{1, 0} + size) * scale, uv[2], uv[3], col_shadow)
		AddImage(draw_list, tex_id, pos + ImVec2{2, 0} * scale, pos + (ImVec2{2, 0} + size) * scale, uv[2], uv[3], col_shadow)
		AddImage(draw_list, tex_id, pos, pos + size * scale, uv[2], uv[3], col_border)
		AddImage(draw_list, tex_id, pos, pos + size * scale, uv[0], uv[1], col_fill)
		PopTextureID(draw_list)
	}
}

//-----------------------------------------------------------------------------
// [SECTION] INITIALIZATION, SHUTDOWN
//-----------------------------------------------------------------------------

// Internal state access - if you want to share Dear ImGui state between modules (e.g. DLL) or allocate it yourself
// Note that we still point to some static data and members (such as GFontAtlas), so the state instance you end up using will point to the static data within its module
GetCurrentContext :: proc "contextless" () -> ^ImGuiContext
{
	return GImGui
}

SetCurrentContext :: proc "contextless" (ctx : ^ImGuiContext)
{
	GImGui = ctx
}

// Memory Allocators
// - Those functions are not reliant on the current context.
// - DLL users: heaps and globals are not shared across DLL boundaries! You will need to call SetCurrentContext() + SetAllocatorFunctions()
//   for each static/DLL boundary you are calling from. Read "Context and Memory Allocators" section of imgui.cpp for more details.
SetAllocatorFunctions :: proc "contextless" (alloc_func : ImGuiMemAllocFunc, free_func : ImGuiMemFreeFunc, user_data : rawptr)
{
	GImAllocatorAllocFunc = alloc_func
	GImAllocatorFreeFunc = free_func
	GImAllocatorUserData = user_data
}

// This is provided to facilitate copying allocators from one static/DLL boundary to another (e.g. retrieve default allocator of your executable address space)
GetAllocatorFunctions :: proc "contextless" (p_alloc_func : ^ImGuiMemAllocFunc, p_free_func : ^ImGuiMemFreeFunc, p_user_data : ^rawptr)
{
	p_alloc_func^ = GImAllocatorAllocFunc
	p_free_func^ = GImAllocatorFreeFunc
	p_user_data^ = GImAllocatorUserData
}

// Context creation and access
// - Each context create its own ImFontAtlas by default. You may instance one yourself and pass it to CreateContext() to share a font atlas between contexts.
// - DLL users: heaps and globals are not shared across DLL boundaries! You will need to call SetCurrentContext() + SetAllocatorFunctions()
//   for each static/DLL boundary you are calling from. Read "Context and Memory Allocators" section of imgui.cpp for details.
CreateContext :: proc(shared_font_atlas : ^ImFontAtlas = nil) -> ^ImGuiContext
{
	prev_ctx : ^ImGuiContext = GetCurrentContext()
	ctx : ^ImGuiContext = IM_NEW_MEM(ImGuiContext); init(ctx, shared_font_atlas)
	SetCurrentContext(ctx)
	Initialize()
	if prev_ctx != nil {
		// Restore previous context if any, else keep new one.
		SetCurrentContext(prev_ctx)
	}
	return ctx
}

// NULL = destroy current context
DestroyContext :: proc(ctx : ^ImGuiContext = nil)
{
	prev_ctx : ^ImGuiContext = GetCurrentContext()
	ctx := ctx
	if ctx == nil {
		//-V1051
		ctx = prev_ctx
	}
	SetCurrentContext(ctx)
	Shutdown()
	SetCurrentContext((prev_ctx != ctx) ? prev_ctx : nil)
	IM_DELETE(ctx)
}

// IMPORTANT: interactive elements requires a fixed ###xxx suffix, it must be same in ALL languages to allow for automation.
GLocalizationEntriesEnUS := [?]ImGuiLocEntry{
	{ImGuiLocKey.ImGuiLocKey_VersionStr, "Dear ImGui "+ IMGUI_VERSION /*+ " (" +IMGUI_VERSION_NUM+ ")"*/},
	{ImGuiLocKey.ImGuiLocKey_TableSizeOne, "Size column to fit###SizeOne"},
	{ImGuiLocKey.ImGuiLocKey_TableSizeAllFit, "Size all columns to fit###SizeAll"},
	{ImGuiLocKey.ImGuiLocKey_TableSizeAllDefault, "Size all columns to default###SizeAll"},
	{ImGuiLocKey.ImGuiLocKey_TableResetOrder, "Reset order###ResetOrder"},
	{ImGuiLocKey.ImGuiLocKey_WindowingMainMenuBar, "(Main menu bar)"},
	{ImGuiLocKey.ImGuiLocKey_WindowingPopup, "(Popup)"},
	{ImGuiLocKey.ImGuiLocKey_WindowingUntitled, "(Untitled)"},
	{ImGuiLocKey.ImGuiLocKey_OpenLink_s, "Open '%s'"},
	{ImGuiLocKey.ImGuiLocKey_CopyLink, "Copy Link###CopyLink"},
	{ImGuiLocKey.ImGuiLocKey_DockingHideTabBar, "Hide tab bar###HideTabBar"},
	{ImGuiLocKey.ImGuiLocKey_DockingHoldShiftToDock, "Hold SHIFT to enable Docking window."},
	{ImGuiLocKey.ImGuiLocKey_DockingDragToUndockOrMoveNode, "Click and drag to move or undock whole node."},
}

ImGuiContext_init :: proc(this : ^ImGuiContext, shared_font_atlas : ^ImFontAtlas)
{
	this^ = {}
	init(&this.IO)
	init(&this.PlatformIO)
	init(&this.Style)
	init(&this.DrawListSharedData)
	init(&this.InputEventsQueue)
	init(&this.InputEventsTrail)
	init(&this.Windows)
	init(&this.WindowsFocusOrder)
	init(&this.WindowsTempSortBuffer)
	init(&this.CurrentWindowStack)
	init(&this.WindowsById)
	init(&this.KeysRoutingTable)
	init(&this.NextItemData)
	init(&this.NextWindowData)
	init(&this.ColorStack)
	init(&this.StyleVarStack)
	init(&this.FontStack)
	init(&this.FocusScopeStack)
	init(&this.ItemFlagsStack)
	init(&this.GroupStack)
	init(&this.OpenPopupStack)
	init(&this.BeginPopupStack)
	init(&this.TreeNodeStack)
	init(&this.Viewports)
	init(&this.FallbackMonitor)
	init(&this.NavFocusRoute)
	init(&this.NavInitResult)
	init(&this.NavMoveResultLocal)
	init(&this.NavMoveResultLocalVisible)
	init(&this.NavMoveResultOther)
	init(&this.NavTabbingResultFirst)
	init(&this.DragDropPayload)
	init(&this.DragDropPayloadBufHeap)
	init(&this.ClipperTempData)
	init(&this.TablesTempData)
	init(&this.Tables)
	init(&this.TablesLastTimeActive)
	init(&this.DrawChannelsTempMergeBuffer)
	init(&this.TabBars)
	init(&this.CurrentTabBarStack)
	init(&this.ShrinkWidthBuffer)
	init(&this.MultiSelectTempData)
	init(&this.MultiSelectStorage)
	init(&this.InputTextState)
	init(&this.InputTextDeactivatedState)
	init(&this.InputTextPasswordFont)
	init(&this.ComboPreviewData)
	init(&this.ClipboardHandlerData)
	init(&this.MenusIdSubmittedThisFrame)
	init(&this.TypingSelectState)
	init(&this.PlatformImeData)
	init(&this.PlatformImeDataPrev)
	init(&this.DockContext)
	init(&this.SettingsIniData)
	init(&this.SettingsHandlers)
	init(&this.SettingsWindows)
	init(&this.SettingsTables)
	init(&this.Hooks)
	init(&this.LogBuffer)
	init(&this.StackSizesInNewFrame)
	init(&this.DebugLogBuf)
	init(&this.DebugLogIndex)
	init(&this.DebugMetricsConfig)
	init(&this.DebugIDStackTool)
	init(&this.TempBuffer)

	this.IO.Ctx = this
	this.InputTextState.Ctx = this

	this.Initialized = false
	this.ConfigFlagsLastFrame = ImGuiConfigFlags_.ImGuiConfigFlags_None; this.ConfigFlagsCurrFrame = this.ConfigFlagsLastFrame
	this.FontAtlasOwnedByContext = shared_font_atlas != nil ? false : true
	this.Font = nil
	this.CurrentDpiScale = 0.0; this.FontScale = this.CurrentDpiScale; this.FontBaseSize = this.FontScale; this.FontSize = this.FontBaseSize
	this.IO.Fonts = shared_font_atlas != nil ? shared_font_atlas : IM_NEW(ImFontAtlas)
	this.Time = 0.0
	this.FrameCount = 0
	this.FrameCountRendered = -1; this.FrameCountPlatformEnded = this.FrameCountRendered; this.FrameCountEnded = this.FrameCountPlatformEnded
	this.WithinEndChildID = 0
	this.WithinFrameScopeWithImplicitWindow = false; this.WithinFrameScope = this.WithinFrameScopeWithImplicitWindow
	this.GcCompactAll = false
	this.TestEngineHookItems = false
	this.TestEngine = nil
	this.ContextName = {}

	this.InputEventsNextMouseSource = ImGuiMouseSource.ImGuiMouseSource_Mouse
	this.InputEventsNextEventId = 1

	this.WindowsActiveCount = 0
	this.CurrentWindow = nil
	this.HoveredWindow = nil
	this.HoveredWindowUnderMovingWindow = nil
	this.HoveredWindowBeforeClear = nil
	this.MovingWindow = nil
	this.WheelingWindow = nil
	this.WheelingWindowScrolledFrame = -1; this.WheelingWindowStartFrame = this.WheelingWindowScrolledFrame
	this.WheelingWindowReleaseTimer = 0.0

	this.DebugDrawIdConflicts = 0
	this.DebugHookIdInfo = 0
	this.HoveredIdPreviousFrame = 0; this.HoveredId = this.HoveredIdPreviousFrame
	this.HoveredIdPreviousFrameItemCount = 0
	this.HoveredIdAllowOverlap = false
	this.HoveredIdIsDisabled = false
	this.HoveredIdNotActiveTimer = 0.0; this.HoveredIdTimer = this.HoveredIdNotActiveTimer
	this.ItemUnclipByLog = false
	this.ActiveId = 0
	this.ActiveIdIsAlive = 0
	this.ActiveIdTimer = 0.0
	this.ActiveIdIsJustActivated = false
	this.ActiveIdAllowOverlap = false
	this.ActiveIdNoClearOnFocusLoss = false
	this.ActiveIdHasBeenPressedBefore = false
	this.ActiveIdHasBeenEditedBefore = false
	this.ActiveIdHasBeenEditedThisFrame = false
	this.ActiveIdFromShortcut = false
	this.ActiveIdClickOffset = ImVec2{-1, -1}
	this.ActiveIdWindow = nil
	this.ActiveIdSource = ImGuiInputSource.ImGuiInputSource_None
	this.ActiveIdMouseButton = cast(ImGuiMouseButton)i32(-1)
	this.ActiveIdPreviousFrame = 0
	this.ActiveIdPreviousFrameIsAlive = false
	this.ActiveIdPreviousFrameHasBeenEditedBefore = false
	this.ActiveIdPreviousFrameWindow = nil
	this.ActiveIdValueOnActivation = {}
	this.LastActiveId = 0
	this.LastActiveIdTimer = 0.0

	this.LastKeyModsChangeFromNoneTime = -1.0; this.LastKeyModsChangeTime = this.LastKeyModsChangeFromNoneTime; this.LastKeyboardKeyPressTime = this.LastKeyModsChangeTime

	this.ActiveIdUsingNavDirMask = 0x00
	this.ActiveIdUsingAllKeyboardKeys = false

	this.CurrentFocusScopeId = 0
	this.CurrentItemFlags = ImGuiItemFlags_.ImGuiItemFlags_None
	this.DebugShowGroupRects = false

	this.CurrentViewport = nil
	this.MouseLastHoveredViewport = nil; this.MouseViewport = this.MouseLastHoveredViewport
	this.PlatformLastFocusedViewportId = 0
	this.PlatformWindowsCreatedCount = 0; this.ViewportCreatedCount = this.PlatformWindowsCreatedCount
	this.ViewportFocusedStampCount = 0

	this.NavCursorVisible = false
	this.NavHighlightItemUnderNav = false
	this.NavMousePosDirty = false
	this.NavIdIsAlive = false
	this.NavId = 0
	this.NavWindow = nil
	this.NavActivatePressedId = 0; this.NavActivateDownId = this.NavActivatePressedId; this.NavActivateId = this.NavActivateDownId; this.NavFocusScopeId = this.NavActivateId
	this.NavLayer = ImGuiNavLayer.ImGuiNavLayer_Main
	this.NavNextActivateId = 0
	this.NavNextActivateFlags = ImGuiActivateFlags_.ImGuiActivateFlags_None; this.NavActivateFlags = this.NavNextActivateFlags
	this.NavHighlightActivatedId = 0
	this.NavHighlightActivatedTimer = 0.0
	this.NavInputSource = ImGuiInputSource.ImGuiInputSource_Keyboard
	this.NavLastValidSelectionUserData = ImGuiSelectionUserData_Invalid
	this.NavCursorHideFrames = 0

	this.NavAnyRequest = false
	this.NavInitRequest = false
	this.NavInitRequestFromMove = false
	this.NavMoveSubmitted = false
	this.NavMoveScoringItems = false
	this.NavMoveForwardToNextFrame = false
	this.NavMoveFlags = ImGuiNavMoveFlags_.ImGuiNavMoveFlags_None
	this.NavMoveScrollFlags = ImGuiScrollFlags_.ImGuiScrollFlags_None
	this.NavMoveKeyMods = ImGuiKey.ImGuiMod_None
	this.NavMoveClipDir = ImGuiDir.ImGuiDir_None; this.NavMoveDirForDebug = this.NavMoveClipDir; this.NavMoveDir = this.NavMoveDirForDebug
	this.NavScoringDebugCount = 0
	this.NavTabbingDir = 0
	this.NavTabbingCounter = 0

	this.NavJustMovedToFocusScopeId = 0; this.NavJustMovedToId = this.NavJustMovedToFocusScopeId; this.NavJustMovedFromFocusScopeId = this.NavJustMovedToId
	this.NavJustMovedToKeyMods = ImGuiKey.ImGuiMod_None
	this.NavJustMovedToIsTabbing = false
	this.NavJustMovedToHasSelectionData = false

	// All platforms use Ctrl+Tab but Ctrl<>Super are swapped on Mac...
	// FIXME: Because this value is stored, it annoyingly interfere with toggling io.ConfigMacOSXBehaviors updating this..
	this.ConfigNavWindowingKeyNext = this.IO.ConfigMacOSXBehaviors ? (ImGuiKey.ImGuiMod_Super | ImGuiKey.ImGuiKey_Tab) : (ImGuiKey.ImGuiMod_Ctrl | ImGuiKey.ImGuiKey_Tab)
	this.ConfigNavWindowingKeyPrev = this.IO.ConfigMacOSXBehaviors ? (ImGuiKey.ImGuiMod_Super | ImGuiKey.ImGuiMod_Shift | ImGuiKey.ImGuiKey_Tab) : (ImGuiKey.ImGuiMod_Ctrl | ImGuiKey.ImGuiMod_Shift | ImGuiKey.ImGuiKey_Tab)
	this.NavWindowingListWindow = nil; this.NavWindowingTargetAnim = this.NavWindowingListWindow; this.NavWindowingTarget = this.NavWindowingTargetAnim
	this.NavWindowingHighlightAlpha = 0.0; this.NavWindowingTimer = this.NavWindowingHighlightAlpha
	this.NavWindowingToggleLayer = false
	this.NavWindowingToggleKey = ImGuiKey.ImGuiKey_None

	this.DimBgRatio = 0.0

	this.DragDropWithinTarget = false; this.DragDropWithinSource = this.DragDropWithinTarget; this.DragDropActive = this.DragDropWithinSource
	this.DragDropSourceFlags = ImGuiDragDropFlags_.ImGuiDragDropFlags_None
	this.DragDropSourceFrameCount = -1
	this.DragDropMouseButton = ImGuiMouseButton(-1)
	this.DragDropTargetId = 0
	this.DragDropAcceptFlags = ImGuiDragDropFlags_.ImGuiDragDropFlags_None
	this.DragDropAcceptIdCurrRectSurface = 0.0
	this.DragDropAcceptIdCurr = 0; this.DragDropAcceptIdPrev = this.DragDropAcceptIdCurr
	this.DragDropAcceptFrameCount = -1
	this.DragDropHoldJustPressedId = 0
	this.DragDropPayloadBufLocal = {}

	this.ClipperTempDataStacked = 0

	this.CurrentTable = nil
	this.TablesTempDataStacked = 0
	this.CurrentTabBar = nil
	this.CurrentMultiSelect = nil
	this.MultiSelectTempDataStacked = 0

	this.HoverWindowUnlockedStationaryId = 0; this.HoverItemUnlockedStationaryId = this.HoverWindowUnlockedStationaryId; this.HoverItemDelayIdPreviousFrame = this.HoverItemUnlockedStationaryId; this.HoverItemDelayId = this.HoverItemDelayIdPreviousFrame
	this.HoverItemDelayClearTimer = 0.0; this.HoverItemDelayTimer = this.HoverItemDelayClearTimer

	this.MouseCursor = ImGuiMouseCursor_.ImGuiMouseCursor_Arrow
	this.MouseStationaryTimer = 0.0

	this.TempInputId = 0
	this.DataTypeZeroValue = {}
	this.BeginComboDepth = 0; this.BeginMenuDepth = this.BeginComboDepth
	this.ColorEditOptions = ImGuiColorEditFlags_.ImGuiColorEditFlags_DefaultOptions_
	this.ColorEditSavedID = 0; this.ColorEditCurrentID = this.ColorEditSavedID
	this.ColorEditSavedSat = 0.0; this.ColorEditSavedHue = this.ColorEditSavedSat
	this.ColorEditSavedColor = 0
	this.WindowResizeRelativeMode = false
	this.ScrollbarSeekMode = 0
	this.ScrollbarClickDeltaToGrabCenter = 0.0
	this.SliderGrabClickOffset = 0.0
	this.SliderCurrentAccum = 0.0
	this.SliderCurrentAccumDirty = false
	this.DragCurrentAccumDirty = false
	this.DragCurrentAccum = 0.0
	this.DragSpeedDefaultRatio = 1.0 / 100.0
	this.DisabledAlphaBackup = 0.0
	this.DisabledStackSize = 0
	this.TooltipOverrideCount = 0
	this.TooltipPreviousWindow = nil

	this.PlatformImeData.InputPos = ImVec2{0.0, 0.0}
	this.PlatformImeDataPrev.InputPos = ImVec2{-1.0, -1.0}; // Different to ensure initial submission
	this.PlatformImeViewport = 0

	this.DockNodeWindowMenuHandler = nil

	this.SettingsLoaded = false
	this.SettingsDirtyTimer = 0.0
	this.HookIdNext = 0

	this.LocalizationTable = {}

	this.LogEnabled = false
	this.LogFlags = ImGuiLogFlags_.ImGuiLogFlags_None
	this.LogWindow = nil
	this.LogNextSuffix = ""; this.LogNextPrefix = this.LogNextSuffix
	this.LogFile = {}
	this.LogLinePosY = FLT_MAX
	this.LogLineFirstItem = false
	this.LogDepthRef = 0
	this.LogDepthToExpandDefault = 2; this.LogDepthToExpand = this.LogDepthToExpandDefault

	this.ErrorCallback = nil
	this.ErrorCallbackUserData = nil
	this.ErrorFirst = true
	this.ErrorCountCurrentFrame = 0
	this.StackSizesInBeginForCurrentWindow = nil

	this.DebugDrawIdConflictsCount = 0
	this.DebugLogFlags = ImGuiDebugLogFlags_.ImGuiDebugLogFlags_EventError | ImGuiDebugLogFlags_.ImGuiDebugLogFlags_OutputToTTY
	this.DebugLocateId = 0
	this.DebugLogSkippedErrors = 0
	this.DebugLogAutoDisableFlags = ImGuiDebugLogFlags_.ImGuiDebugLogFlags_None
	this.DebugLogAutoDisableFrames = 0
	this.DebugLocateFrames = 0
	this.DebugBeginReturnValueCullDepth = -1
	this.DebugItemPickerActive = false
	this.DebugItemPickerMouseButton = cast(u8)ImGuiMouseButton_.ImGuiMouseButton_Left
	this.DebugItemPickerBreakId = 0
	this.DebugFlashStyleColorTime = 0.0
	this.DebugFlashStyleColorIdx = ImGuiCol_.ImGuiCol_COUNT
	this.DebugHoveredDockNode = nil

	// Same as DebugBreakClearData(). Those fields are scattered in their respective subsystem to stay in hot-data locations
	this.DebugBreakInWindow = 0
	this.DebugBreakInTable = 0
	this.DebugBreakInLocateId = false
	this.DebugBreakKeyChord = ImGuiKey.ImGuiKey_Pause
	this.DebugBreakInShortcutRouting = ImGuiKey.ImGuiKey_None

	this.FramerateSecPerFrame = {}
	this.FramerateSecPerFrameCount = 0; this.FramerateSecPerFrameIdx = this.FramerateSecPerFrameCount
	this.FramerateSecPerFrameAccum = 0.0
	this.WantTextInputNextFrame = -1; this.WantCaptureKeyboardNextFrame = this.WantTextInputNextFrame; this.WantCaptureMouseNextFrame = this.WantCaptureKeyboardNextFrame
	this.TempKeychordName = {}
}

// Init
Initialize :: proc()
{
	g : ^ImGuiContext = GImGui
	IM_ASSERT(!g.Initialized && !g.SettingsLoaded)

	// Add .ini handle for ImGuiWindow and ImGuiTable types
	{
	ini_handler : ImGuiSettingsHandler
	ini_handler.TypeName = "Window"
	ini_handler.TypeHash = ImHashStr("Window")
	ini_handler.ClearAllFn = WindowSettingsHandler_ClearAll
	ini_handler.ReadOpenFn = WindowSettingsHandler_ReadOpen
	ini_handler.ReadLineFn = WindowSettingsHandler_ReadLine
	ini_handler.ApplyAllFn = WindowSettingsHandler_ApplyAll
	ini_handler.WriteAllFn = WindowSettingsHandler_WriteAll
	AddSettingsHandler(&ini_handler)
	}
	TableSettingsAddSettingsHandler()

	// Setup default localization table
	LocalizeRegisterEntries(GLocalizationEntriesEnUS[:])

	// Setup default ImGuiPlatformIO clipboard/IME handlers.
	g.PlatformIO.Platform_GetClipboardTextFn = Platform_GetClipboardTextFn_DefaultImpl; // Platform dependent default implementations
	g.PlatformIO.Platform_SetClipboardTextFn = Platform_SetClipboardTextFn_DefaultImpl
	g.PlatformIO.Platform_OpenInShellFn = Platform_OpenInShellFn_DefaultImpl
	g.PlatformIO.Platform_SetImeDataFn = Platform_SetImeDataFn_DefaultImpl

	// Create default viewport
	viewport : ^ImGuiViewportP = IM_NEW(ImGuiViewportP)
	viewport.ID = IMGUI_VIEWPORT_DEFAULT_ID
	viewport.Idx = 0
	viewport.PlatformWindowCreated = true
	viewport.Flags = ImGuiViewportFlags_.ImGuiViewportFlags_OwnedByApp
	push_back(&g.Viewports, viewport)
	resize(&g.TempBuffer, 1024 * 3 + 1, 0)
	post_incr(&g.ViewportCreatedCount)
	push_back(&g.PlatformIO.Viewports, g.Viewports.Data[0])

	// Build KeysMayBeCharInput[] lookup table (1 bool per named key)
	for key : ImGuiKey = ImGuiKey.ImGuiKey_NamedKey_BEGIN; key < ImGuiKey.ImGuiKey_NamedKey_END; key = (key + ImGuiKey(1)) { if (key >= ImGuiKey.ImGuiKey_0 && key <= ImGuiKey.ImGuiKey_9) || (key >= ImGuiKey.ImGuiKey_A && key <= ImGuiKey.ImGuiKey_Z) || (key >= ImGuiKey.ImGuiKey_Keypad0 && key <= ImGuiKey.ImGuiKey_Keypad9) || key == ImGuiKey.ImGuiKey_Tab || key == ImGuiKey.ImGuiKey_Space || key == ImGuiKey.ImGuiKey_Apostrophe || key == ImGuiKey.ImGuiKey_Comma || key == ImGuiKey.ImGuiKey_Minus || key == ImGuiKey.ImGuiKey_Period || key == ImGuiKey.ImGuiKey_Slash || key == ImGuiKey.ImGuiKey_Semicolon || key == ImGuiKey.ImGuiKey_Equal || key == ImGuiKey.ImGuiKey_LeftBracket || key == ImGuiKey.ImGuiKey_RightBracket || key == ImGuiKey.ImGuiKey_GraveAccent || key == ImGuiKey.ImGuiKey_KeypadDecimal || key == ImGuiKey.ImGuiKey_KeypadDivide || key == ImGuiKey.ImGuiKey_KeypadMultiply || key == ImGuiKey.ImGuiKey_KeypadSubtract || key == ImGuiKey.ImGuiKey_KeypadAdd || key == ImGuiKey.ImGuiKey_KeypadEqual { SetBit(&g.KeysMayBeCharInput, u32(key)) } }

	when IMGUI_HAS_DOCK { /* @gen ifdef */
	// Initialize Docking
	DockContextInitialize(g)
	} // preproc endif

	g.Initialized = true
}

// Since 1.60 this is a _private_ function. You can call DestroyContext() to destroy the context created by CreateContext().
// This function is merely here to free heap allocations.
Shutdown :: proc()
{
	g : ^ImGuiContext = GImGui
	IM_ASSERT_USER_ERROR(g.IO.BackendPlatformUserData == nil, "Forgot to shutdown Platform backend?")
	IM_ASSERT_USER_ERROR(g.IO.BackendRendererUserData == nil, "Forgot to shutdown Renderer backend?")

	// The fonts atlas can be used prior to calling NewFrame(), so we clear it even if g.Initialized is FALSE (which would happen if we never called NewFrame)
	if g.IO.Fonts != nil && g.FontAtlasOwnedByContext {
		g.IO.Fonts.Locked = false
		IM_DELETE(g.IO.Fonts)
	}
	g.IO.Fonts = nil
	clear(&g.DrawListSharedData.TempBuffer)

	// Cleanup of other data are conditional on actually having initialized Dear ImGui.
	if !g.Initialized { return }

	// Save settings (unless we haven't attempted to load them: CreateContext/DestroyContext without a call to NewFrame shouldn't save an empty file)
	if g.SettingsLoaded && g.IO.IniFilename != "" { SaveIniSettingsToDisk(g.IO.IniFilename) }

	// Destroy platform windows
	DestroyPlatformWindows()

	// Shutdown extensions
	DockContextShutdown(g)

	CallContextHooks(g, ImGuiContextHookType.ImGuiContextHookType_Shutdown)

	// Clear everything else
	clear_delete(&g.Windows)
	clear(&g.WindowsFocusOrder)
	clear(&g.WindowsTempSortBuffer)
	g.CurrentWindow = nil
	clear(&g.CurrentWindowStack)
	Clear(&g.WindowsById)
	g.NavWindow = nil
	g.HoveredWindowUnderMovingWindow = nil; g.HoveredWindow = g.HoveredWindowUnderMovingWindow
	g.ActiveIdPreviousFrameWindow = nil; g.ActiveIdWindow = g.ActiveIdPreviousFrameWindow
	g.MovingWindow = nil

	Clear(&g.KeysRoutingTable)

	clear(&g.ColorStack)
	clear(&g.StyleVarStack)
	clear(&g.FontStack)
	clear(&g.OpenPopupStack)
	clear(&g.BeginPopupStack)
	clear(&g.TreeNodeStack)

	g.MouseLastHoveredViewport = nil; g.MouseViewport = g.MouseLastHoveredViewport; g.CurrentViewport = g.MouseViewport
	clear_delete(&g.Viewports)

	Clear(&g.TabBars)
	clear(&g.CurrentTabBarStack)
	clear(&g.ShrinkWidthBuffer)

	clear_destruct(&g.ClipperTempData)

	Clear(&g.Tables)
	clear_destruct(&g.TablesTempData)
	clear(&g.DrawChannelsTempMergeBuffer)

	Clear(&g.MultiSelectStorage)
	clear_destruct(&g.MultiSelectTempData)

	clear(&g.ClipboardHandlerData)
	clear(&g.MenusIdSubmittedThisFrame)
	ClearFreeMemory(&g.InputTextState)
	ClearFreeMemory(&g.InputTextDeactivatedState)

	clear(&g.SettingsWindows)
	clear(&g.SettingsHandlers)

	if g.LogFile != {} {
		if IMGUI_DISABLE_TTY_FUNCTIONS || g.LogFile != os.stdout {
			ImFileClose(g.LogFile)
		}
		g.LogFile = {}
	}
	clear(&g.LogBuffer)
	clear(&g.DebugLogBuf)
	clear(&g.DebugLogIndex)

	g.Initialized = false
}

// Generic context hooks
// No specific ordering/dependency support, will see as needed
AddContextHook :: proc(ctx : ^ImGuiContext, hook : ^ImGuiContextHook) -> ImGuiID
{
	g : ^ImGuiContext = ctx
	IM_ASSERT(hook.Callback != nil && hook.HookId == 0 && hook.Type != ImGuiContextHookType.ImGuiContextHookType_PendingRemoval_)
	push_back(&g.Hooks, hook^)
	back(&g.Hooks).HookId = pre_incr(&g.HookIdNext)
	return g.HookIdNext
}

// Deferred removal, avoiding issue with changing vector while iterating it
RemoveContextHook :: proc(ctx : ^ImGuiContext, hook_id : ImGuiID)
{
	g : ^ImGuiContext = ctx
	IM_ASSERT(hook_id != 0)
	for &hook in g.Hooks.Data[:g.Hooks.Size] { if hook.HookId == hook_id { hook.Type = ImGuiContextHookType.ImGuiContextHookType_PendingRemoval_ } }
}

// Call context hooks (used by e.g. test engine)
// We assume a small number of hooks so all stored in same array
CallContextHooks :: proc(ctx : ^ImGuiContext, hook_type : ImGuiContextHookType)
{
	g : ^ImGuiContext = ctx
	for &hook in g.Hooks.Data[:g.Hooks.Size] { if hook.Type == hook_type { hook.Callback(g, &hook) } }
}

//-----------------------------------------------------------------------------
// [SECTION] MAIN CODE (most of the code! lots of stuff, needs tidying up!)
//-----------------------------------------------------------------------------

// ImGuiWindow is mostly a dumb struct. It merely has a constructor and a few helper methods
ImGuiWindow_init :: proc(this : ^ImGuiWindow, ctx : ^ImGuiContext, name : string)
{
	init(&this.WindowClass)
	init(&this.IDStack)
	init(&this.DC)
	init(&this.StateStorage)
	init(&this.ColumnsStorage)
	init(&this.DrawListInst, nil)
	this^ = {}
	this.Ctx = ctx
	this.Name = str.clone(name)
	this.NameBufLen = cast(i32) len(name) + 1
	this.ID = ImHashStr(name)
	push_back(&this.IDStack, this.ID)
	this.ViewportAllowPlatformMonitorExtend = -1
	this.ViewportPos = ImVec2{FLT_MAX, FLT_MAX}
	this.MoveId = GetID(this, "#MOVE")
	this.TabId = GetID(this, "#TAB")
	this.ScrollTarget = ImVec2{FLT_MAX, FLT_MAX}
	this.ScrollTargetCenterRatio = ImVec2{0.5, 0.5}
	this.AutoFitFramesY = -1; this.AutoFitFramesX = this.AutoFitFramesY
	this.AutoPosLastDirection = ImGuiDir.ImGuiDir_None
	this.SetWindowDockAllowFlags = {}; this.SetWindowCollapsedAllowFlags = this.SetWindowDockAllowFlags; this.SetWindowSizeAllowFlags = this.SetWindowCollapsedAllowFlags; this.SetWindowPosAllowFlags = this.SetWindowSizeAllowFlags
	this.SetWindowPosPivot = ImVec2{FLT_MAX, FLT_MAX}; this.SetWindowPosVal = this.SetWindowPosPivot
	this.LastFrameActive = -1
	this.LastFrameJustFocused = -1
	this.LastTimeActive = -1.0
	this.FontDpiScale = 1.0; this.FontWindowScale = this.FontDpiScale
	this.SettingsOffset = -1
	this.DockOrder = -1
	this.DrawList = &this.DrawListInst
	this.DrawList._OwnerName = this.Name
	this.DrawList._Data = &this.Ctx.DrawListSharedData
	this.NavPreferredScoringPosRel[1] = ImVec2{FLT_MAX, FLT_MAX}; this.NavPreferredScoringPosRel[0] = this.NavPreferredScoringPosRel[1]
	init(&this.WindowClass)
}

ImGuiWindow_deinit :: proc(this : ^ImGuiWindow)
{
	deinit(&this.IDStack)
	deinit(&this.DC)
	deinit(&this.StateStorage)
	deinit(&this.ColumnsStorage)
	deinit(&this.DrawListInst)
	IM_ASSERT(this.DrawList == &this.DrawListInst)
	IM_DELETE(raw_data(this.Name))
	clear_destruct(&this.ColumnsStorage)
}

// For use with io.ConfigDockingTransparentPayload. Apply to Viewport _or_ WindowBg in host viewport.

//-------------------------------------------------------------------------
// [SECTION] FORWARD DECLARATIONS
//-------------------------------------------------------------------------

SetCurrentWindow :: proc(window : ^ImGuiWindow)
{
	g : ^ImGuiContext = GImGui
	g.CurrentWindow = window
	g.StackSizesInBeginForCurrentWindow = g.CurrentWindow != nil ? &back(&g.CurrentWindowStack).StackSizesInBegin : nil
	g.CurrentTable = window != nil && window.DC.CurrentTableIdx != -1 ? GetByIndex(&g.Tables, window.DC.CurrentTableIdx) : nil
	if window != nil {
		g.DrawListSharedData.FontSize = CalcFontSize(window); g.FontSize = g.DrawListSharedData.FontSize
		g.DrawListSharedData.FontScale = g.FontSize / g.Font.FontSize; g.FontScale = g.DrawListSharedData.FontScale
		NavUpdateCurrentWindowIsScrollPushableX()
	}
}

// Garbage collection
GcCompactTransientMiscBuffers :: proc()
{
	g : ^ImGuiContext = GImGui
	clear(&g.ItemFlagsStack)
	clear(&g.GroupStack)
	g.MultiSelectTempDataStacked = 0
	clear_destruct(&g.MultiSelectTempData)
	TableGcCompactSettings()
}

// Free up/compact internal window buffers, we can use this when a window becomes unused.
// Not freed:
// - ImGuiWindow, ImGuiWindowSettings, Name, StateStorage, ColumnsStorage (may hold useful data)
// This should have no noticeable visual effect. When the window reappear however, expect new allocation/buffer growth/copy cost.
GcCompactTransientWindowBuffers :: proc(window : ^ImGuiWindow)
{
	window.MemoryCompacted = true
	window.MemoryDrawListIdxCapacity = window.DrawList.IdxBuffer.Capacity
	window.MemoryDrawListVtxCapacity = window.DrawList.VtxBuffer.Capacity
	clear(&window.IDStack)
	_ClearFreeMemory(window.DrawList)
	clear(&window.DC.ChildWindows)
	clear(&window.DC.ItemWidthStack)
	clear(&window.DC.TextWrapPosStack)
}

GcAwakeTransientWindowBuffers :: proc(window : ^ImGuiWindow)
{
	// We stored capacity of the ImDrawList buffer to reduce growth-caused allocation/copy when awakening.
	// The other buffers tends to amortize much faster.
	window.MemoryCompacted = false
	reserve(&window.DrawList.IdxBuffer, window.MemoryDrawListIdxCapacity)
	reserve(&window.DrawList.VtxBuffer, window.MemoryDrawListVtxCapacity)
	window.MemoryDrawListVtxCapacity = 0; window.MemoryDrawListIdxCapacity = window.MemoryDrawListVtxCapacity
}

SetActiveID :: proc(id : ImGuiID, window : ^ImGuiWindow)
{
	g : ^ImGuiContext = GImGui

	// Clear previous active id
	if g.ActiveId != 0 {
		// While most behaved code would make an effort to not steal active id during window move/drag operations,
		// we at least need to be resilient to it. Canceling the move is rather aggressive and users of 'master' branch
		// may prefer the weird ill-defined half working situation ('docking' did assert), so may need to rework that.
		if g.MovingWindow != nil && g.ActiveId == g.MovingWindow.MoveId {
			IMGUI_DEBUG_LOG_ACTIVEID(g, "SetActiveID() cancel MovingWindow\n")
			g.MovingWindow = nil
		}

		// This could be written in a more general way (e.g associate a hook to ActiveId),
		// but since this is currently quite an exception we'll leave it as is.
		// One common scenario leading to this is: pressing Key ->NavMoveRequestApplyResult() -> ClearActiveID()
		if g.InputTextState.ID == g.ActiveId { InputTextDeactivateHook(g.ActiveId) }
	}

	// Set active id
	g.ActiveIdIsJustActivated = (g.ActiveId != id)
	if g.ActiveIdIsJustActivated {
		IMGUI_DEBUG_LOG_ACTIVEID(g, "SetActiveID() old:0x%08X (window \"%s\") -> new:0x%08X (window \"%s\")\n", g.ActiveId, g.ActiveIdWindow != nil ? g.ActiveIdWindow.Name : "", id, window != nil ? window.Name : "")
		g.ActiveIdTimer = 0.0
		g.ActiveIdHasBeenPressedBefore = false
		g.ActiveIdHasBeenEditedBefore = false
		g.ActiveIdMouseButton = cast(ImGuiMouseButton) ~i32(0)
		if id != 0 {
			g.LastActiveId = id
			g.LastActiveIdTimer = 0.0
		}
	}
	g.ActiveId = id
	g.ActiveIdAllowOverlap = false
	g.ActiveIdNoClearOnFocusLoss = false
	g.ActiveIdWindow = window
	g.ActiveIdHasBeenEditedThisFrame = false
	g.ActiveIdFromShortcut = false
	if id != 0 {
		g.ActiveIdIsAlive = id
		g.ActiveIdSource = (g.NavActivateId == id || g.NavJustMovedToId == id) ? g.NavInputSource : ImGuiInputSource.ImGuiInputEventType_Mouse
		IM_ASSERT(g.ActiveIdSource != ImGuiInputSource.ImGuiInputSource_None)
	}

	// Clear declaration of inputs claimed by the widget
	// (Please note that this is WIP and not all keys/inputs are thoroughly declared by all widgets yet)
	g.ActiveIdUsingNavDirMask = 0x00
	g.ActiveIdUsingAllKeyboardKeys = false
}

ClearActiveID :: proc()
{
	SetActiveID(0, nil); // g.ActiveId = 0;
}

SetHoveredID :: proc(id : ImGuiID)
{
	g : ^ImGuiContext = GImGui
	g.HoveredId = id
	g.HoveredIdAllowOverlap = false
	if id != 0 && g.HoveredIdPreviousFrame != id { g.HoveredIdNotActiveTimer = 0.0; g.HoveredIdTimer = g.HoveredIdNotActiveTimer }
}

GetHoveredID :: proc() -> ImGuiID
{
	g : ^ImGuiContext = GImGui
	return g.HoveredId != 0 ? g.HoveredId : g.HoveredIdPreviousFrame
}

// Mark data associated to given item as "edited", used by IsItemDeactivatedAfterEdit() function.
MarkItemEdited :: proc(id : ImGuiID)
{
	// This marking is to be able to provide info for IsItemDeactivatedAfterEdit().
	// ActiveId might have been released by the time we call this (as in the typical press/release button behavior) but still need to fill the data.
	g : ^ImGuiContext = GImGui
	if (g.LastItemData.ItemFlags & cast(ImGuiItemFlags) ImGuiItemFlagsPrivate_.ImGuiItemFlags_NoMarkEdited) != {} { return }
	if g.ActiveId == id || g.ActiveId == 0 {
		g.ActiveIdHasBeenEditedThisFrame = true
		g.ActiveIdHasBeenEditedBefore = true
	}

	// We accept a MarkItemEdited() on drag and drop targets (see https://github.com/ocornut/imgui/issues/1875#issuecomment-978243343)
	// We accept 'ActiveIdPreviousFrame == id' for InputText() returning an edit after it has been taken ActiveId away (#4714)
	IM_ASSERT(g.DragDropActive || g.ActiveId == id || g.ActiveId == 0 || g.ActiveIdPreviousFrame == id || (g.CurrentMultiSelect != nil && g.BoxSelectState.IsActive))

	//IM_ASSERT(g.CurrentWindow->DC.LastItemId == id);
	g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_.ImGuiItemStatusFlags_Edited
}

IsWindowContentHoverable :: proc(window : ^ImGuiWindow, flags : ImGuiHoveredFlags = {}) -> bool
{
	// An active popup disable hovering on other windows (apart from its own children)
	// FIXME-OPT: This could be cached/stored within the window.
	g : ^ImGuiContext = GImGui
	if g.NavWindow != nil { if focused_root_window : ^ImGuiWindow = g.NavWindow.RootWindowDockTree; focused_root_window != nil { if focused_root_window.WasActive && focused_root_window != window.RootWindowDockTree {
	// For the purpose of those flags we differentiate "standard popup" from "modal popup"
	// NB: The 'else' is important because Modal windows are also Popups.
	want_inhibit : bool = false
	if (focused_root_window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_Modal) != {} { want_inhibit = true }
	else if (focused_root_window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_Popup) != {} && (flags & ImGuiHoveredFlags_.ImGuiHoveredFlags_AllowWhenBlockedByPopup) == {} { want_inhibit = true }

	// Inhibit hover unless the window is within the stack of our modal/popup
	if want_inhibit { if !IsWindowWithinBeginStackOf(window.RootWindow, focused_root_window) { return false } }
} } }

	// Filter by viewport
	if window.Viewport != g.MouseViewport { if g.MovingWindow == nil || window.RootWindowDockTree != g.MovingWindow.RootWindowDockTree { return false } }

	return true
}

CalcDelayFromHoveredFlags :: #force_inline proc(flags : ImGuiHoveredFlags) -> f32
{
	g : ^ImGuiContext = GImGui
	if (flags & ImGuiHoveredFlags_.ImGuiHoveredFlags_DelayNormal) != {} { return g.Style.HoverDelayNormal }
	if (flags & ImGuiHoveredFlags_.ImGuiHoveredFlags_DelayShort) != {} { return g.Style.HoverDelayShort }
	return 0.0
}

ApplyHoverFlagsForTooltip :: proc(user_flags : ImGuiHoveredFlags, shared_flags : ImGuiHoveredFlags) -> ImGuiHoveredFlags
{
	shared_flags := shared_flags
	// Allow instance flags to override shared flags
	if (user_flags & (ImGuiHoveredFlags_.ImGuiHoveredFlags_DelayNone | ImGuiHoveredFlags_.ImGuiHoveredFlags_DelayShort | ImGuiHoveredFlags_.ImGuiHoveredFlags_DelayNormal)) != {} { shared_flags &= cast(ImGuiHoveredFlags) ~i32(ImGuiHoveredFlags_.ImGuiHoveredFlags_DelayNone | ImGuiHoveredFlags_.ImGuiHoveredFlags_DelayShort | ImGuiHoveredFlags_.ImGuiHoveredFlags_DelayNormal) }
	return user_flags | shared_flags
}

// Item/Widgets Utilities and Query Functions
// - Most of the functions are referring to the previous Item that has been submitted.
// - See Demo Window under "Widgets->Querying Status" for an interactive visualization of most of those functions.
// is the last item hovered? (and usable, aka not blocked by a popup, etc.). See ImGuiHoveredFlags for more options.
// This is roughly matching the behavior of internal-facing ItemHoverable()
// - we allow hovering to be true when ActiveId==window->MoveID, so that clicking on non-interactive items such as a Text() item still returns true with IsItemHovered()
// - this should work even for non-interactive items that have no ID, so we cannot use LastItemId
IsItemHovered :: proc(flags : ImGuiHoveredFlags = {}) -> bool
{
	g : ^ImGuiContext = GImGui
	window : ^ImGuiWindow = g.CurrentWindow
	IM_ASSERT_USER_ERROR((flags & cast(ImGuiHoveredFlags) ~cast(i32)ImGuiHoveredFlagsPrivate_.ImGuiHoveredFlags_AllowedMaskForIsItemHovered) == {}, "Invalid flags for IsItemHovered()!")

	flags := flags
	if g.NavHighlightItemUnderNav && g.NavCursorVisible && (flags & ImGuiHoveredFlags_.ImGuiHoveredFlags_NoNavOverride) == {} {
		if !IsItemFocused() { return false }
		if (g.LastItemData.ItemFlags & cast(ImGuiItemFlags) ImGuiItemFlagsPrivate_.ImGuiItemFlags_Disabled) != {} && (flags & ImGuiHoveredFlags_.ImGuiHoveredFlags_AllowWhenDisabled) == {} { return false }

		if (flags & ImGuiHoveredFlags_.ImGuiHoveredFlags_ForTooltip) != {} { flags = ApplyHoverFlagsForTooltip(flags, g.Style.HoverFlagsForTooltipNav) }
	}
	else {
		// Test for bounding box overlap, as updated as ItemAdd()
		status_flags : ImGuiItemStatusFlags = g.LastItemData.StatusFlags
		if (status_flags & ImGuiItemStatusFlags_.ImGuiItemStatusFlags_HoveredRect) == {} { return false }

		if (flags & ImGuiHoveredFlags_.ImGuiHoveredFlags_ForTooltip) != {} { flags = ApplyHoverFlagsForTooltip(flags, g.Style.HoverFlagsForTooltipMouse) }

		// Done with rectangle culling so we can perform heavier checks now
		// Test if we are hovering the right window (our window could be behind another window)
		// [2021/03/02] Reworked / reverted the revert, finally. Note we want e.g. BeginGroup/ItemAdd/EndGroup to work as well. (#3851)
		// [2017/10/16] Reverted commit 344d48be3 and testing RootWindow instead. I believe it is correct to NOT test for RootWindow but this leaves us unable
		// to use IsItemHovered() after EndChild() itself. Until a solution is found I believe reverting to the test from 2017/09/27 is safe since this was
		// the test that has been running for a long while.
		if g.HoveredWindow != window && (status_flags & ImGuiItemStatusFlags_.ImGuiItemStatusFlags_HoveredWindow) == {} { if (flags & ImGuiHoveredFlags_.ImGuiHoveredFlags_AllowWhenOverlappedByWindow) == {} { return false } }

		// Test if another item is active (e.g. being dragged)
		id : ImGuiID = g.LastItemData.ID
		if (flags & ImGuiHoveredFlags_.ImGuiHoveredFlags_AllowWhenBlockedByActiveItem) == {} { if g.ActiveId != 0 && g.ActiveId != id && !g.ActiveIdAllowOverlap { if g.ActiveId != window.MoveId && g.ActiveId != window.TabId { return false } } }

		// Test if interactions on this window are blocked by an active popup or modal.
		// The ImGuiHoveredFlags_AllowWhenBlockedByPopup flag will be tested here.
		if !IsWindowContentHoverable(window, flags) && (g.LastItemData.ItemFlags & cast(ImGuiItemFlags) ImGuiItemFlagsPrivate_.ImGuiItemFlags_NoWindowHoverableCheck) == {} { return false }

		// Test if the item is disabled
		if (g.LastItemData.ItemFlags & cast(ImGuiItemFlags) ImGuiItemFlagsPrivate_.ImGuiItemFlags_Disabled) != {} && (flags & ImGuiHoveredFlags_.ImGuiHoveredFlags_AllowWhenDisabled) == {} { return false }

		// Special handling for calling after Begin() which represent the title bar or tab.
		// When the window is skipped/collapsed (SkipItems==true) that last item (always ->MoveId submitted by Begin)
		// will never be overwritten so we need to detect the case.
		if id == window.MoveId && window.WriteAccessed { return false }

		// Test if using AllowOverlap and overlapped
		if (g.LastItemData.ItemFlags & cast(ImGuiItemFlags) ImGuiItemFlagsPrivate_.ImGuiItemFlags_AllowOverlap) != {} && id != 0 { if (flags & ImGuiHoveredFlags_.ImGuiHoveredFlags_AllowWhenOverlappedByItem) == {} { if g.HoveredIdPreviousFrame != g.LastItemData.ID { return false } } }
	}

	// Handle hover delay
	// (some ideas: https://www.nngroup.com/articles/timing-exposing-content)
	delay : f32 = CalcDelayFromHoveredFlags(flags)
	if delay > 0.0 || (flags & ImGuiHoveredFlags_.ImGuiHoveredFlags_Stationary) != {} {
		hover_delay_id : ImGuiID = (g.LastItemData.ID != 0) ? g.LastItemData.ID : GetIDFromPos(window, g.LastItemData.Rect.Min)
		if (flags & ImGuiHoveredFlags_.ImGuiHoveredFlags_NoSharedDelay) != {} && (g.HoverItemDelayIdPreviousFrame != hover_delay_id) { g.HoverItemDelayTimer = 0.0 }
		g.HoverItemDelayId = hover_delay_id

		// When changing hovered item we requires a bit of stationary delay before activating hover timer,
		// but once unlocked on a given item we also moving.
		//if (g.HoverDelayTimer >= delay && (g.HoverDelayTimer - g.IO.DeltaTime < delay || g.MouseStationaryTimer - g.IO.DeltaTime < g.Style.HoverStationaryDelay)) { IMGUI_DEBUG_LOG("HoverDelayTimer = %f/%f, MouseStationaryTimer = %f\n", g.HoverDelayTimer, delay, g.MouseStationaryTimer); }
		if (flags & ImGuiHoveredFlags_.ImGuiHoveredFlags_Stationary) != {} && g.HoverItemUnlockedStationaryId != hover_delay_id { return false }

		if g.HoverItemDelayTimer < delay { return false }
	}

	return true
}

// Internal facing ItemHoverable() used when submitting widgets. Differs slightly from IsItemHovered().
// (this does not rely on LastItemData it can be called from a ButtonBehavior() call not following an ItemAdd() call)
// FIXME-LEGACY: the 'ImGuiItemFlags item_flags' parameter was added on 2023-06-28.
// If you used this in your legacy/custom widgets code:
// - Commonly: if your ItemHoverable() call comes after an ItemAdd() call: pass 'item_flags = g.LastItemData.ItemFlags'.
// - Rare: otherwise you may pass 'item_Flags = {}' (ImGuiItemFlags_None) unless you want to benefit from special behavior handled by ItemHoverable.
ItemHoverable :: proc(bb : ImRect, id : ImGuiID, item_flags : ImGuiItemFlags) -> bool
{
	g : ^ImGuiContext = GImGui
	window : ^ImGuiWindow = g.CurrentWindow

	// Detect ID conflicts
	when ! IMGUI_DISABLE_DEBUG_TOOLS { /* @gen ifndef */
	if id != 0 && g.HoveredIdPreviousFrame == id && (item_flags & ImGuiItemFlags_.ImGuiItemFlags_AllowDuplicateId) == {} {
		post_incr(&g.HoveredIdPreviousFrameItemCount)
		if g.DebugDrawIdConflicts == id { AddRect(window.DrawList, bb.Min - ImVec2{1, 1}, bb.Max + ImVec2{1, 1}, IM_COL32(255, 0, 0, 255), 0.0, ImDrawFlags_.ImDrawFlags_None, 2.0) }
	}
	} // preproc endif

	if g.HoveredWindow != window { return false }
	if !IsMouseHoveringRect(bb.Min, bb.Max) { return false }

	if g.HoveredId != 0 && g.HoveredId != id && !g.HoveredIdAllowOverlap { return false }
	if g.ActiveId != 0 && g.ActiveId != id && !g.ActiveIdAllowOverlap { if !g.ActiveIdFromShortcut { return false } }

	// Done with rectangle culling so we can perform heavier checks now.
	if (item_flags & cast(ImGuiItemFlags) ImGuiItemFlagsPrivate_.ImGuiItemFlags_NoWindowHoverableCheck) == {} && !IsWindowContentHoverable(window, ImGuiHoveredFlags_.ImGuiHoveredFlags_None) {
		g.HoveredIdIsDisabled = true
		return false
	}

	// We exceptionally allow this function to be called with id==0 to allow using it for easy high-level
	// hover test in widgets code. We could also decide to split this function is two.
	if id != 0 {
		// Drag source doesn't report as hovered
		if g.DragDropActive && g.DragDropPayload.SourceId == id && (g.DragDropSourceFlags & ImGuiDragDropFlags_.ImGuiDragDropFlags_SourceNoDisableHover) == {} { return false }

		SetHoveredID(id)

		// AllowOverlap mode (rarely used) requires previous frame HoveredId to be null or to match.
		// This allows using patterns where a later submitted widget overlaps a previous one. Generally perceived as a front-to-back hit-test.
		if (item_flags & cast(ImGuiItemFlags) ImGuiItemFlagsPrivate_.ImGuiItemFlags_AllowOverlap) != {} {
			g.HoveredIdAllowOverlap = true
			if g.HoveredIdPreviousFrame != id { return false }
		}

		// Display shortcut (only works with mouse)
		// (ImGuiItemStatusFlags_HasShortcut in LastItemData denotes we want a tooltip)
		if id == g.LastItemData.ID && (g.LastItemData.StatusFlags & ImGuiItemStatusFlags_.ImGuiItemStatusFlags_HasShortcut) != {} && g.ActiveId != id { if IsItemHovered(ImGuiHoveredFlags_.ImGuiHoveredFlags_ForTooltip | ImGuiHoveredFlags_.ImGuiHoveredFlags_DelayNormal) { SetTooltip("%s", GetKeyChordName(g.LastItemData.Shortcut)) } }
	}

	// When disabled we'll return false but still set HoveredId
	if (item_flags & cast(ImGuiItemFlags) ImGuiItemFlagsPrivate_.ImGuiItemFlags_Disabled) != {} {
		// Release active id if turning disabled
		if g.ActiveId == id && id != 0 { ClearActiveID() }
		g.HoveredIdIsDisabled = true
		return false
	}

	when ! IMGUI_DISABLE_DEBUG_TOOLS { /* @gen ifndef */
	if id != 0 {
		// [DEBUG] Item Picker tool!
		// We perform the check here because reaching is path is rare (1~ time a frame),
		// making the cost of this tool near-zero! We could get better call-stack and support picking non-hovered
		// items if we performed the test in ItemAdd(), but that would incur a bigger runtime cost.
		if g.DebugItemPickerActive && g.HoveredIdPreviousFrame == id { AddRect(GetForegroundDrawList(), bb.Min, bb.Max, IM_COL32(255, 255, 0, 255)) }
		if g.DebugItemPickerBreakId == id { IM_DEBUG_BREAK() }
	}
	} // preproc endif

	if g.NavHighlightItemUnderNav && (item_flags & cast(ImGuiItemFlags) ImGuiItemFlagsPrivate_.ImGuiItemFlags_NoNavDisableMouseHover) == {} { return false }

	return true
}

// FIXME: This is inlined/duplicated in ItemAdd()
// FIXME: The id != 0 path is not used by our codebase, may get rid of it?
IsClippedEx :: proc(bb : ImRect, id : ImGuiID) -> bool
{
	g : ^ImGuiContext = GImGui
	window : ^ImGuiWindow = g.CurrentWindow
	if !Overlaps(bb, window.ClipRect) { if id == 0 || (id != g.ActiveId && id != g.ActiveIdPreviousFrame && id != g.NavId && id != g.NavActivateId) { if !g.ItemUnclipByLog { return true } } }
	return false
}

// This is also inlined in ItemAdd()
// Note: if ImGuiItemStatusFlags_HasDisplayRect is set, user needs to set g.LastItemData.DisplayRect.
SetLastItemData :: proc(item_id : ImGuiID, in_flags : ImGuiItemFlags, item_flags : ImGuiItemStatusFlags, item_rect : ImRect)
{
	g : ^ImGuiContext = GImGui
	g.LastItemData.ID = item_id
	g.LastItemData.ItemFlags = in_flags
	g.LastItemData.StatusFlags = item_flags
	g.LastItemData.NavRect = item_rect; g.LastItemData.Rect = g.LastItemData.NavRect
}

CalcWrapWidthForPos :: proc(pos : ImVec2, wrap_pos_x : f32) -> f32
{
	if wrap_pos_x < 0.0 { return 0.0 }

	wrap_pos_x := wrap_pos_x
	g : ^ImGuiContext = GImGui
	window : ^ImGuiWindow = g.CurrentWindow
	if wrap_pos_x == 0.0 {
		// We could decide to setup a default wrapping max point for auto-resizing windows,
		// or have auto-wrap (with unspecified wrapping pos) behave as a ContentSize extending function?
		//if (window->Hidden && (window->Flags & ImGuiWindowFlags_AlwaysAutoResize))
		//    wrap_pos_x = ImMax(window->WorkRect.Min.x + g.FontSize * 10.0f, window->WorkRect.Max.x);
		//else
		wrap_pos_x = window.WorkRect.Max.x
	}
	else if wrap_pos_x > 0.0 {
		wrap_pos_x += window.Pos.x - window.Scroll.x; // wrap_pos_x is provided is window local space
	}

	return ImMax(wrap_pos_x - pos.x, 1.0)
}

// IM_ALLOC() == ImGui::MemAlloc()
MemAlloc :: proc(#any_int size : uint) -> rawptr
{
	ptr : rawptr = GImAllocatorAllocFunc(size, GImAllocatorUserData)
	when ! IMGUI_DISABLE_DEBUG_TOOLS {
		if ctx : ^ImGuiContext = GImGui; ctx != nil { 
			DebugAllocHook(&ctx.DebugAllocInfo, ctx.FrameCount, ptr, size)
		}
	} // preproc endif
	return ptr
}

// IM_FREE() == ImGui::MemFree()
MemFree :: proc(ptr : rawptr)
{
	when ! IMGUI_DISABLE_DEBUG_TOOLS {
	if ptr != nil { 
		if ctx : ^ImGuiContext = GImGui; ctx != nil {
			DebugAllocHook(&ctx.DebugAllocInfo, ctx.FrameCount, ptr, ~uint(0))
		}
	}
	} // preproc endif
	GImAllocatorFreeFunc(ptr, GImAllocatorUserData)
}

// Debug Tools
// size >= 0 : alloc, size = -1 : free
// We record the number of allocation in recent frames, as a way to audit/sanitize our guiding principles of "no allocations on idle/repeating frames"
DebugAllocHook :: proc(info : ^ImGuiDebugAllocInfo, frame_count : i32, ptr : rawptr, size : uint)
{
	entry : ^ImGuiDebugAllocEntry = &info.LastEntriesBuf[info.LastEntriesIdx]
	IM_UNUSED(ptr)
	if entry.FrameCount != frame_count {
		info.LastEntriesIdx = (info.LastEntriesIdx + 1) % cast(i16) IM_ARRAYSIZE(info.LastEntriesBuf)
		entry = &info.LastEntriesBuf[info.LastEntriesIdx]
		entry.FrameCount = frame_count
		entry.FreeCount = 0; entry.AllocCount = entry.FreeCount
	}
	if size != ~uint(0) {
		//printf("[%05d] MemAlloc(%d) -> 0x%p\n", frame_count, (int)size, ptr);
		post_incr(&entry.AllocCount)
		post_incr(&info.TotalAllocCount)
	}
	else {
		//printf("[%05d] MemFree(0x%p)\n", frame_count, ptr);
		post_incr(&entry.FreeCount)
		post_incr(&info.TotalFreeCount)
	}
}

// Clipboard Utilities
// - Also see the LogToClipboard() function to capture GUI into clipboard, or easily output text data to the clipboard.
GetClipboardText :: proc() -> string
{
	g : ^ImGuiContext = GImGui
	return g.PlatformIO.Platform_GetClipboardTextFn != nil ? g.PlatformIO.Platform_GetClipboardTextFn(g) : ""
}

SetClipboardText :: proc(text : string)
{
	g : ^ImGuiContext = GImGui
	if g.PlatformIO.Platform_SetClipboardTextFn != nil { g.PlatformIO.Platform_SetClipboardTextFn(g, text) }
}

// get the compiled version string e.g. "1.80 WIP" (essentially the value for IMGUI_VERSION from the compiled version of imgui.cpp)
GetVersion :: proc() -> string
{
	return IMGUI_VERSION
}

// Main
// access the ImGuiIO structure (mouse/keyboard/gamepad inputs, time, various configuration options/flags)
GetIO :: proc() -> ^ImGuiIO
{
	IM_ASSERT(GImGui != nil, "No current context. Did you call ImGui::CreateContext() and ImGui::SetCurrentContext() ?")
	return &GImGui.IO
}

// Windows
// We should always have a CurrentWindow in the stack (there is an implicit "Debug" window)
// If this ever crashes because g.CurrentWindow is NULL, it means that either:
// - ImGui::NewFrame() has never been called, which is illegal.
// - You are calling ImGui functions after ImGui::EndFrame()/ImGui::Render() and before the next ImGui::NewFrame(), which is also illegal.
// This variant exists to facilitate backends experimenting with multi-threaded parallel context. (#8069, #6293, #5856)
GetIOEx :: proc(ctx : ^ImGuiContext) -> ^ImGuiIO
{
	IM_ASSERT(ctx != nil)
	return &ctx.IO
}

// access the ImGuiPlatformIO structure (mostly hooks/functions to connect to platform/renderer and OS Clipboard, IME etc.)
GetPlatformIO :: proc() -> ^ImGuiPlatformIO
{
	IM_ASSERT(GImGui != nil, "No current context. Did you call ImGui::CreateContext() and ImGui::SetCurrentContext()?")
	return &GImGui.PlatformIO
}

// This variant exists to facilitate backends experimenting with multi-threaded parallel context. (#8069, #6293, #5856)
GetPlatformIOEx :: proc(ctx : ^ImGuiContext) -> ^ImGuiPlatformIO
{
	IM_ASSERT(ctx != nil)
	return &ctx.PlatformIO
}

// valid after Render() and until the next call to NewFrame(). this is what you have to render.
// Pass this to your backend rendering function! Valid after Render() and until the next call to NewFrame()
GetDrawData :: proc() -> ^ImDrawData
{
	g : ^ImGuiContext = GImGui
	viewport : ^ImGuiViewportP = g.Viewports.Data[0]
	return viewport.DrawDataP.Valid ? &viewport.DrawDataP : nil
}

// get global imgui time. incremented by io.DeltaTime every frame.
GetTime :: proc() -> f64
{
	return GImGui.Time
}

// get global imgui frame count. incremented by 1 every frame.
GetFrameCount :: proc() -> i32
{
	return GImGui.FrameCount
}

GetViewportBgFgDrawList :: proc(viewport : ^ImGuiViewportP, drawlist_no : uint, drawlist_name : string) -> ^ImDrawList
{
	// Create the draw list on demand, because they are not frequently used for all viewports
	g : ^ImGuiContext = GImGui
	IM_ASSERT(drawlist_no < len(viewport.BgFgDrawLists))
	draw_list : ^ImDrawList = viewport.BgFgDrawLists[drawlist_no]
	if draw_list == nil {
		draw_list = cast(^ImDrawList) IM_ALLOC(size_of(ImDrawList))
		init(draw_list, &g.DrawListSharedData)
		draw_list._OwnerName = drawlist_name
		viewport.BgFgDrawLists[drawlist_no] = draw_list
	}

	// Our ImDrawList system requires that there is always a command
	if viewport.BgFgDrawListsLastFrame[drawlist_no] != g.FrameCount {
		ImDrawList__ResetForNewFrame(draw_list)
		PushTextureID(draw_list, g.IO.Fonts.TexID)
		PushClipRect(draw_list, viewport.Pos, viewport.Pos + viewport.Size, false)
		viewport.BgFgDrawListsLastFrame[drawlist_no] = g.FrameCount
	}
	return draw_list
}

// Background/Foreground Draw Lists
// get background draw list for the given viewport or viewport associated to the current window. this draw list will be the first rendering one. Useful to quickly draw shapes/text behind dear imgui contents.
GetBackgroundDrawList :: proc(viewport : ^ImGuiViewport) -> ^ImDrawList
{
	viewport := viewport
	if viewport == nil { viewport = GImGui.CurrentWindow.Viewport }
	return GetViewportBgFgDrawList(cast(^ImGuiViewportP) viewport, 0, "##Background")
}

// get foreground draw list for the given viewport or viewport associated to the current window. this draw list will be the top-most rendered one. Useful to quickly draw shapes/text over dear imgui contents.
GetForegroundDrawList_vp :: proc(viewport : ^ImGuiViewport) -> ^ImDrawList
{
	viewport := viewport
	if viewport == nil { viewport = GImGui.CurrentWindow.Viewport }
	return GetViewportBgFgDrawList(cast(^ImGuiViewportP) viewport, 1, "##Foreground")
}

// you may use this when creating your own ImDrawList instances.
GetDrawListSharedData :: proc() -> ^ImDrawListSharedData
{
	return &GImGui.DrawListSharedData
}

StartMouseMovingWindow :: proc(window : ^ImGuiWindow)
{
	// Set ActiveId even if the _NoMove flag is set. Without it, dragging away from a window with _NoMove would activate hover on other windows.
	// We _also_ call this when clicking in a window empty space when io.ConfigWindowsMoveFromTitleBarOnly is set, but clear g.MovingWindow afterward.
	// This is because we want ActiveId to be set even when the window is not permitted to move.
	g : ^ImGuiContext = GImGui
	FocusWindow(window)
	SetActiveID(window.MoveId, window)
	if g.IO.ConfigNavCursorVisibleAuto { g.NavCursorVisible = false }
	g.ActiveIdClickOffset = g.IO.MouseClickedPos[0] - window.RootWindowDockTree.Pos
	g.ActiveIdNoClearOnFocusLoss = true
	SetActiveIdUsingAllKeyboardKeys()

	can_move_window : bool = true
	if (window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoMove) != {} || (window.RootWindowDockTree.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoMove) != {} { can_move_window = false }
	if node : ^ImGuiDockNode = window.DockNodeAsHost; node != nil { if node.VisibleWindow != nil && (node.VisibleWindow.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoMove) != {} { can_move_window = false } }
	if can_move_window { g.MovingWindow = window }
}

// We use 'undock == false' when dragging from title bar to allow moving groups of floating nodes without undocking them.
StartMouseMovingWindowOrNode :: proc(window : ^ImGuiWindow, node : ^ImGuiDockNode, undock : bool)
{
	g : ^ImGuiContext = GImGui
	can_undock_node : bool = false
	if undock && node != nil && node.VisibleWindow != nil && (node.VisibleWindow.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoMove) == {} && (node.MergedFlags & ImGuiDockNodeFlags_.ImGuiDockNodeFlags_NoUndocking) == {} {
		// Can undock if:
		// - part of a hierarchy with more than one visible node (if only one is visible, we'll just move the root window)
		// - part of a dockspace node hierarchy: so we can undock the last single visible node too. Undocking from a fixed/central node will create a new node and copy windows.
		root_node : ^ImGuiDockNode = DockNodeGetRootNode(node)
		if root_node.OnlyNodeWithWindows != node || root_node.CentralNode != nil {
			// -V1051 PVS-Studio thinks node should be root_node and is wrong about that.
			can_undock_node = true
		}
	}

	clicked : bool = IsMouseClicked(cast(ImGuiMouseButton) 0)
	dragging : bool = IsMouseDragging(cast(ImGuiMouseButton)0)
	if can_undock_node && dragging {
		// Will lead to DockNodeStartMouseMovingWindow() -> StartMouseMovingWindow() being called next frame
		DockContextQueueUndockNode(g, node)
	}
	else if !can_undock_node && (clicked || dragging) && g.MovingWindow != window { StartMouseMovingWindow(window) }
}

// Handle mouse moving window
// Note: moving window with the navigation keys (Square + d-pad / CTRL+TAB + Arrows) are processed in NavUpdateWindowing()
// FIXME: We don't have strong guarantee that g.MovingWindow stay synched with g.ActiveId == g.MovingWindow->MoveId.
// This is currently enforced by the fact that BeginDragDropSource() is setting all g.ActiveIdUsingXXXX flags to inhibit navigation inputs,
// but if we should more thoroughly test cases where g.ActiveId or g.MovingWindow gets changed and not the other.
UpdateMouseMovingWindowNewFrame :: proc()
{
	g : ^ImGuiContext = GImGui
	if g.MovingWindow != nil {
		// We actually want to move the root window. g.MovingWindow == window we clicked on (could be a child window).
		// We track it to preserve Focus and so that generally ActiveIdWindow == MovingWindow and ActiveId == MovingWindow->MoveId for consistency.
		KeepAliveID(g.ActiveId)
		IM_ASSERT(g.MovingWindow != nil && g.MovingWindow.RootWindowDockTree != nil)
		moving_window : ^ImGuiWindow = g.MovingWindow.RootWindowDockTree

		// When a window stop being submitted while being dragged, it may will its viewport until next Begin()
		window_disappared : bool = (!moving_window.WasActive && !moving_window.Active)
		if g.IO.MouseDown[0] && IsMousePosValid(&g.IO.MousePos) && !window_disappared {
			pos : ImVec2 = g.IO.MousePos - g.ActiveIdClickOffset
			if moving_window.Pos.x != pos.x || moving_window.Pos.y != pos.y {
				SetWindowPos(moving_window, pos, ImGuiCond_.ImGuiCond_Always)
				if moving_window.Viewport != nil && moving_window.ViewportOwned {
					// Synchronize viewport immediately because some overlays may relies on clipping rectangle before we Begin() into the window.
					moving_window.Viewport.Pos = pos
					UpdateWorkRect(moving_window.Viewport)
				}
			}
			FocusWindow(g.MovingWindow)
		}
		else {
			if !window_disappared {
				// Try to merge the window back into the main viewport.
				// This works because MouseViewport should be != MovingWindow->Viewport on release (as per code in UpdateViewports)
				if (g.ConfigFlagsCurrFrame & ImGuiConfigFlags_.ImGuiConfigFlags_ViewportsEnable) != {} { UpdateTryMergeWindowIntoHostViewport(moving_window, g.MouseViewport) }

				// Restore the mouse viewport so that we don't hover the viewport _under_ the moved window during the frame we released the mouse button.
				if moving_window.Viewport != nil && !IsDragDropPayloadBeingAccepted() { g.MouseViewport = moving_window.Viewport }

				// Clear the NoInput window flag set by the Viewport system
				if moving_window.Viewport != nil { moving_window.Viewport.Flags &= cast(ImGuiViewportFlags)~cast(i32)ImGuiViewportFlags_.ImGuiViewportFlags_NoInputs }
			}

			g.MovingWindow = nil
			ClearActiveID()
		}
	}
	else {
		// When clicking/dragging from a window that has the _NoMove flag, we still set the ActiveId in order to prevent hovering others.
		if g.ActiveIdWindow != nil && g.ActiveIdWindow.MoveId == g.ActiveId {
			KeepAliveID(g.ActiveId)
			if !g.IO.MouseDown[0] { ClearActiveID() }
		}
	}
}

// Initiate focusing and moving window when clicking on empty space or title bar.
// Initiate focusing window when clicking on a disabled item.
// Handle left-click and right-click focus.
UpdateMouseMovingWindowEndFrame :: proc()
{
	g : ^ImGuiContext = GImGui
	if g.ActiveId != 0 || (g.HoveredId != 0 && !g.HoveredIdIsDisabled) { return }

	// Unless we just made a window/popup appear
	if g.NavWindow != nil && g.NavWindow.Appearing { return }

	// Click on empty space to focus window and start moving
	// (after we're done with all our widgets, so e.g. clicking on docking tab-bar which have set HoveredId already and not get us here!)
	if g.IO.MouseClicked[0] {
		// Handle the edge case of a popup being closed while clicking in its empty space.
		// If we try to focus it, FocusWindow() > ClosePopupsOverWindow() will accidentally close any parent popups because they are not linked together any more.
		root_window : ^ImGuiWindow = g.HoveredWindow != nil ? g.HoveredWindow.RootWindow : nil
		is_closed_popup : bool = root_window != nil && (root_window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_Popup) != {} && !IsPopupOpen(root_window.PopupId, ImGuiPopupFlags_.ImGuiPopupFlags_AnyPopupLevel)

		if root_window != nil && !is_closed_popup {
			StartMouseMovingWindow(g.HoveredWindow); //-V595

			// Cancel moving if clicked outside of title bar
			if g.IO.ConfigWindowsMoveFromTitleBarOnly { if (root_window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoTitleBar) == {} || root_window.DockIsActive { if !Contains(TitleBarRect(root_window), g.IO.MouseClickedPos[0]) { g.MovingWindow = nil } } }

			// Cancel moving if clicked over an item which was disabled or inhibited by popups
			// (when g.HoveredIdIsDisabled == true && g.HoveredId == 0 we are inhibited by popups, when g.HoveredIdIsDisabled == true && g.HoveredId != 0 we are over a disabled item)0 already)
			if g.HoveredIdIsDisabled { g.MovingWindow = nil }
		}
		else if root_window == nil && g.NavWindow != nil {
			// Clicking on void disable focus
			FocusWindow(nil, ImGuiFocusRequestFlags_.ImGuiFocusRequestFlags_UnlessBelowModal)
		}
	}

	// With right mouse button we close popups without changing focus based on where the mouse is aimed
	// Instead, focus will be restored to the window under the bottom-most closed popup.
	// (The left mouse button path calls FocusWindow on the hovered window, which will lead NewFrame->ClosePopupsOverWindow to trigger)
	if g.IO.MouseClicked[1] && g.HoveredId == 0 {
		// Find the top-most window between HoveredWindow and the top-most Modal Window.
		// This is where we can trim the popup stack.
		modal : ^ImGuiWindow = GetTopMostPopupModal()
		hovered_window_above_modal : bool = g.HoveredWindow != nil && (modal == nil || IsWindowAbove(g.HoveredWindow, modal))
		ClosePopupsOverWindow(hovered_window_above_modal ? g.HoveredWindow : modal, true)
	}
}

// This is called during NewFrame()->UpdateViewportsNewFrame() only.
// Need to keep in sync with SetWindowPos()
TranslateWindow :: proc(window : ^ImGuiWindow, delta : ImVec2)
{
	window.Pos += delta
	Translate(&window.ClipRect, delta)
	Translate(&window.OuterRectClipped, delta)
	Translate(&window.InnerRect, delta)
	window.DC.CursorPos += delta
	window.DC.CursorStartPos += delta
	window.DC.CursorMaxPos += delta
	window.DC.IdealMaxPos += delta
}

ScaleWindow :: proc(window : ^ImGuiWindow, scale : f32)
{
	origin : ImVec2 = window.Viewport.Pos
	window.Pos = ImFloor((window.Pos - origin) * scale + origin)
	window.Size = ImTrunc(window.Size * scale)
	window.SizeFull = ImTrunc(window.SizeFull * scale)
	window.ContentSize = ImTrunc(window.ContentSize * scale)
}

IsWindowActiveAndVisible :: proc(window : ^ImGuiWindow) -> bool
{
	return (window.Active) && (!window.Hidden)
}

// The reason this is exposed in imgui_internal.h is: on touch-based system that don't have hovering, we want to dispatch inputs to the right target (imgui vs imgui+app)
UpdateHoveredWindowAndCaptureFlags :: proc()
{
	g : ^ImGuiContext = GImGui
	io : ^ImGuiIO = &g.IO

	// FIXME-DPI: This storage was added on 2021/03/31 for test engine, but if we want to multiply WINDOWS_HOVER_PADDING
	// by DpiScale, we need to make this window-agnostic anyhow, maybe need storing inside ImGuiWindow.
	g.WindowsHoverPadding = ImMax(g.Style.TouchExtraPadding, ImVec2{WINDOWS_HOVER_PADDING, WINDOWS_HOVER_PADDING})

	// Find the window hovered by mouse:
	// - Child windows can extend beyond the limit of their parent so we need to derive HoveredRootWindow from HoveredWindow.
	// - When moving a window we can skip the search, which also conveniently bypasses the fact that window->WindowRectClipped is lagging as this point of the frame.
	// - We also support the moved window toggling the NoInputs flag after moving has started in order to be able to detect windows below it, which is useful for e.g. docking mechanisms.
	clear_hovered_windows : bool = false
	FindHoveredWindowEx(g.IO.MousePos, false, &g.HoveredWindow, &g.HoveredWindowUnderMovingWindow)
	IM_ASSERT(g.HoveredWindow == nil || g.HoveredWindow == g.MovingWindow || g.HoveredWindow.Viewport == g.MouseViewport)
	g.HoveredWindowBeforeClear = g.HoveredWindow

	// Modal windows prevents mouse from hovering behind them.
	modal_window : ^ImGuiWindow = GetTopMostPopupModal()
	if modal_window != nil && g.HoveredWindow != nil && !IsWindowWithinBeginStackOf(g.HoveredWindow.RootWindow, modal_window) {
		// FIXME-MERGE: RootWindowDockTree ?
		clear_hovered_windows = true
	}

	// Disabled mouse hovering (we don't currently clear MousePos, we could)
	if (io.ConfigFlags & ImGuiConfigFlags_.ImGuiConfigFlags_NoMouse) != {} { clear_hovered_windows = true }

	// We track click ownership. When clicked outside of a window the click is owned by the application and
	// won't report hovering nor request capture even while dragging over our windows afterward.
	has_open_popup : bool = (g.OpenPopupStack.Size > 0)
	has_open_modal : bool = (modal_window != nil)
	mouse_earliest_down : i32 = -1
	mouse_any_down : bool = false
	for i : i32 = 0; i < cast(i32)IM_ARRAYSIZE(io.MouseDown); i += 1 {
		if io.MouseClicked[i] {
			io.MouseDownOwned[i] = (g.HoveredWindow != nil) || has_open_popup
			io.MouseDownOwnedUnlessPopupClose[i] = (g.HoveredWindow != nil) || has_open_modal
		}
		mouse_any_down |= io.MouseDown[i]
		if io.MouseDown[i] || io.MouseReleased[i] {
			// Increase release frame for our evaluation of earliest button (#1392)
			if mouse_earliest_down == -1 || io.MouseClickedTime[i] < io.MouseClickedTime[mouse_earliest_down] { mouse_earliest_down = i }
		}
	}

	mouse_avail : bool = (mouse_earliest_down == -1) || io.MouseDownOwned[mouse_earliest_down]
	mouse_avail_unless_popup_close : bool = (mouse_earliest_down == -1) || io.MouseDownOwnedUnlessPopupClose[mouse_earliest_down]

	// If mouse was first clicked outside of ImGui bounds we also cancel out hovering.
	// FIXME: For patterns of drag and drop across OS windows, we may need to rework/remove this test (first committed 311c0ca9 on 2015/02)
	mouse_dragging_extern_payload : bool = g.DragDropActive && (g.DragDropSourceFlags & ImGuiDragDropFlags_.ImGuiDragDropFlags_SourceExtern) != {}
	if !mouse_avail && !mouse_dragging_extern_payload { clear_hovered_windows = true }

	if clear_hovered_windows { g.HoveredWindowUnderMovingWindow = nil; g.HoveredWindow = g.HoveredWindowUnderMovingWindow }

	// Update io.WantCaptureMouse for the user application (true = dispatch mouse info to Dear ImGui only, false = dispatch mouse to Dear ImGui + underlying app)
	// Update io.WantCaptureMouseAllowPopupClose (experimental) to give a chance for app to react to popup closure with a drag
	if g.WantCaptureMouseNextFrame != -1 {
		io.WantCaptureMouseUnlessPopupClose = (g.WantCaptureMouseNextFrame != 0); io.WantCaptureMouse = io.WantCaptureMouseUnlessPopupClose
	}
	else {
		io.WantCaptureMouse = (mouse_avail && (g.HoveredWindow != nil || mouse_any_down)) || has_open_popup
		io.WantCaptureMouseUnlessPopupClose = (mouse_avail_unless_popup_close && (g.HoveredWindow != nil || mouse_any_down)) || has_open_modal
	}

	// Update io.WantCaptureKeyboard for the user application (true = dispatch keyboard info to Dear ImGui only, false = dispatch keyboard info to Dear ImGui + underlying app)
	io.WantCaptureKeyboard = false
	if (io.ConfigFlags & ImGuiConfigFlags_.ImGuiConfigFlags_NoKeyboard) == {} {
		if (g.ActiveId != 0) || (modal_window != nil) { io.WantCaptureKeyboard = true }
		else if io.NavActive && (io.ConfigFlags & ImGuiConfigFlags_.ImGuiConfigFlags_NavEnableKeyboard) != {} && io.ConfigNavCaptureKeyboard { io.WantCaptureKeyboard = true }
	}
	if g.WantCaptureKeyboardNextFrame != -1 {
		// Manual override
		io.WantCaptureKeyboard = (g.WantCaptureKeyboardNextFrame != 0)
	}

	// Update io.WantTextInput flag, this is to allow systems without a keyboard (e.g. mobile, hand-held) to show a software keyboard if possible
	io.WantTextInput = (g.WantTextInputNextFrame != -1) ? (g.WantTextInputNextFrame != 0) : false
}

// Called once a frame. Followed by SetCurrentFont() which sets up the remaining data.
SetupDrawListSharedData :: proc()
{
	g : ^ImGuiContext = GImGui
	virtual_space : ImRect = {{FLT_MAX, FLT_MAX}, {-FLT_MAX, -FLT_MAX}}
	for viewport in g.Viewports.Data[:g.Viewports.Size] { Add(&virtual_space, GetMainRect(viewport)) }

	g.DrawListSharedData.ClipRectFullscreen = ToVec4(virtual_space)
	g.DrawListSharedData.CurveTessellationTol = g.Style.CurveTessellationTol
	SetCircleTessellationMaxError(&g.DrawListSharedData, g.Style.CircleTessellationMaxError)
	g.DrawListSharedData.InitialFlags = ImDrawListFlags_.ImDrawListFlags_None
	if g.Style.AntiAliasedLines { g.DrawListSharedData.InitialFlags |= ImDrawListFlags_.ImDrawListFlags_AntiAliasedLines }
	if g.Style.AntiAliasedLinesUseTex && (g.IO.Fonts.Flags & ImFontAtlasFlags_.ImFontAtlasFlags_NoBakedLines) == {} { g.DrawListSharedData.InitialFlags |= ImDrawListFlags_.ImDrawListFlags_AntiAliasedLinesUseTex }
	if g.Style.AntiAliasedFill { g.DrawListSharedData.InitialFlags |= ImDrawListFlags_.ImDrawListFlags_AntiAliasedFill }
	if (g.IO.BackendFlags & ImGuiBackendFlags_.ImGuiBackendFlags_RendererHasVtxOffset) != {} { g.DrawListSharedData.InitialFlags |= ImDrawListFlags_.ImDrawListFlags_AllowVtxOffset }
}

// start a new Dear ImGui frame, you can submit any command from this point until Render()/EndFrame().
NewFrame :: proc()
{
	IM_ASSERT(GImGui != nil, "No current context. Did you call ImGui::CreateContext() and ImGui::SetCurrentContext() ?")
	g : ^ImGuiContext = GImGui

	// Remove pending delete hooks before frame start.
	// This deferred removal avoid issues of removal while iterating the hook vector
	for n : i32 = g.Hooks.Size - 1; n >= 0; n -= 1 { if g.Hooks.Data[n].Type == ImGuiContextHookType.ImGuiContextHookType_PendingRemoval_ { erase(&g.Hooks, &g.Hooks.Data[n]) } }

	CallContextHooks(g, ImGuiContextHookType.ImGuiContextHookType_NewFramePre)

	// Check and assert for various common IO and Configuration mistakes
	g.ConfigFlagsLastFrame = g.ConfigFlagsCurrFrame
	ErrorCheckNewFrameSanityChecks()
	g.ConfigFlagsCurrFrame = g.IO.ConfigFlags

	// Load settings on first frame, save settings when modified (after a delay)
	UpdateSettings()

	g.Time += f64(g.IO.DeltaTime)
	g.WithinFrameScope = true
	g.FrameCount += 1
	g.TooltipOverrideCount = 0
	g.WindowsActiveCount = 0
	resize(&g.MenusIdSubmittedThisFrame, 0)

	// Calculate frame-rate for the user, as a purely luxurious feature
	g.FramerateSecPerFrameAccum += g.IO.DeltaTime - g.FramerateSecPerFrame[g.FramerateSecPerFrameIdx]
	g.FramerateSecPerFrame[g.FramerateSecPerFrameIdx] = g.IO.DeltaTime
	g.FramerateSecPerFrameIdx = (g.FramerateSecPerFrameIdx + 1) % cast(i32)IM_ARRAYSIZE(g.FramerateSecPerFrame)
	g.FramerateSecPerFrameCount = ImMin(g.FramerateSecPerFrameCount + 1, cast(i32)IM_ARRAYSIZE(g.FramerateSecPerFrame))
	g.IO.Framerate = (g.FramerateSecPerFrameAccum > 0.0) ? (1.0 / (g.FramerateSecPerFrameAccum / cast(f32) g.FramerateSecPerFrameCount)) : FLT_MAX

	// Process input queue (trickle as many events as possible), turn events into writes to IO structure
	resize(&g.InputEventsTrail, 0)
	UpdateInputEvents(g.IO.ConfigInputTrickleEventQueue)

	// Update viewports (after processing input queue, so io.MouseHoveredViewport is set)
	UpdateViewportsNewFrame()

	// Setup current font and draw list shared data
	// FIXME-VIEWPORT: the concept of a single ClipRectFullscreen is not ideal!
	g.IO.Fonts.Locked = true
	SetupDrawListSharedData()
	SetCurrentFont(GetDefaultFont())
	IM_ASSERT(IsLoaded(g.Font))

	// Mark rendering data as invalid to prevent user who may have a handle on it to use it.
	for viewport in g.Viewports.Data[:g.Viewports.Size] {
		viewport.DrawData = nil
		viewport.DrawDataP.Valid = false
	}

	// Drag and drop keep the source ID alive so even if the source disappear our state is consistent
	if g.DragDropActive && g.DragDropPayload.SourceId == g.ActiveId { KeepAliveID(g.DragDropPayload.SourceId) }

	// [DEBUG]
	if !g.IO.ConfigDebugHighlightIdConflicts || !g.IO.KeyCtrl {
		// Count is locked while holding CTRL
		g.DebugDrawIdConflicts = 0
	}
	if g.IO.ConfigDebugHighlightIdConflicts && g.HoveredIdPreviousFrameItemCount > 1 { g.DebugDrawIdConflicts = g.HoveredIdPreviousFrame }

	// Update HoveredId data
	if g.HoveredIdPreviousFrame == 0 { g.HoveredIdTimer = 0.0 }
	if g.HoveredIdPreviousFrame == 0 || (g.HoveredId != 0 && g.ActiveId == g.HoveredId) { g.HoveredIdNotActiveTimer = 0.0 }
	if g.HoveredId != 0 { g.HoveredIdTimer += g.IO.DeltaTime }
	if g.HoveredId != 0 && g.ActiveId != g.HoveredId { g.HoveredIdNotActiveTimer += g.IO.DeltaTime }
	g.HoveredIdPreviousFrame = g.HoveredId
	g.HoveredIdPreviousFrameItemCount = 0
	g.HoveredId = 0
	g.HoveredIdAllowOverlap = false
	g.HoveredIdIsDisabled = false

	// Clear ActiveID if the item is not alive anymore.
	// In 1.87, the common most call to KeepAliveID() was moved from GetID() to ItemAdd().
	// As a result, custom widget using ButtonBehavior() _without_ ItemAdd() need to call KeepAliveID() themselves.
	if g.ActiveId != 0 && g.ActiveIdIsAlive != g.ActiveId && g.ActiveIdPreviousFrame == g.ActiveId {
		IMGUI_DEBUG_LOG_ACTIVEID(g, "NewFrame(): ClearActiveID() because it isn't marked alive anymore!\n")
		ClearActiveID()
	}

	// Update ActiveId data (clear reference to active widget if the widget isn't alive anymore)
	if g.ActiveId != 0 { g.ActiveIdTimer += g.IO.DeltaTime }
	g.LastActiveIdTimer += g.IO.DeltaTime
	g.ActiveIdPreviousFrame = g.ActiveId
	g.ActiveIdPreviousFrameWindow = g.ActiveIdWindow
	g.ActiveIdPreviousFrameHasBeenEditedBefore = g.ActiveIdHasBeenEditedBefore
	g.ActiveIdIsAlive = 0
	g.ActiveIdHasBeenEditedThisFrame = false
	g.ActiveIdPreviousFrameIsAlive = false
	g.ActiveIdIsJustActivated = false
	if g.TempInputId != 0 && g.ActiveId != g.TempInputId { g.TempInputId = 0 }
	if g.ActiveId == 0 {
		g.ActiveIdUsingNavDirMask = 0x00
		g.ActiveIdUsingAllKeyboardKeys = false
	}

	// Record when we have been stationary as this state is preserved while over same item.
	// FIXME: The way this is expressed means user cannot alter HoverStationaryDelay during the frame to use varying values.
	// To allow this we should store HoverItemMaxStationaryTime+ID and perform the >= check in IsItemHovered() function.
	if g.HoverItemDelayId != 0 && g.MouseStationaryTimer >= g.Style.HoverStationaryDelay { g.HoverItemUnlockedStationaryId = g.HoverItemDelayId }
	else if g.HoverItemDelayId == 0 { g.HoverItemUnlockedStationaryId = 0 }
	if g.HoveredWindow != nil && g.MouseStationaryTimer >= g.Style.HoverStationaryDelay { g.HoverWindowUnlockedStationaryId = g.HoveredWindow.ID }
	else if g.HoveredWindow == nil { g.HoverWindowUnlockedStationaryId = 0 }

	// Update hover delay for IsItemHovered() with delays and tooltips
	g.HoverItemDelayIdPreviousFrame = g.HoverItemDelayId
	if g.HoverItemDelayId != 0 {
		g.HoverItemDelayTimer += g.IO.DeltaTime
		g.HoverItemDelayClearTimer = 0.0
		g.HoverItemDelayId = 0
	}
	else if g.HoverItemDelayTimer > 0.0 {
		// This gives a little bit of leeway before clearing the hover timer, allowing mouse to cross gaps
		// We could expose 0.25f as style.HoverClearDelay but I am not sure of the logic yet, this is particularly subtle.
		g.HoverItemDelayClearTimer += g.IO.DeltaTime
		if g.HoverItemDelayClearTimer >= ImMax(f32(0.25), g.IO.DeltaTime * 2.0) {
			// ~7 frames at 30 Hz + allow for low framerate
			// May want a decaying timer, in which case need to clamp at max first, based on max of caller last requested timer.
			g.HoverItemDelayClearTimer = 0.0; g.HoverItemDelayTimer = g.HoverItemDelayClearTimer
		}
	}

	// Drag and drop
	g.DragDropAcceptIdPrev = g.DragDropAcceptIdCurr
	g.DragDropAcceptIdCurr = 0
	g.DragDropAcceptIdCurrRectSurface = FLT_MAX
	g.DragDropWithinSource = false
	g.DragDropWithinTarget = false
	g.DragDropHoldJustPressedId = 0
	g.TooltipPreviousWindow = nil

	// Close popups on focus lost (currently wip/opt-in)
	//if (g.IO.AppFocusLost)
	//    ClosePopupsExceptModals();

	// Update keyboard input state
	UpdateKeyboardInputs()

	//IM_ASSERT(g.IO.KeyCtrl == IsKeyDown(ImGuiKey_LeftCtrl) || IsKeyDown(ImGuiKey_RightCtrl));
	//IM_ASSERT(g.IO.KeyShift == IsKeyDown(ImGuiKey_LeftShift) || IsKeyDown(ImGuiKey_RightShift));
	//IM_ASSERT(g.IO.KeyAlt == IsKeyDown(ImGuiKey_LeftAlt) || IsKeyDown(ImGuiKey_RightAlt));
	//IM_ASSERT(g.IO.KeySuper == IsKeyDown(ImGuiKey_LeftSuper) || IsKeyDown(ImGuiKey_RightSuper));

	// Update keyboard/gamepad navigation
	NavUpdate()

	// Update mouse input state
	UpdateMouseInputs()

	// Undocking
	// (needs to be before UpdateMouseMovingWindowNewFrame so the window is already offset and following the mouse on the detaching frame)
	DockContextNewFrameUpdateUndocking(g)

	// Mark all windows as not visible and compact unused memory.
	IM_ASSERT(g.WindowsFocusOrder.Size <= g.Windows.Size)
	memory_compact_start_time : f32 = (g.GcCompactAll || g.IO.ConfigMemoryCompactTimer < 0.0) ? FLT_MAX : cast(f32) g.Time - g.IO.ConfigMemoryCompactTimer
	for window in g.Windows.Data[:g.Windows.Size] {
		window.WasActive = window.Active
		window.Active = false
		window.WriteAccessed = false
		window.BeginCountPreviousFrame = window.BeginCount
		window.BeginCount = 0

		// Garbage collect transient buffers of recently unused windows
		if !window.WasActive && !window.MemoryCompacted && window.LastTimeActive < memory_compact_start_time { GcCompactTransientWindowBuffers(window) }
	}

	// Find hovered window
	// (needs to be before UpdateMouseMovingWindowNewFrame so we fill g.HoveredWindowUnderMovingWindow on the mouse release frame)
	// (currently needs to be done after the WasActive=Active loop and FindHoveredWindowEx uses ->Active)
	UpdateHoveredWindowAndCaptureFlags()

	// Handle user moving window with mouse (at the beginning of the frame to avoid input lag or sheering)
	UpdateMouseMovingWindowNewFrame()

	// Background darkening/whitening
	if GetTopMostPopupModal() != nil || (g.NavWindowingTarget != nil && g.NavWindowingHighlightAlpha > 0.0) { g.DimBgRatio = ImMin(g.DimBgRatio + g.IO.DeltaTime * 6.0, 1.0) }
	else { g.DimBgRatio = ImMax(g.DimBgRatio - g.IO.DeltaTime * 10.0, 0.0) }

	g.MouseCursor = ImGuiMouseCursor_.ImGuiMouseCursor_Arrow
	g.WantTextInputNextFrame = -1; g.WantCaptureKeyboardNextFrame = g.WantTextInputNextFrame; g.WantCaptureMouseNextFrame = g.WantCaptureKeyboardNextFrame

	// Platform IME data: reset for the frame
	g.PlatformImeDataPrev = g.PlatformImeData
	g.PlatformImeData.WantVisible = false

	// Mouse wheel scrolling, scale
	UpdateMouseWheel()

	// Garbage collect transient buffers of recently unused tables
	for i : i32 = 0; i < g.TablesLastTimeActive.Size; i += 1 { if g.TablesLastTimeActive.Data[i] >= 0.0 && g.TablesLastTimeActive.Data[i] < memory_compact_start_time { TableGcCompactTransientBuffers(GetByIndex(&g.Tables, i)) } }

	for &table_temp_data in g.TablesTempData.Data[:g.TablesTempData.Size] { if table_temp_data.LastTimeActive >= 0.0 && table_temp_data.LastTimeActive < memory_compact_start_time { TableGcCompactTransientBuffers(&table_temp_data) } }

	if g.GcCompactAll { GcCompactTransientMiscBuffers() }
	g.GcCompactAll = false

	// Closing the focused window restore focus to the first active root window in descending z-order
	if g.NavWindow != nil && !g.NavWindow.WasActive { FocusTopMostWindowUnderOne(nil, nil, nil, ImGuiFocusRequestFlags_.ImGuiFocusRequestFlags_RestoreFocusedChild) }

	// No window should be open at the beginning of the frame.
	// But in order to allow the user to call NewFrame() multiple times without calling Render(), we are doing an explicit clear.
	resize(&g.CurrentWindowStack, 0)
	resize(&g.BeginPopupStack, 0)
	resize(&g.ItemFlagsStack, 0)
	push_back(&g.ItemFlagsStack, ImGuiItemFlags_.ImGuiItemFlags_AutoClosePopups); // Default flags
	g.CurrentItemFlags = back(&g.ItemFlagsStack)^
	resize(&g.GroupStack, 0)

	// Docking
	DockContextNewFrameUpdateDocking(g)

	// [DEBUG] Update debug features
	when ! IMGUI_DISABLE_DEBUG_TOOLS { /* @gen ifndef */
	UpdateDebugToolItemPicker()
	UpdateDebugToolStackQueries()
	UpdateDebugToolFlashStyleColor()
	if g.DebugLocateFrames > 0 && pre_decr(&g.DebugLocateFrames) == 0 {
		g.DebugLocateId = 0
		g.DebugBreakInLocateId = false
	}
	if g.DebugLogAutoDisableFrames > 0 && pre_decr(&g.DebugLogAutoDisableFrames) == 0 {
		DebugLog("(Debug Log: Auto-disabled some ImGuiDebugLogFlags after 2 frames)\n")
		g.DebugLogFlags &= cast(ImGuiDebugLogFlags)~cast(i32)g.DebugLogAutoDisableFlags
		g.DebugLogAutoDisableFlags = ImGuiDebugLogFlags_.ImGuiDebugLogFlags_None
	}
	} // preproc endif

	// Create implicit/fallback window - which we will only render it if the user has added something to it.
	// We don't use "Debug" to avoid colliding with user trying to create a "Debug" window with custom flags.
	// This fallback is particularly important as it prevents ImGui:: calls from crashing.
	g.WithinFrameScopeWithImplicitWindow = true
	SetNextWindowSize(ImVec2{400, 400}, ImGuiCond_.ImGuiCond_FirstUseEver)
	Begin("Debug##Default")
	IM_ASSERT(g.CurrentWindow.IsFallbackWindow == true)

	// Store stack sizes
	g.ErrorCountCurrentFrame = 0
	ErrorRecoveryStoreState(&g.StackSizesInNewFrame)

	// [DEBUG] When io.ConfigDebugBeginReturnValue is set, we make Begin()/BeginChild() return false at different level of the window-stack,
	// allowing to validate correct Begin/End behavior in user code.
	when ! IMGUI_DISABLE_DEBUG_TOOLS { /* @gen ifndef */
	if g.IO.ConfigDebugBeginReturnValueLoop { g.DebugBeginReturnValueCullDepth = (g.DebugBeginReturnValueCullDepth == -1) ? 0 : ((g.DebugBeginReturnValueCullDepth + ((g.FrameCount % 4) == 0 ? 1 : 0)) % 10) }
	else { g.DebugBeginReturnValueCullDepth = -1 }
	} // preproc endif

	CallContextHooks(g, ImGuiContextHookType.ImGuiContextHookType_NewFramePost)
}

// FIXME: Add a more explicit sort order in the window structure.
ChildWindowComparer :: proc(a, b : ^ImGuiWindow) -> slice.Ordering
{
	if d := slice.Ordering(a.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_Popup) - slice.Ordering(b.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_Popup); d != slice.Ordering(0) { return d }
	if d := slice.Ordering(a.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_Tooltip) - slice.Ordering(b.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_Tooltip); d != slice.Ordering(0) { return d }
	return slice.Ordering(a.BeginOrderWithinParent - b.BeginOrderWithinParent)
}

AddWindowToSortBuffer :: proc(out_sorted_windows : ^ImVector(^ImGuiWindow), window : ^ImGuiWindow)
{
	push_back(out_sorted_windows, window)
	if window.Active {
		count : i32 = window.DC.ChildWindows.Size
		ImQsort(window.DC.ChildWindows.Data[:count], ChildWindowComparer)
		for i : i32 = 0; i < count; i += 1 {
			child : ^ImGuiWindow = window.DC.ChildWindows.Data[i]
			if child.Active { AddWindowToSortBuffer(out_sorted_windows, child) }
		}
	}
}

AddWindowToDrawData :: proc(window : ^ImGuiWindow, layer : i32)
{
	g : ^ImGuiContext = GImGui
	viewport : ^ImGuiViewportP = window.Viewport
	IM_ASSERT(viewport != nil)
	post_incr(&g.IO.MetricsRenderWindows)
	if window.DrawList._Splitter._Count > 1 {
		// Merge if user forgot to merge back. Also required in Docking branch for ImGuiWindowFlags_DockNodeHost windows.
		ChannelsMerge(window.DrawList)
	}
	AddDrawListToDrawDataEx(&viewport.DrawDataP, viewport.DrawDataBuilder.Layers[layer], window.DrawList)
	for child in window.DC.ChildWindows.Data[:window.DC.ChildWindows.Size] { if IsWindowActiveAndVisible(child) {
		// Clipped children may have been marked not active
		AddWindowToDrawData(child, layer)
	} }
}

GetWindowDisplayLayer :: #force_inline proc(window : ^ImGuiWindow) -> i32
{
	return (window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_Tooltip) != {} ? 1 : 0
}

// Layer is locked for the root window, however child windows may use a different viewport (e.g. extruding menu)
AddRootWindowToDrawData :: #force_inline proc(window : ^ImGuiWindow)
{
	AddWindowToDrawData(window, GetWindowDisplayLayer(window))
}

FlattenDrawDataIntoSingleLayer :: proc(builder : ^ImDrawDataBuilder)
{
	n : i32 = builder.Layers[0].Size
	full_size : i32 = n
	for i : i32 = 1; i < cast(i32)IM_ARRAYSIZE(builder.Layers); i += 1 { full_size += builder.Layers[i].Size }

	resize(builder.Layers[0], full_size)
	for layer_n : i32 = 1; layer_n < cast(i32)IM_ARRAYSIZE(builder.Layers); layer_n += 1 {
		layer : ^ImVector(^ImDrawList) = builder.Layers[layer_n]
		if empty(layer) { continue }
		memcpy(builder.Layers[0].Data[n:], layer.Data, cast(int)layer.Size * size_of(^ImDrawList))
		n += layer.Size
		resize(layer, 0)
	}
}

InitViewportDrawData :: proc(viewport : ^ImGuiViewportP)
{
	io : ^ImGuiIO = GetIO()
	draw_data : ^ImDrawData = &viewport.DrawDataP

	viewport.DrawData = draw_data; // Make publicly accessible
	viewport.DrawDataBuilder.Layers[0] = &draw_data.CmdLists
	viewport.DrawDataBuilder.Layers[1] = &viewport.DrawDataBuilder.LayerData1
	resize(viewport.DrawDataBuilder.Layers[0], 0)
	resize(viewport.DrawDataBuilder.Layers[1], 0)

	// When minimized, we report draw_data->DisplaySize as zero to be consistent with non-viewport mode,
	// and to allow applications/backends to easily skip rendering.
	// FIXME: Note that we however do NOT attempt to report "zero drawlist / vertices" into the ImDrawData structure.
	// This is because the work has been done already, and its wasted! We should fix that and add optimizations for
	// it earlier in the pipeline, rather than pretend to hide the data at the end of the pipeline.
	is_minimized : bool = (viewport.Flags & ImGuiViewportFlags_.ImGuiViewportFlags_IsMinimized) != {}

	draw_data.Valid = true
	draw_data.CmdListsCount = 0
	draw_data.TotalIdxCount = 0; draw_data.TotalVtxCount = draw_data.TotalIdxCount
	draw_data.DisplayPos = viewport.Pos
	draw_data.DisplaySize = is_minimized ? ImVec2{0.0, 0.0} : viewport.Size
	draw_data.FramebufferScale = io.DisplayFramebufferScale; // FIXME-VIEWPORT: This may vary on a per-monitor/viewport basis?
	draw_data.OwnerViewport = viewport
}

// Clipping
// - Mouse hovering is affected by ImGui::PushClipRect() calls, unlike direct calls to ImDrawList::PushClipRect() which are render only.
// Push a clipping rectangle for both ImGui logic (hit-testing etc.) and low-level ImDrawList rendering.
// - When using this function it is sane to ensure that float are perfectly rounded to integer values,
//   so that e.g. (int)(max.x-min.x) in user's render produce correct result.
// - If the code here changes, may need to update code of functions like NextColumn() and PushColumnClipRect():
//   some frequently called functions which to modify both channels and clipping simultaneously tend to use the
//   more specialized SetWindowClipRectBeforeSetChannel() to avoid extraneous updates of underlying ImDrawCmds.
// - This is analoguous to PushFont()/PopFont() in the sense that are a mixing a global stack and a window stack,
//   which in the case of ClipRect is not so problematic but tends to be more restrictive for fonts.
PushClipRect_ :: proc(clip_rect_min : ImVec2, clip_rect_max : ImVec2, intersect_with_current_clip_rect : bool)
{
	window : ^ImGuiWindow = GetCurrentWindow()
	ImDrawList_PushClipRect(window.DrawList, clip_rect_min, clip_rect_max, intersect_with_current_clip_rect)
	window.ClipRect = transmute(ImRect) back(&window.DrawList._ClipRectStack)^
}

PopClipRect_ :: proc()
{
	window : ^ImGuiWindow = GetCurrentWindow()
	ImDrawList_PopClipRect(window.DrawList)
	window.ClipRect = transmute(ImRect) back(&window.DrawList._ClipRectStack)^
}

FindFrontMostVisibleChildWindow :: proc(window : ^ImGuiWindow) -> ^ImGuiWindow
{
	for n : i32 = window.DC.ChildWindows.Size - 1; n >= 0; n -= 1 { if IsWindowActiveAndVisible(window.DC.ChildWindows.Data[n]) { return FindFrontMostVisibleChildWindow(window.DC.ChildWindows.Data[n]) } }

	return window
}

RenderDimmedBackgroundBehindWindow :: proc(window : ^ImGuiWindow, col : ImU32)
{
	if (col & IM_COL32_A_MASK) == 0 { return }

	viewport : ^ImGuiViewportP = window.Viewport
	viewport_rect : ImRect = GetMainRect(viewport)

	// Draw behind window by moving the draw command at the FRONT of the draw list
	{
	// Draw list have been trimmed already, hence the explicit recreation of a draw command if missing.
	// FIXME: This is creating complication, might be simpler if we could inject a drawlist in drawdata at a given position and not attempt to manipulate ImDrawCmd order.
	draw_list : ^ImDrawList = window.RootWindowDockTree.DrawList
	ChannelsMerge(draw_list)
	if draw_list.CmdBuffer.Size == 0 { AddDrawCmd(draw_list) }
	PushClipRect(draw_list, viewport_rect.Min - ImVec2{1, 1}, viewport_rect.Max + ImVec2{1, 1}, false); // FIXME: Need to stricty ensure ImDrawCmd are not merged (ElemCount==6 checks below will verify that)
	AddRectFilled(draw_list, viewport_rect.Min, viewport_rect.Max, col)
	cmd : ImDrawCmd = back(&draw_list.CmdBuffer)^
	IM_ASSERT(cmd.ElemCount == 6)
	pop_back(&draw_list.CmdBuffer)
	push_front(&draw_list.CmdBuffer, cmd)
	AddDrawCmd(draw_list); // We need to create a command as CmdBuffer.back().IdxOffset won't be correct if we append to same command.
	PopClipRect(draw_list)
	}

	// Draw over sibling docking nodes in a same docking tree
	if window.RootWindow.DockIsActive {
		draw_list : ^ImDrawList = FindFrontMostVisibleChildWindow(window.RootWindowDockTree).DrawList
		ChannelsMerge(draw_list)
		if draw_list.CmdBuffer.Size == 0 { AddDrawCmd(draw_list) }
		PushClipRect(draw_list, viewport_rect.Min, viewport_rect.Max, false)
		RenderRectFilledWithHole(draw_list, Rect(window.RootWindowDockTree), Rect(window.RootWindow), col, 0.0); // window->RootWindowDockTree->WindowRounding);
		PopClipRect(draw_list)
	}
}

FindBottomMostVisibleWindowWithinBeginStack :: proc(parent_window : ^ImGuiWindow) -> ^ImGuiWindow
{
	g : ^ImGuiContext = GImGui
	bottom_most_visible_window : ^ImGuiWindow = parent_window
	for i : i32 = FindWindowDisplayIndex(parent_window); i >= 0; i -= 1 {
		window : ^ImGuiWindow = g.Windows.Data[i]
		if (window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_ChildWindow) != {} { continue }
		if !IsWindowWithinBeginStackOf(window, parent_window) { break }
		if IsWindowActiveAndVisible(window) && GetWindowDisplayLayer(window) <= GetWindowDisplayLayer(parent_window) { bottom_most_visible_window = window }
	}

	return bottom_most_visible_window
}

// Important: AddWindowToDrawData() has not been called yet, meaning DockNodeHost windows needs a DrawList->ChannelsMerge() before usage.
// We call ChannelsMerge() lazily here at it is faster that doing a full iteration of g.Windows.Data[] prior to calling RenderDimmedBackgrounds().
RenderDimmedBackgrounds :: proc()
{
	g : ^ImGuiContext = GImGui
	modal_window : ^ImGuiWindow = GetTopMostAndVisiblePopupModal()
	if g.DimBgRatio <= 0.0 && g.NavWindowingHighlightAlpha <= 0.0 { return }
	dim_bg_for_modal : bool = (modal_window != nil)
	dim_bg_for_window_list : bool = (g.NavWindowingTargetAnim != nil && g.NavWindowingTargetAnim.Active)
	if !dim_bg_for_modal && !dim_bg_for_window_list { return }

	viewports_already_dimmed : [2]^ImGuiViewport = {nil, nil}
	if dim_bg_for_modal {
		// Draw dimming behind modal or a begin stack child, whichever comes first in draw order.
		dim_behind_window : ^ImGuiWindow = FindBottomMostVisibleWindowWithinBeginStack(modal_window)
		RenderDimmedBackgroundBehindWindow(dim_behind_window, GetColorU32(modal_window.DC.ModalDimBgColor, g.DimBgRatio))
		viewports_already_dimmed[0] = modal_window.Viewport
	}
	else if dim_bg_for_window_list {
		// Draw dimming behind CTRL+Tab target window and behind CTRL+Tab UI window
		RenderDimmedBackgroundBehindWindow(g.NavWindowingTargetAnim, GetColorU32(ImGuiCol_.ImGuiCol_NavWindowingDimBg, g.DimBgRatio))
		if g.NavWindowingListWindow != nil && g.NavWindowingListWindow.Viewport != nil && g.NavWindowingListWindow.Viewport != g.NavWindowingTargetAnim.Viewport { RenderDimmedBackgroundBehindWindow(g.NavWindowingListWindow, GetColorU32(ImGuiCol_.ImGuiCol_NavWindowingDimBg, g.DimBgRatio)) }
		viewports_already_dimmed[0] = g.NavWindowingTargetAnim.Viewport
		viewports_already_dimmed[1] = g.NavWindowingListWindow != nil ? g.NavWindowingListWindow.Viewport : nil

		// Draw border around CTRL+Tab target window
		window : ^ImGuiWindow = g.NavWindowingTargetAnim
		viewport : ^ImGuiViewport = window.Viewport
		distance : f32 = g.FontSize
		bb : ImRect = Rect(window)
		Expand(&bb, distance)
		if GetWidth(bb) >= viewport.Size.x && GetHeight(bb) >= viewport.Size.y {
			// If a window fits the entire viewport, adjust its highlight inward
			Expand(&bb, -distance - 1.0)
		}
		ChannelsMerge(window.DrawList)
		if window.DrawList.CmdBuffer.Size == 0 { AddDrawCmd(window.DrawList) }
		PushClipRect(window.DrawList, viewport.Pos, viewport.Pos + viewport.Size)
		AddRect(window.DrawList, bb.Min, bb.Max, GetColorU32(ImGuiCol_.ImGuiCol_NavWindowingHighlight, g.NavWindowingHighlightAlpha), window.WindowRounding, {}, 3.0)
		PopClipRect(window.DrawList)
	}

	// Draw dimming background on _other_ viewports than the ones our windows are in
	for viewport in g.Viewports.Data[:g.Viewports.Size] {
		if viewport == viewports_already_dimmed[0] || viewport == viewports_already_dimmed[1] { continue }
		if modal_window != nil && viewport.Window != nil && IsWindowAbove(viewport.Window, modal_window) { continue }
		draw_list : ^ImDrawList = GetForegroundDrawList(viewport)
		dim_bg_col : ImU32 = GetColorU32(dim_bg_for_modal ? ImGuiCol_.ImGuiCol_ModalWindowDimBg : ImGuiCol_.ImGuiCol_NavWindowingDimBg, g.DimBgRatio)
		AddRectFilled(draw_list, viewport.Pos, viewport.Pos + viewport.Size, dim_bg_col)
	}
}

// ends the Dear ImGui frame. automatically called by Render(). If you don't need to render data (skipping rendering) you may call EndFrame() without Render()... but you'll have wasted CPU already! If you don't need to render, better to not create any windows and not call NewFrame() at all!
// This is normally called by Render(). You may want to call it directly if you want to avoid calling Render() but the gain will be very minimal.
EndFrame :: proc()
{
	g : ^ImGuiContext = GImGui
	IM_ASSERT(g.Initialized)

	// Don't process EndFrame() multiple times.
	if g.FrameCountEnded == g.FrameCount { return }
	IM_ASSERT(g.WithinFrameScope, "Forgot to call ImGui::NewFrame()?")

	CallContextHooks(g, ImGuiContextHookType.ImGuiContextHookType_EndFramePre)

	// [EXPERIMENTAL] Recover from errors
	if g.IO.ConfigErrorRecovery { ErrorRecoveryTryToRecoverState(&g.StackSizesInNewFrame) }
	ErrorCheckEndFrameSanityChecks()
	ErrorCheckEndFrameFinalizeErrorTooltip()

	// Notify Platform/OS when our Input Method Editor cursor has moved (e.g. CJK inputs using Microsoft IME)
	ime_data : ^ImGuiPlatformImeData = &g.PlatformImeData
	if g.PlatformIO.Platform_SetImeDataFn != nil && memcmp(ime_data, &g.PlatformImeDataPrev, size_of(ImGuiPlatformImeData)) != 0 {
		viewport : ^ImGuiViewport = FindViewportByID(g.PlatformImeViewport)
		IMGUI_DEBUG_LOG_IO(g, "[io] Calling Platform_SetImeDataFn(): WantVisible: %d, InputPos (%.2f,%.2f)\n", ime_data.WantVisible, ime_data.InputPos.x, ime_data.InputPos.y)
		if viewport == nil { viewport = GetMainViewport() }
		g.PlatformIO.Platform_SetImeDataFn(g, viewport, ime_data)
	}

	// Hide implicit/fallback "Debug" window if it hasn't been used
	g.WithinFrameScopeWithImplicitWindow = false
	if g.CurrentWindow != nil && !g.CurrentWindow.WriteAccessed { g.CurrentWindow.Active = false }
	End()

	// Update navigation: CTRL+Tab, wrap-around requests
	NavEndFrame()

	// Update docking
	DockContextEndFrame(g)

	SetCurrentViewport(nil, nil)

	// Drag and Drop: Elapse payload (if delivered, or if source stops being submitted)
	if g.DragDropActive {
		is_delivered : bool = g.DragDropPayload.Delivery
		is_elapsed : bool = (g.DragDropSourceFrameCount + 1 < g.FrameCount) && ((g.DragDropSourceFlags & ImGuiDragDropFlags_.ImGuiDragDropFlags_PayloadAutoExpire) != {} || g.DragDropMouseButton == ImGuiMouseButton(-1) || !IsMouseDown(g.DragDropMouseButton))
		if is_delivered || is_elapsed { ClearDragDrop() }
	}

	// Drag and Drop: Fallback for missing source tooltip. This is not ideal but better than nothing.
	// If you want to handle source item disappearing: instead of submitting your description tooltip
	// in the BeginDragDropSource() block of the dragged item, you can submit them from a safe single spot
	// (e.g. end of your item loop, or before EndFrame) by reading payload data.
	// In the typical case, the contents of drag tooltip should be possible to infer solely from payload data.
	if g.DragDropActive && g.DragDropSourceFrameCount + 1 < g.FrameCount && (g.DragDropSourceFlags & ImGuiDragDropFlags_.ImGuiDragDropFlags_SourceNoPreviewTooltip) == {} {
		g.DragDropWithinSource = true
		SetTooltip("...")
		g.DragDropWithinSource = false
	}

	// End frame
	g.WithinFrameScope = false
	g.FrameCountEnded = g.FrameCount

	// Initiate moving window + handle left-click and right-click focus
	UpdateMouseMovingWindowEndFrame()

	// Update user-facing viewport list (g.Viewports -> g.PlatformIO.Viewports after filtering out some)
	UpdateViewportsEndFrame()

	// Sort the window list so that all child windows are after their parent
	// We cannot do that on FocusWindow() because children may not exist yet
	resize(&g.WindowsTempSortBuffer, 0)
	reserve(&g.WindowsTempSortBuffer, g.Windows.Size)
	for window in g.Windows.Data[:g.Windows.Size] {
		if window.Active && (window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_ChildWindow) != {} {
			// if a child is active its parent will add it
			continue
		}
		AddWindowToSortBuffer(&g.WindowsTempSortBuffer, window)
	}

	// This usually assert if there is a mismatch between the ImGuiWindowFlags_ChildWindow / ParentWindow values and DC.ChildWindows.Data[] in parents, aka we've done something wrong.
	IM_ASSERT(g.Windows.Size == g.WindowsTempSortBuffer.Size)
	swap(&g.Windows, &g.WindowsTempSortBuffer)
	g.IO.MetricsActiveWindows = g.WindowsActiveCount

	// Unlock font atlas
	g.IO.Fonts.Locked = false

	// Clear Input data for next frame
	g.IO.MousePosPrev = g.IO.MousePos
	g.IO.AppFocusLost = false
	g.IO.MouseWheelH = 0.0; g.IO.MouseWheel = g.IO.MouseWheelH
	resize(&g.IO.InputQueueCharacters, 0)

	CallContextHooks(g, ImGuiContextHookType.ImGuiContextHookType_EndFramePost)
}

// ends the Dear ImGui frame, finalize the draw data. You can then get call GetDrawData().
// Prepare the data for rendering so you can call GetDrawData()
// (As with anything within the ImGui:: namspace this doesn't touch your GPU or graphics API at all:
// it is the role of the ImGui_ImplXXXX_RenderDrawData() function provided by the renderer backend)
Render :: proc()
{
	g : ^ImGuiContext = GImGui
	IM_ASSERT(g.Initialized)

	if g.FrameCountEnded != g.FrameCount { EndFrame() }
	if g.FrameCountRendered == g.FrameCount { return }
	g.FrameCountRendered = g.FrameCount

	g.IO.MetricsRenderWindows = 0
	CallContextHooks(g, ImGuiContextHookType.ImGuiContextHookType_RenderPre)

	// Add background ImDrawList (for each active viewport)
	for viewport in g.Viewports.Data[:g.Viewports.Size] {
		InitViewportDrawData(viewport)
		if viewport.BgFgDrawLists[0] != nil { AddDrawListToDrawDataEx(&viewport.DrawDataP, viewport.DrawDataBuilder.Layers[0], GetBackgroundDrawList(viewport)) }
	}

	// Draw modal/window whitening backgrounds
	RenderDimmedBackgrounds()

	// Add ImDrawList to render
	windows_to_render_top_most : [2]^ImGuiWindow
	windows_to_render_top_most[0] = (g.NavWindowingTarget != nil && (g.NavWindowingTarget.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoBringToFrontOnFocus) == {}) ? g.NavWindowingTarget.RootWindowDockTree : nil
	windows_to_render_top_most[1] = (g.NavWindowingTarget != nil ? g.NavWindowingListWindow : nil)
	for window in g.Windows.Data[:g.Windows.Size] {
		if IsWindowActiveAndVisible(window) && (window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_ChildWindow) == {} && window != windows_to_render_top_most[0] && window != windows_to_render_top_most[1] { AddRootWindowToDrawData(window) }
	}

	for n : i32 = 0; n < cast(i32)IM_ARRAYSIZE(windows_to_render_top_most); n += 1 { if windows_to_render_top_most[n] != nil && IsWindowActiveAndVisible(windows_to_render_top_most[n]) {
	// NavWindowingTarget is always temporarily displayed as the top-most window
		AddRootWindowToDrawData(windows_to_render_top_most[n])
	} }

	// Draw software mouse cursor if requested by io.MouseDrawCursor flag
	if g.IO.MouseDrawCursor && g.MouseCursor != ImGuiMouseCursor_.ImGuiMouseCursor_None { RenderMouseCursor(g.IO.MousePos, g.Style.MouseCursorScale, g.MouseCursor, IM_COL32_WHITE, IM_COL32_BLACK, IM_COL32(0, 0, 0, 48)) }

	// Setup ImDrawData structures for end-user
	g.IO.MetricsRenderIndices = 0; g.IO.MetricsRenderVertices = g.IO.MetricsRenderIndices
	for viewport in g.Viewports.Data[:g.Viewports.Size] {
		FlattenDrawDataIntoSingleLayer(&viewport.DrawDataBuilder)

		// Add foreground ImDrawList (for each active viewport)
		if viewport.BgFgDrawLists[1] != nil { AddDrawListToDrawDataEx(&viewport.DrawDataP, viewport.DrawDataBuilder.Layers[0], GetForegroundDrawList(viewport)) }

		// We call _PopUnusedDrawCmd() last thing, as RenderDimmedBackgrounds() rely on a valid command being there (especially in docking branch).
		draw_data : ^ImDrawData = &viewport.DrawDataP
		IM_ASSERT(draw_data.CmdLists.Size == draw_data.CmdListsCount)
		for draw_list in draw_data.CmdLists.Data[:draw_data.CmdLists.Size] { _PopUnusedDrawCmd(draw_list) }

		g.IO.MetricsRenderVertices += draw_data.TotalVtxCount
		g.IO.MetricsRenderIndices += draw_data.TotalIdxCount
	}

	CallContextHooks(g, ImGuiContextHookType.ImGuiContextHookType_RenderPost)
}

// Text Utilities
// Calculate text size. Text can be multi-line. Optionally ignore text after a ## marker.
// CalcTextSize("") should return ImVec2{0.0f, g.FontSize}
CalcTextSize :: proc(text : string, hide_text_after_double_hash : bool = false, wrap_width : f32 = -1) -> ImVec2
{
	g : ^ImGuiContext = GImGui

	text_display_end := len(text)
	if hide_text_after_double_hash {
		// Hide anything after a '##' string
		text_display_end = FindRenderedTextEnd(text)
	}

	font : ^ImFont = g.Font
	font_size : f32 = g.FontSize
	if len(text) == 0 { return ImVec2{0.0, font_size} }
	text_size : ImVec2 = CalcTextSizeA(font, font_size, FLT_MAX, wrap_width, raw_data(text), &raw_data(text)[text_display_end], nil)

	// Round
	// FIXME: This has been here since Dec 2015 (7b0bf230) but down the line we want this out.
	// FIXME: Investigate using ceilf or e.g.
	// - https://git.musl-libc.org/cgit/musl/tree/src/math/ceilf.c
	// - https://embarkstudios.github.io/rust-gpu/api/src/libm/math/ceilf.rs.html
	text_size.x = IM_TRUNC(text_size.x + 0.99999)

	return text_size
}

// Find window given position, search front-to-back
// - Typically write output back to g.HoveredWindow and g.HoveredWindowUnderMovingWindow.
// - FIXME: Note that we have an inconsequential lag here: OuterRectClipped is updated in Begin(), so windows moved programmatically
//   with SetWindowPos() and not SetNextWindowPos() will have that rectangle lagging by a frame at the time FindHoveredWindow() is
//   called, aka before the next Begin(). Moving window isn't affected.
// - The 'find_first_and_in_any_viewport = true' mode is only used by TestEngine. It is simpler to maintain here.
FindHoveredWindowEx :: proc(pos : ImVec2, find_first_and_in_any_viewport : bool, out_hovered_window : ^^ImGuiWindow, out_hovered_window_under_moving_window : ^^ImGuiWindow)
{
	g : ^ImGuiContext = GImGui
	hovered_window : ^ImGuiWindow = nil
	hovered_window_under_moving_window : ^ImGuiWindow = nil

	// Special handling for the window being moved: Ignore the mouse viewport check (because it may reset/lose its viewport during the undocking frame)
	backup_moving_window_viewport : ^ImGuiViewportP = nil
	if find_first_and_in_any_viewport == false && g.MovingWindow != nil {
		backup_moving_window_viewport = g.MovingWindow.Viewport
		g.MovingWindow.Viewport = g.MouseViewport
		if (g.MovingWindow.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoMouseInputs) == {} { hovered_window = g.MovingWindow }
	}

	padding_regular : ImVec2 = g.Style.TouchExtraPadding
	padding_for_resize : ImVec2 = g.IO.ConfigWindowsResizeFromEdges ? g.WindowsHoverPadding : padding_regular
	for i : i32 = g.Windows.Size - 1; i >= 0; i -= 1 {
		window : ^ImGuiWindow = g.Windows.Data[i]
		if !window.WasActive || window.Hidden { continue }
		if (window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoMouseInputs) != {} { continue }
		IM_ASSERT(window.Viewport != nil)
		if window.Viewport != g.MouseViewport { continue }

		// Using the clipped AABB, a child window will typically be clipped by its parent (not always)
		hit_padding : ImVec2 = (window.Flags & (ImGuiWindowFlags_.ImGuiWindowFlags_NoResize | ImGuiWindowFlags_.ImGuiWindowFlags_AlwaysAutoResize)) != {} ? padding_regular : padding_for_resize
		if !ContainsWithPad(window.OuterRectClipped, pos, hit_padding) { continue }

		// Support for one rectangular hole in any given window
		// FIXME: Consider generalizing hit-testing override (with more generic data, callback, etc.) (#1512)
		if window.HitTestHoleSize.x != 0 {
			hole_pos := ImVec2{ window.Pos.x + cast(f32) window.HitTestHoleOffset.x, window.Pos.y + cast(f32) window.HitTestHoleOffset.y }
			hole_size := ImVec2{ cast(f32) window.HitTestHoleSize.x, cast(f32) window.HitTestHoleSize.y }
			if Contains(ImRect{hole_pos, hole_pos + hole_size}, pos) { continue }
		}

		if find_first_and_in_any_viewport {
			hovered_window = window
			break
		}
		else {
			if hovered_window == nil { hovered_window = window }
			if hovered_window_under_moving_window == nil && (g.MovingWindow == nil || window.RootWindowDockTree != g.MovingWindow.RootWindowDockTree) { hovered_window_under_moving_window = window }
			if hovered_window != nil && hovered_window_under_moving_window != nil { break }
		}
	}

	out_hovered_window^ = hovered_window
	if out_hovered_window_under_moving_window != nil { out_hovered_window_under_moving_window^ = hovered_window_under_moving_window }
	if find_first_and_in_any_viewport == false && g.MovingWindow != nil { g.MovingWindow.Viewport = backup_moving_window_viewport }
}

// is the last item active? (e.g. button being held, text field being edited. This will continuously return true while holding mouse button on an item. Items that don't interact will always return false)
IsItemActive :: proc() -> bool
{
	g : ^ImGuiContext = GImGui
	if g.ActiveId != 0 { return g.ActiveId == g.LastItemData.ID }
	return false
}

// was the last item just made active (item was previously inactive).
IsItemActivated :: proc() -> bool
{
	g : ^ImGuiContext = GImGui
	if g.ActiveId != 0 { if g.ActiveId == g.LastItemData.ID && g.ActiveIdPreviousFrame != g.LastItemData.ID { return true } }
	return false
}

// was the last item just made inactive (item was previously active). Useful for Undo/Redo patterns with widgets that require continuous editing.
IsItemDeactivated :: proc() -> bool
{
	g : ^ImGuiContext = GImGui
	if (g.LastItemData.StatusFlags & ImGuiItemStatusFlags_.ImGuiItemStatusFlags_HasDeactivated) != {} { return (g.LastItemData.StatusFlags & ImGuiItemStatusFlags_.ImGuiItemStatusFlags_Deactivated) != {} }
	return (g.ActiveIdPreviousFrame == g.LastItemData.ID && g.ActiveIdPreviousFrame != 0 && g.ActiveId != g.LastItemData.ID)
}

// was the last item just made inactive and made a value change when it was active? (e.g. Slider/Drag moved). Useful for Undo/Redo patterns with widgets that require continuous editing. Note that you may get false positives (some widgets such as Combo()/ListBox()/Selectable() will return true even when clicking an already selected item).
IsItemDeactivatedAfterEdit :: proc() -> bool
{
	g : ^ImGuiContext = GImGui
	return IsItemDeactivated() && (g.ActiveIdPreviousFrameHasBeenEditedBefore || (g.ActiveId == 0 && g.ActiveIdHasBeenEditedBefore))
}

// is the last item focused for keyboard/gamepad navigation?
// == (GetItemID() == GetFocusID() && GetFocusID() != 0)
IsItemFocused :: proc() -> bool
{
	g : ^ImGuiContext = GImGui
	if g.NavId != g.LastItemData.ID || g.NavId == 0 { return false }

	// Special handling for the dummy item after Begin() which represent the title bar or tab.
	// When the window is collapsed (SkipItems==true) that last item will never be overwritten so we need to detect the case.
	window : ^ImGuiWindow = g.CurrentWindow
	if g.LastItemData.ID == window.ID && window.WriteAccessed { return false }

	return true
}

// is the last item hovered and mouse clicked on? (**)  == IsMouseClicked(mouse_button) && IsItemHovered()Important. (**) this is NOT equivalent to the behavior of e.g. Button(). Read comments in function definition.
// Important: this can be useful but it is NOT equivalent to the behavior of e.g.Button()!
// Most widgets have specific reactions based on mouse-up/down state, mouse position etc.
IsItemClicked :: proc(mouse_button : ImGuiMouseButton) -> bool
{
	return IsMouseClicked(mouse_button) && IsItemHovered(ImGuiHoveredFlags_.ImGuiHoveredFlags_None)
}

// was the last item open state toggled? set by TreeNode().
IsItemToggledOpen :: proc() -> bool
{
	g : ^ImGuiContext = GImGui
	return (g.LastItemData.StatusFlags & ImGuiItemStatusFlags_.ImGuiItemStatusFlags_ToggledOpen) != {} ? true : false
}

// Was the last item selection state toggled? Useful if you need the per-item information _before_ reaching EndMultiSelect(). We only returns toggle _event_ in order to handle clipping correctly.
// Call after a Selectable() or TreeNode() involved in multi-selection.
// Useful if you need the per-item information before reaching EndMultiSelect(), e.g. for rendering purpose.
// This is only meant to be called inside a BeginMultiSelect()/EndMultiSelect() block.
// (Outside of multi-select, it would be misleading/ambiguous to report this signal, as widgets
// return e.g. a pressed event and user code is in charge of altering selection in ways we cannot predict.)
IsItemToggledSelection :: proc() -> bool
{
	g : ^ImGuiContext = GImGui
	IM_ASSERT(g.CurrentMultiSelect != nil); // Can only be used inside a BeginMultiSelect()/EndMultiSelect()
	return (g.LastItemData.StatusFlags & ImGuiItemStatusFlags_.ImGuiItemStatusFlags_ToggledSelection) != {} ? true : false
}

// is any item hovered?
// IMPORTANT: If you are trying to check whether your mouse should be dispatched to Dear ImGui or to your underlying app,
// you should not use this function! Use the 'io.WantCaptureMouse' boolean for that!
// Refer to FAQ entry "How can I tell whether to dispatch mouse/keyboard to Dear ImGui or my application?" for details.
IsAnyItemHovered :: proc() -> bool
{
	g : ^ImGuiContext = GImGui
	return g.HoveredId != 0 || g.HoveredIdPreviousFrame != 0
}

// is any item active?
IsAnyItemActive :: proc() -> bool
{
	g : ^ImGuiContext = GImGui
	return g.ActiveId != 0
}

// is any item focused?
IsAnyItemFocused :: proc() -> bool
{
	g : ^ImGuiContext = GImGui
	return g.NavId != 0 && g.NavCursorVisible
}

// is the last item visible? (items may be out of sight because of clipping/scrolling)
IsItemVisible :: proc() -> bool
{
	g : ^ImGuiContext = GImGui
	return (g.LastItemData.StatusFlags & ImGuiItemStatusFlags_.ImGuiItemStatusFlags_Visible) != {}
}

// did the last item modify its underlying value this frame? or was pressed? This is generally the same as the "bool" return value of many widgets.
IsItemEdited :: proc() -> bool
{
	g : ^ImGuiContext = GImGui
	return (g.LastItemData.StatusFlags & ImGuiItemStatusFlags_.ImGuiItemStatusFlags_Edited) != {}
}

// Overlapping mode
// allow next item to be overlapped by a subsequent item. Useful with invisible buttons, selectable, treenode covering an area where subsequent items may need to be added. Note that both Selectable() and TreeNode() have dedicated flags doing this.
// Allow next item to be overlapped by subsequent items.
// This works by requiring HoveredId to match for two subsequent frames,
// so if a following items overwrite it our interactions will naturally be disabled.
SetNextItemAllowOverlap :: proc()
{
	g : ^ImGuiContext = GImGui
	g.NextItemData.ItemFlags |= cast(ImGuiItemFlags) ImGuiItemFlagsPrivate_.ImGuiItemFlags_AllowOverlap
}

// This is a shortcut for not taking ownership of 100+ keys, frequently used by drag operations.
// FIXME: It might be undesirable that this will likely disable KeyOwner-aware shortcuts systems. Consider a more fine-tuned version if needed?
SetActiveIdUsingAllKeyboardKeys :: proc()
{
	g : ^ImGuiContext = GImGui
	IM_ASSERT(g.ActiveId != 0)
	g.ActiveIdUsingNavDirMask = (1 << cast(u32) ImGuiDir.ImGuiDir_COUNT) - 1
	g.ActiveIdUsingAllKeyboardKeys = true
	NavMoveRequestCancel()
}

// get ID of last item (~~ often same ImGui::GetID(label) beforehand)
GetItemID :: proc() -> ImGuiID
{
	g : ^ImGuiContext = GImGui
	return g.LastItemData.ID
}

// get upper-left bounding rectangle of the last item (screen space)
GetItemRectMin :: proc() -> ImVec2
{
	g : ^ImGuiContext = GImGui
	return g.LastItemData.Rect.Min
}

// get lower-right bounding rectangle of the last item (screen space)
GetItemRectMax :: proc() -> ImVec2
{
	g : ^ImGuiContext = GImGui
	return g.LastItemData.Rect.Max
}

// get size of last item
GetItemRectSize :: proc() -> ImVec2
{
	g : ^ImGuiContext = GImGui
	return GetSize(g.LastItemData.Rect)
}

// Child Windows
// - Use child windows to begin into a self-contained independent scrolling/clipping regions within a host window. Child windows can embed their own child.
// - Before 1.90 (November 2023), the "ImGuiChildFlags child_Flags = {}" parameter was "bool border = false".
//   This API is backward compatible with old code, as we guarantee that ImGuiChildFlags_Borders == true.
//   Consider updating your old code:
//      BeginChild("Name", size, false)   -> Begin("Name", size, 0); or Begin("Name", size, ImGuiChildFlags_None);
//      BeginChild("Name", size, true)    -> Begin("Name", size, ImGuiChildFlags_Borders);
// - Manual sizing (each axis can use a different setting e.g. ImVec2{0.0f, 400.0f}):
//     == 0.0f: use remaining parent window size for this axis.
//      > 0.0f: use specified size for this axis.
//      < 0.0f: right/bottom-align to specified distance from available content boundaries.
// - Specifying ImGuiChildFlags_AutoResizeX or ImGuiChildFlags_AutoResizeY makes the sizing automatic based on child contents.
//   Combining both ImGuiChildFlags_AutoResizeX _and_ ImGuiChildFlags_AutoResizeY defeats purpose of a scrolling region and is NOT recommended.
// - BeginChild() returns false to indicate the window is collapsed or fully clipped, so you may early out and omit submitting
//   anything to the window. Always call a matching EndChild() for each BeginChild() call, regardless of its return value.
//   [Important: due to legacy reason, Begin/End and BeginChild/EndChild are inconsistent with all other functions
//    such as BeginMenu/EndMenu, BeginPopup/EndPopup, etc. where the EndXXX call should only be called if the corresponding
//    BeginXXX function returned true. Begin and BeginChild are the only odd ones out. Will be fixed in a future update.]
// Prior to v1.90 2023/10/16, the BeginChild() function took a 'bool border = false' parameter instead of 'ImGuiChildFlags child_Flags = {}'.
// ImGuiChildFlags_Borders is defined as always == 1 in order to allow old code passing 'true'. Read comments in imgui.h for details!
BeginChild_0 :: proc(str_id : string, size_arg : ImVec2 = {}, child_flags : ImGuiChildFlags = {}, window_flags : ImGuiWindowFlags = {}) -> bool
{
	id : ImGuiID = GetID(GetCurrentWindow(), str_id)
	return BeginChildEx(str_id, id, size_arg, child_flags, window_flags)
}

BeginChild_1 :: proc(id : ImGuiID, size_arg : ImVec2 = {}, child_flags : ImGuiChildFlags = {}, window_flags : ImGuiWindowFlags = {}) -> bool
{
	return BeginChildEx("", id, size_arg, child_flags, window_flags)
}

// Childs
BeginChildEx :: proc(name : string, id : ImGuiID, size_arg : ImVec2, child_flags : ImGuiChildFlags, window_flags : ImGuiWindowFlags) -> bool
{
	g : ^ImGuiContext = GImGui
	parent_window : ^ImGuiWindow = g.CurrentWindow
	IM_ASSERT(id != 0)

	// Sanity check as it is likely that some user will accidentally pass ImGuiWindowFlags into the ImGuiChildFlags argument.
	ImGuiChildFlags_SupportedMask_ : ImGuiChildFlags = ImGuiChildFlags_.ImGuiChildFlags_Borders | ImGuiChildFlags_.ImGuiChildFlags_AlwaysUseWindowPadding | ImGuiChildFlags_.ImGuiChildFlags_ResizeX | ImGuiChildFlags_.ImGuiChildFlags_ResizeY | ImGuiChildFlags_.ImGuiChildFlags_AutoResizeX | ImGuiChildFlags_.ImGuiChildFlags_AutoResizeY | ImGuiChildFlags_.ImGuiChildFlags_AlwaysAutoResize | ImGuiChildFlags_.ImGuiChildFlags_FrameStyle | ImGuiChildFlags_.ImGuiChildFlags_NavFlattened
	IM_UNUSED(ImGuiChildFlags_SupportedMask_)
	IM_ASSERT((child_flags & cast(ImGuiChildFlags)~cast(i32)ImGuiChildFlags_SupportedMask_) == {}, "Illegal ImGuiChildFlags value. Did you pass ImGuiWindowFlags values instead of ImGuiChildFlags?")
	IM_ASSERT((window_flags & ImGuiWindowFlags_.ImGuiWindowFlags_AlwaysAutoResize) == {}, "Cannot specify ImGuiWindowFlags_AlwaysAutoResize for BeginChild(). Use ImGuiChildFlags_AlwaysAutoResize!")
	if (child_flags & ImGuiChildFlags_.ImGuiChildFlags_AlwaysAutoResize) != {} {
		IM_ASSERT((child_flags & (ImGuiChildFlags_.ImGuiChildFlags_ResizeX | ImGuiChildFlags_.ImGuiChildFlags_ResizeY)) == {}, "Cannot use ImGuiChildFlags_ResizeX or ImGuiChildFlags_ResizeY with ImGuiChildFlags_AlwaysAutoResize!")
		IM_ASSERT((child_flags & (ImGuiChildFlags_.ImGuiChildFlags_AutoResizeX | ImGuiChildFlags_.ImGuiChildFlags_AutoResizeY)) != {}, "Must use ImGuiChildFlags_AutoResizeX or ImGuiChildFlags_AutoResizeY with ImGuiChildFlags_AlwaysAutoResize!")
	}

	child_flags, window_flags := child_flags, window_flags

	if (child_flags & ImGuiChildFlags_.ImGuiChildFlags_AutoResizeX) != {} { child_flags &= cast(ImGuiChildFlags)~cast(i32)ImGuiChildFlags_.ImGuiChildFlags_ResizeX }
	if (child_flags & ImGuiChildFlags_.ImGuiChildFlags_AutoResizeY) != {} { child_flags &= cast(ImGuiChildFlags)~cast(i32)ImGuiChildFlags_.ImGuiChildFlags_ResizeY }

	// Set window flags
	window_flags |= ImGuiWindowFlags_.ImGuiWindowFlags_ChildWindow | ImGuiWindowFlags_.ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_.ImGuiWindowFlags_NoDocking
	window_flags |= (parent_window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoMove); // Inherit the NoMove flag
	if (child_flags & (ImGuiChildFlags_.ImGuiChildFlags_AutoResizeX | ImGuiChildFlags_.ImGuiChildFlags_AutoResizeY | ImGuiChildFlags_.ImGuiChildFlags_AlwaysAutoResize)) != {} { window_flags |= ImGuiWindowFlags_.ImGuiWindowFlags_AlwaysAutoResize }
	if (child_flags & (ImGuiChildFlags_.ImGuiChildFlags_ResizeX | ImGuiChildFlags_.ImGuiChildFlags_ResizeY)) == {} { window_flags |= ImGuiWindowFlags_.ImGuiWindowFlags_NoResize | ImGuiWindowFlags_.ImGuiWindowFlags_NoSavedSettings }

	// Special framed style
	if (child_flags & ImGuiChildFlags_.ImGuiChildFlags_FrameStyle) != {} {
		PushStyleColor(ImGuiCol_.ImGuiCol_ChildBg, g.Style.Colors[ImGuiCol_.ImGuiCol_FrameBg])
		PushStyleVar(ImGuiStyleVar_.ImGuiStyleVar_ChildRounding, g.Style.FrameRounding)
		PushStyleVar(ImGuiStyleVar_.ImGuiStyleVar_ChildBorderSize, g.Style.FrameBorderSize)
		PushStyleVar(ImGuiStyleVar_.ImGuiStyleVar_WindowPadding, g.Style.FramePadding)
		child_flags |= ImGuiChildFlags_.ImGuiChildFlags_Borders | ImGuiChildFlags_.ImGuiChildFlags_AlwaysUseWindowPadding
		window_flags |= ImGuiWindowFlags_.ImGuiWindowFlags_NoMove
	}

	// Forward size
	// Important: Begin() has special processing to switch condition to ImGuiCond_FirstUseEver for a given axis when ImGuiChildFlags_ResizeXXX is set.
	// (the alternative would to store conditional flags per axis, which is possible but more code)
	size_avail : ImVec2 = GetContentRegionAvail()
	size_default := ImVec2{ (child_flags & ImGuiChildFlags_.ImGuiChildFlags_AutoResizeX) != {} ? 0.0 : size_avail.x, (child_flags & ImGuiChildFlags_.ImGuiChildFlags_AutoResizeY) != {} ? 0.0 : size_avail.y }
	size : ImVec2 = CalcItemSize(size_arg, size_default.x, size_default.y)

	// A SetNextWindowSize() call always has priority (#8020)
	// (since the code in Begin() never supported SizeVal==0.0f aka auto-resize via SetNextWindowSize() call, we don't support it here for now)
	// FIXME: We only support ImGuiCond_Always in this path. Supporting other paths would requires to obtain window pointer.
	if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_.ImGuiNextWindowDataFlags_HasSize) != {} && (g.NextWindowData.SizeCond & ImGuiCond_.ImGuiCond_Always) != {} {
		if g.NextWindowData.SizeVal.x > 0.0 {
			size.x = g.NextWindowData.SizeVal.x
			child_flags &= cast(ImGuiChildFlags)~cast(i32)ImGuiChildFlags_.ImGuiChildFlags_ResizeX
		}
		if g.NextWindowData.SizeVal.y > 0.0 {
			size.y = g.NextWindowData.SizeVal.y
			child_flags &= cast(ImGuiChildFlags)~cast(i32)ImGuiChildFlags_.ImGuiChildFlags_ResizeY
		}
	}
	SetNextWindowSize(size)

	// Forward child flags (we allow prior settings to merge but it'll only work for adding flags)
	if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_.ImGuiNextWindowDataFlags_HasChildFlags) != {} { g.NextWindowData.ChildFlags |= child_flags }
	else { g.NextWindowData.ChildFlags = child_flags }
	g.NextWindowData.Flags |= ImGuiNextWindowDataFlags_.ImGuiNextWindowDataFlags_HasChildFlags

	// Build up name. If you need to append to a same child from multiple location in the ID stack, use BeginChild(ImGuiID id) with a stable value.
	// FIXME: 2023/11/14: commented out shorted version. We had an issue with multiple ### in child window path names, which the trailing hash helped workaround.
	// e.g. "ParentName###ParentIdentifier/ChildName###ChildIdentifier" would get hashed incorrectly by ImHashStr(), trailing _%08X somehow fixes it.
	temp_window_name : [^]u8
	/*if (name && parent_window->IDStack.back() == parent_window->ID)
        ImFormatStringToTempBuffer(&temp_window_name, NULL, "%s/%s", parent_window->Name, name); // May omit ID if in root of ID stack
    else*/
	if name != "" { ImFormatStringToTempBuffer(&temp_window_name, nil, "%s/%s_%08X", parent_window.Name, name, id) }
	else { ImFormatStringToTempBuffer(&temp_window_name, nil, "%s/%08X", parent_window.Name, id) }

	// Set style
	backup_border_size : f32 = g.Style.ChildBorderSize
	if (child_flags & ImGuiChildFlags_.ImGuiChildFlags_Borders) == {} { g.Style.ChildBorderSize = 0.0 }

	// Begin into window
	ret : bool = Begin(string_from_cstr(cast(cstring)temp_window_name, strlen(temp_window_name)), nil, window_flags)

	// Restore style
	g.Style.ChildBorderSize = backup_border_size
	if (child_flags & ImGuiChildFlags_.ImGuiChildFlags_FrameStyle) != {} {
		PopStyleVar(3)
		PopStyleColor()
	}

	child_window : ^ImGuiWindow = g.CurrentWindow
	child_window.ChildId = id

	// Set the cursor to handle case where the user called SetNextWindowPos()+BeginChild() manually.
	// While this is not really documented/defined, it seems that the expected thing to do.
	if child_window.BeginCount == 1 { parent_window.DC.CursorPos = child_window.Pos }

	// Process navigation-in immediately so NavInit can run on first frame
	// Can enter a child if (A) it has navigable items or (B) it can be scrolled.
	temp_id_for_activation : ImGuiID = ImHashStr("##Child", id)
	if g.ActiveId == temp_id_for_activation { ClearActiveID() }
	if g.NavActivateId == id && (child_flags & ImGuiChildFlags_.ImGuiChildFlags_NavFlattened) == {} && (child_window.DC.NavLayersActiveMask != 0 || child_window.DC.NavWindowHasScrollY) {
		FocusWindow(child_window)
		NavInitWindow(child_window, false)
		SetActiveID(temp_id_for_activation, child_window); // Steal ActiveId with another arbitrary id so that key-press won't activate child item
		g.ActiveIdSource = g.NavInputSource
	}
	return ret
}

EndChild :: proc()
{
	g : ^ImGuiContext = GImGui
	child_window : ^ImGuiWindow = g.CurrentWindow

	backup_within_end_child_id : ImGuiID = g.WithinEndChildID
	IM_ASSERT((child_window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_ChildWindow) != {}); // Mismatched BeginChild()/EndChild() calls

	g.WithinEndChildID = child_window.ID
	child_size : ImVec2 = child_window.Size
	End()
	if child_window.BeginCount == 1 {
		parent_window : ^ImGuiWindow = g.CurrentWindow
		bb : ImRect; init(&bb, parent_window.DC.CursorPos, parent_window.DC.CursorPos + child_size)
		ItemSize(child_size)
		nav_flattened : bool = (child_window.ChildFlags & ImGuiChildFlags_.ImGuiChildFlags_NavFlattened) != {}
		if (child_window.DC.NavLayersActiveMask != 0 || child_window.DC.NavWindowHasScrollY) && !nav_flattened {
			ItemAdd(bb, child_window.ChildId)
			RenderNavCursor(bb, child_window.ChildId)

			// When browsing a window that has no activable items (scroll only) we keep a highlight on the child (pass g.NavId to trick into always displaying)
			if child_window.DC.NavLayersActiveMask == 0 && child_window == g.NavWindow { RenderNavCursor(ImRect{bb.Min - ImVec2{2, 2}, bb.Max + ImVec2{2, 2}}, g.NavId, ImGuiNavRenderCursorFlags_.ImGuiNavRenderCursorFlags_Compact) }
		}
		else {
			// Not navigable into
			// - This is a bit of a fringe use case, mostly useful for undecorated, non-scrolling contents childs, or empty childs.
			// - We could later decide to not apply this path if ImGuiChildFlags_FrameStyle or ImGuiChildFlags_Borders is set.
			ItemAdd(bb, child_window.ChildId, nil, ImGuiItemFlags_.ImGuiItemFlags_NoNav)

			// But when flattened we directly reach items, adjust active layer mask accordingly
			if nav_flattened { parent_window.DC.NavLayersActiveMaskNext |= child_window.DC.NavLayersActiveMaskNext }
		}
		if g.HoveredWindow == child_window { g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_.ImGuiItemStatusFlags_HoveredWindow }
	}
	g.WithinEndChildID = backup_within_end_child_id
	g.LogLinePosY = -FLT_MAX; // To enforce a carriage return
}

SetWindowConditionAllowFlags :: proc(window : ^ImGuiWindow, flags : ImGuiCond, enabled : bool)
{
	window.SetWindowPosAllowFlags = enabled ? (window.SetWindowPosAllowFlags | flags) : (window.SetWindowPosAllowFlags & cast(ImGuiCond)~cast(i32)flags)
	window.SetWindowSizeAllowFlags = enabled ? (window.SetWindowSizeAllowFlags | flags) : (window.SetWindowSizeAllowFlags & cast(ImGuiCond)~cast(i32)flags)
	window.SetWindowCollapsedAllowFlags = enabled ? (window.SetWindowCollapsedAllowFlags | flags) : (window.SetWindowCollapsedAllowFlags & cast(ImGuiCond)~cast(i32)flags)
	window.SetWindowDockAllowFlags = enabled ? (window.SetWindowDockAllowFlags | flags) : (window.SetWindowDockAllowFlags & cast(ImGuiCond)~cast(i32)flags)
}

FindWindowByID :: proc(id : ImGuiID) -> ^ImGuiWindow
{
	g : ^ImGuiContext = GImGui
	return cast(^ImGuiWindow) GetVoidPtr(&g.WindowsById, id)
}

FindWindowByName :: proc(name : string) -> ^ImGuiWindow
{
	id : ImGuiID = ImHashStr(name)
	return FindWindowByID(id)
}

ApplyWindowSettings :: proc(window : ^ImGuiWindow, settings : ^ImGuiWindowSettings)
{
	main_viewport : ^ImGuiViewport = GetMainViewport()
	window.ViewportPos = main_viewport.Pos
	if settings.ViewportId != 0 {
		window.ViewportId = settings.ViewportId
		window.ViewportPos = ImVec2{cast(f32) settings.ViewportPos.x, cast(f32) settings.ViewportPos.y}
	}
	window.Pos = ImTrunc(ImVec2{cast(f32) settings.Pos.x + window.ViewportPos.x, cast(f32) settings.Pos.y + window.ViewportPos.y})
	if settings.Size.x > 0 && settings.Size.y > 0 { window.SizeFull = ImTrunc(ImVec2{cast(f32) settings.Size.x, cast(f32) settings.Size.y}); window.Size = window.SizeFull }
	window.Collapsed = settings.Collapsed
	window.DockId = settings.DockId
	window.DockOrder = settings.DockOrder
}

InitOrLoadWindowSettings :: proc(window : ^ImGuiWindow, settings : ^ImGuiWindowSettings)
{
	// Initial window state with e.g. default/arbitrary window position
	// Use SetNextWindowPos() with the appropriate condition flag to change the initial position of a window.
	main_viewport : ^ImGuiViewport = GetMainViewport()
	window.Pos = main_viewport.Pos + ImVec2{60, 60}
	window.SizeFull = ImVec2{0, 0}; window.Size = window.SizeFull
	window.ViewportPos = main_viewport.Pos
	window.SetWindowDockAllowFlags = ImGuiCond_.ImGuiCond_Always | ImGuiCond_.ImGuiCond_Once | ImGuiCond_.ImGuiCond_FirstUseEver | ImGuiCond_.ImGuiCond_Appearing; window.SetWindowCollapsedAllowFlags = window.SetWindowDockAllowFlags; window.SetWindowSizeAllowFlags = window.SetWindowCollapsedAllowFlags; window.SetWindowPosAllowFlags = window.SetWindowSizeAllowFlags

	if settings != nil {
		SetWindowConditionAllowFlags(window, ImGuiCond_.ImGuiCond_FirstUseEver, false)
		ApplyWindowSettings(window, settings)
	}
	window.DC.IdealMaxPos = window.Pos; window.DC.CursorMaxPos = window.DC.IdealMaxPos; window.DC.CursorStartPos = window.DC.CursorMaxPos; // So first call to CalcWindowContentSizes() doesn't return crazy values

	if (window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_AlwaysAutoResize) != {} {
		window.AutoFitFramesY = 2; window.AutoFitFramesX = window.AutoFitFramesY
		window.AutoFitOnlyGrows = false
	}
	else {
		if window.Size.x <= 0.0 { window.AutoFitFramesX = 2 }
		if window.Size.y <= 0.0 { window.AutoFitFramesY = 2 }
		window.AutoFitOnlyGrows = (window.AutoFitFramesX > 0) || (window.AutoFitFramesY > 0)
	}
}

CreateNewWindow :: proc(name : string, flags : ImGuiWindowFlags) -> ^ImGuiWindow
{
	// Create window the first time
	//IMGUI_DEBUG_LOG("CreateNewWindow '%s', Flags = {}x%08X\n", name, flags);
	g : ^ImGuiContext = GImGui
	window := cast(^ImGuiWindow) IM_ALLOC(size_of(ImGuiWindow))
	init(window, g, name)
	window.Flags = flags
	SetVoidPtr(&g.WindowsById, window.ID, window)

	settings : ^ImGuiWindowSettings = nil
	if (flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoSavedSettings) == {} {
		settings = FindWindowSettingsByWindow(window)
		if settings != nil {
			window.SettingsOffset = offset_from_ptr(&g.SettingsWindows, settings)
		}
	}

	InitOrLoadWindowSettings(window, settings)

	if (flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoBringToFrontOnFocus) != {} {
		// Quite slow but rare and only once
		push_front(&g.Windows, window)
	}
	else { push_back(&g.Windows, window) }

	return window
}

GetWindowForTitleDisplay :: proc(window : ^ImGuiWindow) -> ^ImGuiWindow
{
	return window.DockNodeAsHost != nil ? window.DockNodeAsHost.VisibleWindow : window
}

GetWindowForTitleAndMenuHeight :: proc(window : ^ImGuiWindow) -> ^ImGuiWindow
{
	return (window.DockNodeAsHost != nil && window.DockNodeAsHost.VisibleWindow != nil) ? window.DockNodeAsHost.VisibleWindow : window
}

CalcWindowMinSize :: #force_inline proc(window : ^ImGuiWindow) -> ImVec2
{
	// We give windows non-zero minimum size to facilitate understanding problematic cases (e.g. empty popups)
	// FIXME: Essentially we want to restrict manual resizing to WindowMinSize+Decoration, and allow api resizing to be smaller.
	// Perhaps should tend further a neater test for this.
	g : ^ImGuiContext = GImGui
	size_min : ImVec2
	if (window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_ChildWindow) != {} && (window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_Popup) == {} {
		size_min.x = (window.ChildFlags & ImGuiChildFlags_.ImGuiChildFlags_ResizeX) != {} ? g.Style.WindowMinSize.x : 4.0
		size_min.y = (window.ChildFlags & ImGuiChildFlags_.ImGuiChildFlags_ResizeY) != {} ? g.Style.WindowMinSize.y : 4.0
	}
	else {
		size_min.x = ((window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_AlwaysAutoResize) == {}) ? g.Style.WindowMinSize.x : 4.0
		size_min.y = ((window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_AlwaysAutoResize) == {}) ? g.Style.WindowMinSize.y : 4.0
	}

	// Reduce artifacts with very small windows
	window_for_height : ^ImGuiWindow = GetWindowForTitleAndMenuHeight(window)
	size_min.y = ImMax(size_min.y, window_for_height.TitleBarHeight + window_for_height.MenuBarHeight + ImMax(f32(0.0), g.Style.WindowRounding - 1.0))
	return size_min
}

CalcWindowSizeAfterConstraint :: proc(window : ^ImGuiWindow, size_desired : ImVec2) -> ImVec2
{
	g : ^ImGuiContext = GImGui
	new_size : ImVec2 = size_desired
	if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_.ImGuiNextWindowDataFlags_HasSizeConstraint) != {} {
		// See comments in SetNextWindowSizeConstraints() for details about setting size_min an size_max.
		cr : ImRect = g.NextWindowData.SizeConstraintRect
		new_size.x = (cr.Min.x >= 0 && cr.Max.x >= 0) ? ImClamp(new_size.x, cr.Min.x, cr.Max.x) : window.SizeFull.x
		new_size.y = (cr.Min.y >= 0 && cr.Max.y >= 0) ? ImClamp(new_size.y, cr.Min.y, cr.Max.y) : window.SizeFull.y
		if g.NextWindowData.SizeCallback != {} {
			data : ImGuiSizeCallbackData
			data.UserData = g.NextWindowData.SizeCallbackUserData
			data.Pos = window.Pos
			data.CurrentSize = window.SizeFull
			data.DesiredSize = new_size
			g.NextWindowData.SizeCallback(&data)
			new_size = data.DesiredSize
		}
		new_size.x = IM_TRUNC(new_size.x)
		new_size.y = IM_TRUNC(new_size.y)
	}

	// Minimum size
	size_min : ImVec2 = CalcWindowMinSize(window)
	return ImMax(new_size, size_min)
}

CalcWindowContentSizes :: proc(window : ^ImGuiWindow, content_size_current : ^ImVec2, content_size_ideal : ^ImVec2)
{
	preserve_old_content_sizes : bool = false
	if window.Collapsed && window.AutoFitFramesX <= 0 && window.AutoFitFramesY <= 0 { preserve_old_content_sizes = true }
	else if window.Hidden && window.HiddenFramesCannotSkipItems == 0 && window.HiddenFramesCanSkipItems > 0 { preserve_old_content_sizes = true }
	if preserve_old_content_sizes {
		content_size_current^ = window.ContentSize
		content_size_ideal^ = window.ContentSizeIdeal
		return
	}

	content_size_current.x = (window.ContentSizeExplicit.x != 0.0) ? window.ContentSizeExplicit.x : IM_TRUNC(window.DC.CursorMaxPos.x - window.DC.CursorStartPos.x)
	content_size_current.y = (window.ContentSizeExplicit.y != 0.0) ? window.ContentSizeExplicit.y : IM_TRUNC(window.DC.CursorMaxPos.y - window.DC.CursorStartPos.y)
	content_size_ideal.x = (window.ContentSizeExplicit.x != 0.0) ? window.ContentSizeExplicit.x : IM_TRUNC(ImMax(window.DC.CursorMaxPos.x, window.DC.IdealMaxPos.x) - window.DC.CursorStartPos.x)
	content_size_ideal.y = (window.ContentSizeExplicit.y != 0.0) ? window.ContentSizeExplicit.y : IM_TRUNC(ImMax(window.DC.CursorMaxPos.y, window.DC.IdealMaxPos.y) - window.DC.CursorStartPos.y)
}

CalcWindowAutoFitSize :: proc(window : ^ImGuiWindow, size_contents : ImVec2) -> ImVec2
{
	g : ^ImGuiContext = GImGui
	style : ^ImGuiStyle = &g.Style
	decoration_w_without_scrollbars : f32 = window.DecoOuterSizeX1 + window.DecoOuterSizeX2 - window.ScrollbarSizes.x
	decoration_h_without_scrollbars : f32 = window.DecoOuterSizeY1 + window.DecoOuterSizeY2 - window.ScrollbarSizes.y
	size_pad : ImVec2 = window.WindowPadding * 2.0
	size_desired : ImVec2 = size_contents + size_pad + ImVec2{decoration_w_without_scrollbars, decoration_h_without_scrollbars}
	if (window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_Tooltip) != {} {
		// Tooltip always resize
		return size_desired
	}
	else {
		// Maximum window size is determined by the viewport size or monitor size
		size_min : ImVec2 = CalcWindowMinSize(window)
		size_max : ImVec2 = ImVec2{FLT_MAX, FLT_MAX}

		// Child windows are layed within their parent (unless they are also popups/menus) and thus have no restriction
		if (window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_ChildWindow) == {} || (window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_Popup) != {} {
			if !window.ViewportOwned { size_max = GetMainViewport().WorkSize - style.DisplaySafeAreaPadding * 2.0 }
			monitor_idx : i32 = window.ViewportAllowPlatformMonitorExtend
			if monitor_idx >= 0 && monitor_idx < g.PlatformIO.Monitors.Size { size_max = g.PlatformIO.Monitors.Data[monitor_idx].WorkSize - style.DisplaySafeAreaPadding * 2.0 }
		}

		size_auto_fit : ImVec2 = ImClamp(size_desired, size_min, ImMax(size_min, size_max))

		// FIXME: CalcWindowAutoFitSize() doesn't take into account that only one axis may be auto-fit when calculating scrollbars,
		// we may need to compute/store three variants of size_auto_fit, for x/y/xy.
		// Here we implement a workaround for child windows only, but a full solution would apply to normal windows as well:
		if (window.ChildFlags & ImGuiChildFlags_.ImGuiChildFlags_ResizeX) != {} && (window.ChildFlags & ImGuiChildFlags_.ImGuiChildFlags_ResizeY) == {} { size_auto_fit.y = window.SizeFull.y }
		else if (window.ChildFlags & ImGuiChildFlags_.ImGuiChildFlags_ResizeX) == {} && (window.ChildFlags & ImGuiChildFlags_.ImGuiChildFlags_ResizeY) != {} { size_auto_fit.x = window.SizeFull.x }

		// When the window cannot fit all contents (either because of constraints, either because screen is too small),
		// we are growing the size on the other axis to compensate for expected scrollbar. FIXME: Might turn bigger than ViewportSize-WindowPadding.
		size_auto_fit_after_constraint : ImVec2 = CalcWindowSizeAfterConstraint(window, size_auto_fit)
		will_have_scrollbar_x : bool = (size_auto_fit_after_constraint.x - size_pad.x - decoration_w_without_scrollbars < size_contents.x && (window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoScrollbar) == {} && (window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_HorizontalScrollbar) != {}) || (window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_AlwaysHorizontalScrollbar) != {}
		will_have_scrollbar_y : bool = (size_auto_fit_after_constraint.y - size_pad.y - decoration_h_without_scrollbars < size_contents.y && (window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoScrollbar) == {}) || (window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_AlwaysVerticalScrollbar) != {}
		if will_have_scrollbar_x { size_auto_fit.y += style.ScrollbarSize }
		if will_have_scrollbar_y { size_auto_fit.x += style.ScrollbarSize }
		return size_auto_fit
	}
}

CalcWindowNextAutoFitSize :: proc(window : ^ImGuiWindow) -> ImVec2
{
	size_contents_current : ImVec2
	size_contents_ideal : ImVec2
	CalcWindowContentSizes(window, &size_contents_current, &size_contents_ideal)
	size_auto_fit : ImVec2 = CalcWindowAutoFitSize(window, size_contents_ideal)
	size_final : ImVec2 = CalcWindowSizeAfterConstraint(window, size_auto_fit)
	return size_final
}

GetWindowBgColorIdx :: proc(window : ^ImGuiWindow) -> ImGuiCol
{
	if (window.Flags & (ImGuiWindowFlags_.ImGuiWindowFlags_Tooltip | ImGuiWindowFlags_.ImGuiWindowFlags_Popup)) != {} { return ImGuiCol_.ImGuiCol_PopupBg }
	if (window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_ChildWindow) != {} && !window.DockIsActive { return ImGuiCol_.ImGuiCol_ChildBg }
	return ImGuiCol_.ImGuiCol_WindowBg
}

CalcResizePosSizeFromAnyCorner :: proc(window : ^ImGuiWindow, corner_target : ImVec2, corner_norm : ImVec2, out_pos : ^ImVec2, out_size : ^ImVec2)
{
	pos_min : ImVec2 = ImLerp(corner_target, window.Pos, corner_norm); // Expected window upper-left
	pos_max : ImVec2 = ImLerp(window.Pos + window.Size, corner_target, corner_norm); // Expected window lower-right
	size_expected : ImVec2 = pos_max - pos_min
	size_constrained : ImVec2 = CalcWindowSizeAfterConstraint(window, size_expected)
	out_pos^ = pos_min
	if corner_norm.x == 0.0 { out_pos.x -= (size_constrained.x - size_expected.x) }
	if corner_norm.y == 0.0 { out_pos.y -= (size_constrained.y - size_expected.y) }
	out_size^ = size_constrained
}

// Data for resizing from resize grip / corner
ImGuiResizeGripDef :: struct {
	CornerPosN : ImVec2,
	InnerDir : ImVec2,
	AngleMin12 : i32, AngleMax12 : i32,
}
resize_grip_def : [4]ImGuiResizeGripDef = {
	{ImVec2{1, 1}, ImVec2{-1, -1}, 0, 3}, // Lower-right
	{ImVec2{0, 1}, ImVec2{+1, -1}, 3, 6}, // Lower-left
	{ImVec2{0, 0}, ImVec2{+1, +1}, 6, 9}, // Upper-left (Unused)
	{ImVec2{1, 0}, ImVec2{-1, +1}, 9, 12}, // Upper-right (Unused)
}

// Data for resizing from borders
ImGuiResizeBorderDef :: struct {
	InnerDir : ImVec2, // Normal toward inside
	SegmentN1 : ImVec2, SegmentN2 : ImVec2, // End positions, normalized (0,0: upper left)
	OuterAngle : f32, // Angle toward outside
}
resize_border_def : [4]ImGuiResizeBorderDef = {
	{ImVec2{+1, 0}, ImVec2{0, 1}, ImVec2{0, 0}, IM_PI * 1.00}, // Left
	{ImVec2{-1, 0}, ImVec2{1, 0}, ImVec2{1, 1}, IM_PI * 0.00}, // Right
	{ImVec2{0, +1}, ImVec2{0, 0}, ImVec2{1, 0}, IM_PI * 1.50}, // Up
	{ImVec2{0, -1}, ImVec2{1, 1}, ImVec2{0, 1}, IM_PI * 0.50}, // Down
}

GetResizeBorderRect :: proc(window : ^ImGuiWindow, border_n : ImGuiDir, perp_padding : f32, thickness : f32) -> ImRect
{
	rect : ImRect = Rect(window)
	if thickness == 0.0 { rect.Max -= ImVec2{1, 1} }
	if border_n == ImGuiDir.ImGuiDir_Left { return ImRect{{rect.Min.x - thickness, rect.Min.y + perp_padding}, {rect.Min.x + thickness, rect.Max.y - perp_padding}} }
	if border_n == ImGuiDir.ImGuiDir_Right { return ImRect{{rect.Max.x - thickness, rect.Min.y + perp_padding}, {rect.Max.x + thickness, rect.Max.y - perp_padding}} }
	if border_n == ImGuiDir.ImGuiDir_Up { return ImRect{{rect.Min.x + perp_padding, rect.Min.y - thickness}, {rect.Max.x - perp_padding, rect.Min.y + thickness}} }
	if border_n == ImGuiDir.ImGuiDir_Down { return ImRect{{rect.Min.x + perp_padding, rect.Max.y - thickness}, {rect.Max.x - perp_padding, rect.Max.y + thickness}} }
	IM_ASSERT(false)
	return ImRect{}
}

// 0..3: corners
// 0..3: corners (Lower-right, Lower-left, Unused, Unused)
GetWindowResizeCornerID :: proc(window : ^ImGuiWindow, n : i32) -> ImGuiID
{
	n := n
	IM_ASSERT(n >= 0 && n < 4)
	id : ImGuiID = window.DockIsActive ? window.DockNode.HostWindow.ID : window.ID
	id = ImHashStr("#RESIZE", id)
	id = ImHashData(&n, size_of(i32), id)
	return id
}

// Borders (Left, Right, Up, Down)
GetWindowResizeBorderID :: proc(window : ^ImGuiWindow, dir : ImGuiDir) -> ImGuiID
{
	IM_ASSERT(dir >= ImGuiDir(0) && dir < ImGuiDir(4))
	n : i32 = cast(i32) dir + 4
	id : ImGuiID = window.DockIsActive ? window.DockNode.HostWindow.ID : window.ID
	id = ImHashStr("#RESIZE", id)
	id = ImHashData(&n, size_of(i32), id)
	return id
}

// Handle resize for: Resize Grips, Borders, Gamepad
// Return true when using auto-fit (double-click on resize grip)
UpdateWindowManualResize :: proc(window : ^ImGuiWindow, size_auto_fit : ImVec2, border_hovered : ^ImGuiDir, border_held : ^ImGuiDir, resize_grip_count : i32, resize_grip_col : ^[4]ImU32, visibility_rect : ImRect) -> i32
{
	g : ^ImGuiContext = GImGui
	flags : ImGuiWindowFlags = window.Flags

	if (flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoResize) != {} || (flags & ImGuiWindowFlags_.ImGuiWindowFlags_AlwaysAutoResize) != {} || window.AutoFitFramesX > 0 || window.AutoFitFramesY > 0 { return 0 }
	if window.WasActive == false {
		// Early out to avoid running this code for e.g. a hidden implicit/fallback Debug window.
		return 0
	}

	ret_auto_fit_mask : i32 = 0x00
	grip_draw_size : f32 = IM_TRUNC(ImMax(g.FontSize * 1.35, window.WindowRounding + 1.0 + g.FontSize * 0.2))
	grip_hover_inner_size : f32 = (resize_grip_count > 0) ? IM_TRUNC(grip_draw_size * 0.75) : 0.0
	grip_hover_outer_size : f32 = g.IO.ConfigWindowsResizeFromEdges ? WINDOWS_HOVER_PADDING : 0.0

	clamp_rect : ImRect = visibility_rect
	window_move_from_title_bar : bool = g.IO.ConfigWindowsMoveFromTitleBarOnly && (window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoTitleBar) == {}
	if window_move_from_title_bar { clamp_rect.Min.y -= window.TitleBarHeight }

	pos_target := ImVec2{ FLT_MAX, FLT_MAX }
	size_target := ImVec2{ FLT_MAX, FLT_MAX }

	// Clip mouse interaction rectangles within the viewport rectangle (in practice the narrowing is going to happen most of the time).
	// - Not narrowing would mostly benefit the situation where OS windows _without_ decoration have a threshold for hovering when outside their limits.
	//   This is however not the case with current backends under Win32, but a custom borderless window implementation would benefit from it.
	// - When decoration are enabled we typically benefit from that distance, but then our resize elements would be conflicting with OS resize elements, so we also narrow.
	// - Note that we are unable to tell if the platform setup allows hovering with a distance threshold (on Win32, decorated window have such threshold).
	// We only clip interaction so we overwrite window->ClipRect, cannot call PushClipRect() yet as DrawList is not yet setup.
	clip_with_viewport_rect : bool = (g.IO.BackendFlags & ImGuiBackendFlags_.ImGuiBackendFlags_HasMouseHoveredViewport) == {} || (g.IO.MouseHoveredViewport != window.ViewportId) || (window.Viewport.Flags & ImGuiViewportFlags_.ImGuiViewportFlags_NoDecoration) == {}
	if clip_with_viewport_rect { window.ClipRect = GetMainRect(window.Viewport) }

	// Resize grips and borders are on layer 1
	window.DC.NavLayerCurrent = ImGuiNavLayer.ImGuiNavLayer_Menu

	// Manual resize grips
	PushID("#RESIZE")
	for resize_grip_n : i32 = 0; resize_grip_n < resize_grip_count; resize_grip_n += 1 {
		def : ^ImGuiResizeGripDef = &resize_grip_def[resize_grip_n]
		corner : ImVec2 = ImLerp(window.Pos, window.Pos + window.Size, def.CornerPosN)

		// Using the FlattenChilds button flag we make the resize button accessible even if we are hovering over a child window
		hovered : bool; held : bool
		resize_rect : ImRect; init(&resize_rect, corner - def.InnerDir * grip_hover_outer_size, corner + def.InnerDir * grip_hover_inner_size)
		if resize_rect.Min.x > resize_rect.Max.x { ImSwap(&resize_rect.Min.x, &resize_rect.Max.x) }
		if resize_rect.Min.y > resize_rect.Max.y { ImSwap(&resize_rect.Min.y, &resize_rect.Max.y) }
		resize_grip_id : ImGuiID = GetID(window, resize_grip_n); // == GetWindowResizeCornerID()
		ItemAdd(resize_rect, resize_grip_id, nil, ImGuiItemFlags_.ImGuiItemFlags_NoNav)
		ButtonBehavior(resize_rect, resize_grip_id, &hovered, &held, ImGuiButtonFlags(ImGuiButtonFlagsPrivate_.ImGuiButtonFlags_FlattenChildren | ImGuiButtonFlagsPrivate_.ImGuiButtonFlags_NoNavFocus))
		//GetForegroundDrawList(window)->AddRect(resize_rect.Min, resize_rect.Max, IM_COL32(255, 255, 0, 255));
		if hovered || held { SetMouseCursor((resize_grip_n & 1) != 0 ? ImGuiMouseCursor_.ImGuiMouseCursor_ResizeNESW : ImGuiMouseCursor_.ImGuiMouseCursor_ResizeNWSE) }

		if held && g.IO.MouseDoubleClicked[0] {
			// Auto-fit when double-clicking
			size_target = CalcWindowSizeAfterConstraint(window, size_auto_fit)
			ret_auto_fit_mask = 0x03; // Both axises
			ClearActiveID()
		}
		else if held {
			// Resize from any of the four corners
			// We don't use an incremental MouseDelta but rather compute an absolute target size based on mouse position
			clamp_min : ImVec2 = ImVec2{def.CornerPosN.x == 1.0 ? clamp_rect.Min.x : -FLT_MAX, (def.CornerPosN.y == 1.0 || (def.CornerPosN.y == 0.0 && window_move_from_title_bar)) ? clamp_rect.Min.y : -FLT_MAX}
			clamp_max : ImVec2 = ImVec2{def.CornerPosN.x == 0.0 ? clamp_rect.Max.x : +FLT_MAX, def.CornerPosN.y == 0.0 ? clamp_rect.Max.y : +FLT_MAX}
			corner_target : ImVec2 = g.IO.MousePos - g.ActiveIdClickOffset + ImLerp(def.InnerDir * grip_hover_outer_size, def.InnerDir * -grip_hover_inner_size, def.CornerPosN); // Corner of the window corresponding to our corner grip
			corner_target = ImClamp(corner_target, clamp_min, clamp_max)
			CalcResizePosSizeFromAnyCorner(window, corner_target, def.CornerPosN, &pos_target, &size_target)
		}

		// Only lower-left grip is visible before hovering/activating
		if resize_grip_n == 0 || held || hovered { resize_grip_col[resize_grip_n] = GetColorU32(held ? ImGuiCol_.ImGuiCol_ResizeGripActive : hovered ? ImGuiCol_.ImGuiCol_ResizeGripHovered : ImGuiCol_.ImGuiCol_ResizeGrip) }
	}

	resize_border_mask : i32 = 0x00
	if (window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_ChildWindow) != {} { resize_border_mask |= ((window.ChildFlags & ImGuiChildFlags_.ImGuiChildFlags_ResizeX) != {} ? 0x02 : 0) | ((window.ChildFlags & ImGuiChildFlags_.ImGuiChildFlags_ResizeY) != {} ? 0x08 : 0) }
	else { resize_border_mask = g.IO.ConfigWindowsResizeFromEdges ? 0x0F : 0x00 }
	for border_n : u32 = 0; border_n < 4; border_n += 1 {
		if (resize_border_mask & (1 << border_n)) == 0 { continue }
		def : ^ImGuiResizeBorderDef = &resize_border_def[border_n]
		axis : ImGuiAxis = (cast(ImGuiDir)border_n == ImGuiDir.ImGuiDir_Left || cast(ImGuiDir)border_n == ImGuiDir.ImGuiDir_Right) ? ImGuiAxis.ImGuiAxis_X : ImGuiAxis.ImGuiAxis_Y

		hovered : bool; held : bool
		border_rect : ImRect = GetResizeBorderRect(window, cast(ImGuiDir)border_n, grip_hover_inner_size, WINDOWS_HOVER_PADDING)
		border_id : ImGuiID = GetID(window, i32(border_n + 4)); // == GetWindowResizeBorderID()
		ItemAdd(border_rect, border_id, nil, ImGuiItemFlags_.ImGuiItemFlags_NoNav)
		ButtonBehavior(border_rect, border_id, &hovered, &held, ImGuiButtonFlags(ImGuiButtonFlagsPrivate_.ImGuiButtonFlags_FlattenChildren | ImGuiButtonFlagsPrivate_.ImGuiButtonFlags_NoNavFocus))
		//GetForegroundDrawList(window)->AddRect(border_rect.Min, border_rect.Max, IM_COL32(255, 255, 0, 255));
		if hovered && g.HoveredIdTimer <= WINDOWS_RESIZE_FROM_EDGES_FEEDBACK_TIMER { hovered = false }
		if hovered || held { SetMouseCursor((axis == ImGuiAxis.ImGuiAxis_X) ? ImGuiMouseCursor_.ImGuiMouseCursor_ResizeEW : ImGuiMouseCursor_.ImGuiMouseCursor_ResizeNS) }
		if held && g.IO.MouseDoubleClicked[0] {
			// Double-clicking bottom or right border auto-fit on this axis
			// FIXME: CalcWindowAutoFitSize() doesn't take into account that only one side may be auto-fit when calculating scrollbars.
			// FIXME: Support top and right borders: rework CalcResizePosSizeFromAnyCorner() to be reusable in both cases.
			if border_n == 1 || border_n == 3 {
				// Right and bottom border
				size_target[axis] = CalcWindowSizeAfterConstraint(window, size_auto_fit)[axis]
				ret_auto_fit_mask |= (1 << cast(u32)axis)
				held = false; hovered = held; // So border doesn't show highlighted at new position
			}
			ClearActiveID()
		}
		else if held {
			// Switch to relative resizing mode when border geometry moved (e.g. resizing a child altering parent scroll), in order to avoid resizing feedback loop.
			// Currently only using relative mode on resizable child windows, as the problem to solve is more likely noticeable for them, but could apply for all windows eventually.
			// FIXME: May want to generalize this idiom at lower-level, so more widgets can use it!
			just_scrolled_manually_while_resizing : bool = (g.WheelingWindow != nil && g.WheelingWindowScrolledFrame == g.FrameCount && IsWindowChildOf(window, g.WheelingWindow, false, true))
			if g.ActiveIdIsJustActivated || just_scrolled_manually_while_resizing {
				g.WindowResizeBorderExpectedRect = border_rect
				g.WindowResizeRelativeMode = false
			}
			if (window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_ChildWindow) != {} && memcmp(&g.WindowResizeBorderExpectedRect, &border_rect, size_of(ImRect)) != 0 { g.WindowResizeRelativeMode = true }

			border_curr : ImVec2 = (window.Pos + ImMin(def.SegmentN1, def.SegmentN2) * window.Size)
			border_target_rel_mode_for_axis : f32 = border_curr[axis] + g.IO.MouseDelta[axis]
			border_target_abs_mode_for_axis : f32 = g.IO.MousePos[axis] - g.ActiveIdClickOffset[axis] + WINDOWS_HOVER_PADDING; // Match ButtonBehavior() padding above.

			// Use absolute mode position
			border_target : ImVec2 = window.Pos
			border_target[axis] = border_target_abs_mode_for_axis

			// Use relative mode target for child window, ignore resize when moving back toward the ideal absolute position.
			ignore_resize : bool = false
			if g.WindowResizeRelativeMode {
				//GetForegroundDrawList()->AddText(GetMainViewport()->WorkPos, IM_COL32_WHITE, "Relative Mode");
				border_target[axis] = border_target_rel_mode_for_axis
				if g.IO.MouseDelta[axis] == 0.0 || (g.IO.MouseDelta[axis] > 0.0) == (border_target_rel_mode_for_axis > border_target_abs_mode_for_axis) { ignore_resize = true }
			}

			// Clamp, apply
			clamp_min := ImVec2{ cast(ImGuiDir)border_n == ImGuiDir.ImGuiDir_Right ? clamp_rect.Min.x : -FLT_MAX, cast(ImGuiDir)border_n == ImGuiDir.ImGuiDir_Down || (cast(ImGuiDir)border_n == ImGuiDir.ImGuiDir_Up && window_move_from_title_bar) ? clamp_rect.Min.y : -FLT_MAX }
			clamp_max := ImVec2{ cast(ImGuiDir)border_n == ImGuiDir.ImGuiDir_Left ? clamp_rect.Max.x : +FLT_MAX, cast(ImGuiDir)border_n == ImGuiDir.ImGuiDir_Up ? clamp_rect.Max.y : +FLT_MAX }
			border_target = ImClamp(border_target, clamp_min, clamp_max)
			if (flags & ImGuiWindowFlags_.ImGuiWindowFlags_ChildWindow) != {} {
				// Clamp resizing of childs within parent
				parent_window : ^ImGuiWindow = window.ParentWindow
				parent_flags : ImGuiWindowFlags = parent_window.Flags
				border_limit_rect : ImRect = parent_window.InnerRect
				Expand(&border_limit_rect, ImVec2{-ImMax(parent_window.WindowPadding.x, parent_window.WindowBorderSize), -ImMax(parent_window.WindowPadding.y, parent_window.WindowBorderSize)})
				if (axis == ImGuiAxis.ImGuiAxis_X) && ((parent_flags & (ImGuiWindowFlags_.ImGuiWindowFlags_HorizontalScrollbar | ImGuiWindowFlags_.ImGuiWindowFlags_AlwaysHorizontalScrollbar)) == {} || (parent_flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoScrollbar) != {}) { border_target.x = ImClamp(border_target.x, border_limit_rect.Min.x, border_limit_rect.Max.x) }
				if (axis == ImGuiAxis.ImGuiAxis_Y) && (parent_flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoScrollbar) != {} { border_target.y = ImClamp(border_target.y, border_limit_rect.Min.y, border_limit_rect.Max.y) }
			}
			if !ignore_resize { CalcResizePosSizeFromAnyCorner(window, border_target, ImMin(def.SegmentN1, def.SegmentN2), &pos_target, &size_target) }
		}
		if hovered { border_hovered^ = cast(ImGuiDir)border_n }
		if held { border_held^ = cast(ImGuiDir)border_n }
	}

	PopID()

	// Restore nav layer
	window.DC.NavLayerCurrent = ImGuiNavLayer.ImGuiNavLayer_Main

	// Navigation resize (keyboard/gamepad)
	// FIXME: This cannot be moved to NavUpdateWindowing() because CalcWindowSizeAfterConstraint() need to callback into user.
	// Not even sure the callback works here.
	if g.NavWindowingTarget != nil && g.NavWindowingTarget.RootWindowDockTree == window {
		nav_resize_dir : ImVec2
		if g.NavInputSource == ImGuiInputSource.ImGuiInputSource_Keyboard && g.IO.KeyShift { nav_resize_dir = GetKeyMagnitude2d(ImGuiKey.ImGuiKey_LeftArrow, ImGuiKey.ImGuiKey_RightArrow, ImGuiKey.ImGuiKey_UpArrow, ImGuiKey.ImGuiKey_DownArrow) }
		if g.NavInputSource == ImGuiInputSource.ImGuiInputSource_Gamepad { nav_resize_dir = GetKeyMagnitude2d(ImGuiKey.ImGuiKey_GamepadDpadLeft, ImGuiKey.ImGuiKey_GamepadDpadRight, ImGuiKey.ImGuiKey_GamepadDpadUp, ImGuiKey.ImGuiKey_GamepadDpadDown) }
		if nav_resize_dir.x != 0.0 || nav_resize_dir.y != 0.0 {
			NAV_RESIZE_SPEED : f32 = 600.0
			resize_step : f32 = NAV_RESIZE_SPEED * g.IO.DeltaTime * ImMin(g.IO.DisplayFramebufferScale.x, g.IO.DisplayFramebufferScale.y)
			g.NavWindowingAccumDeltaSize += nav_resize_dir * resize_step
			g.NavWindowingAccumDeltaSize = ImMax(g.NavWindowingAccumDeltaSize, clamp_rect.Min - window.Pos - window.Size); // We need Pos+Size >= clmap_rect.Min, so Size >= clmap_rect.Min - Pos, so size_delta >= clmap_rect.Min - window->Pos - window->Size
			g.NavWindowingToggleLayer = false
			g.NavHighlightItemUnderNav = true
			resize_grip_col[0] = GetColorU32(ImGuiCol_.ImGuiCol_ResizeGripActive)
			accum_floored : ImVec2 = ImTrunc(g.NavWindowingAccumDeltaSize)
			if accum_floored.x != 0.0 || accum_floored.y != 0.0 {
				// FIXME-NAV: Should store and accumulate into a separate size buffer to handle sizing constraints properly, right now a constraint will make us stuck.
				size_target = CalcWindowSizeAfterConstraint(window, window.SizeFull + accum_floored)
				g.NavWindowingAccumDeltaSize -= accum_floored
			}
		}
	}

	// Apply back modified position/size to window
	curr_pos : ImVec2 = window.Pos
	curr_size : ImVec2 = window.SizeFull
	if size_target.x != FLT_MAX && (window.Size.x != size_target.x || window.SizeFull.x != size_target.x) { window.SizeFull.x = size_target.x; window.Size.x = window.SizeFull.x }
	if size_target.y != FLT_MAX && (window.Size.y != size_target.y || window.SizeFull.y != size_target.y) { window.SizeFull.y = size_target.y; window.Size.y = window.SizeFull.y }
	if pos_target.x != FLT_MAX && window.Pos.x != ImTrunc(pos_target.x) { window.Pos.x = ImTrunc(pos_target.x) }
	if pos_target.y != FLT_MAX && window.Pos.y != ImTrunc(pos_target.y) { window.Pos.y = ImTrunc(pos_target.y) }
	if curr_pos.x != window.Pos.x || curr_pos.y != window.Pos.y || curr_size.x != window.SizeFull.x || curr_size.y != window.SizeFull.y { MarkIniSettingsDirty(window) }

	// Recalculate next expected border expected coordinates
	if border_held^ != ImGuiDir.ImGuiDir_None { g.WindowResizeBorderExpectedRect = GetResizeBorderRect(window, border_held^, grip_hover_inner_size, WINDOWS_HOVER_PADDING) }

	return ret_auto_fit_mask
}

ClampWindowPos :: #force_inline proc(window : ^ImGuiWindow, visibility_rect : ImRect)
{
	g : ^ImGuiContext = GImGui
	size_for_clamping : ImVec2 = window.Size
	if g.IO.ConfigWindowsMoveFromTitleBarOnly && window.DockNodeAsHost != nil {
		// Not using window->TitleBarHeight() as DockNodeAsHost will report 0.0f here.
		size_for_clamping.y = GetFrameHeight()
	}
	else if g.IO.ConfigWindowsMoveFromTitleBarOnly && (window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoTitleBar) == {} { size_for_clamping.y = window.TitleBarHeight }
	window.Pos = ImClamp(window.Pos, visibility_rect.Min - size_for_clamping, visibility_rect.Max)
}

RenderWindowOuterSingleBorder :: proc(window : ^ImGuiWindow, border_n : ImGuiDir, border_col : ImU32, border_size : f32)
{
	def : ^ImGuiResizeBorderDef = &resize_border_def[border_n]
	rounding : f32 = window.WindowRounding
	border_r : ImRect = GetResizeBorderRect(window, border_n, rounding, 0.0)
	PathArcTo(window.DrawList, ImLerp(border_r.Min, border_r.Max, def.SegmentN1) + ImVec2{0.5, 0.5} + def.InnerDir * rounding, rounding, def.OuterAngle - IM_PI * 0.25, def.OuterAngle)
	PathArcTo(window.DrawList, ImLerp(border_r.Min, border_r.Max, def.SegmentN2) + ImVec2{0.5, 0.5} + def.InnerDir * rounding, rounding, def.OuterAngle, def.OuterAngle + IM_PI * 0.25)
	PathStroke(window.DrawList, border_col, ImDrawFlags_.ImDrawFlags_None, border_size)
}

RenderWindowOuterBorders :: proc(window : ^ImGuiWindow)
{
	g : ^ImGuiContext = GImGui
	border_size : f32 = window.WindowBorderSize
	border_col : ImU32 = GetColorU32(ImGuiCol_.ImGuiCol_Border)
	if border_size > 0.0 && (window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoBackground) == {} { AddRect(window.DrawList, window.Pos, window.Pos + window.Size, border_col, window.WindowRounding, {}, window.WindowBorderSize) }
	else if border_size > 0.0 {
		if (window.ChildFlags & ImGuiChildFlags_.ImGuiChildFlags_ResizeX) != {} {
			// Similar code as 'resize_border_mask' computation in UpdateWindowManualResize() but we specifically only always draw explicit child resize border.
			RenderWindowOuterSingleBorder(window, ImGuiDir(1), border_col, border_size)
		}
		if (window.ChildFlags & ImGuiChildFlags_.ImGuiChildFlags_ResizeY) != {} { RenderWindowOuterSingleBorder(window, ImGuiDir(3), border_col, border_size) }
	}
	if window.ResizeBorderHovered != -1 || window.ResizeBorderHeld != -1 {
		border_n := ImGuiDir((window.ResizeBorderHeld != -1) ? window.ResizeBorderHeld : window.ResizeBorderHovered)
		border_col_resizing : ImU32 = GetColorU32((window.ResizeBorderHeld != -1) ? ImGuiCol_.ImGuiCol_SeparatorActive : ImGuiCol_.ImGuiCol_SeparatorHovered)
		RenderWindowOuterSingleBorder(window, border_n, border_col_resizing, ImMax(f32(2.0), window.WindowBorderSize)); // Thicker than usual
	}
	if g.Style.FrameBorderSize > 0 && (window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoTitleBar) == {} && !window.DockIsActive {
		y : f32 = window.Pos.y + window.TitleBarHeight - 1
		AddLine(window.DrawList, ImVec2{window.Pos.x + border_size, y}, ImVec2{window.Pos.x + window.Size.x - border_size, y}, border_col, g.Style.FrameBorderSize)
	}
}

// Draw background and borders
// Draw and handle scrollbars
RenderWindowDecorations :: proc(window : ^ImGuiWindow, title_bar_rect : ImRect, title_bar_is_highlight : bool, handle_borders_and_resize_grips : bool, resize_grip_count : i32, resize_grip_col : [4]ImU32, resize_grip_draw_size : f32)
{
	g : ^ImGuiContext = GImGui
	style : ^ImGuiStyle = &g.Style
	flags : ImGuiWindowFlags = window.Flags

	// Ensure that Scrollbar() doesn't read last frame's SkipItems
	IM_ASSERT(window.BeginCount == 0)
	window.SkipItems = false
	window.DC.NavLayerCurrent = ImGuiNavLayer.ImGuiNavLayer_Menu

	// Draw window + handle manual resize
	// As we highlight the title bar when want_focus is set, multiple reappearing windows will have their title bar highlighted on their reappearing frame.
	window_rounding : f32 = window.WindowRounding
	window_border_size : f32 = window.WindowBorderSize
	if window.Collapsed {
		// Title bar only
		backup_border_size : f32 = style.FrameBorderSize
		g.Style.FrameBorderSize = window.WindowBorderSize
		title_bar_col : ImU32 = GetColorU32((title_bar_is_highlight && g.NavCursorVisible) ? ImGuiCol_.ImGuiCol_TitleBgActive : ImGuiCol_.ImGuiCol_TitleBgCollapsed)
		if window.ViewportOwned {
			// No alpha (we don't support is_docking_transparent_payload here because simpler and less meaningful, but could with a bit of code shuffle/reuse)
			title_bar_col |= IM_COL32_A_MASK
		}
		RenderFrame(title_bar_rect.Min, title_bar_rect.Max, title_bar_col, true, window_rounding)
		g.Style.FrameBorderSize = backup_border_size
	}
	else {
		// Window background
		if (flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoBackground) == {} {
			is_docking_transparent_payload : bool = false
			if g.DragDropActive && (g.FrameCount - g.DragDropAcceptFrameCount) <= 1 && g.IO.ConfigDockingTransparentPayload { if IsDataType(&g.DragDropPayload, IMGUI_PAYLOAD_TYPE_WINDOW) && (cast(^^ImGuiWindow) g.DragDropPayload.Data)^ == window { is_docking_transparent_payload = true } }

			bg_col : ImU32 = GetColorU32(GetWindowBgColorIdx(window))
			if window.ViewportOwned {
				bg_col |= IM_COL32_A_MASK; // No alpha
				if is_docking_transparent_payload { window.Viewport.Alpha *= DOCKING_TRANSPARENT_PAYLOAD_ALPHA }
			}
			else {
				// Adjust alpha. For docking
				override_alpha : bool = false
				alpha : f32 = 1.0
				if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_.ImGuiNextWindowDataFlags_HasBgAlpha) != {} {
					alpha = g.NextWindowData.BgAlphaVal
					override_alpha = true
				}
				if is_docking_transparent_payload {
					alpha *= DOCKING_TRANSPARENT_PAYLOAD_ALPHA; // FIXME-DOCK: Should that be an override?
					override_alpha = true
				}
				if override_alpha { bg_col = (bg_col & ~ImU32(IM_COL32_A_MASK)) | (cast(u32)IM_F32_TO_INT8_SAT(alpha) << IM_COL32_A_SHIFT) }
			}

			// Render, for docked windows and host windows we ensure bg goes before decorations
			if window.DockIsActive { window.DockNode.LastBgColor = bg_col }
			bg_draw_list : ^ImDrawList = window.DockIsActive ? window.DockNode.HostWindow.DrawList : window.DrawList
			if window.DockIsActive || (flags & ImGuiWindowFlags_.ImGuiWindowFlags_DockNodeHost) != {} { ChannelsSetCurrent(bg_draw_list, DOCKING_HOST_DRAW_CHANNEL_BG) }
			AddRectFilled(bg_draw_list, window.Pos + ImVec2{0, window.TitleBarHeight}, window.Pos + window.Size, bg_col, window_rounding, (flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoTitleBar) != {} ? {} : ImDrawFlags_.ImDrawFlags_RoundCornersBottom)
			if window.DockIsActive || (flags & ImGuiWindowFlags_.ImGuiWindowFlags_DockNodeHost) != {} { ChannelsSetCurrent(bg_draw_list, DOCKING_HOST_DRAW_CHANNEL_FG) }
		}
		if window.DockIsActive { window.DockNode.IsBgDrawnThisFrame = true }

		// Title bar
		// (when docked, DockNode are drawing their own title bar. Individual windows however do NOT set the _NoTitleBar flag,
		// in order for their pos/size to be matching their undocking state.)
		if (flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoTitleBar) == {} && !window.DockIsActive {
			title_bar_col : ImU32 = GetColorU32(title_bar_is_highlight ? ImGuiCol_.ImGuiCol_TitleBgActive : ImGuiCol_.ImGuiCol_TitleBg)
			if window.ViewportOwned {
				// No alpha
				title_bar_col |= IM_COL32_A_MASK
			}
			AddRectFilled(window.DrawList, title_bar_rect.Min, title_bar_rect.Max, title_bar_col, window_rounding, ImDrawFlags_.ImDrawFlags_RoundCornersTop)
		}

		// Menu bar
		if (flags & ImGuiWindowFlags_.ImGuiWindowFlags_MenuBar) != {} {
			menu_bar_rect : ImRect = MenuBarRect(window)
			ClipWith(&menu_bar_rect, Rect(window)); // Soft clipping, in particular child window don't have minimum size covering the menu bar so this is useful for them.
			AddRectFilled(window.DrawList, menu_bar_rect.Min + ImVec2{window_border_size, 0}, menu_bar_rect.Max - ImVec2{window_border_size, 0}, GetColorU32(ImGuiCol_.ImGuiCol_MenuBarBg), (flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoTitleBar) != {} ? window_rounding : 0.0, ImDrawFlags_.ImDrawFlags_RoundCornersTop)
			if style.FrameBorderSize > 0.0 && menu_bar_rect.Max.y < window.Pos.y + window.Size.y { AddLine(window.DrawList, GetBL(menu_bar_rect), GetBR(menu_bar_rect), GetColorU32(ImGuiCol_.ImGuiCol_Border), style.FrameBorderSize) }
		}

		// Docking: Unhide tab bar (small triangle in the corner), drag from small triangle to quickly undock
		node : ^ImGuiDockNode = window.DockNode
		if window.DockIsActive && IsHiddenTabBar(node) && !IsNoTabBar(node) {
			unhide_sz_draw : f32 = ImTrunc(g.FontSize * 0.70)
			unhide_sz_hit : f32 = ImTrunc(g.FontSize * 0.55)
			p : ImVec2 = node.Pos
			r : ImRect; init(&r, p, p + ImVec2{unhide_sz_hit, unhide_sz_hit})
			unhide_id : ImGuiID = GetID(window, "#UNHIDE")
			KeepAliveID(unhide_id)
			hovered : bool; held : bool
			if ButtonBehavior(r, unhide_id, &hovered, &held, cast(ImGuiButtonFlags)ImGuiButtonFlagsPrivate_.ImGuiButtonFlags_FlattenChildren) { node.WantHiddenTabBarToggle = true }
			else if held && IsMouseDragging(ImGuiMouseButton(0)) {
				// Undock from tab-bar triangle = same as window/collapse menu button
				StartMouseMovingWindowOrNode(window, node, true)
			}

			// FIXME-DOCK: Ideally we'd use ImGuiCol_TitleBgActive/ImGuiCol_TitleBg here, but neither is guaranteed to be visible enough at this sort of size..
			col : ImU32 = GetColorU32(((held && hovered) || (node.IsFocused && !hovered)) ? ImGuiCol_.ImGuiCol_ButtonActive : hovered ? ImGuiCol_.ImGuiCol_ButtonHovered : ImGuiCol_.ImGuiCol_Button)
			AddTriangleFilled(window.DrawList, p, p + ImVec2{unhide_sz_draw, 0.0}, p + ImVec2{0.0, unhide_sz_draw}, col)
		}

		// Scrollbars
		if window.ScrollbarX { Scrollbar(ImGuiAxis.ImGuiAxis_X) }
		if window.ScrollbarY { Scrollbar(ImGuiAxis.ImGuiAxis_Y) }

		// Render resize grips (after their input handling so we don't have a frame of latency)
		if handle_borders_and_resize_grips && (flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoResize) == {} {
			for resize_grip_n : i32 = 0; resize_grip_n < resize_grip_count; resize_grip_n += 1 {
				col : ImU32 = resize_grip_col[resize_grip_n]
				if (col & IM_COL32_A_MASK) == 0 { continue }
				grip : ^ImGuiResizeGripDef = &resize_grip_def[resize_grip_n]
				corner : ImVec2 = ImLerp(window.Pos, window.Pos + window.Size, grip.CornerPosN)
				PathLineTo(window.DrawList, corner + grip.InnerDir * ((resize_grip_n & 1) != 0 ? ImVec2{window_border_size, resize_grip_draw_size} : ImVec2{resize_grip_draw_size, window_border_size}))
				PathLineTo(window.DrawList, corner + grip.InnerDir * ((resize_grip_n & 1) != 0 ? ImVec2{resize_grip_draw_size, window_border_size} : ImVec2{window_border_size, resize_grip_draw_size}))
				PathArcToFast(window.DrawList, ImVec2{corner.x + grip.InnerDir.x * (window_rounding + window_border_size), corner.y + grip.InnerDir.y * (window_rounding + window_border_size)}, window_rounding, grip.AngleMin12, grip.AngleMax12)
				PathFillConvex(window.DrawList, col)
			}
		}

		// Borders (for dock node host they will be rendered over after the tab bar)
		if handle_borders_and_resize_grips && window.DockNodeAsHost == nil { RenderWindowOuterBorders(window) }
	}
	window.DC.NavLayerCurrent = ImGuiNavLayer.ImGuiNavLayer_Main
}

// When inside a dock node, this is handled in DockNodeCalcTabBarLayout() instead.
// Render title text, collapse button, close button
RenderWindowTitleBarContents :: proc(window : ^ImGuiWindow, title_bar_rect : ImRect, name : string, p_open : ^bool)
{
	g : ^ImGuiContext = GImGui
	style : ^ImGuiStyle = &g.Style
	flags : ImGuiWindowFlags = window.Flags

	has_close_button : bool = (p_open != nil)
	has_collapse_button : bool = (flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoCollapse) == {} && (style.WindowMenuButtonPosition != ImGuiDir.ImGuiDir_None)

	// Close & Collapse button are on the Menu NavLayer and don't default focus (unless there's nothing else on that layer)
	// FIXME-NAV: Might want (or not?) to set the equivalent of ImGuiButtonFlags_NoNavFocus so that mouse clicks on standard title bar items don't necessarily set nav/keyboard ref?
	item_flags_backup : ImGuiItemFlags = g.CurrentItemFlags
	g.CurrentItemFlags |= ImGuiItemFlags_.ImGuiItemFlags_NoNavDefaultFocus
	window.DC.NavLayerCurrent = ImGuiNavLayer.ImGuiNavLayer_Menu

	// Layout buttons
	// FIXME: Would be nice to generalize the subtleties expressed here into reusable code.
	pad_l : f32 = style.FramePadding.x
	pad_r : f32 = style.FramePadding.x
	button_sz : f32 = g.FontSize
	close_button_pos : ImVec2
	collapse_button_pos : ImVec2
	if has_close_button {
		close_button_pos = ImVec2{title_bar_rect.Max.x - pad_r - button_sz, title_bar_rect.Min.y + style.FramePadding.y}
		pad_r += button_sz + style.ItemInnerSpacing.x
	}
	if has_collapse_button && style.WindowMenuButtonPosition == ImGuiDir.ImGuiDir_Right {
		collapse_button_pos = ImVec2{title_bar_rect.Max.x - pad_r - button_sz, title_bar_rect.Min.y + style.FramePadding.y}
		pad_r += button_sz + style.ItemInnerSpacing.x
	}
	if has_collapse_button && style.WindowMenuButtonPosition == ImGuiDir.ImGuiDir_Left {
		collapse_button_pos = ImVec2{title_bar_rect.Min.x + pad_l, title_bar_rect.Min.y + style.FramePadding.y}
		pad_l += button_sz + style.ItemInnerSpacing.x
	}

	// Collapse button (submitting first so it gets priority when choosing a navigation init fallback)
	if has_collapse_button { if CollapseButton(GetID(window, "#COLLAPSE"), collapse_button_pos, nil) {
	// Defer actual collapsing to next frame as we are too far in the Begin() function
	window.WantCollapseToggle = true
} }

	// Close button
	if has_close_button { if CloseButton(GetID(window, "#CLOSE"), close_button_pos) { p_open^ = false } }

	window.DC.NavLayerCurrent = ImGuiNavLayer.ImGuiNavLayer_Main
	g.CurrentItemFlags = item_flags_backup

	// Title bar text (with: horizontal alignment, avoiding collapse/close button, optional "unsaved document" marker)
	// FIXME: Refactor text alignment facilities along with RenderText helpers, this is WAY too much messy code..
	marker_size_x : f32 = (flags & ImGuiWindowFlags_.ImGuiWindowFlags_UnsavedDocument) != {} ? button_sz * 0.80 : 0.0
	text_size : ImVec2 = CalcTextSize(name, true) + ImVec2{marker_size_x, 0.0}

	// As a nice touch we try to ensure that centered title text doesn't get affected by visibility of Close/Collapse button,
	// while uncentered title text will still reach edges correctly.
	if pad_l > style.FramePadding.x { pad_l += g.Style.ItemInnerSpacing.x }
	if pad_r > style.FramePadding.x { pad_r += g.Style.ItemInnerSpacing.x }
	if style.WindowTitleAlign.x > 0.0 && style.WindowTitleAlign.x < 1.0 {
		centerness : f32 = ImSaturate(1.0 - ImFabs(style.WindowTitleAlign.x - 0.5) * 2.0); // 0.0f on either edges, 1.0f on center
		pad_extend : f32 = ImMin(ImMax(pad_l, pad_r), GetWidth(title_bar_rect) - pad_l - pad_r - text_size.x)
		pad_l = ImMax(pad_l, pad_extend * centerness)
		pad_r = ImMax(pad_r, pad_extend * centerness)
	}

	layout_r : ImRect; init(&layout_r, title_bar_rect.Min.x + pad_l, title_bar_rect.Min.y, title_bar_rect.Max.x - pad_r, title_bar_rect.Max.y)
	clip_r : ImRect; init(&clip_r, layout_r.Min.x, layout_r.Min.y, ImMin(layout_r.Max.x + g.Style.ItemInnerSpacing.x, title_bar_rect.Max.x), layout_r.Max.y)
	if (flags & ImGuiWindowFlags_.ImGuiWindowFlags_UnsavedDocument) != {} {
		marker_pos : ImVec2
		marker_pos.x = ImClamp(layout_r.Min.x + (GetWidth(layout_r) - text_size.x) * style.WindowTitleAlign.x + text_size.x, layout_r.Min.x, layout_r.Max.x)
		marker_pos.y = (layout_r.Min.y + layout_r.Max.y) * 0.5
		if marker_pos.x > layout_r.Min.x {
			RenderBullet(window.DrawList, marker_pos, GetColorU32(ImGuiCol_.ImGuiCol_Text))
			clip_r.Max.x = ImMin(clip_r.Max.x, marker_pos.x - cast(f32) cast(i32) (marker_size_x * 0.5))
		}
	}
	//if (g.IO.KeyShift) window->DrawList->AddRect(layout_r.Min, layout_r.Max, IM_COL32(255, 128, 0, 255)); // [DEBUG]
	//if (g.IO.KeyCtrl) window->DrawList->AddRect(clip_r.Min, clip_r.Max, IM_COL32(255, 128, 0, 255)); // [DEBUG]
	RenderTextClipped(layout_r.Min, layout_r.Max, name, &text_size, &style.WindowTitleAlign, &clip_r)
}

UpdateWindowParentAndRootLinks :: proc(window : ^ImGuiWindow, flags : ImGuiWindowFlags, parent_window : ^ImGuiWindow)
{
	window.ParentWindow = parent_window
	window.RootWindowForNav = window; window.RootWindowForTitleBarHighlight = window.RootWindowForNav; window.RootWindowDockTree = window.RootWindowForTitleBarHighlight; window.RootWindowPopupTree = window.RootWindowDockTree; window.RootWindow = window.RootWindowPopupTree
	if parent_window != nil && (flags & ImGuiWindowFlags_.ImGuiWindowFlags_ChildWindow) != {} && (flags & ImGuiWindowFlags_.ImGuiWindowFlags_Tooltip) == {} {
		window.RootWindowDockTree = parent_window.RootWindowDockTree
		if !window.DockIsActive && (parent_window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_DockNodeHost) == {} { window.RootWindow = parent_window.RootWindow }
	}
	if parent_window != nil && (flags & ImGuiWindowFlags_.ImGuiWindowFlags_Popup) != {} { window.RootWindowPopupTree = parent_window.RootWindowPopupTree }
	if parent_window != nil && (flags & ImGuiWindowFlags_.ImGuiWindowFlags_Modal) == {} && (flags & (ImGuiWindowFlags_.ImGuiWindowFlags_ChildWindow | ImGuiWindowFlags_.ImGuiWindowFlags_Popup) != {}) {
		// FIXME: simply use _NoTitleBar ?
		window.RootWindowForTitleBarHighlight = parent_window.RootWindowForTitleBarHighlight
	}
	for (window.RootWindowForNav.ChildFlags & ImGuiChildFlags_.ImGuiChildFlags_NavFlattened) != {} {
		IM_ASSERT(window.RootWindowForNav.ParentWindow != nil)
		window.RootWindowForNav = window.RootWindowForNav.ParentWindow
	}
}

// [EXPERIMENTAL] Called by Begin(). NextWindowData is valid at this point.
// This is designed as a toy/test-bed for
UpdateWindowSkipRefresh :: proc(window : ^ImGuiWindow)
{
	g : ^ImGuiContext = GImGui
	window.SkipRefresh = false
	if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_.ImGuiNextWindowDataFlags_HasRefreshPolicy) == {} { return }
	if (g.NextWindowData.RefreshFlagsVal & ImGuiWindowRefreshFlags_.ImGuiWindowRefreshFlags_TryToAvoidRefresh) != {} {
		// FIXME-IDLE: Tests for e.g. mouse clicks or keyboard while focused.
		if window.Appearing {
			// If currently appearing
			return
		}
		if window.Hidden {
			// If was hidden (previous frame)
			return
		}
		if (g.NextWindowData.RefreshFlagsVal & ImGuiWindowRefreshFlags_.ImGuiWindowRefreshFlags_RefreshOnHover) != {} && g.HoveredWindow != nil { if window.RootWindow == g.HoveredWindow.RootWindow || IsWindowWithinBeginStackOf(g.HoveredWindow.RootWindow, window) { return } }
		if (g.NextWindowData.RefreshFlagsVal & ImGuiWindowRefreshFlags_.ImGuiWindowRefreshFlags_RefreshOnFocus) != {} && g.NavWindow != nil { if window.RootWindow == g.NavWindow.RootWindow || IsWindowWithinBeginStackOf(g.NavWindow.RootWindow, window) { return } }
		window.DrawList = nil
		window.SkipRefresh = true
	}
}

SetWindowActiveForSkipRefresh :: proc(window : ^ImGuiWindow)
{
	window.Active = true
	for child in window.DC.ChildWindows.Data[:window.DC.ChildWindows.Size] { if !child.Hidden {
	child.SkipRefresh = true; child.Active = child.SkipRefresh
	SetWindowActiveForSkipRefresh(child)
} }
}

// Windows
// - Begin() = push window to the stack and start appending to it. End() = pop window from the stack.
// - Passing 'bool* p_open != NULL' shows a window-closing widget in the upper-right corner of the window,
//   which clicking will set the boolean to false when clicked.
// - You may append multiple times to the same window during the same frame by calling Begin()/End() pairs multiple times.
//   Some information such as 'flags' or 'p_open' will only be considered by the first call to Begin().
// - Begin() return false to indicate the window is collapsed or fully clipped, so you may early out and omit submitting
//   anything to the window. Always call a matching End() for each Begin() call, regardless of its return value!
//   [Important: due to legacy reason, Begin/End and BeginChild/EndChild are inconsistent with all other functions
//    such as BeginMenu/EndMenu, BeginPopup/EndPopup, etc. where the EndXXX call should only be called if the corresponding
//    BeginXXX function returned true. Begin and BeginChild are the only odd ones out. Will be fixed in a future update.]
// - Note that the bottom of window stack always contains a window called "Debug".
// Push a new Dear ImGui window to add widgets to.
// - A default window called "Debug" is automatically stacked at the beginning of every frame so you can use widgets without explicitly calling a Begin/End pair.
// - Begin/End can be called multiple times during the frame with the same window name to append content.
// - The window name is used as a unique identifier to preserve window information across frames (and save rudimentary information to the .ini file).
//   You can use the "##" or "###" markers to use the same label with different id, or same id with different label. See documentation at the top of this file.
// - Return false when window is collapsed, so you can early out in your code. You always need to call ImGui::End() even if false is returned.
// - Passing 'bool* p_open' displays a Close button on the upper-right corner of the window, the pointed value will be set to false when the button is pressed.
Begin_ :: proc(name : string, p_open : ^bool = nil, flags : ImGuiWindowFlags = {}) -> bool
{
	g : ^ImGuiContext = GImGui
	style : ^ImGuiStyle = &g.Style
	IM_ASSERT(name != ""); // Window name required
	IM_ASSERT(g.WithinFrameScope); // Forgot to call ImGui::NewFrame()
	IM_ASSERT(g.FrameCountEnded != g.FrameCount); // Called ImGui::Render() or ImGui::EndFrame() and haven't called ImGui::NewFrame() again yet

	// Find or create
	window : ^ImGuiWindow = FindWindowByName(name)
	window_just_created : bool = (window == nil)
	if window_just_created { window = CreateNewWindow(name, flags) }

	// [DEBUG] Debug break requested by user
	if g.DebugBreakInWindow == window.ID { IM_DEBUG_BREAK() }

	flags := flags
	// Automatically disable manual moving/resizing when NoInputs is set
	if (flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoInputs) == ImGuiWindowFlags_.ImGuiWindowFlags_NoInputs { flags |= ImGuiWindowFlags_.ImGuiWindowFlags_NoMove | ImGuiWindowFlags_.ImGuiWindowFlags_NoResize }

	current_frame : i32 = g.FrameCount
	first_begin_of_the_frame : bool = (window.LastFrameActive != current_frame)
	window.IsFallbackWindow = (g.CurrentWindowStack.Size == 0 && g.WithinFrameScopeWithImplicitWindow)

	// Update the Appearing flag (note: the BeginDocked() path may also set this to true later)
	window_just_activated_by_user : bool = (window.LastFrameActive < current_frame - 1); // Not using !WasActive because the implicit "Debug" window would always toggle off->on
	if (flags & ImGuiWindowFlags_.ImGuiWindowFlags_Popup) != {} {
		popup_ref : ^ImGuiPopupData = &g.OpenPopupStack.Data[g.BeginPopupStack.Size]
		window_just_activated_by_user |= (window.PopupId != popup_ref.PopupId); // We recycle popups so treat window as activated if popup id changed
		window_just_activated_by_user |= (window != popup_ref.Window)
	}

	// Update Flags, LastFrameActive, BeginOrderXXX fields
	window_was_appearing : bool = window.Appearing
	if first_begin_of_the_frame {
		UpdateWindowInFocusOrderList(window, window_just_created, flags)
		window.Appearing = window_just_activated_by_user
		if window.Appearing { SetWindowConditionAllowFlags(window, ImGuiCond_.ImGuiCond_Appearing, true) }
		window.FlagsPreviousFrame = window.Flags
		window.Flags = cast(ImGuiWindowFlags) flags
		window.ChildFlags = (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_.ImGuiNextWindowDataFlags_HasChildFlags) != {} ? g.NextWindowData.ChildFlags : {}
		window.LastFrameActive = current_frame
		window.LastTimeActive = cast(f32) g.Time
		window.BeginOrderWithinParent = 0
		window.BeginOrderWithinContext = cast(i16) (post_incr(&g.WindowsActiveCount))
	}
	else {
		flags = window.Flags
	}

	// Docking
	// (NB: during the frame dock nodes are created, it is possible that (window->DockIsActive == false) even though (window->DockNode->Windows.Size > 1)
	IM_ASSERT(window.DockNode == nil || window.DockNodeAsHost == nil); // Cannot be both
	if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_.ImGuiNextWindowDataFlags_HasDock) != {} { SetWindowDock(window, g.NextWindowData.DockId, g.NextWindowData.DockCond) }
	if first_begin_of_the_frame {
		has_dock_node : bool = (window.DockId != 0 || window.DockNode != nil)
		new_auto_dock_node : bool = !has_dock_node && GetWindowAlwaysWantOwnTabBar(window)
		dock_node_was_visible : bool = window.DockNodeIsVisible
		dock_tab_was_visible : bool = window.DockTabIsVisible
		if has_dock_node || new_auto_dock_node {
			BeginDocked(window, p_open)
			flags = window.Flags
			if window.DockIsActive {
				IM_ASSERT(window.DockNode != nil)
				g.NextWindowData.Flags &= cast(ImGuiNextWindowDataFlags) ~cast(i32)ImGuiNextWindowDataFlags_.ImGuiNextWindowDataFlags_HasSizeConstraint; // Docking currently override constraints
			}

			// Amend the Appearing flag
			if window.DockTabIsVisible && !dock_tab_was_visible && dock_node_was_visible && !window.Appearing && !window_was_appearing {
				window.Appearing = true
				SetWindowConditionAllowFlags(window, ImGuiCond_.ImGuiCond_Appearing, true)
			}
		}
		else {
			window.DockTabIsVisible = false; window.DockNodeIsVisible = window.DockTabIsVisible; window.DockIsActive = window.DockNodeIsVisible
		}
	}

	// Parent window is latched only on the first call to Begin() of the frame, so further append-calls can be done from a different window stack
	parent_window_in_stack : ^ImGuiWindow = (window.DockIsActive && window.DockNode.HostWindow != nil) ? window.DockNode.HostWindow : empty(&g.CurrentWindowStack) ? nil : back(&g.CurrentWindowStack).Window
	parent_window : ^ImGuiWindow = first_begin_of_the_frame ? ((flags & (ImGuiWindowFlags_.ImGuiWindowFlags_ChildWindow | ImGuiWindowFlags_.ImGuiWindowFlags_Popup)) != {} ? parent_window_in_stack : nil) : window.ParentWindow
	IM_ASSERT(parent_window != nil || (flags & ImGuiWindowFlags_.ImGuiWindowFlags_ChildWindow) == {})

	// We allow window memory to be compacted so recreate the base stack when needed.
	if window.IDStack.Size == 0 { push_back(&window.IDStack, window.ID) }

	// Add to stack
	g.CurrentWindow = window
	resize(&g.CurrentWindowStack, g.CurrentWindowStack.Size + 1)
	window_stack_data : ^ImGuiWindowStackData = back(&g.CurrentWindowStack)
	window_stack_data.Window = window
	window_stack_data.ParentLastItemDataBackup = g.LastItemData
	window_stack_data.DisabledOverrideReenable = (flags & ImGuiWindowFlags_.ImGuiWindowFlags_Tooltip) != {} && (g.CurrentItemFlags & cast(ImGuiItemFlags) ImGuiItemFlagsPrivate_.ImGuiItemFlags_Disabled) != {}
	ErrorRecoveryStoreState(&window_stack_data.StackSizesInBegin)
	g.StackSizesInBeginForCurrentWindow = &window_stack_data.StackSizesInBegin
	if (flags & ImGuiWindowFlags_.ImGuiWindowFlags_ChildMenu) != {} { post_incr(&g.BeginMenuDepth) }

	// Update ->RootWindow and others pointers (before any possible call to FocusWindow)
	if first_begin_of_the_frame {
		UpdateWindowParentAndRootLinks(window, flags, parent_window)
		window.ParentWindowInBeginStack = parent_window_in_stack

		// Focus route
		// There's little point to expose a flag to set this: because the interesting cases won't be using parent_window_in_stack,
		// Use for e.g. linking a tool window in a standalone viewport to a document window, regardless of their Begin() stack parenting. (#6798)
		window.ParentWindowForFocusRoute = (window.RootWindow != window) ? parent_window_in_stack : nil
		if window.ParentWindowForFocusRoute == nil && window.DockNode != nil { if (window.DockNode.MergedFlags & cast(ImGuiDockNodeFlags) ImGuiDockNodeFlagsPrivate_.ImGuiDockNodeFlags_DockedWindowsInFocusRoute) != {} { window.ParentWindowForFocusRoute = window.DockNode.HostWindow } }

		// Override with SetNextWindowClass() field or direct call to SetWindowParentWindowForFocusRoute()
		if window.WindowClass.FocusRouteParentWindowId != 0 {
			window.ParentWindowForFocusRoute = FindWindowByID(window.WindowClass.FocusRouteParentWindowId)
			IM_ASSERT(window.ParentWindowForFocusRoute != nil); // Invalid value for FocusRouteParentWindowId.
		}
	}

	// Add to focus scope stack
	PushFocusScope((window.ChildFlags & ImGuiChildFlags_.ImGuiChildFlags_NavFlattened) != {} ? g.CurrentFocusScopeId : window.ID)
	window.NavRootFocusScopeId = g.CurrentFocusScopeId

	// Add to popup stacks: update OpenPopupStack.Data[] data, push to BeginPopupStack[]
	if (flags & ImGuiWindowFlags_.ImGuiWindowFlags_Popup) != {} {
		popup_ref : ^ImGuiPopupData = &g.OpenPopupStack.Data[g.BeginPopupStack.Size]
		popup_ref.Window = window
		popup_ref.ParentNavLayer = parent_window_in_stack.DC.NavLayerCurrent
		push_back(&g.BeginPopupStack, popup_ref^)
		window.PopupId = popup_ref.PopupId
	}

	// Process SetNextWindow***() calls
	// (FIXME: Consider splitting the HasXXX flags into X/Y components
	window_pos_set_by_api : bool = false
	window_size_x_set_by_api : bool = false; window_size_y_set_by_api : bool = false
	if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_.ImGuiNextWindowDataFlags_HasPos) != {} {
		window_pos_set_by_api = (window.SetWindowPosAllowFlags & g.NextWindowData.PosCond) != {}
		if window_pos_set_by_api && ImLengthSqr(g.NextWindowData.PosPivotVal) > 0.00001 {
			// May be processed on the next frame if this is our first frame and we are measuring size
			// FIXME: Look into removing the branch so everything can go through this same code path for consistency.
			window.SetWindowPosVal = g.NextWindowData.PosVal
			window.SetWindowPosPivot = g.NextWindowData.PosPivotVal
			window.SetWindowPosAllowFlags &= cast(ImGuiCond) ~i32(ImGuiCond_.ImGuiCond_Once | ImGuiCond_.ImGuiCond_FirstUseEver | ImGuiCond_.ImGuiCond_Appearing)
		}
		else {
			SetWindowPos(window, g.NextWindowData.PosVal, g.NextWindowData.PosCond)
		}
	}
	if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_.ImGuiNextWindowDataFlags_HasSize) != {} {
		window_size_x_set_by_api = (window.SetWindowSizeAllowFlags & g.NextWindowData.SizeCond) != {} && (g.NextWindowData.SizeVal.x > 0.0)
		window_size_y_set_by_api = (window.SetWindowSizeAllowFlags & g.NextWindowData.SizeCond) != {} && (g.NextWindowData.SizeVal.y > 0.0)
		if (window.ChildFlags & ImGuiChildFlags_.ImGuiChildFlags_ResizeX) != {} && (window.SetWindowSizeAllowFlags & ImGuiCond_.ImGuiCond_FirstUseEver) == {} {
			// Axis-specific conditions for BeginChild()
			g.NextWindowData.SizeVal.x = window.SizeFull.x
		}
		if (window.ChildFlags & ImGuiChildFlags_.ImGuiChildFlags_ResizeY) != {} && (window.SetWindowSizeAllowFlags & ImGuiCond_.ImGuiCond_FirstUseEver) == {} { g.NextWindowData.SizeVal.y = window.SizeFull.y }
		SetWindowSize(window, g.NextWindowData.SizeVal, g.NextWindowData.SizeCond)
	}
	if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_.ImGuiNextWindowDataFlags_HasScroll) != {} {
		if g.NextWindowData.ScrollVal.x >= 0.0 {
			window.ScrollTarget.x = g.NextWindowData.ScrollVal.x
			window.ScrollTargetCenterRatio.x = 0.0
		}
		if g.NextWindowData.ScrollVal.y >= 0.0 {
			window.ScrollTarget.y = g.NextWindowData.ScrollVal.y
			window.ScrollTargetCenterRatio.y = 0.0
		}
	}
	if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_.ImGuiNextWindowDataFlags_HasContentSize) != {} { window.ContentSizeExplicit = g.NextWindowData.ContentSizeVal }
	else if first_begin_of_the_frame { window.ContentSizeExplicit = ImVec2{0.0, 0.0} }
	if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_.ImGuiNextWindowDataFlags_HasWindowClass) != {} { window.WindowClass = g.NextWindowData.WindowClass }
	if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_.ImGuiNextWindowDataFlags_HasCollapsed) != {} { SetWindowCollapsed(window, g.NextWindowData.CollapsedVal, g.NextWindowData.CollapsedCond) }
	if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_.ImGuiNextWindowDataFlags_HasFocus) != {} { FocusWindow(window) }
	if window.Appearing { SetWindowConditionAllowFlags(window, ImGuiCond_.ImGuiCond_Appearing, false) }

	// [EXPERIMENTAL] Skip Refresh mode
	UpdateWindowSkipRefresh(window)

	// Nested root windows (typically tooltips) override disabled state
	if window_stack_data.DisabledOverrideReenable && window.RootWindow == window { BeginDisabledOverrideReenable() }

	// We intentionally set g.CurrentWindow to NULL to prevent usage until when the viewport is set, then will call SetCurrentWindow()
	g.CurrentWindow = nil

	// When reusing window again multiple times a frame, just append content (don't need to setup again)
	if first_begin_of_the_frame && !window.SkipRefresh {
		// Initialize
		window_is_child_tooltip : bool = (flags & ImGuiWindowFlags_.ImGuiWindowFlags_ChildWindow) != {} && (flags & ImGuiWindowFlags_.ImGuiWindowFlags_Tooltip) != {}; // FIXME-WIP: Undocumented behavior of Child+Tooltip for pinned tooltip (#1345)
		window_just_appearing_after_hidden_for_resize : bool = (window.HiddenFramesCannotSkipItems > 0)
		window.Active = true
		window.HasCloseButton = (p_open != nil)
		window.ClipRect = {{-FLT_MAX, -FLT_MAX}, {+FLT_MAX, +FLT_MAX}}
		resize(&window.IDStack, 1)
		ImDrawList__ResetForNewFrame(window.DrawList)
		window.DC.CurrentTableIdx = -1
		if (flags & ImGuiWindowFlags_.ImGuiWindowFlags_DockNodeHost) != {} {
			ChannelsSplit(window.DrawList, 2)
			ChannelsSetCurrent(window.DrawList, DOCKING_HOST_DRAW_CHANNEL_FG); // Render decorations on channel 1 as we will render the backgrounds manually later
		}

		// Restore buffer capacity when woken from a compacted state, to avoid
		if window.MemoryCompacted { GcAwakeTransientWindowBuffers(window) }

		// Update stored window name when it changes (which can _only_ happen with the "###" operator, so the ID would stay unchanged).
		// The title bar always display the 'name' parameter, so we only update the string storage if it needs to be visible to the end-user elsewhere.
		window_title_visible_elsewhere : bool = false
		if (window.Viewport != nil && window.Viewport.Window == window) || (window.DockIsActive) { window_title_visible_elsewhere = true }
		else if g.NavWindowingListWindow != nil && (window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoNavFocus) == {} {
			// Window titles visible when using CTRL+TAB
			window_title_visible_elsewhere = true
		}
		if window_title_visible_elsewhere && !window_just_created && name != window.Name {
			buf_len : uint = cast(uint) window.NameBufLen
			window.Name = ImStrdupcpy(window.Name, &buf_len, name)
			window.NameBufLen = cast(i32) buf_len
		}

		// UPDATE CONTENTS SIZE, UPDATE HIDDEN STATUS

		// Update contents size from last frame for auto-fitting (or use explicit size)
		CalcWindowContentSizes(window, &window.ContentSize, &window.ContentSizeIdeal)

		// FIXME: These flags are decremented before they are used. This means that in order to have these fields produce their intended behaviors
		// for one frame we must set them to at least 2, which is counter-intuitive. HiddenFramesCannotSkipItems is a more complicated case because
		// it has a single usage before this code block and may be set below before it is finally checked.
		if window.HiddenFramesCanSkipItems > 0 { post_decr(&window.HiddenFramesCanSkipItems) }
		if window.HiddenFramesCannotSkipItems > 0 { post_decr(&window.HiddenFramesCannotSkipItems) }
		if window.HiddenFramesForRenderOnly > 0 { post_decr(&window.HiddenFramesForRenderOnly) }

		// Hide new windows for one frame until they calculate their size
		if window_just_created && (!window_size_x_set_by_api || !window_size_y_set_by_api) { window.HiddenFramesCannotSkipItems = 1 }

		// Hide popup/tooltip window when re-opening while we measure size (because we recycle the windows)
		// We reset Size/ContentSize for reappearing popups/tooltips early in this function, so further code won't be tempted to use the old size.
		if window_just_activated_by_user && (flags & (ImGuiWindowFlags_.ImGuiWindowFlags_Popup | ImGuiWindowFlags_.ImGuiWindowFlags_Tooltip)) != {} {
			window.HiddenFramesCannotSkipItems = 1
			if (flags & ImGuiWindowFlags_.ImGuiWindowFlags_AlwaysAutoResize) != {} {
				if !window_size_x_set_by_api { window.SizeFull.x = 0.; window.Size.x = window.SizeFull.x }
				if !window_size_y_set_by_api { window.SizeFull.y = 0.; window.Size.y = window.SizeFull.y }
				window.ContentSizeIdeal = ImVec2{0., 0.}; window.ContentSize = window.ContentSizeIdeal
			}
		}

		// SELECT VIEWPORT
		// We need to do this before using any style/font sizes, as viewport with a different DPI may affect font sizes.

		WindowSelectViewport(window)
		SetCurrentViewport(window, window.Viewport)
		window.FontDpiScale = (g.IO.ConfigFlags & ImGuiConfigFlags_.ImGuiConfigFlags_DpiEnableScaleFonts) != {} ? window.Viewport.DpiScale : 1.0
		SetCurrentWindow(window)
		flags = window.Flags

		// LOCK BORDER SIZE AND PADDING FOR THE FRAME (so that altering them doesn't cause inconsistencies)
		// We read Style data after the call to UpdateSelectWindowViewport() which might be swapping the style.

		if !window.DockIsActive && (flags & ImGuiWindowFlags_.ImGuiWindowFlags_ChildWindow) != {} { window.WindowBorderSize = style.ChildBorderSize }
		else { window.WindowBorderSize = ((flags & (ImGuiWindowFlags_.ImGuiWindowFlags_Popup | ImGuiWindowFlags_.ImGuiWindowFlags_Tooltip)) != {} && (flags & ImGuiWindowFlags_.ImGuiWindowFlags_Modal) == {}) ? style.PopupBorderSize : style.WindowBorderSize }
		window.WindowPadding = style.WindowPadding
		if !window.DockIsActive && (flags & ImGuiWindowFlags_.ImGuiWindowFlags_ChildWindow) != {} && (flags & ImGuiWindowFlags_.ImGuiWindowFlags_Popup) == {} && (window.ChildFlags & ImGuiChildFlags_.ImGuiChildFlags_AlwaysUseWindowPadding) == {} && window.WindowBorderSize == 0.0 { window.WindowPadding = ImVec2{0.0, (flags & ImGuiWindowFlags_.ImGuiWindowFlags_MenuBar) != {} ? style.WindowPadding.y : 0.0} }

		// Lock menu offset so size calculation can use it as menu-bar windows need a minimum size.
		window.DC.MenuBarOffset.x = ImMax(ImMax(window.WindowPadding.x, style.ItemSpacing.x), g.NextWindowData.MenuBarOffsetMinVal.x)
		window.DC.MenuBarOffset.y = g.NextWindowData.MenuBarOffsetMinVal.y
		window.TitleBarHeight = (flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoTitleBar) != {} ? 0.0 : g.FontSize + g.Style.FramePadding.y * 2.0
		window.MenuBarHeight = (flags & ImGuiWindowFlags_.ImGuiWindowFlags_MenuBar) != {} ? window.DC.MenuBarOffset.y + g.FontSize + g.Style.FramePadding.y * 2.0 : 0.0

		// Depending on condition we use previous or current window size to compare against contents size to decide if a scrollbar should be visible.
		// Those flags will be altered further down in the function depending on more conditions.
		use_current_size_for_scrollbar_x : bool = window_just_created
		use_current_size_for_scrollbar_y : bool = window_just_created
		if window_size_x_set_by_api && window.ContentSizeExplicit.x != 0.0 { use_current_size_for_scrollbar_x = true }
		if window_size_y_set_by_api && window.ContentSizeExplicit.y != 0.0 {
			// #7252
			use_current_size_for_scrollbar_y = true
		}

		// Collapse window by double-clicking on title bar
		// At this point we don't have a clipping rectangle setup yet, so we can use the title bar area for hit detection and drawing
		if (flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoTitleBar) == {} && (flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoCollapse) == {} && !window.DockIsActive {
			// We don't use a regular button+id to test for double-click on title bar (mostly due to legacy reason, could be fixed),
			// so verify that we don't have items over the title bar.
			title_bar_rect : ImRect = TitleBarRect(window)
			if g.HoveredWindow == window && g.HoveredId == 0 && g.HoveredIdPreviousFrame == 0 && g.ActiveId == 0 && IsMouseHoveringRect(title_bar_rect.Min, title_bar_rect.Max) { if g.IO.MouseClickedCount[0] == 2 && GetKeyOwner(ImGuiKey.ImGuiKey_MouseLeft) == ImGuiKeyOwner_NoOwner { window.WantCollapseToggle = true } }
			if window.WantCollapseToggle {
				window.Collapsed = !window.Collapsed
				if !window.Collapsed { use_current_size_for_scrollbar_y = true }
				MarkIniSettingsDirty(window)
			}
		}
		else {
			window.Collapsed = false
		}
		window.WantCollapseToggle = false

		// SIZE

		// Outer Decoration Sizes
		// (we need to clear ScrollbarSize immediately as CalcWindowAutoFitSize() needs it and can be called from other locations).
		scrollbar_sizes_from_last_frame : ImVec2 = window.ScrollbarSizes
		window.DecoOuterSizeX1 = 0.0
		window.DecoOuterSizeX2 = 0.0
		window.DecoOuterSizeY1 = window.TitleBarHeight + window.MenuBarHeight
		window.DecoOuterSizeY2 = 0.0
		window.ScrollbarSizes = ImVec2{0.0, 0.0}

		// Calculate auto-fit size, handle automatic resize
		size_auto_fit : ImVec2 = CalcWindowAutoFitSize(window, window.ContentSizeIdeal)
		if (flags & ImGuiWindowFlags_.ImGuiWindowFlags_AlwaysAutoResize) != {} && !window.Collapsed {
			// Using SetNextWindowSize() overrides ImGuiWindowFlags_AlwaysAutoResize, so it can be used on tooltips/popups, etc.
			if !window_size_x_set_by_api {
				window.SizeFull.x = size_auto_fit.x
				use_current_size_for_scrollbar_x = true
			}
			if !window_size_y_set_by_api {
				window.SizeFull.y = size_auto_fit.y
				use_current_size_for_scrollbar_y = true
			}
		}
		else if window.AutoFitFramesX > 0 || window.AutoFitFramesY > 0 {
			// Auto-fit may only grow window during the first few frames
			// We still process initial auto-fit on collapsed windows to get a window width, but otherwise don't honor ImGuiWindowFlags_AlwaysAutoResize when collapsed.
			if !window_size_x_set_by_api && window.AutoFitFramesX > 0 {
				window.SizeFull.x = window.AutoFitOnlyGrows ? ImMax(window.SizeFull.x, size_auto_fit.x) : size_auto_fit.x
				use_current_size_for_scrollbar_x = true
			}
			if !window_size_y_set_by_api && window.AutoFitFramesY > 0 {
				window.SizeFull.y = window.AutoFitOnlyGrows ? ImMax(window.SizeFull.y, size_auto_fit.y) : size_auto_fit.y
				use_current_size_for_scrollbar_y = true
			}
			if !window.Collapsed { MarkIniSettingsDirty(window) }
		}

		// Apply minimum/maximum window size constraints and final size
		window.SizeFull = CalcWindowSizeAfterConstraint(window, window.SizeFull)
		window.Size = window.Collapsed && (flags & ImGuiWindowFlags_.ImGuiWindowFlags_ChildWindow) == {} ? GetSize(TitleBarRect(window)) : window.SizeFull

		// POSITION

		// Popup latch its initial position, will position itself when it appears next frame
		if window_just_activated_by_user {
			window.AutoPosLastDirection = ImGuiDir.ImGuiDir_None
			if (flags & ImGuiWindowFlags_.ImGuiWindowFlags_Popup) != {} && (flags & ImGuiWindowFlags_.ImGuiWindowFlags_Modal) == {} && !window_pos_set_by_api {
				// FIXME: BeginPopup() could use SetNextWindowPos()
				window.Pos = back(&g.BeginPopupStack).OpenPopupPos
			}
		}

		// Position child window
		if (flags & ImGuiWindowFlags_.ImGuiWindowFlags_ChildWindow) != {} {
			IM_ASSERT(parent_window != nil && parent_window.Active)
			window.BeginOrderWithinParent = cast(i16) parent_window.DC.ChildWindows.Size
			push_back(&parent_window.DC.ChildWindows, window)
			if (flags & ImGuiWindowFlags_.ImGuiWindowFlags_Popup) == {} && !window_pos_set_by_api && !window_is_child_tooltip { window.Pos = parent_window.DC.CursorPos }
		}

		window_pos_with_pivot : bool = (window.SetWindowPosVal.x != FLT_MAX && window.HiddenFramesCannotSkipItems == 0)
		if window_pos_with_pivot {
			// Position given a pivot (e.g. for centering)
			SetWindowPos(window, window.SetWindowPosVal - window.Size * window.SetWindowPosPivot, ImGuiCond.ImGuiCond_None)
		}
		else if (flags & ImGuiWindowFlags_.ImGuiWindowFlags_ChildMenu) != {} { window.Pos = FindBestWindowPosForPopup(window) }
		else if (flags & ImGuiWindowFlags_.ImGuiWindowFlags_Popup) != {} && !window_pos_set_by_api && window_just_appearing_after_hidden_for_resize { window.Pos = FindBestWindowPosForPopup(window) }
		else if (flags & ImGuiWindowFlags_.ImGuiWindowFlags_Tooltip) != {} && !window_pos_set_by_api && !window_is_child_tooltip { window.Pos = FindBestWindowPosForPopup(window) }

		// Late create viewport if we don't fit within our current host viewport.
		if window.ViewportAllowPlatformMonitorExtend >= 0 && !window.ViewportOwned && (window.Viewport.Flags & ImGuiViewportFlags_.ImGuiViewportFlags_IsMinimized) == {} {
			if !Contains(GetMainRect(window.Viewport), Rect(window)) {
				// This is based on the assumption that the DPI will be known ahead (same as the DPI of the selection done in UpdateSelectWindowViewport)
				//ImGuiViewport* old_viewport = window->Viewport;
				window.Viewport = AddUpdateViewport(window, window.ID, window.Pos, window.Size, ImGuiViewportFlags_.ImGuiViewportFlags_NoFocusOnAppearing)

				// FIXME-DPI
				//IM_ASSERT(old_viewport->DpiScale == window->Viewport->DpiScale); // FIXME-DPI: Something went wrong
				SetCurrentViewport(window, window.Viewport)
				window.FontDpiScale = (g.IO.ConfigFlags & ImGuiConfigFlags_.ImGuiConfigFlags_DpiEnableScaleFonts) != {} ? window.Viewport.DpiScale : 1.0
				SetCurrentWindow(window)
			}
		}

		if window.ViewportOwned { WindowSyncOwnedViewport(window, parent_window_in_stack) }

		// Calculate the range of allowed position for that window (to be movable and visible past safe area padding)
		// When clamping to stay visible, we will enforce that window->Pos stays inside of visibility_rect.
		viewport_rect : ImRect = GetMainRect(window.Viewport)
		viewport_work_rect : ImRect = GetWorkRect(window.Viewport)
		visibility_padding : ImVec2 = ImMax(style.DisplayWindowPadding, style.DisplaySafeAreaPadding)
		visibility_rect : ImRect; init(&visibility_rect, viewport_work_rect.Min + visibility_padding, viewport_work_rect.Max - visibility_padding)

		// Clamp position/size so window stays visible within its viewport or monitor
		// Ignore zero-sized display explicitly to avoid losing positions if a window manager reports zero-sized window when initializing or minimizing.
		// FIXME: Similar to code in GetWindowAllowedExtentRect()
		if !window_pos_set_by_api && (flags & ImGuiWindowFlags_.ImGuiWindowFlags_ChildWindow) == {} {
			if !window.ViewportOwned && GetWidth(viewport_rect) > 0 && GetHeight(viewport_rect) > 0.0 {
				ClampWindowPos(window, visibility_rect)
			}
			else if window.ViewportOwned && g.PlatformIO.Monitors.Size > 0 {
				if g.MovingWindow != nil && window.RootWindowDockTree == g.MovingWindow.RootWindowDockTree {
					// While moving windows we allow them to straddle monitors (#7299, #3071)
					visibility_rect = g.PlatformMonitorsFullWorkRect
				}
				else {
					// When not moving ensure visible in its monitor
					// Lost windows (e.g. a monitor disconnected) will naturally moved to the fallback/dummy monitor aka the main viewport.
					monitor : ^ImGuiPlatformMonitor = GetViewportPlatformMonitor(window.Viewport)
					visibility_rect = ImRect{monitor.WorkPos, monitor.WorkPos + monitor.WorkSize}
				}
				Expand(&visibility_rect, -visibility_padding)
				ClampWindowPos(window, visibility_rect)
			}
		}
		window.Pos = ImTrunc(window.Pos)

		// Lock window rounding for the frame (so that altering them doesn't cause inconsistencies)
		// Large values tend to lead to variety of artifacts and are not recommended.
		if window.ViewportOwned || window.DockIsActive { window.WindowRounding = 0.0 }
		else { window.WindowRounding = (flags & ImGuiWindowFlags_.ImGuiWindowFlags_ChildWindow) != {} ? style.ChildRounding : ((flags & ImGuiWindowFlags_.ImGuiWindowFlags_Popup) != {} && (flags & ImGuiWindowFlags_.ImGuiWindowFlags_Modal) == {}) ? style.PopupRounding : style.WindowRounding }

		// For windows with title bar or menu bar, we clamp to FrameHeight(FontSize + FramePadding.y * 2.0f) to completely hide artifacts.
		//if ((window->Flags & ImGuiWindowFlags_MenuBar) || !(window->Flags & ImGuiWindowFlags_NoTitleBar))
		//    window->WindowRounding = ImMin(window->WindowRounding, g.FontSize + style.FramePadding.y * 2.0f);

		// Apply window focus (new and reactivated windows are moved to front)
		want_focus : bool = false
		if window_just_activated_by_user && (flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoFocusOnAppearing) == {} {
			if (flags & ImGuiWindowFlags_.ImGuiWindowFlags_Popup) != {} { want_focus = true }
			else if (window.DockIsActive || (flags & ImGuiWindowFlags_.ImGuiWindowFlags_ChildWindow) == {}) && (flags & ImGuiWindowFlags_.ImGuiWindowFlags_Tooltip) == {} { want_focus = true }
		}

		// [Test Engine] Register whole window in the item system (before submitting further decorations)
		when IMGUI_ENABLE_TEST_ENGINE { /* @gen ifdef */
		if g.TestEngineHookItems {
			IM_ASSERT(window.IDStack.Size == 1)
			window.IDStack.Size = 0; // As window->IDStack[0] == window->ID here, make sure TestEngine doesn't erroneously see window as parent of itself.
			window.DC.NavLayerCurrent = ImGuiNavLayer.ImGuiNavLayer_Menu
			IMGUI_TEST_ENGINE_ITEM_ADD(window.ID, Rect(window), nil)
			when IMGUI_ENABLE_TEST_ENGINE {
				if(g.TestEngineHookItems) {
					ImGuiTestEngineHook_ItemInfo(g, window.ID, window.Name, (g.HoveredWindow == window) ? ImGuiItemStatusFlags_.ImGuiItemStatusFlags_HoveredRect : {})
				}
			}
			window.IDStack.Size = 1
			window.DC.NavLayerCurrent = ImGuiNavLayer.ImGuiNavLayer_Main

		}
		} // preproc endif

		// Decide if we are going to handle borders and resize grips
		handle_borders_and_resize_grips : bool = (window.DockNodeAsHost != nil || !window.DockIsActive)

		// Handle manual resize: Resize Grips, Borders, Gamepad
		border_hovered := ImGuiDir(-1); border_held := ImGuiDir(-1)
		resize_grip_col : [4]ImU32 = {}
		resize_grip_count : i32 = ((flags & ImGuiWindowFlags_.ImGuiWindowFlags_ChildWindow) != {} && (flags & ImGuiWindowFlags_.ImGuiWindowFlags_Popup) == {}) ? 0 : g.IO.ConfigWindowsResizeFromEdges ? 2 : 1; // Allow resize from lower-left if we have the mouse cursor feedback for it.
		resize_grip_draw_size : f32 = IM_TRUNC(ImMax(g.FontSize * 1.10, window.WindowRounding + 1.0 + g.FontSize * 0.2))
		if handle_borders_and_resize_grips && !window.Collapsed {
			if auto_fit_mask : i32 = UpdateWindowManualResize(window, size_auto_fit, &border_hovered, &border_held, resize_grip_count, &resize_grip_col, visibility_rect); auto_fit_mask != 0 {
				if (auto_fit_mask & (1 << cast(u32) ImGuiAxis.ImGuiAxis_X)) != 0 { use_current_size_for_scrollbar_x = true }
				if (auto_fit_mask & (1 << cast(u32) ImGuiAxis.ImGuiAxis_Y)) != 0 { use_current_size_for_scrollbar_y = true }
			}
		}
		window.ResizeBorderHovered = cast(i8) border_hovered
		window.ResizeBorderHeld = cast(i8) border_held

		// Synchronize window --> viewport again and one last time (clamping and manual resize may have affected either)
		if window.ViewportOwned {
			if !window.Viewport.PlatformRequestMove { window.Viewport.Pos = window.Pos }
			if !window.Viewport.PlatformRequestResize { window.Viewport.Size = window.Size }
			UpdateWorkRect(window.Viewport)
			viewport_rect = GetMainRect(window.Viewport)
		}

		// Save last known viewport position within the window itself (so it can be saved in .ini file and restored)
		window.ViewportPos = window.Viewport.Pos

		// SCROLLBAR VISIBILITY

		// Update scrollbar visibility (based on the Size that was effective during last frame or the auto-resized Size).
		if !window.Collapsed {
			// When reading the current size we need to read it after size constraints have been applied.
			// Intentionally use previous frame values for InnerRect and ScrollbarSizes.
			// And when we use window->DecorationUp here it doesn't have ScrollbarSizes.y applied yet.
			avail_size_from_current_frame : ImVec2 = ImVec2{window.SizeFull.x, window.SizeFull.y - (window.DecoOuterSizeY1 + window.DecoOuterSizeY2)}
			avail_size_from_last_frame : ImVec2 = GetSize(window.InnerRect) + scrollbar_sizes_from_last_frame
			needed_size_from_last_frame : ImVec2 = window_just_created ? ImVec2{0, 0} : window.ContentSize + window.WindowPadding * 2.0
			size_x_for_scrollbars : f32 = use_current_size_for_scrollbar_x ? avail_size_from_current_frame.x : avail_size_from_last_frame.x
			size_y_for_scrollbars : f32 = use_current_size_for_scrollbar_y ? avail_size_from_current_frame.y : avail_size_from_last_frame.y
			//bool scrollbar_y_from_last_frame = window->ScrollbarY; // FIXME: May want to use that in the ScrollbarX expression? How many pros vs cons?
			window.ScrollbarY = (flags & ImGuiWindowFlags_.ImGuiWindowFlags_AlwaysVerticalScrollbar) != {} || ((needed_size_from_last_frame.y > size_y_for_scrollbars) && (flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoScrollbar) == {})
			window.ScrollbarX = (flags & ImGuiWindowFlags_.ImGuiWindowFlags_AlwaysHorizontalScrollbar) != {} || ((needed_size_from_last_frame.x > size_x_for_scrollbars - (window.ScrollbarY ? style.ScrollbarSize : 0.0)) && (flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoScrollbar) == {} && (flags & ImGuiWindowFlags_.ImGuiWindowFlags_HorizontalScrollbar) != {})
			if window.ScrollbarX && !window.ScrollbarY { window.ScrollbarY = (needed_size_from_last_frame.y > size_y_for_scrollbars - style.ScrollbarSize) && (flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoScrollbar) == {} }
			window.ScrollbarSizes = ImVec2{window.ScrollbarY ? style.ScrollbarSize : 0.0, window.ScrollbarX ? style.ScrollbarSize : 0.0}

			// Amend the partially filled window->DecorationXXX values.
			window.DecoOuterSizeX2 += window.ScrollbarSizes.x
			window.DecoOuterSizeY2 += window.ScrollbarSizes.y
		}

		// UPDATE RECTANGLES (1- THOSE NOT AFFECTED BY SCROLLING)
		// Update various regions. Variables they depend on should be set above in this function.
		// We set this up after processing the resize grip so that our rectangles doesn't lag by a frame.

		// Outer rectangle
		// Not affected by window border size. Used by:
		// - FindHoveredWindow() (w/ extra padding when border resize is enabled)
		// - Begin() initial clipping rect for drawing window background and borders.
		// - Begin() clipping whole child
		host_rect : ImRect = ((flags & ImGuiWindowFlags_.ImGuiWindowFlags_ChildWindow) != {} && (flags & ImGuiWindowFlags_.ImGuiWindowFlags_Popup) == {} && !window_is_child_tooltip) ? parent_window.ClipRect : viewport_rect
		outer_rect : ImRect = Rect(window)
		title_bar_rect : ImRect = TitleBarRect(window)
		window.OuterRectClipped = outer_rect
		if window.DockIsActive { window.OuterRectClipped.Min.y += window.TitleBarHeight }
		ClipWith(&window.OuterRectClipped, host_rect)

		// Inner rectangle
		// Not affected by window border size. Used by:
		// - InnerClipRect
		// - ScrollToRectEx()
		// - NavUpdatePageUpPageDown()
		// - Scrollbar()
		window.InnerRect.Min.x = window.Pos.x + window.DecoOuterSizeX1
		window.InnerRect.Min.y = window.Pos.y + window.DecoOuterSizeY1
		window.InnerRect.Max.x = window.Pos.x + window.Size.x - window.DecoOuterSizeX2
		window.InnerRect.Max.y = window.Pos.y + window.Size.y - window.DecoOuterSizeY2

		// Inner clipping rectangle.
		// - Extend a outside of normal work region up to borders.
		// - This is to allow e.g. Selectable or CollapsingHeader or some separators to cover that space.
		// - It also makes clipped items be more noticeable.
		// - And is consistent on both axis (prior to 2024/05/03 ClipRect used WindowPadding.x * 0.5f on left and right edge), see #3312
		// - Force round operator last to ensure that e.g. (int)(max.x-min.x) in user's render code produce correct result.
		// Note that if our window is collapsed we will end up with an inverted (~null) clipping rectangle which is the correct behavior.
		// Affected by window/frame border size. Used by:
		// - Begin() initial clip rect
		top_border_size : f32 = (((flags & ImGuiWindowFlags_.ImGuiWindowFlags_MenuBar) != {} || (flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoTitleBar) == {}) ? style.FrameBorderSize : window.WindowBorderSize)

		// Try to match the fact that our border is drawn centered over the window rectangle, rather than inner.
		// This is why we do a *0.5f here. We don't currently even technically support large values for WindowBorderSize,
		// see e.g #7887 #7888, but may do after we move the window border to become an inner border (and then we can remove the 0.5f here).
		window.InnerClipRect.Min.x = ImFloor(0.5 + window.InnerRect.Min.x + window.WindowBorderSize * 0.5)
		window.InnerClipRect.Min.y = ImFloor(0.5 + window.InnerRect.Min.y + top_border_size * 0.5)
		window.InnerClipRect.Max.x = ImFloor(window.InnerRect.Max.x - window.WindowBorderSize * 0.5)
		window.InnerClipRect.Max.y = ImFloor(window.InnerRect.Max.y - window.WindowBorderSize * 0.5)
		ClipWithFull(&window.InnerClipRect, host_rect)

		// Default item width. Make it proportional to window size if window manually resizes
		if window.Size.x > 0.0 && (flags & ImGuiWindowFlags_.ImGuiWindowFlags_Tooltip) == {} && (flags & ImGuiWindowFlags_.ImGuiWindowFlags_AlwaysAutoResize) == {} { window.ItemWidthDefault = ImTrunc(window.Size.x * 0.65) }
		else { window.ItemWidthDefault = ImTrunc(g.FontSize * 16.0) }

		// SCROLLING

		// Lock down maximum scrolling
		// The value of ScrollMax are ahead from ScrollbarX/ScrollbarY which is intentionally using InnerRect from previous rect in order to accommodate
		// for right/bottom aligned items without creating a scrollbar.
		window.ScrollMax.x = ImMax(f32(0.0), window.ContentSize.x + window.WindowPadding.x * 2.0 - GetWidth(window.InnerRect))
		window.ScrollMax.y = ImMax(f32(0.0), window.ContentSize.y + window.WindowPadding.y * 2.0 - GetHeight(window.InnerRect))

		// Apply scrolling
		window.Scroll = CalcNextScrollFromScrollTargetAndClamp(window)
		window.ScrollTarget = ImVec2{FLT_MAX, FLT_MAX}
		window.DecoInnerSizeY1 = 0.0; window.DecoInnerSizeX1 = window.DecoInnerSizeY1

		// DRAWING

		// Setup draw list and outer clipping rectangle
		IM_ASSERT(window.DrawList.CmdBuffer.Size == 1 && window.DrawList.CmdBuffer.Data[0].ElemCount == 0)
		PushTextureID(window.DrawList, g.Font.ContainerAtlas.TexID)
		PushClipRect(host_rect.Min, host_rect.Max, false)

		// Child windows can render their decoration (bg color, border, scrollbars, etc.) within their parent to save a draw call (since 1.71)
		// When using overlapping child windows, this will break the assumption that child z-order is mapped to submission order.
		// FIXME: User code may rely on explicit sorting of overlapping child window and would need to disable this somehow. Please get in contact if you are affected (github #4493)
		is_undocked_or_docked_visible : bool = !window.DockIsActive || window.DockTabIsVisible
		if is_undocked_or_docked_visible {
			render_decorations_in_parent : bool = false
			if (flags & ImGuiWindowFlags_.ImGuiWindowFlags_ChildWindow) != {} && (flags & ImGuiWindowFlags_.ImGuiWindowFlags_Popup) == {} && !window_is_child_tooltip {
				// - We test overlap with the previous child window only (testing all would end up being O(log N) not a good investment here)
				// - We disable this when the parent window has zero vertices, which is a common pattern leading to laying out multiple overlapping childs
				previous_child : ^ImGuiWindow = parent_window.DC.ChildWindows.Size >= 2 ? parent_window.DC.ChildWindows.Data[parent_window.DC.ChildWindows.Size - 2] : nil
				previous_child_overlapping : bool = previous_child != nil ? Overlaps(Rect(previous_child), Rect(window)) : false
				parent_is_empty : bool = (parent_window.DrawList.VtxBuffer.Size == 0)
				if back(&window.DrawList.CmdBuffer).ElemCount == 0 && !parent_is_empty && !previous_child_overlapping { render_decorations_in_parent = true }
			}
			if render_decorations_in_parent { window.DrawList = parent_window.DrawList }

			// Handle title bar, scrollbar, resize grips and resize borders
			window_to_highlight : ^ImGuiWindow = g.NavWindowingTarget != nil ? g.NavWindowingTarget : g.NavWindow
			title_bar_is_highlight : bool = want_focus || (window_to_highlight != nil && (window.RootWindowForTitleBarHighlight == window_to_highlight.RootWindowForTitleBarHighlight || (window.DockNode != nil && window.DockNode == window_to_highlight.DockNode)))
			RenderWindowDecorations(window, title_bar_rect, title_bar_is_highlight, handle_borders_and_resize_grips, resize_grip_count, resize_grip_col, resize_grip_draw_size)

			if render_decorations_in_parent { window.DrawList = &window.DrawListInst }
		}

		// UPDATE RECTANGLES (2- THOSE AFFECTED BY SCROLLING)

		// Work rectangle.
		// Affected by window padding and border size. Used by:
		// - Columns() for right-most edge
		// - TreeNode(), CollapsingHeader() for right-most edge
		// - BeginTabBar() for right-most edge
		allow_scrollbar_x : bool = (flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoScrollbar) == {} && (flags & ImGuiWindowFlags_.ImGuiWindowFlags_HorizontalScrollbar) != {}
		allow_scrollbar_y : bool = (flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoScrollbar) == {}
		work_rect_size_x : f32 = (window.ContentSizeExplicit.x != 0.0 ? window.ContentSizeExplicit.x : ImMax(allow_scrollbar_x ? window.ContentSize.x : 0.0, window.Size.x - window.WindowPadding.x * 2.0 - (window.DecoOuterSizeX1 + window.DecoOuterSizeX2)))
		work_rect_size_y : f32 = (window.ContentSizeExplicit.y != 0.0 ? window.ContentSizeExplicit.y : ImMax(allow_scrollbar_y ? window.ContentSize.y : 0.0, window.Size.y - window.WindowPadding.y * 2.0 - (window.DecoOuterSizeY1 + window.DecoOuterSizeY2)))
		window.WorkRect.Min.x = ImTrunc(window.InnerRect.Min.x - window.Scroll.x + ImMax(window.WindowPadding.x, window.WindowBorderSize))
		window.WorkRect.Min.y = ImTrunc(window.InnerRect.Min.y - window.Scroll.y + ImMax(window.WindowPadding.y, window.WindowBorderSize))
		window.WorkRect.Max.x = window.WorkRect.Min.x + work_rect_size_x
		window.WorkRect.Max.y = window.WorkRect.Min.y + work_rect_size_y
		window.ParentWorkRect = window.WorkRect

		// [LEGACY] Content Region
		// FIXME-OBSOLETE: window->ContentRegionRect.Max is currently very misleading / partly faulty, but some BeginChild() patterns relies on it.
		// Unless explicit content size is specified by user, this currently represent the region leading to no scrolling.
		// Used by:
		// - Mouse wheel scrolling + many other things
		window.ContentRegionRect.Min.x = window.Pos.x - window.Scroll.x + window.WindowPadding.x + window.DecoOuterSizeX1
		window.ContentRegionRect.Min.y = window.Pos.y - window.Scroll.y + window.WindowPadding.y + window.DecoOuterSizeY1
		window.ContentRegionRect.Max.x = window.ContentRegionRect.Min.x + (window.ContentSizeExplicit.x != 0.0 ? window.ContentSizeExplicit.x : (window.Size.x - window.WindowPadding.x * 2.0 - (window.DecoOuterSizeX1 + window.DecoOuterSizeX2)))
		window.ContentRegionRect.Max.y = window.ContentRegionRect.Min.y + (window.ContentSizeExplicit.y != 0.0 ? window.ContentSizeExplicit.y : (window.Size.y - window.WindowPadding.y * 2.0 - (window.DecoOuterSizeY1 + window.DecoOuterSizeY2)))

		// Setup drawing context
		// (NB: That term "drawing context / DC" lost its meaning a long time ago. Initially was meant to hold transient data only. Nowadays difference between window-> and window->DC-> is dubious.)
		window.DC.Indent.x = window.DecoOuterSizeX1 + window.WindowPadding.x - window.Scroll.x
		window.DC.GroupOffset.x = 0.0
		window.DC.ColumnsOffset.x = 0.0

		// Record the loss of precision of CursorStartPos which can happen due to really large scrolling amount.
		// This is used by clipper to compensate and fix the most common use case of large scroll area. Easy and cheap, next best thing compared to switching everything to double or ImU64.
		start_pos_highp_x : f64 = cast(f64) window.Pos.x + cast(f64) window.WindowPadding.x - cast(f64) window.Scroll.x + cast(f64) window.DecoOuterSizeX1 + cast(f64) window.DC.ColumnsOffset.x
		start_pos_highp_y : f64 = cast(f64) window.Pos.y + cast(f64) window.WindowPadding.y - cast(f64) window.Scroll.y + cast(f64) window.DecoOuterSizeY1
		window.DC.CursorStartPos = ImVec2{cast(f32) start_pos_highp_x, cast(f32) start_pos_highp_y}
		window.DC.CursorStartPosLossyness = ImVec2{cast(f32) (start_pos_highp_x - cast(f64) window.DC.CursorStartPos.x), cast(f32) (start_pos_highp_y - cast(f64) window.DC.CursorStartPos.y)}
		window.DC.CursorPos = window.DC.CursorStartPos
		window.DC.CursorPosPrevLine = window.DC.CursorPos
		window.DC.CursorMaxPos = window.DC.CursorStartPos
		window.DC.IdealMaxPos = window.DC.CursorStartPos
		window.DC.PrevLineSize = ImVec2{0.0, 0.0}; window.DC.CurrLineSize = window.DC.PrevLineSize
		window.DC.PrevLineTextBaseOffset = 0.0; window.DC.CurrLineTextBaseOffset = window.DC.PrevLineTextBaseOffset
		window.DC.IsSetPos = false; window.DC.IsSameLine = window.DC.IsSetPos

		window.DC.NavLayerCurrent = ImGuiNavLayer.ImGuiNavLayer_Main
		window.DC.NavLayersActiveMask = window.DC.NavLayersActiveMaskNext
		window.DC.NavLayersActiveMaskNext = 0x00
		window.DC.NavIsScrollPushableX = true
		window.DC.NavHideHighlightOneFrame = false
		window.DC.NavWindowHasScrollY = (window.ScrollMax.y > 0.0)

		window.DC.MenuBarAppending = false
		Update(&window.DC.MenuColumns, style.ItemSpacing.x, window_just_activated_by_user)
		window.DC.TreeDepth = 0
		window.DC.TreeHasStackDataDepthMask = 0x00
		resize(&window.DC.ChildWindows, 0)
		window.DC.StateStorage = &window.StateStorage
		window.DC.CurrentColumns = nil
		window.DC.LayoutType = ImGuiLayoutType_.ImGuiLayoutType_Vertical
		window.DC.ParentLayoutType = parent_window != nil ? parent_window.DC.LayoutType : ImGuiLayoutType_.ImGuiLayoutType_Vertical

		window.DC.ItemWidth = window.ItemWidthDefault
		window.DC.TextWrapPos = -1.0; // disabled
		resize(&window.DC.ItemWidthStack, 0)
		resize(&window.DC.TextWrapPosStack, 0)
		if (flags & ImGuiWindowFlags_.ImGuiWindowFlags_Modal) != {} { window.DC.ModalDimBgColor = ColorConvertFloat4ToU32(GetStyleColorVec4(ImGuiCol_.ImGuiCol_ModalWindowDimBg)) }

		if window.AutoFitFramesX > 0 { post_decr(&window.AutoFitFramesX) }
		if window.AutoFitFramesY > 0 { post_decr(&window.AutoFitFramesY) }

		// Clear SetNextWindowXXX data (can aim to move this higher in the function)
		ClearFlags(&g.NextWindowData)

		// Apply focus (we need to call FocusWindow() AFTER setting DC.CursorStartPos so our initial navigation reference rectangle can start around there)
		// We ImGuiFocusRequestFlags_UnlessBelowModal to:
		// - Avoid focusing a window that is created outside of a modal. This will prevent active modal from being closed.
		// - Position window behind the modal that is not a begin-parent of this window.
		if want_focus { FocusWindow(window, ImGuiFocusRequestFlags_.ImGuiFocusRequestFlags_UnlessBelowModal) }
		if want_focus && window == g.NavWindow {
			// <-- this is in the way for us to be able to defer and sort reappearing FocusWindow() calls
			NavInitWindow(window, false)
		}

		// Close requested by platform window (apply to all windows in this viewport)
		if p_open != nil && window.Viewport.PlatformRequestClose && window.Viewport != GetMainViewport() {
			IMGUI_DEBUG_LOG_VIEWPORT(g, "[viewport] Window '%s' closed by PlatformRequestClose\n", window.Name)
			p_open^ = false
			g.NavWindowingToggleLayer = false; // Assume user mapped PlatformRequestClose on ALT-F4 so we disable ALT for menu toggle. False positive not an issue. // FIXME-NAV: Try removing.
		}

		// Pressing CTRL+C copy window content into the clipboard
		// [EXPERIMENTAL] Breaks on nested Begin/End pairs. We need to work that out and add better logging scope.
		// [EXPERIMENTAL] Text outputs has many issues.
		if g.IO.ConfigWindowsCopyContentsWithCtrlC { if g.NavWindow != nil && g.NavWindow.RootWindow == window && g.ActiveId == 0 && Shortcut(ImGuiKey.ImGuiMod_Ctrl | ImGuiKey.ImGuiKey_C) { LogToClipboard(0) } }

		// Title bar
		if (flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoTitleBar) == {} && !window.DockIsActive {
			RenderWindowTitleBarContents(window, ImRect{{title_bar_rect.Min.x + window.WindowBorderSize, title_bar_rect.Min.y}, {title_bar_rect.Max.x - window.WindowBorderSize, title_bar_rect.Max.y}}, name, p_open)
		}
		else if (flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoTitleBar) == {} && window.DockIsActive {
			LogText("%s\n", window.Name[:FindRenderedTextEnd(window.Name)])
		}

		// Clear hit test shape every frame
		window.HitTestHoleSize.y = 0; window.HitTestHoleSize.x = window.HitTestHoleSize.y

		if (flags & ImGuiWindowFlags_.ImGuiWindowFlags_Tooltip) != {} { g.TooltipPreviousWindow = window }

		if (g.IO.ConfigFlags & ImGuiConfigFlags_.ImGuiConfigFlags_DockingEnable) != {} {
			// Docking: Dragging a dockable window (or any of its child) turns it into a drag and drop source.
			// We need to do this _before_ we overwrite window->DC.LastItemId below because BeginDockableDragDropSource() also overwrites it.
			if g.MovingWindow == window && (window.RootWindowDockTree.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoDocking) == {} { BeginDockableDragDropSource(window) }

			// Docking: Any dockable window can act as a target. For dock node hosts we call BeginDockableDragDropTarget() in DockNodeUpdate() instead.
			if g.DragDropActive && (flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoDocking) == {} { if g.MovingWindow == nil || g.MovingWindow.RootWindowDockTree != window { if (window == window.RootWindowDockTree) && (window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_DockNodeHost) == {} { BeginDockableDragDropTarget(window) } } }
		}

		// We fill last item data based on Title Bar/Tab, in order for IsItemHovered() and IsItemActive() to be usable after Begin().
		// This is useful to allow creating context menus on title bar only, etc.
		SetLastItemDataForWindow(window, title_bar_rect)

		// [DEBUG]
		when ! IMGUI_DISABLE_DEBUG_TOOLS { /* @gen ifndef */
		if g.DebugLocateId != 0 && (window.ID == g.DebugLocateId || window.MoveId == g.DebugLocateId) { DebugLocateItemResolveWithLastItem() }
		} // preproc endif

		// [Test Engine] Register title bar / tab with MoveId.
		when IMGUI_ENABLE_TEST_ENGINE { /* @gen ifdef */
		if (window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoTitleBar) == {} {
			window.DC.NavLayerCurrent = ImGuiNavLayer.ImGuiNavLayer_Menu
			IMGUI_TEST_ENGINE_ITEM_ADD(g.LastItemData.ID, g.LastItemData.Rect, &g.LastItemData)
			window.DC.NavLayerCurrent = ImGuiNavLayer.ImGuiNavLayer_Main
		}
		} // preproc endif
	}
	else {
		// Skip refresh always mark active
		if window.SkipRefresh { SetWindowActiveForSkipRefresh(window) }

		// Append
		SetCurrentViewport(window, window.Viewport)
		SetCurrentWindow(window)
		ClearFlags(&g.NextWindowData)
		SetLastItemDataForWindow(window, TitleBarRect(window))
	}

	if (flags & ImGuiWindowFlags_.ImGuiWindowFlags_DockNodeHost) == {} && !window.SkipRefresh { PushClipRect(window.InnerClipRect.Min, window.InnerClipRect.Max, true) }

	// Clear 'accessed' flag last thing (After PushClipRect which will set the flag. We want the flag to stay false when the default "Debug" window is unused)
	window.WriteAccessed = false
	post_incr(&window.BeginCount)

	// Update visibility
	if first_begin_of_the_frame && !window.SkipRefresh {
		// When we are about to select this tab (which will only be visible on the _next frame_), flag it with a non-zero HiddenFramesCannotSkipItems.
		// This will have the important effect of actually returning true in Begin() and not setting SkipItems, allowing an earlier submission of the window contents.
		// This is analogous to regular windows being hidden from one frame.
		// It is especially important as e.g. nested TabBars would otherwise generate flicker in the form of one empty frame, or focus requests won't be processed.
		if window.DockIsActive && !window.DockTabIsVisible {
			if window.LastFrameJustFocused == g.FrameCount { window.HiddenFramesCannotSkipItems = 1 }
			else { window.HiddenFramesCanSkipItems = 1 }
		}

		if (flags & ImGuiWindowFlags_.ImGuiWindowFlags_ChildWindow) != {} && (flags & ImGuiWindowFlags_.ImGuiWindowFlags_ChildMenu) == {} {
			// Child window can be out of sight and have "negative" clip windows.
			// Mark them as collapsed so commands are skipped earlier (we can't manually collapse them because they have no title bar).
			IM_ASSERT((flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoTitleBar) != {} || window.DockIsActive)
			nav_request : bool = (window.ChildFlags & ImGuiChildFlags_.ImGuiChildFlags_NavFlattened) != {} && (g.NavAnyRequest && g.NavWindow != nil && g.NavWindow.RootWindowForNav == window.RootWindowForNav)
			if !g.LogEnabled && !nav_request { if window.OuterRectClipped.Min.x >= window.OuterRectClipped.Max.x || window.OuterRectClipped.Min.y >= window.OuterRectClipped.Max.y {
	if window.AutoFitFramesX > 0 || window.AutoFitFramesY > 0 { window.HiddenFramesCannotSkipItems = 1 }
	else { window.HiddenFramesCanSkipItems = 1 }
} }

			// Hide along with parent or if parent is collapsed
			if parent_window != nil && (parent_window.Collapsed || parent_window.HiddenFramesCanSkipItems > 0) { window.HiddenFramesCanSkipItems = 1 }
			if parent_window != nil && (parent_window.Collapsed || parent_window.HiddenFramesCannotSkipItems > 0) { window.HiddenFramesCannotSkipItems = 1 }
		}

		// Don't render if style alpha is 0.0 at the time of Begin(). This is arbitrary and inconsistent but has been there for a long while (may remove at some point)
		if style.Alpha <= 0.0 { window.HiddenFramesCanSkipItems = 1 }

		// Update the Hidden flag
		hidden_regular : bool = (window.HiddenFramesCanSkipItems > 0) || (window.HiddenFramesCannotSkipItems > 0)
		window.Hidden = hidden_regular || (window.HiddenFramesForRenderOnly > 0)

		// Disable inputs for requested number of frames
		if window.DisableInputsFrames > 0 {
			post_decr(&window.DisableInputsFrames)
			window.Flags |= ImGuiWindowFlags_.ImGuiWindowFlags_NoInputs
		}

		// Update the SkipItems flag, used to early out of all items functions (no layout required)
		skip_items : bool = false
		if window.Collapsed || !window.Active || hidden_regular { if window.AutoFitFramesX <= 0 && window.AutoFitFramesY <= 0 && window.HiddenFramesCannotSkipItems <= 0 { skip_items = true } }
		window.SkipItems = skip_items

		// Restore NavLayersActiveMaskNext to previous value when not visible, so a CTRL+Tab back can use a safe value.
		if window.SkipItems { window.DC.NavLayersActiveMaskNext = window.DC.NavLayersActiveMask }

		// Sanity check: there are two spots which can set Appearing = true
		// - when 'window_just_activated_by_user' is set -> HiddenFramesCannotSkipItems is set -> SkipItems always false
		// - in BeginDocked() path when DockNodeIsVisible == DockTabIsVisible == true -> hidden _should_ be all zero // FIXME: Not formally proven, hence the assert.
		if window.SkipItems && !window.Appearing {
			// Please report on GitHub if this triggers: https://github.com/ocornut/imgui/issues/4177
			IM_ASSERT(window.Appearing == false)
		}
	}
	else if first_begin_of_the_frame {
		// Skip refresh mode
		window.SkipItems = true
	}

	// [DEBUG] io.ConfigDebugBeginReturnValue override return value to test Begin/End and BeginChild/EndChild behaviors.
	// (The implicit fallback window is NOT automatically ended allowing it to always be able to receive commands without crashing)
	when ! IMGUI_DISABLE_DEBUG_TOOLS { /* @gen ifndef */
	if !window.IsFallbackWindow { if (g.IO.ConfigDebugBeginReturnValueOnce && window_just_created) || (g.IO.ConfigDebugBeginReturnValueLoop && cast(i32) g.DebugBeginReturnValueCullDepth == g.CurrentWindowStack.Size) {
	if window.AutoFitFramesX > 0 { post_incr(&window.AutoFitFramesX) }
	if window.AutoFitFramesY > 0 { post_incr(&window.AutoFitFramesY) }
	return false
} }
	} // preproc endif

	return !window.SkipItems
}

SetLastItemDataForWindow :: proc(window : ^ImGuiWindow, rect : ImRect)
{
	g : ^ImGuiContext = GImGui
	if window.DockIsActive { SetLastItemData(window.MoveId, g.CurrentItemFlags, window.DockTabItemStatusFlags, window.DockTabItemRect) }
	else { SetLastItemData(window.MoveId, g.CurrentItemFlags, IsMouseHoveringRect(rect.Min, rect.Max, false) ? ImGuiItemStatusFlags_.ImGuiItemStatusFlags_HoveredRect : {}, rect) }
}

End :: proc()
{
	g : ^ImGuiContext = GImGui
	window : ^ImGuiWindow = g.CurrentWindow

	// Error checking: verify that user hasn't called End() too many times!
	if g.CurrentWindowStack.Size <= 1 && g.WithinFrameScopeWithImplicitWindow {
		IM_ASSERT_USER_ERROR(g.CurrentWindowStack.Size > 1, "Calling End() too many times!")
		return
	}
	window_stack_data : ^ImGuiWindowStackData = back(&g.CurrentWindowStack)

	// Error checking: verify that user doesn't directly call End() on a child window.
	if (window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_ChildWindow) != {} && (window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_DockNodeHost) == {} && !window.DockIsActive { IM_ASSERT_USER_ERROR(g.WithinEndChildID == window.ID, "Must call EndChild() and not End()!") }

	// Close anything that is open
	if window.DC.CurrentColumns != nil { EndColumns() }
	if (window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_DockNodeHost) == {} && !window.SkipRefresh {
		// Pop inner window clip rectangle
		PopClipRect()
	}
	PopFocusScope()
	if window_stack_data.DisabledOverrideReenable && window.RootWindow == window { EndDisabledOverrideReenable() }

	if window.SkipRefresh {
		IM_ASSERT(window.DrawList == nil)
		window.DrawList = &window.DrawListInst
	}

	// Stop logging
	if g.LogWindow == window {
		// FIXME: add more options for scope of logging
		LogFinish()
	}

	if window.DC.IsSetPos { ErrorCheckUsingSetCursorPosToExtendParentBoundaries() }

	// Docking: report contents sizes to parent to allow for auto-resize
	if window.DockNode != nil && window.DockTabIsVisible { if host_window : ^ImGuiWindow = window.DockNode.HostWindow; host_window != nil {
		// FIXME-DOCK
		host_window.DC.CursorMaxPos = window.DC.CursorMaxPos + window.WindowPadding - host_window.WindowPadding
	} }

	// Pop from window stack
	g.LastItemData = window_stack_data.ParentLastItemDataBackup
	if (window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_ChildMenu) != {} { post_decr(&g.BeginMenuDepth) }
	if (window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_Popup) != {} { pop_back(&g.BeginPopupStack) }

	// Error handling, state recovery
	if g.IO.ConfigErrorRecovery { ErrorRecoveryTryToRecoverWindowState(&window_stack_data.StackSizesInBegin) }

	pop_back(&g.CurrentWindowStack)
	SetCurrentWindow(g.CurrentWindowStack.Size == 0 ? nil : back(&g.CurrentWindowStack).Window)
	if g.CurrentWindow != nil { SetCurrentViewport(g.CurrentWindow, g.CurrentWindow.Viewport) }
}

// Fonts, drawing
// Important: this alone doesn't alter current ImDrawList state. This is called by PushFont/PopFont only.
SetCurrentFont :: proc(font : ^ImFont)
{
	g : ^ImGuiContext = GImGui
	IM_ASSERT(font != nil && IsLoaded(font)); // Font Atlas not created. Did you call io.Fonts->GetTexDataAsRGBA32 / GetTexDataAsAlpha8 ?
	IM_ASSERT(font.Scale > 0.0)
	g.Font = font
	g.FontBaseSize = ImMax(f32(1.0), g.IO.FontGlobalScale * g.Font.FontSize * g.Font.Scale)
	g.FontSize = g.CurrentWindow != nil ? CalcFontSize(g.CurrentWindow) : 0.0
	g.FontScale = g.FontSize / g.Font.FontSize

	atlas : ^ImFontAtlas = g.Font.ContainerAtlas
	g.DrawListSharedData.TexUvWhitePixel = atlas.TexUvWhitePixel
	g.DrawListSharedData.TexUvLines = raw_data(&atlas.TexUvLines)
	g.DrawListSharedData.Font = g.Font
	g.DrawListSharedData.FontSize = g.FontSize
	g.DrawListSharedData.FontScale = g.FontScale
}

// Parameters stacks (shared)
// use NULL as a shortcut to push default font
// Use ImDrawList::_SetTextureID(), making our shared g.FontStack[] authorative against window-local ImDrawList.
// - Whereas ImDrawList::PushTextureID()/PopTextureID() is not to be used across Begin() calls.
// - Note that we don't propagate current texture id when e.g. Begin()-ing into a new window, we never really did...
//   - Some code paths never really fully worked with multiple atlas textures.
//   - The right-ish solution may be to remove _SetTextureID() and make AddText/RenderText lazily call PushTextureID()/PopTextureID()
//     the same way AddImage() does, but then all other primitives would also need to? I don't think we should tackle this problem
//     because we have a concrete need and a test bed for multiple atlas textures.
PushFont :: proc(font : ^ImFont)
{
	font := font
	g : ^ImGuiContext = GImGui
	if font == nil { font = GetDefaultFont() }
	push_back(&g.FontStack, font)
	SetCurrentFont(font)
	_SetTextureID(g.CurrentWindow.DrawList, font.ContainerAtlas.TexID)
}

PopFont :: proc()
{
	g : ^ImGuiContext = GImGui
	if g.FontStack.Size <= 0 {
		IM_ASSERT_USER_ERROR(false, "Calling PopFont() too many times!")
		return
	}
	pop_back(&g.FontStack)
	font : ^ImFont = g.FontStack.Size == 0 ? GetDefaultFont() : back(&g.FontStack)^
	SetCurrentFont(font)
	_SetTextureID(g.CurrentWindow.DrawList, font.ContainerAtlas.TexID)
}

// modify specified shared item flag, e.g. PushItemFlag(ImGuiItemFlags_NoTabStop, true)
PushItemFlag :: proc(option : ImGuiItemFlags, enabled : bool)
{
	g : ^ImGuiContext = GImGui
	item_flags : ImGuiItemFlags = g.CurrentItemFlags
	IM_ASSERT(item_flags == back(&g.ItemFlagsStack)^)
	if enabled { item_flags |= option }
	else { item_flags &= cast(ImGuiItemFlags)~cast(i32)option }
	g.CurrentItemFlags = item_flags
	push_back(&g.ItemFlagsStack, item_flags)
}

PopItemFlag :: proc()
{
	g : ^ImGuiContext = GImGui
	if g.ItemFlagsStack.Size <= 1 {
		IM_ASSERT_USER_ERROR(false, "Calling PopItemFlag() too many times!")
		return
	}
	pop_back(&g.ItemFlagsStack)
	g.CurrentItemFlags = back(&g.ItemFlagsStack)^
}

// Disabling [BETA API]
// - Disable all user interactions and dim items visuals (applying style.DisabledAlpha over current colors)
// - Those can be nested but it cannot be used to enable an already disabled section (a single BeginDisabled(true) in the stack is enough to keep everything disabled)
// - Tooltips windows by exception are opted out of disabling.
// - BeginDisabled(false)/EndDisabled() essentially does nothing but is provided to facilitate use of boolean expressions (as a micro-optimization: if you have tens of thousands of BeginDisabled(false)/EndDisabled() pairs, you might want to reformulate your code to avoid making those calls)
// BeginDisabled()/EndDisabled()
// - Those can be nested but it cannot be used to enable an already disabled section (a single BeginDisabled(true) in the stack is enough to keep everything disabled)
// - Visually this is currently altering alpha, but it is expected that in a future styling system this would work differently.
// - Feedback welcome at https://github.com/ocornut/imgui/issues/211
// - BeginDisabled(false)/EndDisabled() essentially does nothing but is provided to facilitate use of boolean expressions.
//   (as a micro-optimization: if you have tens of thousands of BeginDisabled(false)/EndDisabled() pairs, you might want to reformulate your code to avoid making those calls)
// - Note: mixing up BeginDisabled() and PushItemFlag(ImGuiItemFlags_Disabled) is currently NOT SUPPORTED.
BeginDisabled :: proc(disabled : bool = true)
{
	g : ^ImGuiContext = GImGui
	was_disabled : bool = (g.CurrentItemFlags & cast(ImGuiItemFlags) ImGuiItemFlagsPrivate_.ImGuiItemFlags_Disabled) != {}
	if !was_disabled && disabled {
		g.DisabledAlphaBackup = g.Style.Alpha
		g.Style.Alpha *= g.Style.DisabledAlpha; // PushStyleVar(ImGuiStyleVar_Alpha, g.Style.Alpha * g.Style.DisabledAlpha);
	}
	if was_disabled || disabled { g.CurrentItemFlags |= cast(ImGuiItemFlags) ImGuiItemFlagsPrivate_.ImGuiItemFlags_Disabled }
	push_back(&g.ItemFlagsStack, g.CurrentItemFlags); // FIXME-OPT: can we simply skip this and use DisabledStackSize?
	post_incr(&g.DisabledStackSize)
}

EndDisabled :: proc()
{
	g : ^ImGuiContext = GImGui
	if g.DisabledStackSize <= 0 {
		IM_ASSERT_USER_ERROR(false, "Calling EndDisabled() too many times!")
		return
	}
	post_decr(&g.DisabledStackSize)
	was_disabled : bool = (g.CurrentItemFlags & cast(ImGuiItemFlags) ImGuiItemFlagsPrivate_.ImGuiItemFlags_Disabled) != {}
	//PopItemFlag();
	pop_back(&g.ItemFlagsStack)
	g.CurrentItemFlags = back(&g.ItemFlagsStack)^
	if was_disabled && (g.CurrentItemFlags & cast(ImGuiItemFlags) ImGuiItemFlagsPrivate_.ImGuiItemFlags_Disabled) == {} {
		//PopStyleVar();
		g.Style.Alpha = g.DisabledAlphaBackup
	}
}

// Could have been called BeginDisabledDisable() but it didn't want to be award nominated for most awkward function name.
// Ideally we would use a shared e.g. BeginDisabled()->BeginDisabledEx() but earlier needs to be optimal.
// The whole code for this is awkward, will reevaluate if we find a way to implement SetNextItemDisabled().
BeginDisabledOverrideReenable :: proc()
{
	g : ^ImGuiContext = GImGui
	IM_ASSERT((g.CurrentItemFlags & cast(ImGuiItemFlags) ImGuiItemFlagsPrivate_.ImGuiItemFlags_Disabled) != {})
	g.Style.Alpha = g.DisabledAlphaBackup
	g.CurrentItemFlags &= cast(ImGuiItemFlags) ~cast(i32)ImGuiItemFlagsPrivate_.ImGuiItemFlags_Disabled
	push_back(&g.ItemFlagsStack, g.CurrentItemFlags)
	post_incr(&g.DisabledStackSize)
}

EndDisabledOverrideReenable :: proc()
{
	g : ^ImGuiContext = GImGui
	post_decr(&g.DisabledStackSize)
	IM_ASSERT(g.DisabledStackSize > 0)
	pop_back(&g.ItemFlagsStack)
	g.CurrentItemFlags = back(&g.ItemFlagsStack)^
	g.Style.Alpha = g.DisabledAlphaBackup * g.Style.DisabledAlpha
}

// push word-wrapping position for Text*() commands. < 0.0f: no wrapping; 0.0f: wrap to end of window (or column); > 0.0f: wrap at 'wrap_pos_x' position in window local space
PushTextWrapPos :: proc(wrap_pos_x : f32)
{
	g : ^ImGuiContext = GImGui
	window : ^ImGuiWindow = g.CurrentWindow
	push_back(&window.DC.TextWrapPosStack, window.DC.TextWrapPos)
	window.DC.TextWrapPos = wrap_pos_x
}

PopTextWrapPos :: proc()
{
	g : ^ImGuiContext = GImGui
	window : ^ImGuiWindow = g.CurrentWindow
	if window.DC.TextWrapPosStack.Size <= 0 {
		IM_ASSERT_USER_ERROR(false, "Calling PopTextWrapPos() too many times!")
		return
	}
	window.DC.TextWrapPos = back(&window.DC.TextWrapPosStack)^
	pop_back(&window.DC.TextWrapPosStack)
}

GetCombinedRootWindow :: proc(window : ^ImGuiWindow, popup_hierarchy : bool, dock_hierarchy : bool) -> ^ImGuiWindow
{
	last_window : ^ImGuiWindow = nil
	for window := window; last_window != window; {
		last_window = window
		window = window.RootWindow
		if popup_hierarchy { window = window.RootWindowPopupTree }
		if dock_hierarchy { window = window.RootWindowDockTree }
	}

	return window
}

IsWindowChildOf :: proc(window : ^ImGuiWindow, potential_parent : ^ImGuiWindow, popup_hierarchy : bool, dock_hierarchy : bool) -> bool
{
	window_root : ^ImGuiWindow = GetCombinedRootWindow(window, popup_hierarchy, dock_hierarchy)
	if window_root == potential_parent { return true }
	for window := window; window != nil; {
		if window == potential_parent { return true }
		if window == window_root {
			// end of chain
			return false
		}
		window = window.ParentWindow
	}

	return false
}

IsWindowWithinBeginStackOf :: proc(window : ^ImGuiWindow, potential_parent : ^ImGuiWindow) -> bool
{
	if window.RootWindow == potential_parent { return true }
	for window := window; window != nil; {
		if window == potential_parent { return true }
		window = window.ParentWindowInBeginStack
	}

	return false
}

IsWindowAbove :: proc(potential_above : ^ImGuiWindow, potential_below : ^ImGuiWindow) -> bool
{
	g : ^ImGuiContext = GImGui

	// It would be saner to ensure that display layer is always reflected in the g.Windows.Data[] order, which would likely requires altering all manipulations of that array
	display_layer_delta : i32 = GetWindowDisplayLayer(potential_above) - GetWindowDisplayLayer(potential_below)
	if display_layer_delta != 0 { return display_layer_delta > 0 }

	for i : i32 = g.Windows.Size - 1; i >= 0; i -= 1 {
		candidate_window : ^ImGuiWindow = g.Windows.Data[i]
		if candidate_window == potential_above { return true }
		if candidate_window == potential_below { return false }
	}

	return false
}

// is current window hovered and hoverable (e.g. not blocked by a popup/modal)? See ImGuiHoveredFlags_ for options. IMPORTANT: If you are trying to check whether your mouse should be dispatched to Dear ImGui or to your underlying app, you should not use this function! Use the 'io.WantCaptureMouse' boolean for that! Refer to FAQ entry "How can I tell whether to dispatch mouse/keyboard to Dear ImGui or my application?" for details.
// Is current window hovered and hoverable (e.g. not blocked by a popup/modal)? See ImGuiHoveredFlags_ for options.
// IMPORTANT: If you are trying to check whether your mouse should be dispatched to Dear ImGui or to your underlying app,
// you should not use this function! Use the 'io.WantCaptureMouse' boolean for that!
// Refer to FAQ entry "How can I tell whether to dispatch mouse/keyboard to Dear ImGui or my application?" for details.
IsWindowHovered :: proc(flags : ImGuiHoveredFlags = {}) -> bool
{
	g : ^ImGuiContext = GImGui
	IM_ASSERT_USER_ERROR((flags & cast(ImGuiHoveredFlags)~cast(i32)ImGuiHoveredFlagsPrivate_.ImGuiHoveredFlags_AllowedMaskForIsWindowHovered) == {}, "Invalid flags for IsWindowHovered()!")

	ref_window : ^ImGuiWindow = g.HoveredWindow
	cur_window : ^ImGuiWindow = g.CurrentWindow
	if ref_window == nil { return false }

	if (flags & ImGuiHoveredFlags_.ImGuiHoveredFlags_AnyWindow) == {} {
		IM_ASSERT(cur_window != nil); // Not inside a Begin()/End()
		popup_hierarchy : bool = (flags & ImGuiHoveredFlags_.ImGuiHoveredFlags_NoPopupHierarchy) == {}
		dock_hierarchy : bool = (flags & ImGuiHoveredFlags_.ImGuiHoveredFlags_DockHierarchy) != {}
		if (flags & ImGuiHoveredFlags_.ImGuiHoveredFlags_RootWindow) != {} { cur_window = GetCombinedRootWindow(cur_window, popup_hierarchy, dock_hierarchy) }

		result : bool
		if (flags & ImGuiHoveredFlags_.ImGuiHoveredFlags_ChildWindows) != {} { result = IsWindowChildOf(ref_window, cur_window, popup_hierarchy, dock_hierarchy) }
		else { result = (ref_window == cur_window) }
		if !result { return false }
	}

	if !IsWindowContentHoverable(ref_window, flags) { return false }
	if (flags & ImGuiHoveredFlags_.ImGuiHoveredFlags_AllowWhenBlockedByActiveItem) == {} { if g.ActiveId != 0 && !g.ActiveIdAllowOverlap && g.ActiveId != ref_window.MoveId { return false } }

	flags := flags
	// When changing hovered window we requires a bit of stationary delay before activating hover timer.
	// FIXME: We don't support delay other than stationary one for now, other delay would need a way
	// to fulfill the possibility that multiple IsWindowHovered() with varying flag could return true
	// for different windows of the hierarchy. Possibly need a Hash(Current+Flags) ==> (Timer) cache.
	// We can implement this for _Stationary because the data is linked to HoveredWindow rather than CurrentWindow.
	if (flags & ImGuiHoveredFlags_.ImGuiHoveredFlags_ForTooltip) != {} { flags = ApplyHoverFlagsForTooltip(flags, g.Style.HoverFlagsForTooltipMouse) }
	if (flags & ImGuiHoveredFlags_.ImGuiHoveredFlags_Stationary) != {} && g.HoverWindowUnlockedStationaryId != ref_window.ID { return false }

	return true
}

GetWindowDockID :: proc() -> ImGuiID
{
	g : ^ImGuiContext = GImGui
	return g.CurrentWindow.DockId
}

// is current window docked into another window?
IsWindowDocked :: proc() -> bool
{
	g : ^ImGuiContext = GImGui
	return g.CurrentWindow.DockIsActive
}

// get current window width (IT IS UNLIKELY YOU EVER NEED TO USE THIS). Shortcut for GetWindowSize().x.
GetWindowWidth :: proc() -> f32
{
	window : ^ImGuiWindow = GImGui.CurrentWindow
	return window.Size.x
}

// get current window height (IT IS UNLIKELY YOU EVER NEED TO USE THIS). Shortcut for GetWindowSize().y.
GetWindowHeight :: proc() -> f32
{
	window : ^ImGuiWindow = GImGui.CurrentWindow
	return window.Size.y
}

// get current window position in screen space (IT IS UNLIKELY YOU EVER NEED TO USE THIS. Consider always using GetCursorScreenPos() and GetContentRegionAvail() instead)
GetWindowPos :: proc() -> ImVec2
{
	g : ^ImGuiContext = GImGui
	window : ^ImGuiWindow = g.CurrentWindow
	return window.Pos
}

// (not recommended) set current window position - call within Begin()/End(). prefer using SetNextWindowPos(), as this may incur tearing and side-effects.
// set named window position.
SetWindowPos_0 :: proc(window : ^ImGuiWindow, pos : ImVec2, cond : ImGuiCond)
{
	// Test condition (NB: bit 0 is always true) and clear flags for next time
	if cond != {} && (window.SetWindowPosAllowFlags & cond) == {} { return }

	IM_ASSERT(cond == {} || ImIsPowerOfTwo(transmute(u32) cond)); // Make sure the user doesn't attempt to combine multiple condition flags.
	window.SetWindowPosAllowFlags &= cast(ImGuiCond) ~i32(ImGuiCond_.ImGuiCond_Once | ImGuiCond_.ImGuiCond_FirstUseEver | ImGuiCond_.ImGuiCond_Appearing)
	window.SetWindowPosVal = ImVec2{FLT_MAX, FLT_MAX}

	// Set
	old_pos : ImVec2 = window.Pos
	window.Pos = ImTrunc(pos)
	offset : ImVec2 = window.Pos - old_pos
	if offset.x == 0.0 && offset.y == 0.0 { return }
	MarkIniSettingsDirty(window)
	// FIXME: share code with TranslateWindow(), need to confirm whether the 3 rect modified by TranslateWindow() are desirable here.
	window.DC.CursorPos += offset; // As we happen to move the window while it is being appended to (which is a bad idea - will smear) let's at least offset the cursor
	window.DC.CursorMaxPos += offset; // And more importantly we need to offset CursorMaxPos/CursorStartPos this so ContentSize calculation doesn't get affected.
	window.DC.IdealMaxPos += offset
	window.DC.CursorStartPos += offset
}

// (not recommended) set current window position - call within Begin()/End(). prefer using SetNextWindowPos(), as this may incur tearing and side-effects.
// set named window position.
SetWindowPos_1 :: proc(pos : ImVec2, cond : ImGuiCond)
{
	window : ^ImGuiWindow = GetCurrentWindowRead()
	SetWindowPos(window, pos, cond)
}

// (not recommended) set current window position - call within Begin()/End(). prefer using SetNextWindowPos(), as this may incur tearing and side-effects.
// set named window position.
SetWindowPos_2 :: proc(name : string, pos : ImVec2, cond : ImGuiCond)
{
	if window : ^ImGuiWindow = FindWindowByName(name); window != nil { SetWindowPos(window, pos, cond) }
}

// get current window size (IT IS UNLIKELY YOU EVER NEED TO USE THIS. Consider always using GetCursorScreenPos() and GetContentRegionAvail() instead)
GetWindowSize :: proc() -> ImVec2
{
	window : ^ImGuiWindow = GetCurrentWindowRead()
	return window.Size
}

// (not recommended) set current window size - call within Begin()/End(). set to ImVec2{0, 0} to force an auto-fit. prefer using SetNextWindowSize(), as this may incur tearing and minor side-effects.
// set named window size. set axis to 0.0f to force an auto-fit on this axis.
SetWindowSize_0 :: proc(window : ^ImGuiWindow, size : ImVec2, cond : ImGuiCond)
{
	// Test condition (NB: bit 0 is always true) and clear flags for next time
	if cond != {} && (window.SetWindowSizeAllowFlags & cond) == {} { return }

	IM_ASSERT(cond == {} || ImIsPowerOfTwo(cast(u32)cond)); // Make sure the user doesn't attempt to combine multiple condition flags.
	window.SetWindowSizeAllowFlags &= cast(ImGuiCond)~i32(ImGuiCond_.ImGuiCond_Once | ImGuiCond_.ImGuiCond_FirstUseEver | ImGuiCond_.ImGuiCond_Appearing)

	// Enable auto-fit (not done in BeginChild() path unless appearing or combined with ImGuiChildFlags_AlwaysAutoResize)
	if (window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_ChildWindow) == {} || window.Appearing || (window.ChildFlags & ImGuiChildFlags_.ImGuiChildFlags_AlwaysAutoResize) != {} { window.AutoFitFramesX = (size.x <= 0.0) ? 2 : 0 }
	if (window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_ChildWindow) == {} || window.Appearing || (window.ChildFlags & ImGuiChildFlags_.ImGuiChildFlags_AlwaysAutoResize) != {} { window.AutoFitFramesY = (size.y <= 0.0) ? 2 : 0 }

	// Set
	old_size : ImVec2 = window.SizeFull
	if size.x <= 0.0 { window.AutoFitOnlyGrows = false }
	else { window.SizeFull.x = IM_TRUNC(size.x) }
	if size.y <= 0.0 { window.AutoFitOnlyGrows = false }
	else { window.SizeFull.y = IM_TRUNC(size.y) }
	if old_size.x != window.SizeFull.x || old_size.y != window.SizeFull.y { MarkIniSettingsDirty(window) }
}

// (not recommended) set current window size - call within Begin()/End(). set to ImVec2{0, 0} to force an auto-fit. prefer using SetNextWindowSize(), as this may incur tearing and minor side-effects.
// set named window size. set axis to 0.0f to force an auto-fit on this axis.
SetWindowSize_1 :: proc(size : ImVec2, cond : ImGuiCond)
{
	SetWindowSize(GImGui.CurrentWindow, size, cond)
}

// (not recommended) set current window size - call within Begin()/End(). set to ImVec2{0, 0} to force an auto-fit. prefer using SetNextWindowSize(), as this may incur tearing and minor side-effects.
// set named window size. set axis to 0.0f to force an auto-fit on this axis.
SetWindowSize_2 :: proc(name : string, size : ImVec2, cond : ImGuiCond)
{
	if window : ^ImGuiWindow = FindWindowByName(name); window != nil { SetWindowSize(window, size, cond) }
}

// (not recommended) set current window collapsed state. prefer using SetNextWindowCollapsed().
// set named window collapsed state
SetWindowCollapsed_0 :: proc(window : ^ImGuiWindow, collapsed : bool, cond : ImGuiCond)
{
	// Test condition (NB: bit 0 is always true) and clear flags for next time
	if cond != {} && (window.SetWindowCollapsedAllowFlags & cond) == {} { return }
	window.SetWindowCollapsedAllowFlags &= cast(ImGuiCond) ~i32(ImGuiCond_.ImGuiCond_Once | ImGuiCond_.ImGuiCond_FirstUseEver | ImGuiCond_.ImGuiCond_Appearing)

	// Set
	window.Collapsed = collapsed
}

SetWindowHitTestHole :: proc(window : ^ImGuiWindow, pos : ImVec2, size : ImVec2)
{
	IM_ASSERT(window.HitTestHoleSize.x == 0); // We don't support multiple holes/hit test filters
	window.HitTestHoleSize = ImVec2ih{cast(i16)size.x, cast(i16)size.y}
	x := pos - window.Pos
	window.HitTestHoleOffset = ImVec2ih{cast(i16)x.x, cast(i16)x.y}
}

SetWindowHiddenAndSkipItemsForCurrentFrame :: proc(window : ^ImGuiWindow)
{
	window.SkipItems = true; window.Hidden = window.SkipItems
	window.HiddenFramesCanSkipItems = 1
}

// (not recommended) set current window collapsed state. prefer using SetNextWindowCollapsed().
// set named window collapsed state
SetWindowCollapsed_1 :: proc(collapsed : bool, cond : ImGuiCond)
{
	SetWindowCollapsed(GImGui.CurrentWindow, collapsed, cond)
}

IsWindowCollapsed :: proc() -> bool
{
	window : ^ImGuiWindow = GetCurrentWindowRead()
	return window.Collapsed
}

// Windows Utilities
// - 'current window' = the window we are appending into while inside a Begin()/End() block. 'next window' = next window we will Begin() into.
IsWindowAppearing :: proc() -> bool
{
	window : ^ImGuiWindow = GetCurrentWindowRead()
	return window.Appearing
}

// (not recommended) set current window collapsed state. prefer using SetNextWindowCollapsed().
// set named window collapsed state
SetWindowCollapsed_2 :: proc(name : string, collapsed : bool, cond : ImGuiCond)
{
	if window : ^ImGuiWindow = FindWindowByName(name); window != nil { SetWindowCollapsed(window, collapsed, cond) }
}

// Window manipulation
// - Prefer using SetNextXXX functions (before Begin) rather that SetXXX functions (after Begin).
// set next window position. call before Begin(). use pivot=(0.5f,0.5f) to center on given point, etc.
SetNextWindowPos :: proc(pos : ImVec2, cond : ImGuiCond = {}, pivot : ImVec2 = {})
{
	g : ^ImGuiContext = GImGui
	IM_ASSERT(cond == {} || ImIsPowerOfTwo(cast(u32) cond)); // Make sure the user doesn't attempt to combine multiple condition flags.
	g.NextWindowData.Flags |= ImGuiNextWindowDataFlags_.ImGuiNextWindowDataFlags_HasPos
	g.NextWindowData.PosVal = pos
	g.NextWindowData.PosPivotVal = pivot
	g.NextWindowData.PosCond = cond != {} ? cond : ImGuiCond_.ImGuiCond_Always
	g.NextWindowData.PosUndock = true
}

// set next window size. set axis to 0.0f to force an auto-fit on this axis. call before Begin()
SetNextWindowSize :: proc(size : ImVec2, cond : ImGuiCond = {})
{
	g : ^ImGuiContext = GImGui
	IM_ASSERT(cond == {} || ImIsPowerOfTwo(cast(u32) cond)); // Make sure the user doesn't attempt to combine multiple condition flags.
	g.NextWindowData.Flags |= ImGuiNextWindowDataFlags_.ImGuiNextWindowDataFlags_HasSize
	g.NextWindowData.SizeVal = size
	g.NextWindowData.SizeCond = cond != {} ? cond : ImGuiCond_.ImGuiCond_Always
}

// set next window size limits. use 0.0f or FLT_MAX if you don't want limits. Use -1 for both min and max of same axis to preserve current size (which itself is a constraint). Use callback to apply non-trivial programmatic constraints.
// For each axis:
// - Use 0.0f as min or FLT_MAX as max if you don't want limits, e.g. size_min = (500.0f, 0.0f), size_max = (FLT_MAX, FLT_MAX) sets a minimum width.
// - Use -1 for both min and max of same axis to preserve current size which itself is a constraint.
// - See "Demo->Examples->Constrained-resizing window" for examples.
SetNextWindowSizeConstraints :: proc(size_min : ImVec2, size_max : ImVec2, custom_callback : ImGuiSizeCallback = nil, custom_callback_user_data : rawptr = nil)
{
	g : ^ImGuiContext = GImGui
	g.NextWindowData.Flags |= ImGuiNextWindowDataFlags_.ImGuiNextWindowDataFlags_HasSizeConstraint
	g.NextWindowData.SizeConstraintRect = ImRect{size_min, size_max}
	g.NextWindowData.SizeCallback = custom_callback
	g.NextWindowData.SizeCallbackUserData = custom_callback_user_data
}

// set next window content size (~ scrollable client area, which enforce the range of scrollbars). Not including window decorations (title bar, menu bar, etc.) nor WindowPadding. set an axis to 0.0f to leave it automatic. call before Begin()
// Content size = inner scrollable rectangle, padded with WindowPadding.
// SetNextWindowContentSize(ImVec2{100,100} + ImGuiWindowFlags_AlwaysAutoResize will always allow submitting a 100x100 item.
SetNextWindowContentSize :: proc(size : ImVec2)
{
	g : ^ImGuiContext = GImGui
	g.NextWindowData.Flags |= ImGuiNextWindowDataFlags_.ImGuiNextWindowDataFlags_HasContentSize
	g.NextWindowData.ContentSizeVal = ImTrunc(size)
}

// set next window scrolling value (use < 0.0f to not affect a given axis).
SetNextWindowScroll :: proc(scroll : ImVec2)
{
	g : ^ImGuiContext = GImGui
	g.NextWindowData.Flags |= ImGuiNextWindowDataFlags_.ImGuiNextWindowDataFlags_HasScroll
	g.NextWindowData.ScrollVal = scroll
}

// set next window collapsed state. call before Begin()
SetNextWindowCollapsed :: proc(collapsed : bool, cond : ImGuiCond = {})
{
	g : ^ImGuiContext = GImGui
	IM_ASSERT(cond == {} || ImIsPowerOfTwo(u32(cond))); // Make sure the user doesn't attempt to combine multiple condition flags.
	g.NextWindowData.Flags |= ImGuiNextWindowDataFlags_.ImGuiNextWindowDataFlags_HasCollapsed
	g.NextWindowData.CollapsedVal = collapsed
	g.NextWindowData.CollapsedCond = cond != {} ? cond : ImGuiCond_.ImGuiCond_Always
}

// set next window background color alpha. helper to easily override the Alpha component of ImGuiCol_WindowBg/ChildBg/PopupBg. you may also use ImGuiWindowFlags_NoBackground.
SetNextWindowBgAlpha :: proc(alpha : f32)
{
	g : ^ImGuiContext = GImGui
	g.NextWindowData.Flags |= ImGuiNextWindowDataFlags_.ImGuiNextWindowDataFlags_HasBgAlpha
	g.NextWindowData.BgAlphaVal = alpha
}

// set next window viewport
SetNextWindowViewport :: proc(id : ImGuiID)
{
	g : ^ImGuiContext = GImGui
	g.NextWindowData.Flags |= ImGuiNextWindowDataFlags_.ImGuiNextWindowDataFlags_HasViewport
	g.NextWindowData.ViewportId = id
}

// set next window dock id
SetNextWindowDockID :: proc(id : ImGuiID, cond : ImGuiCond = {})
{
	g : ^ImGuiContext = GImGui
	g.NextWindowData.Flags |= ImGuiNextWindowDataFlags_.ImGuiNextWindowDataFlags_HasDock
	g.NextWindowData.DockCond = cond != {} ? cond : ImGuiCond_.ImGuiCond_Always
	g.NextWindowData.DockId = id
}

// set next window class (control docking compatibility + provide hints to platform backend via custom viewport flags and platform parent/child relationship)
SetNextWindowClass :: proc(window_class : ^ImGuiWindowClass)
{
	g : ^ImGuiContext = GImGui
	IM_ASSERT((window_class.ViewportFlagsOverrideSet & window_class.ViewportFlagsOverrideClear) == {}); // Cannot set both set and clear for the same bit
	g.NextWindowData.Flags |= ImGuiNextWindowDataFlags_.ImGuiNextWindowDataFlags_HasWindowClass
	g.NextWindowData.WindowClass = window_class^
}

// Windows: Idle, Refresh Policies [EXPERIMENTAL]
// This is experimental and meant to be a toy for exploring a future/wider range of features.
SetNextWindowRefreshPolicy :: proc(flags : ImGuiWindowRefreshFlags)
{
	g : ^ImGuiContext = GImGui
	g.NextWindowData.Flags |= ImGuiNextWindowDataFlags_.ImGuiNextWindowDataFlags_HasRefreshPolicy
	g.NextWindowData.RefreshFlagsVal = flags
}

// get draw list associated to the current window, to append your own drawing primitives
GetWindowDrawList :: proc() -> ^ImDrawList
{
	window : ^ImGuiWindow = GetCurrentWindow()
	return window.DrawList
}

// get DPI scale currently associated to the current window's viewport.
GetWindowDpiScale :: proc() -> f32
{
	g : ^ImGuiContext = GImGui
	return g.CurrentDpiScale
}

// get viewport currently associated to the current window.
GetWindowViewport :: proc() -> ^ImGuiViewport
{
	g : ^ImGuiContext = GImGui
	IM_ASSERT(g.CurrentViewport != nil && g.CurrentViewport == g.CurrentWindow.Viewport)
	return g.CurrentViewport
}

// Style read access
// - Use the ShowStyleEditor() function to interactively see/edit the colors.
// get current font
GetFont :: proc() -> ^ImFont
{
	return GImGui.Font
}

// get current font size (= height in pixels) of current font with current scale applied
GetFontSize :: proc() -> f32
{
	return GImGui.FontSize
}

// get UV coordinate for a white pixel, useful to draw custom shapes via the ImDrawList API
GetFontTexUvWhitePixel :: proc() -> ImVec2
{
	return GImGui.DrawListSharedData.TexUvWhitePixel
}

// [OBSOLETE] set font scale. Adjust IO.FontGlobalScale if you want to scale all windows. This is an old API! For correct scaling, prefer to reload font + rebuild ImFontAtlas + call style.ScaleAllSizes().
SetWindowFontScale :: proc(scale : f32)
{
	IM_ASSERT(scale > 0.0)
	g : ^ImGuiContext = GImGui
	window : ^ImGuiWindow = GetCurrentWindow()
	window.FontWindowScale = scale
	g.DrawListSharedData.FontSize = CalcFontSize(window); g.FontSize = g.DrawListSharedData.FontSize
	g.DrawListSharedData.FontScale = g.FontSize / g.Font.FontSize; g.FontScale = g.DrawListSharedData.FontScale
}

// [EXPERIMENTAL] Focus Scope
// This is generally used to identify a unique input location (for e.g. a selection set)
// There is one per window (automatically set in Begin), but:
// - Selection patterns generally need to react (e.g. clear a selection) when landing on one item of the set.
//   So in order to identify a set multiple lists in same window may each need a focus scope.
//   If you imagine an hypothetical BeginSelectionGroup()/EndSelectionGroup() api, it would likely call PushFocusScope()/EndFocusScope()
// - Shortcut routing also use focus scope as a default location identifier if an owner is not provided.
// We don't use the ID Stack for this as it is common to want them separate.
PushFocusScope :: proc(id : ImGuiID)
{
	g : ^ImGuiContext = GImGui
	data : ImGuiFocusScopeData
	data.ID = id
	data.WindowID = g.CurrentWindow.ID
	push_back(&g.FocusScopeStack, data)
	g.CurrentFocusScopeId = id
}

PopFocusScope :: proc()
{
	g : ^ImGuiContext = GImGui
	if g.FocusScopeStack.Size <= cast(i32) g.StackSizesInBeginForCurrentWindow.SizeOfFocusScopeStack {
		IM_ASSERT_USER_ERROR(false, "Calling PopFocusScope() too many times!")
		return
	}
	pop_back(&g.FocusScopeStack)
	g.CurrentFocusScopeId = g.FocusScopeStack.Size != 0 ? back(&g.FocusScopeStack).ID : 0
}

SetNavFocusScope :: proc(focus_scope_id : ImGuiID)
{
	g : ^ImGuiContext = GImGui
	g.NavFocusScopeId = focus_scope_id
	resize(&g.NavFocusRoute, 0); // Invalidate
	if focus_scope_id == 0 { return }
	IM_ASSERT(g.NavWindow != nil)

	// Store current path (in reverse order)
	if focus_scope_id == g.CurrentFocusScopeId {
		// Top of focus stack contains local focus scopes inside current window
		for n : i32 = g.FocusScopeStack.Size - 1; n >= 0 && g.FocusScopeStack.Data[n].WindowID == g.CurrentWindow.ID; n -= 1 { push_back(&g.NavFocusRoute, g.FocusScopeStack.Data[n]) }
	}
	else if focus_scope_id == g.NavWindow.NavRootFocusScopeId { push_back(&g.NavFocusRoute, ImGuiFocusScopeData{focus_scope_id, g.NavWindow.ID}) }
	else { return }

	// Then follow on manually set ParentWindowForFocusRoute field (#6798)
	for window : ^ImGuiWindow = g.NavWindow.ParentWindowForFocusRoute; window != nil; window = window.ParentWindowForFocusRoute { push_back(&g.NavFocusRoute, ImGuiFocusScopeData{window.NavRootFocusScopeId, window.ID}) }

	IM_ASSERT(g.NavFocusRoute.Size < 100); // Maximum depth is technically 251 as per CalcRoutingScore(): 254 - 3
}

// Focus/Activation
// This should be part of a larger set of API: FocusItem(offset = -1), FocusItemByID(id), ActivateItem(offset = -1), ActivateItemByID(id) etc. which are
// much harder to design and implement than expected. I have a couple of private branches on this matter but it's not simple. For now implementing the easy ones.
// Focus last item (no selection/activation).
// Focus = move navigation cursor, set scrolling, set focus window.
FocusItem :: proc()
{
	g : ^ImGuiContext = GImGui
	window : ^ImGuiWindow = g.CurrentWindow
	IMGUI_DEBUG_LOG_FOCUS(g, "FocusItem(0x%08x) in window \"%s\"\n", g.LastItemData.ID, window.Name)
	if g.DragDropActive || g.MovingWindow != nil {
		// FIXME: Opt-in flags for this?
		IMGUI_DEBUG_LOG_FOCUS(g, "FocusItem() ignored while DragDropActive!\n")
		return
	}

	move_flags : ImGuiNavMoveFlags = ImGuiNavMoveFlags_.ImGuiNavMoveFlags_IsTabbing | ImGuiNavMoveFlags_.ImGuiNavMoveFlags_FocusApi | ImGuiNavMoveFlags_.ImGuiNavMoveFlags_NoSetNavCursorVisible | ImGuiNavMoveFlags_.ImGuiNavMoveFlags_NoSelect
	scroll_flags : ImGuiScrollFlags = window.Appearing ? ImGuiScrollFlags_.ImGuiScrollFlags_KeepVisibleEdgeX | ImGuiScrollFlags_.ImGuiScrollFlags_AlwaysCenterY : ImGuiScrollFlags_.ImGuiScrollFlags_KeepVisibleEdgeX | ImGuiScrollFlags_.ImGuiScrollFlags_KeepVisibleEdgeY
	SetNavWindow(window)
	NavMoveRequestSubmit(ImGuiDir.ImGuiDir_None, ImGuiDir.ImGuiDir_Up, move_flags, scroll_flags)
	NavMoveRequestResolveWithLastItem(&g.NavMoveResultLocal)
}

// Activate an item by ID (button, checkbox, tree node etc.). Activation is queued and processed on the next frame when the item is encountered again.
ActivateItemByID :: proc(id : ImGuiID)
{
	g : ^ImGuiContext = GImGui
	g.NavNextActivateId = id
	g.NavNextActivateFlags = ImGuiActivateFlags_.ImGuiActivateFlags_None
}

// focus keyboard on the next widget. Use positive 'offset' to access sub components of a multiple component widget. Use -1 to access previous widget.
// Note: this will likely be called ActivateItem() once we rework our Focus/Activation system!
// But ActivateItem() should function without altering scroll/focus?
SetKeyboardFocusHere :: proc(offset : i32)
{
	g : ^ImGuiContext = GImGui
	window : ^ImGuiWindow = g.CurrentWindow
	IM_ASSERT(offset >= -1); // -1 is allowed but not below
	IMGUI_DEBUG_LOG_FOCUS(g, "SetKeyboardFocusHere(%d) in window \"%s\"\n", offset, window.Name)

	// It makes sense in the vast majority of cases to never interrupt a drag and drop.
	// When we refactor this function into ActivateItem() we may want to make this an option.
	// MovingWindow is protected from most user inputs using SetActiveIdUsingNavAndKeys(), but
	// is also automatically dropped in the event g.ActiveId is stolen.
	if g.DragDropActive || g.MovingWindow != nil {
		IMGUI_DEBUG_LOG_FOCUS(g, "SetKeyboardFocusHere() ignored while DragDropActive!\n")
		return
	}

	SetNavWindow(window)

	move_flags : ImGuiNavMoveFlags = ImGuiNavMoveFlags_.ImGuiNavMoveFlags_IsTabbing | ImGuiNavMoveFlags_.ImGuiNavMoveFlags_Activate | ImGuiNavMoveFlags_.ImGuiNavMoveFlags_FocusApi | ImGuiNavMoveFlags_.ImGuiNavMoveFlags_NoSetNavCursorVisible
	scroll_flags : ImGuiScrollFlags = window.Appearing ? ImGuiScrollFlags_.ImGuiScrollFlags_KeepVisibleEdgeX | ImGuiScrollFlags_.ImGuiScrollFlags_AlwaysCenterY : ImGuiScrollFlags_.ImGuiScrollFlags_KeepVisibleEdgeX | ImGuiScrollFlags_.ImGuiScrollFlags_KeepVisibleEdgeY
	NavMoveRequestSubmit(ImGuiDir.ImGuiDir_None, offset < 0 ? ImGuiDir.ImGuiDir_Up : ImGuiDir.ImGuiDir_Down, move_flags, scroll_flags); // FIXME-NAV: Once we refactor tabbing, add LegacyApi flag to not activate non-inputable.
	if offset == -1 {
		NavMoveRequestResolveWithLastItem(&g.NavMoveResultLocal)
	}
	else {
		g.NavTabbingDir = 1
		g.NavTabbingCounter = offset + 1
	}
}

// Focus, Activation
// make last item the default focused item of of a newly appearing window.
SetItemDefaultFocus :: proc()
{
	g : ^ImGuiContext = GImGui
	window : ^ImGuiWindow = g.CurrentWindow
	if !window.Appearing { return }
	if g.NavWindow != window.RootWindowForNav || (!g.NavInitRequest && g.NavInitResult.ID == 0) || g.NavLayer != window.DC.NavLayerCurrent { return }

	g.NavInitRequest = false
	NavApplyItemToResult(&g.NavInitResult)
	NavUpdateAnyRequestFlag()

	// Scroll could be done in NavInitRequestApplyResult() via an opt-in flag (we however don't want regular init requests to scroll)
	if !Contains(window.ClipRect, g.LastItemData.Rect) { ScrollToRectEx(window, g.LastItemData.Rect, ImGuiScrollFlags_.ImGuiScrollFlags_None) }
}

// replace current window storage with our own (if you want to manipulate it yourself, typically clear subsection of it)
SetStateStorage :: proc(tree : ^ImGuiStorage)
{
	window : ^ImGuiWindow = GImGui.CurrentWindow
	window.DC.StateStorage = tree != nil ? tree : &window.StateStorage
}

GetStateStorage :: proc() -> ^ImGuiStorage
{
	window : ^ImGuiWindow = GImGui.CurrentWindow
	return window.DC.StateStorage
}

// Miscellaneous Utilities
// test if rectangle (of given size, starting from cursor position) is visible / not clipped.
// test if rectangle (in screen space) is visible / not clipped. to perform coarse clipping on user's side.
IsRectVisible_0 :: proc(size : ImVec2) -> bool
{
	window : ^ImGuiWindow = GImGui.CurrentWindow
	return Overlaps(window.ClipRect, ImRect{window.DC.CursorPos, window.DC.CursorPos + size})
}

// Miscellaneous Utilities
// test if rectangle (of given size, starting from cursor position) is visible / not clipped.
// test if rectangle (in screen space) is visible / not clipped. to perform coarse clipping on user's side.
IsRectVisible_1 :: proc(rect_min : ImVec2, rect_max : ImVec2) -> bool
{
	window : ^ImGuiWindow = GImGui.CurrentWindow
	return Overlaps(window.ClipRect, ImRect{rect_min, rect_max})
}

//-----------------------------------------------------------------------------
// [SECTION] ID STACK
//-----------------------------------------------------------------------------

// This is one of the very rare legacy case where we use ImGuiWindow methods,
// it should ideally be flattened at some point but it's been used a lots by widgets.

ImGuiWindow_GetID_3 :: proc(this : ^ImGuiWindow, str : string) -> ImGuiID
{
	return ImGuiWindow_GetID_0(this, raw_data(str), mem.ptr_offset(cast(^u8)raw_data(str), len(str)))
}

ImGuiWindow_GetID_0 :: proc(this : ^ImGuiWindow, str : [^]u8, str_end : ^u8 = nil) -> ImGuiID
{
	seed : ImGuiID = back(&this.IDStack)^
	id : ImGuiID = ImHashStr(str, str_end != nil ? cast(uint) mem.ptr_sub(str_end, cast(^u8) str) : 0, seed)
	when ! IMGUI_DISABLE_DEBUG_TOOLS { /* @gen ifndef */
	g : ^ImGuiContext = this.Ctx
	if g.DebugHookIdInfo == id { DebugHookIdInfo(id, .ImGuiDataType_String, str, str_end) }
	} // preproc endif
	return id
}

ImGuiWindow_GetID_1 :: proc(this : ^ImGuiWindow, ptr : rawptr) -> ImGuiID
{
	seed : ImGuiID = back(&this.IDStack)^
	ptr := ptr
	id : ImGuiID = ImHashData(&ptr, size_of(rawptr), seed)
	when ! IMGUI_DISABLE_DEBUG_TOOLS { /* @gen ifndef */
	g : ^ImGuiContext = this.Ctx
	if g.DebugHookIdInfo == id { DebugHookIdInfo(id, cast(ImGuiDataType) ImGuiDataTypePrivate_.ImGuiDataType_Pointer, ptr, nil) }
	} // preproc endif
	return id
}

ImGuiWindow_GetID_2 :: proc(this : ^ImGuiWindow, n : i32) -> ImGuiID
{
	seed : ImGuiID = back(&this.IDStack)^
	n := n
	id : ImGuiID = ImHashData(&n, size_of(n), seed)
	when ! IMGUI_DISABLE_DEBUG_TOOLS { /* @gen ifndef */
	g : ^ImGuiContext = this.Ctx
	if g.DebugHookIdInfo == id { DebugHookIdInfo(id, .ImGuiDataType_S32, cast(rawptr) cast(uintptr) n, nil) }
	} // preproc endif
	return id
}

// This is only used in rare/specific situations to manufacture an ID out of nowhere.
// FIXME: Consider instead storing last non-zero ID + count of successive zero-ID, and combine those?
ImGuiWindow_GetIDFromPos :: proc(this : ^ImGuiWindow, p_abs : ImVec2) -> ImGuiID
{
	seed : ImGuiID = back(&this.IDStack)^
	p_rel : ImVec2 = WindowPosAbsToRel(this, p_abs)
	id : ImGuiID = ImHashData(&p_rel, size_of(p_rel), seed)
	return id
}

// "
ImGuiWindow_GetIDFromRectangle :: proc(this : ^ImGuiWindow, r_abs : ImRect) -> ImGuiID
{
	seed : ImGuiID = back(&this.IDStack)^
	r_rel : ImRect = WindowRectAbsToRel(this, r_abs)
	id : ImGuiID = ImHashData(&r_rel, size_of(r_rel), seed)
	return id
}

// ID stack/scopes
// Read the FAQ (docs/FAQ.md or http://dearimgui.com/faq) for more details about how ID are handled in dear imgui.
// - Those questions are answered and impacted by understanding of the ID stack system:
//   - "Q: Why is my widget not reacting when I click on it?"
//   - "Q: How can I have widgets with an empty label?"
//   - "Q: How can I have multiple widgets with the same label?"
// - Short version: ID are hashes of the entire ID stack. If you are creating widgets in a loop you most likely
//   want to push a unique identifier (e.g. object pointer, loop index) to uniquely differentiate them.
// - You can also use the "Label##foobar" syntax within widget label to distinguish them from each others.
// - In this header file we use the "label"/"name" terminology to denote a string that will be displayed + used as an ID,
//   whereas "str_id" denote a string that is only used as an ID and not normally displayed.
// push string into the ID stack (will hash string).
PushID_0 :: proc(str_id : string)
{
	g : ^ImGuiContext = GImGui
	window : ^ImGuiWindow = g.CurrentWindow
	id : ImGuiID = GetID(window, str_id)
	push_back(&window.IDStack, id)
}

// push string into the ID stack (will hash string).
PushID_1 :: proc(str_id_begin : ^u8, str_id_end : ^u8)
{
	g : ^ImGuiContext = GImGui
	window : ^ImGuiWindow = g.CurrentWindow
	id : ImGuiID = GetID(window, str_id_begin, str_id_end)
	push_back(&window.IDStack, id)
}

// push pointer into the ID stack (will hash pointer).
PushID_2 :: proc(ptr_id : rawptr)
{
	g : ^ImGuiContext = GImGui
	window : ^ImGuiWindow = g.CurrentWindow
	id : ImGuiID = GetID(window, ptr_id)
	push_back(&window.IDStack, id)
}

// push integer into the ID stack (will hash integer).
PushID_3 :: proc(int_id : i32)
{
	g : ^ImGuiContext = GImGui
	window : ^ImGuiWindow = g.CurrentWindow
	id : ImGuiID = GetID(window, int_id)
	push_back(&window.IDStack, id)
}

// Push given value as-is at the top of the ID stack (whereas PushID combines old and new hashes)
// Push a given id value ignoring the ID stack as a seed.
PushOverrideID :: proc(id : ImGuiID)
{
	g : ^ImGuiContext = GImGui
	window : ^ImGuiWindow = g.CurrentWindow
	when ! IMGUI_DISABLE_DEBUG_TOOLS { /* @gen ifndef */
	if g.DebugHookIdInfo == id { DebugHookIdInfo(id, cast(ImGuiDataType) ImGuiDataTypePrivate_.ImGuiDataType_ID, nil, nil) }
	} // preproc endif
	push_back(&window.IDStack, id)
}

// Helper to avoid a common series of PushOverrideID -> GetID() -> PopID() call
// (note that when using this pattern, ID Stack Tool will tend to not display the intermediate stack level.
//  for that to work we would need to do PushOverrideID() -> ItemAdd() -> PopID() which would alter widget code a little more)
GetIDWithSeed_0 :: proc(str : string, seed : ImGuiID) -> ImGuiID
{
	id : ImGuiID = ImHashStr(str, seed)
	when ! IMGUI_DISABLE_DEBUG_TOOLS { /* @gen ifndef */
	g : ^ImGuiContext = GImGui
	if g.DebugHookIdInfo == id { DebugHookIdInfo(id, ImGuiDataType_.ImGuiDataType_String, raw_data(str), &raw_data(str)[len(str)]) }
	} // preproc endif
	return id
}

GetIDWithSeed_1 :: proc(n : i32, seed : ImGuiID) -> ImGuiID
{
	n := n
	id : ImGuiID = ImHashData(&n, size_of(n), seed)
	when ! IMGUI_DISABLE_DEBUG_TOOLS { /* @gen ifndef */
	g : ^ImGuiContext = GImGui
	if g.DebugHookIdInfo == id { DebugHookIdInfo(id, ImGuiDataType_.ImGuiDataType_S32, cast(rawptr) cast(uintptr) n, nil) }
	} // preproc endif
	return id
}

// pop from the ID stack.
PopID :: proc()
{
	window : ^ImGuiWindow = GImGui.CurrentWindow
	if window.IDStack.Size <= 1 {
		IM_ASSERT_USER_ERROR(false, "Calling PopID() too many times!")
		return
	}
	pop_back(&window.IDStack)
}

// calculate unique ID (hash of whole ID stack + given parameter). e.g. if you want to query into ImGuiStorage yourself
GetID_0 :: proc(str_id : string) -> ImGuiID
{
	window : ^ImGuiWindow = GImGui.CurrentWindow
	return GetID(window, str_id)
}

// calculate unique ID (hash of whole ID stack + given parameter). e.g. if you want to query into ImGuiStorage yourself
GetID_1 :: proc(str_id_begin : [^]u8, str_id_end : ^u8) -> ImGuiID
{
	window : ^ImGuiWindow = GImGui.CurrentWindow
	return GetID(window, str_id_begin, str_id_end)
}

// calculate unique ID (hash of whole ID stack + given parameter). e.g. if you want to query into ImGuiStorage yourself
GetID_2 :: proc(ptr_id : rawptr) -> ImGuiID
{
	window : ^ImGuiWindow = GImGui.CurrentWindow
	return GetID(window, ptr_id)
}

// calculate unique ID (hash of whole ID stack + given parameter). e.g. if you want to query into ImGuiStorage yourself
GetID_3 :: proc(int_id : i32) -> ImGuiID
{
	window : ^ImGuiWindow = GImGui.CurrentWindow
	return GetID(window, int_id)
}


//-----------------------------------------------------------------------------
// [SECTION] INPUTS
//-----------------------------------------------------------------------------
// - GetModForLRModKey() [Internal]
// - FixupKeyChord() [Internal]
// - GetKeyData() [Internal]
// - GetKeyIndex() [Internal]
// - GetKeyName()
// - GetKeyChordName() [Internal]
// - CalcTypematicRepeatAmount() [Internal]
// - GetTypematicRepeatRate() [Internal]
// - GetKeyPressedAmount() [Internal]
// - GetKeyMagnitude2d() [Internal]
//-----------------------------------------------------------------------------
// - UpdateKeyRoutingTable() [Internal]
// - GetRoutingIdFromOwnerId() [Internal]
// - GetShortcutRoutingData() [Internal]
// - CalcRoutingScore() [Internal]
// - SetShortcutRouting() [Internal]
// - TestShortcutRouting() [Internal]
//-----------------------------------------------------------------------------
// - IsKeyDown()
// - IsKeyPressed()
// - IsKeyReleased()
//-----------------------------------------------------------------------------
// - IsMouseDown()
// - IsMouseClicked()
// - IsMouseReleased()
// - IsMouseDoubleClicked()
// - GetMouseClickedCount()
// - IsMouseHoveringRect() [Internal]
// - IsMouseDragPastThreshold() [Internal]
// - IsMouseDragging()
// - GetMousePos()
// - SetMousePos() [Internal]
// - GetMousePosOnOpeningCurrentPopup()
// - IsMousePosValid()
// - IsAnyMouseDown()
// - GetMouseDragDelta()
// - ResetMouseDragDelta()
// - GetMouseCursor()
// - SetMouseCursor()
//-----------------------------------------------------------------------------
// - UpdateAliasKey()
// - GetMergedModsFromKeys()
// - UpdateKeyboardInputs()
// - UpdateMouseInputs()
//-----------------------------------------------------------------------------
// - LockWheelingWindow [Internal]
// - FindBestWheelingWindow [Internal]
// - UpdateMouseWheel() [Internal]
//-----------------------------------------------------------------------------
// - SetNextFrameWantCaptureKeyboard()
// - SetNextFrameWantCaptureMouse()
//-----------------------------------------------------------------------------
// - GetInputSourceName() [Internal]
// - DebugPrintInputEvent() [Internal]
// - UpdateInputEvents() [Internal]
//-----------------------------------------------------------------------------
// - GetKeyOwner() [Internal]
// - TestKeyOwner() [Internal]
// - SetKeyOwner() [Internal]
// - SetItemKeyOwner() [Internal]
// - Shortcut() [Internal]
//-----------------------------------------------------------------------------

GetModForLRModKey :: proc(key : ImGuiKey) -> ImGuiKeyChord
{
	if key == ImGuiKey.ImGuiKey_LeftCtrl || key == ImGuiKey.ImGuiKey_RightCtrl { return ImGuiKey.ImGuiMod_Ctrl }
	if key == ImGuiKey.ImGuiKey_LeftShift || key == ImGuiKey.ImGuiKey_RightShift { return ImGuiKey.ImGuiMod_Shift }
	if key == ImGuiKey.ImGuiKey_LeftAlt || key == ImGuiKey.ImGuiKey_RightAlt { return ImGuiKey.ImGuiMod_Alt }
	if key == ImGuiKey.ImGuiKey_LeftSuper || key == ImGuiKey.ImGuiKey_RightSuper { return ImGuiKey.ImGuiMod_Super }
	return ImGuiKey.ImGuiMod_None
}

FixupKeyChord :: proc(key_chord : ImGuiKeyChord) -> ImGuiKeyChord
{
	key_chord := key_chord
	// Add ImGuiMod_XXXX when a corresponding ImGuiKey_LeftXXX/ImGuiKey_RightXXX is specified.
	key : ImGuiKey = cast(ImGuiKey) (key_chord & cast(ImGuiKey) ~cast(i32) ImGuiKey.ImGuiMod_Mask_)
	if IsLRModKey(key) { key_chord |= GetModForLRModKey(key) }
	return key_chord
}

GetKeyData_0 :: proc(ctx : ^ImGuiContext, key : ImGuiKey) -> ^ImGuiKeyData
{
	g : ^ImGuiContext = ctx

	key := key
	// Special storage location for mods
	if (key & ImGuiKey.ImGuiMod_Mask_) != {} { key = ConvertSingleModFlagToKey(key) }

	IM_ASSERT(IsNamedKey(key), "Support for user key indices was dropped in favor of ImGuiKey. Please update backend & user code.")
	return &g.IO.KeysData[key - ImGuiKey.ImGuiKey_NamedKey_BEGIN]
}

// Those names a provided for debugging purpose and are not meant to be saved persistently not compared.
GKeyNames := [?]string {
	"Tab", "LeftArrow", "RightArrow", "UpArrow", "DownArrow", "PageUp", "PageDown",
	"Home", "End", "Insert", "Delete", "Backspace", "Space", "Enter", "Escape",
	"LeftCtrl", "LeftShift", "LeftAlt", "LeftSuper", "RightCtrl", "RightShift", "RightAlt", "RightSuper", "Menu",
	"0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "A", "B", "C", "D", "E", "F", "G", "H",
	"I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z",
	"F1", "F2", "F3", "F4", "F5", "F6", "F7", "F8", "F9", "F10", "F11", "F12",
	"F13", "F14", "F15", "F16", "F17", "F18", "F19", "F20", "F21", "F22", "F23", "F24",
	"Apostrophe", "Comma", "Minus", "Period", "Slash", "Semicolon", "Equal", "LeftBracket",
	"Backslash", "RightBracket", "GraveAccent", "CapsLock", "ScrollLock", "NumLock", "PrintScreen",
	"Pause", "Keypad0", "Keypad1", "Keypad2", "Keypad3", "Keypad4", "Keypad5", "Keypad6",
	"Keypad7", "Keypad8", "Keypad9", "KeypadDecimal", "KeypadDivide", "KeypadMultiply",
	"KeypadSubtract", "KeypadAdd", "KeypadEnter", "KeypadEqual",
	"AppBack", "AppForward",
	"GamepadStart", "GamepadBack",
	"GamepadFaceLeft", "GamepadFaceRight", "GamepadFaceUp", "GamepadFaceDown",
	"GamepadDpadLeft", "GamepadDpadRight", "GamepadDpadUp", "GamepadDpadDown",
	"GamepadL1", "GamepadR1", "GamepadL2", "GamepadR2", "GamepadL3", "GamepadR3",
	"GamepadLStickLeft", "GamepadLStickRight", "GamepadLStickUp", "GamepadLStickDown",
	"GamepadRStickLeft", "GamepadRStickRight", "GamepadRStickUp", "GamepadRStickDown",
	"MouseLeft", "MouseRight", "MouseMiddle", "MouseX1", "MouseX2", "MouseWheelX", "MouseWheelY",
	"ModCtrl", "ModShift", "ModAlt", "ModSuper", // ReservedForModXXX are showing the ModXXX names.
}
#assert(int(ImGuiKey.ImGuiKey_NamedKey_COUNT) == len(GKeyNames))

// [DEBUG] returns English name of the key. Those names a provided for debugging purpose and are not meant to be saved persistently not compared.
GetKeyName :: proc(key : ImGuiKey) -> string
{
	key := key
	if key == ImGuiKey.ImGuiKey_None { return "None" }
	IM_ASSERT(IsNamedKeyOrMod(key), "Support for user key indices was dropped in favor of ImGuiKey. Please update backend and user code.")
	if (key & ImGuiKey.ImGuiMod_Mask_) != {} { key = ConvertSingleModFlagToKey(key) }
	if !IsNamedKey(key) { return "Unknown" }

	return GKeyNames[key - ImGuiKey.ImGuiKey_NamedKey_BEGIN]
}

// Return untranslated names: on macOS, Cmd key will show as Ctrl, Ctrl key will show as super.
// Lifetime of return value: valid until next call to same function.
GetKeyChordName :: proc(key_chord : ImGuiKeyChord) -> [^]u8
{
	g : ^ImGuiContext = GImGui

	key_chord := key_chord
	key : ImGuiKey = cast(ImGuiKey) (key_chord & cast(ImGuiKey)~cast(i32)ImGuiKey.ImGuiMod_Mask_)
	if IsLRModKey(key) {
		// Return "Ctrl+LeftShift" instead of "Ctrl+Shift+LeftShift"
		key_chord &= cast(ImGuiKeyChord)~cast(i32)GetModForLRModKey(key)
	}
	ImFormatString(g.TempKeychordName[:], "%s%s%s%s%s", (key_chord & ImGuiKey.ImGuiMod_Ctrl) != {} ? "Ctrl+" : "", (key_chord & ImGuiKey.ImGuiMod_Shift) != {} ? "Shift+" : "", (key_chord & ImGuiKey.ImGuiMod_Alt) != {} ? "Alt+" : "", (key_chord & ImGuiKey.ImGuiMod_Super) != {} ? "Super+" : "", (key != ImGuiKey.ImGuiKey_None || key_chord == ImGuiKey.ImGuiKey_None) ? GetKeyName(key) : "")
	if key == ImGuiKey.ImGuiKey_None && key_chord != {} {
		len := strlen(raw_data(&g.TempKeychordName))
		if len != 0 {
			// Remove trailing '+'
			g.TempKeychordName[len - 1] = 0
		}
	}
	return raw_data(&g.TempKeychordName)
}

// t0 = previous time (e.g.: g.Time - g.IO.DeltaTime)
// t1 = current time (e.g.: g.Time)
// An event is triggered at:
//  t = 0.0f     t = repeat_delay,    t = repeat_delay + repeat_rate*N
CalcTypematicRepeatAmount :: proc(t0 : f32, t1 : f32, repeat_delay : f32, repeat_rate : f32) -> i32
{
	if t1 == 0.0 { return 1 }
	if t0 >= t1 { return 0 }
	if repeat_rate <= 0.0 { return (t0 < repeat_delay) && (t1 >= repeat_delay) ? 1 : 0 }
	count_t0 : i32 = (t0 < repeat_delay) ? -1 : cast(i32) ((t0 - repeat_delay) / repeat_rate)
	count_t1 : i32 = (t1 < repeat_delay) ? -1 : cast(i32) ((t1 - repeat_delay) / repeat_rate)
	count : i32 = count_t1 - count_t0
	return count
}

GetTypematicRepeatRate :: proc(flags : ImGuiInputFlags, repeat_delay : ^f32, repeat_rate : ^f32)
{
	g : ^ImGuiContext = GImGui
	#partial switch (flags & cast(ImGuiInputFlags) ImGuiInputFlagsPrivate_.ImGuiInputFlags_RepeatRateMask_) {
		case cast(ImGuiInputFlags)ImGuiInputFlagsPrivate_.ImGuiInputFlags_RepeatRateNavMove:
			repeat_delay^ = g.IO.KeyRepeatDelay * 0.72
			repeat_rate^ = g.IO.KeyRepeatRate * 0.80
			return
		case cast(ImGuiInputFlags)ImGuiInputFlagsPrivate_.ImGuiInputFlags_RepeatRateNavTweak:
			repeat_delay^ = g.IO.KeyRepeatDelay * 0.72
			repeat_rate^ = g.IO.KeyRepeatRate * 0.30
			return
		case cast(ImGuiInputFlags)ImGuiInputFlagsPrivate_.ImGuiInputFlags_RepeatRateDefault: fallthrough
		case:
			repeat_delay^ = g.IO.KeyRepeatDelay * 1.00
			repeat_rate^ = g.IO.KeyRepeatRate * 1.00
			return
	}
}

// uses provided repeat rate/delay. return a count, most often 0 or 1 but might be >1 if RepeatRate is small enough that DeltaTime > RepeatRate
// Return value representing the number of presses in the last time period, for the given repeat rate
// (most often returns 0 or 1. The result is generally only >1 when RepeatRate is smaller than DeltaTime, aka large DeltaTime or fast RepeatRate)
GetKeyPressedAmount :: proc(key : ImGuiKey, repeat_delay : f32, repeat_rate : f32) -> i32
{
	g : ^ImGuiContext = GImGui
	key_data : ^ImGuiKeyData = GetKeyData(key)
	if !key_data.Down {
		// In theory this should already be encoded as (DownDuration < 0.0f), but testing this facilitates eating mechanism (until we finish work on key ownership)
		return 0
	}
	t : f32 = key_data.DownDuration
	return CalcTypematicRepeatAmount(t - g.IO.DeltaTime, t, repeat_delay, repeat_rate)
}

// Return 2D vector representing the combination of four cardinal direction, with analog value support (for e.g. ImGuiKey_GamepadLStick* values).
GetKeyMagnitude2d :: proc(key_left : ImGuiKey, key_right : ImGuiKey, key_up : ImGuiKey, key_down : ImGuiKey) -> ImVec2
{
	return ImVec2{GetKeyData(key_right).AnalogValue - GetKeyData(key_left).AnalogValue, GetKeyData(key_down).AnalogValue - GetKeyData(key_up).AnalogValue}
}

// Rewrite routing data buffers to strip old entries + sort by key to make queries not touch scattered data.
//   Entries   D,A,B,B,A,C,B     --> A,A,B,B,B,C,D
//   Index     A:1 B:2 C:5 D:0   --> A:0 B:2 C:5 D:6
// See 'Metrics->Key Owners & Shortcut Routing' to visualize the result of that operation.
UpdateKeyRoutingTable :: proc(rt : ^ImGuiKeyRoutingTable)
{
	g : ^ImGuiContext = GImGui
	resize(&rt.EntriesNext, 0)
	for key := ImGuiKey.ImGuiKey_NamedKey_BEGIN; key < ImGuiKey.ImGuiKey_NamedKey_END; key += ImGuiKey(1) {
		new_routing_start_idx : i32 = rt.EntriesNext.Size
		routing_entry : ^ImGuiKeyRoutingData
		for old_routing_idx := rt.Index[key - ImGuiKey.ImGuiKey_NamedKey_BEGIN]; old_routing_idx != -1; old_routing_idx = routing_entry.NextEntryIndex {
			routing_entry = &rt.Entries.Data[old_routing_idx]
			routing_entry.RoutingCurrScore = routing_entry.RoutingNextScore
			routing_entry.RoutingCurr = routing_entry.RoutingNext; // Update entry
			routing_entry.RoutingNext = ImGuiKeyOwner_NoOwner
			routing_entry.RoutingNextScore = 255
			if routing_entry.RoutingCurr == ImGuiKeyOwner_NoOwner { continue }
			push_back(&rt.EntriesNext, routing_entry^); // Write alive ones into new buffer

			// Apply routing to owner if there's no owner already (RoutingCurr == None at this point)
			// This is the result of previous frame's SetShortcutRouting() call.
			if ImGuiKey(routing_entry.Mods) == g.IO.KeyMods {
				owner_data : ^ImGuiKeyOwnerData = GetKeyOwnerData(g, key)
				if owner_data.OwnerCurr == ImGuiKeyOwner_NoOwner {
					owner_data.OwnerCurr = routing_entry.RoutingCurr
					//IMGUI_DEBUG_LOG("SetKeyOwner(%s, owner_id=0x%08X) via Routing\n", GetKeyName(key), routing_entry->RoutingCurr);
				}
			}
		}

		// Rewrite linked-list
		rt.Index[key - ImGuiKey.ImGuiKey_NamedKey_BEGIN] = cast(ImGuiKeyRoutingIndex) (new_routing_start_idx < rt.EntriesNext.Size ? new_routing_start_idx : -1)
		for n : i32 = new_routing_start_idx; n < rt.EntriesNext.Size; n += 1 { rt.EntriesNext.Data[n].NextEntryIndex = cast(ImGuiKeyRoutingIndex) ((n + 1 < rt.EntriesNext.Size) ? n + 1 : -1) }
	}

	swap(&rt.Entries, &rt.EntriesNext); // Swap new and old indexes
}

// owner_id may be None/Any, but routing_id needs to be always be set, so we default to GetCurrentFocusScope().
GetRoutingIdFromOwnerId :: #force_inline proc(owner_id : ImGuiID) -> ImGuiID
{
	g : ^ImGuiContext = GImGui
	return (owner_id != ImGuiKeyOwner_NoOwner && owner_id != ImGuiKeyOwner_Any) ? owner_id : g.CurrentFocusScopeId
}

GetShortcutRoutingData :: proc(key_chord : ImGuiKeyChord) -> ^ImGuiKeyRoutingData
{
	// Majority of shortcuts will be Key + any number of Mods
	// We accept _Single_ mod with ImGuiKey_None.
	//  - Shortcut(ImGuiKey_S | ImGuiMod_Ctrl);                    // Legal
	//  - Shortcut(ImGuiKey_S | ImGuiMod_Ctrl | ImGuiMod_Shift);   // Legal
	//  - Shortcut(ImGuiMod_Ctrl);                                 // Legal
	//  - Shortcut(ImGuiMod_Ctrl | ImGuiMod_Shift);                // Not legal
	g : ^ImGuiContext = GImGui
	rt : ^ImGuiKeyRoutingTable = &g.KeysRoutingTable
	routing_data : ^ImGuiKeyRoutingData
	key : ImGuiKey = cast(ImGuiKey) (key_chord & cast(ImGuiKey)~cast(i32)ImGuiKey.ImGuiMod_Mask_)
	mods : ImGuiKey = cast(ImGuiKey) (key_chord & ImGuiKey.ImGuiMod_Mask_)
	if key == ImGuiKey.ImGuiKey_None { key = ConvertSingleModFlagToKey(mods) }
	IM_ASSERT(IsNamedKey(key))

	// Get (in the majority of case, the linked list will have one element so this should be 2 reads.
	// Subsequent elements will be contiguous in memory as list is sorted/rebuilt in NewFrame).
	for idx : ImGuiKeyRoutingIndex = rt.Index[key - ImGuiKey.ImGuiKey_NamedKey_BEGIN]; idx != -1; idx = routing_data.NextEntryIndex {
		routing_data = &rt.Entries.Data[idx]
		if cast(ImGuiKey) routing_data.Mods == mods { return routing_data }
	}

	// Add to linked-list
	routing_data_idx : ImGuiKeyRoutingIndex = cast(ImGuiKeyRoutingIndex) rt.Entries.Size
	rd : ImGuiKeyRoutingData
	init(&rd)
	push_back(&rt.Entries, rd)
	routing_data = &rt.Entries.Data[routing_data_idx]
	routing_data.Mods = cast(ImU16) mods
	routing_data.NextEntryIndex = rt.Index[key - ImGuiKey.ImGuiKey_NamedKey_BEGIN]; // Setup linked list
	rt.Index[key - ImGuiKey.ImGuiKey_NamedKey_BEGIN] = routing_data_idx
	return routing_data
}

// Current score encoding (lower is highest priority):
//  -   0: ImGuiInputFlags_RouteGlobal | ImGuiInputFlags_RouteOverActive
//  -   1: ImGuiInputFlags_ActiveItem or ImGuiInputFlags_RouteFocused (if item active)
//  -   2: ImGuiInputFlags_RouteGlobal | ImGuiInputFlags_RouteOverFocused
//  -  3+: ImGuiInputFlags_RouteFocused (if window in focus-stack)
//  - 254: ImGuiInputFlags_RouteGlobal
//  - 255: never route
// 'flags' should include an explicit routing policy
CalcRoutingScore :: proc(focus_scope_id : ImGuiID, owner_id : ImGuiID, flags : ImGuiInputFlags) -> i32
{
	g : ^ImGuiContext = GImGui
	if (flags & ImGuiInputFlags_.ImGuiInputFlags_RouteFocused) != {} {
		// ActiveID gets top priority
		// (we don't check g.ActiveIdUsingAllKeys here. Routing is applied but if input ownership is tested later it may discard it)
		if owner_id != 0 && g.ActiveId == owner_id { return 1 }

		// Score based on distance to focused window (lower is better)
		// Assuming both windows are submitting a routing request,
		// - When Window....... is focused -> Window scores 3 (best), Window/ChildB scores 255 (no match)
		// - When Window/ChildB is focused -> Window scores 4,        Window/ChildB scores 3 (best)
		// Assuming only WindowA is submitting a routing request,
		// - When Window/ChildB is focused -> Window scores 4 (best), Window/ChildB doesn't have a score.
		// This essentially follow the window->ParentWindowForFocusRoute chain.
		if focus_scope_id == 0 { return 255 }
		for index_in_focus_path : i32 = 0; index_in_focus_path < g.NavFocusRoute.Size; index_in_focus_path += 1 { if g.NavFocusRoute.Data[index_in_focus_path].ID == focus_scope_id { return 3 + index_in_focus_path } }

		return 255
	}
	else if (flags & ImGuiInputFlags_.ImGuiInputFlags_RouteActive) != {} {
		if owner_id != 0 && g.ActiveId == owner_id { return 1 }
		return 255
	}
	else if (flags & ImGuiInputFlags_.ImGuiInputFlags_RouteGlobal) != {} {
		if (flags & ImGuiInputFlags_.ImGuiInputFlags_RouteOverActive) != {} { return 0 }
		if (flags & ImGuiInputFlags_.ImGuiInputFlags_RouteOverFocused) != {} { return 2 }
		return 254
	}
	IM_ASSERT(false)
	return 0
}

// - We need this to filter some Shortcut() routes when an item e.g. an InputText() is active
//   e.g. ImGuiKey_G won't be considered a shortcut when item is active, but ImGuiMod|ImGuiKey_G can be.
// - This is also used by UpdateInputEvents() to avoid trickling in the most common case of e.g. pressing ImGuiKey_G also emitting a G character.
IsKeyChordPotentiallyCharInput :: proc(key_chord : ImGuiKeyChord) -> bool
{
	// Mimic 'ignore_char_inputs' logic in InputText()
	g : ^ImGuiContext = GImGui

	// When the right mods are pressed it cannot be a char input so we won't filter the shortcut out.
	mods : ImGuiKey = cast(ImGuiKey) (key_chord & ImGuiKey.ImGuiMod_Mask_)
	ignore_char_inputs : bool = ((mods & ImGuiKey.ImGuiMod_Ctrl) != {} && (mods & ImGuiKey.ImGuiMod_Alt) == {}) || (g.IO.ConfigMacOSXBehaviors && (mods & ImGuiKey.ImGuiMod_Ctrl) != {})
	if ignore_char_inputs { return false }

	// Return true for A-Z, 0-9 and other keys associated to char inputs. Other keys such as F1-F12 won't be filtered.
	key : ImGuiKey = cast(ImGuiKey) (key_chord & cast(ImGuiKey)~cast(i32)ImGuiKey.ImGuiMod_Mask_)
	if key == ImGuiKey.ImGuiKey_None { return false }
	return TestBit(&g.KeysMayBeCharInput, cast(u32)key)
}

// owner_id needs to be explicit and cannot be 0
// Request a desired route for an input chord (key + mods).
// Return true if the route is available this frame.
// - Routes and key ownership are attributed at the beginning of next frame based on best score and mod state.
//   (Conceptually this does a "Submit for next frame" + "Test for current frame".
//   As such, it could be called TrySetXXX or SubmitXXX, or the Submit and Test operations should be separate.)
SetShortcutRouting :: proc(key_chord : ImGuiKeyChord, flags : ImGuiInputFlags, owner_id : ImGuiID) -> bool
{
	g : ^ImGuiContext = GImGui
	flags := flags
	if (flags & cast(ImGuiInputFlags) ImGuiInputFlagsPrivate_.ImGuiInputFlags_RouteTypeMask_) == {} {
		// IMPORTANT: This is the default for SetShortcutRouting() but NOT Shortcut()
		flags |= ImGuiInputFlags_.ImGuiInputFlags_RouteGlobal | ImGuiInputFlags_.ImGuiInputFlags_RouteOverFocused | ImGuiInputFlags_.ImGuiInputFlags_RouteOverActive
	}
	else {
		// Check that only 1 routing flag is used
		IM_ASSERT(ImIsPowerOfTwo(u32(flags & cast(ImGuiInputFlags) ImGuiInputFlagsPrivate_.ImGuiInputFlags_RouteTypeMask_)))
	}
	IM_ASSERT(owner_id != ImGuiKeyOwner_Any && owner_id != ImGuiKeyOwner_NoOwner)
	if (flags & (ImGuiInputFlags_.ImGuiInputFlags_RouteOverFocused | ImGuiInputFlags_.ImGuiInputFlags_RouteOverActive | ImGuiInputFlags_.ImGuiInputFlags_RouteUnlessBgFocused)) != {} { IM_ASSERT((flags & ImGuiInputFlags_.ImGuiInputFlags_RouteGlobal) != {}) }

	key_chord := key_chord
	// Add ImGuiMod_XXXX when a corresponding ImGuiKey_LeftXXX/ImGuiKey_RightXXX is specified.
	key_chord = FixupKeyChord(key_chord)

	// [DEBUG] Debug break requested by user
	if g.DebugBreakInShortcutRouting == key_chord { IM_DEBUG_BREAK() }

	if (flags & ImGuiInputFlags_.ImGuiInputFlags_RouteUnlessBgFocused) != {} { if g.NavWindow == nil { return false } }

	// Note how ImGuiInputFlags_RouteAlways won't set routing and thus won't set owner. May want to rework this?
	if (flags & ImGuiInputFlags_.ImGuiInputFlags_RouteAlways) != {} {
		IMGUI_DEBUG_LOG_INPUTROUTING(g, "SetShortcutRouting(%s, flags=%04X, owner_id=0x%08X) -> always, no register\n", GetKeyChordName(key_chord), flags, owner_id)
		return true
	}

	// Specific culling when there's an active item.
	if g.ActiveId != 0 && g.ActiveId != owner_id {
		if (flags & ImGuiInputFlags_.ImGuiInputFlags_RouteActive) != {} { return false }

		// Cull shortcuts with no modifiers when it could generate a character.
		// e.g. Shortcut(ImGuiKey_G) also generates 'g' character, should not trigger when InputText() is active.
		// but  Shortcut(Ctrl+G) should generally trigger when InputText() is active.
		// TL;DR: lettered shortcut with no mods or with only Alt mod will not trigger while an item reading text input is active.
		// (We cannot filter based on io.InputQueueCharacters.Data[] contents because of trickling and key<>chars submission order are undefined)
		if g.IO.WantTextInput && IsKeyChordPotentiallyCharInput(key_chord) {
			IMGUI_DEBUG_LOG_INPUTROUTING(g, "SetShortcutRouting(%s, flags=%04X, owner_id=0x%08X) -> filtered as potential char input\n", GetKeyChordName(key_chord), flags, owner_id)
			return false
		}

		// ActiveIdUsingAllKeyboardKeys trumps all for ActiveId
		if (flags & ImGuiInputFlags_.ImGuiInputFlags_RouteOverActive) == {} && g.ActiveIdUsingAllKeyboardKeys {
			key : ImGuiKey = cast(ImGuiKey) (key_chord & cast(ImGuiKey)~cast(i32)ImGuiKey.ImGuiMod_Mask_)
			if key == ImGuiKey.ImGuiKey_None { key = ConvertSingleModFlagToKey(cast(ImGuiKey) (key_chord & ImGuiKey.ImGuiMod_Mask_)) }
			if key >= ImGuiKey_Keyboard_BEGIN && key < ImGuiKey_Keyboard_END { return false }
		}
	}

	// Where do we evaluate route for?
	focus_scope_id : ImGuiID = g.CurrentFocusScopeId
	if (flags & ImGuiInputFlags_.ImGuiInputFlags_RouteFromRootWindow) != {} {
		// See PushFocusScope() call in Begin()
		focus_scope_id = g.CurrentWindow.RootWindow.ID
	}

	score : i32 = CalcRoutingScore(focus_scope_id, owner_id, flags)
	IMGUI_DEBUG_LOG_INPUTROUTING(g, "SetShortcutRouting(%s, flags=%04X, owner_id=0x%08X) -> score %d\n", GetKeyChordName(key_chord), flags, owner_id, score)
	if score == 255 { return false }

	// Submit routing for NEXT frame (assuming score is sufficient)
	// FIXME: Could expose a way to use a "serve last" policy for same score resolution (using <= instead of <).
	routing_data : ^ImGuiKeyRoutingData = GetShortcutRoutingData(key_chord)
	//const bool set_route = (flags & ImGuiInputFlags_ServeLast) ? (score <= routing_data->RoutingNextScore) : (score < routing_data->RoutingNextScore);
	if score < cast(i32)routing_data.RoutingNextScore {
		routing_data.RoutingNext = owner_id
		routing_data.RoutingNextScore = cast(ImU8) score
	}

	// Return routing state for CURRENT frame
	if routing_data.RoutingCurr == owner_id { IMGUI_DEBUG_LOG_INPUTROUTING(g, "--> granting current route\n") }
	return routing_data.RoutingCurr == owner_id
}

// Currently unused by core (but used by tests)
// Note: this cannot be turned into GetShortcutRouting() because we do the owner_id->routing_id translation, name would be more misleading.
TestShortcutRouting :: proc(key_chord : ImGuiKeyChord, owner_id : ImGuiID) -> bool
{
	routing_id : ImGuiID = GetRoutingIdFromOwnerId(owner_id)
	key_chord := FixupKeyChord(key_chord)
	routing_data : ^ImGuiKeyRoutingData = GetShortcutRoutingData(key_chord); // FIXME: Could avoid creating entry.
	return routing_data.RoutingCurr == routing_id
}

// Inputs Utilities: Keyboard/Mouse/Gamepad
// - the ImGuiKey enum contains all possible keyboard, mouse and gamepad inputs (e.g. ImGuiKey_A, ImGuiKey_MouseLeft, ImGuiKey_GamepadDpadUp...).
// - (legacy: before v1.87, we used ImGuiKey to carry native/user indices as defined by each backends. This was obsoleted in 1.87 (2022-02) and completely removed in 1.91.5 (2024-11). See https://github.com/ocornut/imgui/issues/4921)
// - (legacy: any use of ImGuiKey will assert when key < 512 to detect passing legacy native/user indices)
// is key being held.
// [EXPERIMENTAL] High-Level: Input Access functions w/ support for Key/Input Ownership
// - Important: legacy IsKeyPressed(ImGuiKey, bool repeat=true) _DEFAULTS_ to repeat, new IsKeyPressed() requires _EXPLICIT_ ImGuiInputFlags_Repeat flag.
// - Expected to be later promoted to public API, the prototypes are designed to replace existing ones (since owner_id can default to Any == 0)
// - Specifying a value for 'ImGuiID owner' will test that EITHER the key is NOT owned (UNLESS locked), EITHER the key is owned by 'owner'.
//   Legacy functions use ImGuiKeyOwner_Any meaning that they typically ignore ownership, unless a call to SetKeyOwner() explicitly used ImGuiInputFlags_LockThisFrame or ImGuiInputFlags_LockUntilRelease.
// - Binding generators may want to ignore those for now, or suffix them with Ex() until we decide if this gets moved into public API.
// Note that Dear ImGui doesn't know the meaning/semantic of ImGuiKey from 0..511: they are legacy native keycodes.
// Consider transitioning from 'IsKeyDown(MY_ENGINE_KEY_A)' (<1.87) to IsKeyDown(ImGuiKey_A) (>= 1.87)
IsKeyDown_0 :: proc(key : ImGuiKey) -> bool
{
	return IsKeyDown(key, ImGuiKeyOwner_Any)
}

IsKeyDown_1 :: proc(key : ImGuiKey, owner_id : ImGuiID) -> bool
{
	key_data : ^ImGuiKeyData = GetKeyData(key)
	if !key_data.Down { return false }
	if !TestKeyOwner(key, owner_id) { return false }
	return true
}

// was key pressed (went from !Down to Down)? if repeat=true, uses io.KeyRepeatDelay / KeyRepeatRate
// Important: when transitioning from old to new IsKeyPressed(): old API has "bool repeat = true", so would default to repeat. New API requiress explicit ImGuiInputFlags_Repeat.
IsKeyPressed_0 :: proc(key : ImGuiKey, repeat : bool = true) -> bool
{
	return IsKeyPressed(key, repeat ? ImGuiInputFlags_.ImGuiInputFlags_Repeat : ImGuiInputFlags_.ImGuiInputFlags_None, ImGuiKeyOwner_Any)
}

// was key pressed (went from !Down to Down)? if repeat=true, uses io.KeyRepeatDelay / KeyRepeatRate
// Important: when transitioning from old to new IsKeyPressed(): old API has "bool repeat = true", so would default to repeat. New API requiress explicit ImGuiInputFlags_Repeat.
// Important: unlike legacy IsKeyPressed(ImGuiKey, bool repeat=true) which DEFAULT to repeat, this requires EXPLICIT repeat.
IsKeyPressed_1 :: proc(key : ImGuiKey, flags : ImGuiInputFlags, owner_id : ImGuiID = 0) -> bool
{
	key_data : ^ImGuiKeyData = GetKeyData(key)
	if !key_data.Down {
		// In theory this should already be encoded as (DownDuration < 0.0f), but testing this facilitates eating mechanism (until we finish work on key ownership)
		return false
	}
	t : f32 = key_data.DownDuration
	if t < 0.0 { return false }
	IM_ASSERT((flags & cast(ImGuiInputFlags)~cast(i32)ImGuiInputFlagsPrivate_.ImGuiInputFlags_SupportedByIsKeyPressed) == {}); // Passing flags not supported by this function!
	flags := flags
	if (flags & cast(ImGuiInputFlags)(ImGuiInputFlagsPrivate_.ImGuiInputFlags_RepeatRateMask_ | ImGuiInputFlagsPrivate_.ImGuiInputFlags_RepeatUntilMask_)) != {} {
		// Setting any _RepeatXXX option enables _Repeat
		flags |= ImGuiInputFlags_.ImGuiInputFlags_Repeat
	}

	pressed : bool = (t == 0.0)
	if !pressed && (flags & ImGuiInputFlags_.ImGuiInputFlags_Repeat) != {} {
		repeat_delay : f32; repeat_rate : f32
		GetTypematicRepeatRate(flags, &repeat_delay, &repeat_rate)
		pressed = (t > repeat_delay) && GetKeyPressedAmount(key, repeat_delay, repeat_rate) > 0
		if pressed && (flags & cast(ImGuiInputFlags) ImGuiInputFlagsPrivate_.ImGuiInputFlags_RepeatUntilMask_) != {} {
			// Slightly bias 'key_pressed_time' as DownDuration is an accumulation of DeltaTime which we compare to an absolute time value.
			// Ideally we'd replace DownDuration with KeyPressedTime but it would break user's code.
			g : ^ImGuiContext = GImGui
			key_pressed_time : f64 = g.Time - cast(f64) t + 0.00001
			if (flags & cast(ImGuiInputFlags) ImGuiInputFlagsPrivate_.ImGuiInputFlags_RepeatUntilKeyModsChange) != {} && (g.LastKeyModsChangeTime > key_pressed_time) { pressed = false }
			if (flags & cast(ImGuiInputFlags) ImGuiInputFlagsPrivate_.ImGuiInputFlags_RepeatUntilKeyModsChangeFromNone) != {} && (g.LastKeyModsChangeFromNoneTime > key_pressed_time) { pressed = false }
			if (flags & cast(ImGuiInputFlags) ImGuiInputFlagsPrivate_.ImGuiInputFlags_RepeatUntilOtherKeyPress) != {} && (g.LastKeyboardKeyPressTime > key_pressed_time) { pressed = false }
		}
	}
	if !pressed { return false }
	if !TestKeyOwner(key, owner_id) { return false }
	return true
}

// was key released (went from Down to !Down)?
IsKeyReleased_0 :: proc(key : ImGuiKey) -> bool
{
	return IsKeyReleased(key, ImGuiKeyOwner_Any)
}

// was key released (went from Down to !Down)?
IsKeyReleased_1 :: proc(key : ImGuiKey, owner_id : ImGuiID) -> bool
{
	key_data : ^ImGuiKeyData = GetKeyData(key)
	if key_data.DownDurationPrev < 0.0 || key_data.Down { return false }
	if !TestKeyOwner(key, owner_id) { return false }
	return true
}

// Inputs Utilities: Mouse
// - To refer to a mouse button, you may use named enums in your code e.g. ImGuiMouseButton_Left, ImGuiMouseButton_Right.
// - You can also use regular integer: it is forever guaranteed that 0=Left, 1=Right, 2=Middle.
// - Dragging operations are only reported after mouse has moved a certain distance away from the initial clicking position (see 'lock_threshold' and 'io.MouseDraggingThreshold')
// is mouse button held?
IsMouseDown_0 :: proc(button : ImGuiMouseButton) -> bool
{
	g : ^ImGuiContext = GImGui
	IM_ASSERT(button >= ImGuiMouseButton(0) && int(button) < len(g.IO.MouseDown))
	return g.IO.MouseDown[button] && TestKeyOwner(MouseButtonToKey(button), ImGuiKeyOwner_Any)// should be same as IsKeyDown(MouseButtonToKey(button), ImGuiKeyOwner_Any), but this allows legacy code hijacking the io.Mousedown[] array.
}

// Inputs Utilities: Mouse
// - To refer to a mouse button, you may use named enums in your code e.g. ImGuiMouseButton_Left, ImGuiMouseButton_Right.
// - You can also use regular integer: it is forever guaranteed that 0=Left, 1=Right, 2=Middle.
// - Dragging operations are only reported after mouse has moved a certain distance away from the initial clicking position (see 'lock_threshold' and 'io.MouseDraggingThreshold')
// is mouse button held?
IsMouseDown_1 :: proc(button : ImGuiMouseButton, owner_id : ImGuiID) -> bool
{
	g : ^ImGuiContext = GImGui
	IM_ASSERT(button >= ImGuiMouseButton(0) && int(button) < len(g.IO.MouseDown))
	return g.IO.MouseDown[button] && TestKeyOwner(MouseButtonToKey(button), owner_id)// Should be same as IsKeyDown(MouseButtonToKey(button), owner_id), but this allows legacy code hijacking the io.Mousedown[] array.
}

// did mouse button clicked? (went from !Down to Down). Same as GetMouseClickedCount() == 1.
IsMouseClicked_0 :: proc(button : ImGuiMouseButton, repeat : bool = false) -> bool
{
	return IsMouseClicked(button, repeat ? ImGuiInputFlags_.ImGuiInputFlags_Repeat : ImGuiInputFlags_.ImGuiInputFlags_None, ImGuiKeyOwner_Any)
}

// did mouse button clicked? (went from !Down to Down). Same as GetMouseClickedCount() == 1.
IsMouseClicked_1 :: proc(button : ImGuiMouseButton, flags : ImGuiInputFlags, owner_id : ImGuiID = 0) -> bool
{
	g : ^ImGuiContext = GImGui
	IM_ASSERT(button >= ImGuiMouseButton(0) && button < cast(ImGuiMouseButton) IM_ARRAYSIZE(g.IO.MouseDown))
	if !g.IO.MouseDown[button] {
		// In theory this should already be encoded as (DownDuration < 0.0f), but testing this facilitates eating mechanism (until we finish work on key ownership)
		return false
	}
	t : f32 = g.IO.MouseDownDuration[button]
	if t < 0.0 { return false }
	IM_ASSERT((flags & cast(ImGuiInputFlags)~cast(i32)ImGuiInputFlagsPrivate_.ImGuiInputFlags_SupportedByIsMouseClicked) == {}); // Passing flags not supported by this function! // FIXME: Could support RepeatRate and RepeatUntil flags here.

	repeat : bool = (flags & ImGuiInputFlags_.ImGuiInputFlags_Repeat) != {}
	pressed : bool = (t == 0.0) || (repeat && t > g.IO.KeyRepeatDelay && CalcTypematicRepeatAmount(t - g.IO.DeltaTime, t, g.IO.KeyRepeatDelay, g.IO.KeyRepeatRate) > 0)
	if !pressed { return false }

	if !TestKeyOwner(MouseButtonToKey(button), owner_id) { return false }

	return true
}

// did mouse button released? (went from Down to !Down)
IsMouseReleased_0 :: proc(button : ImGuiMouseButton) -> bool
{
	g : ^ImGuiContext = GImGui
	IM_ASSERT(button >= ImGuiMouseButton(0) && button < cast(ImGuiMouseButton)IM_ARRAYSIZE(g.IO.MouseDown))
	return g.IO.MouseReleased[button] && TestKeyOwner(MouseButtonToKey(button), ImGuiKeyOwner_Any)// Should be same as IsKeyReleased(MouseButtonToKey(button), ImGuiKeyOwner_Any)
}

// did mouse button released? (went from Down to !Down)
IsMouseReleased_1 :: proc(button : ImGuiMouseButton, owner_id : ImGuiID) -> bool
{
	g : ^ImGuiContext = GImGui
	IM_ASSERT(button >= ImGuiMouseButton(0) && button < cast(ImGuiMouseButton)IM_ARRAYSIZE(g.IO.MouseDown))
	return g.IO.MouseReleased[button] && TestKeyOwner(MouseButtonToKey(button), owner_id)// Should be same as IsKeyReleased(MouseButtonToKey(button), owner_id)
}

// did mouse button double-clicked? Same as GetMouseClickedCount() == 2. (note that a double-click will also report IsMouseClicked() == true)
IsMouseDoubleClicked_0 :: proc(button : ImGuiMouseButton) -> bool
{
	g : ^ImGuiContext = GImGui
	IM_ASSERT(button >= ImGuiMouseButton(0) && button < cast(ImGuiMouseButton)IM_ARRAYSIZE(g.IO.MouseDown))
	return g.IO.MouseClickedCount[button] == 2 && TestKeyOwner(MouseButtonToKey(button), ImGuiKeyOwner_Any)
}

// did mouse button double-clicked? Same as GetMouseClickedCount() == 2. (note that a double-click will also report IsMouseClicked() == true)
IsMouseDoubleClicked_1 :: proc(button : ImGuiMouseButton, owner_id : ImGuiID) -> bool
{
	g : ^ImGuiContext = GImGui
	IM_ASSERT(button >= ImGuiMouseButton(0) && button < cast(ImGuiMouseButton)IM_ARRAYSIZE(g.IO.MouseDown))
	return g.IO.MouseClickedCount[button] == 2 && TestKeyOwner(MouseButtonToKey(button), owner_id)
}

// return the number of successive mouse-clicks at the time where a click happen (otherwise 0).
GetMouseClickedCount :: proc(button : ImGuiMouseButton) -> i32
{
	g : ^ImGuiContext = GImGui
	IM_ASSERT(button >= ImGuiMouseButton(0) && button < cast(ImGuiMouseButton)IM_ARRAYSIZE(g.IO.MouseDown))
	return i32(g.IO.MouseClickedCount[button])
}

// is mouse hovering given bounding rect (in screen space). clipped by current clipping settings, but disregarding of other consideration of focus/window ordering/popup-block.
// Test if mouse cursor is hovering given rectangle
// NB- Rectangle is clipped by our current clip setting
// NB- Expand the rectangle to be generous on imprecise inputs systems (g.Style.TouchExtraPadding)
IsMouseHoveringRect :: proc(r_min : ImVec2, r_max : ImVec2, clip : bool = true) -> bool
{
	g : ^ImGuiContext = GImGui

	// Clip
	rect_clipped : ImRect; init(&rect_clipped, r_min, r_max)
	if clip { ClipWith(&rect_clipped, g.CurrentWindow.ClipRect) }

	// Hit testing, expanded for touch input
	if !ContainsWithPad(rect_clipped, g.IO.MousePos, g.Style.TouchExtraPadding) { return false }
	if !Overlaps(GetMainRect(g.MouseViewport), rect_clipped) { return false }
	return true
}

// Return if a mouse click/drag went past the given threshold. Valid to call during the MouseReleased frame.
// [Internal] This doesn't test if the button is pressed
IsMouseDragPastThreshold :: proc(button : ImGuiMouseButton, lock_threshold : f32 = -1) -> bool
{
	g : ^ImGuiContext = GImGui
	lock_threshold := lock_threshold
	IM_ASSERT(button >= ImGuiMouseButton(0) && button < cast(ImGuiMouseButton)IM_ARRAYSIZE(g.IO.MouseDown))
	if lock_threshold < 0.0 { lock_threshold = g.IO.MouseDragThreshold }
	return g.IO.MouseDragMaxDistanceSqr[button] >= lock_threshold * lock_threshold
}

// is mouse dragging? (uses io.MouseDraggingThreshold if lock_threshold < 0.0f)
IsMouseDragging :: proc(button : ImGuiMouseButton, lock_threshold : f32 = -1) -> bool
{
	g : ^ImGuiContext = GImGui
	IM_ASSERT(button >= ImGuiMouseButton(0) && button < cast(ImGuiMouseButton)IM_ARRAYSIZE(g.IO.MouseDown))
	if !g.IO.MouseDown[button] { return false }
	return IsMouseDragPastThreshold(button, lock_threshold)
}

// shortcut to ImGui::GetIO().MousePos provided by user, to be consistent with other calls
GetMousePos :: proc() -> ImVec2
{
	g : ^ImGuiContext = GImGui
	return g.IO.MousePos
}

// This is called TeleportMousePos() and not SetMousePos() to emphasis that setting MousePosPrev will effectively clear mouse delta as well.
// It is expected you only call this if (io.BackendFlags & ImGuiBackendFlags_HasSetMousePos) is set and supported by backend.
TeleportMousePos :: proc(pos : ImVec2)
{
	g : ^ImGuiContext = GImGui
	g.IO.MousePosPrev = pos; g.IO.MousePos = g.IO.MousePosPrev
	g.IO.MouseDelta = ImVec2{0.0, 0.0}
	g.IO.WantSetMousePos = true
	//IMGUI_DEBUG_LOG_IO(g, "TeleportMousePos: (%.1f,%.1f)\n", io.MousePos.x, io.MousePos.y);
}

// retrieve mouse position at the time of opening popup we have BeginPopup() into (helper to avoid user backing that value themselves)
// NB: prefer to call right after BeginPopup(). At the time Selectable/MenuItem is activated, the popup is already closed!
GetMousePosOnOpeningCurrentPopup :: proc() -> ImVec2
{
	g : ^ImGuiContext = GImGui
	if g.BeginPopupStack.Size > 0 { return g.OpenPopupStack.Data[g.BeginPopupStack.Size - 1].OpenMousePos }
	return g.IO.MousePos
}

// by convention we use (-FLT_MAX,-FLT_MAX) to denote that there is no mouse available
// We typically use ImVec2{-FLT_MAX,-FLT_MAX} to denote an invalid mouse position.
IsMousePosValid :: proc(mouse_pos : ^ImVec2 = nil) -> bool
{
	// The assert is only to silence a false-positive in XCode Static Analysis.
	// Because GImGui is not dereferenced in every code path, the static analyzer assume that it may be NULL (which it doesn't for other functions).
	IM_ASSERT(GImGui != nil)
	MOUSE_INVALID : f32 = -256000.0
	p : ImVec2 = mouse_pos != nil ? mouse_pos^ : GImGui.IO.MousePos
	return p.x >= MOUSE_INVALID && p.y >= MOUSE_INVALID
}

// [WILL OBSOLETE] is any mouse button held? This was designed for backends, but prefer having backend maintain a mask of held mouse buttons, because upcoming input queue system will make this invalid.
// [WILL OBSOLETE] This was designed for backends, but prefer having backend maintain a mask of held mouse buttons, because upcoming input queue system will make this invalid.
IsAnyMouseDown :: proc() -> bool
{
	g : ^ImGuiContext = GImGui
	for n : i32 = 0; n < cast(i32)IM_ARRAYSIZE(g.IO.MouseDown); n += 1 { if g.IO.MouseDown[n] { return true } }

	return false
}

// return the delta from the initial clicking position while the mouse button is pressed or was just released. This is locked and return 0.0f until the mouse moves past a distance threshold at least once (uses io.MouseDraggingThreshold if lock_threshold < 0.0f)
// Return the delta from the initial clicking position while the mouse button is clicked or was just released.
// This is locked and return 0.0f until the mouse moves past a distance threshold at least once.
// NB: This is only valid if IsMousePosValid(). backends in theory should always keep mouse position valid when dragging even outside the client window.
GetMouseDragDelta :: proc(button : ImGuiMouseButton, lock_threshold : f32) -> ImVec2
{
	lock_threshold := lock_threshold
	g : ^ImGuiContext = GImGui
	IM_ASSERT(button >= ImGuiMouseButton(0) && int(button) < IM_ARRAYSIZE(g.IO.MouseDown))
	if lock_threshold < 0.0 { lock_threshold = g.IO.MouseDragThreshold }
	if g.IO.MouseDown[button] || g.IO.MouseReleased[button] { if g.IO.MouseDragMaxDistanceSqr[button] >= lock_threshold * lock_threshold { if IsMousePosValid(&g.IO.MousePos) && IsMousePosValid(&g.IO.MouseClickedPos[button]) { return g.IO.MousePos - g.IO.MouseClickedPos[button] } } }
	return ImVec2{0.0, 0.0}
}

//
ResetMouseDragDelta :: proc(button : ImGuiMouseButton)
{
	g : ^ImGuiContext = GImGui
	IM_ASSERT(button >= ImGuiMouseButton(0) && int(button) < IM_ARRAYSIZE(g.IO.MouseDown))
	// NB: We don't need to reset g.IO.MouseDragMaxDistanceSqr
	g.IO.MouseClickedPos[button] = g.IO.MousePos
}

// get desired mouse cursor shape. Important: reset in ImGui::NewFrame(), this is updated during the frame. valid before Render(). If you use software rendering by setting io.MouseDrawCursor ImGui will render those for you
// Get desired mouse cursor shape.
// Important: this is meant to be used by a platform backend, it is reset in ImGui::NewFrame(),
// updated during the frame, and locked in EndFrame()/Render().
// If you use software rendering by setting io.MouseDrawCursor then Dear ImGui will render those for you
GetMouseCursor :: proc() -> ImGuiMouseCursor
{
	g : ^ImGuiContext = GImGui
	return g.MouseCursor
}

// set desired mouse cursor shape
// We intentionally accept values of ImGuiMouseCursor that are outside our bounds, in case users needs to hack-in a custom cursor value.
// Custom cursors may be handled by custom backends. If you are using a standard backend and want to hack in a custom cursor, you may
// handle it before the backend _NewFrame() call and temporarily set ImGuiConfigFlags_NoMouseCursorChange during the backend _NewFrame() call.
SetMouseCursor :: proc(cursor_type : ImGuiMouseCursor)
{
	g : ^ImGuiContext = GImGui
	g.MouseCursor = cursor_type
}

UpdateAliasKey :: proc(key : ImGuiKey, v : bool, analog_value : f32)
{
	IM_ASSERT(IsAliasKey(key))
	key_data : ^ImGuiKeyData = GetKeyData(key)
	key_data.Down = v
	key_data.AnalogValue = analog_value
}

// [Internal] Do not use directly
GetMergedModsFromKeys :: proc() -> ImGuiKeyChord
{
	mods : ImGuiKeyChord
	if IsKeyDown(ImGuiKey.ImGuiMod_Ctrl) { mods |= ImGuiKey.ImGuiMod_Ctrl }
	if IsKeyDown(ImGuiKey.ImGuiMod_Shift) { mods |= ImGuiKey.ImGuiMod_Shift }
	if IsKeyDown(ImGuiKey.ImGuiMod_Alt) { mods |= ImGuiKey.ImGuiMod_Alt }
	if IsKeyDown(ImGuiKey.ImGuiMod_Super) { mods |= ImGuiKey.ImGuiMod_Super }
	return mods
}

// Inputs
UpdateKeyboardInputs :: proc()
{
	g : ^ImGuiContext = GImGui
	io : ^ImGuiIO = &g.IO

	if (io.ConfigFlags & ImGuiConfigFlags_.ImGuiConfigFlags_NoKeyboard) != {} { ClearInputKeys(io) }

	// Update aliases
	for n := ImGuiMouseButton(0); n < ImGuiMouseButton_.ImGuiMouseButton_COUNT; n += ImGuiMouseButton(1) { UpdateAliasKey(MouseButtonToKey(n), io.MouseDown[n], io.MouseDown[n] ? 1.0 : 0.0) }

	UpdateAliasKey(ImGuiKey.ImGuiKey_MouseWheelX, io.MouseWheelH != 0.0, io.MouseWheelH)
	UpdateAliasKey(ImGuiKey.ImGuiKey_MouseWheelY, io.MouseWheel != 0.0, io.MouseWheel)

	// Synchronize io.KeyMods and io.KeyCtrl/io.KeyShift/etc. values.
	// - New backends (1.87+): send io.AddKeyEvent(ImGuiMod_XXX) ->                                      -> (here) deriving io.KeyMods + io.KeyXXX from key array.
	// - Legacy backends:      set io.KeyXXX bools               -> (above) set key array from io.KeyXXX -> (here) deriving io.KeyMods + io.KeyXXX from key array.
	// So with legacy backends the 4 values will do a unnecessary back-and-forth but it makes the code simpler and future facing.
	prev_key_mods : ImGuiKeyChord = io.KeyMods
	io.KeyMods = GetMergedModsFromKeys()
	io.KeyCtrl = (io.KeyMods & ImGuiKey.ImGuiMod_Ctrl) != {}
	io.KeyShift = (io.KeyMods & ImGuiKey.ImGuiMod_Shift) != {}
	io.KeyAlt = (io.KeyMods & ImGuiKey.ImGuiMod_Alt) != {}
	io.KeySuper = (io.KeyMods & ImGuiKey.ImGuiMod_Super) != {}
	if prev_key_mods != io.KeyMods { g.LastKeyModsChangeTime = g.Time }
	if prev_key_mods != io.KeyMods && prev_key_mods == {} { g.LastKeyModsChangeFromNoneTime = g.Time }

	// Clear gamepad data if disabled
	if (io.BackendFlags & ImGuiBackendFlags_.ImGuiBackendFlags_HasGamepad) == {} { for key := ImGuiKey_Gamepad_BEGIN; key < ImGuiKey_Gamepad_END; key += ImGuiKey(1) {
	io.KeysData[key - ImGuiKey.ImGuiKey_NamedKey_BEGIN].Down = false
	io.KeysData[key - ImGuiKey.ImGuiKey_NamedKey_BEGIN].AnalogValue = 0.0
} }

	// Update keys
	for key := ImGuiKey.ImGuiKey_NamedKey_BEGIN; key < ImGuiKey.ImGuiKey_NamedKey_END; key += ImGuiKey(1) {
		key_data : ^ImGuiKeyData = &io.KeysData[key - ImGuiKey.ImGuiKey_NamedKey_BEGIN]
		key_data.DownDurationPrev = key_data.DownDuration
		key_data.DownDuration = key_data.Down ? (key_data.DownDuration < 0.0 ? 0.0 : key_data.DownDuration + io.DeltaTime) : -1.0
		if key_data.DownDuration == 0.0 {
			if IsKeyboardKey(cast(ImGuiKey) key) { g.LastKeyboardKeyPressTime = g.Time }
			else if key == ImGuiKey.ImGuiKey_ReservedForModCtrl || key == ImGuiKey.ImGuiKey_ReservedForModShift || key == ImGuiKey.ImGuiKey_ReservedForModAlt || key == ImGuiKey.ImGuiKey_ReservedForModSuper { g.LastKeyboardKeyPressTime = g.Time }
		}
	}

	// Update keys/input owner (named keys only): one entry per key
	for key : ImGuiKey = ImGuiKey.ImGuiKey_NamedKey_BEGIN; key < ImGuiKey.ImGuiKey_NamedKey_END; key += ImGuiKey(1) {
		key_data : ^ImGuiKeyData = &io.KeysData[key - ImGuiKey.ImGuiKey_NamedKey_BEGIN]
		owner_data : ^ImGuiKeyOwnerData = &g.KeysOwnerData[key - ImGuiKey.ImGuiKey_NamedKey_BEGIN]
		owner_data.OwnerCurr = owner_data.OwnerNext
		if !key_data.Down {
			// Important: ownership is released on the frame after a release. Ensure a 'MouseDown -> CloseWindow -> MouseUp' chain doesn't lead to someone else seeing the MouseUp.
			owner_data.OwnerNext = ImGuiKeyOwner_NoOwner
		}
		owner_data.LockUntilRelease = owner_data.LockUntilRelease && key_data.Down; owner_data.LockThisFrame = owner_data.LockUntilRelease; // Clear LockUntilRelease when key is not Down anymore
	}

	// Update key routing (for e.g. shortcuts)
	UpdateKeyRoutingTable(&g.KeysRoutingTable)
}

UpdateMouseInputs :: proc()
{
	g : ^ImGuiContext = GImGui
	io : ^ImGuiIO = &g.IO

	// Mouse Wheel swapping flag
	// As a standard behavior holding SHIFT while using Vertical Mouse Wheel triggers Horizontal scroll instead
	// - We avoid doing it on OSX as it the OS input layer handles this already.
	// - FIXME: However this means when running on OSX over Emscripten, Shift+WheelY will incur two swapping (1 in OS, 1 here), canceling the feature.
	// - FIXME: When we can distinguish e.g. touchpad scroll events from mouse ones, we'll set this accordingly based on input source.
	io.MouseWheelRequestAxisSwap = io.KeyShift && !io.ConfigMacOSXBehaviors

	// Round mouse position to avoid spreading non-rounded position (e.g. UpdateManualResize doesn't support them well)
	if IsMousePosValid(&io.MousePos) { g.MouseLastValidPos = ImFloor(io.MousePos); io.MousePos = g.MouseLastValidPos }

	// If mouse just appeared or disappeared (usually denoted by -FLT_MAX components) we cancel out movement in MouseDelta
	if IsMousePosValid(&io.MousePos) && IsMousePosValid(&io.MousePosPrev) { io.MouseDelta = io.MousePos - io.MousePosPrev }
	else { io.MouseDelta = ImVec2{0.0, 0.0} }

	// Update stationary timer.
	// FIXME: May need to rework again to have some tolerance for occasional small movement, while being functional on high-framerates.
	mouse_stationary_threshold : f32 = (io.MouseSource == ImGuiMouseSource.ImGuiMouseSource_Mouse) ? 2.0 : 3.0; // Slightly higher threshold for ImGuiMouseSource_TouchScreen/ImGuiMouseSource_Pen, may need rework.
	mouse_stationary : bool = (ImLengthSqr(io.MouseDelta) <= mouse_stationary_threshold * mouse_stationary_threshold)
	g.MouseStationaryTimer = mouse_stationary ? (g.MouseStationaryTimer + io.DeltaTime) : 0.0
	//IMGUI_DEBUG_LOG("%.4f\n", g.MouseStationaryTimer);

	// If mouse moved we re-enable mouse hovering in case it was disabled by keyboard/gamepad. In theory should use a >0.0f threshold but would need to reset in everywhere we set this to true.
	if io.MouseDelta.x != 0.0 || io.MouseDelta.y != 0.0 { g.NavHighlightItemUnderNav = false }

	for i : i32 = 0; i < cast(i32)IM_ARRAYSIZE(io.MouseDown); i += 1 {
		io.MouseClicked[i] = io.MouseDown[i] && io.MouseDownDuration[i] < 0.0
		io.MouseClickedCount[i] = 0; // Will be filled below
		io.MouseReleased[i] = !io.MouseDown[i] && io.MouseDownDuration[i] >= 0.0
		io.MouseDownDurationPrev[i] = io.MouseDownDuration[i]
		io.MouseDownDuration[i] = io.MouseDown[i] ? (io.MouseDownDuration[i] < 0.0 ? 0.0 : io.MouseDownDuration[i] + io.DeltaTime) : -1.0
		if io.MouseClicked[i] {
			is_repeated_click : bool = false
			if cast(f32) (g.Time - io.MouseClickedTime[i]) < io.MouseDoubleClickTime {
				delta_from_click_pos : ImVec2 = IsMousePosValid(&io.MousePos) ? (io.MousePos - io.MouseClickedPos[i]) : ImVec2{0.0, 0.0}
				if ImLengthSqr(delta_from_click_pos) < io.MouseDoubleClickMaxDist * io.MouseDoubleClickMaxDist { is_repeated_click = true }
			}
			if is_repeated_click { post_incr(&io.MouseClickedLastCount[i]) }
			else { io.MouseClickedLastCount[i] = 1 }
			io.MouseClickedTime[i] = g.Time
			io.MouseClickedPos[i] = io.MousePos
			io.MouseClickedCount[i] = io.MouseClickedLastCount[i]
			io.MouseDragMaxDistanceAbs[i] = ImVec2{0.0, 0.0}
			io.MouseDragMaxDistanceSqr[i] = 0.0
		}
		else if io.MouseDown[i] {
			// Maintain the maximum distance we reaching from the initial click position, which is used with dragging threshold
			delta_from_click_pos : ImVec2 = IsMousePosValid(&io.MousePos) ? (io.MousePos - io.MouseClickedPos[i]) : ImVec2{0.0, 0.0}
			io.MouseDragMaxDistanceSqr[i] = ImMax(io.MouseDragMaxDistanceSqr[i], ImLengthSqr(delta_from_click_pos))
			io.MouseDragMaxDistanceAbs[i].x = ImMax(io.MouseDragMaxDistanceAbs[i].x, delta_from_click_pos.x < 0.0 ? -delta_from_click_pos.x : delta_from_click_pos.x)
			io.MouseDragMaxDistanceAbs[i].y = ImMax(io.MouseDragMaxDistanceAbs[i].y, delta_from_click_pos.y < 0.0 ? -delta_from_click_pos.y : delta_from_click_pos.y)
		}

		// We provide io.MouseDoubleClicked[] as a legacy service
		io.MouseDoubleClicked[i] = (io.MouseClickedCount[i] == 2)

		// Clicking any mouse button reactivate mouse hovering which may have been deactivated by keyboard/gamepad navigation
		if io.MouseClicked[i] { g.NavHighlightItemUnderNav = false }
	}
}

LockWheelingWindow :: proc(window : ^ImGuiWindow, wheel_amount : f32)
{
	g : ^ImGuiContext = GImGui
	if window != nil { g.WheelingWindowReleaseTimer = ImMin(g.WheelingWindowReleaseTimer + ImAbs(wheel_amount) * WINDOWS_MOUSE_WHEEL_SCROLL_LOCK_TIMER, WINDOWS_MOUSE_WHEEL_SCROLL_LOCK_TIMER) }
	else { g.WheelingWindowReleaseTimer = 0.0 }
	if g.WheelingWindow == window { return }
	IMGUI_DEBUG_LOG_IO(g, "[io] LockWheelingWindow() \"%s\"\n", window != nil ? window.Name : "NULL")
	g.WheelingWindow = window
	g.WheelingWindowRefMousePos = g.IO.MousePos
	if window == nil {
		g.WheelingWindowStartFrame = -1
		g.WheelingAxisAvg = ImVec2{0.0, 0.0}
	}
}

FindBestWheelingWindow :: proc(wheel : ImVec2) -> ^ImGuiWindow
{
	// For each axis, find window in the hierarchy that may want to use scrolling
	g : ^ImGuiContext = GImGui
	windows : [2]^ImGuiWindow = {nil, nil}
	for axis : i32 = 0; axis < 2; axis += 1 {
		if wheel[axis] != 0.0 {
			windows[axis] = g.HoveredWindow
			for window : ^ImGuiWindow = g.HoveredWindow; (window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_ChildWindow) != {}; windows[axis], window = window.ParentWindow, windows[axis] {
				// Bubble up into parent window if:
				// - a child window doesn't allow any scrolling.
				// - a child window has the ImGuiWindowFlags_NoScrollWithMouse flag.
				//// - a child window doesn't need scrolling because it is already at the edge for the direction we are going in (FIXME-WIP)
				has_scrolling : bool = (window.ScrollMax[axis] != 0.0)
				inputs_disabled : bool = (window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoScrollWithMouse) != {} && (window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoMouseInputs) == {}
				//const bool scrolling_past_limits = (wheel_v < 0.0f) ? (window->Scroll[axis] <= 0.0f) : (window->Scroll[axis] >= window->ScrollMax[axis]);
				if has_scrolling && !inputs_disabled {
					// && !scrolling_past_limits)
					// select this window
					break
				}
			}
		}
	}

	if windows[0] == nil && windows[1] == nil { return nil }

	// If there's only one window or only one axis then there's no ambiguity
	if windows[0] == windows[1] || windows[0] == nil || windows[1] == nil { return windows[1] != nil ? windows[1] : windows[0] }

	// If candidate are different windows we need to decide which one to prioritize
	// - First frame: only find a winner if one axis is zero.
	// - Subsequent frames: only find a winner when one is more than the other.
	if g.WheelingWindowStartFrame == -1 { g.WheelingWindowStartFrame = g.FrameCount }
	if (g.WheelingWindowStartFrame == g.FrameCount && wheel.x != 0.0 && wheel.y != 0.0) || (g.WheelingAxisAvg.x == g.WheelingAxisAvg.y) {
		g.WheelingWindowWheelRemainder = wheel
		return nil
	}
	return (g.WheelingAxisAvg.x > g.WheelingAxisAvg.y) ? windows[0] : windows[1]
}

// Called by NewFrame()
UpdateMouseWheel :: proc()
{
	// Reset the locked window if we move the mouse or after the timer elapses.
	// FIXME: Ideally we could refactor to have one timer for "changing window w/ same axis" and a shorter timer for "changing window or axis w/ other axis" (#3795)
	g : ^ImGuiContext = GImGui
	if g.WheelingWindow != nil {
		g.WheelingWindowReleaseTimer -= g.IO.DeltaTime
		if IsMousePosValid() && ImLengthSqr(g.IO.MousePos - g.WheelingWindowRefMousePos) > g.IO.MouseDragThreshold * g.IO.MouseDragThreshold { g.WheelingWindowReleaseTimer = 0.0 }
		if g.WheelingWindowReleaseTimer <= 0.0 { LockWheelingWindow(nil, 0.0) }
	}

	wheel : ImVec2
	wheel.x = TestKeyOwner(ImGuiKey.ImGuiKey_MouseWheelX, ImGuiKeyOwner_NoOwner) ? g.IO.MouseWheelH : 0.0
	wheel.y = TestKeyOwner(ImGuiKey.ImGuiKey_MouseWheelY, ImGuiKeyOwner_NoOwner) ? g.IO.MouseWheel : 0.0

	//IMGUI_DEBUG_LOG("MouseWheel X:%.3f Y:%.3f\n", wheel_x, wheel_y);
	mouse_window : ^ImGuiWindow = g.WheelingWindow != nil ? g.WheelingWindow : g.HoveredWindow
	if mouse_window == nil || mouse_window.Collapsed { return }

	// Zoom / Scale window
	// FIXME-OBSOLETE: This is an old feature, it still works but pretty much nobody is using it and may be best redesigned.
	if wheel.y != 0.0 && g.IO.KeyCtrl && g.IO.FontAllowUserScaling {
		LockWheelingWindow(mouse_window, wheel.y)
		window : ^ImGuiWindow = mouse_window
		new_font_scale : f32 = ImClamp(window.FontWindowScale + g.IO.MouseWheel * 0.10, 0.50, 2.50)
		scale : f32 = new_font_scale / window.FontWindowScale
		window.FontWindowScale = new_font_scale
		if window == window.RootWindow {
			offset : ImVec2 = window.Size * (1.0 - scale) * (g.IO.MousePos - window.Pos) / window.Size
			SetWindowPos(window, window.Pos + offset, ImGuiCond{})
			window.Size = ImTrunc(window.Size * scale)
			window.SizeFull = ImTrunc(window.SizeFull * scale)
		}
		return
	}
	if g.IO.KeyCtrl { return }

	// Mouse wheel scrolling
	// Read about io.MouseWheelRequestAxisSwap and its issue on Mac+Emscripten in UpdateMouseInputs()
	if g.IO.MouseWheelRequestAxisSwap { wheel = ImVec2{wheel.y, 0.0} }

	// Maintain a rough average of moving magnitude on both axises
	// FIXME: should by based on wall clock time rather than frame-counter
	g.WheelingAxisAvg.x = ImExponentialMovingAverage(g.WheelingAxisAvg.x, ImAbs(wheel.x), 30)
	g.WheelingAxisAvg.y = ImExponentialMovingAverage(g.WheelingAxisAvg.y, ImAbs(wheel.y), 30)

	// In the rare situation where FindBestWheelingWindow() had to defer first frame of wheeling due to ambiguous main axis, reinject it now.
	wheel += g.WheelingWindowWheelRemainder
	g.WheelingWindowWheelRemainder = ImVec2{0.0, 0.0}
	if wheel.x == 0.0 && wheel.y == 0.0 { return }

	// Mouse wheel scrolling: find target and apply
	// - don't renew lock if axis doesn't apply on the window.
	// - select a main axis when both axises are being moved.
	if window : ^ImGuiWindow = (g.WheelingWindow != nil ? g.WheelingWindow : FindBestWheelingWindow(wheel)); window != nil { if (window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoScrollWithMouse) == {} && (window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoMouseInputs) == {} {
	do_scroll : [2]bool = {wheel.x != 0.0 && window.ScrollMax.x != 0.0, wheel.y != 0.0 && window.ScrollMax.y != 0.0}
	if do_scroll[ImGuiAxis.ImGuiAxis_X] && do_scroll[ImGuiAxis.ImGuiAxis_Y] { do_scroll[(g.WheelingAxisAvg.x > g.WheelingAxisAvg.y) ? ImGuiAxis.ImGuiAxis_Y : ImGuiAxis.ImGuiAxis_X] = false }
	if do_scroll[ImGuiAxis.ImGuiAxis_X] {
		LockWheelingWindow(window, wheel.x)
		max_step : f32 = GetWidth(window.InnerRect) * 0.67
		scroll_step : f32 = ImTrunc(ImMin(2 * CalcFontSize(window), max_step))
		SetScrollX(window, window.Scroll.x - wheel.x * scroll_step)
		g.WheelingWindowScrolledFrame = g.FrameCount
	}
	if do_scroll[ImGuiAxis.ImGuiAxis_Y] {
		LockWheelingWindow(window, wheel.y)
		max_step : f32 = GetHeight(window.InnerRect) * 0.67
		scroll_step : f32 = ImTrunc(ImMin(5 * CalcFontSize(window), max_step))
		SetScrollY(window, window.Scroll.y - wheel.y * scroll_step)
		g.WheelingWindowScrolledFrame = g.FrameCount
	}
} }
}

// Override io.WantCaptureKeyboard flag next frame (said flag is left for your application to handle, typically when true it instructs your app to ignore inputs). e.g. force capture keyboard when your widget is being hovered. This is equivalent to setting "io.WantCaptureKeyboard = want_capture_keyboard"; after the next NewFrame() call.
SetNextFrameWantCaptureKeyboard :: proc(want_capture_keyboard : bool)
{
	g : ^ImGuiContext = GImGui
	g.WantCaptureKeyboardNextFrame = want_capture_keyboard ? 1 : 0
}

// Override io.WantCaptureMouse flag next frame (said flag is left for your application to handle, typical when true it instucts your app to ignore inputs). This is equivalent to setting "io.WantCaptureMouse = want_capture_mouse;" after the next NewFrame() call.
SetNextFrameWantCaptureMouse :: proc(want_capture_mouse : bool)
{
	g : ^ImGuiContext = GImGui
	g.WantCaptureMouseNextFrame = want_capture_mouse ? 1 : 0
}

when ! IMGUI_DISABLE_DEBUG_TOOLS { /* @gen ifndef */
GetInputSourceName :: proc(source : ImGuiInputSource) -> string
{
	input_source_names := [?]string{"None", "Mouse", "Keyboard", "Gamepad"}
	IM_ASSERT(len(input_source_names) == cast(int)ImGuiInputSource.ImGuiInputSource_COUNT && source >= ImGuiInputSource(0) && source < ImGuiInputSource.ImGuiInputSource_COUNT)
	return input_source_names[source]
}
GetMouseSourceName :: proc(source : ImGuiMouseSource) -> string
{
	mouse_source_names := [?]string{"Mouse", "TouchScreen", "Pen"}
	IM_ASSERT(len(mouse_source_names) == cast(int)ImGuiMouseSource.ImGuiMouseSource_COUNT && source >= ImGuiMouseSource(0) && source < ImGuiMouseSource.ImGuiMouseSource_COUNT)
	return mouse_source_names[source]
}
DebugPrintInputEvent :: proc(prefix : string, e : ^ImGuiInputEvent)
{
	g : ^ImGuiContext = GImGui
	if e.Type == ImGuiInputEventType.ImGuiInputEventType_MousePos {if e.MousePos.PosX == -FLT_MAX && e.MousePos.PosY == -FLT_MAX { IMGUI_DEBUG_LOG_IO(g, "[io] %s: MousePos (-FLT_MAX, -FLT_MAX)\n", prefix) }
		else { IMGUI_DEBUG_LOG_IO(g, "[io] %s: MousePos (%.1f, %.1f) (%s)\n", prefix, e.MousePos.PosX, e.MousePos.PosY, GetMouseSourceName(e.MousePos.MouseSource)) }; return
	}
	if e.Type == ImGuiInputEventType.ImGuiInputEventType_MouseButton {IMGUI_DEBUG_LOG_IO(g, "[io] %s: MouseButton %d %s (%s)\n", prefix, e.MouseButton.Button, e.MouseButton.Down ? "Down" : "Up", GetMouseSourceName(e.MouseButton.MouseSource)); return
	}
	if e.Type == ImGuiInputEventType.ImGuiInputEventType_MouseWheel {IMGUI_DEBUG_LOG_IO(g, "[io] %s: MouseWheel (%.3f, %.3f) (%s)\n", prefix, e.MouseWheel.WheelX, e.MouseWheel.WheelY, GetMouseSourceName(e.MouseWheel.MouseSource)); return
	}
	if e.Type == ImGuiInputEventType.ImGuiInputEventType_MouseViewport {IMGUI_DEBUG_LOG_IO(g, "[io] %s: MouseViewport (0x%08X)\n", prefix, e.MouseViewport.HoveredViewportID); return
	}
	if e.Type == ImGuiInputEventType.ImGuiInputEventType_Key {IMGUI_DEBUG_LOG_IO(g, "[io] %s: Key \"%s\" %s\n", prefix, GetKeyName(e.Key.Key), e.Key.Down ? "Down" : "Up"); return
	}
	if e.Type == ImGuiInputEventType.ImGuiInputEventType_Text {IMGUI_DEBUG_LOG_IO(g, "[io] %s: Text: %c (U+%08X)\n", prefix, e.Text.Char, e.Text.Char); return
	}
	if e.Type == ImGuiInputEventType.ImGuiInputEventType_Focus {IMGUI_DEBUG_LOG_IO(g, "[io] %s: AppFocused %d\n", prefix, e.AppFocused.Focused); return
	}
}
} // preproc endif

// NewFrame
// Process input queue
// We always call this with the value of 'bool g.IO.ConfigInputTrickleEventQueue'.
// - trickle_fast_inputs = false : process all events, turn into flattened input state (e.g. successive down/up/down/up will be lost)
// - trickle_fast_inputs = true  : process as many events as possible (successive down/up/down/up will be trickled over several frames so nothing is lost) (new feature in 1.87)
UpdateInputEvents :: proc(trickle_fast_inputs : bool)
{
	g : ^ImGuiContext = GImGui
	io : ^ImGuiIO = &g.IO

	// Only trickle chars<>key when working with InputText()
	// FIXME: InputText() could parse event trail?
	// FIXME: Could specialize chars<>keys trickling rules for control keys (those not typically associated to characters)
	trickle_interleaved_nonchar_keys_and_text : bool = (trickle_fast_inputs && g.WantTextInputNextFrame == 1)

	mouse_moved : bool = false; mouse_wheeled : bool = false; key_changed : bool = false; key_changed_nonchar : bool = false; text_inputted : bool = false
	mouse_button_changed : i32 = 0x00
	key_changed_mask : ImBitArray(u32(ImGuiKey.ImGuiKey_NamedKey_COUNT))

	event_n : i32 = 0
	for ; event_n < g.InputEventsQueue.Size; event_n += 1 {
		e : ^ImGuiInputEvent = &g.InputEventsQueue.Data[event_n]
		if e.Type == ImGuiInputEventType.ImGuiInputEventType_MousePos {
			if g.IO.WantSetMousePos { continue }
			// Trickling Rule: Stop processing queued events if we already handled a mouse button change
			event_pos := ImVec2{ e.MousePos.PosX, e.MousePos.PosY }
			if trickle_fast_inputs && (mouse_button_changed != 0 || mouse_wheeled || key_changed || text_inputted) { break }
			io.MousePos = event_pos
			io.MouseSource = e.MousePos.MouseSource
			mouse_moved = true
		}
		else if e.Type == ImGuiInputEventType.ImGuiInputEventType_MouseButton {
			// Trickling Rule: Stop processing queued events if we got multiple action on the same button
			button : ImGuiMouseButton = e.MouseButton.Button
			IM_ASSERT(button >= ImGuiMouseButton(0) && button < ImGuiMouseButton_.ImGuiMouseButton_COUNT)
			if trickle_fast_inputs && ((mouse_button_changed & (1 << u32(button))) != {} || mouse_wheeled) { break }
			if trickle_fast_inputs && e.MouseButton.MouseSource == ImGuiMouseSource.ImGuiMouseSource_TouchScreen && mouse_moved {
				// #2702: TouchScreen have no initial hover.
				break
			}
			io.MouseDown[button] = e.MouseButton.Down
			io.MouseSource = e.MouseButton.MouseSource
			mouse_button_changed |= (1 << u32(button))
		}
		else if e.Type == ImGuiInputEventType.ImGuiInputEventType_MouseWheel {
			// Trickling Rule: Stop processing queued events if we got multiple action on the event
			if trickle_fast_inputs && (mouse_moved || mouse_button_changed != 0) { break }
			io.MouseWheelH += e.MouseWheel.WheelX
			io.MouseWheel += e.MouseWheel.WheelY
			io.MouseSource = e.MouseWheel.MouseSource
			mouse_wheeled = true
		}
		else if e.Type == ImGuiInputEventType.ImGuiInputEventType_MouseViewport {
			io.MouseHoveredViewport = e.MouseViewport.HoveredViewportID
		}
		else if e.Type == ImGuiInputEventType.ImGuiInputEventType_Key {
			// Trickling Rule: Stop processing queued events if we got multiple action on the same button
			if (io.ConfigFlags & ImGuiConfigFlags_.ImGuiConfigFlags_NoKeyboard) != {} { continue }
			key : ImGuiKey = e.Key.Key
			IM_ASSERT(key != ImGuiKey.ImGuiKey_None)
			key_data : ^ImGuiKeyData = GetKeyData(key)
			key_data_index := cast(u32) mem.ptr_sub(key_data, cast(^ImGuiKeyData)raw_data(&g.IO.KeysData))
			if trickle_fast_inputs && key_data.Down != e.Key.Down && (TestBit(&key_changed_mask, key_data_index) || mouse_button_changed != 0) { break }

			key_is_potentially_for_char_input : bool = IsKeyChordPotentiallyCharInput(GetMergedModsFromKeys() | key)
			if trickle_interleaved_nonchar_keys_and_text && (text_inputted && !key_is_potentially_for_char_input) { break }

			key_data.Down = e.Key.Down
			key_data.AnalogValue = e.Key.AnalogValue
			key_changed = true
			SetBit(&key_changed_mask, key_data_index)
			if trickle_interleaved_nonchar_keys_and_text && !key_is_potentially_for_char_input { key_changed_nonchar = true }
		}
		else if e.Type == ImGuiInputEventType.ImGuiInputEventType_Text {
			if (io.ConfigFlags & ImGuiConfigFlags_.ImGuiConfigFlags_NoKeyboard) != {} { continue }
			// Trickling Rule: Stop processing queued events if keys/mouse have been interacted with
			if trickle_fast_inputs && (mouse_button_changed != 0 || mouse_moved || mouse_wheeled) { break }
			if trickle_interleaved_nonchar_keys_and_text && key_changed_nonchar { break }
			c : u32 = e.Text.Char
			push_back(&io.InputQueueCharacters, c <= IM_UNICODE_CODEPOINT_MAX ? cast(ImWchar) c : IM_UNICODE_CODEPOINT_INVALID)
			if trickle_interleaved_nonchar_keys_and_text { text_inputted = true }
		}
		else if e.Type == ImGuiInputEventType.ImGuiInputEventType_Focus {
			// We intentionally overwrite this and process in NewFrame(), in order to give a chance
			// to multi-viewports backends to queue AddFocusEvent(false) + AddFocusEvent(true) in same frame.
			focus_lost : bool = !e.AppFocused.Focused
			io.AppFocusLost = focus_lost
		}
		else {
			IM_ASSERT(false, "Unknown event!")
		}
	}

	// Record trail (for domain-specific applications wanting to access a precise trail)
	//if (event_n != 0) IMGUI_DEBUG_LOG_IO(g, "Processed: %d / Remaining: %d\n", event_n, g.InputEventsQueue.Size - event_n);
	for n : i32 = 0; n < event_n; n += 1 { push_back(&g.InputEventsTrail, g.InputEventsQueue.Data[n]) }

	// [DEBUG]
	when ! IMGUI_DISABLE_DEBUG_TOOLS { /* @gen ifndef */
	if event_n != 0 && (g.DebugLogFlags & ImGuiDebugLogFlags_.ImGuiDebugLogFlags_EventIO) != {} {
		for n : i32 = 0; n < g.InputEventsQueue.Size; n += 1 { DebugPrintInputEvent(n < event_n ? "Processed" : "Remaining", &g.InputEventsQueue.Data[n]) }
	}
	} // preproc endif

	// Remaining events will be processed on the next frame
	if event_n == g.InputEventsQueue.Size { resize(&g.InputEventsQueue, 0) }
	else { erase(&g.InputEventsQueue, g.InputEventsQueue.Data, &g.InputEventsQueue.Data[event_n]) }

	// Clear buttons state when focus is lost
	// - this is useful so e.g. releasing Alt after focus loss on Alt-Tab doesn't trigger the Alt menu toggle.
	// - we clear in EndFrame() and not now in order allow application/user code polling this flag
	//   (e.g. custom backend may want to clear additional data, custom widgets may want to react with a "canceling" event).
	if g.IO.AppFocusLost {
		ClearInputKeys(&g.IO)
		ClearInputMouse(&g.IO)
	}
}

// [EXPERIMENTAL] Low-Level: Key/Input Ownership
// - The idea is that instead of "eating" a given input, we can link to an owner id.
// - Ownership is most often claimed as a result of reacting to a press/down event (but occasionally may be claimed ahead).
// - Input queries can then read input by specifying ImGuiKeyOwner_Any (== 0), ImGuiKeyOwner_NoOwner (== -1) or a custom ID.
// - Legacy input queries (without specifying an owner or _Any or _None) are equivalent to using ImGuiKeyOwner_Any (== 0).
// - Input ownership is automatically released on the frame after a key is released. Therefore:
//   - for ownership registration happening as a result of a down/press event, the SetKeyOwner() call may be done once (common case).
//   - for ownership registration happening ahead of a down/press event, the SetKeyOwner() call needs to be made every frame (happens if e.g. claiming ownership on hover).
// - SetItemKeyOwner() is a shortcut for common simple case. A custom widget will probably want to call SetKeyOwner() multiple times directly based on its interaction state.
// - This is marked experimental because not all widgets are fully honoring the Set/Test idioms. We will need to move forward step by step.
//   Please open a GitHub Issue to submit your usage scenario or if there's a use case you need solved.
GetKeyOwner :: proc(key : ImGuiKey) -> ImGuiID
{
	if !IsNamedKeyOrMod(key) { return ImGuiKeyOwner_NoOwner }

	g : ^ImGuiContext = GImGui
	owner_data : ^ImGuiKeyOwnerData = GetKeyOwnerData(g, key)
	owner_id : ImGuiID = owner_data.OwnerCurr

	if g.ActiveIdUsingAllKeyboardKeys && owner_id != g.ActiveId && owner_id != ImGuiKeyOwner_Any { if key >= ImGuiKey_Keyboard_BEGIN && key < ImGuiKey_Keyboard_END { return ImGuiKeyOwner_NoOwner } }

	return owner_id
}

// Test that key is either not owned, either owned by 'owner_id'
// TestKeyOwner(..., ID)   : (owner == None || owner == ID)
// TestKeyOwner(..., None) : (owner == None)
// TestKeyOwner(..., Any)  : no owner test
// All paths are also testing for key not being locked, for the rare cases that key have been locked with using ImGuiInputFlags_LockXXX flags.
TestKeyOwner :: proc(key : ImGuiKey, owner_id : ImGuiID) -> bool
{
	if !IsNamedKeyOrMod(key) { return true }

	g : ^ImGuiContext = GImGui
	if g.ActiveIdUsingAllKeyboardKeys && owner_id != g.ActiveId && owner_id != ImGuiKeyOwner_Any { if key >= ImGuiKey_Keyboard_BEGIN && key < ImGuiKey_Keyboard_END { return false } }

	owner_data : ^ImGuiKeyOwnerData = GetKeyOwnerData(g, key)
	if owner_id == ImGuiKeyOwner_Any { return (owner_data.LockThisFrame == false) }

	// Note: SetKeyOwner() sets OwnerCurr. It is not strictly required for most mouse routing overlap (because of ActiveId/HoveredId
	// are acting as filter before this has a chance to filter), but sane as soon as user tries to look into things.
	// Setting OwnerCurr in SetKeyOwner() is more consistent than testing OwnerNext here: would be inconsistent with getter and other functions.
	if owner_data.OwnerCurr != owner_id {
		if owner_data.LockThisFrame { return false }
		if owner_data.OwnerCurr != ImGuiKeyOwner_NoOwner { return false }
	}

	return true
}

// _LockXXX flags are useful to lock keys away from code which is not input-owner aware.
// When using _LockXXX flags, you can use ImGuiKeyOwner_Any to lock keys from everyone.
// - SetKeyOwner(..., None)              : clears owner
// - SetKeyOwner(..., Any, !Lock)        : illegal (assert)
// - SetKeyOwner(..., Any or None, Lock) : set lock
SetKeyOwner :: proc(key : ImGuiKey, owner_id : ImGuiID, flags : ImGuiInputFlags = {})
{
	g : ^ImGuiContext = GImGui
	IM_ASSERT(IsNamedKeyOrMod(key) && (owner_id != ImGuiKeyOwner_Any || (flags & ImGuiInputFlags(ImGuiInputFlagsPrivate_.ImGuiInputFlags_LockThisFrame | ImGuiInputFlagsPrivate_.ImGuiInputFlags_LockUntilRelease)) != {})); // Can only use _Any with _LockXXX flags (to eat a key away without an ID to retrieve it)
	IM_ASSERT((flags & cast(ImGuiInputFlags)~cast(i32)ImGuiInputFlagsPrivate_.ImGuiInputFlags_SupportedBySetKeyOwner) == {}); // Passing flags not supported by this function!
	//IMGUI_DEBUG_LOG("SetKeyOwner(%s, owner_id=0x%08X, flags=%08X)\n", GetKeyName(key), owner_id, flags);

	owner_data : ^ImGuiKeyOwnerData = GetKeyOwnerData(g, key)
	owner_data.OwnerNext = owner_id; owner_data.OwnerCurr = owner_data.OwnerNext

	// We cannot lock by default as it would likely break lots of legacy code.
	// In the case of using LockUntilRelease while key is not down we still lock during the frame (no key_data->Down test)
	owner_data.LockUntilRelease = (flags & cast(ImGuiInputFlags) ImGuiInputFlagsPrivate_.ImGuiInputFlags_LockUntilRelease) != {}
	owner_data.LockThisFrame = (flags & cast(ImGuiInputFlags) ImGuiInputFlagsPrivate_.ImGuiInputFlags_LockThisFrame) != {} || (owner_data.LockUntilRelease)
}

// Rarely used helper
SetKeyOwnersForKeyChord :: proc(key_chord : ImGuiKeyChord, owner_id : ImGuiID, flags : ImGuiInputFlags = {})
{
	if (key_chord & ImGuiKey.ImGuiMod_Ctrl) != {} { SetKeyOwner(ImGuiKey.ImGuiMod_Ctrl, owner_id, flags) }
	if (key_chord & ImGuiKey.ImGuiMod_Shift) != {} { SetKeyOwner(ImGuiKey.ImGuiMod_Shift, owner_id, flags) }
	if (key_chord & ImGuiKey.ImGuiMod_Alt) != {} { SetKeyOwner(ImGuiKey.ImGuiMod_Alt, owner_id, flags) }
	if (key_chord & ImGuiKey.ImGuiMod_Super) != {} { SetKeyOwner(ImGuiKey.ImGuiMod_Super, owner_id, flags) }
	if (key_chord & cast(ImGuiKey)~cast(i32)ImGuiKey.ImGuiMod_Mask_) != {} { SetKeyOwner(cast(ImGuiKey) (key_chord & cast(ImGuiKey)~cast(i32)ImGuiKey.ImGuiMod_Mask_), owner_id, flags) }
}

// Inputs Utilities: Key/Input Ownership [BETA]
// - One common use case would be to allow your items to disable standard inputs behaviors such
//   as Tab or Alt key handling, Mouse Wheel scrolling, etc.
//   e.g. Button(...); SetItemKeyOwner(ImGuiKey_MouseWheelY); to make hovering/activating a button disable wheel for scrolling.
// - Reminder ImGuiKey enum include access to mouse buttons and gamepad, so key ownership can apply to them.
// - Many related features are still in imgui_internal.h. For instance, most IsKeyXXX()/IsMouseXXX() functions have an owner-id-aware version.
// Set key owner to last item ID if it is hovered or active. Equivalent to 'if (IsItemHovered() || IsItemActive()) { SetKeyOwner(key, GetItemID());'.
// Set key owner to last item if it is hovered or active. Equivalent to 'if (IsItemHovered() || IsItemActive()) { SetKeyOwner(key, GetItemID());'.
// This is more or less equivalent to:
//   if (IsItemHovered() || IsItemActive())
//       SetKeyOwner(key, GetItemID());
// Extensive uses of that (e.g. many calls for a single item) may want to manually perform the tests once and then call SetKeyOwner() multiple times.
// More advanced usage scenarios may want to call SetKeyOwner() manually based on different condition.
// Worth noting is that only one item can be hovered and only one item can be active, therefore this usage pattern doesn't need to bother with routing and priority.
SetItemKeyOwner_0 :: proc(key : ImGuiKey, flags : ImGuiInputFlags)
{
	flags := flags
	g : ^ImGuiContext = GImGui
	id : ImGuiID = g.LastItemData.ID
	if id == 0 || (g.HoveredId != id && g.ActiveId != id) { return }
	if (flags & cast(ImGuiInputFlags) ImGuiInputFlagsPrivate_.ImGuiInputFlags_CondMask_) == {} { flags |= cast(ImGuiInputFlags) ImGuiInputFlagsPrivate_.ImGuiInputFlags_CondDefault_ }
	if (g.HoveredId == id && (flags & cast(ImGuiInputFlags) ImGuiInputFlagsPrivate_.ImGuiInputFlags_CondHovered) != {}) || (g.ActiveId == id && (flags & cast(ImGuiInputFlags) ImGuiInputFlagsPrivate_.ImGuiInputFlags_CondActive) != {}) {
		IM_ASSERT((flags & cast(ImGuiInputFlags)~cast(i32)ImGuiInputFlagsPrivate_.ImGuiInputFlags_SupportedBySetItemKeyOwner) == {}); // Passing flags not supported by this function!
		SetKeyOwner(key, id, flags & cast(ImGuiInputFlags)~cast(i32)ImGuiInputFlagsPrivate_.ImGuiInputFlags_CondMask_)
	}
}

SetItemKeyOwner_1 :: proc(key : ImGuiKey)
{
	SetItemKeyOwner(key, ImGuiInputFlags_.ImGuiInputFlags_None)
}

// was key chord (mods + key) pressed, e.g. you can pass 'ImGuiMod_Ctrl | ImGuiKey_S' as a key-chord. This doesn't do any routing or focus check, please consider using Shortcut() function instead.
// This is the only public API until we expose owner_id versions of the API as replacements.
IsKeyChordPressed_0 :: proc(key_chord : ImGuiKeyChord) -> bool
{
	return IsKeyChordPressed(key_chord, ImGuiInputFlags_.ImGuiInputFlags_None, ImGuiKeyOwner_Any)
}

// was key chord (mods + key) pressed, e.g. you can pass 'ImGuiMod_Ctrl | ImGuiKey_S' as a key-chord. This doesn't do any routing or focus check, please consider using Shortcut() function instead.
// This is equivalent to comparing KeyMods + doing a IsKeyPressed()
IsKeyChordPressed_1 :: proc(key_chord : ImGuiKeyChord, flags : ImGuiInputFlags, owner_id : ImGuiID) -> bool
{
	g : ^ImGuiContext = GImGui
	key_chord := FixupKeyChord(key_chord)
	mods : ImGuiKey = cast(ImGuiKey) (key_chord & ImGuiKey.ImGuiMod_Mask_)
	if g.IO.KeyMods != mods { return false }

	// Special storage location for mods
	key : ImGuiKey = cast(ImGuiKey) (key_chord & cast(ImGuiKeyChord)~cast(i32)ImGuiKey.ImGuiMod_Mask_)
	if key == ImGuiKey.ImGuiKey_None { key = ConvertSingleModFlagToKey(mods) }
	if !IsKeyPressed(key, (flags & cast(ImGuiInputFlags) ImGuiInputFlagsPrivate_.ImGuiInputFlags_RepeatMask_), owner_id) { return false }
	return true
}

SetNextItemShortcut :: proc(key_chord : ImGuiKeyChord, flags : ImGuiInputFlags = {})
{
	g : ^ImGuiContext = GImGui
	g.NextItemData.HasFlags |= ImGuiNextItemDataFlags_.ImGuiNextItemDataFlags_HasShortcut
	g.NextItemData.Shortcut = key_chord
	g.NextItemData.ShortcutFlags = flags
}

// Item
// Called from within ItemAdd: at this point we can read from NextItemData and write to LastItemData
ItemHandleShortcut :: proc(id : ImGuiID)
{
	g : ^ImGuiContext = GImGui
	flags : ImGuiInputFlags = g.NextItemData.ShortcutFlags
	IM_ASSERT((flags & cast(ImGuiInputFlags) ~cast(i32) ImGuiInputFlagsPrivate_.ImGuiInputFlags_SupportedBySetNextItemShortcut) == {}); // Passing flags not supported by SetNextItemShortcut()!

	if (g.LastItemData.ItemFlags & cast(ImGuiItemFlags) ImGuiItemFlagsPrivate_.ImGuiItemFlags_Disabled) != {} { return }
	if (flags & ImGuiInputFlags_.ImGuiInputFlags_Tooltip) != {} {
		g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_.ImGuiItemStatusFlags_HasShortcut
		g.LastItemData.Shortcut = g.NextItemData.Shortcut
	}
	if !Shortcut(g.NextItemData.Shortcut, flags & cast(ImGuiInputFlags) ImGuiInputFlagsPrivate_.ImGuiInputFlags_SupportedByShortcut, id) || g.NavActivateId != 0 { return }

	// FIXME: Generalize Activation queue?
	g.NavActivateId = id; // Will effectively disable clipping.
	g.NavActivateFlags = ImGuiActivateFlags_.ImGuiActivateFlags_PreferInput | ImGuiActivateFlags_.ImGuiActivateFlags_FromShortcut
	//if (g.ActiveId == 0 || g.ActiveId == id)
	g.NavActivatePressedId = id; g.NavActivateDownId = g.NavActivatePressedId
	NavHighlightActivated(id)
}

// Inputs Utilities: Shortcut Testing & Routing [BETA]
// - ImGuiKeyChord = a ImGuiKey + optional ImGuiMod_Alt/ImGuiMod_Ctrl/ImGuiMod_Shift/ImGuiMod_Super.
//       ImGuiKey_C                          // Accepted by functions taking ImGuiKey or ImGuiKeyChord arguments)
//       ImGuiMod_Ctrl | ImGuiKey_C          // Accepted by functions taking ImGuiKeyChord arguments)
//   only ImGuiMod_XXX values are legal to combine with an ImGuiKey. You CANNOT combine two ImGuiKey values.
// - The general idea is that several callers may register interest in a shortcut, and only one owner gets it.
//      Parent   -> call Shortcut(Ctrl+S)    // When Parent is focused, Parent gets the shortcut.
//        Child1 -> call Shortcut(Ctrl+S)    // When Child1 is focused, Child1 gets the shortcut (Child1 overrides Parent shortcuts)
//        Child2 -> no call                  // When Child2 is focused, Parent gets the shortcut.
//   The whole system is order independent, so if Child1 makes its calls before Parent, results will be identical.
//   This is an important property as it facilitate working with foreign code or larger codebase.
// - To understand the difference:
//   - IsKeyChordPressed() compares mods and call IsKeyPressed() -> function has no side-effect.
//   - Shortcut() submits a route, routes are resolved, if it currently can be routed it calls IsKeyChordPressed() -> function has (desirable) side-effects as it can prevents another call from getting the route.
// - Visualize registered routes in 'Metrics/Debugger->Inputs'.
// Shortcut Testing & Routing
// - Set Shortcut() and SetNextItemShortcut() in imgui.h
// - When a policy (except for ImGuiInputFlags_RouteAlways *) is set, Shortcut() will register itself with SetShortcutRouting(),
//   allowing the system to decide where to route the input among other route-aware calls.
//   (* using ImGuiInputFlags_RouteAlways is roughly equivalent to calling IsKeyChordPressed(key) and bypassing route registration and check)
// - When using one of the routing option:
//   - The default route is ImGuiInputFlags_RouteFocused (accept inputs if window is in focus stack. Deep-most focused window takes inputs. ActiveId takes inputs over deep-most focused window.)
//   - Routes are requested given a chord (key + modifiers) and a routing policy.
//   - Routes are resolved during NewFrame(): if keyboard modifiers are matching current ones: SetKeyOwner() is called + route is granted for the frame.
//   - Each route may be granted to a single owner. When multiple requests are made we have policies to select the winning route (e.g. deep most window).
//   - Multiple read sites may use the same owner id can all access the granted route.
//   - When owner_id is 0 we use the current Focus Scope ID as a owner ID in order to identify our location.
// - You can chain two unrelated windows in the focus stack using SetWindowParentWindowForFocusRoute()
//   e.g. if you have a tool window associated to a document, and you want document shortcuts to run when the tool is focused.
Shortcut_0 :: proc(key_chord : ImGuiKeyChord, flags : ImGuiInputFlags = {}) -> bool
{
	return Shortcut(key_chord, flags, ImGuiKeyOwner_Any)
}

Shortcut_1 :: proc(key_chord : ImGuiKeyChord, flags : ImGuiInputFlags, owner_id : ImGuiID) -> bool
{
	g : ^ImGuiContext = GImGui
	//IMGUI_DEBUG_LOG("Shortcut(%s, flags=%X, owner_id=0x%08X)\n", GetKeyChordName(key_chord, g.TempBuffer.Data, g.TempBuffer.Size), flags, owner_id);

	flags := flags
	// When using (owner_id == 0/Any): SetShortcutRouting() will use CurrentFocusScopeId and filter with this, so IsKeyPressed() is fine with he 0/Any.
	if (flags & cast(ImGuiInputFlags) ImGuiInputFlagsPrivate_.ImGuiInputFlags_RouteTypeMask_) == {} { flags |= ImGuiInputFlags_.ImGuiInputFlags_RouteFocused }

	owner_id := owner_id
	// Using 'owner_id == ImGuiKeyOwner_Any/0': auto-assign an owner based on current focus scope (each window has its focus scope by default)
	// Effectively makes Shortcut() always input-owner aware.
	if owner_id == ImGuiKeyOwner_Any || owner_id == ImGuiKeyOwner_NoOwner { owner_id = GetRoutingIdFromOwnerId(owner_id) }

	if (g.CurrentItemFlags & cast(ImGuiItemFlags) ImGuiItemFlagsPrivate_.ImGuiItemFlags_Disabled) != {} { return false }

	// Submit route
	if !SetShortcutRouting(key_chord, flags, owner_id) { return false }

	// Default repeat behavior for Shortcut()
	// So e.g. pressing Ctrl+W and releasing Ctrl while holding W will not trigger the W shortcut.
	if (flags & ImGuiInputFlags_.ImGuiInputFlags_Repeat) != {} && (flags & cast(ImGuiInputFlags) ImGuiInputFlagsPrivate_.ImGuiInputFlags_RepeatUntilMask_) == {} { flags |= cast(ImGuiInputFlags) ImGuiInputFlagsPrivate_.ImGuiInputFlags_RepeatUntilKeyModsChange }

	if !IsKeyChordPressed(key_chord, flags, owner_id) { return false }

	// Claim mods during the press
	SetKeyOwnersForKeyChord(key_chord & ImGuiKey.ImGuiMod_Mask_, owner_id)

	IM_ASSERT((flags & cast(ImGuiInputFlags)~cast(i32)ImGuiInputFlagsPrivate_.ImGuiInputFlags_SupportedByShortcut) == {}); // Passing flags not supported by this function!
	return true
}

// This is called by IMGUI_CHECKVERSION() macro.
//-----------------------------------------------------------------------------
// [SECTION] ERROR CHECKING, STATE RECOVERY
//-----------------------------------------------------------------------------
// - DebugCheckVersionAndDataLayout() (called via IMGUI_CHECKVERSION() macros)
// - ErrorCheckUsingSetCursorPosToExtendParentBoundaries()
// - ErrorCheckNewFrameSanityChecks()
// - ErrorCheckEndFrameSanityChecks()
// - ErrorRecoveryStoreState()
// - ErrorRecoveryTryToRecoverState()
// - ErrorRecoveryTryToRecoverWindowState()
// - ErrorLog()
//-----------------------------------------------------------------------------

// Verify ABI compatibility between caller code and compiled version of Dear ImGui. This helps detects some build issues.
// Called by IMGUI_CHECKVERSION().
// Verify that the type sizes are matching between the calling file's compilation unit and imgui.cpp's compilation unit
// If this triggers you have mismatched headers and compiled code versions.
// - It could be because of a build issue (using new headers with old compiled code)
// - It could be because of mismatched configuration #define, compilation settings, packing pragma etc.
//   THE CONFIGURATION SETTINGS MENTIONED IN imconfig.h MUST BE SET FOR ALL COMPILATION UNITS INVOLVED WITH DEAR IMGUI.
//   Which is why it is required you put them in your imconfig file (and NOT only before including imgui.h).
//   Otherwise it is possible that different compilation units would see different structure layout.
//   If you don't want to modify imconfig.h you can use the IMGUI_USER_CONFIG define to change filename.
DebugCheckVersionAndDataLayout :: proc(version : string, sz_io : uint, sz_style : uint, sz_vec2 : uint, sz_vec4 : uint, sz_vert : uint, sz_idx : uint) -> bool
{
	error : bool = false
	if version == IMGUI_VERSION {error = true; IM_ASSERT(version == IMGUI_VERSION, "Mismatched version string!") }
	if sz_io != size_of(ImGuiIO) {error = true; IM_ASSERT(sz_io == size_of(ImGuiIO), "Mismatched struct layout!") }
	if sz_style != size_of(ImGuiStyle) {error = true; IM_ASSERT(sz_style == size_of(ImGuiStyle), "Mismatched struct layout!") }
	if sz_vec2 != size_of(ImVec2) {error = true; IM_ASSERT(sz_vec2 == size_of(ImVec2), "Mismatched struct layout!") }
	if sz_vec4 != size_of(ImVec4) {error = true; IM_ASSERT(sz_vec4 == size_of(ImVec4), "Mismatched struct layout!") }
	if sz_vert != size_of(ImDrawVert) {error = true; IM_ASSERT(sz_vert == size_of(ImDrawVert), "Mismatched struct layout!") }
	if sz_idx != size_of(ImDrawIdx) {error = true; IM_ASSERT(sz_idx == size_of(ImDrawIdx), "Mismatched struct layout!") }
	return !error
}

// Until 1.89 (IMGUI_VERSION_NUM < 18814) it was legal to use SetCursorPos() to extend the boundary of a parent (e.g. window or table cell)
// This is causing issues and ambiguity and we need to retire that.
// See https://github.com/ocornut/imgui/issues/5548 for more details.
// [Scenario 1]
//  Previously this would make the window content size ~200x200:
//    Begin(...) + SetCursorScreenPos(GetCursorScreenPos() + ImVec2{200,200}) + End();  // NOT OK
//  Instead, please submit an item:
//    Begin(...) + SetCursorScreenPos(GetCursorScreenPos() + ImVec2{200,200}) + Dummy(ImVec2{0,0}) + End(); // OK
//  Alternative:
//    Begin(...) + Dummy(ImVec2{200,200}) + End(); // OK
// [Scenario 2]
//  For reference this is one of the issue what we aim to fix with this change:
//    BeginGroup() + SomeItem("foobar") + SetCursorScreenPos(GetCursorScreenPos()) + EndGroup()
//  The previous logic made SetCursorScreenPos(GetCursorScreenPos()) have a side-effect! It would erroneously incorporate ItemSpacing.y after the item into content size, making the group taller!
//  While this code is a little twisted, no-one would expect SetXXX(GetXXX()) to have a side-effect. Using vertical alignment patterns could trigger this issue.
ErrorCheckUsingSetCursorPosToExtendParentBoundaries :: proc()
{
	g : ^ImGuiContext = GImGui
	window : ^ImGuiWindow = g.CurrentWindow
	IM_ASSERT(window.DC.IsSetPos)
	window.DC.IsSetPos = false
	if window.DC.CursorPos.x <= window.DC.CursorMaxPos.x && window.DC.CursorPos.y <= window.DC.CursorMaxPos.y { return }
	if window.SkipItems { return }
	IM_ASSERT(false, "Code uses SetCursorPos()/SetCursorScreenPos() to extend window/parent boundaries. Please submit an item e.g. Dummy() to validate extent.")
}

// Error Checking and Debug Tools
ErrorCheckNewFrameSanityChecks :: proc()
{
	g : ^ImGuiContext = GImGui

	// Check user IM_ASSERT macro
	// (IF YOU GET A WARNING OR COMPILE ERROR HERE: it means your assert macro is incorrectly defined!
	//  If your macro uses multiple statements, it NEEDS to be surrounded by a 'do { ... } while (0)' block.
	//  This is a common C/C++ idiom to allow multiple statements macros to be used in control flow blocks.)
	// #define IM_ASSERT(EXPR)   if (SomeCode(EXPR)) SomeMoreCode();                    // Wrong!
	// #define IM_ASSERT(EXPR)   do { if (SomeCode(EXPR)) SomeMoreCode(); } while (0)   // Correct!
	if true { IM_ASSERT(true) }
	else { IM_ASSERT(false) }

	// Emscripten backends are often imprecise in their submission of DeltaTime. (#6114, #3644)
	// Ideally the Emscripten app/backend should aim to fix or smooth this value and avoid feeding zero, but we tolerate it.
	when ODIN_OS == .JS { /* @gen ifdef */
	if g.IO.DeltaTime <= 0.0 && g.FrameCount > 0 { g.IO.DeltaTime = 0.00001 }
	} // preproc endif

	// Check user data
	// (We pass an error message in the assert expression to make it visible to programmers who are not using a debugger, as most assert handlers display their argument)
	IM_ASSERT(g.Initialized)
	IM_ASSERT((g.IO.DeltaTime > 0.0 || g.FrameCount == 0), "Need a positive DeltaTime!")
	IM_ASSERT((g.FrameCount == 0 || g.FrameCountEnded == g.FrameCount), "Forgot to call Render() or EndFrame() at the end of the previous frame?")
	IM_ASSERT(g.IO.DisplaySize.x >= 0.0 && g.IO.DisplaySize.y >= 0.0, "Invalid DisplaySize value!")
	IM_ASSERT(IsBuilt(g.IO.Fonts), "Font Atlas not built! Make sure you called ImGui_ImplXXXX_NewFrame() function for renderer backend, which should call io.Fonts->GetTexDataAsRGBA32() / GetTexDataAsAlpha8()")
	IM_ASSERT(g.Style.CurveTessellationTol > 0.0, "Invalid style setting!")
	IM_ASSERT(g.Style.CircleTessellationMaxError > 0.0, "Invalid style setting!")
	IM_ASSERT(g.Style.Alpha >= 0.0 && g.Style.Alpha <= 1.0, "Invalid style setting!"); // Allows us to avoid a few clamps in color computations
	IM_ASSERT(g.Style.WindowMinSize.x >= 1.0 && g.Style.WindowMinSize.y >= 1.0, "Invalid style setting.")
	IM_ASSERT(g.Style.WindowMenuButtonPosition == ImGuiDir.ImGuiDir_None || g.Style.WindowMenuButtonPosition == ImGuiDir.ImGuiDir_Left || g.Style.WindowMenuButtonPosition == ImGuiDir.ImGuiDir_Right)
	IM_ASSERT(g.Style.ColorButtonPosition == ImGuiDir.ImGuiDir_Left || g.Style.ColorButtonPosition == ImGuiDir.ImGuiDir_Right)

	// Error handling: we do not accept 100% silent recovery! Please contact me if you feel this is getting in your way.
	if g.IO.ConfigErrorRecovery { IM_ASSERT(g.IO.ConfigErrorRecoveryEnableAssert || g.IO.ConfigErrorRecoveryEnableDebugLog || g.IO.ConfigErrorRecoveryEnableTooltip || g.ErrorCallback != nil) }



	// Perform simple check: error if Docking or Viewport are enabled _exactly_ on frame 1 (instead of frame 0 or later), which is a common error leading to loss of .ini data.
	if g.FrameCount == 1 && (g.IO.ConfigFlags & ImGuiConfigFlags_.ImGuiConfigFlags_DockingEnable) != {} && (g.ConfigFlagsLastFrame & ImGuiConfigFlags_.ImGuiConfigFlags_DockingEnable) == {} { IM_ASSERT(false, "Please set DockingEnable before the first call to NewFrame()! Otherwise you will lose your .ini settings!") }
	if g.FrameCount == 1 && (g.IO.ConfigFlags & ImGuiConfigFlags_.ImGuiConfigFlags_ViewportsEnable) != {} && (g.ConfigFlagsLastFrame & ImGuiConfigFlags_.ImGuiConfigFlags_ViewportsEnable) == {} { IM_ASSERT(false, "Please set ViewportsEnable before the first call to NewFrame()! Otherwise you will lose your .ini settings!") }

	// Perform simple checks: multi-viewport and platform windows support
	if (g.IO.ConfigFlags & ImGuiConfigFlags_.ImGuiConfigFlags_ViewportsEnable) != {} {
		if (g.IO.BackendFlags & ImGuiBackendFlags_.ImGuiBackendFlags_PlatformHasViewports) != {} && (g.IO.BackendFlags & ImGuiBackendFlags_.ImGuiBackendFlags_RendererHasViewports) != {} {
			IM_ASSERT((g.FrameCount == 0 || g.FrameCount == g.FrameCountPlatformEnded), "Forgot to call UpdatePlatformWindows() in main loop after EndFrame()? Check examples/ applications for reference.")
			IM_ASSERT(g.PlatformIO.Platform_CreateWindow != nil, "Platform init didn't install handlers?")
			IM_ASSERT(g.PlatformIO.Platform_DestroyWindow != nil, "Platform init didn't install handlers?")
			IM_ASSERT(g.PlatformIO.Platform_GetWindowPos != nil, "Platform init didn't install handlers?")
			IM_ASSERT(g.PlatformIO.Platform_SetWindowPos != nil, "Platform init didn't install handlers?")
			IM_ASSERT(g.PlatformIO.Platform_GetWindowSize != nil, "Platform init didn't install handlers?")
			IM_ASSERT(g.PlatformIO.Platform_SetWindowSize != nil, "Platform init didn't install handlers?")
			IM_ASSERT(g.PlatformIO.Monitors.Size > 0, "Platform init didn't setup Monitors list?")
			IM_ASSERT((g.Viewports.Data[0].PlatformUserData != nil || g.Viewports.Data[0].PlatformHandle != nil), "Platform init didn't setup main viewport.")
			if g.IO.ConfigDockingTransparentPayload && (g.IO.ConfigFlags & ImGuiConfigFlags_.ImGuiConfigFlags_DockingEnable) != {} { IM_ASSERT(g.PlatformIO.Platform_SetWindowAlpha != nil, "Platform_SetWindowAlpha handler is required to use io.ConfigDockingTransparent!") }
		}
		else {
			// Disable feature, our backends do not support it
			g.IO.ConfigFlags &= cast(ImGuiConfigFlags)~cast(i32)ImGuiConfigFlags_.ImGuiConfigFlags_ViewportsEnable
		}

		// Perform simple checks on platform monitor data + compute a total bounding box for quick early outs
		for mon in g.PlatformIO.Monitors.Data[:g.PlatformIO.Monitors.Size] {
			IM_UNUSED(mon)
			IM_ASSERT(mon.MainSize.x > 0.0 && mon.MainSize.y > 0.0, "Monitor main bounds not setup properly.")
			IM_ASSERT(Contains(ImRect{mon.MainPos, mon.MainPos + mon.MainSize}, ImRect{mon.WorkPos, mon.WorkPos + mon.WorkSize}), "Monitor work bounds not setup properly. If you don't have work area information, just copy MainPos/MainSize into them.")
			IM_ASSERT(mon.DpiScale > 0.0 && mon.DpiScale < 99.0, "Monitor DpiScale is invalid."); // Typical correct values would be between 1.0f and 4.0f
		}
	}
}

ErrorCheckEndFrameSanityChecks :: proc()
{
	// Verify that io.KeyXXX fields haven't been tampered with. Key mods should not be modified between NewFrame() and EndFrame()
	// One possible reason leading to this assert is that your backends update inputs _AFTER_ NewFrame().
	// It is known that when some modal native windows called mid-frame takes focus away, some backends such as GLFW will
	// send key release events mid-frame. This would normally trigger this assertion and lead to sheared inputs.
	// We silently accommodate for this case by ignoring the case where all io.KeyXXX modifiers were released (aka key_mod_flags == 0),
	// while still correctly asserting on mid-frame key press events.
	g : ^ImGuiContext = GImGui
	key_mods : ImGuiKeyChord = GetMergedModsFromKeys()
	IM_UNUSED(g)
	IM_UNUSED(key_mods)
	IM_ASSERT((key_mods == {} || g.IO.KeyMods == key_mods), "Mismatching io.KeyCtrl/io.KeyShift/io.KeyAlt/io.KeySuper vs io.KeyMods")
	IM_UNUSED(key_mods)

	IM_ASSERT(g.CurrentWindowStack.Size == 1)
	IM_ASSERT(g.CurrentWindowStack.Data[0].Window.IsFallbackWindow)
}

// Save current stack sizes. Called e.g. by NewFrame() and by Begin() but may be called for manual recovery.
ErrorRecoveryStoreState :: proc(state_out : ^ImGuiErrorRecoveryState)
{
	g : ^ImGuiContext = GImGui
	state_out.SizeOfWindowStack = cast(i16) g.CurrentWindowStack.Size
	state_out.SizeOfIDStack = cast(i16) g.CurrentWindow.IDStack.Size
	state_out.SizeOfTreeStack = cast(i16) g.CurrentWindow.DC.TreeDepth; // NOT g.TreeNodeStack.Size which is a partial stack!
	state_out.SizeOfColorStack = cast(i16) g.ColorStack.Size
	state_out.SizeOfStyleVarStack = cast(i16) g.StyleVarStack.Size
	state_out.SizeOfFontStack = cast(i16) g.FontStack.Size
	state_out.SizeOfFocusScopeStack = cast(i16) g.FocusScopeStack.Size
	state_out.SizeOfGroupStack = cast(i16) g.GroupStack.Size
	state_out.SizeOfItemFlagsStack = cast(i16) g.ItemFlagsStack.Size
	state_out.SizeOfBeginPopupStack = cast(i16) g.BeginPopupStack.Size
	state_out.SizeOfDisabledStack = cast(i16) g.DisabledStackSize
}

// Chosen name "Try to recover" over e.g. "Restore" to suggest this is not a 100% guaranteed recovery.
// Called by e.g. EndFrame() but may be called for manual recovery.
// Attempt to recover full window stack.
ErrorRecoveryTryToRecoverState :: proc(state_in : ^ImGuiErrorRecoveryState)
{
	// PVS-Studio V1044 is "Loop break conditions do not depend on the number of iterations"
	g : ^ImGuiContext = GImGui
	for g.CurrentWindowStack.Size > i32(state_in.SizeOfWindowStack) {
		// Recap:
		// - Begin()/BeginChild() return false to indicate the window is collapsed or fully clipped.
		// - Always call a matching End() for each Begin() call, regardless of its return value!
		// - Begin/End and BeginChild/EndChild logic is KNOWN TO BE INCONSISTENT WITH ALL OTHER BEGIN/END FUNCTIONS.
		// - We will fix that in a future major update.
		window : ^ImGuiWindow = g.CurrentWindow
		if (window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_ChildWindow) != {} {
			if g.CurrentTable != nil && g.CurrentTable.InnerWindow == g.CurrentWindow {
				IM_ASSERT_USER_ERROR(false, "Missing EndTable()")
				EndTable()
			}
			else {
				IM_ASSERT_USER_ERROR(false, "Missing EndChild()")
				EndChild()
			}
		}
		else {
			IM_ASSERT_USER_ERROR(false, "Missing End()")
			End()
		}
	}

	if g.CurrentWindowStack.Size == i32(state_in.SizeOfWindowStack) { ErrorRecoveryTryToRecoverWindowState(state_in) }
}

// Called by e.g. End() but may be called for manual recovery.
// Read '// Error Handling [BETA]' block in imgui_internal.h for details.
// Attempt to recover from incorrect usage of BeginXXX/EndXXX/PushXXX/PopXXX calls.
ErrorRecoveryTryToRecoverWindowState :: proc(state_in : ^ImGuiErrorRecoveryState)
{
	g : ^ImGuiContext = GImGui

	for g.CurrentTable != nil && g.CurrentTable.InnerWindow == g.CurrentWindow {
		IM_ASSERT_USER_ERROR(false, "Missing EndTable()")
		EndTable()
	}

	window : ^ImGuiWindow = g.CurrentWindow

	// FIXME: Can't recover from inside BeginTabItem/EndTabItem yet.
	for g.CurrentTabBar != nil && g.CurrentTabBar.Window == window {
		IM_ASSERT_USER_ERROR(false, "Missing EndTabBar()")
		EndTabBar()
	}

	for g.CurrentMultiSelect != nil && g.CurrentMultiSelect.Storage.Window == window {
		IM_ASSERT_USER_ERROR(false, "Missing EndMultiSelect()")
		EndMultiSelect()
	}

	for window.DC.TreeDepth > cast(i32) state_in.SizeOfTreeStack {
		IM_ASSERT_USER_ERROR(false, "Missing TreePop()")
		TreePop()
	}

	for g.GroupStack.Size > cast(i32) state_in.SizeOfGroupStack {
		IM_ASSERT_USER_ERROR(false, "Missing EndGroup()")
		EndGroup()
	}

	IM_ASSERT(g.GroupStack.Size == cast(i32) state_in.SizeOfGroupStack)
	for window.IDStack.Size > cast(i32) state_in.SizeOfIDStack {
		IM_ASSERT_USER_ERROR(false, "Missing PopID()")
		PopID()
	}

	for g.DisabledStackSize > state_in.SizeOfDisabledStack {
		IM_ASSERT_USER_ERROR(false, "Missing EndDisabled()")
		if (g.CurrentItemFlags & cast(ImGuiItemFlags) ImGuiItemFlagsPrivate_.ImGuiItemFlags_Disabled) != {} { EndDisabled() }
		else {
			EndDisabledOverrideReenable()
			back(&g.CurrentWindowStack).DisabledOverrideReenable = false
		}
	}

	IM_ASSERT(g.DisabledStackSize == state_in.SizeOfDisabledStack)
	for g.ColorStack.Size > cast(i32) state_in.SizeOfColorStack {
		IM_ASSERT_USER_ERROR(false, "Missing PopStyleColor()")
		PopStyleColor()
	}

	for g.ItemFlagsStack.Size > cast(i32) state_in.SizeOfItemFlagsStack {
		IM_ASSERT_USER_ERROR(false, "Missing PopItemFlag()")
		PopItemFlag()
	}

	for g.StyleVarStack.Size > cast(i32) state_in.SizeOfStyleVarStack {
		IM_ASSERT_USER_ERROR(false, "Missing PopStyleVar()")
		PopStyleVar()
	}

	for g.FontStack.Size > cast(i32) state_in.SizeOfFontStack {
		IM_ASSERT_USER_ERROR(false, "Missing PopFont()")
		PopFont()
	}

	for g.FocusScopeStack.Size > cast(i32) state_in.SizeOfFocusScopeStack {
		IM_ASSERT_USER_ERROR(false, "Missing PopFocusScope()")
		PopFocusScope()
	}

	//IM_ASSERT(g.FocusScopeStack.Size == state_in->SizeOfFocusScopeStack);
}

// Error handling, State Recovery
ErrorLog :: proc(msg : string) -> bool
{
	g : ^ImGuiContext = GImGui

	// Output to debug log
	when ! IMGUI_DISABLE_DEBUG_TOOLS { /* @gen ifndef */
	window : ^ImGuiWindow = g.CurrentWindow

	if g.IO.ConfigErrorRecoveryEnableDebugLog {
		if g.ErrorFirst { IMGUI_DEBUG_LOG_ERROR("[imgui-error] (current settings: Assert=%d, Log=%d, Tooltip=%d)\n", g.IO.ConfigErrorRecoveryEnableAssert, g.IO.ConfigErrorRecoveryEnableDebugLog, g.IO.ConfigErrorRecoveryEnableTooltip) }
		IMGUI_DEBUG_LOG_ERROR("[imgui-error] In window '%s': %s\n", window != nil ? window.Name : "NULL", msg)
	}
	g.ErrorFirst = false

	// Output to tooltip
	if g.IO.ConfigErrorRecoveryEnableTooltip {
		if g.WithinFrameScope && BeginErrorTooltip() {
			if g.ErrorCountCurrentFrame < 20 {
				Text("In window '%s': %s", window != nil ? window.Name : "NULL", msg)
				if window != nil && (!window.IsFallbackWindow || window.WasActive) { AddRect(GetForegroundDrawList(window), window.Pos, window.Pos + window.Size, IM_COL32(255, 0, 0, 255)) }
			}
			if g.ErrorCountCurrentFrame == 20 { Text("(and more errors)") }
			// EndFrame() will amend debug buttons to this window, after all errors have been submitted.
			EndErrorTooltip()
		}
		post_incr(&g.ErrorCountCurrentFrame)
	}
	} // preproc endif

	// Output to callback
	if g.ErrorCallback != nil { g.ErrorCallback(g, g.ErrorCallbackUserData, msg) }

	// Return whether we should assert
	return g.IO.ConfigErrorRecoveryEnableAssert
}

ErrorCheckEndFrameFinalizeErrorTooltip :: proc()
{
	when ! IMGUI_DISABLE_DEBUG_TOOLS { /* @gen ifndef */
	g : ^ImGuiContext = GImGui
	if g.DebugDrawIdConflicts != 0 && g.IO.KeyCtrl == false { g.DebugDrawIdConflictsCount = g.HoveredIdPreviousFrameItemCount }
	if g.DebugDrawIdConflicts != 0 && g.DebugItemPickerActive == false && BeginErrorTooltip() {
		Text("Programmer error: %d visible items with conflicting ID!", g.DebugDrawIdConflictsCount)
		BulletText("Code should use PushID()/PopID() in loops, or append \"##xx\" to same-label identifiers!")
		BulletText("Empty label e.g. Button(\"\") == same ID as parent widget/node. Use Button(\"##xx\") instead!")
		//BulletText("Code intending to use duplicate ID may use e.g. PushItemFlag(ImGuiItemFlags_AllowDuplicateId, true); ... PopItemFlag()"); // Not making this too visible for fear of it being abused.
		BulletText("Set io.ConfigDebugHighlightIdConflicts=false to disable this warning in non-programmers builds.")
		Separator()
		Text("(Hold CTRL to: use")
		SameLine()
		if SmallButton("Item Picker") { DebugStartItemPicker() }
		SameLine()
		Text("to break in item call-stack, or")
		SameLine()
		if SmallButton("Open FAQ->About ID Stack System") && g.PlatformIO.Platform_OpenInShellFn != nil { g.PlatformIO.Platform_OpenInShellFn(g, "https://github.com/ocornut/imgui/blob/master/docs/FAQ.md#qa-usage") }
		EndErrorTooltip()
	}

	if g.ErrorCountCurrentFrame > 0 && BeginErrorTooltip() {
		// Amend at end of frame
		Separator()
		Text("(Hold CTRL to:")
		SameLine()
		if SmallButton("Enable Asserts") { g.IO.ConfigErrorRecoveryEnableAssert = true }
		//SameLine();
		//if (SmallButton("Hide Error Tooltips"))
		//    g.IO.ConfigErrorRecoveryEnableTooltip = false; // Too dangerous
		SameLine(0, 0)
		Text(")")
		EndErrorTooltip()
	}
	} // preproc endif
}

// Pseudo-tooltip. Follow mouse until CTRL is held. When CTRL is held we lock position, allowing to click it.
BeginErrorTooltip :: proc() -> bool
{
	g : ^ImGuiContext = GImGui
	window : ^ImGuiWindow = FindWindowByName("##Tooltip_Error")
	use_locked_pos : bool = (g.IO.KeyCtrl && window != nil && window.WasActive)
	PushStyleColor(ImGuiCol_.ImGuiCol_PopupBg, ImLerp(g.Style.Colors[ImGuiCol_.ImGuiCol_PopupBg], ImVec4{1.0, 0.0, 0.0, 1.0}, 0.15))
	if use_locked_pos { SetNextWindowPos(g.ErrorTooltipLockedPos) }
	is_visible : bool = Begin("##Tooltip_Error", nil, ImGuiWindowFlags_.ImGuiWindowFlags_Tooltip | ImGuiWindowFlags_.ImGuiWindowFlags_NoDecoration | ImGuiWindowFlags_.ImGuiWindowFlags_NoMove | ImGuiWindowFlags_.ImGuiWindowFlags_NoResize | ImGuiWindowFlags_.ImGuiWindowFlags_NoSavedSettings | ImGuiWindowFlags_.ImGuiWindowFlags_AlwaysAutoResize)
	PopStyleColor()
	if is_visible && g.CurrentWindow.BeginCount == 1 {
		SeparatorText("MESSAGE FROM DEAR IMGUI")
		BringWindowToDisplayFront(g.CurrentWindow)
		BringWindowToFocusFront(g.CurrentWindow)
		g.ErrorTooltipLockedPos = GetWindowPos()
	}
	else if !is_visible {
		End()
	}
	return is_visible
}

EndErrorTooltip :: proc()
{
	End()
}

//-----------------------------------------------------------------------------
// [SECTION] ITEM SUBMISSION
//-----------------------------------------------------------------------------
// - KeepAliveID()
// - ItemAdd()
//-----------------------------------------------------------------------------

// Code not using ItemAdd() may need to call this manually otherwise ActiveId will be cleared. In IMGUI_VERSION_NUM < 18717 this was called by GetID().
KeepAliveID :: proc(id : ImGuiID)
{
	g : ^ImGuiContext = GImGui
	if g.ActiveId == id { g.ActiveIdIsAlive = id }
	if g.ActiveIdPreviousFrame == id { g.ActiveIdPreviousFrameIsAlive = true }
}

// Declare item bounding box for clipping and interaction.
// Note that the size can be different than the one provided to ItemSize(). Typically, widgets that spread over available surface
// declare their minimum size requirement to ItemSize() and provide a larger region to ItemAdd() which is used drawing/interaction.
// THIS IS IN THE PERFORMANCE CRITICAL PATH (UNTIL THE CLIPPING TEST AND EARLY-RETURN)

ItemAdd :: proc(bb : ImRect, id : ImGuiID, nav_bb_arg : ^ImRect = nil, extra_flags : ImGuiItemFlags = {}) -> bool
{
	g : ^ImGuiContext = GImGui
	window : ^ImGuiWindow = g.CurrentWindow

	// Set item data
	// (DisplayRect is left untouched, made valid when ImGuiItemStatusFlags_HasDisplayRect is set)
	g.LastItemData.ID = id
	g.LastItemData.Rect = bb
	g.LastItemData.NavRect = nav_bb_arg != nil ? nav_bb_arg^ : bb
	g.LastItemData.ItemFlags = g.CurrentItemFlags | g.NextItemData.ItemFlags | extra_flags
	g.LastItemData.StatusFlags = ImGuiItemStatusFlags_.ImGuiItemStatusFlags_None
	// Note: we don't copy 'g.NextItemData.SelectionUserData' to an hypothetical g.LastItemData.SelectionUserData: since the former is not cleared.

	if id != 0 {
		KeepAliveID(id)

		// Directional navigation processing
		// Runs prior to clipping early-out
		//  (a) So that NavInitRequest can be honored, for newly opened windows to select a default widget
		//  (b) So that we can scroll up/down past clipped items. This adds a small O(N) cost to regular navigation requests
		//      unfortunately, but it is still limited to one window. It may not scale very well for windows with ten of
		//      thousands of item, but at least NavMoveRequest is only set on user interaction, aka maximum once a frame.
		//      We could early out with "if (is_clipped && !g.NavInitRequest) return false;" but when we wouldn't be able
		//      to reach unclipped widgets. This would work if user had explicit scrolling control (e.g. mapped on a stick).
		// We intentionally don't check if g.NavWindow != NULL because g.NavAnyRequest should only be set when it is non null.
		// If we crash on a NULL g.NavWindow we need to fix the bug elsewhere.
		if (g.LastItemData.ItemFlags & ImGuiItemFlags_.ImGuiItemFlags_NoNav) == {} {
			// FIMXE-NAV: investigate changing the window tests into a simple 'if (g.NavFocusScopeId == g.CurrentFocusScopeId)' test.
			window.DC.NavLayersActiveMaskNext |= (1 << cast(u32) window.DC.NavLayerCurrent)
			if g.NavId == id || g.NavAnyRequest {
				if g.NavWindow.RootWindowForNav == window.RootWindowForNav {
					if window == g.NavWindow || ((window.ChildFlags | g.NavWindow.ChildFlags) & ImGuiChildFlags_.ImGuiChildFlags_NavFlattened) != {} { NavProcessItem() }
				}
			}
		}

		if (g.NextItemData.HasFlags & ImGuiNextItemDataFlags_.ImGuiNextItemDataFlags_HasShortcut) != {} { ItemHandleShortcut(id) }
	}

	// Lightweight clear of SetNextItemXXX data.
	g.NextItemData.HasFlags = ImGuiNextItemDataFlags_.ImGuiNextItemDataFlags_None
	g.NextItemData.ItemFlags = ImGuiItemFlags_.ImGuiItemFlags_None

	when IMGUI_ENABLE_TEST_ENGINE { /* @gen ifdef */
	if id != 0 { IMGUI_TEST_ENGINE_ITEM_ADD(id, g.LastItemData.NavRect, &g.LastItemData) }
	} // preproc endif

	// Clipping test
	// (this is an inline copy of IsClippedEx() so we can reuse the is_rect_visible value, otherwise we'd do 'if (IsClippedEx(bb, id)) return false')
	// g.NavActivateId is not necessarily == g.NavId, in the case of remote activation (e.g. shortcuts)
	is_rect_visible : bool = Overlaps(bb, window.ClipRect)
	if !is_rect_visible { if id == 0 || (id != g.ActiveId && id != g.ActiveIdPreviousFrame && id != g.NavId && id != g.NavActivateId) { if !g.ItemUnclipByLog { return false } } }

	// [DEBUG]
	when ! IMGUI_DISABLE_DEBUG_TOOLS { /* @gen ifndef */
	if id != 0 {
		if id == g.DebugLocateId { DebugLocateItemResolveWithLastItem() }

		// [DEBUG] People keep stumbling on this problem and using "" as identifier in the root of a window instead of "##something".
		// Empty identifier are valid and useful in a small amount of cases, but 99.9% of the time you want to use "##something".
		// READ THE FAQ: https://dearimgui.com/faq
		IM_ASSERT(id != window.ID, "Cannot have an empty ID at the root of a window. If you need an empty label, use ## and read the FAQ about how the ID Stack works!")
	}
	//if (g.IO.KeyAlt) window->DrawList->AddRect(bb.Min, bb.Max, IM_COL32(255,255,0,120)); // [DEBUG]
	//if ((g.LastItemData.ItemFlags & ImGuiItemFlags_NoNav) == 0)
	//    window->DrawList->AddRect(g.LastItemData.NavRect.Min, g.LastItemData.NavRect.Max, IM_COL32(255,255,0,255)); // [DEBUG]
	} // preproc endif

	// We need to calculate this now to take account of the current clipping rectangle (as items like Selectable may change them)
	if is_rect_visible { g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_.ImGuiItemStatusFlags_Visible }
	if IsMouseHoveringRect(bb.Min, bb.Max) { g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_.ImGuiItemStatusFlags_HoveredRect }
	return true
}


// Basic Helpers for widget code
// FIXME: This is a misleading API since we expect CursorPos to be bb.Min.
//-----------------------------------------------------------------------------
// [SECTION] LAYOUT
//-----------------------------------------------------------------------------
// - ItemSize()
// - SameLine()
// - GetCursorScreenPos()
// - SetCursorScreenPos()
// - GetCursorPos(), GetCursorPosX(), GetCursorPosY()
// - SetCursorPos(), SetCursorPosX(), SetCursorPosY()
// - GetCursorStartPos()
// - Indent()
// - Unindent()
// - SetNextItemWidth()
// - PushItemWidth()
// - PushMultiItemsWidths()
// - PopItemWidth()
// - CalcItemWidth()
// - CalcItemSize()
// - GetTextLineHeight()
// - GetTextLineHeightWithSpacing()
// - GetFrameHeight()
// - GetFrameHeightWithSpacing()
// - GetContentRegionMax()
// - GetContentRegionAvail(),
// - BeginGroup()
// - EndGroup()
// Also see in imgui_widgets: tab bars, and in imgui_tables: tables, columns.
//-----------------------------------------------------------------------------

// Advance cursor given item size for layout.
// Register minimum needed size so it can extend the bounding box used for auto-fit calculation.
// See comments in ItemAdd() about how/why the size provided to ItemSize() vs ItemAdd() may often different.
// THIS IS IN THE PERFORMANCE CRITICAL PATH.

ItemSize_1 :: proc(size : ImVec2, text_baseline_y : f32 = -1)
{
	g : ^ImGuiContext = GImGui
	window : ^ImGuiWindow = g.CurrentWindow
	if window.SkipItems { return }

	// We increase the height in this function to accommodate for baseline offset.
	// In theory we should be offsetting the starting position (window->DC.CursorPos), that will be the topic of a larger refactor,
	// but since ItemSize() is not yet an API that moves the cursor (to handle e.g. wrapping) enlarging the height has the same effect.
	offset_to_match_baseline_y : f32 = (text_baseline_y >= 0) ? ImMax(f32(0.0), window.DC.CurrLineTextBaseOffset - text_baseline_y) : 0.0

	line_y1 : f32 = window.DC.IsSameLine ? window.DC.CursorPosPrevLine.y : window.DC.CursorPos.y
	line_height : f32 = ImMax(window.DC.CurrLineSize.y, window.DC.CursorPos.y - line_y1 + size.y + offset_to_match_baseline_y)

	// Always align ourselves on pixel boundaries
	//if (g.IO.KeyAlt) window->DrawList->AddRect(window->DC.CursorPos, window->DC.CursorPos + ImVec2{size.x, line_height}, IM_COL32(255,0,0,200)); // [DEBUG]
	window.DC.CursorPosPrevLine.x = window.DC.CursorPos.x + size.x
	window.DC.CursorPosPrevLine.y = line_y1
	window.DC.CursorPos.x = IM_TRUNC(window.Pos.x + window.DC.Indent.x + window.DC.ColumnsOffset.x); // Next line
	window.DC.CursorPos.y = IM_TRUNC(line_y1 + line_height + g.Style.ItemSpacing.y); // Next line
	window.DC.CursorMaxPos.x = ImMax(window.DC.CursorMaxPos.x, window.DC.CursorPosPrevLine.x)
	window.DC.CursorMaxPos.y = ImMax(window.DC.CursorMaxPos.y, window.DC.CursorPos.y - g.Style.ItemSpacing.y)
	//if (g.IO.KeyAlt) window->DrawList->AddCircle(window->DC.CursorMaxPos, 3.0f, IM_COL32(255,0,0,255), 4); // [DEBUG]

	window.DC.PrevLineSize.y = line_height
	window.DC.CurrLineSize.y = 0.0
	window.DC.PrevLineTextBaseOffset = ImMax(window.DC.CurrLineTextBaseOffset, text_baseline_y)
	window.DC.CurrLineTextBaseOffset = 0.0
	window.DC.IsSetPos = false; window.DC.IsSameLine = window.DC.IsSetPos

	// Horizontal layout mode
	if window.DC.LayoutType == ImGuiLayoutType_.ImGuiLayoutType_Horizontal { SameLine() }
}


// call between widgets or groups to layout them horizontally. X position given in window coordinates.
// Gets back to previous line and continue with horizontal layout
//      offset_from_start_x == 0 : follow right after previous item
//      offset_from_start_x != 0 : align to specified x position (relative to window/group left)
//      spacing_w < 0            : use default spacing if offset_from_start_x == 0, no spacing if offset_from_start_x != 0
//      spacing_w >= 0           : enforce spacing amount
SameLine :: proc(offset_from_start_x : f32 = 0, spacing_w : f32 = -1)
{
	g : ^ImGuiContext = GImGui
	window : ^ImGuiWindow = g.CurrentWindow
	if window.SkipItems { return }

	spacing_w := spacing_w
	if offset_from_start_x != 0.0 {
		if spacing_w < 0.0 { spacing_w = 0.0 }
		window.DC.CursorPos.x = window.Pos.x - window.Scroll.x + offset_from_start_x + spacing_w + window.DC.GroupOffset.x + window.DC.ColumnsOffset.x
		window.DC.CursorPos.y = window.DC.CursorPosPrevLine.y
	}
	else {
		if spacing_w < 0.0 { spacing_w = g.Style.ItemSpacing.x }
		window.DC.CursorPos.x = window.DC.CursorPosPrevLine.x + spacing_w
		window.DC.CursorPos.y = window.DC.CursorPosPrevLine.y
	}
	window.DC.CurrLineSize = window.DC.PrevLineSize
	window.DC.CurrLineTextBaseOffset = window.DC.PrevLineTextBaseOffset
	window.DC.IsSameLine = true
}

// Layout cursor positioning
// - By "cursor" we mean the current output position.
// - The typical widget behavior is to output themselves at the current cursor position, then move the cursor one line down.
// - You can call SameLine() between widgets to undo the last carriage return and output at the right of the preceding widget.
// - YOU CAN DO 99% OF WHAT YOU NEED WITH ONLY GetCursorScreenPos() and GetContentRegionAvail().
// - Attention! We currently have inconsistencies between window-local and absolute positions we will aim to fix with future API:
//    - Absolute coordinate:        GetCursorScreenPos(), SetCursorScreenPos(), all ImDrawList:: functions. -> this is the preferred way forward.
//    - Window-local coordinates:   SameLine(offset), GetCursorPos(), SetCursorPos(), GetCursorStartPos(), PushTextWrapPos()
//    - Window-local coordinates:   GetContentRegionMax(), GetWindowContentRegionMin(), GetWindowContentRegionMax() --> all obsoleted. YOU DON'T NEED THEM.
// - GetCursorScreenPos() = GetCursorPos() + GetWindowPos(). GetWindowPos() is almost only ever useful to convert from window-local to absolute coordinates. Try not to use it.
// cursor position, absolute coordinates. THIS IS YOUR BEST FRIEND (prefer using this rather than GetCursorPos(), also more useful to work with ImDrawList API).
GetCursorScreenPos :: proc() -> ImVec2
{
	window : ^ImGuiWindow = GetCurrentWindowRead()
	return window.DC.CursorPos
}

// cursor position, absolute coordinates. THIS IS YOUR BEST FRIEND.
SetCursorScreenPos :: proc(pos : ImVec2)
{
	window : ^ImGuiWindow = GetCurrentWindow()
	window.DC.CursorPos = pos
	//window->DC.CursorMaxPos = ImMax(window->DC.CursorMaxPos, window->DC.CursorPos);
	window.DC.IsSetPos = true
}

// [window-local] cursor position in window-local coordinates. This is not your best friend.
// User generally sees positions in window coordinates. Internally we store CursorPos in absolute screen coordinates because it is more convenient.
// Conversion happens as we pass the value to user, but it makes our naming convention confusing because GetCursorPos() == (DC.CursorPos - window.Pos). May want to rename 'DC.CursorPos'.
GetCursorPos :: proc() -> ImVec2
{
	window : ^ImGuiWindow = GetCurrentWindowRead()
	return window.DC.CursorPos - window.Pos + window.Scroll
}

GetCursorPosX :: proc() -> f32
{
	window : ^ImGuiWindow = GetCurrentWindowRead()
	return window.DC.CursorPos.x - window.Pos.x + window.Scroll.x
}

GetCursorPosY :: proc() -> f32
{
	window : ^ImGuiWindow = GetCurrentWindowRead()
	return window.DC.CursorPos.y - window.Pos.y + window.Scroll.y
}

SetCursorPos :: proc(local_pos : ImVec2)
{
	window : ^ImGuiWindow = GetCurrentWindow()
	window.DC.CursorPos = window.Pos - window.Scroll + local_pos
	//window->DC.CursorMaxPos = ImMax(window->DC.CursorMaxPos, window->DC.CursorPos);
	window.DC.IsSetPos = true
}

SetCursorPosX :: proc(x : f32)
{
	window : ^ImGuiWindow = GetCurrentWindow()
	window.DC.CursorPos.x = window.Pos.x - window.Scroll.x + x
	//window->DC.CursorMaxPos.x = ImMax(window->DC.CursorMaxPos.x, window->DC.CursorPos.x);
	window.DC.IsSetPos = true
}

SetCursorPosY :: proc(y : f32)
{
	window : ^ImGuiWindow = GetCurrentWindow()
	window.DC.CursorPos.y = window.Pos.y - window.Scroll.y + y
	//window->DC.CursorMaxPos.y = ImMax(window->DC.CursorMaxPos.y, window->DC.CursorPos.y);
	window.DC.IsSetPos = true
}

// [window-local] initial cursor position, in window-local coordinates. Call GetCursorScreenPos() after Begin() to get the absolute coordinates version.
GetCursorStartPos :: proc() -> ImVec2
{
	window : ^ImGuiWindow = GetCurrentWindowRead()
	return window.DC.CursorStartPos - window.Pos
}

// move content position toward the right, by indent_w, or style.IndentSpacing if indent_w <= 0
Indent :: proc(indent_w : f32 = 0)
{
	g : ^ImGuiContext = GImGui
	window : ^ImGuiWindow = GetCurrentWindow()
	window.DC.Indent.x += (indent_w != 0.0) ? indent_w : g.Style.IndentSpacing
	window.DC.CursorPos.x = window.Pos.x + window.DC.Indent.x + window.DC.ColumnsOffset.x
}

// move content position back to the left, by indent_w, or style.IndentSpacing if indent_w <= 0
Unindent :: proc(indent_w : f32 = 0)
{
	g : ^ImGuiContext = GImGui
	window : ^ImGuiWindow = GetCurrentWindow()
	window.DC.Indent.x -= (indent_w != 0.0) ? indent_w : g.Style.IndentSpacing
	window.DC.CursorPos.x = window.Pos.x + window.DC.Indent.x + window.DC.ColumnsOffset.x
}

// set width of the _next_ common large "item+label" widget. >0.0f: width in pixels, <0.0f align xx pixels to the right of window (so -FLT_MIN always align width to the right side)
// Affect large frame+labels widgets only.
SetNextItemWidth :: proc(item_width : f32)
{
	g : ^ImGuiContext = GImGui
	g.NextItemData.HasFlags |= ImGuiNextItemDataFlags_.ImGuiNextItemDataFlags_HasWidth
	g.NextItemData.Width = item_width
}

// Parameters stacks (current window)
// push width of items for common large "item+label" widgets. >0.0f: width in pixels, <0.0f align xx pixels to the right of window (so -FLT_MIN always align width to the right side).
// FIXME: Remove the == 0.0f behavior?
PushItemWidth :: proc(item_width : f32)
{
	g : ^ImGuiContext = GImGui
	window : ^ImGuiWindow = g.CurrentWindow
	push_back(&window.DC.ItemWidthStack, window.DC.ItemWidth); // Backup current width
	window.DC.ItemWidth = (item_width == 0.0 ? window.ItemWidthDefault : item_width)
	g.NextItemData.HasFlags &= cast(ImGuiNextItemDataFlags)~cast(i32)ImGuiNextItemDataFlags_.ImGuiNextItemDataFlags_HasWidth
}

PushMultiItemsWidths :: proc(components : i32, w_full : f32)
{
	g : ^ImGuiContext = GImGui
	window : ^ImGuiWindow = g.CurrentWindow
	IM_ASSERT(components > 0)
	style : ^ImGuiStyle = &g.Style
	push_back(&window.DC.ItemWidthStack, window.DC.ItemWidth); // Backup current width
	w_items : f32 = w_full - style.ItemInnerSpacing.x * f32(components - 1)
	prev_split : f32 = w_items
	for i : i32 = components - 1; i > 0; i -= 1 {
		next_split : f32 = IM_TRUNC(w_items * f32(i) / f32(components))
		push_back(&window.DC.ItemWidthStack, ImMax(prev_split - next_split, 1.0))
		prev_split = next_split
	}

	window.DC.ItemWidth = ImMax(prev_split, 1.0)
	g.NextItemData.HasFlags &= cast(ImGuiNextItemDataFlags)~cast(i32)ImGuiNextItemDataFlags_.ImGuiNextItemDataFlags_HasWidth
}

PopItemWidth :: proc()
{
	g : ^ImGuiContext = GImGui
	window : ^ImGuiWindow = g.CurrentWindow
	if window.DC.ItemWidthStack.Size <= 0 {
		IM_ASSERT_USER_ERROR(false, "Calling PopItemWidth() too many times!")
		return
	}
	window.DC.ItemWidth = back(&window.DC.ItemWidthStack)^
	pop_back(&window.DC.ItemWidthStack)
}

// width of item given pushed settings and current cursor position. NOT necessarily the width of last item unlike most 'Item' functions.
// Calculate default item width given value passed to PushItemWidth() or SetNextItemWidth().
// The SetNextItemWidth() data is generally cleared/consumed by ItemAdd() or NextItemData.ClearFlags()
CalcItemWidth :: proc() -> f32
{
	g : ^ImGuiContext = GImGui
	window : ^ImGuiWindow = g.CurrentWindow
	w : f32
	if (g.NextItemData.HasFlags & ImGuiNextItemDataFlags_.ImGuiNextItemDataFlags_HasWidth) != {} { w = g.NextItemData.Width }
	else { w = window.DC.ItemWidth }
	if w < 0.0 {
		region_avail_x : f32 = GetContentRegionAvail().x
		w = ImMax(f32(1.0), region_avail_x + w)
	}
	w = IM_TRUNC(w)
	return w
}

// [Internal] Calculate full item size given user provided 'size' parameter and default width/height. Default width is often == CalcItemWidth().
// Those two functions CalcItemWidth vs CalcItemSize are awkwardly named because they are not fully symmetrical.
// Note that only CalcItemWidth() is publicly exposed.
// The 4.0f here may be changed to match CalcItemWidth() and/or BeginChild() (right now we have a mismatch which is harmless but undesirable)
CalcItemSize :: proc(size : ImVec2, default_w : f32, default_h : f32) -> ImVec2
{
	avail : ImVec2
	if size.x < 0.0 || size.y < 0.0 { avail = GetContentRegionAvail() }

	size := size
	if size.x == 0.0 { size.x = default_w }
	else if size.x < 0.0 {
		// <-- size.x is negative here so we are subtracting
		size.x = ImMax(f32(4.0), avail.x + size.x)
	}

	if size.y == 0.0 { size.y = default_h }
	else if size.y < 0.0 {
		// <-- size.y is negative here so we are subtracting
		size.y = ImMax(f32(4.0), avail.y + size.y)
	}

	return size
}

// ~ FontSize
GetTextLineHeight :: proc() -> f32
{
	g : ^ImGuiContext = GImGui
	return g.FontSize
}

// ~ FontSize + style.ItemSpacing.y (distance in pixels between 2 consecutive lines of text)
GetTextLineHeightWithSpacing :: proc() -> f32
{
	g : ^ImGuiContext = GImGui
	return g.FontSize + g.Style.ItemSpacing.y
}

// ~ FontSize + style.FramePadding.y * 2
GetFrameHeight :: proc() -> f32
{
	g : ^ImGuiContext = GImGui
	return g.FontSize + g.Style.FramePadding.y * 2.0
}

// ~ FontSize + style.FramePadding.y * 2 + style.ItemSpacing.y (distance in pixels between 2 consecutive lines of framed widgets)
GetFrameHeightWithSpacing :: proc() -> f32
{
	g : ^ImGuiContext = GImGui
	return g.FontSize + g.Style.FramePadding.y * 2.0 + g.Style.ItemSpacing.y
}

// available space from current position. THIS IS YOUR BEST FRIEND.
GetContentRegionAvail :: proc() -> ImVec2
{
	g : ^ImGuiContext = GImGui
	window : ^ImGuiWindow = g.CurrentWindow
	mx : ImVec2 = (window.DC.CurrentColumns != nil || g.CurrentTable != nil) ? window.WorkRect.Max : window.ContentRegionRect.Max
	return mx - window.DC.CursorPos
}



// Lock horizontal starting position + capture group bounding box into one "item" (so you can use IsItemHovered() or layout primitives such as SameLine() on whole group, etc.)
// Groups are currently a mishmash of functionalities which should perhaps be clarified and separated.
// FIXME-OPT: Could we safely early out on ->SkipItems?
BeginGroup :: proc()
{
	g : ^ImGuiContext = GImGui
	window : ^ImGuiWindow = g.CurrentWindow

	resize(&g.GroupStack, g.GroupStack.Size + 1)
	group_data : ^ImGuiGroupData = back(&g.GroupStack)
	group_data.WindowID = window.ID
	group_data.BackupCursorPos = window.DC.CursorPos
	group_data.BackupCursorPosPrevLine = window.DC.CursorPosPrevLine
	group_data.BackupCursorMaxPos = window.DC.CursorMaxPos
	group_data.BackupIndent = window.DC.Indent
	group_data.BackupGroupOffset = window.DC.GroupOffset
	group_data.BackupCurrLineSize = window.DC.CurrLineSize
	group_data.BackupCurrLineTextBaseOffset = window.DC.CurrLineTextBaseOffset
	group_data.BackupActiveIdIsAlive = g.ActiveIdIsAlive
	group_data.BackupHoveredIdIsAlive = g.HoveredId != 0
	group_data.BackupIsSameLine = window.DC.IsSameLine
	group_data.BackupActiveIdPreviousFrameIsAlive = g.ActiveIdPreviousFrameIsAlive
	group_data.EmitItem = true

	window.DC.GroupOffset.x = window.DC.CursorPos.x - window.Pos.x - window.DC.ColumnsOffset.x
	window.DC.Indent = window.DC.GroupOffset
	window.DC.CursorMaxPos = window.DC.CursorPos
	window.DC.CurrLineSize = ImVec2{0.0, 0.0}
	if g.LogEnabled {
		// To enforce a carriage return
		g.LogLinePosY = -FLT_MAX
	}
}

// unlock horizontal starting position + capture the whole group bounding box into one "item" (so you can use IsItemHovered() or layout primitives such as SameLine() on whole group, etc.)
EndGroup :: proc()
{
	g : ^ImGuiContext = GImGui
	window : ^ImGuiWindow = g.CurrentWindow
	IM_ASSERT(g.GroupStack.Size > 0); // Mismatched BeginGroup()/EndGroup() calls

	group_data : ^ImGuiGroupData = back(&g.GroupStack)
	IM_ASSERT(group_data.WindowID == window.ID); // EndGroup() in wrong window?

	if window.DC.IsSetPos { ErrorCheckUsingSetCursorPosToExtendParentBoundaries() }

	// Include LastItemData.Rect.Max as a workaround for e.g. EndTable() undershooting with CursorMaxPos report. (#7543)
	group_bb : ImRect; init(&group_bb, group_data.BackupCursorPos, ImMax(ImMax(window.DC.CursorMaxPos, g.LastItemData.Rect.Max), group_data.BackupCursorPos))
	window.DC.CursorPos = group_data.BackupCursorPos
	window.DC.CursorPosPrevLine = group_data.BackupCursorPosPrevLine
	window.DC.CursorMaxPos = ImMax(group_data.BackupCursorMaxPos, group_bb.Max)
	window.DC.Indent = group_data.BackupIndent
	window.DC.GroupOffset = group_data.BackupGroupOffset
	window.DC.CurrLineSize = group_data.BackupCurrLineSize
	window.DC.CurrLineTextBaseOffset = group_data.BackupCurrLineTextBaseOffset
	window.DC.IsSameLine = group_data.BackupIsSameLine
	if g.LogEnabled {
		// To enforce a carriage return
		g.LogLinePosY = -FLT_MAX
	}

	if !group_data.EmitItem {
		pop_back(&g.GroupStack)
		return
	}

	window.DC.CurrLineTextBaseOffset = ImMax(window.DC.PrevLineTextBaseOffset, group_data.BackupCurrLineTextBaseOffset); // FIXME: Incorrect, we should grab the base offset from the *first line* of the group but it is hard to obtain now.
	ItemSize(GetSize(group_bb))
	ItemAdd(group_bb, 0, nil, ImGuiItemFlags_.ImGuiItemFlags_NoTabStop)

	// If the current ActiveId was declared within the boundary of our group, we copy it to LastItemId so IsItemActive(), IsItemDeactivated() etc. will be functional on the entire group.
	// It would be neater if we replaced window.DC.LastItemId by e.g. 'bool LastItemIsActive', but would put a little more burden on individual widgets.
	// Also if you grep for LastItemId you'll notice it is only used in that context.
	// (The two tests not the same because ActiveIdIsAlive is an ID itself, in order to be able to handle ActiveId being overwritten during the frame.)
	group_contains_curr_active_id : bool = (group_data.BackupActiveIdIsAlive != g.ActiveId) && (g.ActiveIdIsAlive == g.ActiveId) && g.ActiveId != 0
	group_contains_prev_active_id : bool = (group_data.BackupActiveIdPreviousFrameIsAlive == false) && (g.ActiveIdPreviousFrameIsAlive == true)
	if group_contains_curr_active_id { g.LastItemData.ID = g.ActiveId }
	else if group_contains_prev_active_id { g.LastItemData.ID = g.ActiveIdPreviousFrame }
	g.LastItemData.Rect = group_bb

	// Forward Hovered flag
	group_contains_curr_hovered_id : bool = (group_data.BackupHoveredIdIsAlive == false) && g.HoveredId != 0
	if group_contains_curr_hovered_id { g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_.ImGuiItemStatusFlags_HoveredWindow }

	// Forward Edited flag
	if group_contains_curr_active_id && g.ActiveIdHasBeenEditedThisFrame { g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_.ImGuiItemStatusFlags_Edited }

	// Forward Deactivated flag
	g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_.ImGuiItemStatusFlags_HasDeactivated
	if group_contains_prev_active_id && g.ActiveId != g.ActiveIdPreviousFrame { g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_.ImGuiItemStatusFlags_Deactivated }

	pop_back(&g.GroupStack)
	if g.DebugShowGroupRects {
		// [Debug]
		AddRect(window.DrawList, group_bb.Min, group_bb.Max, IM_COL32(255, 0, 255, 255))
	}
}


//-----------------------------------------------------------------------------
// [SECTION] SCROLLING
//-----------------------------------------------------------------------------

// Helper to snap on edges when aiming at an item very close to the edge,
// So the difference between WindowPadding and ItemSpacing will be in the visible area after scrolling.
// When we refactor the scrolling API this may be configurable with a flag?
// Note that the effect for this won't be visible on X axis with default Style settings as WindowPadding.x == ItemSpacing.x by default.
CalcScrollEdgeSnap :: proc(target : f32, snap_min : f32, snap_max : f32, snap_threshold : f32, center_ratio : f32) -> f32
{
	if target <= snap_min + snap_threshold { return ImLerp(snap_min, target, center_ratio) }
	if target >= snap_max - snap_threshold { return ImLerp(target, snap_max, center_ratio) }
	return target
}

CalcNextScrollFromScrollTargetAndClamp :: proc(window : ^ImGuiWindow) -> ImVec2
{
	scroll : ImVec2 = window.Scroll
	decoration_size := ImVec2{ window.DecoOuterSizeX1 + window.DecoInnerSizeX1 + window.DecoOuterSizeX2, window.DecoOuterSizeY1 + window.DecoInnerSizeY1 + window.DecoOuterSizeY2 }
	for axis : i32 = 0; axis < 2; axis += 1 {
		if window.ScrollTarget[axis] < FLT_MAX {
			center_ratio : f32 = window.ScrollTargetCenterRatio[axis]
			scroll_target : f32 = window.ScrollTarget[axis]
			if window.ScrollTargetEdgeSnapDist[axis] > 0.0 {
				snap_min : f32 = 0.0
				snap_max : f32 = window.ScrollMax[axis] + window.SizeFull[axis] - decoration_size[axis]
				scroll_target = CalcScrollEdgeSnap(scroll_target, snap_min, snap_max, window.ScrollTargetEdgeSnapDist[axis], center_ratio)
			}
			scroll[axis] = scroll_target - center_ratio * (window.SizeFull[axis] - decoration_size[axis])
		}
		scroll[axis] = IM_ROUND(ImMax(scroll[axis], 0.0))
		if !window.Collapsed && !window.SkipItems { scroll[axis] = ImMin(scroll[axis], window.ScrollMax[axis]) }
	}

	return scroll
}

// Early work-in-progress API (ScrollToItem() will become public)
ScrollToItem :: proc(flags : ImGuiScrollFlags)
{
	g : ^ImGuiContext = GImGui
	window : ^ImGuiWindow = g.CurrentWindow
	ScrollToRectEx(window, g.LastItemData.NavRect, flags)
}

ScrollToRect :: proc(window : ^ImGuiWindow, item_rect : ImRect, flags : ImGuiScrollFlags = {})
{
	ScrollToRectEx(window, item_rect, flags)
}

// Scroll to keep newly navigated item fully into view
ScrollToRectEx :: proc(window : ^ImGuiWindow, item_rect : ImRect, flags : ImGuiScrollFlags = {}) -> ImVec2
{
	g : ^ImGuiContext = GImGui
	scroll_rect : ImRect; init(&scroll_rect, window.InnerRect.Min - ImVec2{1, 1}, window.InnerRect.Max + ImVec2{1, 1})
	scroll_rect.Min.x = ImMin(scroll_rect.Min.x + window.DecoInnerSizeX1, scroll_rect.Max.x)
	scroll_rect.Min.y = ImMin(scroll_rect.Min.y + window.DecoInnerSizeY1, scroll_rect.Max.y)
	//GetForegroundDrawList(window)->AddRect(item_rect.Min, item_rect.Max, IM_COL32(255,0,0,255), 0.0f, 0, 5.0f); // [DEBUG]
	//GetForegroundDrawList(window)->AddRect(scroll_rect.Min, scroll_rect.Max, IM_COL32_WHITE); // [DEBUG]

	// Check that only one behavior is selected per axis
	IM_ASSERT((flags & ImGuiScrollFlags_.ImGuiScrollFlags_MaskX_) == {} || ImIsPowerOfTwo(u32(flags & ImGuiScrollFlags_.ImGuiScrollFlags_MaskX_)))
	IM_ASSERT((flags & ImGuiScrollFlags_.ImGuiScrollFlags_MaskY_) == {} || ImIsPowerOfTwo(u32(flags & ImGuiScrollFlags_.ImGuiScrollFlags_MaskY_)))

	// Defaults
	in_flags : ImGuiScrollFlags = flags
	flags := flags
	if (flags & ImGuiScrollFlags_.ImGuiScrollFlags_MaskX_) == {} && window.ScrollbarX { flags |= ImGuiScrollFlags_.ImGuiScrollFlags_KeepVisibleEdgeX }
	if (flags & ImGuiScrollFlags_.ImGuiScrollFlags_MaskY_) == {} { flags |= window.Appearing ? ImGuiScrollFlags_.ImGuiScrollFlags_AlwaysCenterY : ImGuiScrollFlags_.ImGuiScrollFlags_KeepVisibleEdgeY }

	fully_visible_x : bool = item_rect.Min.x >= scroll_rect.Min.x && item_rect.Max.x <= scroll_rect.Max.x
	fully_visible_y : bool = item_rect.Min.y >= scroll_rect.Min.y && item_rect.Max.y <= scroll_rect.Max.y
	can_be_fully_visible_x : bool = (GetWidth(item_rect) + g.Style.ItemSpacing.x * 2.0) <= GetWidth(scroll_rect) || (window.AutoFitFramesX > 0) || (window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_AlwaysAutoResize) != {}
	can_be_fully_visible_y : bool = (GetHeight(item_rect) + g.Style.ItemSpacing.y * 2.0) <= GetHeight(scroll_rect) || (window.AutoFitFramesY > 0) || (window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_AlwaysAutoResize) != {}

	if (flags & ImGuiScrollFlags_.ImGuiScrollFlags_KeepVisibleEdgeX) == {} && !fully_visible_x {
		if item_rect.Min.x < scroll_rect.Min.x || !can_be_fully_visible_x { SetScrollFromPosX(window, item_rect.Min.x - g.Style.ItemSpacing.x - window.Pos.x, 0.0) }
		else if item_rect.Max.x >= scroll_rect.Max.x { SetScrollFromPosX(window, item_rect.Max.x + g.Style.ItemSpacing.x - window.Pos.x, 1.0) }
	}
	else if ((flags & ImGuiScrollFlags_.ImGuiScrollFlags_KeepVisibleCenterX) == {} && !fully_visible_x) || (flags & ImGuiScrollFlags_.ImGuiScrollFlags_AlwaysCenterX) != {} {
		if can_be_fully_visible_x { SetScrollFromPosX(window, ImTrunc((item_rect.Min.x + item_rect.Max.x) * 0.5) - window.Pos.x, 0.5) }
		else { SetScrollFromPosX(window, item_rect.Min.x - window.Pos.x, 0.0) }
	}

	if (flags & ImGuiScrollFlags_.ImGuiScrollFlags_KeepVisibleEdgeY) == {} && !fully_visible_y {
		if item_rect.Min.y < scroll_rect.Min.y || !can_be_fully_visible_y { SetScrollFromPosY(window, item_rect.Min.y - g.Style.ItemSpacing.y - window.Pos.y, 0.0) }
		else if item_rect.Max.y >= scroll_rect.Max.y { SetScrollFromPosY(window, item_rect.Max.y + g.Style.ItemSpacing.y - window.Pos.y, 1.0) }
	}
	else if ((flags & ImGuiScrollFlags_.ImGuiScrollFlags_KeepVisibleCenterY) == {} && !fully_visible_y) || (flags & ImGuiScrollFlags_.ImGuiScrollFlags_AlwaysCenterY) != {} {
		if can_be_fully_visible_y { SetScrollFromPosY(window, ImTrunc((item_rect.Min.y + item_rect.Max.y) * 0.5) - window.Pos.y, 0.5) }
		else { SetScrollFromPosY(window, item_rect.Min.y - window.Pos.y, 0.0) }
	}

	next_scroll : ImVec2 = CalcNextScrollFromScrollTargetAndClamp(window)
	delta_scroll : ImVec2 = next_scroll - window.Scroll

	// Also scroll parent window to keep us into view if necessary
	if (flags & ImGuiScrollFlags_.ImGuiScrollFlags_NoScrollParent) == {} && (window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_ChildWindow) == {} {
		// FIXME-SCROLL: May be an option?
		if (in_flags & (ImGuiScrollFlags_.ImGuiScrollFlags_AlwaysCenterX | ImGuiScrollFlags_.ImGuiScrollFlags_KeepVisibleCenterX)) != {} { in_flags = (in_flags & cast(ImGuiScrollFlags) ~cast(i32)ImGuiScrollFlags_.ImGuiScrollFlags_MaskX_) | ImGuiScrollFlags_.ImGuiScrollFlags_KeepVisibleEdgeX }
		if (in_flags & (ImGuiScrollFlags_.ImGuiScrollFlags_AlwaysCenterY | ImGuiScrollFlags_.ImGuiScrollFlags_KeepVisibleCenterY)) != {} { in_flags = (in_flags & cast(ImGuiScrollFlags) ~cast(i32)ImGuiScrollFlags_.ImGuiScrollFlags_MaskY_) | ImGuiScrollFlags_.ImGuiScrollFlags_KeepVisibleEdgeY }
		delta_scroll += ScrollToRectEx(window.ParentWindow, ImRect{item_rect.Min - delta_scroll, item_rect.Max - delta_scroll}, in_flags)
	}

	return delta_scroll
}

// Windows Scrolling
// - Any change of Scroll will be applied at the beginning of next frame in the first call to Begin().
// - You may instead use SetNextWindowScroll() prior to calling Begin() to avoid this delay, as an alternative to using SetScrollX()/SetScrollY().
// get scrolling amount [0 .. GetScrollMaxX()]
GetScrollX :: proc() -> f32
{
	window : ^ImGuiWindow = GImGui.CurrentWindow
	return window.Scroll.x
}

// get scrolling amount [0 .. GetScrollMaxY()]
GetScrollY :: proc() -> f32
{
	window : ^ImGuiWindow = GImGui.CurrentWindow
	return window.Scroll.y
}

// get maximum scrolling amount ~~ ContentSize.x - WindowSize.x - DecorationsSize.x
GetScrollMaxX :: proc() -> f32
{
	window : ^ImGuiWindow = GImGui.CurrentWindow
	return window.ScrollMax.x
}

// get maximum scrolling amount ~~ ContentSize.y - WindowSize.y - DecorationsSize.y
GetScrollMaxY :: proc() -> f32
{
	window : ^ImGuiWindow = GImGui.CurrentWindow
	return window.ScrollMax.y
}

// set scrolling amount [0 .. GetScrollMaxX()]
// Scrolling
SetScrollX_0 :: proc(window : ^ImGuiWindow, scroll_x : f32)
{
	window.ScrollTarget.x = scroll_x
	window.ScrollTargetCenterRatio.x = 0.0
	window.ScrollTargetEdgeSnapDist.x = 0.0
}

// set scrolling amount [0 .. GetScrollMaxY()]
SetScrollY_0 :: proc(window : ^ImGuiWindow, scroll_y : f32)
{
	window.ScrollTarget.y = scroll_y
	window.ScrollTargetCenterRatio.y = 0.0
	window.ScrollTargetEdgeSnapDist.y = 0.0
}

// set scrolling amount [0 .. GetScrollMaxX()]
// Scrolling
SetScrollX_1 :: proc(scroll_x : f32)
{
	g : ^ImGuiContext = GImGui
	SetScrollX(g.CurrentWindow, scroll_x)
}

// set scrolling amount [0 .. GetScrollMaxY()]
SetScrollY_1 :: proc(scroll_y : f32)
{
	g : ^ImGuiContext = GImGui
	SetScrollY(g.CurrentWindow, scroll_y)
}

// adjust scrolling amount to make given position visible. Generally GetCursorStartPos() + offset to compute a valid position.
// Note that a local position will vary depending on initial scroll value,
// This is a little bit confusing so bear with us:
//  - local_pos = (absolution_pos - window->Pos)
//  - So local_x/local_y are 0.0f for a position at the upper-left corner of a window,
//    and generally local_x/local_y are >(padding+decoration) && <(size-padding-decoration) when in the visible area.
//  - They mostly exist because of legacy API.
// Following the rules above, when trying to work with scrolling code, consider that:
//  - SetScrollFromPosY(0.0f) == SetScrollY(0.0f + scroll.y) == has no effect!
//  - SetScrollFromPosY(-scroll.y) == SetScrollY(-scroll.y + scroll.y) == SetScrollY(0.0f) == reset scroll. Of course writing SetScrollY(0.0f) directly then makes more sense
// We store a target position so centering and clamping can occur on the next frame when we are guaranteed to have a known window size
SetScrollFromPosX_0 :: proc(window : ^ImGuiWindow, local_x : f32, center_x_ratio : f32)
{
	IM_ASSERT(center_x_ratio >= 0.0 && center_x_ratio <= 1.0)
	window.ScrollTarget.x = IM_TRUNC(local_x - window.DecoOuterSizeX1 - window.DecoInnerSizeX1 + window.Scroll.x); // Convert local position to scroll offset
	window.ScrollTargetCenterRatio.x = center_x_ratio
	window.ScrollTargetEdgeSnapDist.x = 0.0
}

// adjust scrolling amount to make given position visible. Generally GetCursorStartPos() + offset to compute a valid position.
SetScrollFromPosY_0 :: proc(window : ^ImGuiWindow, local_y : f32, center_y_ratio : f32)
{
	IM_ASSERT(center_y_ratio >= 0.0 && center_y_ratio <= 1.0)
	window.ScrollTarget.y = IM_TRUNC(local_y - window.DecoOuterSizeY1 - window.DecoInnerSizeY1 + window.Scroll.y); // Convert local position to scroll offset
	window.ScrollTargetCenterRatio.y = center_y_ratio
	window.ScrollTargetEdgeSnapDist.y = 0.0
}

// adjust scrolling amount to make given position visible. Generally GetCursorStartPos() + offset to compute a valid position.
SetScrollFromPosX_1 :: proc(local_x : f32, center_x_ratio : f32)
{
	g : ^ImGuiContext = GImGui
	SetScrollFromPosX(g.CurrentWindow, local_x, center_x_ratio)
}

// adjust scrolling amount to make given position visible. Generally GetCursorStartPos() + offset to compute a valid position.
SetScrollFromPosY_1 :: proc(local_y : f32, center_y_ratio : f32)
{
	g : ^ImGuiContext = GImGui
	SetScrollFromPosY(g.CurrentWindow, local_y, center_y_ratio)
}

// adjust scrolling amount to make current cursor position visible. center_x_ratio=0.0: left, 0.5: center, 1.0: right. When using to make a "default/current item" visible, consider using SetItemDefaultFocus() instead.
// center_x_ratio: 0.0f left of last item, 0.5f horizontal center of last item, 1.0f right of last item.
SetScrollHereX :: proc(center_x_ratio : f32)
{
	g : ^ImGuiContext = GImGui
	window : ^ImGuiWindow = g.CurrentWindow
	spacing_x : f32 = ImMax(window.WindowPadding.x, g.Style.ItemSpacing.x)
	target_pos_x : f32 = ImLerp(g.LastItemData.Rect.Min.x - spacing_x, g.LastItemData.Rect.Max.x + spacing_x, center_x_ratio)
	SetScrollFromPosX(window, target_pos_x - window.Pos.x, center_x_ratio); // Convert from absolute to local pos

	// Tweak: snap on edges when aiming at an item very close to the edge
	window.ScrollTargetEdgeSnapDist.x = ImMax(f32(0.0), window.WindowPadding.x - spacing_x)
}

// adjust scrolling amount to make current cursor position visible. center_y_ratio=0.0: top, 0.5: center, 1.0: bottom. When using to make a "default/current item" visible, consider using SetItemDefaultFocus() instead.
// center_y_ratio: 0.0f top of last item, 0.5f vertical center of last item, 1.0f bottom of last item.
SetScrollHereY :: proc(center_y_ratio : f32)
{
	g : ^ImGuiContext = GImGui
	window : ^ImGuiWindow = g.CurrentWindow
	spacing_y : f32 = ImMax(window.WindowPadding.y, g.Style.ItemSpacing.y)
	target_pos_y : f32 = ImLerp(window.DC.CursorPosPrevLine.y - spacing_y, window.DC.CursorPosPrevLine.y + window.DC.PrevLineSize.y + spacing_y, center_y_ratio)
	SetScrollFromPosY(window, target_pos_y - window.Pos.y, center_y_ratio); // Convert from absolute to local pos

	// Tweak: snap on edges when aiming at an item very close to the edge
	window.ScrollTargetEdgeSnapDist.y = ImMax(f32(0.0), window.WindowPadding.y - spacing_y)
}

// Tooltips
// - Tooltips are windows following the mouse. They do not take focus away.
// - A tooltip window can contain items of any types.
// - SetTooltip() is more or less a shortcut for the 'if (BeginTooltip()) { Text(...); EndTooltip(); }' idiom (with a subtlety that it discard any previously submitted tooltip)
// begin/append a tooltip window.
//-----------------------------------------------------------------------------
// [SECTION] TOOLTIPS
//-----------------------------------------------------------------------------

BeginTooltip :: proc() -> bool
{
	return BeginTooltipEx(ImGuiTooltipFlags_.ImGuiTooltipFlags_None, ImGuiWindowFlags_.ImGuiWindowFlags_None)
}

// Tooltips: helpers for showing a tooltip when hovering an item
// - BeginItemTooltip() is a shortcut for the 'if (IsItemHovered(ImGuiHoveredFlags_ForTooltip) && BeginTooltip())' idiom.
// - SetItemTooltip() is a shortcut for the 'if (IsItemHovered(ImGuiHoveredFlags_ForTooltip)) { SetTooltip(...); }' idiom.
// - Where 'ImGuiHoveredFlags_ForTooltip' itself is a shortcut to use 'style.HoverFlagsForTooltipMouse' or 'style.HoverFlagsForTooltipNav' depending on active input type. For mouse it defaults to 'ImGuiHoveredFlags_Stationary | ImGuiHoveredFlags_DelayShort'.
// begin/append a tooltip window if preceding item was hovered.
BeginItemTooltip :: proc() -> bool
{
	if !IsItemHovered(ImGuiHoveredFlags_.ImGuiHoveredFlags_ForTooltip) { return false }
	return BeginTooltipEx(ImGuiTooltipFlags_.ImGuiTooltipFlags_None, ImGuiWindowFlags_.ImGuiWindowFlags_None)
}

// Tooltips
BeginTooltipEx :: proc(tooltip_flags : ImGuiTooltipFlags, extra_window_flags : ImGuiWindowFlags) -> bool
{
	g : ^ImGuiContext = GImGui
	tooltip_flags := tooltip_flags

	is_dragdrop_tooltip : bool = g.DragDropWithinSource || g.DragDropWithinTarget
	if is_dragdrop_tooltip {
		// Drag and Drop tooltips are positioning differently than other tooltips:
		// - offset visibility to increase visibility around mouse.
		// - never clamp within outer viewport boundary.
		// We call SetNextWindowPos() to enforce position and disable clamping.
		// See FindBestWindowPosForPopup() for positionning logic of other tooltips (not drag and drop ones).
		//ImVec2 tooltip_pos = g.IO.MousePos - g.ActiveIdClickOffset - g.Style.WindowPadding;
		is_touchscreen : bool = (g.IO.MouseSource == ImGuiMouseSource.ImGuiMouseSource_TouchScreen)
		if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_.ImGuiNextWindowDataFlags_HasPos) == {} {
			tooltip_pos : ImVec2 = is_touchscreen ? (g.IO.MousePos + TOOLTIP_DEFAULT_OFFSET_TOUCH * g.Style.MouseCursorScale) : (g.IO.MousePos + TOOLTIP_DEFAULT_OFFSET_MOUSE * g.Style.MouseCursorScale)
			tooltip_pivot : ImVec2 = is_touchscreen ? TOOLTIP_DEFAULT_PIVOT_TOUCH : ImVec2{0.0, 0.0}
			SetNextWindowPos(tooltip_pos, ImGuiCond_.ImGuiCond_None, tooltip_pivot)
		}

		SetNextWindowBgAlpha(g.Style.Colors[ImGuiCol_.ImGuiCol_PopupBg].w * 0.60)
		//PushStyleVar(ImGuiStyleVar_Alpha, g.Style.Alpha * 0.60f); // This would be nice but e.g ColorButton with checkboard has issue with transparent colors :(
		tooltip_flags |= ImGuiTooltipFlags_.ImGuiTooltipFlags_OverridePrevious
	}

	window_name_template : string = is_dragdrop_tooltip ? "##Tooltip_DragDrop_%02d" : "##Tooltip_%02d"
	window_name : [32]u8
	ImFormatString(window_name[:], window_name_template, g.TooltipOverrideCount)
	if (tooltip_flags & ImGuiTooltipFlags_.ImGuiTooltipFlags_OverridePrevious) != {} && g.TooltipPreviousWindow != nil && g.TooltipPreviousWindow.Active {
		// Hide previous tooltip from being displayed. We can't easily "reset" the content of a window so we create a new one.
		//IMGUI_DEBUG_LOG("[tooltip] '%s' already active, using +1 for this frame\n", window_name);
		SetWindowHiddenAndSkipItemsForCurrentFrame(g.TooltipPreviousWindow)
		ImFormatString(window_name[:], window_name_template, pre_incr(&g.TooltipOverrideCount))
	}

	flags : ImGuiWindowFlags = ImGuiWindowFlags_.ImGuiWindowFlags_Tooltip | ImGuiWindowFlags_.ImGuiWindowFlags_NoInputs | ImGuiWindowFlags_.ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_.ImGuiWindowFlags_NoMove | ImGuiWindowFlags_.ImGuiWindowFlags_NoResize | ImGuiWindowFlags_.ImGuiWindowFlags_NoSavedSettings | ImGuiWindowFlags_.ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_.ImGuiWindowFlags_NoDocking
	Begin(cast(string) window_name[:strlen(raw_data(&window_name))], nil, flags | extra_window_flags)
	// 2023-03-09: Added bool return value to the API, but currently always returning true.
	// If this ever returns false we need to update BeginDragDropSource() accordingly.
	//if (!ret)
	//    End();
	//return ret;
	return true
}

// only call EndTooltip() if BeginTooltip()/BeginItemTooltip() returns true!
EndTooltip :: proc()
{
	IM_ASSERT((GetCurrentWindowRead().Flags & ImGuiWindowFlags_.ImGuiWindowFlags_Tooltip) != {}); // Mismatched BeginTooltip()/EndTooltip() calls
	End()
}

// set a text-only tooltip. Often used after a ImGui::IsItemHovered() check. Override any previous call to SetTooltip().
SetTooltip :: proc(fmt : string, args : ..any)
{
	SetTooltipV(fmt, args)
}

SetTooltipV :: proc(fmt : string, args : []any)
{
	if !BeginTooltipEx(ImGuiTooltipFlags_.ImGuiTooltipFlags_OverridePrevious, ImGuiWindowFlags_.ImGuiWindowFlags_None) { return }
	TextV(fmt, args)
	EndTooltip()
}

// set a text-only tooltip if preceding item was hovered. override any previous call to SetTooltip().
// Shortcut to use 'style.HoverFlagsForTooltipMouse' or 'style.HoverFlagsForTooltipNav'.
// Defaults to == ImGuiHoveredFlags_Stationary | ImGuiHoveredFlags_DelayShort when using the mouse.
SetItemTooltip :: proc(fmt : string, args : ..any)
{
	if IsItemHovered(ImGuiHoveredFlags_.ImGuiHoveredFlags_ForTooltip) { SetTooltipV(fmt, args) }
}

SetItemTooltipV :: proc(fmt : string, args : []any)
{
	if IsItemHovered(ImGuiHoveredFlags_.ImGuiHoveredFlags_ForTooltip) { SetTooltipV(fmt, args) }
}


// Popups: query functions
//  - IsPopupOpen(): return true if the popup is open at the current BeginPopup() level of the popup stack.
//  - IsPopupOpen() with ImGuiPopupFlags_AnyPopupId: return true if any popup is open at the current BeginPopup() level of the popup stack.
//  - IsPopupOpen() with ImGuiPopupFlags_AnyPopupId + ImGuiPopupFlags_AnyPopupLevel: return true if any popup is open.
// return true if the popup is open.
//-----------------------------------------------------------------------------
// [SECTION] POPUPS
//-----------------------------------------------------------------------------

// Supported flags: ImGuiPopupFlags_AnyPopupId, ImGuiPopupFlags_AnyPopupLevel
IsPopupOpen_0 :: proc(id : ImGuiID, popup_flags : ImGuiPopupFlags) -> bool
{
	g : ^ImGuiContext = GImGui
	if (popup_flags & ImGuiPopupFlags_.ImGuiPopupFlags_AnyPopupId) != {} {
		// Return true if any popup is open at the current BeginPopup() level of the popup stack
		// This may be used to e.g. test for another popups already opened to handle popups priorities at the same level.
		IM_ASSERT(id == 0)
		if (popup_flags & ImGuiPopupFlags_.ImGuiPopupFlags_AnyPopupLevel) != {} { return g.OpenPopupStack.Size > 0 }
		else { return g.OpenPopupStack.Size > g.BeginPopupStack.Size }
	}
	else {
		if (popup_flags & ImGuiPopupFlags_.ImGuiPopupFlags_AnyPopupLevel) != {} {
			// Return true if the popup is open anywhere in the popup stack
			for popup_data in g.OpenPopupStack.Data[:g.OpenPopupStack.Size] { if popup_data.PopupId == id { return true } }

			return false
		}
		else {
			// Return true if the popup is open at the current BeginPopup() level of the popup stack (this is the most-common query)
			return g.OpenPopupStack.Size > g.BeginPopupStack.Size && g.OpenPopupStack.Data[g.BeginPopupStack.Size].PopupId == id
		}
	}
}

// Popups: query functions
//  - IsPopupOpen(): return true if the popup is open at the current BeginPopup() level of the popup stack.
//  - IsPopupOpen() with ImGuiPopupFlags_AnyPopupId: return true if any popup is open at the current BeginPopup() level of the popup stack.
//  - IsPopupOpen() with ImGuiPopupFlags_AnyPopupId + ImGuiPopupFlags_AnyPopupLevel: return true if any popup is open.
// return true if the popup is open.
IsPopupOpen_1 :: proc(str_id : string, popup_flags : ImGuiPopupFlags = {}) -> bool
{
	g : ^ImGuiContext = GImGui
	id : ImGuiID = (popup_flags & ImGuiPopupFlags_.ImGuiPopupFlags_AnyPopupId) != {} ? 0 : GetID(g.CurrentWindow, str_id)
	if (popup_flags & ImGuiPopupFlags_.ImGuiPopupFlags_AnyPopupLevel) != {} && id != 0 {
		// But non-string version is legal and used internally
		IM_ASSERT(false, "Cannot use IsPopupOpen() with a string id and ImGuiPopupFlags_AnyPopupLevel.")
	}
	return IsPopupOpen(id, popup_flags)
}

// Also see FindBlockingModal(NULL)
GetTopMostPopupModal :: proc() -> ^ImGuiWindow
{
	g : ^ImGuiContext = GImGui
	for n : i32 = g.OpenPopupStack.Size - 1; n >= 0; n -= 1 { if popup : ^ImGuiWindow = g.OpenPopupStack.Data[n].Window; popup != nil { if (popup.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_Modal) != {} { return popup } } }

	return nil
}

// See Demo->Stacked Modal to confirm what this is for.
GetTopMostAndVisiblePopupModal :: proc() -> ^ImGuiWindow
{
	g : ^ImGuiContext = GImGui
	for n : i32 = g.OpenPopupStack.Size - 1; n >= 0; n -= 1 { if popup : ^ImGuiWindow = g.OpenPopupStack.Data[n].Window; popup != nil { if (popup.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_Modal) != {} && IsWindowActiveAndVisible(popup) { return popup } } }

	return nil
}


// When a modal popup is open, newly created windows that want focus (i.e. are not popups and do not specify ImGuiWindowFlags_NoFocusOnAppearing)
// should be positioned behind that modal window, unless the window was created inside the modal begin-stack.
// In case of multiple stacked modals newly created window honors begin stack order and does not go below its own modal parent.
// - WindowA            // FindBlockingModal() returns Modal1
//   - WindowB          //                  .. returns Modal1
//   - Modal1           //                  .. returns Modal2
//      - WindowC       //                  .. returns Modal2
//          - WindowD   //                  .. returns Modal2
//          - Modal2    //                  .. returns Modal2
//            - WindowE //                  .. returns NULL
// Notes:
// - FindBlockingModal(NULL) == NULL is generally equivalent to GetTopMostPopupModal() == NULL.
//   Only difference is here we check for ->Active/WasActive but it may be unnecessary.
FindBlockingModal :: proc(window : ^ImGuiWindow) -> ^ImGuiWindow
{
	g : ^ImGuiContext = GImGui
	if g.OpenPopupStack.Size <= 0 { return nil }

	// Find a modal that has common parent with specified window. Specified window should be positioned behind that modal.
	for popup_data in g.OpenPopupStack.Data[:g.OpenPopupStack.Size] {
		popup_window : ^ImGuiWindow = popup_data.Window
		if popup_window == nil || (popup_window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_Modal) == {} { continue }
		if !popup_window.Active && !popup_window.WasActive {
			// Check WasActive, because this code may run before popup renders on current frame, also check Active to handle newly created windows.
			continue
		}
		if window == nil {
			// FindBlockingModal(NULL) test for if FocusWindow(NULL) is naturally possible via a mouse click.
			return popup_window
		}
		if IsWindowWithinBeginStackOf(window, popup_window) {
			// Window may be over modal
			continue
		}
		return popup_window// Place window right below first block modal
	}

	return nil
}

// Popups: open/close functions
//  - OpenPopup(): set popup state to open. ImGuiPopupFlags are available for opening options.
//  - If not modal: they can be closed by clicking anywhere outside them, or by pressing ESCAPE.
//  - CloseCurrentPopup(): use inside the BeginPopup()/EndPopup() scope to close manually.
//  - CloseCurrentPopup() is called by default by Selectable()/MenuItem() when activated (FIXME: need some options).
//  - Use ImGuiPopupFlags_NoOpenOverExistingPopup to avoid opening a popup if there's already one at the same level. This is equivalent to e.g. testing for !IsAnyPopupOpen() prior to OpenPopup().
//  - Use IsWindowAppearing() after BeginPopup() to tell if a window just opened.
//  - IMPORTANT: Notice that for OpenPopupOnItemClick() we exceptionally default flags to 1 (== ImGuiPopupFlags_MouseButtonRight) for backward compatibility with older API taking 'int mouse_button = 1' parameter
// call to mark popup as open (don't call every frame!).
// id overload to facilitate calling from nested stacks
OpenPopup_0 :: proc(str_id : string, popup_flags : ImGuiPopupFlags = {})
{
	g : ^ImGuiContext = GImGui
	id : ImGuiID = GetID(g.CurrentWindow, str_id)
	IMGUI_DEBUG_LOG_POPUP(g, "[popup] OpenPopup(\"%s\" -> 0x%08X)\n", str_id, id)
	OpenPopupEx(id, popup_flags)
}

// Popups: open/close functions
//  - OpenPopup(): set popup state to open. ImGuiPopupFlags are available for opening options.
//  - If not modal: they can be closed by clicking anywhere outside them, or by pressing ESCAPE.
//  - CloseCurrentPopup(): use inside the BeginPopup()/EndPopup() scope to close manually.
//  - CloseCurrentPopup() is called by default by Selectable()/MenuItem() when activated (FIXME: need some options).
//  - Use ImGuiPopupFlags_NoOpenOverExistingPopup to avoid opening a popup if there's already one at the same level. This is equivalent to e.g. testing for !IsAnyPopupOpen() prior to OpenPopup().
//  - Use IsWindowAppearing() after BeginPopup() to tell if a window just opened.
//  - IMPORTANT: Notice that for OpenPopupOnItemClick() we exceptionally default flags to 1 (== ImGuiPopupFlags_MouseButtonRight) for backward compatibility with older API taking 'int mouse_button = 1' parameter
// call to mark popup as open (don't call every frame!).
// id overload to facilitate calling from nested stacks
OpenPopup_1 :: proc(id : ImGuiID, popup_flags : ImGuiPopupFlags = {})
{
	OpenPopupEx(id, popup_flags)
}

// Mark popup as open (toggle toward open state).
// Popups are closed when user click outside, or activate a pressable item, or CloseCurrentPopup() is called within a BeginPopup()/EndPopup() block.
// Popup identifiers are relative to the current ID-stack (so OpenPopup and BeginPopup needs to be at the same level).
// One open popup per level of the popup hierarchy (NB: when assigning we reset the Window member of ImGuiPopupRef to NULL)
OpenPopupEx :: proc(id : ImGuiID, popup_flags : ImGuiPopupFlags)
{
	g : ^ImGuiContext = GImGui
	parent_window : ^ImGuiWindow = g.CurrentWindow
	current_stack_size : i32 = g.BeginPopupStack.Size

	if (popup_flags & ImGuiPopupFlags_.ImGuiPopupFlags_NoOpenOverExistingPopup) != {} { if IsPopupOpen(cast(ImGuiID) 0, ImGuiPopupFlags_.ImGuiPopupFlags_AnyPopupId) { return } }

	popup_ref : ImGuiPopupData; // Tagged as new ref as Window will be set back to NULL if we write this into OpenPopupStack.
	popup_ref.PopupId = id
	popup_ref.Window = nil
	popup_ref.RestoreNavWindow = g.NavWindow; // When popup closes focus may be restored to NavWindow (depend on window type).
	popup_ref.OpenFrameCount = g.FrameCount
	popup_ref.OpenParentId = back(&parent_window.IDStack)^
	popup_ref.OpenPopupPos = NavCalcPreferredRefPos()
	popup_ref.OpenMousePos = IsMousePosValid(&g.IO.MousePos) ? g.IO.MousePos : popup_ref.OpenPopupPos

	IMGUI_DEBUG_LOG_POPUP(g, "[popup] OpenPopupEx(0x%08X)\n", id)
	if g.OpenPopupStack.Size < current_stack_size + 1 {
		push_back(&g.OpenPopupStack, popup_ref)
	}
	else {
		// Gently handle the user mistakenly calling OpenPopup() every frames: it is likely a programming mistake!
		// However, if we were to run the regular code path, the ui would become completely unusable because the popup will always be
		// in hidden-while-calculating-size state _while_ claiming focus. Which is extremely confusing situation for the programmer.
		// Instead, for successive frames calls to OpenPopup(), we silently avoid reopening even if ImGuiPopupFlags_NoReopen is not specified.
		keep_existing : bool = false
		if g.OpenPopupStack.Data[current_stack_size].PopupId == id { if (g.OpenPopupStack.Data[current_stack_size].OpenFrameCount == g.FrameCount - 1) || (popup_flags & ImGuiPopupFlags_.ImGuiPopupFlags_NoReopen) != {} { keep_existing = true } }
		if keep_existing {
			// No reopen
			g.OpenPopupStack.Data[current_stack_size].OpenFrameCount = popup_ref.OpenFrameCount
		}
		else {
			// Reopen: close child popups if any, then flag popup for open/reopen (set position, focus, init navigation)
			ClosePopupToLevel(current_stack_size, true)
			push_back(&g.OpenPopupStack, popup_ref)
		}

		// When reopening a popup we first refocus its parent, otherwise if its parent is itself a popup it would get closed by ClosePopupsOverWindow().
		// This is equivalent to what ClosePopupToLevel() does.
		//if (g.OpenPopupStack.Data[current_stack_size].PopupId == id)
		//    FocusWindow(parent_window);
	}
}

// When popups are stacked, clicking on a lower level popups puts focus back to it and close popups above it.
// This function closes any popups that are over 'ref_window'.
ClosePopupsOverWindow :: proc(ref_window : ^ImGuiWindow, restore_focus_to_window_under_popup : bool)
{
	g : ^ImGuiContext = GImGui
	if g.OpenPopupStack.Size == 0 { return }

	// Don't close our own child popup windows.
	//IMGUI_DEBUG_LOG_POPUP(g, "[popup] ClosePopupsOverWindow(\"%s\") restore_under=%d\n", ref_window ? ref_window->Name : "<NULL>", restore_focus_to_window_under_popup);
	popup_count_to_keep : i32 = 0
	if ref_window != nil {
		// Find the highest popup which is a descendant of the reference window (generally reference window = NavWindow)
		for ; popup_count_to_keep < g.OpenPopupStack.Size; popup_count_to_keep += 1 {
			popup : ^ImGuiPopupData = &g.OpenPopupStack.Data[popup_count_to_keep]
			if popup.Window == nil { continue }
			IM_ASSERT((popup.Window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_Popup) != {})

			// Trim the stack unless the popup is a direct parent of the reference window (the reference window is often the NavWindow)
			// - Clicking/Focusing Window2 won't close Popup1:
			//     Window -> Popup1 -> Window2(Ref)
			// - Clicking/focusing Popup1 will close Popup2 and Popup3:
			//     Window -> Popup1(Ref) -> Popup2 -> Popup3
			// - Each popups may contain child windows, which is why we compare ->RootWindowDockTree!
			//     Window -> Popup1 -> Popup1_Child -> Popup2 -> Popup2_Child
			// We step through every popup from bottom to top to validate their position relative to reference window.
			ref_window_is_descendent_of_popup : bool = false
			for n : i32 = popup_count_to_keep; n < g.OpenPopupStack.Size; n += 1 {
				if popup_window : ^ImGuiWindow = g.OpenPopupStack.Data[n].Window; popup_window != nil {
					//if (popup_window->RootWindowDockTree == ref_window->RootWindowDockTree) // FIXME-MERGE
					if IsWindowWithinBeginStackOf(ref_window, popup_window) {
						ref_window_is_descendent_of_popup = true
						break
					}
				}
			}

			if !ref_window_is_descendent_of_popup { break }
		}
	}
	if popup_count_to_keep < g.OpenPopupStack.Size {
		// This test is not required but it allows to set a convenient breakpoint on the statement below
		IMGUI_DEBUG_LOG_POPUP(g, "[popup] ClosePopupsOverWindow(\"%s\")\n", ref_window != nil ? ref_window.Name : "<NULL>")
		ClosePopupToLevel(popup_count_to_keep, restore_focus_to_window_under_popup)
	}
}

ClosePopupsExceptModals :: proc()
{
	g : ^ImGuiContext = GImGui

	popup_count_to_keep : i32
	for popup_count_to_keep = g.OpenPopupStack.Size; popup_count_to_keep > 0; popup_count_to_keep -= 1 {
		window : ^ImGuiWindow = g.OpenPopupStack.Data[popup_count_to_keep - 1].Window
		if window == nil || (window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_Modal) != {} { break }
	}

	if popup_count_to_keep < g.OpenPopupStack.Size {
		// This test is not required but it allows to set a convenient breakpoint on the statement below
		ClosePopupToLevel(popup_count_to_keep, true)
	}
}

ClosePopupToLevel :: proc(remaining : i32, restore_focus_to_window_under_popup : bool)
{
	g : ^ImGuiContext = GImGui
	IMGUI_DEBUG_LOG_POPUP(g, "[popup] ClosePopupToLevel(%d), restore_under=%d\n", remaining, restore_focus_to_window_under_popup)
	IM_ASSERT(remaining >= 0 && remaining < g.OpenPopupStack.Size)
	if (g.DebugLogFlags & ImGuiDebugLogFlags_.ImGuiDebugLogFlags_EventPopup) != {} { for n : i32 = remaining; n < g.OpenPopupStack.Size; n += 1 { IMGUI_DEBUG_LOG_POPUP(g, "[popup] - Closing PopupID 0x%08X Window \"%s\"\n", g.OpenPopupStack.Data[n].PopupId, g.OpenPopupStack.Data[n].Window != nil ? g.OpenPopupStack.Data[n].Window.Name : "") } }

	// Trim open popup stack
	prev_popup : ImGuiPopupData = g.OpenPopupStack.Data[remaining]
	resize(&g.OpenPopupStack, remaining)

	// Restore focus (unless popup window was not yet submitted, and didn't have a chance to take focus anyhow. See #7325 for an edge case)
	if restore_focus_to_window_under_popup && prev_popup.Window != nil {
		popup_window : ^ImGuiWindow = prev_popup.Window
		focus_window : ^ImGuiWindow = (popup_window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_ChildMenu) != {} ? popup_window.ParentWindow : prev_popup.RestoreNavWindow
		if focus_window != nil && !focus_window.WasActive {
			// Fallback
			FocusTopMostWindowUnderOne(popup_window, nil, nil, ImGuiFocusRequestFlags_.ImGuiFocusRequestFlags_RestoreFocusedChild)
		}
		else { FocusWindow(focus_window, (g.NavLayer == ImGuiNavLayer.ImGuiNavLayer_Main) ? ImGuiFocusRequestFlags_.ImGuiFocusRequestFlags_RestoreFocusedChild : ImGuiFocusRequestFlags_.ImGuiFocusRequestFlags_None) }
	}
}

// manually close the popup we have begin-ed into.
// Close the popup we have begin-ed into.
CloseCurrentPopup :: proc()
{
	g : ^ImGuiContext = GImGui
	popup_idx : i32 = g.BeginPopupStack.Size - 1
	if popup_idx < 0 || popup_idx >= g.OpenPopupStack.Size || g.BeginPopupStack.Data[popup_idx].PopupId != g.OpenPopupStack.Data[popup_idx].PopupId { return }

	// Closing a menu closes its top-most parent popup (unless a modal)
	for popup_idx > 0 {
		popup_window : ^ImGuiWindow = g.OpenPopupStack.Data[popup_idx].Window
		parent_popup_window : ^ImGuiWindow = g.OpenPopupStack.Data[popup_idx - 1].Window
		close_parent : bool = false
		if popup_window != nil && (popup_window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_ChildMenu) != {} { if parent_popup_window != nil && (parent_popup_window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_MenuBar) == {} { close_parent = true } }
		if !close_parent { break }
		post_decr(&popup_idx)
	}

	IMGUI_DEBUG_LOG_POPUP(g, "[popup] CloseCurrentPopup %d -> %d\n", g.BeginPopupStack.Size - 1, popup_idx)
	ClosePopupToLevel(popup_idx, true)

	// A common pattern is to close a popup when selecting a menu item/selectable that will open another window.
	// To improve this usage pattern, we avoid nav highlight for a single frame in the parent window.
	// Similarly, we could avoid mouse hover highlight in this window but it is less visually problematic.
	if window : ^ImGuiWindow = g.NavWindow; window != nil { window.DC.NavHideHighlightOneFrame = true }
}

// Popups, Modals
// Attention! BeginPopup() adds default flags when calling BeginPopupEx()!
BeginPopupEx :: proc(id : ImGuiID, extra_window_flags : ImGuiWindowFlags) -> bool
{
	g : ^ImGuiContext = GImGui
	if !IsPopupOpen(id, ImGuiPopupFlags_.ImGuiPopupFlags_None) {
		ClearFlags(&g.NextWindowData); // We behave like Begin() and need to consume those values
		return false
	}

	name : [20]u8
	if (extra_window_flags & ImGuiWindowFlags_.ImGuiWindowFlags_ChildMenu) != {} {
		// Recycle windows based on depth
		ImFormatString(name[:], "##Menu_%02d", g.BeginMenuDepth)
	}
	else {
		// Not recycling, so we can close/open during the same frame
		ImFormatString(name[:], "##Popup_%08x", id)
	}

	is_open : bool = Begin(string_from_slice(name[:]), nil, extra_window_flags | ImGuiWindowFlags_.ImGuiWindowFlags_Popup | ImGuiWindowFlags_.ImGuiWindowFlags_NoDocking)
	if !is_open {
		// NB: Begin can return false when the popup is completely clipped (e.g. zero size display)
		EndPopup()
	}

	//g.CurrentWindow->FocusRouteParentWindow = g.CurrentWindow->ParentWindowInBeginStack;

	return is_open
}

// Popups, Modals
//  - They block normal mouse hovering detection (and therefore most mouse interactions) behind them.
//  - If not modal: they can be closed by clicking anywhere outside them, or by pressing ESCAPE.
//  - Their visibility state (~bool) is held internally instead of being held by the programmer as we are used to with regular Begin*() calls.
//  - The 3 properties above are related: we need to retain popup visibility state in the library because popups may be closed as any time.
//  - You can bypass the hovering restriction by using ImGuiHoveredFlags_AllowWhenBlockedByPopup when calling IsItemHovered() or IsWindowHovered().
//  - IMPORTANT: Popup identifiers are relative to the current ID stack, so OpenPopup and BeginPopup generally needs to be at the same level of the stack.
//    This is sometimes leading to confusing mistakes. May rework this in the future.
//  - BeginPopup(): query popup state, if open start appending into the window. Call EndPopup() afterwards if returned true. ImGuiWindowFlags are forwarded to the window.
//  - BeginPopupModal(): block every interaction behind the window, cannot be closed by user, add a dimming background, has a title bar.
// return true if the popup is open, and you can start outputting to it.
BeginPopup :: proc(str_id : string, flags : ImGuiWindowFlags = {}) -> bool
{
	flags := flags
	g : ^ImGuiContext = GImGui
	if g.OpenPopupStack.Size <= g.BeginPopupStack.Size {
		// Early out for performance
		ClearFlags(&g.NextWindowData); // We behave like Begin() and need to consume those values
		return false
	}
	flags |= ImGuiWindowFlags_.ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_.ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_.ImGuiWindowFlags_NoSavedSettings
	id : ImGuiID = GetID(g.CurrentWindow, str_id)
	return BeginPopupEx(id, flags)
}

// return true if the modal is open, and you can start outputting to it.
// If 'p_open' is specified for a modal popup window, the popup will have a regular close button which will close the popup.
// Note that popup visibility status is owned by Dear ImGui (and manipulated with e.g. OpenPopup).
// - *p_open set back to false in BeginPopupModal() when popup is not open.
// - if you set *p_open to false before calling BeginPopupModal(), it will close the popup.
BeginPopupModal :: proc(name : string, p_open : ^bool, flags : ImGuiWindowFlags) -> bool
{
	g : ^ImGuiContext = GImGui
	window : ^ImGuiWindow = g.CurrentWindow
	id : ImGuiID = GetID(window, name)
	if !IsPopupOpen(id, ImGuiPopupFlags_.ImGuiPopupFlags_None) {
		ClearFlags(&g.NextWindowData); // We behave like Begin() and need to consume those values
		if p_open != nil && p_open^ { p_open^ = false }
		return false
	}

	// Center modal windows by default for increased visibility
	// (this won't really last as settings will kick in, and is mostly for backward compatibility. user may do the same themselves)
	// FIXME: Should test for (PosCond & window->SetWindowPosAllowFlags) with the upcoming window.
	if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_.ImGuiNextWindowDataFlags_HasPos) == {} {
		viewport : ^ImGuiViewport = window.WasActive ? window.Viewport : GetMainViewport(); // FIXME-VIEWPORT: What may be our reference viewport?
		SetNextWindowPos(GetCenter(viewport), ImGuiCond_.ImGuiCond_FirstUseEver, ImVec2{0.5, 0.5})
	}

	flags := flags | ImGuiWindowFlags_.ImGuiWindowFlags_Popup | ImGuiWindowFlags_.ImGuiWindowFlags_Modal | ImGuiWindowFlags_.ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_.ImGuiWindowFlags_NoDocking
	is_open : bool = Begin(name, p_open, flags)
	if !is_open || (p_open != nil && !p_open^) {
		// NB: is_open can be 'false' when the popup is completely clipped (e.g. zero size display)
		EndPopup()
		if is_open { ClosePopupToLevel(g.BeginPopupStack.Size, true) }
		return false
	}
	return is_open
}

// only call EndPopup() if BeginPopupXXX() returns true!
EndPopup :: proc()
{
	g : ^ImGuiContext = GImGui
	window : ^ImGuiWindow = g.CurrentWindow
	IM_ASSERT((window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_Popup) != {}); // Mismatched BeginPopup()/EndPopup() calls
	IM_ASSERT(g.BeginPopupStack.Size > 0)

	// Make all menus and popups wrap around for now, may need to expose that policy (e.g. focus scope could include wrap/loop policy flags used by new move requests)
	if g.NavWindow == window { NavMoveRequestTryWrapping(window, ImGuiNavMoveFlags_.ImGuiNavMoveFlags_LoopY) }

	// Child-popups don't need to be laid out
	backup_within_end_child_id : ImGuiID = g.WithinEndChildID
	if (window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_ChildWindow) != {} { g.WithinEndChildID = window.ID }
	End()
	g.WithinEndChildID = backup_within_end_child_id
}

// helper to open popup when clicked on last item. Default to ImGuiPopupFlags_MouseButtonRight == 1. (note: actually triggers on the mouse _released_ event to be consistent with popup behaviors)
// Helper to open a popup if mouse button is released over the item
// - This is essentially the same as BeginPopupContextItem() but without the trailing BeginPopup()
OpenPopupOnItemClick :: proc(str_id : string, popup_flags : ImGuiPopupFlags)
{
	g : ^ImGuiContext = GImGui
	window : ^ImGuiWindow = g.CurrentWindow
	mouse_button := ImGuiMouseButton(popup_flags & ImGuiPopupFlags_.ImGuiPopupFlags_MouseButtonMask_)
	if IsMouseReleased(mouse_button) && IsItemHovered(ImGuiHoveredFlags_.ImGuiHoveredFlags_AllowWhenBlockedByPopup) {
		id : ImGuiID = str_id != "" ? GetID(window, str_id) : g.LastItemData.ID; // If user hasn't passed an ID, we can use the LastItemID. Using LastItemID as a Popup ID won't conflict!
		IM_ASSERT(id != 0); // You cannot pass a NULL str_id if the last item has no identifier (e.g. a Text() item)
		OpenPopupEx(id, popup_flags)
	}
}

// Popups: open+begin combined functions helpers
//  - Helpers to do OpenPopup+BeginPopup where the Open action is triggered by e.g. hovering an item and right-clicking.
//  - They are convenient to easily create context menus, hence the name.
//  - IMPORTANT: Notice that BeginPopupContextXXX takes ImGuiPopupFlags just like OpenPopup() and unlike BeginPopup(). For full consistency, we may add ImGuiWindowFlags to the BeginPopupContextXXX functions in the future.
//  - IMPORTANT: Notice that we exceptionally default their flags to 1 (== ImGuiPopupFlags_MouseButtonRight) for backward compatibility with older API taking 'int mouse_button = 1' parameter, so if you add other flags remember to re-add the ImGuiPopupFlags_MouseButtonRight.
// open+begin popup when clicked on last item. Use str_id==NULL to associate the popup to previous item. If you want to use that on a non-interactive item such as Text() you need to pass in an explicit ID here. read comments in .cpp!
// This is a helper to handle the simplest case of associating one named popup to one given widget.
// - To create a popup associated to the last item, you generally want to pass a NULL value to str_id.
// - To create a popup with a specific identifier, pass it in str_id.
//    - This is useful when using using BeginPopupContextItem() on an item which doesn't have an identifier, e.g. a Text() call.
//    - This is useful when multiple code locations may want to manipulate/open the same popup, given an explicit id.
// - You may want to handle the whole on user side if you have specific needs (e.g. tweaking IsItemHovered() parameters).
//   This is essentially the same as:
//       id = str_id ? GetID(str_id) : GetItemID();
//       OpenPopupOnItemClick(str_id, ImGuiPopupFlags_MouseButtonRight);
//       return BeginPopup(id);
//   Which is essentially the same as:
//       id = str_id ? GetID(str_id) : GetItemID();
//       if (IsItemHovered() && IsMouseReleased(ImGuiMouseButton_Right))
//           OpenPopup(id);
//       return BeginPopup(id);
//   The main difference being that this is tweaked to avoid computing the ID twice.
BeginPopupContextItem :: proc(str_id : string = "", popup_flags : ImGuiPopupFlags = ImGuiPopupFlags(1)) -> bool
{
	g : ^ImGuiContext = GImGui
	window : ^ImGuiWindow = g.CurrentWindow
	if window.SkipItems { return false }
	id : ImGuiID = str_id != "" ? GetID(window, str_id) : g.LastItemData.ID; // If user hasn't passed an ID, we can use the LastItemID. Using LastItemID as a Popup ID won't conflict!
	IM_ASSERT(id != 0); // You cannot pass a NULL str_id if the last item has no identifier (e.g. a Text() item)
	mouse_button := ImGuiMouseButton(popup_flags & ImGuiPopupFlags_.ImGuiPopupFlags_MouseButtonMask_)
	if IsMouseReleased(mouse_button) && IsItemHovered(ImGuiHoveredFlags_.ImGuiHoveredFlags_AllowWhenBlockedByPopup) { OpenPopupEx(id, popup_flags) }
	return BeginPopupEx(id, ImGuiWindowFlags_.ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_.ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_.ImGuiWindowFlags_NoSavedSettings)
}

// open+begin popup when clicked on current window.
BeginPopupContextWindow :: proc(str_id : string = "", popup_flags : ImGuiPopupFlags = ImGuiPopupFlags(1)) -> bool
{
	g : ^ImGuiContext = GImGui
	window : ^ImGuiWindow = g.CurrentWindow
	str_id := str_id
	if str_id == "" { str_id = "window_context" }
	id : ImGuiID = GetID(window, str_id)
	mouse_button := ImGuiMouseButton(popup_flags & ImGuiPopupFlags_.ImGuiPopupFlags_MouseButtonMask_)
	if IsMouseReleased(mouse_button) && IsWindowHovered(ImGuiHoveredFlags_.ImGuiHoveredFlags_AllowWhenBlockedByPopup) { if (popup_flags & ImGuiPopupFlags_.ImGuiPopupFlags_NoOpenOverItems) == {} || !IsAnyItemHovered() { OpenPopupEx(id, popup_flags) } }
	return BeginPopupEx(id, ImGuiWindowFlags_.ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_.ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_.ImGuiWindowFlags_NoSavedSettings)
}

// open+begin popup when clicked in void (where there are no windows).
BeginPopupContextVoid :: proc(str_id : string = "", popup_flags : ImGuiPopupFlags = ImGuiPopupFlags(1)) -> bool
{
	g : ^ImGuiContext = GImGui
	window : ^ImGuiWindow = g.CurrentWindow
	str_id := str_id
	if str_id == "" { str_id = "void_context" }
	id : ImGuiID = GetID(window, str_id)
	mouse_button := ImGuiMouseButton(popup_flags & ImGuiPopupFlags_.ImGuiPopupFlags_MouseButtonMask_)
	if IsMouseReleased(mouse_button) && !IsWindowHovered(ImGuiHoveredFlags_.ImGuiHoveredFlags_AnyWindow) { if GetTopMostPopupModal() == nil { OpenPopupEx(id, popup_flags) } }
	return BeginPopupEx(id, ImGuiWindowFlags_.ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_.ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_.ImGuiWindowFlags_NoSavedSettings)
}

// r_avoid = the rectangle to avoid (e.g. for tooltip it is a rectangle around the mouse cursor which we want to avoid. for popups it's a small point around the cursor.)
// r_outer = the visible area rectangle, minus safe area padding. If our popup size won't fit because of safe area padding we ignore it.
// (r_outer is usually equivalent to the viewport rectangle minus padding, but when multi-viewports are enabled and monitor
//  information are available, it may represent the entire platform monitor from the frame of reference of the current viewport.
//  this allows us to have tooltips/popups displayed out of the parent viewport.)
FindBestWindowPosForPopupEx :: proc(ref_pos : ImVec2, size : ImVec2, last_dir : ^ImGuiDir, r_outer : ImRect, r_avoid : ImRect, policy : ImGuiPopupPositionPolicy) -> ImVec2
{
	base_pos_clamped : ImVec2 = ImClamp(ref_pos, r_outer.Min, r_outer.Max - size)
	//GetForegroundDrawList()->AddRect(r_avoid.Min, r_avoid.Max, IM_COL32(255,0,0,255));
	//GetForegroundDrawList()->AddRect(r_outer.Min, r_outer.Max, IM_COL32(0,255,0,255));

	// Combo Box policy (we want a connecting edge)
	if policy == ImGuiPopupPositionPolicy.ImGuiPopupPositionPolicy_ComboBox {
		dir_prefered_order : [ImGuiDir.ImGuiDir_COUNT]ImGuiDir = {ImGuiDir.ImGuiDir_Down, ImGuiDir.ImGuiDir_Right, ImGuiDir.ImGuiDir_Left, ImGuiDir.ImGuiDir_Up}
		for n : i32 = (last_dir^ != ImGuiDir.ImGuiDir_None) ? -1 : 0; n < cast(i32) ImGuiDir.ImGuiDir_COUNT; n += 1 {
			dir : ImGuiDir = (n == -1) ? last_dir^ : dir_prefered_order[n]
			if n != -1 && dir == last_dir^ {
				// Already tried this direction?
				continue
			}
			pos : ImVec2
			if dir == ImGuiDir.ImGuiDir_Down {
				// Below, Toward Right (default)
				pos = ImVec2{r_avoid.Min.x, r_avoid.Max.y}
			}
			if dir == ImGuiDir.ImGuiDir_Right {
				// Above, Toward Right
				pos = ImVec2{r_avoid.Min.x, r_avoid.Min.y - size.y}
			}
			if dir == ImGuiDir.ImGuiDir_Left {
				// Below, Toward Left
				pos = ImVec2{r_avoid.Max.x - size.x, r_avoid.Max.y}
			}
			if dir == ImGuiDir.ImGuiDir_Up {
				// Above, Toward Left
				pos = ImVec2{r_avoid.Max.x - size.x, r_avoid.Min.y - size.y}
			}
			if !Contains(r_outer, ImRect{pos, pos + size}) { continue }
			last_dir^ = dir
			return pos
		}
	}

	// Tooltip and Default popup policy
	// (Always first try the direction we used on the last frame, if any)
	if policy == ImGuiPopupPositionPolicy.ImGuiPopupPositionPolicy_Tooltip || policy == ImGuiPopupPositionPolicy.ImGuiPopupPositionPolicy_Default {
		dir_prefered_order : [ImGuiDir.ImGuiDir_COUNT]ImGuiDir = {ImGuiDir.ImGuiDir_Right, ImGuiDir.ImGuiDir_Down, ImGuiDir.ImGuiDir_Up, ImGuiDir.ImGuiDir_Left}
		for n : i32 = (last_dir^ != ImGuiDir.ImGuiDir_None) ? -1 : 0; n < cast(i32)ImGuiDir.ImGuiDir_COUNT; n += 1 {
			dir : ImGuiDir = (n == -1) ? last_dir^ : dir_prefered_order[n]
			if n != -1 && dir == last_dir^ {
				// Already tried this direction?
				continue
			}

			avail_w : f32 = (dir == ImGuiDir.ImGuiDir_Left ? r_avoid.Min.x : r_outer.Max.x) - (dir == ImGuiDir.ImGuiDir_Right ? r_avoid.Max.x : r_outer.Min.x)
			avail_h : f32 = (dir == ImGuiDir.ImGuiDir_Up ? r_avoid.Min.y : r_outer.Max.y) - (dir == ImGuiDir.ImGuiDir_Down ? r_avoid.Max.y : r_outer.Min.y)

			// If there's not enough room on one axis, there's no point in positioning on a side on this axis (e.g. when not enough width, use a top/bottom position to maximize available width)
			if avail_w < size.x && (dir == ImGuiDir.ImGuiDir_Left || dir == ImGuiDir.ImGuiDir_Right) { continue }
			if avail_h < size.y && (dir == ImGuiDir.ImGuiDir_Up || dir == ImGuiDir.ImGuiDir_Down) { continue }

			pos : ImVec2
			pos.x = (dir == ImGuiDir.ImGuiDir_Left) ? r_avoid.Min.x - size.x : (dir == ImGuiDir.ImGuiDir_Right) ? r_avoid.Max.x : base_pos_clamped.x
			pos.y = (dir == ImGuiDir.ImGuiDir_Up) ? r_avoid.Min.y - size.y : (dir == ImGuiDir.ImGuiDir_Down) ? r_avoid.Max.y : base_pos_clamped.y

			// Clamp top-left corner of popup
			pos.x = ImMax(pos.x, r_outer.Min.x)
			pos.y = ImMax(pos.y, r_outer.Min.y)

			last_dir^ = dir
			return pos
		}
	}

	// Fallback when not enough room:
	last_dir^ = ImGuiDir.ImGuiDir_None

	// For tooltip we prefer avoiding the cursor at all cost even if it means that part of the tooltip won't be visible.
	if policy == ImGuiPopupPositionPolicy.ImGuiPopupPositionPolicy_Tooltip { return ref_pos + ImVec2{2, 2} }

	// Otherwise try to keep within display
	pos : ImVec2 = ref_pos
	pos.x = ImMax(ImMin(pos.x + size.x, r_outer.Max.x) - size.x, r_outer.Min.x)
	pos.y = ImMax(ImMin(pos.y + size.y, r_outer.Max.y) - size.y, r_outer.Min.y)
	return pos
}

// Note that this is used for popups, which can overlap the non work-area of individual viewports.
GetPopupAllowedExtentRect :: proc(window : ^ImGuiWindow) -> ImRect
{
	g : ^ImGuiContext = GImGui
	r_screen : ImRect
	if window.ViewportAllowPlatformMonitorExtend >= 0 {
		// Extent with be in the frame of reference of the given viewport (so Min is likely to be negative here)
		monitor : ^ImGuiPlatformMonitor = &g.PlatformIO.Monitors.Data[window.ViewportAllowPlatformMonitorExtend]
		r_screen.Min = monitor.WorkPos
		r_screen.Max = monitor.WorkPos + monitor.WorkSize
	}
	else {
		// Use the full viewport area (not work area) for popups
		r_screen = GetMainRect(window.Viewport)
	}
	padding : ImVec2 = g.Style.DisplaySafeAreaPadding
	Expand(&r_screen, ImVec2{(GetWidth(r_screen) > padding.x * 2) ? -padding.x : 0.0, (GetHeight(r_screen) > padding.y * 2) ? -padding.y : 0.0})
	return r_screen
}

FindBestWindowPosForPopup :: proc(window : ^ImGuiWindow) -> ImVec2
{
	g : ^ImGuiContext = GImGui

	r_outer : ImRect = GetPopupAllowedExtentRect(window)
	if (window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_ChildMenu) != {} {
		// Child menus typically request _any_ position within the parent menu item, and then we move the new menu outside the parent bounds.
		// This is how we end up with child menus appearing (most-commonly) on the right of the parent menu.
		parent_window : ^ImGuiWindow = window.ParentWindow
		horizontal_overlap : f32 = g.Style.ItemInnerSpacing.x; // We want some overlap to convey the relative depth of each menu (currently the amount of overlap is hard-coded to style.ItemSpacing.x).
		r_avoid : ImRect
		if parent_window.DC.MenuBarAppending {
			// Avoid parent menu-bar. If we wanted multi-line menu-bar, we may instead want to have the calling window setup e.g. a NextWindowData.PosConstraintAvoidRect field
			r_avoid = ImRect{{-FLT_MAX, parent_window.ClipRect.Min.y}, {FLT_MAX, parent_window.ClipRect.Max.y}}
		}
		else { r_avoid = ImRect{{parent_window.Pos.x + horizontal_overlap, -FLT_MAX}, {parent_window.Pos.x + parent_window.Size.x - horizontal_overlap - parent_window.ScrollbarSizes.x, FLT_MAX}} }
		return FindBestWindowPosForPopupEx(window.Pos, window.Size, &window.AutoPosLastDirection, r_outer, r_avoid, ImGuiPopupPositionPolicy.ImGuiPopupPositionPolicy_Default)
	}
	if (window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_Popup) != {} {
		return FindBestWindowPosForPopupEx(window.Pos, window.Size, &window.AutoPosLastDirection, r_outer, ImRect{window.Pos, window.Pos}, ImGuiPopupPositionPolicy.ImGuiPopupPositionPolicy_Default)// Ideally we'd disable r_avoid here
	}
	if (window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_Tooltip) != {} {
		// Position tooltip (always follows mouse + clamp within outer boundaries)
		// FIXME:
		// - Too many paths. One problem is that FindBestWindowPosForPopupEx() doesn't allow passing a suggested position (so touch screen path doesn't use it by default).
		// - Drag and drop tooltips are not using this path either: BeginTooltipEx() manually sets their position.
		// - Require some tidying up. In theory we could handle both cases in same location, but requires a bit of shuffling
		//   as drag and drop tooltips are calling SetNextWindowPos() leading to 'window_pos_set_by_api' being set in Begin().
		IM_ASSERT(g.CurrentWindow == window)
		scale : f32 = g.Style.MouseCursorScale
		ref_pos : ImVec2 = NavCalcPreferredRefPos()

		if g.IO.MouseSource == ImGuiMouseSource.ImGuiMouseSource_TouchScreen && NavCalcPreferredRefPosSource() == ImGuiInputSource.ImGuiInputEventType_Mouse {
			tooltip_pos : ImVec2 = ref_pos + TOOLTIP_DEFAULT_OFFSET_TOUCH * scale - (TOOLTIP_DEFAULT_PIVOT_TOUCH * window.Size)
			if Contains(r_outer, ImRect{tooltip_pos, tooltip_pos + window.Size}) { return tooltip_pos }
		}

		tooltip_pos : ImVec2 = ref_pos + TOOLTIP_DEFAULT_OFFSET_MOUSE * scale
		r_avoid : ImRect
		if g.NavCursorVisible && g.NavHighlightItemUnderNav && !g.IO.ConfigNavMoveSetMousePos { r_avoid = ImRect{{ref_pos.x - 16, ref_pos.y - 8}, {ref_pos.x + 16, ref_pos.y + 8}} }
		else {
			// FIXME: Hard-coded based on mouse cursor shape expectation. Exact dimension not very important.
			r_avoid = ImRect{{ref_pos.x - 16, ref_pos.y - 8}, {ref_pos.x + 24 * scale, ref_pos.y + 24 * scale}}
		}
		//GetForegroundDrawList()->AddRect(r_avoid.Min, r_avoid.Max, IM_COL32(255, 0, 255, 255));

		return FindBestWindowPosForPopupEx(tooltip_pos, window.Size, &window.AutoPosLastDirection, r_outer, r_avoid, ImGuiPopupPositionPolicy.ImGuiPopupPositionPolicy_Tooltip)
	}
	IM_ASSERT(false)
	return window.Pos
}

// (not recommended) set current window to be focused / top-most. prefer using SetNextWindowFocus().
// set named window to be focused / top-most. use NULL to remove focus.
//-----------------------------------------------------------------------------
// [SECTION] WINDOW FOCUS
//----------------------------------------------------------------------------
// - SetWindowFocus()
// - SetNextWindowFocus()
// - IsWindowFocused()
// - UpdateWindowInFocusOrderList() [Internal]
// - BringWindowToFocusFront() [Internal]
// - BringWindowToDisplayFront() [Internal]
// - BringWindowToDisplayBack() [Internal]
// - BringWindowToDisplayBehind() [Internal]
// - FindWindowDisplayIndex() [Internal]
// - FocusWindow() [Internal]
// - FocusTopMostWindowUnderOne() [Internal]
//-----------------------------------------------------------------------------

SetWindowFocus_0 :: proc()
{
	FocusWindow(GImGui.CurrentWindow)
}

// (not recommended) set current window to be focused / top-most. prefer using SetNextWindowFocus().
// set named window to be focused / top-most. use NULL to remove focus.
SetWindowFocus_1 :: proc(name : string)
{
	if name != "" {
		if window : ^ImGuiWindow = FindWindowByName(name); window != nil { FocusWindow(window) }
	}
	else {
		FocusWindow(nil)
	}
}

// set next window to be focused / top-most. call before Begin()
SetNextWindowFocus :: proc()
{
	g : ^ImGuiContext = GImGui
	g.NextWindowData.Flags |= ImGuiNextWindowDataFlags_.ImGuiNextWindowDataFlags_HasFocus
}

// is current window focused? or its root/child, depending on flags. see flags for options.
// Similar to IsWindowHovered()
IsWindowFocused :: proc(flags : ImGuiFocusedFlags) -> bool
{
	g : ^ImGuiContext = GImGui
	ref_window : ^ImGuiWindow = g.NavWindow
	cur_window : ^ImGuiWindow = g.CurrentWindow

	if ref_window == nil { return false }
	if (flags & ImGuiFocusedFlags_.ImGuiFocusedFlags_AnyWindow) != {} { return true }

	IM_ASSERT(cur_window != nil); // Not inside a Begin()/End()
	popup_hierarchy : bool = (flags & ImGuiFocusedFlags_.ImGuiFocusedFlags_NoPopupHierarchy) == {}
	dock_hierarchy : bool = (flags & ImGuiFocusedFlags_.ImGuiFocusedFlags_DockHierarchy) != {}
	if (flags & cast(ImGuiFocusedFlags)ImGuiHoveredFlags_.ImGuiHoveredFlags_RootWindow) != {} { cur_window = GetCombinedRootWindow(cur_window, popup_hierarchy, dock_hierarchy) }

	if (flags & cast(ImGuiFocusedFlags)ImGuiHoveredFlags_.ImGuiHoveredFlags_ChildWindows) != {} { return IsWindowChildOf(ref_window, cur_window, popup_hierarchy, dock_hierarchy) }
	else { return (ref_window == cur_window) }
}

// Window Focus
FindWindowFocusIndex :: proc(window : ^ImGuiWindow) -> i32
{
	g : ^ImGuiContext = GImGui
	IM_UNUSED(g)
	order := cast(i32) window.FocusOrder
	IM_ASSERT(window.RootWindow == window); // No child window (not testing _ChildWindow because of docking)
	IM_ASSERT(g.WindowsFocusOrder.Data[order] == window)
	return order
}

UpdateWindowInFocusOrderList :: proc(window : ^ImGuiWindow, just_created : bool, new_flags : ImGuiWindowFlags)
{
	g : ^ImGuiContext = GImGui

	new_is_explicit_child : bool = (new_flags & ImGuiWindowFlags_.ImGuiWindowFlags_ChildWindow) != {} && ((new_flags & ImGuiWindowFlags_.ImGuiWindowFlags_Popup) == {} || (new_flags & ImGuiWindowFlags_.ImGuiWindowFlags_ChildMenu) != {})
	child_flag_changed : bool = new_is_explicit_child != window.IsExplicitChild
	if (just_created || child_flag_changed) && !new_is_explicit_child {
		IM_ASSERT(!contains(g.WindowsFocusOrder, window))
		push_back(&g.WindowsFocusOrder, window)
		window.FocusOrder = cast(i16) (g.WindowsFocusOrder.Size - 1)
	}
	else if !just_created && child_flag_changed && new_is_explicit_child {
		IM_ASSERT(g.WindowsFocusOrder.Data[window.FocusOrder] == window)
		for n := cast(i32) window.FocusOrder + 1; n < g.WindowsFocusOrder.Size; n += 1 { post_decr(&g.WindowsFocusOrder.Data[n].FocusOrder) }

		erase(&g.WindowsFocusOrder, &g.WindowsFocusOrder.Data[window.FocusOrder])
		window.FocusOrder = -1
	}
	window.IsExplicitChild = new_is_explicit_child
}

BringWindowToFocusFront :: proc(window : ^ImGuiWindow)
{
	g : ^ImGuiContext = GImGui
	IM_ASSERT(window == window.RootWindow)

	cur_order := cast(i32) window.FocusOrder
	IM_ASSERT(g.WindowsFocusOrder.Data[cur_order] == window)
	if back(&g.WindowsFocusOrder)^ == window { return }

	new_order : i32 = g.WindowsFocusOrder.Size - 1
	for n : i32 = cur_order; n < new_order; n += 1 {
		g.WindowsFocusOrder.Data[n] = g.WindowsFocusOrder.Data[n + 1]
		post_decr(&g.WindowsFocusOrder.Data[n].FocusOrder)
		IM_ASSERT(cast(i32)g.WindowsFocusOrder.Data[n].FocusOrder == n)
	}

	g.WindowsFocusOrder.Data[new_order] = window
	window.FocusOrder = cast(i16) new_order
}

// Note technically focus related but rather adjacent and close to BringWindowToFocusFront()
BringWindowToDisplayFront :: proc(window : ^ImGuiWindow)
{
	g : ^ImGuiContext = GImGui
	current_front_window : ^ImGuiWindow = back(&g.Windows)^
	if current_front_window == window || current_front_window.RootWindowDockTree == window {
		// Cheap early out (could be better)
		return
	}
	for i : i32 = g.Windows.Size - 2; i >= 0; i -= 1 { if g.Windows.Data[i] == window {
	memmove(&g.Windows.Data[i], &g.Windows.Data[i + 1], cast(int) (g.Windows.Size - i - 1) * size_of(^ImGuiWindow))
	g.Windows.Data[g.Windows.Size - 1] = window
	break
} }
}

BringWindowToDisplayBack :: proc(window : ^ImGuiWindow)
{
	g : ^ImGuiContext = GImGui
	if g.Windows.Data[0] == window { return }
	for i : i32 = 0; i < g.Windows.Size; i += 1 { if g.Windows.Data[i] == window {
	memmove(&g.Windows.Data[1], &g.Windows.Data[0], cast(int) i * size_of(^ImGuiWindow))
	g.Windows.Data[0] = window
	break
} }
}

BringWindowToDisplayBehind :: proc(window : ^ImGuiWindow, behind_window : ^ImGuiWindow)
{
	IM_ASSERT(window != nil && behind_window != nil)
	g : ^ImGuiContext = GImGui
	window := window.RootWindow
	behind_window := behind_window.RootWindow
	pos_wnd : i32 = FindWindowDisplayIndex(window)
	pos_beh : i32 = FindWindowDisplayIndex(behind_window)
	if pos_wnd < pos_beh {
		copy_bytes := int(pos_beh - pos_wnd - 1) * size_of(^ImGuiWindow)
		memmove(&g.Windows.Data[pos_wnd], &g.Windows.Data[pos_wnd + 1], copy_bytes)
		g.Windows.Data[pos_beh - 1] = window
	}
	else {
		copy_bytes := int(pos_wnd - pos_beh) * size_of(^ImGuiWindow)
		memmove(&g.Windows.Data[pos_beh + 1], &g.Windows.Data[pos_beh], copy_bytes)
		g.Windows.Data[pos_beh] = window
	}
}

FindWindowDisplayIndex :: proc(window : ^ImGuiWindow) -> i32
{
	g : ^ImGuiContext = GImGui
	return index_from_ptr(&g.Windows, find(&g.Windows, window))
}

// Windows: Display Order and Focus Order
// Moving window to front of display and set focus (which happens to be back of our sorted list)
FocusWindow :: proc(window : ^ImGuiWindow, flags : ImGuiFocusRequestFlags = {})
{
	g : ^ImGuiContext = GImGui

	// Modal check?
	if (flags & ImGuiFocusRequestFlags_.ImGuiFocusRequestFlags_UnlessBelowModal) != {} && (g.NavWindow != window) {
		// Early out in common case.
		if blocking_modal : ^ImGuiWindow = FindBlockingModal(window); blocking_modal != nil {
			// This block would typically be reached in two situations:
			// - API call to FocusWindow() with a window under a modal and ImGuiFocusRequestFlags_UnlessBelowModal flag.
			// - User clicking on void or anything behind a modal while a modal is open (window == NULL)
			IMGUI_DEBUG_LOG_FOCUS(g, "[focus] FocusWindow(\"%s\", UnlessBelowModal): prevented by \"%s\".\n", window != nil ? window.Name : "<NULL>", blocking_modal.Name)
			if window != nil && window == window.RootWindow && (window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoBringToFrontOnFocus) == {} {
				// Still bring right under modal. (FIXME: Could move in focus list too?)
				BringWindowToDisplayBehind(window, blocking_modal)
			}
			ClosePopupsOverWindow(GetTopMostPopupModal(), false); // Note how we need to use GetTopMostPopupModal() aad NOT blocking_modal, to handle nested modals
			return
		}
	}

	window := window
	// Find last focused child (if any) and focus it instead.
	if (flags & ImGuiFocusRequestFlags_.ImGuiFocusRequestFlags_RestoreFocusedChild) != {} && window != nil { window = NavRestoreLastChildNavWindow(window) }

	// Apply focus
	if g.NavWindow != window {
		SetNavWindow(window)
		if window != nil && g.NavHighlightItemUnderNav { g.NavMousePosDirty = true }
		g.NavId = window != nil ? window.NavLastIds[0] : 0; // Restore NavId
		g.NavLayer = ImGuiNavLayer.ImGuiNavLayer_Main
		SetNavFocusScope(window != nil ? window.NavRootFocusScopeId : 0)
		g.NavIdIsAlive = false
		g.NavLastValidSelectionUserData = ImGuiSelectionUserData_Invalid

		// Close popups if any
		ClosePopupsOverWindow(window, false)
	}

	// Move the root window to the top of the pile
	IM_ASSERT(window == nil || window.RootWindowDockTree != nil)
	focus_front_window : ^ImGuiWindow = window != nil ? window.RootWindow : nil
	display_front_window : ^ImGuiWindow = window != nil ? window.RootWindowDockTree : nil
	dock_node : ^ImGuiDockNode = window != nil ? window.DockNode : nil
	active_id_window_is_dock_node_host : bool = (g.ActiveIdWindow != nil && dock_node != nil && dock_node.HostWindow == g.ActiveIdWindow)

	// Steal active widgets. Some of the cases it triggers includes:
	// - Focus a window while an InputText in another window is active, if focus happens before the old InputText can run.
	// - When using Nav to activate menu items (due to timing of activating on press->new window appears->losing ActiveId)
	// - Using dock host items (tab, collapse button) can trigger this before we redirect the ActiveIdWindow toward the child window.
	if g.ActiveId != 0 && g.ActiveIdWindow != nil && g.ActiveIdWindow.RootWindow != focus_front_window { if !g.ActiveIdNoClearOnFocusLoss && !active_id_window_is_dock_node_host { ClearActiveID() } }

	// Passing NULL allow to disable keyboard focus
	if window == nil { return }
	window.LastFrameJustFocused = g.FrameCount

	// Select in dock node
	// For #2304 we avoid applying focus immediately before the tabbar is visible.
	//if (dock_node && dock_node->TabBar)
	//    dock_node->TabBar->SelectedTabId = dock_node->TabBar->NextSelectedTabId = window->TabId;

	// Bring to front
	BringWindowToFocusFront(focus_front_window)
	if ((window.Flags | focus_front_window.Flags | display_front_window.Flags) & ImGuiWindowFlags_.ImGuiWindowFlags_NoBringToFrontOnFocus) == {} { BringWindowToDisplayFront(display_front_window) }
}

FocusTopMostWindowUnderOne :: proc(under_this_window : ^ImGuiWindow, ignore_window : ^ImGuiWindow, filter_viewport : ^ImGuiViewport, flags : ImGuiFocusRequestFlags)
{
	g : ^ImGuiContext = GImGui
	start_idx : i32 = g.WindowsFocusOrder.Size - 1
	under_this_window := under_this_window
	if under_this_window != nil {
		// Aim at root window behind us, if we are in a child window that's our own root (see #4640)
		offset : i32 = -1
		for (under_this_window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_ChildWindow) != {} {
			under_this_window = under_this_window.ParentWindow
			offset = 0
		}

		start_idx = FindWindowFocusIndex(under_this_window) + offset
	}
	for i : i32 = start_idx; i >= 0; i -= 1 {
		// We may later decide to test for different NoXXXInputs based on the active navigation input (mouse vs nav) but that may feel more confusing to the user.
		window : ^ImGuiWindow = g.WindowsFocusOrder.Data[i]
		if window == ignore_window || !window.WasActive { continue }
		if filter_viewport != nil && window.Viewport != filter_viewport { continue }
		if (window.Flags & (ImGuiWindowFlags_.ImGuiWindowFlags_NoMouseInputs | ImGuiWindowFlags_.ImGuiWindowFlags_NoNavInputs)) != (ImGuiWindowFlags_.ImGuiWindowFlags_NoMouseInputs | ImGuiWindowFlags_.ImGuiWindowFlags_NoNavInputs) {
			// FIXME-DOCK: When ImGuiFocusRequestFlags_RestoreFocusedChild is set...
			// This is failing (lagging by one frame) for docked windows.
			// If A and B are docked into window and B disappear, at the NewFrame() call site window->NavLastChildNavWindow will still point to B.
			// We might leverage the tab order implicitly stored in window->DockNodeAsHost->TabBar (essentially the 'most_recently_selected_tab' code in tab bar will do that but on next update)
			// to tell which is the "previous" window. Or we may leverage 'LastFrameFocused/LastFrameJustFocused' and have this function handle child window itself?
			FocusWindow(window, flags)
			return
		}
	}

	FocusWindow(nil, flags)
}

// Keyboard/Gamepad Navigation
// alter visibility of keyboard/gamepad cursor. by default: show when using an arrow key, hide when clicking with mouse.
//-----------------------------------------------------------------------------
// [SECTION] KEYBOARD/GAMEPAD NAVIGATION
//-----------------------------------------------------------------------------

// FIXME-NAV: The existence of SetNavID vs SetFocusID vs FocusWindow() needs to be clarified/reworked.
// In our terminology those should be interchangeable, yet right now this is super confusing.
// Those two functions are merely a legacy artifact, so at minimum naming should be clarified.

SetNavCursorVisible :: proc(visible : bool)
{
	g : ^ImGuiContext = GImGui
	visible := visible
	if g.IO.ConfigNavCursorVisibleAlways { visible = true }
	g.NavCursorVisible = visible
}

// (was called NavRestoreHighlightAfterMove() before 1.91.4)
SetNavCursorVisibleAfterMove :: proc()
{
	g : ^ImGuiContext = GImGui
	if g.IO.ConfigNavCursorVisibleAuto { g.NavCursorVisible = true }
	g.NavMousePosDirty = true; g.NavHighlightItemUnderNav = g.NavMousePosDirty
}

SetNavWindow :: proc(window : ^ImGuiWindow)
{
	g : ^ImGuiContext = GImGui
	if g.NavWindow != window {
		IMGUI_DEBUG_LOG_FOCUS(g, "[focus] SetNavWindow(\"%s\")\n", window != nil ? window.Name : "<NULL>")
		g.NavWindow = window
		g.NavLastValidSelectionUserData = ImGuiSelectionUserData_Invalid
	}
	g.NavMoveScoringItems = false; g.NavMoveSubmitted = g.NavMoveScoringItems; g.NavInitRequest = g.NavMoveSubmitted
	NavUpdateAnyRequestFlag()
}

NavHighlightActivated :: proc(id : ImGuiID)
{
	g : ^ImGuiContext = GImGui
	g.NavHighlightActivatedId = id
	g.NavHighlightActivatedTimer = NAV_ACTIVATE_HIGHLIGHT_TIMER
}

NavClearPreferredPosForAxis :: proc(axis : ImGuiAxis)
{
	g : ^ImGuiContext = GImGui
	g.NavWindow.RootWindowForNav.NavPreferredScoringPosRel[g.NavLayer][axis] = FLT_MAX
}

SetNavID :: proc(id : ImGuiID, nav_layer : ImGuiNavLayer, focus_scope_id : ImGuiID, rect_rel : ImRect)
{
	g : ^ImGuiContext = GImGui
	IM_ASSERT(g.NavWindow != nil)
	IM_ASSERT(nav_layer == ImGuiNavLayer.ImGuiNavLayer_Main || nav_layer == ImGuiNavLayer.ImGuiNavLayer_Menu)
	g.NavId = id
	g.NavLayer = nav_layer
	SetNavFocusScope(focus_scope_id)
	g.NavWindow.NavLastIds[nav_layer] = id
	g.NavWindow.NavRectRel[nav_layer] = rect_rel

	// Clear preferred scoring position (NavMoveRequestApplyResult() will tend to restore it)
	NavClearPreferredPosForAxis(ImGuiAxis.ImGuiAxis_X)
	NavClearPreferredPosForAxis(ImGuiAxis.ImGuiAxis_Y)
}

SetFocusID :: proc(id : ImGuiID, window : ^ImGuiWindow)
{
	g : ^ImGuiContext = GImGui
	IM_ASSERT(id != 0)

	if g.NavWindow != window { SetNavWindow(window) }

	// Assume that SetFocusID() is called in the context where its window->DC.NavLayerCurrent and g.CurrentFocusScopeId are valid.
	// Note that window may be != g.CurrentWindow (e.g. SetFocusID call in InputTextEx for multi-line text)
	nav_layer : ImGuiNavLayer = window.DC.NavLayerCurrent
	g.NavId = id
	g.NavLayer = nav_layer
	SetNavFocusScope(g.CurrentFocusScopeId)
	window.NavLastIds[nav_layer] = id
	if g.LastItemData.ID == id { window.NavRectRel[nav_layer] = WindowRectAbsToRel(window, g.LastItemData.NavRect) }

	if g.ActiveIdSource == ImGuiInputSource.ImGuiInputSource_Keyboard || g.ActiveIdSource == ImGuiInputSource.ImGuiInputSource_Gamepad { g.NavHighlightItemUnderNav = true }
	else if g.IO.ConfigNavCursorVisibleAuto { g.NavCursorVisible = false }

	// Clear preferred scoring position (NavMoveRequestApplyResult() will tend to restore it)
	NavClearPreferredPosForAxis(ImGuiAxis.ImGuiAxis_X)
	NavClearPreferredPosForAxis(ImGuiAxis.ImGuiAxis_Y)
}

ImGetDirQuadrantFromDelta :: proc(dx : f32, dy : f32) -> ImGuiDir
{
	if ImFabs(dx) > ImFabs(dy) { return (dx > 0.0) ? ImGuiDir.ImGuiDir_Right : ImGuiDir.ImGuiDir_Left }
	return (dy > 0.0) ? ImGuiDir.ImGuiDir_Down : ImGuiDir.ImGuiDir_Up
}

NavScoreItemDistInterval :: #force_inline proc(cand_min : f32, cand_max : f32, curr_min : f32, curr_max : f32) -> f32
{
	if cand_max < curr_min { return cand_max - curr_min }
	if curr_max < cand_min { return cand_min - curr_max }
	return 0.0
}

// Scoring function for keyboard/gamepad directional navigation. Based on https://gist.github.com/rygorous/6981057
NavScoreItem :: proc(result : ^ImGuiNavItemData) -> bool
{
	g : ^ImGuiContext = GImGui
	window : ^ImGuiWindow = g.CurrentWindow
	if g.NavLayer != window.DC.NavLayerCurrent { return false }

	// FIXME: Those are not good variables names
	cand : ImRect = g.LastItemData.NavRect; // Current item nav rectangle
	curr : ImRect = g.NavScoringRect; // Current modified source rect (NB: we've applied Max.x = Min.x in NavUpdate() to inhibit the effect of having varied item width)
	post_incr(&g.NavScoringDebugCount)

	// When entering through a NavFlattened border, we consider child window items as fully clipped for scoring
	if window.ParentWindow == g.NavWindow {
		IM_ASSERT(((window.ChildFlags | g.NavWindow.ChildFlags) & ImGuiChildFlags_.ImGuiChildFlags_NavFlattened) != {})
		if !Overlaps(window.ClipRect, cand) { return false }
		ClipWithFull(&cand, window.ClipRect); // This allows the scored item to not overlap other candidates in the parent window
	}

	// Compute distance between boxes
	// FIXME-NAV: Introducing biases for vertical navigation, needs to be removed.
	dbx : f32 = NavScoreItemDistInterval(cand.Min.x, cand.Max.x, curr.Min.x, curr.Max.x)
	dby : f32 = NavScoreItemDistInterval(ImLerp(cand.Min.y, cand.Max.y, 0.2), ImLerp(cand.Min.y, cand.Max.y, 0.8), ImLerp(curr.Min.y, curr.Max.y, 0.2), ImLerp(curr.Min.y, curr.Max.y, 0.8)); // Scale down on Y to keep using box-distance for vertically touching items
	if dby != 0.0 && dbx != 0.0 { dbx = (dbx / 1000.0) + ((dbx > 0.0) ? +1.0 : -1.0) }
	dist_box : f32 = ImFabs(dbx) + ImFabs(dby)

	// Compute distance between centers (this is off by a factor of 2, but we only compare center distances with each other so it doesn't matter)
	dcx : f32 = (cand.Min.x + cand.Max.x) - (curr.Min.x + curr.Max.x)
	dcy : f32 = (cand.Min.y + cand.Max.y) - (curr.Min.y + curr.Max.y)
	dist_center : f32 = ImFabs(dcx) + ImFabs(dcy); // L1 metric (need this for our connectedness guarantee)

	// Determine which quadrant of 'curr' our candidate item 'cand' lies in based on distance
	quadrant : ImGuiDir
	dax : f32 = 0.0; day : f32 = 0.0; dist_axial : f32 = 0.0
	if dbx != 0.0 || dby != 0.0 {
		// For non-overlapping boxes, use distance between boxes
		// FIXME-NAV: Quadrant may be incorrect because of (1) dbx bias and (2) curr.Max.y bias applied by NavBiasScoringRect() where typically curr.Max.y==curr.Min.y
		// One typical case where this happens, with style.WindowMenuButtonPosition == ImGuiDir_Right, pressing Left to navigate from Close to Collapse tends to fail.
		// Also see #6344. Calling ImGetDirQuadrantFromDelta() with unbiased values may be good but side-effects are plenty.
		dax = dbx
		day = dby
		dist_axial = dist_box
		quadrant = ImGetDirQuadrantFromDelta(dbx, dby)
	}
	else if dcx != 0.0 || dcy != 0.0 {
		// For overlapping boxes with different centers, use distance between centers
		dax = dcx
		day = dcy
		dist_axial = dist_center
		quadrant = ImGetDirQuadrantFromDelta(dcx, dcy)
	}
	else {
		// Degenerate case: two overlapping buttons with same center, break ties arbitrarily (note that LastItemId here is really the _previous_ item order, but it doesn't matter)
		quadrant = (g.LastItemData.ID < g.NavId) ? ImGuiDir.ImGuiDir_Left : ImGuiDir.ImGuiDir_Right
	}

	move_dir : ImGuiDir = g.NavMoveDir
	when IMGUI_DEBUG_NAV_SCORING {
	buf : [200]u8
	if g.IO.KeyCtrl {
		// Hold CTRL to preview score in matching quadrant. CTRL+Arrow to rotate.
		if quadrant == move_dir {
			ImFormatString(buf, IM_ARRAYSIZE(buf), "%.0f/%.0f", dist_box, dist_center)
			draw_list : ^ImDrawList = GetForegroundDrawList(window)
			AddRectFilled(draw_list, cand.Min, cand.Max, IM_COL32(255, 0, 0, 80))
			AddRectFilled(draw_list, cand.Min, cand.Min + CalcTextSize(buf), IM_COL32(255, 0, 0, 200))
			AddText(draw_list, cand.Min, IM_COL32(255, 255, 255, 255), buf)
		}
	}
	debug_hovering : bool = IsMouseHoveringRect(cand.Min, cand.Max)
	debug_tty : bool = (g.IO.KeyCtrl && IsKeyPressed(ImGuiKey.ImGuiKey_Space))
	if debug_hovering || debug_tty {
		ImFormatString(buf, IM_ARRAYSIZE(buf), "d-box    (%7.3f,%7.3f) -> %7.3f\nd-center (%7.3f,%7.3f) -> %7.3f\nd-axial  (%7.3f,%7.3f) -> %7.3f\nnav %c, quadrant %c", dbx, dby, dist_box, dcx, dcy, dist_center, dax, day, dist_axial, "-WENS"[move_dir + 1], "-WENS"[quadrant + 1])
		if debug_hovering {
			draw_list : ^ImDrawList = GetForegroundDrawList(window)
			AddRect(draw_list, curr.Min, curr.Max, IM_COL32(255, 200, 0, 100))
			AddRect(draw_list, cand.Min, cand.Max, IM_COL32(255, 255, 0, 200))
			AddRectFilled(draw_list, cand.Max - ImVec2{4, 4}, cand.Max + CalcTextSize(buf) + ImVec2{4, 4}, IM_COL32(40, 0, 0, 200))
			AddText(draw_list, cand.Max, ~0, buf)
		}
		if debug_tty { IMGUI_DEBUG_LOG_NAV(g, "id 0x%08X\n%s\n", g.LastItemData.ID, buf) }
	}
	} // preproc endif

	// Is it in the quadrant we're interested in moving to?
	new_best : bool = false
	if quadrant == move_dir {
		// Does it beat the current best candidate?
		if dist_box < result.DistBox {
			result.DistBox = dist_box
			result.DistCenter = dist_center
			return true
		}
		if dist_box == result.DistBox {
			// Try using distance between center points to break ties
			if dist_center < result.DistCenter {
				result.DistCenter = dist_center
				new_best = true
			}
			else if dist_center == result.DistCenter {
				// Still tied! we need to be extra-careful to make sure everything gets linked properly. We consistently break ties by symbolically moving "later" items
				// (with higher index) to the right/downwards by an infinitesimal amount since we the current "best" button already (so it must have a lower index),
				// this is fairly easy. This rule ensures that all buttons with dx==dy==0 will end up being linked in order of appearance along the x axis.
				if ((move_dir == ImGuiDir.ImGuiDir_Up || move_dir == ImGuiDir.ImGuiDir_Down) ? dby : dbx) < 0.0 {
					// moving bj to the right/down decreases distance
					new_best = true
				}
			}
		}
	}

	// Axial check: if 'curr' has no link at all in some direction and 'cand' lies roughly in that direction, add a tentative link. This will only be kept if no "real" matches
	// are found, so it only augments the graph produced by the above method using extra links. (important, since it doesn't guarantee strong connectedness)
	// This is just to avoid buttons having no links in a particular direction when there's a suitable neighbor. you get good graphs without this too.
	// 2017/09/29: FIXME: This now currently only enabled inside menu bars, ideally we'd disable it everywhere. Menus in particular need to catch failure. For general navigation it feels awkward.
	// Disabling it may lead to disconnected graphs when nodes are very spaced out on different axis. Perhaps consider offering this as an option?
	if result.DistBox == FLT_MAX && dist_axial < result.DistAxial {
		// Check axial match
		if g.NavLayer == ImGuiNavLayer.ImGuiNavLayer_Menu && (g.NavWindow.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_ChildMenu) == {} {
			if (move_dir == ImGuiDir.ImGuiDir_Left && dax < 0.0) || (move_dir == ImGuiDir.ImGuiDir_Right && dax > 0.0) || (move_dir == ImGuiDir.ImGuiDir_Up && day < 0.0) || (move_dir == ImGuiDir.ImGuiDir_Down && day > 0.0) {
				result.DistAxial = dist_axial
				new_best = true
			}
		}
	}

	return new_best
}

NavApplyItemToResult :: proc(result : ^ImGuiNavItemData)
{
	g : ^ImGuiContext = GImGui
	window : ^ImGuiWindow = g.CurrentWindow
	result.Window = window
	result.ID = g.LastItemData.ID
	result.FocusScopeId = g.CurrentFocusScopeId
	result.ItemFlags = g.LastItemData.ItemFlags
	result.RectRel = WindowRectAbsToRel(window, g.LastItemData.NavRect)
	if (result.ItemFlags & cast(ImGuiItemFlags) ImGuiItemFlagsPrivate_.ImGuiItemFlags_HasSelectionUserData) != {} {
		IM_ASSERT(g.NextItemData.SelectionUserData != ImGuiSelectionUserData_Invalid)
		result.SelectionUserData = g.NextItemData.SelectionUserData; // INTENTIONAL: At this point this field is not cleared in NextItemData. Avoid unnecessary copy to LastItemData.
	}
}

// True when current work location may be scrolled horizontally when moving left / right.
// This is generally always true UNLESS within a column. We don't have a vertical equivalent.
NavUpdateCurrentWindowIsScrollPushableX :: proc()
{
	g : ^ImGuiContext = GImGui
	window : ^ImGuiWindow = g.CurrentWindow
	window.DC.NavIsScrollPushableX = (g.CurrentTable == nil && window.DC.CurrentColumns == nil)
}

// We get there when either NavId == id, or when g.NavAnyRequest is set (which is updated by NavUpdateAnyRequestFlag above)
// This is called after LastItemData is set, but NextItemData is also still valid.
NavProcessItem :: proc()
{
	g : ^ImGuiContext = GImGui
	window : ^ImGuiWindow = g.CurrentWindow
	id : ImGuiID = g.LastItemData.ID
	item_flags : ImGuiItemFlags = g.LastItemData.ItemFlags

	// When inside a container that isn't scrollable with Left<>Right, clip NavRect accordingly (#2221)
	if window.DC.NavIsScrollPushableX == false {
		g.LastItemData.NavRect.Min.x = ImClamp(g.LastItemData.NavRect.Min.x, window.ClipRect.Min.x, window.ClipRect.Max.x)
		g.LastItemData.NavRect.Max.x = ImClamp(g.LastItemData.NavRect.Max.x, window.ClipRect.Min.x, window.ClipRect.Max.x)
	}
	nav_bb : ImRect = g.LastItemData.NavRect

	// Process Init Request
	if g.NavInitRequest && g.NavLayer == window.DC.NavLayerCurrent && (item_flags & cast(ImGuiItemFlags) ImGuiItemFlagsPrivate_.ImGuiItemFlags_Disabled) == {} {
		// Even if 'ImGuiItemFlags_NoNavDefaultFocus' is on (typically collapse/close button) we record the first ResultId so they can be used as a fallback
		candidate_for_nav_default_focus : bool = (item_flags & ImGuiItemFlags_.ImGuiItemFlags_NoNavDefaultFocus) == {}
		if candidate_for_nav_default_focus || g.NavInitResult.ID == 0 {
			NavApplyItemToResult(&g.NavInitResult)
		}
		if candidate_for_nav_default_focus {
			g.NavInitRequest = false; // Found a match, clear request
			NavUpdateAnyRequestFlag()
		}
	}

	// Process Move Request (scoring for navigation)
	// FIXME-NAV: Consider policy for double scoring (scoring from NavScoringRect + scoring from a rect wrapped according to current wrapping policy)
	if g.NavMoveScoringItems && (item_flags & cast(ImGuiItemFlags)ImGuiItemFlagsPrivate_.ImGuiItemFlags_Disabled) == {} {
		if (g.NavMoveFlags & ImGuiNavMoveFlags_.ImGuiNavMoveFlags_FocusApi) != {} || (window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoNavInputs) == {} {
			is_tabbing : bool = (g.NavMoveFlags & ImGuiNavMoveFlags_.ImGuiNavMoveFlags_IsTabbing) != {}
			if is_tabbing {
				NavProcessItemForTabbingRequest(id, item_flags, g.NavMoveFlags)
			}
			else if g.NavId != id || (g.NavMoveFlags & ImGuiNavMoveFlags_.ImGuiNavMoveFlags_AllowCurrentNavId) != {} {
				result : ^ImGuiNavItemData = (window == g.NavWindow) ? &g.NavMoveResultLocal : &g.NavMoveResultOther
				if NavScoreItem(result) { NavApplyItemToResult(result) }

				// Features like PageUp/PageDown need to maintain a separate score for the visible set of items.
				VISIBLE_RATIO : f32 = 0.70
				if (g.NavMoveFlags & ImGuiNavMoveFlags_.ImGuiNavMoveFlags_AlsoScoreVisibleSet) != {} && Overlaps(window.ClipRect, nav_bb) { if ImClamp(nav_bb.Max.y, window.ClipRect.Min.y, window.ClipRect.Max.y) - ImClamp(nav_bb.Min.y, window.ClipRect.Min.y, window.ClipRect.Max.y) >= (nav_bb.Max.y - nav_bb.Min.y) * VISIBLE_RATIO { if NavScoreItem(&g.NavMoveResultLocalVisible) { NavApplyItemToResult(&g.NavMoveResultLocalVisible) } } }
			}
		}
	}

	// Update information for currently focused/navigated item
	if g.NavId == id {
		if g.NavWindow != window {
			// Always refresh g.NavWindow, because some operations such as FocusItem() may not have a window.
			SetNavWindow(window)
		}
		g.NavLayer = window.DC.NavLayerCurrent
		SetNavFocusScope(g.CurrentFocusScopeId); // Will set g.NavFocusScopeId AND store g.NavFocusScopePath
		g.NavFocusScopeId = g.CurrentFocusScopeId
		g.NavIdIsAlive = true
		if (g.LastItemData.ItemFlags & cast(ImGuiItemFlags) ImGuiItemFlagsPrivate_.ImGuiItemFlags_HasSelectionUserData) != {} {
			IM_ASSERT(g.NextItemData.SelectionUserData != ImGuiSelectionUserData_Invalid)
			g.NavLastValidSelectionUserData = g.NextItemData.SelectionUserData; // INTENTIONAL: At this point this field is not cleared in NextItemData. Avoid unnecessary copy to LastItemData.
		}
		window.NavRectRel[window.DC.NavLayerCurrent] = WindowRectAbsToRel(window, nav_bb); // Store item bounding box (relative to window position)
	}
}

// Handle "scoring" of an item for a tabbing/focusing request initiated by NavUpdateCreateTabbingRequest().
// Note that SetKeyboardFocusHere() API calls are considered tabbing requests!
// - Case 1: no nav/active id:    set result to first eligible item, stop storing.
// - Case 2: tab forward:         on ref id set counter, on counter elapse store result
// - Case 3: tab forward wrap:    set result to first eligible item (preemptively), on ref id set counter, on next frame if counter hasn't elapsed store result. // FIXME-TABBING: Could be done as a next-frame forwarded request
// - Case 4: tab backward:        store all results, on ref id pick prev, stop storing
// - Case 5: tab backward wrap:   store all results, on ref id if no result keep storing until last // FIXME-TABBING: Could be done as next-frame forwarded requested
NavProcessItemForTabbingRequest :: proc(id : ImGuiID, item_flags : ImGuiItemFlags, move_flags : ImGuiNavMoveFlags)
{
	g : ^ImGuiContext = GImGui

	if (move_flags & ImGuiNavMoveFlags_.ImGuiNavMoveFlags_FocusApi) == {} {
		if g.NavLayer != g.CurrentWindow.DC.NavLayerCurrent { return }
		if g.NavFocusScopeId != g.CurrentFocusScopeId { return }
	}

	// - Can always land on an item when using API call.
	// - Tabbing with _NavEnableKeyboard (space/enter/arrows): goes through every item.
	// - Tabbing without _NavEnableKeyboard: goes through inputable items only.
	can_stop : bool
	if (move_flags & ImGuiNavMoveFlags_.ImGuiNavMoveFlags_FocusApi) != {} { can_stop = true }
	else { can_stop = (item_flags & ImGuiItemFlags_.ImGuiItemFlags_NoTabStop) == {} && ((g.IO.ConfigFlags & ImGuiConfigFlags_.ImGuiConfigFlags_NavEnableKeyboard) != {} || (item_flags & cast(ImGuiItemFlags) ImGuiItemFlagsPrivate_.ImGuiItemFlags_Inputable) != {}) }

	// Always store in NavMoveResultLocal (unlike directional request which uses NavMoveResultOther on sibling/flattened windows)
	result : ^ImGuiNavItemData = &g.NavMoveResultLocal
	if g.NavTabbingDir == +1 {
		// Tab Forward or SetKeyboardFocusHere() with >= 0
		if can_stop && g.NavTabbingResultFirst.ID == 0 { NavApplyItemToResult(&g.NavTabbingResultFirst) }
		if can_stop && g.NavTabbingCounter > 0 && pre_decr(&g.NavTabbingCounter) == 0 { NavMoveRequestResolveWithLastItem(result) }
		else if g.NavId == id { g.NavTabbingCounter = 1 }
	}
	else if g.NavTabbingDir == -1 {
		// Tab Backward
		if g.NavId == id {
			if result.ID != 0 {
				g.NavMoveScoringItems = false
				NavUpdateAnyRequestFlag()
			}
		}
		else if can_stop {
			// Keep applying until reaching NavId
			NavApplyItemToResult(result)
		}
	}
	else if g.NavTabbingDir == 0 {
		if can_stop && g.NavId == id { NavMoveRequestResolveWithLastItem(result) }
		if can_stop && g.NavTabbingResultFirst.ID == 0 {
			// Tab init
			NavApplyItemToResult(&g.NavTabbingResultFirst)
		}
	}
}

NavMoveRequestButNoResultYet :: proc() -> bool
{
	g : ^ImGuiContext = GImGui
	return g.NavMoveScoringItems && g.NavMoveResultLocal.ID == 0 && g.NavMoveResultOther.ID == 0
}

// FIXME: ScoringRect is not set
NavMoveRequestSubmit :: proc(move_dir : ImGuiDir, clip_dir : ImGuiDir, move_flags : ImGuiNavMoveFlags, scroll_flags : ImGuiScrollFlags)
{
	g : ^ImGuiContext = GImGui
	IM_ASSERT(g.NavWindow != nil)
	//IMGUI_DEBUG_LOG_NAV(g, "[nav] NavMoveRequestSubmit: dir %c, window \"%s\"\n", "-WENS"[move_dir + 1], g.NavWindow->Name);

	move_flags := move_flags
	if (move_flags & ImGuiNavMoveFlags_.ImGuiNavMoveFlags_IsTabbing) != {} { move_flags |= ImGuiNavMoveFlags_.ImGuiNavMoveFlags_AllowCurrentNavId }

	g.NavMoveScoringItems = true; g.NavMoveSubmitted = g.NavMoveScoringItems
	g.NavMoveDir = move_dir
	g.NavMoveDirForDebug = move_dir
	g.NavMoveClipDir = clip_dir
	g.NavMoveFlags = move_flags
	g.NavMoveScrollFlags = scroll_flags
	g.NavMoveForwardToNextFrame = false
	g.NavMoveKeyMods = (move_flags & ImGuiNavMoveFlags_.ImGuiNavMoveFlags_FocusApi) != {} ? {} : g.IO.KeyMods
	Clear(&g.NavMoveResultLocal)
	Clear(&g.NavMoveResultLocalVisible)
	Clear(&g.NavMoveResultOther)
	g.NavTabbingCounter = 0
	Clear(&g.NavTabbingResultFirst)
	NavUpdateAnyRequestFlag()
}

NavMoveRequestResolveWithLastItem :: proc(result : ^ImGuiNavItemData)
{
	g : ^ImGuiContext = GImGui
	g.NavMoveScoringItems = false; // Ensure request doesn't need more processing
	NavApplyItemToResult(result)
	NavUpdateAnyRequestFlag()
}

// Called by TreePop() to implement ImGuiTreeNodeFlags_NavLeftJumpsBackHere
NavMoveRequestResolveWithPastTreeNode :: proc(result : ^ImGuiNavItemData, tree_node_data : ^ImGuiTreeNodeStackData)
{
	g : ^ImGuiContext = GImGui
	g.NavMoveScoringItems = false
	g.LastItemData.ID = tree_node_data.ID
	g.LastItemData.ItemFlags = tree_node_data.ItemFlags & cast(ImGuiItemFlags) ~cast(i32)ImGuiItemFlagsPrivate_.ImGuiItemFlags_HasSelectionUserData; // Losing SelectionUserData, recovered next-frame (cheaper).
	g.LastItemData.NavRect = tree_node_data.NavRect
	NavApplyItemToResult(result); // Result this instead of implementing a NavApplyPastTreeNodeToResult()
	NavClearPreferredPosForAxis(ImGuiAxis.ImGuiAxis_Y)
	NavUpdateAnyRequestFlag()
}

NavMoveRequestCancel :: proc()
{
	g : ^ImGuiContext = GImGui
	g.NavMoveScoringItems = false; g.NavMoveSubmitted = g.NavMoveScoringItems
	NavUpdateAnyRequestFlag()
}

// Forward will reuse the move request again on the next frame (generally with modifications done to it)
NavMoveRequestForward :: proc(move_dir : ImGuiDir, clip_dir : ImGuiDir, move_flags : ImGuiNavMoveFlags, scroll_flags : ImGuiScrollFlags)
{
	g : ^ImGuiContext = GImGui
	IM_ASSERT(g.NavMoveForwardToNextFrame == false)
	NavMoveRequestCancel()
	g.NavMoveForwardToNextFrame = true
	g.NavMoveDir = move_dir
	g.NavMoveClipDir = clip_dir
	g.NavMoveFlags = move_flags | ImGuiNavMoveFlags_.ImGuiNavMoveFlags_Forwarded
	g.NavMoveScrollFlags = scroll_flags
}

// Navigation wrap-around logic is delayed to the end of the frame because this operation is only valid after entire
// popup is assembled and in case of appended popups it is not clear which EndPopup() call is final.
NavMoveRequestTryWrapping :: proc(window : ^ImGuiWindow, wrap_flags : ImGuiNavMoveFlags)
{
	g : ^ImGuiContext = GImGui
	IM_ASSERT((wrap_flags & ImGuiNavMoveFlags_.ImGuiNavMoveFlags_WrapMask_) != {} && (wrap_flags & cast(ImGuiNavMoveFlags) ~cast(i32)ImGuiNavMoveFlags_.ImGuiNavMoveFlags_WrapMask_) == {}); // Call with _WrapX, _WrapY, _LoopX, _LoopY

	// In theory we should test for NavMoveRequestButNoResultYet() but there's no point doing it:
	// as NavEndFrame() will do the same test. It will end up calling NavUpdateCreateWrappingRequest().
	if g.NavWindow == window && g.NavMoveScoringItems && g.NavLayer == ImGuiNavLayer.ImGuiNavLayer_Main { g.NavMoveFlags = (g.NavMoveFlags & cast(ImGuiNavMoveFlags) ~cast(i32)ImGuiNavMoveFlags_.ImGuiNavMoveFlags_WrapMask_) | wrap_flags }
}

// FIXME: This could be replaced by updating a frame number in each window when (window == NavWindow) and (NavLayer == 0).
// This way we could find the last focused window among our children. It would be much less confusing this way?
NavSaveLastChildNavWindowIntoParent :: proc(nav_window : ^ImGuiWindow)
{
	parent : ^ImGuiWindow = nav_window
	for parent != nil && parent.RootWindow != parent && (parent.Flags & (ImGuiWindowFlags_.ImGuiWindowFlags_Popup | ImGuiWindowFlags_.ImGuiWindowFlags_ChildMenu)) == {} { parent = parent.ParentWindow }

	if parent != nil && parent != nav_window { parent.NavLastChildNavWindow = nav_window }
}

// Restore the last focused child.
// Call when we are expected to land on the Main Layer (0) after FocusWindow()
NavRestoreLastChildNavWindow :: proc(window : ^ImGuiWindow) -> ^ImGuiWindow
{
	if window.NavLastChildNavWindow != nil && window.NavLastChildNavWindow.WasActive { return window.NavLastChildNavWindow }
	if window.DockNodeAsHost != nil && window.DockNodeAsHost.TabBar != nil { if tab : ^ImGuiTabItem = TabBarFindMostRecentlySelectedTabForActiveWindow(window.DockNodeAsHost.TabBar); tab != nil { return tab.Window } }
	return window
}

NavRestoreLayer :: proc(layer : ImGuiNavLayer)
{
	g : ^ImGuiContext = GImGui
	if layer == ImGuiNavLayer.ImGuiNavLayer_Main {
		prev_nav_window : ^ImGuiWindow = g.NavWindow
		g.NavWindow = NavRestoreLastChildNavWindow(g.NavWindow); // FIXME-NAV: Should clear ongoing nav requests?
		g.NavLastValidSelectionUserData = ImGuiSelectionUserData_Invalid
		if prev_nav_window != nil { IMGUI_DEBUG_LOG_FOCUS(g, "[focus] NavRestoreLayer: from \"%s\" to SetNavWindow(\"%s\")\n", prev_nav_window.Name, g.NavWindow.Name) }
	}
	window : ^ImGuiWindow = g.NavWindow
	if window.NavLastIds[layer] != 0 {
		SetNavID(window.NavLastIds[layer], layer, 0, window.NavRectRel[layer])
	}
	else {
		g.NavLayer = layer
		NavInitWindow(window, true)
	}
}

NavUpdateAnyRequestFlag :: #force_inline proc()
{
	g : ^ImGuiContext = GImGui
	g.NavAnyRequest = g.NavMoveScoringItems || g.NavInitRequest || (IMGUI_DEBUG_NAV_SCORING && g.NavWindow != nil)
	if g.NavAnyRequest { IM_ASSERT(g.NavWindow != nil) }
}

// Keyboard/Gamepad Navigation
// This needs to be called before we submit any widget (aka in or before Begin)
NavInitWindow :: proc(window : ^ImGuiWindow, force_reinit : bool)
{
	// FIXME: ChildWindow test here is wrong for docking
	g : ^ImGuiContext = GImGui
	IM_ASSERT(window == g.NavWindow)

	if (window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoNavInputs) != {} {
		g.NavId = 0
		SetNavFocusScope(window.NavRootFocusScopeId)
		return
	}

	init_for_nav : bool = false
	if window == window.RootWindow || (window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_Popup) != {} || (window.NavLastIds[0] == 0) || force_reinit { init_for_nav = true }
	IMGUI_DEBUG_LOG_NAV(g, "[nav] NavInitRequest: from NavInitWindow(), init_for_nav=%d, window=\"%s\", layer=%d\n", init_for_nav, window.Name, g.NavLayer)
	if init_for_nav {
		SetNavID(0, g.NavLayer, window.NavRootFocusScopeId, ImRect{})
		g.NavInitRequest = true
		g.NavInitRequestFromMove = false
		g.NavInitResult.ID = 0
		NavUpdateAnyRequestFlag()
	}
	else {
		g.NavId = window.NavLastIds[0]
		SetNavFocusScope(window.NavRootFocusScopeId)
	}
}

NavCalcPreferredRefPosSource :: proc() -> ImGuiInputSource
{
	g : ^ImGuiContext = GImGui
	window : ^ImGuiWindow = g.NavWindow
	activated_shortcut : bool = g.ActiveId != 0 && g.ActiveIdFromShortcut && g.ActiveId == g.LastItemData.ID

	// Testing for !activated_shortcut here could in theory be removed if we decided that activating a remote shortcut altered one of the g.NavDisableXXX flag.
	if (!g.NavCursorVisible || !g.NavHighlightItemUnderNav || window == nil) && !activated_shortcut { return ImGuiInputSource.ImGuiInputEventType_Mouse }
	else {
		// or Nav in general
		return ImGuiInputSource.ImGuiInputSource_Keyboard
	}
}

NavCalcPreferredRefPos :: proc() -> ImVec2
{
	g : ^ImGuiContext = GImGui
	window : ^ImGuiWindow = g.NavWindow
	source : ImGuiInputSource = NavCalcPreferredRefPosSource()

	activated_shortcut : bool = g.ActiveId != 0 && g.ActiveIdFromShortcut && g.ActiveId == g.LastItemData.ID

	// Testing for !activated_shortcut here could in theory be removed if we decided that activating a remote shortcut altered one of the g.NavDisableXXX flag.
	if source == ImGuiInputSource.ImGuiInputEventType_Mouse {
		// Mouse (we need a fallback in case the mouse becomes invalid after being used)
		// The +1.0f offset when stored by OpenPopupEx() allows reopening this or another popup (same or another mouse button) while not moving the mouse, it is pretty standard.
		// In theory we could move that +1.0f offset in OpenPopupEx()
		p : ImVec2 = IsMousePosValid(&g.IO.MousePos) ? g.IO.MousePos : g.MouseLastValidPos
		return ImVec2{p.x + 1.0, p.y}
	}
	else {
		// When navigation is active and mouse is disabled, pick a position around the bottom left of the currently navigated item
		ref_rect : ImRect
		if activated_shortcut { ref_rect = g.LastItemData.NavRect }
		else { ref_rect = WindowRectRelToAbs(window, window.NavRectRel[g.NavLayer]) }

		// Take account of upcoming scrolling (maybe set mouse pos should be done in EndFrame?)
		if window.LastFrameActive != g.FrameCount && (window.ScrollTarget.x != FLT_MAX || window.ScrollTarget.y != FLT_MAX) {
			next_scroll : ImVec2 = CalcNextScrollFromScrollTargetAndClamp(window)
			Translate(&ref_rect, window.Scroll - next_scroll)
		}
		pos : ImVec2 = ImVec2{ref_rect.Min.x + ImMin(g.Style.FramePadding.x * 4, GetWidth(ref_rect)), ref_rect.Max.y - ImMin(g.Style.FramePadding.y, GetHeight(ref_rect))}
		viewport : ^ImGuiViewport = window.Viewport
		return ImTrunc(ImClamp(pos, viewport.Pos, viewport.Pos + viewport.Size))// ImTrunc() is important because non-integer mouse position application in backend might be lossy and result in undesirable non-zero delta.
	}
}

GetNavTweakPressedAmount :: proc(axis : ImGuiAxis) -> f32
{
	g : ^ImGuiContext = GImGui
	repeat_delay : f32; repeat_rate : f32
	GetTypematicRepeatRate(cast(ImGuiInputFlags)ImGuiInputFlagsPrivate_.ImGuiInputFlags_RepeatRateNavTweak, &repeat_delay, &repeat_rate)

	key_less : ImGuiKey; key_more : ImGuiKey
	if g.NavInputSource == ImGuiInputSource.ImGuiInputSource_Gamepad {
		key_less = (axis == ImGuiAxis.ImGuiAxis_X) ? ImGuiKey.ImGuiKey_GamepadDpadLeft : ImGuiKey.ImGuiKey_GamepadDpadUp
		key_more = (axis == ImGuiAxis.ImGuiAxis_X) ? ImGuiKey.ImGuiKey_GamepadDpadRight : ImGuiKey.ImGuiKey_GamepadDpadDown
	}
	else {
		key_less = (axis == ImGuiAxis.ImGuiAxis_X) ? ImGuiKey.ImGuiKey_LeftArrow : ImGuiKey.ImGuiKey_UpArrow
		key_more = (axis == ImGuiAxis.ImGuiAxis_X) ? ImGuiKey.ImGuiKey_RightArrow : ImGuiKey.ImGuiKey_DownArrow
	}
	amount : f32 = cast(f32) GetKeyPressedAmount(key_more, repeat_delay, repeat_rate) - cast(f32) GetKeyPressedAmount(key_less, repeat_delay, repeat_rate)
	if amount != 0.0 && IsKeyDown(key_less) && IsKeyDown(key_more) {
		// Cancel when opposite directions are held, regardless of repeat phase
		amount = 0.0
	}
	return amount
}

// Navigation
NavUpdate :: proc()
{
	g : ^ImGuiContext = GImGui
	io : ^ImGuiIO = &g.IO

	io.WantSetMousePos = false
	//if (g.NavScoringDebugCount > 0) IMGUI_DEBUG_LOG_NAV(g, "[nav] NavScoringDebugCount %d for '%s' layer %d (Init:%d, Move:%d)\n", g.NavScoringDebugCount, g.NavWindow ? g.NavWindow->Name : "NULL", g.NavLayer, g.NavInitRequest || g.NavInitResultId != 0, g.NavMoveRequest);

	// Set input source based on which keys are last pressed (as some features differs when used with Gamepad vs Keyboard)
	// FIXME-NAV: Now that keys are separated maybe we can get rid of NavInputSource?
	nav_gamepad_active : bool = (io.ConfigFlags & ImGuiConfigFlags_.ImGuiConfigFlags_NavEnableGamepad) != {} && (io.BackendFlags & ImGuiBackendFlags_.ImGuiBackendFlags_HasGamepad) != {}
	nav_gamepad_keys_to_change_source := [?]ImGuiKey{ImGuiKey.ImGuiKey_GamepadFaceRight, ImGuiKey.ImGuiKey_GamepadFaceLeft, ImGuiKey.ImGuiKey_GamepadFaceUp, ImGuiKey.ImGuiKey_GamepadFaceDown, ImGuiKey.ImGuiKey_GamepadDpadRight, ImGuiKey.ImGuiKey_GamepadDpadLeft, ImGuiKey.ImGuiKey_GamepadDpadUp, ImGuiKey.ImGuiKey_GamepadDpadDown}
	if nav_gamepad_active { for key in nav_gamepad_keys_to_change_source { if IsKeyDown(key) { g.NavInputSource = ImGuiInputSource.ImGuiInputSource_Gamepad } } }
	nav_keyboard_active : bool = (io.ConfigFlags & ImGuiConfigFlags_.ImGuiConfigFlags_NavEnableKeyboard) != {}
	nav_keyboard_keys_to_change_source := [?]ImGuiKey{ImGuiKey.ImGuiKey_Space, ImGuiKey.ImGuiKey_Enter, ImGuiKey.ImGuiKey_Escape, ImGuiKey.ImGuiKey_RightArrow, ImGuiKey.ImGuiKey_LeftArrow, ImGuiKey.ImGuiKey_UpArrow, ImGuiKey.ImGuiKey_DownArrow}
	if nav_keyboard_active { for key in nav_keyboard_keys_to_change_source { if IsKeyDown(key) { g.NavInputSource = ImGuiInputSource.ImGuiInputSource_Keyboard } } }

	// Process navigation init request (select first/default focus)
	g.NavJustMovedToId = 0
	g.NavJustMovedFromFocusScopeId = 0; g.NavJustMovedToFocusScopeId = g.NavJustMovedFromFocusScopeId
	if g.NavInitResult.ID != 0 { NavInitRequestApplyResult() }
	g.NavInitRequest = false
	g.NavInitRequestFromMove = false
	g.NavInitResult.ID = 0

	// Process navigation move request
	if g.NavMoveSubmitted { NavMoveRequestApplyResult() }
	g.NavTabbingCounter = 0
	g.NavMoveScoringItems = false; g.NavMoveSubmitted = g.NavMoveScoringItems
	if g.NavCursorHideFrames > 0 { if pre_decr(&g.NavCursorHideFrames) == 0 { g.NavCursorVisible = true } }

	// Schedule mouse position update (will be done at the bottom of this function, after 1) processing all move requests and 2) updating scrolling)
	set_mouse_pos : bool = false
	if g.NavMousePosDirty && g.NavIdIsAlive { if g.NavCursorVisible && g.NavHighlightItemUnderNav && g.NavWindow != nil { set_mouse_pos = true } }
	g.NavMousePosDirty = false
	IM_ASSERT(g.NavLayer == ImGuiNavLayer.ImGuiNavLayer_Main || g.NavLayer == ImGuiNavLayer.ImGuiNavLayer_Menu)

	// Store our return window (for returning from Menu Layer to Main Layer) and clear it as soon as we step back in our own Layer 0
	if g.NavWindow != nil { NavSaveLastChildNavWindowIntoParent(g.NavWindow) }
	if g.NavWindow != nil && g.NavWindow.NavLastChildNavWindow != nil && g.NavLayer == ImGuiNavLayer.ImGuiNavLayer_Main { g.NavWindow.NavLastChildNavWindow = nil }

	// Update CTRL+TAB and Windowing features (hold Square to move/resize/etc.)
	NavUpdateWindowing()

	// Set output flags for user application
	io.NavActive = (nav_keyboard_active || nav_gamepad_active) && g.NavWindow != nil && (g.NavWindow.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoNavInputs) == {}
	io.NavVisible = (io.NavActive && g.NavId != 0 && g.NavCursorVisible) || (g.NavWindowingTarget != nil)

	// Process NavCancel input (to close a popup, get back to parent, clear focus)
	NavUpdateCancelRequest()

	// Process manual activation request
	g.NavActivatePressedId = 0; g.NavActivateDownId = g.NavActivatePressedId; g.NavActivateId = g.NavActivateDownId
	g.NavActivateFlags = ImGuiActivateFlags_.ImGuiActivateFlags_None
	if g.NavId != 0 && g.NavCursorVisible && g.NavWindowingTarget == nil && g.NavWindow != nil && (g.NavWindow.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoNavInputs) == {} {
		activate_down : bool = (nav_keyboard_active && IsKeyDown(ImGuiKey.ImGuiKey_Space, ImGuiKeyOwner_NoOwner)) || (nav_gamepad_active && IsKeyDown(ImGuiKey_NavGamepadActivate(g), ImGuiKeyOwner_NoOwner))
		activate_pressed : bool = activate_down && ((nav_keyboard_active && IsKeyPressed(ImGuiKey.ImGuiKey_Space, ImGuiInputFlags{}, ImGuiKeyOwner_NoOwner)) || (nav_gamepad_active && IsKeyPressed(ImGuiKey_NavGamepadActivate(g), ImGuiInputFlags{}, ImGuiKeyOwner_NoOwner)))
		input_down : bool = (nav_keyboard_active && (IsKeyDown(ImGuiKey.ImGuiKey_Enter, ImGuiKeyOwner_NoOwner) || IsKeyDown(ImGuiKey.ImGuiKey_KeypadEnter, ImGuiKeyOwner_NoOwner))) || (nav_gamepad_active && IsKeyDown(ImGuiKey_NavGamepadInput, ImGuiKeyOwner_NoOwner))
		input_pressed : bool = input_down && ((nav_keyboard_active && (IsKeyPressed(ImGuiKey.ImGuiKey_Enter, ImGuiInputFlags{}, ImGuiKeyOwner_NoOwner) || IsKeyPressed(ImGuiKey.ImGuiKey_KeypadEnter, ImGuiInputFlags{}, ImGuiKeyOwner_NoOwner))) || (nav_gamepad_active && IsKeyPressed(ImGuiKey_NavGamepadInput, ImGuiInputFlags{}, ImGuiKeyOwner_NoOwner)))
		if g.ActiveId == 0 && activate_pressed {
			g.NavActivateId = g.NavId
			g.NavActivateFlags = ImGuiActivateFlags_.ImGuiActivateFlags_PreferTweak
		}
		if (g.ActiveId == 0 || g.ActiveId == g.NavId) && input_pressed {
			g.NavActivateId = g.NavId
			g.NavActivateFlags = ImGuiActivateFlags_.ImGuiActivateFlags_PreferInput
		}
		if (g.ActiveId == 0 || g.ActiveId == g.NavId) && (activate_down || input_down) { g.NavActivateDownId = g.NavId }
		if (g.ActiveId == 0 || g.ActiveId == g.NavId) && (activate_pressed || input_pressed) {
			g.NavActivatePressedId = g.NavId
			NavHighlightActivated(g.NavId)
		}
	}
	if g.NavWindow != nil && (g.NavWindow.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoNavInputs) != {} { g.NavCursorVisible = false }
	else if g.IO.ConfigNavCursorVisibleAlways && g.NavCursorHideFrames == 0 { g.NavCursorVisible = true }
	if g.NavActivateId != 0 { IM_ASSERT(g.NavActivateDownId == g.NavActivateId) }

	// Highlight
	if g.NavHighlightActivatedTimer > 0.0 { g.NavHighlightActivatedTimer = ImMax(f32(0.0), g.NavHighlightActivatedTimer - io.DeltaTime) }
	if g.NavHighlightActivatedTimer == 0.0 { g.NavHighlightActivatedId = 0 }

	// Process programmatic activation request
	// FIXME-NAV: Those should eventually be queued (unlike focus they don't cancel each others)
	if g.NavNextActivateId != 0 {
		g.NavActivatePressedId = g.NavNextActivateId; g.NavActivateDownId = g.NavActivatePressedId; g.NavActivateId = g.NavActivateDownId
		g.NavActivateFlags = g.NavNextActivateFlags
	}
	g.NavNextActivateId = 0

	// Process move requests
	NavUpdateCreateMoveRequest()
	if g.NavMoveDir == ImGuiDir.ImGuiDir_None { NavUpdateCreateTabbingRequest() }
	NavUpdateAnyRequestFlag()
	g.NavIdIsAlive = false

	// Scrolling
	if g.NavWindow != nil && (g.NavWindow.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoNavInputs) == {} && g.NavWindowingTarget == nil {
		// *Fallback* manual-scroll with Nav directional keys when window has no navigable item
		window : ^ImGuiWindow = g.NavWindow
		scroll_speed : f32 = IM_ROUND(CalcFontSize(window) * 100 * io.DeltaTime); // We need round the scrolling speed because sub-pixel scroll isn't reliably supported.
		move_dir : ImGuiDir = g.NavMoveDir
		if window.DC.NavLayersActiveMask == 0x00 && window.DC.NavWindowHasScrollY && move_dir != ImGuiDir.ImGuiDir_None {
			if move_dir == ImGuiDir.ImGuiDir_Left || move_dir == ImGuiDir.ImGuiDir_Right { SetScrollX(window, ImTrunc(window.Scroll.x + ((move_dir == ImGuiDir.ImGuiDir_Left) ? -1.0 : +1.0) * scroll_speed)) }
			if move_dir == ImGuiDir.ImGuiDir_Up || move_dir == ImGuiDir.ImGuiDir_Down { SetScrollY(window, ImTrunc(window.Scroll.y + ((move_dir == ImGuiDir.ImGuiDir_Up) ? -1.0 : +1.0) * scroll_speed)) }
		}

		// *Normal* Manual scroll with LStick
		// Next movement request will clamp the NavId reference rectangle to the visible area, so navigation will resume within those bounds.
		if nav_gamepad_active {
			scroll_dir : ImVec2 = GetKeyMagnitude2d(ImGuiKey.ImGuiKey_GamepadLStickLeft, ImGuiKey.ImGuiKey_GamepadLStickRight, ImGuiKey.ImGuiKey_GamepadLStickUp, ImGuiKey.ImGuiKey_GamepadLStickDown)
			tweak_factor : f32 = IsKeyDown(ImGuiKey_NavGamepadTweakSlow) ? 1.0 / 10.0 : IsKeyDown(ImGuiKey_NavGamepadTweakFast) ? 10.0 : 1.0
			if scroll_dir.x != 0.0 && window.ScrollbarX { SetScrollX(window, ImTrunc(window.Scroll.x + scroll_dir.x * scroll_speed * tweak_factor)) }
			if scroll_dir.y != 0.0 { SetScrollY(window, ImTrunc(window.Scroll.y + scroll_dir.y * scroll_speed * tweak_factor)) }
		}
	}

	// Always prioritize mouse highlight if navigation is disabled
	if !nav_keyboard_active && !nav_gamepad_active {
		g.NavCursorVisible = false
		set_mouse_pos = false; g.NavHighlightItemUnderNav = set_mouse_pos
	}

	// Update mouse position if requested
	// (This will take into account the possibility that a Scroll was queued in the window to offset our absolute mouse position before scroll has been applied)
	if set_mouse_pos && io.ConfigNavMoveSetMousePos && (io.BackendFlags & ImGuiBackendFlags_.ImGuiBackendFlags_HasSetMousePos) != {} { TeleportMousePos(NavCalcPreferredRefPos()) }

	// [DEBUG]
	g.NavScoringDebugCount = 0
	when IMGUI_DEBUG_NAV_RECTS {
	if debug_window : ^ImGuiWindow = g.NavWindow; debug_window != nil {
		draw_list : ^ImDrawList = GetForegroundDrawList(debug_window)
		layer : i32 = g.NavLayer; /* for (int layer = 0; layer < 2; layer++)*/{r : ImRect = WindowRectRelToAbs(debug_window, debug_window.NavRectRel[layer]); AddRect(draw_list, r.Min, r.Max, IM_COL32(255, 200, 0, 255))}
		//if (1) { ImU32 col = (!debug_window->Hidden) ? IM_COL32(255,0,255,255) : IM_COL32(255,0,0,255); ImVec2 p = NavCalcPreferredRefPos(); char Buf.Data[32]; ImFormatString(buf, 32, "%d", g.NavLayer); draw_list->AddCircleFilled(p, 3.0f, col); draw_list->AddText(NULL, 13.0f, p + ImVec2{8,-4}, col, buf); }
	}
	} // preproc endif
}

NavInitRequestApplyResult :: proc()
{
	// In very rare cases g.NavWindow may be null (e.g. clearing focus after requesting an init request, which does happen when releasing Alt while clicking on void)
	g : ^ImGuiContext = GImGui
	if g.NavWindow == nil { return }

	result : ^ImGuiNavItemData = &g.NavInitResult
	if g.NavId != result.ID {
		g.NavJustMovedFromFocusScopeId = g.NavFocusScopeId
		g.NavJustMovedToId = result.ID
		g.NavJustMovedToFocusScopeId = result.FocusScopeId
		g.NavJustMovedToKeyMods = {}
		g.NavJustMovedToIsTabbing = false
		g.NavJustMovedToHasSelectionData = (result.ItemFlags & cast(ImGuiItemFlags) ImGuiItemFlagsPrivate_.ImGuiItemFlags_HasSelectionUserData) != {}
	}

	// Apply result from previous navigation init request (will typically select the first item, unless SetItemDefaultFocus() has been called)
	// FIXME-NAV: On _NavFlattened windows, g.NavWindow will only be updated during subsequent frame. Not a problem currently.
	IMGUI_DEBUG_LOG_NAV(g, "[nav] NavInitRequest: ApplyResult: NavID 0x%08X in Layer %d Window \"%s\"\n", result.ID, g.NavLayer, g.NavWindow.Name)
	SetNavID(result.ID, g.NavLayer, result.FocusScopeId, result.RectRel)
	g.NavIdIsAlive = true; // Mark as alive from previous frame as we got a result
	if result.SelectionUserData != ImGuiSelectionUserData_Invalid { g.NavLastValidSelectionUserData = result.SelectionUserData }
	if g.NavInitRequestFromMove { SetNavCursorVisibleAfterMove() }
}

// Bias scoring rect ahead of scoring + update preferred pos (if missing) using source position
NavBiasScoringRect :: proc(r : ^ImRect, preferred_pos_rel : ^ImVec2, move_dir : ImGuiDir, move_flags : ImGuiNavMoveFlags)
{
	// Bias initial rect
	g : ^ImGuiContext = GImGui
	rel_to_abs_offset : ImVec2 = g.NavWindow.DC.CursorStartPos

	// Initialize bias on departure if we don't have any. So mouse-click + arrow will record bias.
	// - We default to L/U bias, so moving down from a large source item into several columns will land on left-most column.
	// - But each successful move sets new bias on one axis, only cleared when using mouse.
	if (move_flags & ImGuiNavMoveFlags_.ImGuiNavMoveFlags_Forwarded) == {} {
		if preferred_pos_rel.x == FLT_MAX { preferred_pos_rel.x = ImMin(r.Min.x + 1.0, r.Max.x) - rel_to_abs_offset.x }
		if preferred_pos_rel.y == FLT_MAX { preferred_pos_rel.y = GetCenter(r^).y - rel_to_abs_offset.y }
	}

	// Apply general bias on the other axis
	if (move_dir == ImGuiDir.ImGuiDir_Up || move_dir == ImGuiDir.ImGuiDir_Down) && preferred_pos_rel.x != FLT_MAX { r.Max.x = preferred_pos_rel.x + rel_to_abs_offset.x; r.Min.x = r.Max.x }
	else if (move_dir == ImGuiDir.ImGuiDir_Left || move_dir == ImGuiDir.ImGuiDir_Right) && preferred_pos_rel.y != FLT_MAX { r.Max.y = preferred_pos_rel.y + rel_to_abs_offset.y; r.Min.y = r.Max.y }
}

NavUpdateCreateMoveRequest :: proc()
{
	g : ^ImGuiContext = GImGui
	io : ^ImGuiIO = &g.IO
	window : ^ImGuiWindow = g.NavWindow
	nav_gamepad_active : bool = (io.ConfigFlags & ImGuiConfigFlags_.ImGuiConfigFlags_NavEnableGamepad) != {} && (io.BackendFlags & ImGuiBackendFlags_.ImGuiBackendFlags_HasGamepad) != {}
	nav_keyboard_active : bool = (io.ConfigFlags & ImGuiConfigFlags_.ImGuiConfigFlags_NavEnableKeyboard) != {}

	if g.NavMoveForwardToNextFrame && window != nil {
		// Forwarding previous request (which has been modified, e.g. wrap around menus rewrite the requests with a starting rectangle at the other side of the window)
		// (preserve most state, which were already set by the NavMoveRequestForward() function)
		IM_ASSERT(g.NavMoveDir != ImGuiDir.ImGuiDir_None && g.NavMoveClipDir != ImGuiDir.ImGuiDir_None)
		IM_ASSERT((g.NavMoveFlags & ImGuiNavMoveFlags_.ImGuiNavMoveFlags_Forwarded) != {})
		IMGUI_DEBUG_LOG_NAV(g, "[nav] NavMoveRequestForward %d\n", g.NavMoveDir)
	}
	else {
		// Initiate directional inputs request
		g.NavMoveDir = ImGuiDir.ImGuiDir_None
		g.NavMoveFlags = ImGuiNavMoveFlags_.ImGuiNavMoveFlags_None
		g.NavMoveScrollFlags = ImGuiScrollFlags_.ImGuiScrollFlags_None
		if window != nil && g.NavWindowingTarget == nil && (window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoNavInputs) == {} {
			repeat_mode : ImGuiInputFlags = ImGuiInputFlags_.ImGuiInputFlags_Repeat | cast(ImGuiInputFlags) ImGuiInputFlagsPrivate_.ImGuiInputFlags_RepeatRateNavMove
			if !IsActiveIdUsingNavDir(ImGuiDir.ImGuiDir_Left) && ((nav_gamepad_active && IsKeyPressed(ImGuiKey.ImGuiKey_GamepadDpadLeft, repeat_mode, ImGuiKeyOwner_NoOwner)) || (nav_keyboard_active && IsKeyPressed(ImGuiKey.ImGuiKey_LeftArrow, repeat_mode, ImGuiKeyOwner_NoOwner))) { g.NavMoveDir = ImGuiDir.ImGuiDir_Left }
			if !IsActiveIdUsingNavDir(ImGuiDir.ImGuiDir_Right) && ((nav_gamepad_active && IsKeyPressed(ImGuiKey.ImGuiKey_GamepadDpadRight, repeat_mode, ImGuiKeyOwner_NoOwner)) || (nav_keyboard_active && IsKeyPressed(ImGuiKey.ImGuiKey_RightArrow, repeat_mode, ImGuiKeyOwner_NoOwner))) { g.NavMoveDir = ImGuiDir.ImGuiDir_Right }
			if !IsActiveIdUsingNavDir(ImGuiDir.ImGuiDir_Up) && ((nav_gamepad_active && IsKeyPressed(ImGuiKey.ImGuiKey_GamepadDpadUp, repeat_mode, ImGuiKeyOwner_NoOwner)) || (nav_keyboard_active && IsKeyPressed(ImGuiKey.ImGuiKey_UpArrow, repeat_mode, ImGuiKeyOwner_NoOwner))) { g.NavMoveDir = ImGuiDir.ImGuiDir_Up }
			if !IsActiveIdUsingNavDir(ImGuiDir.ImGuiDir_Down) && ((nav_gamepad_active && IsKeyPressed(ImGuiKey.ImGuiKey_GamepadDpadDown, repeat_mode, ImGuiKeyOwner_NoOwner)) || (nav_keyboard_active && IsKeyPressed(ImGuiKey.ImGuiKey_DownArrow, repeat_mode, ImGuiKeyOwner_NoOwner))) { g.NavMoveDir = ImGuiDir.ImGuiDir_Down }
		}
		g.NavMoveClipDir = g.NavMoveDir
		g.NavScoringNoClipRect = ImRect{{+FLT_MAX, +FLT_MAX}, {-FLT_MAX, -FLT_MAX}}
	}

	// Update PageUp/PageDown/Home/End scroll
	// FIXME-NAV: Consider enabling those keys even without the master ImGuiConfigFlags_NavEnableKeyboard flag?
	scoring_rect_offset_y : f32 = 0.0
	if window != nil && g.NavMoveDir == ImGuiDir.ImGuiDir_None && nav_keyboard_active { scoring_rect_offset_y = NavUpdatePageUpPageDown() }
	if scoring_rect_offset_y != 0.0 {
		g.NavScoringNoClipRect = window.InnerRect
		TranslateY(&g.NavScoringNoClipRect, scoring_rect_offset_y)
	}

	// [DEBUG] Always send a request when holding CTRL. Hold CTRL + Arrow change the direction.
	when IMGUI_DEBUG_NAV_SCORING {
	//if (io.KeyCtrl && IsKeyPressed(ImGuiKey_C))
	//    g.NavMoveDirForDebug = (ImGuiDir)((g.NavMoveDirForDebug + 1) & 3);
	if io.KeyCtrl {
		if g.NavMoveDir == ImGuiDir.ImGuiDir_None { g.NavMoveDir = g.NavMoveDirForDebug }
		g.NavMoveClipDir = g.NavMoveDir
		g.NavMoveFlags |= ImGuiNavMoveFlags_.ImGuiNavMoveFlags_DebugNoResult
	}
	} // preproc endif

	// Submit
	g.NavMoveForwardToNextFrame = false
	if g.NavMoveDir != ImGuiDir.ImGuiDir_None { NavMoveRequestSubmit(g.NavMoveDir, g.NavMoveClipDir, g.NavMoveFlags, g.NavMoveScrollFlags) }

	// Moving with no reference triggers an init request (will be used as a fallback if the direction fails to find a match)
	if g.NavMoveSubmitted && g.NavId == 0 {
		IMGUI_DEBUG_LOG_NAV(g, "[nav] NavInitRequest: from move, window \"%s\", layer=%d\n", window != nil ? window.Name : "<NULL>", g.NavLayer)
		g.NavInitRequestFromMove = true; g.NavInitRequest = g.NavInitRequestFromMove
		g.NavInitResult.ID = 0
		if g.IO.ConfigNavCursorVisibleAuto { g.NavCursorVisible = true }
	}

	// When using gamepad, we project the reference nav bounding box into window visible area.
	// This is to allow resuming navigation inside the visible area after doing a large amount of scrolling,
	// since with gamepad all movements are relative (can't focus a visible object like we can with the mouse).
	if g.NavMoveSubmitted && g.NavInputSource == ImGuiInputSource.ImGuiInputSource_Gamepad && g.NavLayer == ImGuiNavLayer.ImGuiNavLayer_Main && window != nil {
		// && (g.NavMoveFlags & ImGuiNavMoveFlags_Forwarded))
		clamp_x : bool = (g.NavMoveFlags & (ImGuiNavMoveFlags_.ImGuiNavMoveFlags_LoopX | ImGuiNavMoveFlags_.ImGuiNavMoveFlags_WrapX)) == {}
		clamp_y : bool = (g.NavMoveFlags & (ImGuiNavMoveFlags_.ImGuiNavMoveFlags_LoopY | ImGuiNavMoveFlags_.ImGuiNavMoveFlags_WrapY)) == {}
		inner_rect_rel : ImRect = WindowRectAbsToRel(window, ImRect{window.InnerRect.Min - ImVec2{1, 1}, window.InnerRect.Max + ImVec2{1, 1}})

		// Take account of changing scroll to handle triggering a new move request on a scrolling frame. (#6171)
		// Otherwise 'inner_rect_rel' would be off on the move result frame.
		Translate(&inner_rect_rel, CalcNextScrollFromScrollTargetAndClamp(window) - window.Scroll)

		if (clamp_x || clamp_y) && !Contains(inner_rect_rel, window.NavRectRel[g.NavLayer]) {
			IMGUI_DEBUG_LOG_NAV(g, "[nav] NavMoveRequest: clamp NavRectRel for gamepad move\n")
			pad_x : f32 = ImMin(GetWidth(inner_rect_rel), CalcFontSize(window) * 0.5)
			pad_y : f32 = ImMin(GetHeight(inner_rect_rel), CalcFontSize(window) * 0.5); // Terrible approximation for the intent of starting navigation from first fully visible item
			inner_rect_rel.Min.x = clamp_x ? (inner_rect_rel.Min.x + pad_x) : -FLT_MAX
			inner_rect_rel.Max.x = clamp_x ? (inner_rect_rel.Max.x - pad_x) : +FLT_MAX
			inner_rect_rel.Min.y = clamp_y ? (inner_rect_rel.Min.y + pad_y) : -FLT_MAX
			inner_rect_rel.Max.y = clamp_y ? (inner_rect_rel.Max.y - pad_y) : +FLT_MAX
			ClipWithFull(&window.NavRectRel[g.NavLayer], inner_rect_rel)
			g.NavId = 0
		}
	}

	// For scoring we use a single segment on the left side our current item bounding box (not touching the edge to avoid box overlap with zero-spaced items)
	scoring_rect : ImRect
	if window != nil {
		nav_rect_rel : ImRect = !IsInverted(window.NavRectRel[g.NavLayer]) ? window.NavRectRel[g.NavLayer] : ImRect{}
		scoring_rect = WindowRectRelToAbs(window, nav_rect_rel)
		TranslateY(&scoring_rect, scoring_rect_offset_y)
		if g.NavMoveSubmitted { NavBiasScoringRect(&scoring_rect, &window.RootWindowForNav.NavPreferredScoringPosRel[g.NavLayer], g.NavMoveDir, g.NavMoveFlags) }
		IM_ASSERT(!IsInverted(scoring_rect)); // Ensure we have a non-inverted bounding box here will allow us to remove extraneous ImFabs() calls in NavScoreItem().
		//GetForegroundDrawList()->AddRect(scoring_rect.Min, scoring_rect.Max, IM_COL32(255,200,0,255)); // [DEBUG]
		//if (!g.NavScoringNoClipRect.IsInverted()) { GetForegroundDrawList()->AddRect(g.NavScoringNoClipRect.Min, g.NavScoringNoClipRect.Max, IM_COL32(255, 200, 0, 255)); } // [DEBUG]
	}
	g.NavScoringRect = scoring_rect
	Add(&g.NavScoringNoClipRect, scoring_rect)
}

NavUpdateCreateTabbingRequest :: proc()
{
	g : ^ImGuiContext = GImGui
	window : ^ImGuiWindow = g.NavWindow
	IM_ASSERT(g.NavMoveDir == ImGuiDir.ImGuiDir_None)
	if window == nil || g.NavWindowingTarget != nil || (window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoNavInputs) != {} { return }

	tab_pressed : bool = IsKeyPressed(ImGuiKey.ImGuiKey_Tab, ImGuiInputFlags_.ImGuiInputFlags_Repeat, ImGuiKeyOwner_NoOwner) && !g.IO.KeyCtrl && !g.IO.KeyAlt
	if !tab_pressed { return }

	// Initiate tabbing request
	// (this is ALWAYS ENABLED, regardless of ImGuiConfigFlags_NavEnableKeyboard flag!)
	// See NavProcessItemForTabbingRequest() for a description of the various forward/backward tabbing cases with and without wrapping.
	nav_keyboard_active : bool = (g.IO.ConfigFlags & ImGuiConfigFlags_.ImGuiConfigFlags_NavEnableKeyboard) != {}
	if nav_keyboard_active { g.NavTabbingDir = g.IO.KeyShift ? -1 : (g.NavCursorVisible == false && g.ActiveId == 0) ? 0 : +1 }
	else { g.NavTabbingDir = g.IO.KeyShift ? -1 : (g.ActiveId == 0) ? 0 : +1 }
	move_flags : ImGuiNavMoveFlags = ImGuiNavMoveFlags_.ImGuiNavMoveFlags_IsTabbing | ImGuiNavMoveFlags_.ImGuiNavMoveFlags_Activate
	scroll_flags : ImGuiScrollFlags = window.Appearing ? ImGuiScrollFlags_.ImGuiScrollFlags_KeepVisibleEdgeX | ImGuiScrollFlags_.ImGuiScrollFlags_AlwaysCenterY : ImGuiScrollFlags_.ImGuiScrollFlags_KeepVisibleEdgeX | ImGuiScrollFlags_.ImGuiScrollFlags_KeepVisibleEdgeY
	clip_dir : ImGuiDir = (g.NavTabbingDir < 0) ? ImGuiDir.ImGuiDir_Up : ImGuiDir.ImGuiDir_Down
	NavMoveRequestSubmit(ImGuiDir.ImGuiDir_None, clip_dir, move_flags, scroll_flags); // FIXME-NAV: Once we refactor tabbing, add LegacyApi flag to not activate non-inputable.
	g.NavTabbingCounter = -1
}

// Apply result from previous frame navigation directional move request. Always called from NavUpdate()
NavMoveRequestApplyResult :: proc()
{
	g : ^ImGuiContext = GImGui
	when IMGUI_DEBUG_NAV_SCORING {
	if (g.NavMoveFlags & ImGuiNavMoveFlags_.ImGuiNavMoveFlags_DebugNoResult) != {} {
		// [DEBUG] Scoring all items in NavWindow at all times
		return
	}
	} // preproc endif

	// Select which result to use
	result : ^ImGuiNavItemData = (g.NavMoveResultLocal.ID != 0) ? &g.NavMoveResultLocal : (g.NavMoveResultOther.ID != 0) ? &g.NavMoveResultOther : nil

	// Tabbing forward wrap
	if (g.NavMoveFlags & ImGuiNavMoveFlags_.ImGuiNavMoveFlags_IsTabbing) != {} && result == nil { if (g.NavTabbingCounter == 1 || g.NavTabbingDir == 0) && g.NavTabbingResultFirst.ID != {} { result = &g.NavTabbingResultFirst } }

	// In a situation when there are no results but NavId != 0, re-enable the Navigation highlight (because g.NavId is not considered as a possible result)
	axis : ImGuiAxis = (g.NavMoveDir == ImGuiDir.ImGuiDir_Up || g.NavMoveDir == ImGuiDir.ImGuiDir_Down) ? ImGuiAxis.ImGuiAxis_Y : ImGuiAxis.ImGuiAxis_X
	if result == nil {
		if (g.NavMoveFlags & ImGuiNavMoveFlags_.ImGuiNavMoveFlags_IsTabbing) != {} { g.NavMoveFlags |= ImGuiNavMoveFlags_.ImGuiNavMoveFlags_NoSetNavCursorVisible }
		if g.NavId != 0 && (g.NavMoveFlags & ImGuiNavMoveFlags_.ImGuiNavMoveFlags_NoSetNavCursorVisible) == {} { SetNavCursorVisibleAfterMove() }
		NavClearPreferredPosForAxis(axis); // On a failed move, clear preferred pos for this axis.
		IMGUI_DEBUG_LOG_NAV(g, "[nav] NavMoveSubmitted but not led to a result!\n")
		return
	}

	// PageUp/PageDown behavior first jumps to the bottom/top mostly visible item, _otherwise_ use the result from the previous/next page.
	if (g.NavMoveFlags & ImGuiNavMoveFlags_.ImGuiNavMoveFlags_AlsoScoreVisibleSet) != {} { if g.NavMoveResultLocalVisible.ID != 0 && g.NavMoveResultLocalVisible.ID != g.NavId { result = &g.NavMoveResultLocalVisible } }

	// Maybe entering a flattened child from the outside? In this case solve the tie using the regular scoring rules.
	if result != &g.NavMoveResultOther && g.NavMoveResultOther.ID != 0 && g.NavMoveResultOther.Window.ParentWindow == g.NavWindow { if (g.NavMoveResultOther.DistBox < result.DistBox) || (g.NavMoveResultOther.DistBox == result.DistBox && g.NavMoveResultOther.DistCenter < result.DistCenter) { result = &g.NavMoveResultOther } }
	IM_ASSERT(g.NavWindow != nil && result.Window != nil)

	// Scroll to keep newly navigated item fully into view.
	if g.NavLayer == ImGuiNavLayer.ImGuiNavLayer_Main {
		rect_abs : ImRect = WindowRectRelToAbs(result.Window, result.RectRel)
		ScrollToRectEx(result.Window, rect_abs, g.NavMoveScrollFlags)

		if (g.NavMoveFlags & ImGuiNavMoveFlags_.ImGuiNavMoveFlags_ScrollToEdgeY) != {} {
			// FIXME: Should remove this? Or make more precise: use ScrollToRectEx() with edge?
			scroll_target : f32 = (g.NavMoveDir == ImGuiDir.ImGuiDir_Up) ? result.Window.ScrollMax.y : 0.0
			SetScrollY(result.Window, scroll_target)
		}
	}

	if g.NavWindow != result.Window {
		IMGUI_DEBUG_LOG_FOCUS(g, "[focus] NavMoveRequest: SetNavWindow(\"%s\")\n", result.Window.Name)
		g.NavWindow = result.Window
		g.NavLastValidSelectionUserData = ImGuiSelectionUserData_Invalid
	}

	// Clear active id unless requested not to
	// FIXME: ImGuiNavMoveFlags_NoClearActiveId is currently unused as we don't have a clear strategy to preserve active id after interaction,
	// so this is mostly provided as a gateway for further experiments (see #1418, #2890)
	if g.ActiveId != result.ID && (g.NavMoveFlags & ImGuiNavMoveFlags_.ImGuiNavMoveFlags_NoClearActiveId) == {} { ClearActiveID() }

	// Don't set NavJustMovedToId if just landed on the same spot (which may happen with ImGuiNavMoveFlags_AllowCurrentNavId)
	// PageUp/PageDown however sets always set NavJustMovedTo (vs Home/End which doesn't) mimicking Windows behavior.
	if (g.NavId != result.ID || (g.NavMoveFlags & ImGuiNavMoveFlags_.ImGuiNavMoveFlags_IsPageMove) != {}) && (g.NavMoveFlags & ImGuiNavMoveFlags_.ImGuiNavMoveFlags_NoSelect) == {} {
		g.NavJustMovedFromFocusScopeId = g.NavFocusScopeId
		g.NavJustMovedToId = result.ID
		g.NavJustMovedToFocusScopeId = result.FocusScopeId
		g.NavJustMovedToKeyMods = g.NavMoveKeyMods
		g.NavJustMovedToIsTabbing = (g.NavMoveFlags & ImGuiNavMoveFlags_.ImGuiNavMoveFlags_IsTabbing) != {}
		g.NavJustMovedToHasSelectionData = (result.ItemFlags & cast(ImGuiItemFlags) ImGuiItemFlagsPrivate_.ImGuiItemFlags_HasSelectionUserData) != {}
		//IMGUI_DEBUG_LOG_NAV(g, "[nav] NavJustMovedFromFocusScopeId = 0x%08X, NavJustMovedToFocusScopeId = 0x%08X\n", g.NavJustMovedFromFocusScopeId, g.NavJustMovedToFocusScopeId);
	}

	// Apply new NavID/Focus
	IMGUI_DEBUG_LOG_NAV(g, "[nav] NavMoveRequest: result NavID 0x%08X in Layer %d Window \"%s\"\n", result.ID, g.NavLayer, g.NavWindow.Name)
	preferred_scoring_pos_rel : ImVec2 = g.NavWindow.RootWindowForNav.NavPreferredScoringPosRel[g.NavLayer]
	SetNavID(result.ID, g.NavLayer, result.FocusScopeId, result.RectRel)
	if result.SelectionUserData != ImGuiSelectionUserData_Invalid { g.NavLastValidSelectionUserData = result.SelectionUserData }

	// Restore last preferred position for current axis
	// (storing in RootWindowForNav-> as the info is desirable at the beginning of a Move Request. In theory all storage should use RootWindowForNav..)
	if (g.NavMoveFlags & ImGuiNavMoveFlags_.ImGuiNavMoveFlags_IsTabbing) == {} {
		preferred_scoring_pos_rel[axis] = GetCenter(result.RectRel)[axis]
		g.NavWindow.RootWindowForNav.NavPreferredScoringPosRel[g.NavLayer] = preferred_scoring_pos_rel
	}

	// Tabbing: Activates Inputable, otherwise only Focus
	if (g.NavMoveFlags & ImGuiNavMoveFlags_.ImGuiNavMoveFlags_IsTabbing) != {} && (result.ItemFlags & cast(ImGuiItemFlags) ImGuiItemFlagsPrivate_.ImGuiItemFlags_Inputable) == {} { g.NavMoveFlags &= cast(ImGuiNavMoveFlags)~cast(i32)ImGuiNavMoveFlags_.ImGuiNavMoveFlags_Activate }

	// Activate
	if (g.NavMoveFlags & ImGuiNavMoveFlags_.ImGuiNavMoveFlags_Activate) != {} {
		g.NavNextActivateId = result.ID
		g.NavNextActivateFlags = ImGuiActivateFlags_.ImGuiActivateFlags_None
		if (g.NavMoveFlags & ImGuiNavMoveFlags_.ImGuiNavMoveFlags_IsTabbing) != {} { g.NavNextActivateFlags |= ImGuiActivateFlags_.ImGuiActivateFlags_PreferInput | ImGuiActivateFlags_.ImGuiActivateFlags_TryToPreserveState | ImGuiActivateFlags_.ImGuiActivateFlags_FromTabbing }
	}

	// Make nav cursor visible
	if (g.NavMoveFlags & ImGuiNavMoveFlags_.ImGuiNavMoveFlags_NoSetNavCursorVisible) == {} { SetNavCursorVisibleAfterMove() }
}

// Process Escape/NavCancel input (to close a popup, get back to parent, clear focus)
// FIXME: In order to support e.g. Escape to clear a selection we'll need:
// - either to store the equivalent of ActiveIdUsingKeyInputMask for a FocusScope and test for it.
// - either to move most/all of those tests to the epilogue/end functions of the scope they are dealing with (e.g. exit child window in EndChild()) or in EndFrame(), to allow an earlier intercept
NavUpdateCancelRequest :: proc()
{
	g : ^ImGuiContext = GImGui
	nav_gamepad_active : bool = (g.IO.ConfigFlags & ImGuiConfigFlags_.ImGuiConfigFlags_NavEnableGamepad) != {} && (g.IO.BackendFlags & ImGuiBackendFlags_.ImGuiBackendFlags_HasGamepad) != {}
	nav_keyboard_active : bool = (g.IO.ConfigFlags & ImGuiConfigFlags_.ImGuiConfigFlags_NavEnableKeyboard) != {}
	if !(nav_keyboard_active && IsKeyPressed(ImGuiKey.ImGuiKey_Escape, ImGuiInputFlags{}, ImGuiKeyOwner_NoOwner)) && !(nav_gamepad_active && IsKeyPressed(ImGuiKey_NavGamepadCancel(g), ImGuiInputFlags{}, ImGuiKeyOwner_NoOwner)) { return }

	IMGUI_DEBUG_LOG_NAV(g, "[nav] NavUpdateCancelRequest()\n")
	if g.ActiveId != 0 {
		ClearActiveID()
	}
	else if g.NavLayer != ImGuiNavLayer.ImGuiNavLayer_Main {
		// Leave the "menu" layer
		NavRestoreLayer(ImGuiNavLayer.ImGuiNavLayer_Main)
		SetNavCursorVisibleAfterMove()
	}
	else if g.NavWindow != nil && g.NavWindow != g.NavWindow.RootWindow && (g.NavWindow.RootWindowForNav.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_Popup) == {} && g.NavWindow.RootWindowForNav.ParentWindow != nil {
		// Exit child window
		child_window : ^ImGuiWindow = g.NavWindow.RootWindowForNav
		parent_window : ^ImGuiWindow = child_window.ParentWindow
		IM_ASSERT(child_window.ChildId != 0)
		FocusWindow(parent_window)
		SetNavID(child_window.ChildId, ImGuiNavLayer.ImGuiNavLayer_Main, 0, WindowRectAbsToRel(parent_window, Rect(child_window)))
		SetNavCursorVisibleAfterMove()
	}
	else if g.OpenPopupStack.Size > 0 && back(&g.OpenPopupStack).Window != nil && (back(&g.OpenPopupStack).Window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_Modal) == {} {
		// Close open popup/menu
		ClosePopupToLevel(g.OpenPopupStack.Size - 1, true)
	}
	else {
		// Clear NavLastId for popups but keep it for regular child window so we can leave one and come back where we were
		// FIXME-NAV: This should happen on window appearing.
		if g.IO.ConfigNavEscapeClearFocusItem || g.IO.ConfigNavEscapeClearFocusWindow { if g.NavWindow != nil && ((g.NavWindow.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_Popup) != {}) {
		// || !(g.NavWindow->Flags & ImGuiWindowFlags_ChildWindow)))
			g.NavWindow.NavLastIds[0] = 0
		}}

		// Clear nav focus
		if g.IO.ConfigNavEscapeClearFocusItem || g.IO.ConfigNavEscapeClearFocusWindow { g.NavId = 0 }
		if g.IO.ConfigNavEscapeClearFocusWindow { FocusWindow(nil) }
	}
}

// Handle PageUp/PageDown/Home/End keys
// Called from NavUpdateCreateMoveRequest() which will use our output to create a move request
// FIXME-NAV: This doesn't work properly with NavFlattened siblings as we use NavWindow rectangle for reference
// FIXME-NAV: how to get Home/End to aim at the beginning/end of a 2D grid?
NavUpdatePageUpPageDown :: proc() -> f32
{
	g : ^ImGuiContext = GImGui
	window : ^ImGuiWindow = g.NavWindow
	if (window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoNavInputs) != {} || g.NavWindowingTarget != nil { return 0.0 }

	page_up_held : bool = IsKeyDown(ImGuiKey.ImGuiKey_PageUp, ImGuiKeyOwner_NoOwner)
	page_down_held : bool = IsKeyDown(ImGuiKey.ImGuiKey_PageDown, ImGuiKeyOwner_NoOwner)
	home_pressed : bool = IsKeyPressed(ImGuiKey.ImGuiKey_Home, ImGuiInputFlags_.ImGuiInputFlags_Repeat, ImGuiKeyOwner_NoOwner)
	end_pressed : bool = IsKeyPressed(ImGuiKey.ImGuiKey_End, ImGuiInputFlags_.ImGuiInputFlags_Repeat, ImGuiKeyOwner_NoOwner)
	if page_up_held == page_down_held && home_pressed == end_pressed {
		// Proceed if either (not both) are pressed, otherwise early out
		return 0.0
	}

	if g.NavLayer != ImGuiNavLayer.ImGuiNavLayer_Main { NavRestoreLayer(ImGuiNavLayer.ImGuiNavLayer_Main) }

	if window.DC.NavLayersActiveMask == 0x00 && window.DC.NavWindowHasScrollY {
		// Fallback manual-scroll when window has no navigable item
		if IsKeyPressed(ImGuiKey.ImGuiKey_PageUp, ImGuiInputFlags_.ImGuiInputFlags_Repeat, ImGuiKeyOwner_NoOwner) { SetScrollY(window, window.Scroll.y - GetHeight(window.InnerRect)) }
		else if IsKeyPressed(ImGuiKey.ImGuiKey_PageDown, ImGuiInputFlags_.ImGuiInputFlags_Repeat, ImGuiKeyOwner_NoOwner) { SetScrollY(window, window.Scroll.y + GetHeight(window.InnerRect)) }
		else if home_pressed { SetScrollY(window, 0.0) }
		else if end_pressed { SetScrollY(window, window.ScrollMax.y) }
	}
	else {
		nav_rect_rel := &window.NavRectRel[g.NavLayer]
		page_offset_y : f32 = ImMax(f32(0.0), GetHeight(window.InnerRect) - CalcFontSize(window) * 1.0 + GetHeight(nav_rect_rel^))
		nav_scoring_rect_offset_y : f32 = 0.0
		if IsKeyPressed(ImGuiKey.ImGuiKey_PageUp, true) {
			nav_scoring_rect_offset_y = -page_offset_y
			g.NavMoveDir = ImGuiDir.ImGuiDir_Down; // Because our scoring rect is offset up, we request the down direction (so we can always land on the last item)
			g.NavMoveClipDir = ImGuiDir.ImGuiDir_Up
			g.NavMoveFlags = ImGuiNavMoveFlags_.ImGuiNavMoveFlags_AllowCurrentNavId | ImGuiNavMoveFlags_.ImGuiNavMoveFlags_AlsoScoreVisibleSet | ImGuiNavMoveFlags_.ImGuiNavMoveFlags_IsPageMove
		}
		else if IsKeyPressed(ImGuiKey.ImGuiKey_PageDown, true) {
			nav_scoring_rect_offset_y = +page_offset_y
			g.NavMoveDir = ImGuiDir.ImGuiDir_Up; // Because our scoring rect is offset down, we request the up direction (so we can always land on the last item)
			g.NavMoveClipDir = ImGuiDir.ImGuiDir_Down
			g.NavMoveFlags = ImGuiNavMoveFlags_.ImGuiNavMoveFlags_AllowCurrentNavId | ImGuiNavMoveFlags_.ImGuiNavMoveFlags_AlsoScoreVisibleSet | ImGuiNavMoveFlags_.ImGuiNavMoveFlags_IsPageMove
		}
		else if home_pressed {
			// FIXME-NAV: handling of Home/End is assuming that the top/bottom most item will be visible with Scroll.y == 0/ScrollMax.y
			// Scrolling will be handled via the ImGuiNavMoveFlags_ScrollToEdgeY flag, we don't scroll immediately to avoid scrolling happening before nav result.
			// Preserve current horizontal position if we have any.
			nav_rect_rel.Max.y = 0.0; nav_rect_rel.Min.y = nav_rect_rel.Max.y
			if IsInverted(nav_rect_rel^) { nav_rect_rel.Max.x = 0.0; nav_rect_rel.Min.x = nav_rect_rel.Max.x }
			g.NavMoveDir = ImGuiDir.ImGuiDir_Down
			g.NavMoveFlags = ImGuiNavMoveFlags_.ImGuiNavMoveFlags_AllowCurrentNavId | ImGuiNavMoveFlags_.ImGuiNavMoveFlags_ScrollToEdgeY
			// FIXME-NAV: MoveClipDir left to _None, intentional?
		}
		else if end_pressed {
			nav_rect_rel.Max.y = window.ContentSize.y; nav_rect_rel.Min.y = nav_rect_rel.Max.y
			if IsInverted(nav_rect_rel^) { nav_rect_rel.Max.x = 0.0; nav_rect_rel.Min.x = nav_rect_rel.Max.x }
			g.NavMoveDir = ImGuiDir.ImGuiDir_Up
			g.NavMoveFlags = ImGuiNavMoveFlags_.ImGuiNavMoveFlags_AllowCurrentNavId | ImGuiNavMoveFlags_.ImGuiNavMoveFlags_ScrollToEdgeY
			// FIXME-NAV: MoveClipDir left to _None, intentional?
		}
		return nav_scoring_rect_offset_y
	}
	return 0.0
}

NavEndFrame :: proc()
{
	g : ^ImGuiContext = GImGui

	// Show CTRL+TAB list window
	if g.NavWindowingTarget != nil { NavUpdateWindowingOverlay() }

	// Perform wrap-around in menus
	// FIXME-NAV: Wrap may need to apply a weight bias on the other axis. e.g. 4x4 grid with 2 last items missing on last item won't handle LoopY/WrapY correctly.
	// FIXME-NAV: Wrap (not Loop) support could be handled by the scoring function and then WrapX would function without an extra frame.
	if g.NavWindow != nil && NavMoveRequestButNoResultYet() && (g.NavMoveFlags & ImGuiNavMoveFlags_.ImGuiNavMoveFlags_WrapMask_) != {} && (g.NavMoveFlags & ImGuiNavMoveFlags_.ImGuiNavMoveFlags_Forwarded) == {} { NavUpdateCreateWrappingRequest() }
}

NavUpdateCreateWrappingRequest :: proc()
{
	g : ^ImGuiContext = GImGui
	window : ^ImGuiWindow = g.NavWindow

	do_forward : bool = false
	bb_rel : ImRect = window.NavRectRel[g.NavLayer]
	clip_dir : ImGuiDir = g.NavMoveDir

	move_flags : ImGuiNavMoveFlags = g.NavMoveFlags
	//const ImGuiAxis move_axis = (g.NavMoveDir == ImGuiDir_Up || g.NavMoveDir == ImGuiDir_Down) ? ImGuiAxis_Y : ImGuiAxis_X;
	if g.NavMoveDir == ImGuiDir.ImGuiDir_Left && (move_flags & (ImGuiNavMoveFlags_.ImGuiNavMoveFlags_WrapX | ImGuiNavMoveFlags_.ImGuiNavMoveFlags_LoopX)) != {} {
		bb_rel.Max.x = window.ContentSize.x + window.WindowPadding.x; bb_rel.Min.x = bb_rel.Max.x
		if (move_flags & ImGuiNavMoveFlags_.ImGuiNavMoveFlags_WrapX) != {} {
			TranslateY(&bb_rel, -GetHeight(bb_rel)); // Previous row
			clip_dir = ImGuiDir.ImGuiDir_Up
		}
		do_forward = true
	}
	if g.NavMoveDir == ImGuiDir.ImGuiDir_Right && (move_flags & (ImGuiNavMoveFlags_.ImGuiNavMoveFlags_WrapX | ImGuiNavMoveFlags_.ImGuiNavMoveFlags_LoopX)) != {} {
		bb_rel.Max.x = -window.WindowPadding.x; bb_rel.Min.x = bb_rel.Max.x
		if (move_flags & ImGuiNavMoveFlags_.ImGuiNavMoveFlags_WrapX) != {} {
			TranslateY(&bb_rel, +GetHeight(bb_rel)); // Next row
			clip_dir = ImGuiDir.ImGuiDir_Down
		}
		do_forward = true
	}
	if g.NavMoveDir == ImGuiDir.ImGuiDir_Up && (move_flags & (ImGuiNavMoveFlags_.ImGuiNavMoveFlags_WrapY | ImGuiNavMoveFlags_.ImGuiNavMoveFlags_LoopY)) != {} {
		bb_rel.Max.y = window.ContentSize.y + window.WindowPadding.y; bb_rel.Min.y = bb_rel.Max.y
		if (move_flags & ImGuiNavMoveFlags_.ImGuiNavMoveFlags_WrapY) != {} {
			TranslateX(&bb_rel, -GetWidth(bb_rel)); // Previous column
			clip_dir = ImGuiDir.ImGuiDir_Left
		}
		do_forward = true
	}
	if g.NavMoveDir == ImGuiDir.ImGuiDir_Down && (move_flags & (ImGuiNavMoveFlags_.ImGuiNavMoveFlags_WrapY | ImGuiNavMoveFlags_.ImGuiNavMoveFlags_LoopY)) != {} {
		bb_rel.Max.y = -window.WindowPadding.y; bb_rel.Min.y = bb_rel.Max.y
		if (move_flags & ImGuiNavMoveFlags_.ImGuiNavMoveFlags_WrapY) != {} {
			TranslateX(&bb_rel, +GetWidth(bb_rel)); // Next column
			clip_dir = ImGuiDir.ImGuiDir_Right
		}
		do_forward = true
	}
	if !do_forward { return }
	window.NavRectRel[g.NavLayer] = bb_rel
	NavClearPreferredPosForAxis(ImGuiAxis.ImGuiAxis_X)
	NavClearPreferredPosForAxis(ImGuiAxis.ImGuiAxis_Y)
	NavMoveRequestForward(g.NavMoveDir, clip_dir, move_flags, g.NavMoveScrollFlags)
}

// Can we focus this window with CTRL+TAB (or PadMenu + PadFocusPrev/PadFocusNext)
// Note that NoNavFocus makes the window not reachable with CTRL+TAB but it can still be focused with mouse or programmatically.
// If you want a window to never be focused, you may use the e.g. NoInputs flag.
IsWindowNavFocusable :: proc(window : ^ImGuiWindow) -> bool
{
	return window.WasActive && window == window.RootWindow && (window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoNavFocus) == {}
}

// FIXME-OPT O(N)
FindWindowNavFocusable :: proc(i_start : i32, i_stop : i32, dir : i32) -> ^ImGuiWindow
{
	g : ^ImGuiContext = GImGui
	for i : i32 = i_start; i >= 0 && i < g.WindowsFocusOrder.Size && i != i_stop; i += dir { if IsWindowNavFocusable(g.WindowsFocusOrder.Data[i]) { return g.WindowsFocusOrder.Data[i] } }

	return nil
}

NavUpdateWindowingTarget :: proc(focus_change_dir : i32)
{
	g : ^ImGuiContext = GImGui
	IM_ASSERT(g.NavWindowingTarget != nil)
	if (g.NavWindowingTarget.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_Modal) != {} { return }

	i_current : i32 = FindWindowFocusIndex(g.NavWindowingTarget)
	window_target : ^ImGuiWindow = FindWindowNavFocusable(i_current + focus_change_dir, -INT_MAX, focus_change_dir)
	if window_target == nil { window_target = FindWindowNavFocusable((focus_change_dir < 0) ? (g.WindowsFocusOrder.Size - 1) : 0, i_current, focus_change_dir) }
	if window_target != nil {
		// Don't reset windowing target if there's a single window in the list
		g.NavWindowingTargetAnim = window_target; g.NavWindowingTarget = g.NavWindowingTargetAnim
		g.NavWindowingAccumDeltaSize = ImVec2{0.0, 0.0}; g.NavWindowingAccumDeltaPos = g.NavWindowingAccumDeltaSize
	}
	g.NavWindowingToggleLayer = false
}

// Windowing management mode
// Keyboard: CTRL+Tab (change focus/move/resize), Alt (toggle menu layer)
// Gamepad:  Hold Menu/Square (change focus/move/resize), Tap Menu/Square (toggle menu layer)
NavUpdateWindowing :: proc()
{
	g : ^ImGuiContext = GImGui
	io : ^ImGuiIO = &g.IO

	apply_focus_window : ^ImGuiWindow = nil
	apply_toggle_layer : bool = false

	modal_window : ^ImGuiWindow = GetTopMostPopupModal()
	allow_windowing : bool = (modal_window == nil); // FIXME: This prevent CTRL+TAB from being usable with windows that are inside the Begin-stack of that modal.
	if !allow_windowing { g.NavWindowingTarget = nil }

	// Fade out
	if g.NavWindowingTargetAnim != nil && g.NavWindowingTarget == nil {
		g.NavWindowingHighlightAlpha = ImMax(g.NavWindowingHighlightAlpha - io.DeltaTime * 10.0, 0.0)
		if g.DimBgRatio <= 0.0 && g.NavWindowingHighlightAlpha <= 0.0 { g.NavWindowingTargetAnim = nil }
	}

	// Start CTRL+Tab or Square+L/R window selection
	// (g.ConfigNavWindowingKeyNext/g.ConfigNavWindowingKeyPrev defaults are ImGuiMod_Ctrl|ImGuiKey_Tab and ImGuiMod_Ctrl|ImGuiMod_Shift|ImGuiKey_Tab)
	owner_id : ImGuiID = ImHashStr("###NavUpdateWindowing")
	nav_gamepad_active : bool = (io.ConfigFlags & ImGuiConfigFlags_.ImGuiConfigFlags_NavEnableGamepad) != {} && (io.BackendFlags & ImGuiBackendFlags_.ImGuiBackendFlags_HasGamepad) != {}
	nav_keyboard_active : bool = (io.ConfigFlags & ImGuiConfigFlags_.ImGuiConfigFlags_NavEnableKeyboard) != {}
	keyboard_next_window : bool = allow_windowing && g.ConfigNavWindowingKeyNext != nil && Shortcut(g.ConfigNavWindowingKeyNext, ImGuiInputFlags_.ImGuiInputFlags_Repeat | ImGuiInputFlags_.ImGuiInputFlags_RouteAlways, owner_id)
	keyboard_prev_window : bool = allow_windowing && g.ConfigNavWindowingKeyPrev != nil && Shortcut(g.ConfigNavWindowingKeyPrev, ImGuiInputFlags_.ImGuiInputFlags_Repeat | ImGuiInputFlags_.ImGuiInputFlags_RouteAlways, owner_id)
	start_windowing_with_gamepad : bool = allow_windowing && nav_gamepad_active && g.NavWindowingTarget == nil && IsKeyPressed(ImGuiKey_NavGamepadMenu, ImGuiInputFlags_.ImGuiInputFlags_None)
	start_windowing_with_keyboard : bool = allow_windowing && g.NavWindowingTarget == nil && (keyboard_next_window || keyboard_prev_window); // Note: enabled even without NavEnableKeyboard!
	just_started_windowing_from_null_focus : bool = false
	if start_windowing_with_gamepad || start_windowing_with_keyboard { if window : ^ImGuiWindow = g.NavWindow != nil ? g.NavWindow : FindWindowNavFocusable(g.WindowsFocusOrder.Size - 1, -INT_MAX, -1); window != nil {
	g.NavWindowingTargetAnim = window.RootWindow; g.NavWindowingTarget = g.NavWindowingTargetAnim; // Current location
	g.NavWindowingHighlightAlpha = 0.0; g.NavWindowingTimer = g.NavWindowingHighlightAlpha
	g.NavWindowingAccumDeltaSize = ImVec2{0.0, 0.0}; g.NavWindowingAccumDeltaPos = g.NavWindowingAccumDeltaSize
	g.NavWindowingToggleLayer = start_windowing_with_gamepad ? true : false; // Gamepad starts toggling layer
	g.NavInputSource = start_windowing_with_keyboard ? ImGuiInputSource.ImGuiInputSource_Keyboard : ImGuiInputSource.ImGuiInputSource_Gamepad
	if g.NavWindow == nil { just_started_windowing_from_null_focus = true }

	// Manually register ownership of our mods. Using a global route in the Shortcut() calls instead would probably be correct but may have more side-effects.
	if keyboard_next_window || keyboard_prev_window { SetKeyOwnersForKeyChord((g.ConfigNavWindowingKeyNext | g.ConfigNavWindowingKeyPrev) & ImGuiKey.ImGuiMod_Mask_, owner_id) }
} }

	// Gamepad update
	g.NavWindowingTimer += io.DeltaTime
	if g.NavWindowingTarget != nil && g.NavInputSource == ImGuiInputSource.ImGuiInputSource_Gamepad {
		// Highlight only appears after a brief time holding the button, so that a fast tap on PadMenu (to toggle NavLayer) doesn't add visual noise
		g.NavWindowingHighlightAlpha = ImMax(g.NavWindowingHighlightAlpha, ImSaturate((g.NavWindowingTimer - NAV_WINDOWING_HIGHLIGHT_DELAY) / 0.05))

		// Select window to focus
		focus_change_dir : i32 = cast(i32) IsKeyPressed(ImGuiKey.ImGuiKey_GamepadL1) - cast(i32) IsKeyPressed(ImGuiKey.ImGuiKey_GamepadR1)
		if focus_change_dir != 0 && !just_started_windowing_from_null_focus {
			NavUpdateWindowingTarget(focus_change_dir)
			g.NavWindowingHighlightAlpha = 1.0
		}

		// Single press toggles NavLayer, long press with L/R apply actual focus on release (until then the window was merely rendered top-most)
		if !IsKeyDown(ImGuiKey_NavGamepadMenu) {
			g.NavWindowingToggleLayer &= (g.NavWindowingHighlightAlpha < 1.0); // Once button was held long enough we don't consider it a tap-to-toggle-layer press anymore.
			if g.NavWindowingToggleLayer && g.NavWindow != nil { apply_toggle_layer = true }
			else if !g.NavWindowingToggleLayer { apply_focus_window = g.NavWindowingTarget }
			g.NavWindowingTarget = nil
		}
	}

	// Keyboard: Focus
	if g.NavWindowingTarget != nil && g.NavInputSource == ImGuiInputSource.ImGuiInputSource_Keyboard {
		// Visuals only appears after a brief time after pressing TAB the first time, so that a fast CTRL+TAB doesn't add visual noise
		shared_mods : ImGuiKeyChord = ((g.ConfigNavWindowingKeyNext != {} ? g.ConfigNavWindowingKeyNext : ImGuiKey.ImGuiMod_Mask_) & (g.ConfigNavWindowingKeyPrev != {} ? g.ConfigNavWindowingKeyPrev : ImGuiKey.ImGuiMod_Mask_)) & ImGuiKey.ImGuiMod_Mask_
		IM_ASSERT(shared_mods != {}); // Next/Prev shortcut currently needs a shared modifier to "hold", otherwise Prev actions would keep cycling between two windows.
		g.NavWindowingHighlightAlpha = ImMax(g.NavWindowingHighlightAlpha, ImSaturate((g.NavWindowingTimer - NAV_WINDOWING_HIGHLIGHT_DELAY) / 0.05)); // 1.0f
		if (keyboard_next_window || keyboard_prev_window) && !just_started_windowing_from_null_focus { NavUpdateWindowingTarget(keyboard_next_window ? -1 : +1) }
		else if (io.KeyMods & shared_mods) != shared_mods { apply_focus_window = g.NavWindowingTarget }
	}

	// Keyboard: Press and Release ALT to toggle menu layer
	windowing_toggle_keys := [?]ImGuiKey {ImGuiKey.ImGuiKey_LeftAlt, ImGuiKey.ImGuiKey_RightAlt}
	windowing_toggle_layer_start : bool = false
	if g.NavWindow != nil && (g.NavWindow.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoNavInputs) == {} { for windowing_toggle_key in windowing_toggle_keys { if nav_keyboard_active && IsKeyPressed(windowing_toggle_key, ImGuiInputFlags{}, ImGuiKeyOwner_NoOwner) {
	windowing_toggle_layer_start = true
	g.NavWindowingToggleLayer = true
	g.NavWindowingToggleKey = windowing_toggle_key
	g.NavInputSource = ImGuiInputSource.ImGuiInputSource_Keyboard
	break
} } }
	if g.NavWindowingToggleLayer && g.NavInputSource == ImGuiInputSource.ImGuiInputSource_Keyboard {
		// We cancel toggling nav layer when any text has been typed (generally while holding Alt). (See #370)
		// We cancel toggling nav layer when other modifiers are pressed. (See #4439)
		// - AltGR is Alt+Ctrl on some layout but we can't reliably detect it (not all backends/systems/layout emit it as Alt+Ctrl).
		// We cancel toggling nav layer if an owner has claimed the key.
		if io.InputQueueCharacters.Size > 0 || io.KeyCtrl || io.KeyShift || io.KeySuper { g.NavWindowingToggleLayer = false }
		else if windowing_toggle_layer_start == false && g.LastKeyboardKeyPressTime == g.Time { g.NavWindowingToggleLayer = false }
		else if TestKeyOwner(g.NavWindowingToggleKey, ImGuiKeyOwner_NoOwner) == false || TestKeyOwner(ImGuiKey.ImGuiMod_Alt, ImGuiKeyOwner_NoOwner) == false { g.NavWindowingToggleLayer = false }

		// Apply layer toggle on Alt release
		// Important: as before version <18314 we lacked an explicit IO event for focus gain/loss, we also compare mouse validity to detect old backends clearing mouse pos on focus loss.
		if IsKeyReleased(g.NavWindowingToggleKey) && g.NavWindowingToggleLayer { if g.ActiveId == 0 || g.ActiveIdAllowOverlap { if IsMousePosValid(&io.MousePos) == IsMousePosValid(&io.MousePosPrev) { apply_toggle_layer = true } } }
		if !IsKeyDown(g.NavWindowingToggleKey) { g.NavWindowingToggleLayer = false }
	}

	// Move window
	if g.NavWindowingTarget != nil && (g.NavWindowingTarget.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoMove) == {} {
		nav_move_dir : ImVec2
		if g.NavInputSource == ImGuiInputSource.ImGuiInputSource_Keyboard && !io.KeyShift { nav_move_dir = GetKeyMagnitude2d(ImGuiKey.ImGuiKey_LeftArrow, ImGuiKey.ImGuiKey_RightArrow, ImGuiKey.ImGuiKey_UpArrow, ImGuiKey.ImGuiKey_DownArrow) }
		if g.NavInputSource == ImGuiInputSource.ImGuiInputSource_Gamepad { nav_move_dir = GetKeyMagnitude2d(ImGuiKey.ImGuiKey_GamepadLStickLeft, ImGuiKey.ImGuiKey_GamepadLStickRight, ImGuiKey.ImGuiKey_GamepadLStickUp, ImGuiKey.ImGuiKey_GamepadLStickDown) }
		if nav_move_dir.x != 0.0 || nav_move_dir.y != 0.0 {
			NAV_MOVE_SPEED : f32 = 800.0
			move_step : f32 = NAV_MOVE_SPEED * io.DeltaTime * ImMin(io.DisplayFramebufferScale.x, io.DisplayFramebufferScale.y)
			g.NavWindowingAccumDeltaPos += nav_move_dir * move_step
			g.NavHighlightItemUnderNav = true
			accum_floored : ImVec2 = ImTrunc(g.NavWindowingAccumDeltaPos)
			if accum_floored.x != 0.0 || accum_floored.y != 0.0 {
				moving_window : ^ImGuiWindow = g.NavWindowingTarget.RootWindowDockTree
				SetWindowPos(moving_window, moving_window.Pos + accum_floored, ImGuiCond_.ImGuiCond_Always)
				g.NavWindowingAccumDeltaPos -= accum_floored
			}
		}
	}

	// Apply final focus
	if apply_focus_window != nil && (g.NavWindow == nil || apply_focus_window != g.NavWindow.RootWindow) {
		// FIXME: Many actions here could be part of a higher-level/reused function. Why aren't they in FocusWindow()
		// Investigate for each of them: ClearActiveID(), NavRestoreHighlightAfterMove(), NavRestoreLastChildNavWindow(), ClosePopupsOverWindow(), NavInitWindow()
		previous_viewport : ^ImGuiViewport = g.NavWindow != nil ? g.NavWindow.Viewport : nil
		ClearActiveID()
		SetNavCursorVisibleAfterMove()
		ClosePopupsOverWindow(apply_focus_window, false)
		FocusWindow(apply_focus_window, ImGuiFocusRequestFlags_.ImGuiFocusRequestFlags_RestoreFocusedChild)
		apply_focus_window = g.NavWindow
		if apply_focus_window.NavLastIds[0] == 0 { NavInitWindow(apply_focus_window, false) }

		// If the window has ONLY a menu layer (no main layer), select it directly
		// Use NavLayersActiveMaskNext since windows didn't have a chance to be Begin()-ed on this frame,
		// so CTRL+Tab where the keys are only held for 1 frame will be able to use correct layers mask since
		// the target window as already been previewed once.
		// FIXME-NAV: This should be done in NavInit.. or in FocusWindow... However in both of those cases,
		// we won't have a guarantee that windows has been visible before and therefore NavLayersActiveMask*
		// won't be valid.
		if apply_focus_window.DC.NavLayersActiveMaskNext == (1 << u32(ImGuiNavLayer.ImGuiNavLayer_Menu)) { g.NavLayer = ImGuiNavLayer.ImGuiNavLayer_Menu }

		// Request OS level focus
		if apply_focus_window.Viewport != previous_viewport && g.PlatformIO.Platform_SetWindowFocus != nil { g.PlatformIO.Platform_SetWindowFocus(apply_focus_window.Viewport) }
	}
	if apply_focus_window != nil { g.NavWindowingTarget = nil }

	// Apply menu/layer toggle
	if apply_toggle_layer && g.NavWindow != nil {
		ClearActiveID()

		// Move to parent menu if necessary
		new_nav_window : ^ImGuiWindow = g.NavWindow
		for new_nav_window.ParentWindow != nil && (new_nav_window.DC.NavLayersActiveMask & (1 << u32(ImGuiNavLayer.ImGuiNavLayer_Menu))) == 0 && (new_nav_window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_ChildWindow) != {} && (new_nav_window.Flags & (ImGuiWindowFlags_.ImGuiWindowFlags_Popup | ImGuiWindowFlags_.ImGuiWindowFlags_ChildMenu)) == {} { new_nav_window = new_nav_window.ParentWindow }

		if new_nav_window != g.NavWindow {
			old_nav_window : ^ImGuiWindow = g.NavWindow
			FocusWindow(new_nav_window)
			new_nav_window.NavLastChildNavWindow = old_nav_window
		}

		// Toggle layer
		new_nav_layer : ImGuiNavLayer = (g.NavWindow.DC.NavLayersActiveMask & (1 << u32(ImGuiNavLayer.ImGuiNavLayer_Menu))) != 0 ? cast(ImGuiNavLayer) (cast(i32) g.NavLayer ~ 1) : ImGuiNavLayer.ImGuiNavLayer_Main
		if new_nav_layer != g.NavLayer {
			// Reinitialize navigation when entering menu bar with the Alt key (FIXME: could be a properly of the layer?)
			preserve_layer_1_nav_id : bool = (new_nav_window.DockNodeAsHost != nil)
			if new_nav_layer == ImGuiNavLayer.ImGuiNavLayer_Menu && !preserve_layer_1_nav_id { g.NavWindow.NavLastIds[new_nav_layer] = 0 }
			NavRestoreLayer(new_nav_layer)
			SetNavCursorVisibleAfterMove()
		}
	}
}

// Window has already passed the IsWindowNavFocusable()
GetFallbackWindowNameForWindowingList :: proc(window : ^ImGuiWindow) -> string
{
	if (window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_Popup) != {} { return LocalizeGetMsg(ImGuiLocKey.ImGuiLocKey_WindowingPopup) }
	if (window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_MenuBar) != {} && window.Name == "##MainMenuBar" { return LocalizeGetMsg(ImGuiLocKey.ImGuiLocKey_WindowingMainMenuBar) }
	if window.DockNodeAsHost != nil {
		// Not normally shown to user.
		return "(Dock node)"
	}
	return LocalizeGetMsg(ImGuiLocKey.ImGuiLocKey_WindowingUntitled)
}

// Overlay displayed when using CTRL+TAB. Called by EndFrame().
NavUpdateWindowingOverlay :: proc()
{
	g : ^ImGuiContext = GImGui
	IM_ASSERT(g.NavWindowingTarget != nil)

	if g.NavWindowingTimer < NAV_WINDOWING_LIST_APPEAR_DELAY { return }

	if g.NavWindowingListWindow == nil { g.NavWindowingListWindow = FindWindowByName("###NavWindowingList") }
	viewport : ^ImGuiViewport = GetMainViewport()
	SetNextWindowSizeConstraints(ImVec2{viewport.Size.x * 0.20, viewport.Size.y * 0.20}, ImVec2{FLT_MAX, FLT_MAX})
	SetNextWindowPos(GetCenter(viewport), ImGuiCond_.ImGuiCond_Always, ImVec2{0.5, 0.5})
	PushStyleVar(ImGuiStyleVar_.ImGuiStyleVar_WindowPadding, g.Style.WindowPadding * 2.0)
	Begin("###NavWindowingList", nil, ImGuiWindowFlags_.ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_.ImGuiWindowFlags_NoFocusOnAppearing | ImGuiWindowFlags_.ImGuiWindowFlags_NoResize | ImGuiWindowFlags_.ImGuiWindowFlags_NoMove | ImGuiWindowFlags_.ImGuiWindowFlags_NoInputs | ImGuiWindowFlags_.ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_.ImGuiWindowFlags_NoSavedSettings)
	if g.ContextName[0] != 0 { SeparatorText(string_from_slice(g.ContextName[:])) }
	for n : i32 = g.WindowsFocusOrder.Size - 1; n >= 0; n -= 1 {
		window : ^ImGuiWindow = g.WindowsFocusOrder.Data[n]
		IM_ASSERT(window != nil); // Fix static analyzers
		if !IsWindowNavFocusable(window) { continue }
		label : string = window.Name
		if len(label) == FindRenderedTextEnd(label) { label = GetFallbackWindowNameForWindowingList(window) }
		Selectable(label, g.NavWindowingTarget == window)
	}

	End()
	PopStyleVar()
}

// Drag and Drop
//-----------------------------------------------------------------------------
// [SECTION] DRAG AND DROP
//-----------------------------------------------------------------------------

IsDragDropActive :: proc() -> bool
{
	g : ^ImGuiContext = GImGui
	return g.DragDropActive
}

ClearDragDrop :: proc()
{
	g : ^ImGuiContext = GImGui
	if g.DragDropActive { IMGUI_DEBUG_LOG_ACTIVEID(g, "[dragdrop] ClearDragDrop()\n") }
	g.DragDropActive = false
	Clear(&g.DragDropPayload)
	g.DragDropAcceptFlags = ImGuiDragDropFlags_.ImGuiDragDropFlags_None
	g.DragDropAcceptIdPrev = 0; g.DragDropAcceptIdCurr = g.DragDropAcceptIdPrev
	g.DragDropAcceptIdCurrRectSurface = FLT_MAX
	g.DragDropAcceptFrameCount = -1

	clear(&g.DragDropPayloadBufHeap)
	memset(&g.DragDropPayloadBufLocal, 0, size_of(g.DragDropPayloadBufLocal))
}

BeginTooltipHidden :: proc() -> bool
{
	g : ^ImGuiContext = GImGui
	ret : bool = Begin("##Tooltip_Hidden", nil, ImGuiWindowFlags_.ImGuiWindowFlags_Tooltip | ImGuiWindowFlags_.ImGuiWindowFlags_NoInputs | ImGuiWindowFlags_.ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_.ImGuiWindowFlags_NoMove | ImGuiWindowFlags_.ImGuiWindowFlags_NoResize | ImGuiWindowFlags_.ImGuiWindowFlags_NoSavedSettings | ImGuiWindowFlags_.ImGuiWindowFlags_AlwaysAutoResize)
	SetWindowHiddenAndSkipItemsForCurrentFrame(g.CurrentWindow)
	return ret
}

// Drag and Drop
// - On source items, call BeginDragDropSource(), if it returns true also call SetDragDropPayload() + EndDragDropSource().
// - On target candidates, call BeginDragDropTarget(), if it returns true also call AcceptDragDropPayload() + EndDragDropTarget().
// - If you stop calling BeginDragDropSource() the payload is preserved however it won't have a preview tooltip (we currently display a fallback "..." tooltip, see #1725)
// - An item can be both drag source and drop target.
// call after submitting an item which may be dragged. when this return true, you can call SetDragDropPayload() + EndDragDropSource()
// When this returns true you need to: a) call SetDragDropPayload() exactly once, b) you may render the payload visual/description, c) call EndDragDropSource()
// If the item has an identifier:
// - This assume/require the item to be activated (typically via ButtonBehavior).
// - Therefore if you want to use this with a mouse button other than left mouse button, it is up to the item itself to activate with another button.
// - We then pull and use the mouse button that was used to activate the item and use it to carry on the drag.
// If the item has no identifier:
// - Currently always assume left mouse button.
BeginDragDropSource :: proc(flags : ImGuiDragDropFlags = {}) -> bool
{
	g : ^ImGuiContext = GImGui
	window : ^ImGuiWindow = g.CurrentWindow

	// FIXME-DRAGDROP: While in the common-most "drag from non-zero active id" case we can tell the mouse button,
	// in both SourceExtern and id==0 cases we may requires something else (explicit flags or some heuristic).
	mouse_button : ImGuiMouseButton = ImGuiMouseButton_.ImGuiMouseButton_Left

	source_drag_active : bool = false
	source_id : ImGuiID = 0
	source_parent_id : ImGuiID = 0
	if (flags & ImGuiDragDropFlags_.ImGuiDragDropFlags_SourceExtern) == {} {
		source_id = g.LastItemData.ID
		if source_id != 0 {
			// Common path: items with ID
			if g.ActiveId != source_id { return false }
			if g.ActiveIdMouseButton != cast(ImGuiMouseButton) ~i32(0) { mouse_button = g.ActiveIdMouseButton }
			if g.IO.MouseDown[mouse_button] == false || window.SkipItems { return false }
			g.ActiveIdAllowOverlap = false
		}
		else {
			// Uncommon path: items without ID
			if g.IO.MouseDown[mouse_button] == false || window.SkipItems { return false }
			if (g.LastItemData.StatusFlags & ImGuiItemStatusFlags_.ImGuiItemStatusFlags_HoveredRect) == {} && (g.ActiveId == 0 || g.ActiveIdWindow != window) { return false }

			// If you want to use BeginDragDropSource() on an item with no unique identifier for interaction, such as Text() or Image(), you need to:
			// A) Read the explanation below, B) Use the ImGuiDragDropFlags_SourceAllowNullID flag.
			if (flags & ImGuiDragDropFlags_.ImGuiDragDropFlags_SourceAllowNullID) == {} {
				IM_ASSERT(false)
				return false
			}

			// Magic fallback to handle items with no assigned ID, e.g. Text(), Image()
			// We build a throwaway ID based on current ID stack + relative AABB of items in window.
			// THE IDENTIFIER WON'T SURVIVE ANY REPOSITIONING/RESIZINGG OF THE WIDGET, so if your widget moves your dragging operation will be canceled.
			// We don't need to maintain/call ClearActiveID() as releasing the button will early out this function and trigger !ActiveIdIsAlive.
			// Rely on keeping other window->LastItemXXX fields intact.
			g.LastItemData.ID = GetIDFromRectangle(window, g.LastItemData.Rect); source_id = g.LastItemData.ID
			KeepAliveID(source_id)
			is_hovered : bool = ItemHoverable(g.LastItemData.Rect, source_id, g.LastItemData.ItemFlags)
			if is_hovered && g.IO.MouseClicked[mouse_button] {
				SetActiveID(source_id, window)
				FocusWindow(window)
			}
			if g.ActiveId == source_id {
				// Allow the underlying widget to display/return hovered during the mouse release frame, else we would get a flicker.
				g.ActiveIdAllowOverlap = is_hovered
			}
		}
		if g.ActiveId != source_id { return false }
		source_parent_id = back(&window.IDStack)^
		source_drag_active = IsMouseDragging(mouse_button)

		// Disable navigation and key inputs while dragging + cancel existing request if any
		SetActiveIdUsingAllKeyboardKeys()
	}
	else {
		// When ImGuiDragDropFlags_SourceExtern is set:
		window = nil
		source_id = ImHashStr("#SourceExtern")
		source_drag_active = true
		mouse_button = g.IO.MouseDown[0] ? ImGuiMouseButton(0) : cast(ImGuiMouseButton) ~i32(0)
		KeepAliveID(source_id)
		SetActiveID(source_id, nil)
	}

	IM_ASSERT(g.DragDropWithinTarget == false); // Can't nest BeginDragDropSource() and BeginDragDropTarget()
	if !source_drag_active { return false }

	// Activate drag and drop
	if !g.DragDropActive {
		IM_ASSERT(source_id != 0)
		ClearDragDrop()
		IMGUI_DEBUG_LOG_ACTIVEID(g, "[dragdrop] BeginDragDropSource() DragDropActive = true, source_id = 0x%08X%s\n", source_id, (flags & ImGuiDragDropFlags_.ImGuiDragDropFlags_SourceExtern) != {} ? " (EXTERN)" : "")
		payload : ^ImGuiPayload = &g.DragDropPayload
		payload.SourceId = source_id
		payload.SourceParentId = source_parent_id
		g.DragDropActive = true
		g.DragDropSourceFlags = flags
		g.DragDropMouseButton = mouse_button
		if payload.SourceId == g.ActiveId { g.ActiveIdNoClearOnFocusLoss = true }
	}
	g.DragDropSourceFrameCount = g.FrameCount
	g.DragDropWithinSource = true

	if (flags & ImGuiDragDropFlags_.ImGuiDragDropFlags_SourceNoPreviewTooltip) == {} {
		// Target can request the Source to not display its tooltip (we use a dedicated flag to make this request explicit)
		// We unfortunately can't just modify the source flags and skip the call to BeginTooltip, as caller may be emitting contents.
		ret : bool
		if g.DragDropAcceptIdPrev != 0 && (g.DragDropAcceptFlags & ImGuiDragDropFlags_.ImGuiDragDropFlags_AcceptNoPreviewTooltip) != {} { ret = BeginTooltipHidden() }
		else { ret = BeginTooltip() }
		IM_ASSERT(ret); // FIXME-NEWBEGIN: If this ever becomes false, we need to Begin("##Hidden", NULL, ImGuiWindowFlags_NoSavedSettings) + SetWindowHiddendAndSkipItemsForCurrentFrame().
		IM_UNUSED(ret)
	}

	if (flags & ImGuiDragDropFlags_.ImGuiDragDropFlags_SourceNoDisableHover) == {} && (flags & ImGuiDragDropFlags_.ImGuiDragDropFlags_SourceExtern) == {} { g.LastItemData.StatusFlags &= cast(ImGuiItemStatusFlags)~cast(i32)ImGuiItemStatusFlags_.ImGuiItemStatusFlags_HoveredRect }

	return true
}

// only call EndDragDropSource() if BeginDragDropSource() returns true!
EndDragDropSource :: proc()
{
	g : ^ImGuiContext = GImGui
	IM_ASSERT(g.DragDropActive)
	IM_ASSERT(g.DragDropWithinSource, "Not after a BeginDragDropSource()?")

	if (g.DragDropSourceFlags & ImGuiDragDropFlags_.ImGuiDragDropFlags_SourceNoPreviewTooltip) == {} { EndTooltip() }

	// Discard the drag if have not called SetDragDropPayload()
	if g.DragDropPayload.DataFrameCount == -1 { ClearDragDrop() }
	g.DragDropWithinSource = false
}

// type is a user defined string of maximum 32 characters. Strings starting with '_' are reserved for dear imgui internal types. Data is copied and held by imgui. Return true when payload has been accepted.
// Use 'cond' to choose to submit payload on drag start or every frame
SetDragDropPayload :: proc(type : string, data : rawptr, data_size : uint, cond : ImGuiCond = {}) -> bool
{
	g : ^ImGuiContext = GImGui
	payload : ^ImGuiPayload = &g.DragDropPayload
	cond := cond
	if cond == {} { cond = ImGuiCond_.ImGuiCond_Always }

	IM_ASSERT(type != "")
	IM_ASSERT(len(type) < IM_ARRAYSIZE(payload.DataType), "Payload type can be at most 32 characters long")
	IM_ASSERT((data != nil && data_size > 0) || (data == nil && data_size == 0))
	IM_ASSERT(cond == ImGuiCond_.ImGuiCond_Always || cond == ImGuiCond_.ImGuiCond_Once)
	IM_ASSERT(payload.SourceId != 0); // Not called between BeginDragDropSource() and EndDragDropSource()

	if cond == ImGuiCond_.ImGuiCond_Always || payload.DataFrameCount == -1 {
		// Copy payload
		ImStrncpy(raw_data(&payload.DataType), raw_data(type), cast(uint) IM_ARRAYSIZE(payload.DataType))
		resize(&g.DragDropPayloadBufHeap, 0)
		if data_size > size_of(g.DragDropPayloadBufLocal) {
			// Store in heap
			resize(&g.DragDropPayloadBufHeap, cast(i32) data_size)
			payload.Data = g.DragDropPayloadBufHeap.Data
			memcpy(payload.Data, data, cast(int) data_size)
		}
		else if data_size > 0 {
			// Store locally
			memset(&g.DragDropPayloadBufLocal, 0, size_of(g.DragDropPayloadBufLocal))
			payload.Data = &g.DragDropPayloadBufLocal
			memcpy(payload.Data, data, cast(int) data_size)
		}
		else {
			payload.Data = nil
		}
		payload.DataSize = cast(i32) data_size
	}
	payload.DataFrameCount = g.FrameCount

	// Return whether the payload has been accepted
	return (g.DragDropAcceptFrameCount == g.FrameCount) || (g.DragDropAcceptFrameCount == g.FrameCount - 1)
}

BeginDragDropTargetCustom :: proc(bb : ImRect, id : ImGuiID) -> bool
{
	g : ^ImGuiContext = GImGui
	if !g.DragDropActive { return false }

	window : ^ImGuiWindow = g.CurrentWindow
	hovered_window : ^ImGuiWindow = g.HoveredWindowUnderMovingWindow
	if hovered_window == nil || window.RootWindowDockTree != hovered_window.RootWindowDockTree { return false }
	IM_ASSERT(id != 0)
	if !IsMouseHoveringRect(bb.Min, bb.Max) || (id == g.DragDropPayload.SourceId) { return false }
	if window.SkipItems { return false }

	IM_ASSERT(g.DragDropWithinTarget == false && g.DragDropWithinSource == false); // Can't nest BeginDragDropSource() and BeginDragDropTarget()
	g.DragDropTargetRect = bb
	g.DragDropTargetClipRect = window.ClipRect; // May want to be overridden by user depending on use case?
	g.DragDropTargetId = id
	g.DragDropWithinTarget = true
	return true
}

// call after submitting an item that may receive a payload. If this returns true, you can call AcceptDragDropPayload() + EndDragDropTarget()
// We don't use BeginDragDropTargetCustom() and duplicate its code because:
// 1) we use LastItemData's ImGuiItemStatusFlags_HoveredRect which handles items that push a temporarily clip rectangle in their code. Calling BeginDragDropTargetCustom(LastItemRect) would not handle them.
// 2) and it's faster. as this code may be very frequently called, we want to early out as fast as we can.
// Also note how the HoveredWindow test is positioned differently in both functions (in both functions we optimize for the cheapest early out case)
BeginDragDropTarget :: proc() -> bool
{
	g : ^ImGuiContext = GImGui
	if !g.DragDropActive { return false }

	window : ^ImGuiWindow = g.CurrentWindow
	if (g.LastItemData.StatusFlags & ImGuiItemStatusFlags_.ImGuiItemStatusFlags_HoveredRect) == {} { return false }
	hovered_window : ^ImGuiWindow = g.HoveredWindowUnderMovingWindow
	if hovered_window == nil || window.RootWindowDockTree != hovered_window.RootWindowDockTree || window.SkipItems { return false }

	display_rect : ImRect = (g.LastItemData.StatusFlags & ImGuiItemStatusFlags_.ImGuiItemStatusFlags_HasDisplayRect) != {} ? g.LastItemData.DisplayRect : g.LastItemData.Rect
	id : ImGuiID = g.LastItemData.ID
	if id == 0 {
		id = GetIDFromRectangle(window, display_rect)
		KeepAliveID(id)
	}
	if g.DragDropPayload.SourceId == id { return false }

	IM_ASSERT(g.DragDropWithinTarget == false && g.DragDropWithinSource == false); // Can't nest BeginDragDropSource() and BeginDragDropTarget()
	g.DragDropTargetRect = display_rect
	g.DragDropTargetClipRect = (g.LastItemData.StatusFlags & ImGuiItemStatusFlags_.ImGuiItemStatusFlags_HasClipRect) != {} ? g.LastItemData.ClipRect : window.ClipRect
	g.DragDropTargetId = id
	g.DragDropWithinTarget = true
	return true
}

IsDragDropPayloadBeingAccepted :: proc() -> bool
{
	g : ^ImGuiContext = GImGui
	return g.DragDropActive && g.DragDropAcceptIdPrev != 0
}

// accept contents of a given type. If ImGuiDragDropFlags_AcceptBeforeDelivery is set you can peek into the payload before the mouse button is released.
AcceptDragDropPayload :: proc(type : string, flags : ImGuiDragDropFlags = {}) -> ^ImGuiPayload
{
	g : ^ImGuiContext = GImGui
	payload : ^ImGuiPayload = &g.DragDropPayload
	IM_ASSERT(g.DragDropActive); // Not called between BeginDragDropTarget() and EndDragDropTarget() ?
	IM_ASSERT(payload.DataFrameCount != -1); // Forgot to call EndDragDropTarget() ?
	if type != "" && !IsDataType(payload, type) { return nil }

	// Accept smallest drag target bounding box, this allows us to nest drag targets conveniently without ordering constraints.
	// NB: We currently accept NULL id as target. However, overlapping targets requires a unique ID to function!
	was_accepted_previously : bool = (g.DragDropAcceptIdPrev == g.DragDropTargetId)
	r : ImRect = g.DragDropTargetRect
	r_surface : f32 = GetWidth(r) * GetHeight(r)
	if r_surface > g.DragDropAcceptIdCurrRectSurface { return nil }

	g.DragDropAcceptFlags = flags
	g.DragDropAcceptIdCurr = g.DragDropTargetId
	g.DragDropAcceptIdCurrRectSurface = r_surface
	//IMGUI_DEBUG_LOG("AcceptDragDropPayload(): %08X: accept\n", g.DragDropTargetId);

	// Render default drop visuals
	payload.Preview = was_accepted_previously
	flags := flags
	flags |= (g.DragDropSourceFlags & ImGuiDragDropFlags_.ImGuiDragDropFlags_AcceptNoDrawDefaultRect); // Source can also inhibit the preview (useful for external sources that live for 1 frame)
	if (flags & ImGuiDragDropFlags_.ImGuiDragDropFlags_AcceptNoDrawDefaultRect) == {} && payload.Preview { RenderDragDropTargetRect(r, g.DragDropTargetClipRect) }

	g.DragDropAcceptFrameCount = g.FrameCount
	if (g.DragDropSourceFlags & ImGuiDragDropFlags_.ImGuiDragDropFlags_SourceExtern) != {} && transmute(i32)g.DragDropMouseButton == -1 { payload.Delivery = was_accepted_previously && (g.DragDropSourceFrameCount < g.FrameCount) }
	else {
		// For extern drag sources affecting OS window focus, it's easier to just test !IsMouseDown() instead of IsMouseReleased()
		payload.Delivery = was_accepted_previously && !IsMouseDown(g.DragDropMouseButton)
	}
	if !payload.Delivery && (flags & ImGuiDragDropFlags_.ImGuiDragDropFlags_AcceptBeforeDelivery) == {} { return nil }

	if payload.Delivery { IMGUI_DEBUG_LOG_ACTIVEID(g, "[dragdrop] AcceptDragDropPayload(): 0x%08X: payload delivery\n", g.DragDropTargetId) }
	return payload
}

// FIXME-STYLE FIXME-DRAGDROP: Settle on a proper default visuals for drop target.
RenderDragDropTargetRect :: proc(bb : ImRect, item_clip_rect : ImRect)
{
	g : ^ImGuiContext = GImGui
	window : ^ImGuiWindow = g.CurrentWindow
	bb_display : ImRect = bb
	ClipWith(&bb_display, item_clip_rect); // Clip THEN expand so we have a way to visualize that target is not entirely visible.
	Expand(&bb_display, 3.5)
	push_clip_rect : bool = !Contains(window.ClipRect, bb_display)
	if push_clip_rect { PushClipRectFullScreen(window.DrawList) }
	AddRect(window.DrawList, bb_display.Min, bb_display.Max, GetColorU32(ImGuiCol_.ImGuiCol_DragDropTarget), 0.0, {}, 2.0)
	if push_clip_rect { PopClipRect(window.DrawList) }
}

// peek directly into the current payload from anywhere. returns NULL when drag and drop is finished or inactive. use ImGuiPayload::IsDataType() to test for the payload type.
GetDragDropPayload :: proc() -> ^ImGuiPayload
{
	g : ^ImGuiContext = GImGui
	return (g.DragDropActive && g.DragDropPayload.DataFrameCount != -1) ? &g.DragDropPayload : nil
}

// only call EndDragDropTarget() if BeginDragDropTarget() returns true!
EndDragDropTarget :: proc()
{
	g : ^ImGuiContext = GImGui
	IM_ASSERT(g.DragDropActive)
	IM_ASSERT(g.DragDropWithinTarget)
	g.DragDropWithinTarget = false

	// Clear drag and drop state payload right after delivery
	if g.DragDropPayload.Delivery { ClearDragDrop() }
}

//-----------------------------------------------------------------------------
// [SECTION] LOGGING/CAPTURING
//-----------------------------------------------------------------------------
// All text output from the interface can be captured into tty/file/clipboard.
// By default, tree nodes are automatically opened during logging.
//-----------------------------------------------------------------------------

// Pass text data straight to log (without being displayed)
LogTextV_0 :: #force_inline proc(g : ^ImGuiContext, fmt : string, args : []any)
{
	if g.LogFile != {} {
		resize(&g.LogBuffer.Buf, 0)
		appendfv(&g.LogBuffer, fmt, args)
		ImFileWrite(c_str(&g.LogBuffer), size_of(u8), cast(ImU64) size(&g.LogBuffer), g.LogFile)
	}
	else {
		appendfv(&g.LogBuffer, fmt, args)
	}
}

// pass text data straight to log (without being displayed)
LogText :: proc(fmt : string, args : ..any)
{
	g : ^ImGuiContext = GImGui
	if !g.LogEnabled { return }

	LogTextV(g, fmt, args)
}

LogTextV_1 :: proc(fmt : string, args : []any)
{
	g : ^ImGuiContext = GImGui
	if !g.LogEnabled { return }

	LogTextV(g, fmt, args)
}

// Internal version that takes a position to decide on newline placement and pad items according to their depth.
// We split text into individual lines to add current tree level padding
// FIXME: This code is a little complicated perhaps, considering simplifying the whole system.
LogRenderedText :: proc(ref_pos : ^ImVec2, text : string, hide_label_after_double_hash := true)
{
	g : ^ImGuiContext = GImGui
	window : ^ImGuiWindow = g.CurrentWindow

	prefix := g.LogNextPrefix
	suffix := g.LogNextSuffix
	g.LogNextSuffix = ""; g.LogNextPrefix = g.LogNextSuffix

	text_vis := text
	if hide_label_after_double_hash { text_vis = text[:FindRenderedTextEnd(text)] }

	log_new_line : bool = ref_pos != nil && (ref_pos.y > g.LogLinePosY + g.Style.FramePadding.y + 1)
	if ref_pos != nil { g.LogLinePosY = ref_pos.y }
	if log_new_line {
		LogText(IM_NEWLINE)
		g.LogLineFirstItem = true
	}

	if prefix != "" {
		// Calculate end ourself to ensure "##" are included here.
		LogRenderedText(ref_pos, text, false)
	}

	// Re-adjust padding if we have popped out of our starting depth
	if g.LogDepthRef > window.DC.TreeDepth { g.LogDepthRef = window.DC.TreeDepth }
	tree_depth : i32 = (window.DC.TreeDepth - g.LogDepthRef)

	text_remaining : [^]u8 = raw_data(text_vis)
	text_end := &text_remaining[len(text_vis)]
	for {
		// Split the string. Each new line (after a '\n') is followed by indentation corresponding to the current depth of our log entry.
		// We don't add a trailing \n yet to allow a subsequent item on the same line to be captured.
		line_start : ^u8 = text_remaining
		line_end : ^u8 = ImStreolRange(line_start, text_end)
		is_last_line : bool = (line_end == text_end)
		if line_start != line_end || !is_last_line {
			line_length : i32 = cast(i32) mem.ptr_sub(line_end, line_start)
			indentation : i32 = g.LogLineFirstItem ? tree_depth * 4 : 1
			LogText("%*s%.*s", indentation, "", line_length, line_start)
			g.LogLineFirstItem = false
			if line_end^ == '\n' {
				LogText(IM_NEWLINE)
				g.LogLineFirstItem = true
			}
		}
		if is_last_line { break }
		text_remaining = mem.ptr_offset(line_end, 1)
	}

	if suffix != "" {
		LogRenderedText(ref_pos, suffix, false)
	}
}

// Logging/Capture
// -> BeginCapture() when we design v2 api, for now stay under the radar by using the old name.
// Start logging/capturing text output
LogBegin :: proc(flags : ImGuiLogFlags, auto_open_depth : i32)
{
	g : ^ImGuiContext = GImGui
	window : ^ImGuiWindow = g.CurrentWindow
	IM_ASSERT(g.LogEnabled == false)
	IM_ASSERT(g.LogFile == {} && empty(&g.LogBuffer))
	IM_ASSERT(ImIsPowerOfTwo(u32(flags & ImGuiLogFlags_.ImGuiLogFlags_OutputMask_))); // Check that only 1 type flag is used

	g.ItemUnclipByLog = true; g.LogEnabled = g.ItemUnclipByLog
	g.LogFlags = flags
	g.LogWindow = window
	g.LogNextSuffix = ""; g.LogNextPrefix = g.LogNextSuffix
	g.LogDepthRef = window.DC.TreeDepth
	g.LogDepthToExpand = ((auto_open_depth >= 0) ? auto_open_depth : g.LogDepthToExpandDefault)
	g.LogLinePosY = FLT_MAX
	g.LogLineFirstItem = true
}

// Important: doesn't copy underlying data, use carefully (prefix/suffix must be in scope at the time of the next LogRenderedText)
LogSetNextTextDecoration :: proc(prefix : string, suffix : string)
{
	g : ^ImGuiContext = GImGui
	g.LogNextPrefix = prefix
	g.LogNextSuffix = suffix
}

// Logging/Capture
// - All text output from the interface can be captured into tty/file/clipboard. By default, tree nodes are automatically opened during logging.
// start logging to tty (stdout)
LogToTTY :: proc(auto_open_depth : i32 = -1)
{
	g : ^ImGuiContext = GImGui
	if g.LogEnabled { return }
	IM_UNUSED(auto_open_depth)
	when ! IMGUI_DISABLE_TTY_FUNCTIONS { /* @gen ifndef */
	LogBegin(ImGuiLogFlags_.ImGuiLogFlags_OutputTTY, auto_open_depth)
	g.LogFile = os.stdout
	} // preproc endif
}

// start logging to file
// Start logging/capturing text output to given file
LogToFile :: proc(auto_open_depth : i32 = -1, filename : string = "")
{
	g : ^ImGuiContext = GImGui
	if g.LogEnabled { return }

	filename := filename
	// FIXME: We could probably open the file in text mode "at", however note that clipboard/buffer logging will still
	// be subject to outputting OS-incompatible carriage return if within strings the user doesn't use IM_NEWLINE.
	// By opening the file in binary mode "ab" we have consistent output everywhere.
	if filename == "" { filename = g.IO.LogFilename }
	if filename == "" || filename[0] == 0 { return }
	f : ImFileHandle = ImFileOpen(filename, "ab")
	if f == {} {
		IM_ASSERT(false)
		return
	}

	LogBegin(ImGuiLogFlags_.ImGuiLogFlags_OutputFile, auto_open_depth)
	g.LogFile = f
}

// start logging to OS clipboard
// Start logging/capturing text output to clipboard
LogToClipboard :: proc(auto_open_depth : i32 = -1)
{
	g : ^ImGuiContext = GImGui
	if g.LogEnabled { return }
	LogBegin(ImGuiLogFlags_.ImGuiLogFlags_OutputClipboard, auto_open_depth)
}

// Start logging/capturing to internal buffer
LogToBuffer :: proc(auto_open_depth : i32)
{
	g : ^ImGuiContext = GImGui
	if g.LogEnabled { return }
	LogBegin(ImGuiLogFlags_.ImGuiLogFlags_OutputBuffer, auto_open_depth)
}

// stop logging (close file, etc.)
LogFinish :: proc()
{
	g : ^ImGuiContext = GImGui
	if !g.LogEnabled { return }

	LogText(IM_NEWLINE)
	#partial switch g.LogFlags & ImGuiLogFlags_.ImGuiLogFlags_OutputMask_ {
		case ImGuiLogFlags_.ImGuiLogFlags_OutputTTY:
			when ! IMGUI_DISABLE_TTY_FUNCTIONS { /* @gen ifndef */
				os.flush(g.LogFile)
			} // preproc endif
			break

		case ImGuiLogFlags_.ImGuiLogFlags_OutputFile:
			ImFileClose(g.LogFile)
			break

		case ImGuiLogFlags_.ImGuiLogFlags_OutputBuffer:
			break

		case ImGuiLogFlags_.ImGuiLogFlags_OutputClipboard:
			if !empty(&g.LogBuffer) {
				b := begin(&g.LogBuffer)
				SetClipboardText(string_from_cstr(cast(cstring)b, strlen(b)))
			}
			break

		case:
			IM_ASSERT(false)
			break
	}

	g.ItemUnclipByLog = false; g.LogEnabled = g.ItemUnclipByLog
	g.LogFlags = ImGuiLogFlags_.ImGuiLogFlags_None
	g.LogFile = {}
	clear(&g.LogBuffer)
}

// helper to display buttons for logging to tty/file/clipboard
// Helper to display logging buttons
// FIXME-OBSOLETE: We should probably obsolete this and let the user have their own helper (this is one of the oldest function alive!)
LogButtons :: proc()
{
	g : ^ImGuiContext = GImGui

	PushID("LogButtons")
	when ! IMGUI_DISABLE_TTY_FUNCTIONS { /* @gen ifndef */
	log_to_tty : bool = Button("Log To TTY"); SameLine()
	} else { // preproc else
	log_to_tty : bool = false
	} // preproc endif
	log_to_file : bool = Button("Log To File"); SameLine()
	log_to_clipboard : bool = Button("Log To Clipboard"); SameLine()
	PushItemFlag(ImGuiItemFlags_.ImGuiItemFlags_NoTabStop, true)
	SetNextItemWidth(80.0)
	SliderInt("Default Depth", &g.LogDepthToExpandDefault, 0, 9, "")
	PopItemFlag()
	PopID()

	// Start logging at the end of the function so that the buttons don't appear in the log
	if log_to_tty { LogToTTY() }
	if log_to_file { LogToFile() }
	if log_to_clipboard { LogToClipboard() }
}

// Misc
//-----------------------------------------------------------------------------
// [SECTION] SETTINGS
//-----------------------------------------------------------------------------
// - UpdateSettings() [Internal]
// - MarkIniSettingsDirty() [Internal]
// - FindSettingsHandler() [Internal]
// - ClearIniSettings() [Internal]
// - LoadIniSettingsFromDisk()
// - LoadIniSettingsFromMemory()
// - SaveIniSettingsToDisk()
// - SaveIniSettingsToMemory()
//-----------------------------------------------------------------------------
// - CreateNewWindowSettings() [Internal]
// - FindWindowSettingsByID() [Internal]
// - FindWindowSettingsByWindow() [Internal]
// - ClearWindowSettings() [Internal]
// - WindowSettingsHandler_***() [Internal]
//-----------------------------------------------------------------------------

// Called by NewFrame()
UpdateSettings :: proc()
{
	// Load settings on first frame (if not explicitly loaded manually before)
	g : ^ImGuiContext = GImGui
	if !g.SettingsLoaded {
		IM_ASSERT(empty(&g.SettingsWindows))
		if g.IO.IniFilename != "" { LoadIniSettingsFromDisk(g.IO.IniFilename) }
		g.SettingsLoaded = true
	}

	// Save settings (with a delay after the last modification, so we don't spam disk too much)
	if g.SettingsDirtyTimer > 0.0 {
		g.SettingsDirtyTimer -= g.IO.DeltaTime
		if g.SettingsDirtyTimer <= 0.0 {
			if g.IO.IniFilename != "" { SaveIniSettingsToDisk(g.IO.IniFilename) }
			else {
				// Let user know they can call SaveIniSettingsToMemory(). user will need to clear io.WantSaveIniSettings themselves.
				g.IO.WantSaveIniSettings = true
			}
			g.SettingsDirtyTimer = 0.0
		}
	}
}

// Settings
MarkIniSettingsDirty_0 :: proc()
{
	g : ^ImGuiContext = GImGui
	if g.SettingsDirtyTimer <= 0.0 { g.SettingsDirtyTimer = g.IO.IniSavingRate }
}

// Settings
MarkIniSettingsDirty_1 :: proc(window : ^ImGuiWindow)
{
	g : ^ImGuiContext = GImGui
	if (window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoSavedSettings) == {} { if g.SettingsDirtyTimer <= 0.0 { g.SettingsDirtyTimer = g.IO.IniSavingRate } }
}

AddSettingsHandler :: proc(handler : ^ImGuiSettingsHandler)
{
	g : ^ImGuiContext = GImGui
	IM_ASSERT(FindSettingsHandler(handler.TypeName) == nil)
	push_back(&g.SettingsHandlers, handler^)
}

RemoveSettingsHandler :: proc(type_name : string)
{
	g : ^ImGuiContext = GImGui
	if handler : ^ImGuiSettingsHandler = FindSettingsHandler(type_name); handler != nil { erase(&g.SettingsHandlers, handler) }
}

FindSettingsHandler :: proc(type_name : string) -> ^ImGuiSettingsHandler
{
	g : ^ImGuiContext = GImGui
	type_hash : ImGuiID = ImHashStr(type_name)
	for &handler in g.SettingsHandlers.Data[:g.SettingsHandlers.Size] { if handler.TypeHash == type_hash { return &handler } }

	return nil
}

// Clear all settings (windows, tables, docking etc.)
ClearIniSettings :: proc()
{
	g : ^ImGuiContext = GImGui
	clear(&g.SettingsIniData)
	for &handler in g.SettingsHandlers.Data[:g.SettingsHandlers.Size] { if handler.ClearAllFn != nil { handler.ClearAllFn(g, &handler) } }
}

// Settings/.Ini Utilities
// - The disk functions are automatically called if io.IniFilename != NULL (default is "imgui.ini").
// - Set io.IniFilename to NULL to load/save manually. Read io.WantSaveIniSettings description about handling .ini saving manually.
// - Important: default value "imgui.ini" is relative to current working dir! Most apps will want to lock this to an absolute path (e.g. same path as executables).
// call after CreateContext() and before the first call to NewFrame(). NewFrame() automatically calls LoadIniSettingsFromDisk(io.IniFilename).
LoadIniSettingsFromDisk :: proc(ini_filename : string)
{
	file_data_size : uint = 0
	file_data := cast([^]u8) ImFileLoadToMemory(ini_filename, "rb", &file_data_size)
	if file_data == nil { return }
	if file_data_size > 0 { LoadIniSettingsFromMemory(file_data[:file_data_size]) }
	IM_FREE(file_data)
}

// call after CreateContext() and before the first call to NewFrame() to provide .ini data from your own data source.
// Zero-tolerance, no error reporting, cheap .ini parsing
LoadIniSettingsFromMemory :: proc(ini_data : []u8)
{
	g : ^ImGuiContext = GImGui
	IM_ASSERT(g.Initialized)
	//IM_ASSERT(!g.WithinFrameScope, "Cannot be called between NewFrame() and EndFrame()");
	//IM_ASSERT(g.SettingsLoaded == false && g.FrameCount == 0);

	resize(&g.SettingsIniData.Buf, cast(i32) len(ini_data) + 1)
	copy(g.SettingsIniData.Buf.Data[:len(ini_data)], ini_data)
	buf := g.SettingsIniData.Buf.Data
	buf_end := g.SettingsIniData.Buf.Data[len(ini_data):]
	buf[len(ini_data)] = 0

	// Call pre-read handlers
	// Some types will clear their data (e.g. dock information) some types will allow merge/override (window)
	for &handler in g.SettingsHandlers.Data[:g.SettingsHandlers.Size] { if handler.ReadInitFn != nil { handler.ReadInitFn(g, &handler) } }

	entry_data : rawptr = nil
	entry_handler : ^ImGuiSettingsHandler = nil

	line_end : [^]u8 = nil
	for line : [^]u8 = buf; line < buf_end; line = line_end[1:] {
		// Skip new lines markers, then find end of the line
		for line[0] == '\n' || line[0] == '\r' { post_incr(&line) }

		line_end = line
		for line_end < buf_end && line_end[0] != '\n' && line_end[0] != '\r' { post_incr(&line_end) }

		line_end[0] = 0
		if line[0] == ';' { continue }
		if line[0] == '[' && line_end > line && line_end[-1] == ']' {
			// Parse "[Type][Name]". Note that 'Name' can itself contains [] characters, which is acceptable with the current format and parsing code.
			line_end[-1] = 0
			name_end := line_end[-1:]
			type_start := line[1:]
			type_end := cast([^]u8) cast(rawptr) ImStrchrRange(type_start, name_end, ']')
			name_start := type_end != nil ? cast([^]u8)ImStrchrRange(type_end[1:], name_end, '[') : nil
			if type_end == nil || name_start == nil { continue }
			type_end[0] = 0; // Overwrite first ']'
			post_incr(&name_start); // Skip second '['
			entry_handler = FindSettingsHandler(string_from_cstr(cast(cstring)type_start))
			entry_data = entry_handler != nil ? entry_handler.ReadOpenFn(g, entry_handler, string_from_cstr(cast(cstring)name_start)) : nil
		}
		else if entry_handler != nil && entry_data != nil {
			// Let type handler parse the line
			entry_handler.ReadLineFn(g, entry_handler, entry_data, string_from_cstr(cast(cstring)line))
		}
	}

	g.SettingsLoaded = true

	// [DEBUG] Restore untouched copy so it can be browsed in Metrics (not strictly necessary)
	memcpy(buf, raw_data(ini_data), len(ini_data))

	// Call post-read handlers
	for &handler in g.SettingsHandlers.Data[:g.SettingsHandlers.Size] { if handler.ApplyAllFn != nil { handler.ApplyAllFn(g, &handler) } }
}

// this is automatically called (if io.IniFilename is not empty) a few seconds after any modification that should be reflected in the .ini file (and also by DestroyContext).
SaveIniSettingsToDisk :: proc(ini_filename : string)
{
	g : ^ImGuiContext = GImGui
	g.SettingsDirtyTimer = 0.0
	if ini_filename == "" { return }

	ini_data_size : uint = 0
	ini_data : ^u8 = SaveIniSettingsToMemory(&ini_data_size)
	f : ImFileHandle = ImFileOpen(ini_filename, "wt")
	if f == {} { return }
	ImFileWrite(ini_data, size_of(u8), cast(u64)ini_data_size, f)
	ImFileClose(f)
}

// return a zero-terminated string with the .ini data which you can save by your own mean. call when io.WantSaveIniSettings is set, then save data by your own mean and clear io.WantSaveIniSettings.
// Call registered handlers (e.g. SettingsHandlerWindow_WriteAll() + custom handlers) to write their stuff into a text buffer
SaveIniSettingsToMemory :: proc(out_size : ^uint = nil) -> ^u8
{
	g : ^ImGuiContext = GImGui
	g.SettingsDirtyTimer = 0.0
	resize(&g.SettingsIniData.Buf, 0)
	push_back(&g.SettingsIniData.Buf, 0)
	for &handler in g.SettingsHandlers.Data[:g.SettingsHandlers.Size] { handler.WriteAllFn(g, &handler, &g.SettingsIniData) }

	if out_size != nil { out_size^ = cast(uint) size(&g.SettingsIniData) }
	return c_str(&g.SettingsIniData)
}

// Settings - Windows
CreateNewWindowSettings :: proc(name : string) -> ^ImGuiWindowSettings
{
	name := name
	g : ^ImGuiContext = GImGui

	if g.IO.ConfigDebugIniSettings == false {
		// Skip to the "###" marker if any. We don't skip past to match the behavior of GetID()
		// Preserve the full string when ConfigDebugVerboseIniSettings is set to make .ini inspection easier.
		if p := str.index(name, "###"); p != -1 { name = name[p:] }
	}
	name_len := len(name)
	
	// Allocate chunk
	chunk_size := size_of(ImGuiWindowSettings) + cast(uint)name_len + 1
	settings : ^ImGuiWindowSettings = alloc_chunk(&g.SettingsWindows, chunk_size)
	init(settings)
	settings.ID = ImHashStr(name)
	n := GetName(settings)
	memcpy(n, raw_data(name), name_len);
	n[name_len] = 0 // Store with zero terminator

	return settings
}

// We don't provide a FindWindowSettingsByName() because Docking system doesn't always hold on names.
// This is called once per window .ini entry + once per newly instantiated window.
FindWindowSettingsByID :: proc(id : ImGuiID) -> ^ImGuiWindowSettings
{
	g : ^ImGuiContext = GImGui
	for settings : ^ImGuiWindowSettings = begin(&g.SettingsWindows); settings != nil; settings = next_chunk(&g.SettingsWindows, settings) { if settings.ID == id && !settings.WantDelete { return settings } }

	return nil
}

// This is faster if you are holding on a Window already as we don't need to perform a search.
FindWindowSettingsByWindow :: proc(window : ^ImGuiWindow) -> ^ImGuiWindowSettings
{
	g : ^ImGuiContext = GImGui
	if window.SettingsOffset != -1 { return ptr_from_offset(&g.SettingsWindows, window.SettingsOffset) }
	return FindWindowSettingsByID(window.ID)
}

// This will revert window to its initial state, including enabling the ImGuiCond_FirstUseEver/ImGuiCond_Once conditions once more.
ClearWindowSettings :: proc(name : string)
{
	//IMGUI_DEBUG_LOG("ClearWindowSettings('%s')\n", name);
	g : ^ImGuiContext = GImGui
	window : ^ImGuiWindow = FindWindowByName(name)
	if window != nil {
		window.Flags |= ImGuiWindowFlags_.ImGuiWindowFlags_NoSavedSettings
		InitOrLoadWindowSettings(window, nil)
		if window.DockId != 0 { DockContextProcessUndockWindow(g, window, true) }
	}
	if settings : ^ImGuiWindowSettings = window != nil ? FindWindowSettingsByWindow(window) : FindWindowSettingsByID(ImHashStr(name)); settings != nil { settings.WantDelete = true }
}

// Settings
WindowSettingsHandler_ClearAll :: proc(ctx : ^ImGuiContext, _ : ^ImGuiSettingsHandler)
{
	g : ^ImGuiContext = ctx
	for window in g.Windows.Data[:g.Windows.Size] { window.SettingsOffset = -1 }

	clear(&g.SettingsWindows)
}

WindowSettingsHandler_ReadOpen :: proc(_ : ^ImGuiContext, _ : ^ImGuiSettingsHandler, name : string) -> rawptr
{
	id : ImGuiID = ImHashStr(name)
	settings : ^ImGuiWindowSettings = FindWindowSettingsByID(id)
	if settings != nil {
		// Clear existing if recycling previous entry
		init(settings)
	}
	else { settings = CreateNewWindowSettings(name) }
	settings.ID = id
	settings.WantApply = true
	return cast(rawptr) settings
}

WindowSettingsHandler_ReadLine :: proc(_ : ^ImGuiContext, _ : ^ImGuiSettingsHandler, entry : rawptr, line : string)
{
	settings : ^ImGuiWindowSettings = cast(^ImGuiWindowSettings) entry
	x, y : i64
	o, l : int

	reset_if_failed :: #force_inline proc(ok : bool, offset : ^int) -> bool { if !ok { offset^ = 0 }; return ok }

	if reset_if_failed(parse_int_pair_prefixed(line, &o, "Pos=", &x, 10, &y, 10), &o) {
		settings.Pos = {cast(i16) x, cast(i16) y}
	}
	else if reset_if_failed(parse_int_pair_prefixed(line, &o, "Size=", &x, 10, &y, 10), &o) {
		settings.Pos = {cast(i16) x, cast(i16) y}
	}
	else if reset_if_failed(parse_int_prefixed(line, &o, "ViewportId=", &x, 16), &o) {
		settings.ViewportId = cast(u32) x
	}
	else if reset_if_failed(parse_int_pair_prefixed(line, &o, "ViewportPos=", &x, 10, &y, 10), &o) {
		settings.ViewportPos = {cast(i16) x, cast(i16) y}
	}
	else if reset_if_failed(parse_int_prefixed(line, &o, "Collapsed=", &x, 10), &o) {
		settings.Collapsed = x != 0
	}
	else if reset_if_failed(parse_int_prefixed(line, &o, "IsChild=", &x, 10), &o) {
		settings.IsChild = x != 0
	}
	else if o = str.index(line, "DockId="); o != -1 {
		ok : bool
		if line[o:o + 2] != "0x" { return }; o += 2
		x, ok = strconv.parse_i64_of_base(line[o:], 16, &l); if !ok { return }
		if line[o + l] != ',' {
			settings.DockId = cast(u32) x; settings.DockOrder = -1
		}
		else {
			y, ok = strconv.parse_i64_of_base(line[o + l + 1:], 10); if !ok { return }
			settings.DockId = cast(u32) x; settings.DockOrder = cast(i16) y
		}
	}
	else if reset_if_failed(parse_int_prefixed(line, &o, "ClassId=", &x, 16), &o){
		settings.ClassId = cast(u32) x
	}
}

// Apply to existing windows (if any)
WindowSettingsHandler_ApplyAll :: proc(ctx : ^ImGuiContext, _ : ^ImGuiSettingsHandler)
{
	g : ^ImGuiContext = ctx
	for settings : ^ImGuiWindowSettings = begin(&g.SettingsWindows); settings != nil; settings = next_chunk(&g.SettingsWindows, settings) { if settings.WantApply {
	if window : ^ImGuiWindow = FindWindowByID(settings.ID); window != nil { ApplyWindowSettings(window, settings) }
	settings.WantApply = false
} }
}

WindowSettingsHandler_WriteAll :: proc(ctx : ^ImGuiContext, handler : ^ImGuiSettingsHandler, buf : ^ImGuiTextBuffer)
{
	// Gather data from windows that were active during this session
	// (if a window wasn't opened in this session we preserve its settings)
	g : ^ImGuiContext = ctx
	for window in g.Windows.Data[:g.Windows.Size] {
		if (window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoSavedSettings) != {} { continue }

		settings : ^ImGuiWindowSettings = FindWindowSettingsByWindow(window)
		if settings == nil {
			settings = CreateNewWindowSettings(window.Name)
			window.SettingsOffset = offset_from_ptr(&g.SettingsWindows, settings)
		}
		IM_ASSERT(settings.ID == window.ID)
		x := window.Pos - window.ViewportPos
		settings.Pos = ImVec2ih{cast(i16)x.x, cast(i16)x.y}
		settings.Size = ImVec2ih{cast(i16)window.SizeFull.x, cast(i16)window.SizeFull.y}
		settings.ViewportId = window.ViewportId
		settings.ViewportPos = ImVec2ih{cast(i16)window.ViewportPos.x, cast(i16)window.ViewportPos.y}
		IM_ASSERT(window.DockNode == nil || window.DockNode.ID == window.DockId)
		settings.DockId = window.DockId
		settings.ClassId = window.WindowClass.ClassId
		settings.DockOrder = window.DockOrder
		settings.Collapsed = window.Collapsed
		settings.IsChild = (window.RootWindow != window); // Cannot rely on ImGuiWindowFlags_ChildWindow here as docked windows have this set.
		settings.WantDelete = false
	}

	// Write to text buffer
	reserve(buf, size(buf) + size(&g.SettingsWindows) * 6); // ballpark reserve
	for settings : ^ImGuiWindowSettings = begin(&g.SettingsWindows); settings != nil; settings = next_chunk(&g.SettingsWindows, settings) {
		if settings.WantDelete { continue }
		settings_name : ^u8 = GetName(settings)
		appendf(buf, "[%s][%s]\n", handler.TypeName, settings_name)
		if settings.IsChild {
			appendf(buf, "IsChild=1\n")
			appendf(buf, "Size=%d,%d\n", settings.Size.x, settings.Size.y)
		}
		else {
			if settings.ViewportId != 0 && settings.ViewportId != IMGUI_VIEWPORT_DEFAULT_ID {
				appendf(buf, "ViewportPos=%d,%d\n", settings.ViewportPos.x, settings.ViewportPos.y)
				appendf(buf, "ViewportId=0x%08X\n", settings.ViewportId)
			}
			if settings.Pos.x != 0 || settings.Pos.y != 0 || settings.ViewportId == IMGUI_VIEWPORT_DEFAULT_ID { appendf(buf, "Pos=%d,%d\n", settings.Pos.x, settings.Pos.y) }
			if settings.Size.x != 0 || settings.Size.y != 0 { appendf(buf, "Size=%d,%d\n", settings.Size.x, settings.Size.y) }
			appendf(buf, "Collapsed=%d\n", settings.Collapsed)
			if settings.DockId != 0 {
				//buf->appendf("TabId=0x%08X\n", ImHashStr("#TAB", 4, settings->ID)); // window->TabId: this is not read back but writing it makes "debugging" the .ini data easier.
				if settings.DockOrder == -1 { appendf(buf, "DockId=0x%08X\n", settings.DockId) }
				else { appendf(buf, "DockId=0x%08X,%d\n", settings.DockId, settings.DockOrder) }
				if settings.ClassId != 0 { appendf(buf, "ClassId=0x%08X\n", settings.ClassId) }
			}
		}
		append(buf, "\n")
	}
}

// Localization
//-----------------------------------------------------------------------------
// [SECTION] LOCALIZATION
//-----------------------------------------------------------------------------

LocalizeRegisterEntries :: proc(entries : []ImGuiLocEntry)
{
	g : ^ImGuiContext = GImGui
	for e in entries { g.LocalizationTable[e.Key] = e.Text }
}

// Viewports
// - Currently represents the Platform Window created by the application which is hosting our Dear ImGui windows.
// - In 'docking' branch with multi-viewport enabled, we extend this concept to have multiple active viewports.
// - In the future we will extend this concept further to also represent Platform Monitor and support a "no main platform window" operation mode.
// return primary/default viewport. This can never be NULL.
//-----------------------------------------------------------------------------
// [SECTION] VIEWPORTS, PLATFORM WINDOWS
//-----------------------------------------------------------------------------
// - GetMainViewport()
// - FindViewportByID()
// - FindViewportByPlatformHandle()
// - SetCurrentViewport() [Internal]
// - SetWindowViewport() [Internal]
// - GetWindowAlwaysWantOwnViewport() [Internal]
// - UpdateTryMergeWindowIntoHostViewport() [Internal]
// - UpdateTryMergeWindowIntoHostViewports() [Internal]
// - TranslateWindowsInViewport() [Internal]
// - ScaleWindowsInViewport() [Internal]
// - FindHoveredViewportFromPlatformWindowStack() [Internal]
// - UpdateViewportsNewFrame() [Internal]
// - UpdateViewportsEndFrame() [Internal]
// - AddUpdateViewport() [Internal]
// - WindowSelectViewport() [Internal]
// - WindowSyncOwnedViewport() [Internal]
// - UpdatePlatformWindows()
// - RenderPlatformWindowsDefault()
// - FindPlatformMonitorForPos() [Internal]
// - FindPlatformMonitorForRect() [Internal]
// - UpdateViewportPlatformMonitor() [Internal]
// - DestroyPlatformWindow() [Internal]
// - DestroyPlatformWindows()
//-----------------------------------------------------------------------------

GetMainViewport :: proc() -> ^ImGuiViewport
{
	g : ^ImGuiContext = GImGui
	return g.Viewports.Data[0]
}

// this is a helper for backends.
// FIXME: This leaks access to viewports not listed in PlatformIO.Viewports.Data[]. Problematic? (#4236)
FindViewportByID :: proc(id : ImGuiID) -> ^ImGuiViewport
{
	g : ^ImGuiContext = GImGui
	for viewport in g.Viewports.Data[:g.Viewports.Size] { if viewport.ID == id { return viewport } }

	return nil
}

// this is a helper for backends. the type platform_handle is decided by the backend (e.g. HWND, MyWindow*, GLFWwindow* etc.)
FindViewportByPlatformHandle :: proc(platform_handle : rawptr) -> ^ImGuiViewport
{
	g : ^ImGuiContext = GImGui
	for viewport in g.Viewports.Data[:g.Viewports.Size] { if viewport.PlatformHandle == platform_handle { return viewport } }

	return nil
}

SetCurrentViewport :: proc(current_window : ^ImGuiWindow, viewport : ^ImGuiViewportP)
{
	g : ^ImGuiContext = GImGui
	_ = current_window

	if viewport != nil { viewport.LastFrameActive = g.FrameCount }
	if g.CurrentViewport == viewport { return }
	g.CurrentDpiScale = viewport != nil ? viewport.DpiScale : 1.0
	g.CurrentViewport = viewport
	IM_ASSERT(g.CurrentDpiScale > 0.0 && g.CurrentDpiScale < 99.0); // Typical correct values would be between 1.0f and 4.0f
	//IMGUI_DEBUG_LOG_VIEWPORT(g, "[viewport] SetCurrentViewport changed '%s' 0x%08X\n", current_window ? current_window->Name : NULL, viewport ? viewport->ID : 0);

	// Notify platform layer of viewport changes
	// FIXME-DPI: This is only currently used for experimenting with handling of multiple DPI
	if g.CurrentViewport != nil && g.PlatformIO.Platform_OnChangedViewport != nil { g.PlatformIO.Platform_OnChangedViewport(g.CurrentViewport) }
}

SetWindowViewport :: proc(window : ^ImGuiWindow, viewport : ^ImGuiViewportP)
{
	// Abandon viewport
	if window.ViewportOwned && window.Viewport.Window == window { window.Viewport.Size = ImVec2{0.0, 0.0} }

	window.Viewport = viewport
	window.ViewportId = viewport.ID
	window.ViewportOwned = (viewport.Window == window)
}

GetWindowAlwaysWantOwnViewport :: proc(window : ^ImGuiWindow) -> bool
{
	// Tooltips and menus are not automatically forced into their own viewport when the NoMerge flag is set, however the multiplication of viewports makes them more likely to protrude and create their own.
	g : ^ImGuiContext = GImGui
	if g.IO.ConfigViewportsNoAutoMerge || (window.WindowClass.ViewportFlagsOverrideSet & ImGuiViewportFlags_.ImGuiViewportFlags_NoAutoMerge) != {} { if (g.ConfigFlagsCurrFrame & ImGuiConfigFlags_.ImGuiConfigFlags_ViewportsEnable) != {} { if !window.DockIsActive { if (window.Flags & (ImGuiWindowFlags_.ImGuiWindowFlags_ChildWindow | ImGuiWindowFlags_.ImGuiWindowFlags_ChildMenu | ImGuiWindowFlags_.ImGuiWindowFlags_Tooltip)) == {} { if (window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_Popup) == {} || (window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_Modal) != {} { return true } } } } }
	return false
}

UpdateTryMergeWindowIntoHostViewport :: proc(window : ^ImGuiWindow, viewport : ^ImGuiViewportP) -> bool
{
	g : ^ImGuiContext = GImGui
	if window.Viewport == viewport { return false }
	if (viewport.Flags & ImGuiViewportFlags_.ImGuiViewportFlags_CanHostOtherWindows) == {} { return false }
	if (viewport.Flags & ImGuiViewportFlags_.ImGuiViewportFlags_IsMinimized) != {} { return false }
	if !Contains(GetMainRect(viewport), Rect(window)) { return false }
	if GetWindowAlwaysWantOwnViewport(window) { return false }

	// FIXME: Can't use g.WindowsFocusOrder.Data[] for root windows only as we care about Z order. If we maintained a DisplayOrder along with FocusOrder we could..
	for window_behind in g.Windows.Data[:g.Windows.Size] {
		if window_behind == window { break }
		if window_behind.WasActive && window_behind.ViewportOwned && (window_behind.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_ChildWindow) == {} { if Overlaps(GetMainRect(window_behind.Viewport), Rect(window)) { return false } }
	}

	// Move to the existing viewport, Move child/hosted windows as well (FIXME-OPT: iterate child)
	old_viewport : ^ImGuiViewportP = window.Viewport
	if window.ViewportOwned { for n : i32 = 0; n < g.Windows.Size; n += 1 { if g.Windows.Data[n].Viewport == old_viewport { SetWindowViewport(g.Windows.Data[n], viewport) } } }
	SetWindowViewport(window, viewport)
	BringWindowToDisplayFront(window)

	return true
}

// FIXME: handle 0 to N host viewports
UpdateTryMergeWindowIntoHostViewports :: proc(window : ^ImGuiWindow) -> bool
{
	g : ^ImGuiContext = GImGui
	return UpdateTryMergeWindowIntoHostViewport(window, g.Viewports.Data[0])
}

// Viewports
// Translate Dear ImGui windows when a Host Viewport has been moved
// (This additionally keeps windows at the same place when ImGuiConfigFlags_ViewportsEnable is toggled!)
TranslateWindowsInViewport :: proc(viewport : ^ImGuiViewportP, old_pos : ImVec2, new_pos : ImVec2, old_size : ImVec2, new_size : ImVec2)
{
	g : ^ImGuiContext = GImGui
	IM_ASSERT(viewport.Window == nil && (viewport.Flags & ImGuiViewportFlags_.ImGuiViewportFlags_CanHostOtherWindows) != {})

	// 1) We test if ImGuiConfigFlags_ViewportsEnable was just toggled, which allows us to conveniently
	// translate imgui windows from OS-window-local to absolute coordinates or vice-versa.
	// 2) If it's not going to fit into the new size, keep it at same absolute position.
	// One problem with this is that most Win32 applications doesn't update their render while dragging,
	// and so the window will appear to teleport when releasing the mouse.
	translate_all_windows : bool = (g.ConfigFlagsCurrFrame & ImGuiConfigFlags_.ImGuiConfigFlags_ViewportsEnable) != (g.ConfigFlagsLastFrame & ImGuiConfigFlags_.ImGuiConfigFlags_ViewportsEnable)
	test_still_fit_rect : ImRect; init(&test_still_fit_rect, old_pos, old_pos + viewport.Size)
	delta_pos : ImVec2 = new_pos - old_pos
	for window in g.Windows.Data[:g.Windows.Size] { if translate_all_windows || (window.Viewport == viewport && (old_size == new_size || Contains(test_still_fit_rect, Rect(window)))) { TranslateWindow(window, delta_pos) } }
}

// Scale all windows (position, size). Use when e.g. changing DPI. (This is a lossy operation!)
ScaleWindowsInViewport :: proc(viewport : ^ImGuiViewportP, scale : f32)
{
	g : ^ImGuiContext = GImGui
	if viewport.Window != nil {
		ScaleWindow(viewport.Window, scale)
	}
	else {
		for window in g.Windows.Data[:g.Windows.Size] { if window.Viewport == viewport { ScaleWindow(window, scale) } }
	}
}

// If the backend doesn't set MouseLastHoveredViewport or doesn't honor ImGuiViewportFlags_NoInputs, we do a search ourselves.
// A) It won't take account of the possibility that non-imgui windows may be in-between our dragged window and our target window.
// B) It requires Platform_GetWindowFocus to be implemented by backend.
FindHoveredViewportFromPlatformWindowStack :: proc(mouse_platform_pos : ImVec2) -> ^ImGuiViewportP
{
	g : ^ImGuiContext = GImGui
	best_candidate : ^ImGuiViewportP = nil
	for viewport in g.Viewports.Data[:g.Viewports.Size] { if (viewport.Flags & (ImGuiViewportFlags_.ImGuiViewportFlags_NoInputs | ImGuiViewportFlags_.ImGuiViewportFlags_IsMinimized)) == {} && Contains(GetMainRect(viewport), mouse_platform_pos) { if best_candidate == nil || best_candidate.LastFocusedStampCount < viewport.LastFocusedStampCount { best_candidate = viewport } } }

	return best_candidate
}

// Update viewports and monitor infos
// Note that this is running even if 'ImGuiConfigFlags_ViewportsEnable' is not set, in order to clear unused viewports (if any) and update monitor info.
UpdateViewportsNewFrame :: proc()
{
	g : ^ImGuiContext = GImGui
	IM_ASSERT(g.PlatformIO.Viewports.Size <= g.Viewports.Size)

	// Update Minimized status (we need it first in order to decide if we'll apply Pos/Size of the main viewport)
	// Update Focused status
	viewports_enabled : bool = (g.ConfigFlagsCurrFrame & ImGuiConfigFlags_.ImGuiConfigFlags_ViewportsEnable) != {}
	if viewports_enabled {
		focused_viewport : ^ImGuiViewportP = nil
		for viewport in g.Viewports.Data[:g.Viewports.Size] {
			platform_funcs_available : bool = viewport.PlatformWindowCreated
			if g.PlatformIO.Platform_GetWindowMinimized != nil && platform_funcs_available {
				is_minimized : bool = g.PlatformIO.Platform_GetWindowMinimized(viewport)
				if is_minimized { viewport.Flags |= ImGuiViewportFlags_.ImGuiViewportFlags_IsMinimized }
				else { viewport.Flags &= cast(ImGuiViewportFlags)~cast(i32)ImGuiViewportFlags_.ImGuiViewportFlags_IsMinimized }
			}

			// Update our implicit z-order knowledge of platform windows, which is used when the backend cannot provide io.MouseHoveredViewport.
			// When setting Platform_GetWindowFocus, it is expected that the platform backend can handle calls without crashing if it doesn't have data stored.
			if g.PlatformIO.Platform_GetWindowFocus != nil && platform_funcs_available {
				is_focused : bool = g.PlatformIO.Platform_GetWindowFocus(viewport)
				if is_focused { viewport.Flags |= ImGuiViewportFlags_.ImGuiViewportFlags_IsFocused }
				else { viewport.Flags &= cast(ImGuiViewportFlags)~cast(i32)ImGuiViewportFlags_.ImGuiViewportFlags_IsFocused }
				if is_focused { focused_viewport = viewport }
			}
		}

		// Focused viewport has changed?
		if focused_viewport != nil && g.PlatformLastFocusedViewportId != focused_viewport.ID {
			IMGUI_DEBUG_LOG_VIEWPORT(g, "[viewport] Focused viewport changed %08X -> %08X, attempting to apply our focus.\n", g.PlatformLastFocusedViewportId, focused_viewport.ID)
			prev_focused_viewport : ^ImGuiViewport = FindViewportByID(g.PlatformLastFocusedViewportId)
			prev_focused_has_been_destroyed : bool = (prev_focused_viewport == nil) || (prev_focused_viewport.PlatformWindowCreated == false)

			// Store a tag so we can infer z-order easily from all our windows
			// We compare PlatformLastFocusedViewportId so newly created viewports with _NoFocusOnAppearing flag
			// will keep the front most stamp instead of losing it back to their parent viewport.
			if focused_viewport.LastFocusedStampCount != g.ViewportFocusedStampCount { focused_viewport.LastFocusedStampCount = pre_incr(&g.ViewportFocusedStampCount) }
			g.PlatformLastFocusedViewportId = focused_viewport.ID

			// Focus associated dear imgui window
			// - if focus didn't happen with a click within imgui boundaries, e.g. Clicking platform title bar. (#6299)
			// - if focus didn't happen because we destroyed another window (#6462)
			// FIXME: perhaps 'FocusTopMostWindowUnderOne()' can handle the 'focused_window->Window != NULL' case as well.
			apply_imgui_focus_on_focused_viewport : bool = !IsAnyMouseDown() && !prev_focused_has_been_destroyed
			if apply_imgui_focus_on_focused_viewport {
				focused_viewport.LastFocusedHadNavWindow |= (g.NavWindow != nil) && (g.NavWindow.Viewport == focused_viewport); // Update so a window changing viewport won't lose focus.
				focus_request_flags : ImGuiFocusRequestFlags = ImGuiFocusRequestFlags_.ImGuiFocusRequestFlags_UnlessBelowModal | ImGuiFocusRequestFlags_.ImGuiFocusRequestFlags_RestoreFocusedChild
				if focused_viewport.Window != nil { FocusWindow(focused_viewport.Window, focus_request_flags) }
				else if focused_viewport.LastFocusedHadNavWindow {
					// Focus top most in viewport
					FocusTopMostWindowUnderOne(nil, nil, focused_viewport, focus_request_flags)
				}
				else {
					// No window had focus last time viewport was focused
					FocusWindow(nil, focus_request_flags)
				}
			}
		}
		if focused_viewport != nil { focused_viewport.LastFocusedHadNavWindow = (g.NavWindow != nil) && (g.NavWindow.Viewport == focused_viewport) }
	}

	// Create/update main viewport with current platform position.
	// FIXME-VIEWPORT: Size is driven by backend/user code for backward-compatibility but we should aim to make this more consistent.
	main_viewport : ^ImGuiViewportP = g.Viewports.Data[0]
	IM_ASSERT(main_viewport.ID == IMGUI_VIEWPORT_DEFAULT_ID)
	IM_ASSERT(main_viewport.Window == nil)
	main_viewport_pos : ImVec2 = viewports_enabled ? g.PlatformIO.Platform_GetWindowPos(main_viewport) : ImVec2{0.0, 0.0}
	main_viewport_size : ImVec2 = g.IO.DisplaySize
	if viewports_enabled && (main_viewport.Flags & ImGuiViewportFlags_.ImGuiViewportFlags_IsMinimized) != {} {
		main_viewport_pos = main_viewport.Pos; // Preserve last pos/size when minimized (FIXME: We don't do the same for Size outside of the viewport path)
		main_viewport_size = main_viewport.Size
	}
	AddUpdateViewport(nil, IMGUI_VIEWPORT_DEFAULT_ID, main_viewport_pos, main_viewport_size, ImGuiViewportFlags_.ImGuiViewportFlags_OwnedByApp | ImGuiViewportFlags_.ImGuiViewportFlags_CanHostOtherWindows)

	g.CurrentDpiScale = 0.0
	g.CurrentViewport = nil
	g.MouseViewport = nil
	for n : i32 = 0; n < g.Viewports.Size; n += 1 {
		viewport : ^ImGuiViewportP = g.Viewports.Data[n]
		viewport.Idx = n

		// Erase unused viewports
		if n > 0 && viewport.LastFrameActive < g.FrameCount - 2 {
			DestroyViewport(viewport)
			post_decr(&n)
			continue
		}

		platform_funcs_available : bool = viewport.PlatformWindowCreated
		if viewports_enabled {
			// Update Position and Size (from Platform Window to ImGui) if requested.
			// We do it early in the frame instead of waiting for UpdatePlatformWindows() to avoid a frame of lag when moving/resizing using OS facilities.
			if (viewport.Flags & ImGuiViewportFlags_.ImGuiViewportFlags_IsMinimized) == {} && platform_funcs_available {
				// Viewport->WorkPos and WorkSize will be updated below
				if viewport.PlatformRequestMove { viewport.LastPlatformPos = g.PlatformIO.Platform_GetWindowPos(viewport); viewport.Pos = viewport.LastPlatformPos }
				if viewport.PlatformRequestResize { viewport.LastPlatformSize = g.PlatformIO.Platform_GetWindowSize(viewport); viewport.Size = viewport.LastPlatformSize }
			}
		}

		// Update/copy monitor info
		UpdateViewportPlatformMonitor(viewport)

		// Lock down space taken by menu bars and status bars + query initial insets from backend
		// Setup initial value for functions like BeginMainMenuBar(), DockSpaceOverViewport() etc.
		viewport.WorkInsetMin = viewport.BuildWorkInsetMin
		viewport.WorkInsetMax = viewport.BuildWorkInsetMax
		viewport.BuildWorkInsetMax = ImVec2{0.0, 0.0}; viewport.BuildWorkInsetMin = viewport.BuildWorkInsetMax
		if g.PlatformIO.Platform_GetWindowWorkAreaInsets != nil && platform_funcs_available {
			insets : ImVec4 = g.PlatformIO.Platform_GetWindowWorkAreaInsets(viewport)
			IM_ASSERT(insets.x >= 0.0 && insets.y >= 0.0 && insets.z >= 0.0 && insets.w >= 0.0)
			viewport.BuildWorkInsetMin = ImVec2{insets.x, insets.y}
			viewport.BuildWorkInsetMax = ImVec2{insets.z, insets.w}
		}
		UpdateWorkRect(viewport)

		// Reset alpha every frame. Users of transparency (docking) needs to request a lower alpha back.
		viewport.Alpha = 1.0

		// Translate Dear ImGui windows when a Host Viewport has been moved
		// (This additionally keeps windows at the same place when ImGuiConfigFlags_ViewportsEnable is toggled!)
		viewport_delta_pos : ImVec2 = viewport.Pos - viewport.LastPos
		if (viewport.Flags & ImGuiViewportFlags_.ImGuiViewportFlags_CanHostOtherWindows) != {} && (viewport_delta_pos.x != 0.0 || viewport_delta_pos.y != 0.0) { TranslateWindowsInViewport(viewport, viewport.LastPos, viewport.Pos, viewport.LastSize, viewport.Size) }

		// Update DPI scale
		new_dpi_scale : f32
		if g.PlatformIO.Platform_GetWindowDpiScale != nil && platform_funcs_available { new_dpi_scale = g.PlatformIO.Platform_GetWindowDpiScale(viewport) }
		else if viewport.PlatformMonitor != -1 { new_dpi_scale = g.PlatformIO.Monitors.Data[viewport.PlatformMonitor].DpiScale }
		else { new_dpi_scale = (viewport.DpiScale != 0.0) ? viewport.DpiScale : 1.0 }
		IM_ASSERT(new_dpi_scale > 0.0 && new_dpi_scale < 99.0); // Typical correct values would be between 1.0f and 4.0f
		if viewport.DpiScale != 0.0 && new_dpi_scale != viewport.DpiScale {
			scale_factor : f32 = new_dpi_scale / viewport.DpiScale
			if (g.IO.ConfigFlags & ImGuiConfigFlags_.ImGuiConfigFlags_DpiEnableScaleViewports) != {} { ScaleWindowsInViewport(viewport, scale_factor) }
			//if (viewport == GetMainViewport())
			//    g.PlatformInterface.SetWindowSize(viewport, viewport->Size * scale_factor);

			// Scale our window moving pivot so that the window will rescale roughly around the mouse position.
			// FIXME-VIEWPORT: This currently creates a resizing feedback loop when a window is straddling a DPI transition border.
			// (Minor: since our sizes do not perfectly linearly scale, deferring the click offset scale until we know the actual window scale ratio may get us slightly more precise mouse positioning.)
			//if (g.MovingWindow != NULL && g.MovingWindow->Viewport == viewport)
			//    g.ActiveIdClickOffset = ImTrunc(g.ActiveIdClickOffset * scale_factor);
		}
		viewport.DpiScale = new_dpi_scale
	}

	// Update fallback monitor
	g.PlatformMonitorsFullWorkRect = ImRect{{+FLT_MAX, +FLT_MAX}, {-FLT_MAX, -FLT_MAX}}
	if g.PlatformIO.Monitors.Size == 0 {
		monitor : ^ImGuiPlatformMonitor = &g.FallbackMonitor
		monitor.MainPos = main_viewport.Pos
		monitor.MainSize = main_viewport.Size
		monitor.WorkPos = main_viewport.WorkPos
		monitor.WorkSize = main_viewport.WorkSize
		monitor.DpiScale = main_viewport.DpiScale
		Add(&g.PlatformMonitorsFullWorkRect, monitor.WorkPos)
		Add(&g.PlatformMonitorsFullWorkRect, monitor.WorkPos + monitor.WorkSize)
	}
	else {
		g.FallbackMonitor = g.PlatformIO.Monitors.Data[0]
	}
	for monitor in g.PlatformIO.Monitors.Data[:g.PlatformIO.Monitors.Size] {
		Add(&g.PlatformMonitorsFullWorkRect, monitor.WorkPos)
		Add(&g.PlatformMonitorsFullWorkRect, monitor.WorkPos + monitor.WorkSize)
	}

	if !viewports_enabled {
		g.MouseViewport = main_viewport
		return
	}

	// Mouse handling: decide on the actual mouse viewport for this frame between the active/focused viewport and the hovered viewport.
	// Note that 'viewport_hovered' should skip over any viewport that has the ImGuiViewportFlags_NoInputs flags set.
	viewport_hovered : ^ImGuiViewportP = nil
	if (g.IO.BackendFlags & ImGuiBackendFlags_.ImGuiBackendFlags_HasMouseHoveredViewport) != {} {
		viewport_hovered = g.IO.MouseHoveredViewport != 0 ? cast(^ImGuiViewportP) FindViewportByID(g.IO.MouseHoveredViewport) : nil
		if viewport_hovered != nil && (viewport_hovered.Flags & ImGuiViewportFlags_.ImGuiViewportFlags_NoInputs) != {} {
			// Backend failed to handle _NoInputs viewport: revert to our fallback.
			viewport_hovered = FindHoveredViewportFromPlatformWindowStack(g.IO.MousePos)
		}
	}
	else {
		// If the backend doesn't know how to honor ImGuiViewportFlags_NoInputs, we do a search ourselves. Note that this search:
		// A) won't take account of the possibility that non-imgui windows may be in-between our dragged window and our target window.
		// B) won't take account of how the backend apply parent<>child relationship to secondary viewports, which affects their Z order.
		// C) uses LastFrameAsRefViewport as a flawed replacement for the last time a window was focused (we could/should fix that by introducing Focus functions in PlatformIO)
		viewport_hovered = FindHoveredViewportFromPlatformWindowStack(g.IO.MousePos)
	}
	if viewport_hovered != nil { g.MouseLastHoveredViewport = viewport_hovered }
	else if g.MouseLastHoveredViewport == nil { g.MouseLastHoveredViewport = g.Viewports.Data[0] }

	// Update mouse reference viewport
	// (when moving a window we aim at its viewport, but this will be overwritten below if we go in drag and drop mode)
	// (MovingViewport->Viewport will be NULL in the rare situation where the window disappared while moving, set UpdateMouseMovingWindowNewFrame() for details)
	if g.MovingWindow != nil && g.MovingWindow.Viewport != nil { g.MouseViewport = g.MovingWindow.Viewport }
	else { g.MouseViewport = g.MouseLastHoveredViewport }

	// When dragging something, always refer to the last hovered viewport.
	// - when releasing a moving window we will revert to aiming behind (at viewport_hovered)
	// - when we are between viewports, our dragged preview will tend to show in the last viewport _even_ if we don't have tooltips in their viewports (when lacking monitor info)
	// - consider the case of holding on a menu item to browse child menus: even thou a mouse button is held, there's no active id because menu items only react on mouse release.
	// FIXME-VIEWPORT: This is essentially broken, when ImGuiBackendFlags_HasMouseHoveredViewport is set we want to trust when viewport_hovered==NULL and use that.
	is_mouse_dragging_with_an_expected_destination : bool = g.DragDropActive
	if is_mouse_dragging_with_an_expected_destination && viewport_hovered == nil { viewport_hovered = g.MouseLastHoveredViewport }
	if is_mouse_dragging_with_an_expected_destination || g.ActiveId == 0 || !IsAnyMouseDown() { if viewport_hovered != nil && viewport_hovered != g.MouseViewport && (viewport_hovered.Flags & ImGuiViewportFlags_.ImGuiViewportFlags_NoInputs) == {} { g.MouseViewport = viewport_hovered } }

	IM_ASSERT(g.MouseViewport != nil)
}

// Update user-facing viewport list (g.Viewports -> g.PlatformIO.Viewports after filtering out some)
UpdateViewportsEndFrame :: proc()
{
	g : ^ImGuiContext = GImGui
	resize(&g.PlatformIO.Viewports, 0)
	for i : i32 = 0; i < g.Viewports.Size; i += 1 {
		viewport : ^ImGuiViewportP = g.Viewports.Data[i]
		viewport.LastPos = viewport.Pos
		viewport.LastSize = viewport.Size
		if viewport.LastFrameActive < g.FrameCount || viewport.Size.x <= 0.0 || viewport.Size.y <= 0.0 { if i > 0 {
			// Always include main viewport in the list
			continue
		} }
		if viewport.Window != nil && !IsWindowActiveAndVisible(viewport.Window) { continue }
		if i > 0 { IM_ASSERT(viewport.Window != nil) }
		push_back(&g.PlatformIO.Viewports, viewport)
	}

	ClearRequestFlags(g.Viewports.Data[0]); // Clear main viewport flags because UpdatePlatformWindows() won't do it and may not even be called
}

// Using an arbitrary constant instead of e.g. ImHashStr("ViewportDefault", 0); so it's easier to spot in the debugger. The exact value doesn't matter.
// FIXME: We should ideally refactor the system to call this every frame (we currently don't)
AddUpdateViewport :: proc(window : ^ImGuiWindow, id : ImGuiID, pos : ImVec2, size : ImVec2, flags : ImGuiViewportFlags) -> ^ImGuiViewportP
{
	g : ^ImGuiContext = GImGui
	IM_ASSERT(id != 0)

	flags := flags
	flags |= ImGuiViewportFlags_.ImGuiViewportFlags_IsPlatformWindow
	if window != nil {
		if g.MovingWindow != nil && g.MovingWindow.RootWindowDockTree == window { flags |= ImGuiViewportFlags_.ImGuiViewportFlags_NoInputs | ImGuiViewportFlags_.ImGuiViewportFlags_NoFocusOnAppearing }
		if (window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoMouseInputs) != {} && (window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoNavInputs) != {} { flags |= ImGuiViewportFlags_.ImGuiViewportFlags_NoInputs }
		if (window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoFocusOnAppearing) != {} { flags |= ImGuiViewportFlags_.ImGuiViewportFlags_NoFocusOnAppearing }
	}

	viewport : ^ImGuiViewportP = cast(^ImGuiViewportP) FindViewportByID(id)
	if viewport != nil {
		// Always update for main viewport as we are already pulling correct platform pos/size (see #4900)
		if !viewport.PlatformRequestMove || viewport.ID == IMGUI_VIEWPORT_DEFAULT_ID { viewport.Pos = pos }
		if !viewport.PlatformRequestResize || viewport.ID == IMGUI_VIEWPORT_DEFAULT_ID { viewport.Size = size }
		viewport.Flags = flags | (viewport.Flags & (ImGuiViewportFlags_.ImGuiViewportFlags_IsMinimized | ImGuiViewportFlags_.ImGuiViewportFlags_IsFocused)); // Preserve existing flags
	}
	else {
		// New viewport
		viewport = IM_NEW(ImGuiViewportP)
		viewport.ID = id
		viewport.Idx = g.Viewports.Size
		viewport.LastPos = pos; viewport.Pos = viewport.LastPos
		viewport.LastSize = size; viewport.Size = viewport.LastSize
		viewport.Flags = flags
		UpdateViewportPlatformMonitor(viewport)
		push_back(&g.Viewports, viewport)
		post_incr(&g.ViewportCreatedCount)
		IMGUI_DEBUG_LOG_VIEWPORT(g, "[viewport] Add Viewport %08X '%s'\n", id, window != nil ? window.Name : "<NULL>")

		// We normally setup for all viewports in NewFrame() but here need to handle the mid-frame creation of a new viewport.
		// We need to extend the fullscreen clip rect so the OverlayDrawList clip is correct for that the first frame
		g.DrawListSharedData.ClipRectFullscreen.x = ImMin(g.DrawListSharedData.ClipRectFullscreen.x, viewport.Pos.x)
		g.DrawListSharedData.ClipRectFullscreen.y = ImMin(g.DrawListSharedData.ClipRectFullscreen.y, viewport.Pos.y)
		g.DrawListSharedData.ClipRectFullscreen.z = ImMax(g.DrawListSharedData.ClipRectFullscreen.z, viewport.Pos.x + viewport.Size.x)
		g.DrawListSharedData.ClipRectFullscreen.w = ImMax(g.DrawListSharedData.ClipRectFullscreen.w, viewport.Pos.y + viewport.Size.y)

		// Store initial DpiScale before the OS platform window creation, based on expected monitor data.
		// This is so we can select an appropriate font size on the first frame of our window lifetime
		if viewport.PlatformMonitor != -1 { viewport.DpiScale = g.PlatformIO.Monitors.Data[viewport.PlatformMonitor].DpiScale }
	}

	viewport.Window = window
	viewport.LastFrameActive = g.FrameCount
	UpdateWorkRect(viewport)
	IM_ASSERT(window == nil || viewport.ID == window.ID)

	if window != nil { window.ViewportOwned = true }

	return viewport
}

DestroyViewport :: proc(viewport : ^ImGuiViewportP)
{
	// Clear references to this viewport in windows (window->ViewportId becomes the master data)
	g : ^ImGuiContext = GImGui
	for window in g.Windows.Data[:g.Windows.Size] {
		if window.Viewport != viewport { continue }
		window.Viewport = nil
		window.ViewportOwned = false
	}

	if viewport == g.MouseLastHoveredViewport { g.MouseLastHoveredViewport = nil }

	// Destroy
	IMGUI_DEBUG_LOG_VIEWPORT(g, "[viewport] Delete Viewport %08X '%s'\n", viewport.ID, viewport.Window != nil ? viewport.Window.Name : "n/a")
	DestroyPlatformWindow(viewport); // In most circumstances the platform window will already be destroyed here.
	IM_ASSERT(contains(g.PlatformIO.Viewports, cast(^ImGuiViewport)viewport) == false)
	IM_ASSERT(g.Viewports.Data[viewport.Idx] == viewport)
	erase(&g.Viewports, &g.Viewports.Data[viewport.Idx])
	IM_DELETE(viewport)
}

// FIXME-VIEWPORT: This is all super messy and ought to be clarified or rewritten.
WindowSelectViewport :: proc(window : ^ImGuiWindow)
{
	g : ^ImGuiContext = GImGui
	flags : ImGuiWindowFlags = window.Flags
	window.ViewportAllowPlatformMonitorExtend = -1

	// Restore main viewport if multi-viewport is not supported by the backend
	main_viewport : ^ImGuiViewportP = cast(^ImGuiViewportP) cast(rawptr) GetMainViewport()
	if (g.ConfigFlagsCurrFrame & ImGuiConfigFlags_.ImGuiConfigFlags_ViewportsEnable) == {} {
		SetWindowViewport(window, main_viewport)
		return
	}
	window.ViewportOwned = false

	// Appearing popups reset their viewport so they can inherit again
	if (flags & (ImGuiWindowFlags_.ImGuiWindowFlags_Popup | ImGuiWindowFlags_.ImGuiWindowFlags_Tooltip)) != {} && window.Appearing {
		window.Viewport = nil
		window.ViewportId = 0
	}

	if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_.ImGuiNextWindowDataFlags_HasViewport) == {} {
		// By default inherit from parent window
		if window.Viewport == nil && window.ParentWindow != nil && (!window.ParentWindow.IsFallbackWindow || window.ParentWindow.WasActive) { window.Viewport = window.ParentWindow.Viewport }

		// Attempt to restore saved viewport id (= window that hasn't been activated yet), try to restore the viewport based on saved 'window->ViewportPos' restored from .ini file
		if window.Viewport == nil && window.ViewportId != 0 {
			window.Viewport = cast(^ImGuiViewportP) FindViewportByID(window.ViewportId)
			if window.Viewport == nil && window.ViewportPos.x != FLT_MAX && window.ViewportPos.y != FLT_MAX { window.Viewport = AddUpdateViewport(window, window.ID, window.ViewportPos, window.Size, ImGuiViewportFlags_.ImGuiViewportFlags_None) }
		}
	}

	lock_viewport : bool = false
	if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_.ImGuiNextWindowDataFlags_HasViewport) != {} {
		// Code explicitly request a viewport
		window.Viewport = cast(^ImGuiViewportP) FindViewportByID(g.NextWindowData.ViewportId)
		window.ViewportId = g.NextWindowData.ViewportId; // Store ID even if Viewport isn't resolved yet.
		if window.Viewport != nil && (window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_DockNodeHost) != {} && window.Viewport.Window != nil {
			window.Viewport.Window = window
			window.ViewportId = window.ID; window.Viewport.ID = window.ViewportId; // Overwrite ID (always owned by node)
		}
		lock_viewport = true
	}
	else if (flags & ImGuiWindowFlags_.ImGuiWindowFlags_ChildWindow) != {} || (flags & ImGuiWindowFlags_.ImGuiWindowFlags_ChildMenu) != {} {
		// Always inherit viewport from parent window
		if window.DockNode != nil && window.DockNode.HostWindow != nil { IM_ASSERT(window.DockNode.HostWindow.Viewport == window.ParentWindow.Viewport) }
		window.Viewport = window.ParentWindow.Viewport
	}
	else if window.DockNode != nil && window.DockNode.HostWindow != nil {
		// This covers the "always inherit viewport from parent window" case for when a window reattach to a node that was just created mid-frame
		window.Viewport = window.DockNode.HostWindow.Viewport
	}
	else if (flags & ImGuiWindowFlags_.ImGuiWindowFlags_Tooltip) != {} {
		window.Viewport = g.MouseViewport
	}
	else if GetWindowAlwaysWantOwnViewport(window) {
		window.Viewport = AddUpdateViewport(window, window.ID, window.Pos, window.Size, ImGuiViewportFlags_.ImGuiViewportFlags_None)
	}
	else if g.MovingWindow != nil && g.MovingWindow.RootWindowDockTree == window && IsMousePosValid() {
		if window.Viewport != nil && window.Viewport.Window == window { window.Viewport = AddUpdateViewport(window, window.ID, window.Pos, window.Size, ImGuiViewportFlags_.ImGuiViewportFlags_None) }
	}
	else {
		// Merge into host viewport?
		// We cannot test window->ViewportOwned as it set lower in the function.
		// Testing (g.ActiveId == 0 || g.ActiveIdAllowOverlap) to avoid merging during a short-term widget interaction. Main intent was to avoid during resize (see #4212)
		try_to_merge_into_host_viewport : bool = (window.Viewport != nil && window == window.Viewport.Window && (g.ActiveId == 0 || g.ActiveIdAllowOverlap))
		if try_to_merge_into_host_viewport { UpdateTryMergeWindowIntoHostViewports(window) }
	}

	// Fallback: merge in default viewport if z-order matches, otherwise create a new viewport
	if window.Viewport == nil { if !UpdateTryMergeWindowIntoHostViewport(window, main_viewport) { window.Viewport = AddUpdateViewport(window, window.ID, window.Pos, window.Size, ImGuiViewportFlags_.ImGuiViewportFlags_None) } }

	// Mark window as allowed to protrude outside of its viewport and into the current monitor
	if !lock_viewport {
		if (flags & (ImGuiWindowFlags_.ImGuiWindowFlags_Tooltip | ImGuiWindowFlags_.ImGuiWindowFlags_Popup)) != {} {
			// We need to take account of the possibility that mouse may become invalid.
			// Popups/Tooltip always set ViewportAllowPlatformMonitorExtend so GetWindowAllowedExtentRect() will return full monitor bounds.
			mouse_ref : ImVec2 = (flags & ImGuiWindowFlags_.ImGuiWindowFlags_Tooltip) != {} ? g.IO.MousePos : back(&g.BeginPopupStack).OpenMousePos
			use_mouse_ref : bool = (!g.NavCursorVisible || !g.NavHighlightItemUnderNav || g.NavWindow == nil)
			mouse_valid : bool = IsMousePosValid(&mouse_ref)
			if (window.Appearing || (flags & (ImGuiWindowFlags_.ImGuiWindowFlags_Tooltip | ImGuiWindowFlags_.ImGuiWindowFlags_ChildMenu)) != {}) && (!use_mouse_ref || mouse_valid) { window.ViewportAllowPlatformMonitorExtend = FindPlatformMonitorForPos((use_mouse_ref && mouse_valid) ? mouse_ref : NavCalcPreferredRefPos()) }
			else { window.ViewportAllowPlatformMonitorExtend = cast(i32) window.Viewport.PlatformMonitor }
		}
		else if window.Viewport != nil && window != window.Viewport.Window && window.Viewport.Window != nil && (flags & ImGuiWindowFlags_.ImGuiWindowFlags_ChildWindow) == {} && window.DockNode == nil {
			// When called from Begin() we don't have access to a proper version of the Hidden flag yet, so we replicate this code.
			will_be_visible : bool = (window.DockIsActive && !window.DockTabIsVisible) ? false : true
			if (window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_DockNodeHost) != {} && window.Viewport.LastFrameActive < g.FrameCount && will_be_visible {
				// Steal/transfer ownership
				IMGUI_DEBUG_LOG_VIEWPORT(g, "[viewport] Window '%s' steal Viewport %08X from Window '%s'\n", window.Name, window.Viewport.ID, window.Viewport.Window.Name)
				window.Viewport.Window = window
				window.Viewport.ID = window.ID
				window.Viewport.LastNameHash = 0
			}
			else if !UpdateTryMergeWindowIntoHostViewports(window) {
				// Merge?
				// New viewport
				window.Viewport = AddUpdateViewport(window, window.ID, window.Pos, window.Size, ImGuiViewportFlags_.ImGuiViewportFlags_NoFocusOnAppearing)
			}
		}
		else if window.ViewportAllowPlatformMonitorExtend < 0 && (flags & ImGuiWindowFlags_.ImGuiWindowFlags_ChildWindow) == {} {
			// Regular (non-child, non-popup) windows by default are also allowed to protrude
			// Child windows are kept contained within their parent.
			window.ViewportAllowPlatformMonitorExtend = cast(i32) window.Viewport.PlatformMonitor
		}
	}

	// Update flags
	window.ViewportOwned = (window == window.Viewport.Window)
	window.ViewportId = window.Viewport.ID

	// If the OS window has a title bar, hide our imgui title bar
	//if (window->ViewportOwned && !(window->Viewport->Flags & ImGuiViewportFlags_NoDecoration))
	//    window->Flags |= ImGuiWindowFlags_NoTitleBar;
}

WindowSyncOwnedViewport :: proc(window : ^ImGuiWindow, parent_window_in_stack : ^ImGuiWindow)
{
	g : ^ImGuiContext = GImGui

	viewport_rect_changed : bool = false

	// Synchronize window --> viewport in most situations
	// Synchronize viewport -> window in case the platform window has been moved or resized from the OS/WM
	if window.Viewport.PlatformRequestMove {
		window.Pos = window.Viewport.Pos
		MarkIniSettingsDirty(window)
	}
	else if memcmp(&window.Viewport.Pos, &window.Pos, size_of(window.Pos)) != 0 {
		viewport_rect_changed = true
		window.Viewport.Pos = window.Pos
	}

	if window.Viewport.PlatformRequestResize {
		window.SizeFull = window.Viewport.Size; window.Size = window.SizeFull
		MarkIniSettingsDirty(window)
	}
	else if memcmp(&window.Viewport.Size, &window.Size, size_of(window.Size)) != 0 {
		viewport_rect_changed = true
		window.Viewport.Size = window.Size
	}
	UpdateWorkRect(window.Viewport)

	// The viewport may have changed monitor since the global update in UpdateViewportsNewFrame()
	// Either a SetNextWindowPos() call in the current frame or a SetWindowPos() call in the previous frame may have this effect.
	if viewport_rect_changed { UpdateViewportPlatformMonitor(window.Viewport) }

	// Update common viewport flags
	viewport_flags_to_clear : ImGuiViewportFlags = ImGuiViewportFlags_.ImGuiViewportFlags_TopMost | ImGuiViewportFlags_.ImGuiViewportFlags_NoTaskBarIcon | ImGuiViewportFlags_.ImGuiViewportFlags_NoDecoration | ImGuiViewportFlags_.ImGuiViewportFlags_NoRendererClear
	viewport_flags : ImGuiViewportFlags = window.Viewport.Flags & cast(ImGuiViewportFlags)~cast(u32)viewport_flags_to_clear
	window_flags : ImGuiWindowFlags = window.Flags
	is_modal : bool = (window_flags & ImGuiWindowFlags_.ImGuiWindowFlags_Modal) != {}
	is_short_lived_floating_window : bool = (window_flags & (ImGuiWindowFlags_.ImGuiWindowFlags_ChildMenu | ImGuiWindowFlags_.ImGuiWindowFlags_Tooltip | ImGuiWindowFlags_.ImGuiWindowFlags_Popup)) != {}
	if (window_flags & ImGuiWindowFlags_.ImGuiWindowFlags_Tooltip) != {} { viewport_flags |= ImGuiViewportFlags_.ImGuiViewportFlags_TopMost }
	if (g.IO.ConfigViewportsNoTaskBarIcon || is_short_lived_floating_window) && !is_modal { viewport_flags |= ImGuiViewportFlags_.ImGuiViewportFlags_NoTaskBarIcon }
	if g.IO.ConfigViewportsNoDecoration || is_short_lived_floating_window { viewport_flags |= ImGuiViewportFlags_.ImGuiViewportFlags_NoDecoration }

	// Not correct to set modal as topmost because:
	// - Because other popups can be stacked above a modal (e.g. combo box in a modal)
	// - ImGuiViewportFlags_TopMost is currently handled different in backends: in Win32 it is "appear top most" whereas in GLFW and SDL it is "stay topmost"
	//if (flags & ImGuiWindowFlags_Modal)
	//    viewport_flags |= ImGuiViewportFlags_TopMost;

	// For popups and menus that may be protruding out of their parent viewport, we enable _NoFocusOnClick so that clicking on them
	// won't steal the OS focus away from their parent window (which may be reflected in OS the title bar decoration).
	// Setting _NoFocusOnClick would technically prevent us from bringing back to front in case they are being covered by an OS window from a different app,
	// but it shouldn't be much of a problem considering those are already popups that are closed when clicking elsewhere.
	if is_short_lived_floating_window && !is_modal { viewport_flags |= ImGuiViewportFlags_.ImGuiViewportFlags_NoFocusOnAppearing | ImGuiViewportFlags_.ImGuiViewportFlags_NoFocusOnClick }

	// We can overwrite viewport flags using ImGuiWindowClass (advanced users)
	if window.WindowClass.ViewportFlagsOverrideSet != {} { viewport_flags |= window.WindowClass.ViewportFlagsOverrideSet }
	if window.WindowClass.ViewportFlagsOverrideClear != {} { viewport_flags &= cast(ImGuiViewportFlags)~cast(u32)window.WindowClass.ViewportFlagsOverrideClear }

	// We can also tell the backend that clearing the platform window won't be necessary,
	// as our window background is filling the viewport and we have disabled BgAlpha.
	// FIXME: Work on support for per-viewport transparency (#2766)
	if (window_flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoBackground) == {} { viewport_flags |= ImGuiViewportFlags_.ImGuiViewportFlags_NoRendererClear }

	window.Viewport.Flags = viewport_flags

	// Update parent viewport ID
	// (the !IsFallbackWindow test mimic the one done in WindowSelectViewport())
	if window.WindowClass.ParentViewportId != ~cast(ImGuiID)(0) { window.Viewport.ParentViewportId = window.WindowClass.ParentViewportId }
	else if (window_flags & (ImGuiWindowFlags_.ImGuiWindowFlags_Popup | ImGuiWindowFlags_.ImGuiWindowFlags_Tooltip)) != {} && parent_window_in_stack != nil && (!parent_window_in_stack.IsFallbackWindow || parent_window_in_stack.WasActive) { window.Viewport.ParentViewportId = parent_window_in_stack.Viewport.ID }
	else { window.Viewport.ParentViewportId = g.IO.ConfigViewportsNoDefaultParent ? 0 : IMGUI_VIEWPORT_DEFAULT_ID }
}

// (Optional) Platform/OS interface for multi-viewport support
// Read comments around the ImGuiPlatformIO structure for more details.
// Note: You may use GetWindowViewport() to get the current viewport of the current window.
// call in main loop. will call CreateWindow/ResizeWindow/etc. platform functions for each secondary viewport, and DestroyWindow for each inactive viewport.
// Called by user at the end of the main loop, after EndFrame()
// This will handle the creation/update of all OS windows via function defined in the ImGuiPlatformIO api.
UpdatePlatformWindows :: proc()
{
	g : ^ImGuiContext = GImGui
	IM_ASSERT(g.FrameCountEnded == g.FrameCount, "Forgot to call Render() or EndFrame() before UpdatePlatformWindows()?")
	IM_ASSERT(g.FrameCountPlatformEnded < g.FrameCount)
	g.FrameCountPlatformEnded = g.FrameCount
	if (g.ConfigFlagsCurrFrame & ImGuiConfigFlags_.ImGuiConfigFlags_ViewportsEnable) == {} { return }

	// Create/resize/destroy platform windows to match each active viewport.
	// Skip the main viewport (index 0), which is always fully handled by the application!
	for i : i32 = 1; i < g.Viewports.Size; i += 1 {
		viewport : ^ImGuiViewportP = g.Viewports.Data[i]

		// Destroy platform window if the viewport hasn't been submitted or if it is hosting a hidden window
		// (the implicit/fallback Debug##Default window will be registering its viewport then be disabled, causing a dummy DestroyPlatformWindow to be made each frame)
		destroy_platform_window : bool = false
		destroy_platform_window |= (viewport.LastFrameActive < g.FrameCount - 1)
		destroy_platform_window |= (viewport.Window != nil && !IsWindowActiveAndVisible(viewport.Window))
		if destroy_platform_window {
			DestroyPlatformWindow(viewport)
			continue
		}

		// New windows that appears directly in a new viewport won't always have a size on their first frame
		if viewport.LastFrameActive < g.FrameCount || viewport.Size.x <= 0 || viewport.Size.y <= 0 { continue }

		// Create window
		is_new_platform_window : bool = (viewport.PlatformWindowCreated == false)
		if is_new_platform_window {
			IMGUI_DEBUG_LOG_VIEWPORT(g, "[viewport] Create Platform Window %08X '%s'\n", viewport.ID, viewport.Window != nil ? viewport.Window.Name : "n/a")
			g.PlatformIO.Platform_CreateWindow(viewport)
			if g.PlatformIO.Renderer_CreateWindow != nil { g.PlatformIO.Renderer_CreateWindow(viewport) }
			post_incr(&g.PlatformWindowsCreatedCount)
			viewport.LastNameHash = 0
			viewport.LastPlatformSize = ImVec2{FLT_MAX, FLT_MAX}; viewport.LastPlatformPos = viewport.LastPlatformSize; // By clearing those we'll enforce a call to Platform_SetWindowPos/Size below, before Platform_ShowWindow (FIXME: Is that necessary?)
			viewport.LastRendererSize = viewport.Size; // We don't need to call Renderer_SetWindowSize() as it is expected Renderer_CreateWindow() already did it.
			viewport.PlatformWindowCreated = true
		}

		// Apply Position and Size (from ImGui to Platform/Renderer backends)
		if (viewport.LastPlatformPos.x != viewport.Pos.x || viewport.LastPlatformPos.y != viewport.Pos.y) && !viewport.PlatformRequestMove { g.PlatformIO.Platform_SetWindowPos(viewport, viewport.Pos) }
		if (viewport.LastPlatformSize.x != viewport.Size.x || viewport.LastPlatformSize.y != viewport.Size.y) && !viewport.PlatformRequestResize { g.PlatformIO.Platform_SetWindowSize(viewport, viewport.Size) }
		if (viewport.LastRendererSize.x != viewport.Size.x || viewport.LastRendererSize.y != viewport.Size.y) && g.PlatformIO.Renderer_SetWindowSize != nil { g.PlatformIO.Renderer_SetWindowSize(viewport, viewport.Size) }
		viewport.LastPlatformPos = viewport.Pos
		viewport.LastRendererSize = viewport.Size; viewport.LastPlatformSize = viewport.LastRendererSize

		// Update title bar (if it changed)
		if window_for_title : ^ImGuiWindow = GetWindowForTitleDisplay(viewport.Window); window_for_title != nil {
			title_begin := window_for_title.Name
			title_end := FindRenderedTextEnd(title_begin)
			title_hash : ImGuiID = ImHashStr(title_begin[:title_end])
			if viewport.LastNameHash != title_hash {
				title_end_backup_c : u8 = title_begin[title_end]
				raw_data(title_begin)[title_end] = 0; // Cut existing buffer short instead of doing an alloc/free, no small gain.
				g.PlatformIO.Platform_SetWindowTitle(viewport, title_begin[:title_end])
				raw_data(title_begin)[title_end] = title_end_backup_c
				viewport.LastNameHash = title_hash
			}
		}

		// Update alpha (if it changed)
		if viewport.LastAlpha != viewport.Alpha && g.PlatformIO.Platform_SetWindowAlpha != nil { g.PlatformIO.Platform_SetWindowAlpha(viewport, viewport.Alpha) }
		viewport.LastAlpha = viewport.Alpha

		// Optional, general purpose call to allow the backend to perform general book-keeping even if things haven't changed.
		if g.PlatformIO.Platform_UpdateWindow != nil { g.PlatformIO.Platform_UpdateWindow(viewport) }

		if is_new_platform_window {
			// On startup ensure new platform window don't steal focus (give it a few frames, as nested contents may lead to viewport being created a few frames late)
			if g.FrameCount < 3 { viewport.Flags |= ImGuiViewportFlags_.ImGuiViewportFlags_NoFocusOnAppearing }

			// Show window
			g.PlatformIO.Platform_ShowWindow(viewport)

			// Even without focus, we assume the window becomes front-most.
			// This is useful for our platform z-order heuristic when io.MouseHoveredViewport is not available.
			if viewport.LastFocusedStampCount != g.ViewportFocusedStampCount { viewport.LastFocusedStampCount = pre_incr(&g.ViewportFocusedStampCount) }
		}

		// Clear request flags
		ClearRequestFlags(viewport)
	}
}

// call in main loop. will call RenderWindow/SwapBuffers platform functions for each secondary viewport which doesn't have the ImGuiViewportFlags_Minimized flag set. May be reimplemented by user for custom rendering needs.
// This is a default/basic function for performing the rendering/swap of multiple Platform Windows.
// Custom renderers may prefer to not call this function at all, and instead iterate the publicly exposed platform data and handle rendering/sync themselves.
// The Render/Swap functions stored in ImGuiPlatformIO are merely here to allow for this helper to exist, but you can do it yourself:
//
//    ImGuiPlatformIO& platform_io = ImGui::GetPlatformIO();
//    for (int i = 1; i < platform_io.Viewports.Size; i++)
//        if ((platform_io.Viewports.Data[i]->Flags & ImGuiViewportFlags_Minimized) == 0)
//            MyRenderFunction(platform_io.Viewports.Data[i], my_args);
//    for (int i = 1; i < platform_io.Viewports.Size; i++)
//        if ((platform_io.Viewports.Data[i]->Flags & ImGuiViewportFlags_Minimized) == 0)
//            MySwapBufferFunction(platform_io.Viewports.Data[i], my_args);
//
RenderPlatformWindowsDefault :: proc(platform_render_arg : rawptr, renderer_render_arg : rawptr)
{
	// Skip the main viewport (index 0), which is always fully handled by the application!
	platform_io : ^ImGuiPlatformIO = GetPlatformIO()
	for i : i32 = 1; i < platform_io.Viewports.Size; i += 1 {
		viewport : ^ImGuiViewport = platform_io.Viewports.Data[i]
		if (viewport.Flags & ImGuiViewportFlags_.ImGuiViewportFlags_IsMinimized) != {} { continue }
		if platform_io.Platform_RenderWindow != nil { platform_io.Platform_RenderWindow(viewport, platform_render_arg) }
		if platform_io.Renderer_RenderWindow != nil { platform_io.Renderer_RenderWindow(viewport, renderer_render_arg) }
	}

	for i : i32 = 1; i < platform_io.Viewports.Size; i += 1 {
		viewport : ^ImGuiViewport = platform_io.Viewports.Data[i]
		if (viewport.Flags & ImGuiViewportFlags_.ImGuiViewportFlags_IsMinimized) != {} { continue }
		if platform_io.Platform_SwapBuffers != nil { platform_io.Platform_SwapBuffers(viewport, platform_render_arg) }
		if platform_io.Renderer_SwapBuffers != nil { platform_io.Renderer_SwapBuffers(viewport, renderer_render_arg) }
	}
}

FindPlatformMonitorForPos :: proc(pos : ImVec2) -> i32
{
	g : ^ImGuiContext = GImGui
	for monitor_n : i32 = 0; monitor_n < g.PlatformIO.Monitors.Size; monitor_n += 1 {
		monitor : ^ImGuiPlatformMonitor = &g.PlatformIO.Monitors.Data[monitor_n]
		if Contains(ImRect{monitor.MainPos, monitor.MainPos + monitor.MainSize}, pos) { return monitor_n }
	}

	return -1
}

// Search for the monitor with the largest intersection area with the given rectangle
// We generally try to avoid searching loops but the monitor count should be very small here
// FIXME-OPT: We could test the last monitor used for that viewport first, and early
FindPlatformMonitorForRect :: proc(rect : ImRect) -> i32
{
	g : ^ImGuiContext = GImGui

	monitor_count : i32 = g.PlatformIO.Monitors.Size
	if monitor_count <= 1 { return monitor_count - 1 }

	// Use a minimum threshold of 1.0f so a zero-sized rect won't false positive, and will still find the correct monitor given its position.
	// This is necessary for tooltips which always resize down to zero at first.
	surface_threshold : f32 = ImMax(GetWidth(rect) * GetHeight(rect) * 0.5, 1.0)
	best_monitor_n : i32 = -1
	best_monitor_surface : f32 = 0.001

	for monitor_n : i32 = 0; monitor_n < g.PlatformIO.Monitors.Size && best_monitor_surface < surface_threshold; monitor_n += 1 {
		monitor : ^ImGuiPlatformMonitor = &g.PlatformIO.Monitors.Data[monitor_n]
		monitor_rect : ImRect = ImRect{monitor.MainPos, monitor.MainPos + monitor.MainSize}
		if Contains(monitor_rect, rect) { return monitor_n }
		overlapping_rect : ImRect = rect
		ClipWithFull(&overlapping_rect, monitor_rect)
		overlapping_surface : f32 = GetWidth(overlapping_rect) * GetHeight(overlapping_rect)
		if overlapping_surface < best_monitor_surface { continue }
		best_monitor_surface = overlapping_surface
		best_monitor_n = monitor_n
	}

	return best_monitor_n
}

// Update monitor from viewport rectangle (we'll use this info to clamp windows and save windows lost in a removed monitor)
UpdateViewportPlatformMonitor :: proc(viewport : ^ImGuiViewportP)
{
	viewport.PlatformMonitor = cast(i16) FindPlatformMonitorForRect(GetMainRect(viewport))
}

// Return value is always != NULL, but don't hold on it across frames.
GetViewportPlatformMonitor :: proc(viewport_p : ^ImGuiViewport) -> ^ImGuiPlatformMonitor
{
	g : ^ImGuiContext = GImGui
	viewport : ^ImGuiViewportP = cast(^ImGuiViewportP) cast(rawptr) viewport_p
	monitor_idx := cast(i32) viewport.PlatformMonitor
	if monitor_idx >= 0 && monitor_idx < g.PlatformIO.Monitors.Size { return &g.PlatformIO.Monitors.Data[monitor_idx] }
	return &g.FallbackMonitor
}

DestroyPlatformWindow :: proc(viewport : ^ImGuiViewportP)
{
	g : ^ImGuiContext = GImGui
	if viewport.PlatformWindowCreated {
		IMGUI_DEBUG_LOG_VIEWPORT(g, "[viewport] Destroy Platform Window %08X '%s'\n", viewport.ID, viewport.Window != nil ? viewport.Window.Name : "n/a")
		if g.PlatformIO.Renderer_DestroyWindow != nil { g.PlatformIO.Renderer_DestroyWindow(viewport) }
		if g.PlatformIO.Platform_DestroyWindow != nil { g.PlatformIO.Platform_DestroyWindow(viewport) }
		IM_ASSERT(viewport.RendererUserData == nil && viewport.PlatformUserData == nil)

		// Don't clear PlatformWindowCreated for the main viewport, as we initially set that up to true in Initialize()
		// The righter way may be to leave it to the backend to set this flag all-together, and made the flag public.
		if viewport.ID != IMGUI_VIEWPORT_DEFAULT_ID { viewport.PlatformWindowCreated = false }
	}
	else {
		IM_ASSERT(viewport.RendererUserData == nil && viewport.PlatformUserData == nil && viewport.PlatformHandle == nil)
	}
	viewport.PlatformHandle = nil; viewport.PlatformUserData = viewport.PlatformHandle; viewport.RendererUserData = viewport.PlatformUserData
	ClearRequestFlags(viewport)
}

// call DestroyWindow platform functions for all viewports. call from backend Shutdown() if you need to close platform windows before imgui shutdown. otherwise will be called by DestroyContext().
DestroyPlatformWindows :: proc()
{
	// We call the destroy window on every viewport (including the main viewport, index 0) to give a chance to the backend
	// to clear any data they may have stored in e.g. PlatformUserData, RendererUserData.
	// It is convenient for the platform backend code to store something in the main viewport, in order for e.g. the mouse handling
	// code to operator a consistent manner.
	// It is expected that the backend can handle calls to Renderer_DestroyWindow/Platform_DestroyWindow without
	// crashing if it doesn't have data stored.
	g : ^ImGuiContext = GImGui
	for viewport in g.Viewports.Data[:g.Viewports.Size] { DestroyPlatformWindow(viewport) }
}


//-----------------------------------------------------------------------------
// [SECTION] DOCKING
//-----------------------------------------------------------------------------
// Docking: Internal Types
// Docking: Forward Declarations
// Docking: ImGuiDockContext
// Docking: ImGuiDockContext Docking/Undocking functions
// Docking: ImGuiDockNode
// Docking: ImGuiDockNode Tree manipulation functions
// Docking: Public Functions (SetWindowDock, DockSpace, DockSpaceOverViewport)
// Docking: Builder Functions
// Docking: Begin/End Support Functions (called from Begin/End)
// Docking: Settings
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// Typical Docking call flow: (root level is generally public API):
//-----------------------------------------------------------------------------
// - NewFrame()                               new dear imgui frame
//    | DockContextNewFrameUpdateUndocking()  - process queued undocking requests
//    | - DockContextProcessUndockWindow()    - process one window undocking request
//    | - DockContextProcessUndockNode()      - process one whole node undocking request
//    | DockContextNewFrameUpdateUndocking()  - process queue docking requests, create floating dock nodes
//    | - update g.HoveredDockNode            - [debug] update node hovered by mouse
//    | - DockContextProcessDock()            - process one docking request
//    | - DockNodeUpdate()
//    |   - DockNodeUpdateForRootNode()
//    |     - DockNodeUpdateFlagsAndCollapse()
//    |     - DockNodeFindInfo()
//    |   - destroy unused node or tab bar
//    |   - create dock node host window
//    |      - Begin() etc.
//    |   - DockNodeStartMouseMovingWindow()
//    |   - DockNodeTreeUpdatePosSize()
//    |   - DockNodeTreeUpdateSplitter()
//    |   - draw node background
//    |   - DockNodeUpdateTabBar()            - create/update tab bar for a docking node
//    |     - DockNodeAddTabBar()
//    |     - DockNodeWindowMenuUpdate()
//    |     - DockNodeCalcTabBarLayout()
//    |     - BeginTabBarEx()
//    |     - TabItemEx() calls
//    |     - EndTabBar()
//    |   - BeginDockableDragDropTarget()
//    |      - DockNodeUpdate()               - recurse into child nodes...
//-----------------------------------------------------------------------------
// - DockSpace()                              user submit a dockspace into a window
//    | Begin(Child)                          - create a child window
//    | DockNodeUpdate()                      - call main dock node update function
//    | End(Child)
//    | ItemSize()
//-----------------------------------------------------------------------------
// - Begin()
//    | BeginDocked()
//    | BeginDockableDragDropSource()
//    | BeginDockableDragDropTarget()
//    | - DockNodePreviewDockRender()
//-----------------------------------------------------------------------------
// - EndFrame()
//    | DockContextEndFrame()
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// Docking: Internal Types
//-----------------------------------------------------------------------------
// - ImGuiDockRequestType
// - ImGuiDockRequest
// - ImGuiDockPreviewData
// - ImGuiDockNodeSettings
// - ImGuiDockContext
//-----------------------------------------------------------------------------

ImGuiDockRequestType :: enum i32 {
	ImGuiDockRequestType_None = 0,
	ImGuiDockRequestType_Dock,
	ImGuiDockRequestType_Undock,
	ImGuiDockRequestType_Split, // Split is the same as Dock but without a DockPayload
}

// Docking system dock/undock queued request
ImGuiDockRequest :: struct {
	Type : ImGuiDockRequestType,
	DockTargetWindow : ^ImGuiWindow, // Destination/Target Window to dock into (may be a loose window or a DockNode, might be NULL in which case DockTargetNode cannot be NULL)
	DockTargetNode : ^ImGuiDockNode, // Destination/Target Node to dock into
	DockPayload : ^ImGuiWindow, // Source/Payload window to dock (may be a loose window or a DockNode), [Optional]
	DockSplitDir : ImGuiDir,
	DockSplitRatio : f32,
	DockSplitOuter : bool,
	UndockTargetWindow : ^ImGuiWindow,
	UndockTargetNode : ^ImGuiDockNode,
}

ImGuiDockRequest_init :: proc(this : ^ImGuiDockRequest)
{
	this.Type = ImGuiDockRequestType.ImGuiDockRequestType_None
	this.UndockTargetWindow = nil; this.DockPayload = this.UndockTargetWindow; this.DockTargetWindow = this.DockPayload
	this.UndockTargetNode = nil; this.DockTargetNode = this.UndockTargetNode
	this.DockSplitDir = ImGuiDir.ImGuiDir_None
	this.DockSplitRatio = 0.5
	this.DockSplitOuter = false
}

ImGuiDockPreviewData :: struct {
	FutureNode : ImGuiDockNode,
	IsDropAllowed : bool,
	IsCenterAvailable : bool,
	IsSidesAvailable : bool, // Hold your breath, grammar freaks..
	IsSplitDirExplicit : bool, // Set when hovered the drop rect (vs. implicit SplitDir==None when hovered the window)
	SplitNode : ^ImGuiDockNode,
	SplitDir : ImGuiDir,
	SplitRatio : f32,
	DropRectsDraw : [int(ImGuiDir.ImGuiDir_COUNT) + 1]ImRect, // May be slightly different from hit-testing drop rects used in DockNodeCalcDropRects()
}

ImGuiDockPreviewData_deinit :: proc(this : ^ImGuiDockPreviewData) { deinit(&this.FutureNode) }

ImGuiDockPreviewData_init :: proc(this : ^ImGuiDockPreviewData)
{
	init(&this.FutureNode, ImGuiID(0))
	this.IsSplitDirExplicit = false
	this.IsSidesAvailable = this.IsSplitDirExplicit
	this.IsCenterAvailable = this.IsSidesAvailable
	this.IsDropAllowed = this.IsCenterAvailable
	this.SplitNode = nil
	this.SplitDir = ImGuiDir.ImGuiDir_None
	this.SplitRatio = 0.
	for n : i32 = 0; n < cast(i32)IM_ARRAYSIZE(this.DropRectsDraw); n += 1 { this.DropRectsDraw[n] = ImRect{{+FLT_MAX, +FLT_MAX}, {-FLT_MAX, -FLT_MAX}} }
}

// Storage for a dock node in .ini file (we preserve those even if the associated dock node isn't active during the session)
// Persistent Settings data, stored contiguously in SettingsNodes (sizeof() ~32 bytes)
ImGuiDockNodeSettings :: struct {
	ID : ImGuiID,
	ParentNodeId : ImGuiID,
	ParentWindowId : ImGuiID,
	SelectedTabId : ImGuiID,
	SplitAxis : i8,
	Depth : u8,
	Flags : ImGuiDockNodeFlags, // NB: We save individual flags one by one in ascii format (ImGuiDockNodeFlags_SavedFlagsMask_)
	Pos : ImVec2ih,
	Size : ImVec2ih,
	SizeRef : ImVec2ih,
}

ImGuiDockNodeSettings_init :: proc(this : ^ImGuiDockNodeSettings)
{
	this^ = {}; this.SplitAxis = cast(i8)ImGuiAxis.ImGuiAxis_None
}

//-----------------------------------------------------------------------------
// Docking: Forward Declarations
//-----------------------------------------------------------------------------

DockNodeGetHostWindowTitle :: proc(node : ^ImGuiDockNode, buf : []u8) -> string
{
	l := ImFormatString(buf, "##DockNode_%02X", node.ID); return string_from_slice(buf[:l], false)
}
//-----------------------------------------------------------------------------
// Docking: ImGuiDockContext
//-----------------------------------------------------------------------------
// The lifetime model is different from the one of regular windows: we always create a ImGuiDockNode for each ImGuiDockNodeSettings,
// or we always hold the entire docking node tree. Nodes are frequently hidden, e.g. if the window(s) or child nodes they host are not active.
// At boot time only, we run a simple GC to remove nodes that have no references.
// Because dock node settings (which are small, contiguous structures) are always mirrored by their corresponding dock nodes (more complete structures),
// we can also very easily recreate the nodes from scratch given the settings data (this is what DockContextRebuild() does).
// This is convenient as docking reconfiguration can be implemented by mostly poking at the simpler settings data.
//-----------------------------------------------------------------------------
// - DockContextInitialize()
// - DockContextShutdown()
// - DockContextClearNodes()
// - DockContextRebuildNodes()
// - DockContextNewFrameUpdateUndocking()
// - DockContextNewFrameUpdateDocking()
// - DockContextEndFrame()
// - DockContextFindNodeByID()
// - DockContextBindNodeToWindow()
// - DockContextGenNodeID()
// - DockContextAddNode()
// - DockContextRemoveNode()
// - ImGuiDockContextPruneNodeData
// - DockContextPruneUnusedSettingsNodes()
// - DockContextBuildNodesFromSettings()
// - DockContextBuildAddWindowsToNodes()
//-----------------------------------------------------------------------------

DockContextInitialize :: proc(ctx : ^ImGuiContext)
{
	g : ^ImGuiContext = ctx

	// Add .ini handle for persistent docking data
	ini_handler : ImGuiSettingsHandler
	ini_handler.TypeName = "Docking"
	ini_handler.TypeHash = ImHashStr("Docking")
	ini_handler.ClearAllFn = DockSettingsHandler_ClearAll
	ini_handler.ReadInitFn = DockSettingsHandler_ClearAll; // Also clear on read
	ini_handler.ReadOpenFn = DockSettingsHandler_ReadOpen
	ini_handler.ReadLineFn = DockSettingsHandler_ReadLine
	ini_handler.ApplyAllFn = DockSettingsHandler_ApplyAll
	ini_handler.WriteAllFn = DockSettingsHandler_WriteAll
	push_back(&g.SettingsHandlers, ini_handler)

	g.DockNodeWindowMenuHandler = DockNodeWindowMenuHandler_Default
}

DockContextShutdown :: proc(ctx : ^ImGuiContext)
{
	dc : ^ImGuiDockContext = &ctx.DockContext
	for n : i32 = 0; n < dc.Nodes.Data.Size; n += 1 { if node : ^ImGuiDockNode = cast(^ImGuiDockNode) dc.Nodes.Data.Data[n].val_p; node != nil { IM_DELETE(node) } }
}

// Use root_id==0 to clear all
DockContextClearNodes :: proc(ctx : ^ImGuiContext, root_id : ImGuiID, clear_settings_refs : bool)
{
	IM_UNUSED(ctx)
	IM_ASSERT(ctx == GImGui)
	DockBuilderRemoveNodeDockedWindows(root_id, clear_settings_refs)
	DockBuilderRemoveNodeChildNodes(root_id)
}

// [DEBUG] This function also acts as a defacto test to make sure we can rebuild from scratch without a glitch
// (Different from DockSettingsHandler_ClearAll() + DockSettingsHandler_ApplyAll() because this reuses current settings!)
DockContextRebuildNodes :: proc(ctx : ^ImGuiContext)
{
	g : ^ImGuiContext = ctx
	dc : ^ImGuiDockContext = &ctx.DockContext
	IMGUI_DEBUG_LOG_DOCKING(g, "[docking] DockContextRebuildNodes\n")
	SaveIniSettingsToMemory()
	root_id : ImGuiID = 0; // Rebuild all
	DockContextClearNodes(ctx, root_id, false)
	DockContextBuildNodesFromSettings(ctx, dc.NodesSettings.Data, dc.NodesSettings.Size)
	DockContextBuildAddWindowsToNodes(ctx, root_id)
}

// Docking context update function, called by NewFrame()
DockContextNewFrameUpdateUndocking :: proc(ctx : ^ImGuiContext)
{
	g : ^ImGuiContext = ctx
	dc : ^ImGuiDockContext = &ctx.DockContext
	if (g.IO.ConfigFlags & ImGuiConfigFlags_.ImGuiConfigFlags_DockingEnable) == {} {
		if dc.Nodes.Data.Size > 0 || dc.Requests.Size > 0 { DockContextClearNodes(ctx, 0, true) }
		return
	}

	// Setting NoSplit at runtime merges all nodes
	if g.IO.ConfigDockingNoSplit {
		for n : i32 = 0; n < dc.Nodes.Data.Size; n += 1 {
			if node := cast(^ImGuiDockNode) dc.Nodes.Data.Data[n].val_p; node != nil {
				if IsRootNode(node) && IsSplitNode(node) {
					DockBuilderRemoveNodeChildNodes(node.ID)
					//dc->WantFullRebuild = true;
				}
			}
		}
	}

	// Process full rebuild

	if dc.WantFullRebuild {
		DockContextRebuildNodes(ctx)
		dc.WantFullRebuild = false
	}

	// Process Undocking requests (we need to process them _before_ the UpdateMouseMovingWindowNewFrame call in NewFrame)
	for req in dc.Requests.Data[:dc.Requests.Size] {
		if req.Type == ImGuiDockRequestType.ImGuiDockRequestType_Undock && req.UndockTargetWindow != nil { DockContextProcessUndockWindow(ctx, req.UndockTargetWindow) }
		else if req.Type == ImGuiDockRequestType.ImGuiDockRequestType_Undock && req.UndockTargetNode != nil { DockContextProcessUndockNode(ctx, req.UndockTargetNode) }
	}
}

// Docking context update function, called by NewFrame()
DockContextNewFrameUpdateDocking :: proc(ctx : ^ImGuiContext)
{
	g : ^ImGuiContext = ctx
	dc : ^ImGuiDockContext = &ctx.DockContext
	if (g.IO.ConfigFlags & ImGuiConfigFlags_.ImGuiConfigFlags_DockingEnable) == {} { return }

	// [DEBUG] Store hovered dock node.
	// We could in theory use DockNodeTreeFindVisibleNodeByPos() on the root host dock node, but using ->DockNode is a good shortcut.
	// Note this is mostly a debug thing and isn't actually used for docking target, because docking involve more detailed filtering.
	g.DebugHoveredDockNode = nil
	if hovered_window : ^ImGuiWindow = g.HoveredWindowUnderMovingWindow; hovered_window != nil {
		if hovered_window.DockNodeAsHost != nil { g.DebugHoveredDockNode = DockNodeTreeFindVisibleNodeByPos(hovered_window.DockNodeAsHost, g.IO.MousePos) }
		else if hovered_window.RootWindow.DockNode != nil { g.DebugHoveredDockNode = hovered_window.RootWindow.DockNode }
	}

	// Process Docking requests
	for &req in dc.Requests.Data[:dc.Requests.Size] { if req.Type == ImGuiDockRequestType.ImGuiDockRequestType_Dock { DockContextProcessDock(ctx, &req) } }

	resize(&dc.Requests, 0)

	// Create windows for each automatic docking nodes
	// We can have NULL pointers when we delete nodes, but because ID are recycled this should amortize nicely (and our node count will never be very high)
	for n : i32 = 0; n < dc.Nodes.Data.Size; n += 1 { if node : ^ImGuiDockNode = cast(^ImGuiDockNode) dc.Nodes.Data.Data[n].val_p; node != nil { if IsFloatingNode(node) { DockNodeUpdate(node) } } }
}

DockContextEndFrame :: proc(ctx : ^ImGuiContext)
{
	// Draw backgrounds of node missing their window
	g : ^ImGuiContext = ctx
	dc : ^ImGuiDockContext = &g.DockContext
	for n : i32 = 0; n < dc.Nodes.Data.Size; n += 1 { if node : ^ImGuiDockNode = cast(^ImGuiDockNode) dc.Nodes.Data.Data[n].val_p; node != nil { if node.LastFrameActive == g.FrameCount && node.IsVisible && node.HostWindow != nil && IsLeafNode(node) && !node.IsBgDrawnThisFrame {
	bg_rect : ImRect; init(&bg_rect, node.Pos + ImVec2{0.0, GetFrameHeight()}, node.Pos + node.Size)
	bg_rounding_flags : ImDrawFlags = CalcRoundingFlagsForRectInRect(bg_rect, Rect(node.HostWindow), g.Style.DockingSeparatorSize)
	ChannelsSetCurrent(node.HostWindow.DrawList, DOCKING_HOST_DRAW_CHANNEL_BG)
	AddRectFilled(node.HostWindow.DrawList, bg_rect.Min, bg_rect.Max, node.LastBgColor, node.HostWindow.WindowRounding, bg_rounding_flags)
} } }
}

DockContextFindNodeByID :: proc(ctx : ^ImGuiContext, id : ImGuiID) -> ^ImGuiDockNode
{
	return cast(^ImGuiDockNode) GetVoidPtr(&ctx.DockContext.Nodes, id)
}

DockContextGenNodeID :: proc(ctx : ^ImGuiContext) -> ImGuiID
{
	// Generate an ID for new node (the exact ID value doesn't matter as long as it is not already used)
	// FIXME-OPT FIXME-DOCK: This is suboptimal, even if the node count is small enough not to be a worry.0
	// We should poke in ctx->Nodes to find a suitable ID faster. Even more so trivial that ctx->Nodes lookup is already sorted.
	id : ImGuiID = 0x0001
	for DockContextFindNodeByID(ctx, id) != nil { post_incr(&id) }

	return id
}

// ImGuiDockContext
DockContextAddNode :: proc(ctx : ^ImGuiContext, id : ImGuiID) -> ^ImGuiDockNode
{
	// Generate an ID for the new node (the exact ID value doesn't matter as long as it is not already used) and add the first window.
	g : ^ImGuiContext = ctx
	id := id
	if id == 0 { id = DockContextGenNodeID(ctx) }
	else { IM_ASSERT(DockContextFindNodeByID(ctx, id) == nil) }

	// We don't set node->LastFrameAlive on construction. Nodes are always created at all time to reflect .ini settings!
	IMGUI_DEBUG_LOG_DOCKING(g, "[docking] DockContextAddNode 0x%08X\n", id)
	node : ^ImGuiDockNode = IM_NEW_MEM(ImGuiDockNode); init(node, id)
	SetVoidPtr(&ctx.DockContext.Nodes, node.ID, node)
	return node
}

DockContextRemoveNode :: proc(ctx : ^ImGuiContext, node : ^ImGuiDockNode, merge_sibling_into_parent_node : bool)
{
	g : ^ImGuiContext = ctx
	dc : ^ImGuiDockContext = &ctx.DockContext

	IMGUI_DEBUG_LOG_DOCKING(g, "[docking] DockContextRemoveNode 0x%08X\n", node.ID)
	IM_ASSERT(DockContextFindNodeByID(ctx, node.ID) == node)
	IM_ASSERT(node.ChildNodes[0] == nil && node.ChildNodes[1] == nil)
	IM_ASSERT(node.Windows.Size == 0)

	if node.HostWindow != nil { node.HostWindow.DockNodeAsHost = nil }

	parent_node : ^ImGuiDockNode = node.ParentNode
	merge : bool = (merge_sibling_into_parent_node && parent_node != nil)
	if merge {
		IM_ASSERT(parent_node.ChildNodes[0] == node || parent_node.ChildNodes[1] == node)
		sibling_node : ^ImGuiDockNode = (parent_node.ChildNodes[0] == node ? parent_node.ChildNodes[1] : parent_node.ChildNodes[0])
		DockNodeTreeMerge(g, parent_node, sibling_node)
	}
	else {
		for n : int = 0; parent_node != nil && n < IM_ARRAYSIZE(parent_node.ChildNodes); n += 1 { if parent_node.ChildNodes[n] == node { node.ParentNode.ChildNodes[n] = nil } }

		SetVoidPtr(&dc.Nodes, node.ID, nil)
		IM_DELETE(node)
	}
}

DockNodeComparerDepthMostFirst :: proc(a, b : ^ImGuiDockNode) -> slice.Ordering
{
	return slice.Ordering(DockNodeGetDepth(b) - DockNodeGetDepth(a))
}

// Pre C++0x doesn't allow us to use a function-local type (without linkage) as template parameter, so we moved this here.
ImGuiDockContextPruneNodeData :: struct {
	CountWindows : i32, CountChildWindows : i32, CountChildNodes : i32,
	RootId : ImGuiID,
}

ImGuiDockContextPruneNodeData_init :: proc(this : ^ImGuiDockContextPruneNodeData)
{
	this.CountChildNodes = 0; this.CountChildWindows = this.CountChildNodes; this.CountWindows = this.CountChildWindows; this.RootId = 0
}

// Garbage collect unused nodes (run once at init time)
DockContextPruneUnusedSettingsNodes :: proc(ctx : ^ImGuiContext)
{
	g : ^ImGuiContext = ctx
	dc : ^ImGuiDockContext = &ctx.DockContext
	IM_ASSERT(g.Windows.Size == 0)

	pool : ImPool(ImGuiDockContextPruneNodeData)
	Reserve(&pool, dc.NodesSettings.Size)

	// Count child nodes and compute RootID
	for settings_n : i32 = 0; settings_n < dc.NodesSettings.Size; settings_n += 1 {
		settings : ^ImGuiDockNodeSettings = &dc.NodesSettings.Data[settings_n]
		parent_data : ^ImGuiDockContextPruneNodeData = settings.ParentNodeId != 0 ? GetByKey(&pool, settings.ParentNodeId) : nil
		GetOrAddByKey(&pool, settings.ID).RootId = parent_data != nil ? parent_data.RootId : settings.ID
		if settings.ParentNodeId != 0 { post_incr(&GetOrAddByKey(&pool, settings.ParentNodeId).CountChildNodes) }
	}

	// Count reference to dock ids from dockspaces
	// We track the 'auto-DockNode <- manual-Window <- manual-DockSpace' in order to avoid 'auto-DockNode' being ditched by DockContextPruneUnusedSettingsNodes()
	for settings_n : i32 = 0; settings_n < dc.NodesSettings.Size; settings_n += 1 {
		settings : ^ImGuiDockNodeSettings = &dc.NodesSettings.Data[settings_n]
		if settings.ParentWindowId != 0 { if window_settings : ^ImGuiWindowSettings = FindWindowSettingsByID(settings.ParentWindowId); window_settings != nil { if window_settings.DockId != 0 { if data : ^ImGuiDockContextPruneNodeData = GetByKey(&pool, window_settings.DockId); data != nil { post_incr(&data.CountChildNodes) } } } }
	}

	// Count reference to dock ids from window settings
	// We guard against the possibility of an invalid .ini file (RootID may point to a missing node)
	for settings : ^ImGuiWindowSettings = begin(&g.SettingsWindows); settings != nil; settings = next_chunk(&g.SettingsWindows, settings) { if dock_id : ImGuiID = settings.DockId; dock_id != 0 { if data : ^ImGuiDockContextPruneNodeData = GetByKey(&pool, dock_id); data != nil {
	post_incr(&data.CountWindows)
	if data_root : ^ImGuiDockContextPruneNodeData = (data.RootId == dock_id) ? data : GetByKey(&pool, data.RootId); data_root != nil { post_incr(&data_root.CountChildWindows) }
} } }

	// Prune
	for settings_n : i32 = 0; settings_n < dc.NodesSettings.Size; settings_n += 1 {
		settings : ^ImGuiDockNodeSettings = &dc.NodesSettings.Data[settings_n]
		data : ^ImGuiDockContextPruneNodeData = GetByKey(&pool, settings.ID)
		if data.CountWindows > 1 { continue }
		data_root : ^ImGuiDockContextPruneNodeData = (data.RootId == settings.ID) ? data : GetByKey(&pool, data.RootId)

		remove : bool = false
		remove |= (data.CountWindows == 1 && settings.ParentNodeId == 0 && data.CountChildNodes == 0 && (settings.Flags & cast(ImGuiDockNodeFlags) ImGuiDockNodeFlagsPrivate_.ImGuiDockNodeFlags_CentralNode) == {}); // Floating root node with only 1 window
		remove |= (data.CountWindows == 0 && settings.ParentNodeId == 0 && data.CountChildNodes == 0); // Leaf nodes with 0 window
		remove |= (data_root.CountChildWindows == 0)
		if remove {
			IMGUI_DEBUG_LOG_DOCKING(g, "[docking] DockContextPruneUnusedSettingsNodes: Prune 0x%08X\n", settings.ID)
			DockSettingsRemoveNodeReferences({settings.ID})
			settings.ID = 0
		}
	}
}

DockContextBuildNodesFromSettings :: proc(ctx : ^ImGuiContext, node_settings_array : [^]ImGuiDockNodeSettings, node_settings_count : i32)
{
	// Build nodes
	for node_n : i32 = 0; node_n < node_settings_count; node_n += 1 {
		settings : ^ImGuiDockNodeSettings = &node_settings_array[node_n]
		if settings.ID == 0 { continue }
		node : ^ImGuiDockNode = DockContextAddNode(ctx, settings.ID)
		node.ParentNode = settings.ParentNodeId != 0 ? DockContextFindNodeByID(ctx, settings.ParentNodeId) : nil
		node.Pos     = ImVec2{cast(f32)settings.Pos.x, cast(f32)settings.Pos.y}
		node.Size    = ImVec2{cast(f32)settings.Size.x, cast(f32)settings.Size.y}
		node.SizeRef = ImVec2{cast(f32)settings.SizeRef.x, cast(f32)settings.SizeRef.y}
		node.AuthorityForViewport = ImGuiDataAuthority_.ImGuiDataAuthority_DockNode; node.AuthorityForSize = node.AuthorityForViewport; node.AuthorityForPos = node.AuthorityForSize
		if node.ParentNode != nil && node.ParentNode.ChildNodes[0] == nil { node.ParentNode.ChildNodes[0] = node }
		else if node.ParentNode != nil && node.ParentNode.ChildNodes[1] == nil { node.ParentNode.ChildNodes[1] = node }
		node.SelectedTabId = settings.SelectedTabId
		node.SplitAxis = cast(ImGuiAxis) settings.SplitAxis
		SetLocalFlags(node, settings.Flags & cast(ImGuiDockNodeFlags) ImGuiDockNodeFlagsPrivate_.ImGuiDockNodeFlags_SavedFlagsMask_)

		// Bind host window immediately if it already exist (in case of a rebuild)
		// This is useful as the RootWindowForTitleBarHighlight links necessary to highlight the currently focused node requires node->HostWindow to be set.
		host_window_title : [20]u8
		root_node : ^ImGuiDockNode = DockNodeGetRootNode(node)
		node.HostWindow = FindWindowByName(DockNodeGetHostWindowTitle(root_node, host_window_title[:]))
	}
}

// Use root_id==0 to add all
DockContextBuildAddWindowsToNodes :: proc(ctx : ^ImGuiContext, root_id : ImGuiID)
{
	// Rebind all windows to nodes (they can also lazily rebind but we'll have a visible glitch during the first frame)
	g : ^ImGuiContext = ctx
	for window in g.Windows.Data[:g.Windows.Size] {
		if window.DockId == 0 || window.LastFrameActive < g.FrameCount - 1 { continue }
		if window.DockNode != nil { continue }

		node : ^ImGuiDockNode = DockContextFindNodeByID(ctx, window.DockId)
		IM_ASSERT(node != nil); // This should have been called after DockContextBuildNodesFromSettings()
		if root_id == 0 || DockNodeGetRootNode(node).ID == root_id { DockNodeAddWindow(node, window, true) }
	}
}

//-----------------------------------------------------------------------------
// Docking: ImGuiDockContext Docking/Undocking functions
//-----------------------------------------------------------------------------
// - DockContextQueueDock()
// - DockContextQueueUndockWindow()
// - DockContextQueueUndockNode()
// - DockContextQueueNotifyRemovedNode()
// - DockContextProcessDock()
// - DockContextProcessUndockWindow()
// - DockContextProcessUndockNode()
// - DockContextCalcDropPosForDocking()
//-----------------------------------------------------------------------------

DockContextQueueDock :: proc(ctx : ^ImGuiContext, target : ^ImGuiWindow, target_node : ^ImGuiDockNode, payload : ^ImGuiWindow, split_dir : ImGuiDir, split_ratio : f32, split_outer : bool)
{
	IM_ASSERT(target != payload)
	req : ImGuiDockRequest
	req.Type = ImGuiDockRequestType.ImGuiDockRequestType_Dock
	req.DockTargetWindow = target
	req.DockTargetNode = target_node
	req.DockPayload = payload
	req.DockSplitDir = split_dir
	req.DockSplitRatio = split_ratio
	req.DockSplitOuter = split_outer
	push_back(&ctx.DockContext.Requests, req)
}

DockContextQueueUndockWindow :: proc(ctx : ^ImGuiContext, window : ^ImGuiWindow)
{
	req : ImGuiDockRequest
	req.Type = ImGuiDockRequestType.ImGuiDockRequestType_Undock
	req.UndockTargetWindow = window
	push_back(&ctx.DockContext.Requests, req)
}

DockContextQueueUndockNode :: proc(ctx : ^ImGuiContext, node : ^ImGuiDockNode)
{
	req : ImGuiDockRequest
	req.Type = ImGuiDockRequestType.ImGuiDockRequestType_Undock
	req.UndockTargetNode = node
	push_back(&ctx.DockContext.Requests, req)
}

DockContextQueueNotifyRemovedNode :: proc(ctx : ^ImGuiContext, node : ^ImGuiDockNode)
{
	dc : ^ImGuiDockContext = &ctx.DockContext
	for &req in dc.Requests.Data[:dc.Requests.Size] { if req.DockTargetNode == node { req.Type = ImGuiDockRequestType.ImGuiDockRequestType_None } }
}

DockContextProcessDock :: proc(ctx : ^ImGuiContext, req : ^ImGuiDockRequest)
{
	IM_ASSERT((req.Type == ImGuiDockRequestType.ImGuiDockRequestType_Dock && req.DockPayload != nil) || (req.Type == ImGuiDockRequestType.ImGuiDockRequestType_Split && req.DockPayload == nil))
	IM_ASSERT(req.DockTargetWindow != nil || req.DockTargetNode != nil)

	g : ^ImGuiContext = ctx
	IM_UNUSED(g)

	payload_window : ^ImGuiWindow = req.DockPayload; // Optional
	target_window : ^ImGuiWindow = req.DockTargetWindow
	node : ^ImGuiDockNode = req.DockTargetNode
	if payload_window != nil { IMGUI_DEBUG_LOG_DOCKING(g, "[docking] DockContextProcessDock node 0x%08X target '%s' dock window '%s', split_dir %d\n", node != nil ? node.ID : 0, target_window != nil ? target_window.Name : "NULL", payload_window.Name, req.DockSplitDir) }
	else { IMGUI_DEBUG_LOG_DOCKING(g, "[docking] DockContextProcessDock node 0x%08X, split_dir %d\n", node != nil ? node.ID : 0, req.DockSplitDir) }

	// Decide which Tab will be selected at the end of the operation
	next_selected_id : ImGuiID = 0
	payload_node : ^ImGuiDockNode = nil
	if payload_window != nil {
		payload_node = payload_window.DockNodeAsHost
		payload_window.DockNodeAsHost = nil; // Important to clear this as the node will have its life as a child which might be merged/deleted later.
		if payload_node != nil && IsLeafNode(payload_node) { next_selected_id = payload_node.TabBar.NextSelectedTabId != 0 ? payload_node.TabBar.NextSelectedTabId : payload_node.TabBar.SelectedTabId }
		if payload_node == nil { next_selected_id = payload_window.TabId }
	}

	// FIXME-DOCK: When we are trying to dock an existing single-window node into a loose window, transfer Node ID as well
	// When processing an interactive split, usually LastFrameAlive will be < g.FrameCount. But DockBuilder operations can make it ==.
	if node != nil { IM_ASSERT(node.LastFrameAlive <= g.FrameCount) }
	if node != nil && target_window != nil && node == target_window.DockNodeAsHost { IM_ASSERT(node.Windows.Size > 0 || IsSplitNode(node) || IsCentralNode(node)) }

	// Create new node and add existing window to it
	if node == nil {
		node = DockContextAddNode(ctx, 0)
		node.Pos = target_window.Pos
		node.Size = target_window.Size
		if target_window.DockNodeAsHost == nil {
			DockNodeAddWindow(node, target_window, true)
			node.TabBar.Tabs.Data[0].Flags &= cast(ImGuiTabItemFlags)~cast(i32)ImGuiTabItemFlagsPrivate_.ImGuiTabItemFlags_Unsorted
			target_window.DockIsActive = true
		}
	}

	split_dir : ImGuiDir = req.DockSplitDir
	if split_dir != ImGuiDir.ImGuiDir_None {
		// Split into two, one side will be our payload node unless we are dropping a loose window
		split_axis : ImGuiAxis = (split_dir == ImGuiDir.ImGuiDir_Left || split_dir == ImGuiDir.ImGuiDir_Right) ? ImGuiAxis.ImGuiAxis_X : ImGuiAxis.ImGuiAxis_Y
		split_inheritor_child_idx : i32 = (split_dir == ImGuiDir.ImGuiDir_Left || split_dir == ImGuiDir.ImGuiDir_Up) ? 1 : 0; // Current contents will be moved to the opposite side
		split_ratio : f32 = req.DockSplitRatio
		DockNodeTreeSplit(ctx, node, split_axis, split_inheritor_child_idx, split_ratio, payload_node); // payload_node may be NULL here!
		new_node : ^ImGuiDockNode = node.ChildNodes[split_inheritor_child_idx ~ 1]
		new_node.HostWindow = node.HostWindow
		node = new_node
	}
	SetLocalFlags(node, node.LocalFlags & cast(ImGuiDockNodeFlags)~cast(i32)ImGuiDockNodeFlagsPrivate_.ImGuiDockNodeFlags_HiddenTabBar)

	if node != payload_node {
		// Create tab bar before we call DockNodeMoveWindows (which would attempt to move the old tab-bar, which would lead us to payload tabs wrongly appearing before target tabs!)
		if node.Windows.Size > 0 && node.TabBar == nil {
			DockNodeAddTabBar(node)
			for n : i32 = 0; n < node.Windows.Size; n += 1 { TabBarAddTab(node.TabBar, ImGuiTabItemFlags_.ImGuiTabItemFlags_None, node.Windows.Data[n]) }
		}

		if payload_node != nil {
			// Transfer full payload node (with 1+ child windows or child nodes)
			if IsSplitNode(payload_node) {
				if node.Windows.Size > 0 {
					// We can dock a split payload into a node that already has windows _only_ if our payload is a node tree with a single visible node.
					// In this situation, we move the windows of the target node into the currently visible node of the payload.
					// This allows us to preserve some of the underlying dock tree settings nicely.
					IM_ASSERT(payload_node.OnlyNodeWithWindows != nil); // The docking should have been blocked by DockNodePreviewDockSetup() early on and never submitted.
					visible_node : ^ImGuiDockNode = payload_node.OnlyNodeWithWindows
					if visible_node.TabBar != nil { IM_ASSERT(visible_node.TabBar.Tabs.Size > 0) }
					DockNodeMoveWindows(node, visible_node)
					DockNodeMoveWindows(visible_node, node)
					DockSettingsRenameNodeReferences(node.ID, visible_node.ID)
				}
				if IsCentralNode(node) {
					// Central node property needs to be moved to a leaf node, pick the last focused one.
					// FIXME-DOCK: If we had to transfer other flags here, what would the policy be?
					last_focused_node : ^ImGuiDockNode = DockContextFindNodeByID(ctx, payload_node.LastFocusedNodeId)
					IM_ASSERT(last_focused_node != nil)
					last_focused_root_node : ^ImGuiDockNode = DockNodeGetRootNode(last_focused_node)
					IM_ASSERT(last_focused_root_node == DockNodeGetRootNode(payload_node))
					SetLocalFlags(last_focused_node, last_focused_node.LocalFlags | cast(ImGuiDockNodeFlags)ImGuiDockNodeFlagsPrivate_.ImGuiDockNodeFlags_CentralNode)
					SetLocalFlags(node, node.LocalFlags & cast(ImGuiDockNodeFlags)~cast(i32)ImGuiDockNodeFlagsPrivate_.ImGuiDockNodeFlags_CentralNode)
					last_focused_root_node.CentralNode = last_focused_node
				}

				IM_ASSERT(node.Windows.Size == 0)
				DockNodeMoveChildNodes(node, payload_node)
			}
			else {
				payload_dock_id : ImGuiID = payload_node.ID
				DockNodeMoveWindows(node, payload_node)
				DockSettingsRenameNodeReferences(payload_dock_id, node.ID)
			}
			DockContextRemoveNode(ctx, payload_node, true)
		}
		else if payload_window != nil {
			// Transfer single window
			payload_dock_id : ImGuiID = payload_window.DockId
			node.VisibleWindow = payload_window
			DockNodeAddWindow(node, payload_window, true)
			if payload_dock_id != 0 { DockSettingsRenameNodeReferences(payload_dock_id, node.ID) }
		}
	}
	else {
		// When docking a floating single window node we want to reevaluate auto-hiding of the tab bar
		node.WantHiddenTabBarUpdate = true
	}

	// Update selection immediately
	if tab_bar : ^ImGuiTabBar = node.TabBar; tab_bar != nil { tab_bar.NextSelectedTabId = next_selected_id }
	MarkIniSettingsDirty()
}

// Problem:
//   Undocking a large (~full screen) window would leave it so large that the bottom right sizing corner would more
//   than likely be off the screen and the window would be hard to resize to fit on screen. This can be particularly problematic
//   with 'ConfigWindowsMoveFromTitleBarOnly=true' and/or with 'ConfigWindowsResizeFromEdges=false' as well (the later can be
//   due to missing ImGuiBackendFlags_HasMouseCursors backend flag).
// Solution:
//   When undocking a window we currently force its maximum size to 90% of the host viewport or monitor.
// Reevaluate this when we implement preserving docked/undocked size ("docking_wip/undocked_size" branch).
FixLargeWindowsWhenUndocking :: proc(size : ImVec2, ref_viewport : ^ImGuiViewport) -> ImVec2
{
	if ref_viewport == nil { return size }

	g : ^ImGuiContext = GImGui
	max_size : ImVec2 = ImTrunc(ref_viewport.WorkSize * 0.90)
	if (g.ConfigFlagsCurrFrame & ImGuiConfigFlags_.ImGuiConfigFlags_ViewportsEnable) != {} {
		monitor : ^ImGuiPlatformMonitor = GetViewportPlatformMonitor(ref_viewport)
		max_size = ImTrunc(monitor.WorkSize * 0.90)
	}
	return ImMin(size, max_size)
}

DockContextProcessUndockWindow :: proc(ctx : ^ImGuiContext, window : ^ImGuiWindow, clear_persistent_docking_ref : bool = true)
{
	g : ^ImGuiContext = ctx
	IMGUI_DEBUG_LOG_DOCKING(g, "[docking] DockContextProcessUndockWindow window '%s', clear_persistent_docking_ref = %d\n", window.Name, clear_persistent_docking_ref)
	if window.DockNode != nil { DockNodeRemoveWindow(window.DockNode, window, clear_persistent_docking_ref ? 0 : window.DockId) }
	else { window.DockId = 0 }
	window.Collapsed = false
	window.DockIsActive = false
	window.DockTabIsVisible = false; window.DockNodeIsVisible = window.DockTabIsVisible
	window.SizeFull = FixLargeWindowsWhenUndocking(window.SizeFull, window.Viewport); window.Size = window.SizeFull

	MarkIniSettingsDirty()
}

DockContextProcessUndockNode :: proc(ctx : ^ImGuiContext, node : ^ImGuiDockNode)
{
	g : ^ImGuiContext = ctx
	IMGUI_DEBUG_LOG_DOCKING(g, "[docking] DockContextProcessUndockNode node %08X\n", node.ID)
	IM_ASSERT(IsLeafNode(node))
	IM_ASSERT(node.Windows.Size >= 1)

	node := node
	if IsRootNode(node) || IsCentralNode(node) {
		// In the case of a root node or central node, the node will have to stay in place. Create a new node to receive the payload.
		new_node : ^ImGuiDockNode = DockContextAddNode(ctx, 0)
		new_node.Pos = node.Pos
		new_node.Size = node.Size
		new_node.SizeRef = node.SizeRef
		DockNodeMoveWindows(new_node, node)
		DockSettingsRenameNodeReferences(node.ID, new_node.ID)
		node = new_node
	}
	else {
		// Otherwise extract our node and merge our sibling back into the parent node.
		IM_ASSERT(node.ParentNode.ChildNodes[0] == node || node.ParentNode.ChildNodes[1] == node)
		index_in_parent : i32 = (node.ParentNode.ChildNodes[0] == node) ? 0 : 1
		node.ParentNode.ChildNodes[index_in_parent] = nil
		DockNodeTreeMerge(ctx, node.ParentNode, node.ParentNode.ChildNodes[index_in_parent ~ 1])
		node.ParentNode.AuthorityForViewport = ImGuiDataAuthority_.ImGuiDataAuthority_Window; // The node that stays in place keeps the viewport, so our newly dragged out node will create a new viewport
		node.ParentNode = nil
	}
	for window in node.Windows.Data[:node.Windows.Size] {
		window.Flags &= cast(ImGuiWindowFlags)~cast(i32)ImGuiWindowFlags_.ImGuiWindowFlags_ChildWindow
		if window.ParentWindow != nil { find_erase(&window.ParentWindow.DC.ChildWindows, window) }
		UpdateWindowParentAndRootLinks(window, window.Flags, nil)
	}

	node.AuthorityForSize = ImGuiDataAuthority_.ImGuiDataAuthority_DockNode; node.AuthorityForPos = node.AuthorityForSize
	node.Size = FixLargeWindowsWhenUndocking(node.Size, node.Windows.Data[0].Viewport)
	node.WantMouseMove = true
	MarkIniSettingsDirty()
}

// This is mostly used for automation.
DockContextCalcDropPosForDocking :: proc(target : ^ImGuiWindow, target_node : ^ImGuiDockNode, payload_window : ^ImGuiWindow, payload_node : ^ImGuiDockNode, split_dir : ImGuiDir, split_outer : bool, out_pos : ^ImVec2) -> bool
{
	target_node, split_outer := target_node, split_outer
	if target != nil && target_node == nil { target_node = target.DockNode }

	// In DockNodePreviewDockSetup() for a root central node instead of showing both "inner" and "outer" drop rects
	// (which would be functionally identical) we only show the outer one. Reflect this here.
	if target_node != nil && target_node.ParentNode == nil && IsCentralNode(target_node) && split_dir != ImGuiDir.ImGuiDir_None { split_outer = true }
	split_data : ImGuiDockPreviewData
	DockNodePreviewDockSetup(target, target_node, payload_window, payload_node, &split_data, false, split_outer)
	if IsInverted(split_data.DropRectsDraw[split_dir + ImGuiDir(1)]) { return false }
	out_pos^ = GetCenter(split_data.DropRectsDraw[split_dir + ImGuiDir(1)])
	return true
}

//-----------------------------------------------------------------------------
// Docking: ImGuiDockNode
//-----------------------------------------------------------------------------
// - DockNodeGetTabOrder()
// - DockNodeAddWindow()
// - DockNodeRemoveWindow()
// - DockNodeMoveChildNodes()
// - DockNodeMoveWindows()
// - DockNodeApplyPosSizeToWindows()
// - DockNodeHideHostWindow()
// - ImGuiDockNodeFindInfoResults
// - DockNodeFindInfo()
// - DockNodeFindWindowByID()
// - DockNodeUpdateFlagsAndCollapse()
// - DockNodeUpdateHasCentralNodeFlag()
// - DockNodeUpdateVisibleFlag()
// - DockNodeStartMouseMovingWindow()
// - DockNodeUpdate()
// - DockNodeUpdateWindowMenu()
// - DockNodeBeginAmendTabBar()
// - DockNodeEndAmendTabBar()
// - DockNodeUpdateTabBar()
// - DockNodeAddTabBar()
// - DockNodeRemoveTabBar()
// - DockNodeIsDropAllowedOne()
// - DockNodeIsDropAllowed()
// - DockNodeCalcTabBarLayout()
// - DockNodeCalcSplitRects()
// - DockNodeCalcDropRectsAndTestMousePos()
// - DockNodePreviewDockSetup()
// - DockNodePreviewDockRender()
//-----------------------------------------------------------------------------

ImGuiDockNode_init :: proc(this : ^ImGuiDockNode, id : ImGuiID)
{
	init(&this.Windows)
	this.Pos = {}
	this.Size = {}
	this.SizeRef = {}
	init(&this.WindowClass)
	this.ID = id
	this.MergedFlags = ImGuiDockNodeFlags_.ImGuiDockNodeFlags_None; this.LocalFlagsInWindows = this.MergedFlags; this.LocalFlags = this.LocalFlagsInWindows; this.SharedFlags = this.LocalFlags
	this.ChildNodes[1] = nil; this.ChildNodes[0] = this.ChildNodes[1]; this.ParentNode = this.ChildNodes[0]
	this.TabBar = nil
	this.SplitAxis = ImGuiAxis.ImGuiAxis_None

	this.State = ImGuiDockNodeState.ImGuiDockNodeState_Unknown
	this.LastBgColor = IM_COL32_WHITE
	this.VisibleWindow = nil; this.HostWindow = this.VisibleWindow
	this.OnlyNodeWithWindows = nil; this.CentralNode = this.OnlyNodeWithWindows
	this.CountNodeWithWindows = 0
	this.LastFrameFocused = -1; this.LastFrameActive = this.LastFrameFocused; this.LastFrameAlive = this.LastFrameActive
	this.LastFocusedNodeId = 0
	this.SelectedTabId = 0
	this.WantCloseTabId = 0
	this.RefViewportId = 0
	this.AuthorityForSize = ImGuiDataAuthority_.ImGuiDataAuthority_DockNode; this.AuthorityForPos = this.AuthorityForSize
	this.AuthorityForViewport = ImGuiDataAuthority_.ImGuiDataAuthority_Auto
	this.IsVisible = true
	this.HasCentralNodeChild = false; this.HasWindowMenuButton = this.HasCentralNodeChild; this.HasCloseButton = this.HasWindowMenuButton; this.IsFocused = this.HasCloseButton
	this.IsBgDrawnThisFrame = false
	this.WantHiddenTabBarToggle = false; this.WantHiddenTabBarUpdate = this.WantHiddenTabBarToggle; this.WantMouseMove = this.WantHiddenTabBarUpdate; this.WantLockSizeOnce = this.WantMouseMove; this.WantCloseAll = this.WantLockSizeOnce
}

ImGuiDockNode_deinit :: proc(this : ^ImGuiDockNode)
{
	IM_DELETE(this.TabBar)
	this.TabBar = nil
	this.ChildNodes[1] = nil; this.ChildNodes[0] = this.ChildNodes[1]
	deinit(&this.Windows)
}

DockNodeGetTabOrder :: proc(window : ^ImGuiWindow) -> i32
{
	tab_bar : ^ImGuiTabBar = window.DockNode.TabBar
	if tab_bar == nil { return -1 }
	tab : ^ImGuiTabItem = TabBarFindTabByID(tab_bar, window.TabId)
	return tab != nil ? TabBarGetTabOrder(tab_bar, tab) : -1
}

DockNodeHideWindowDuringHostWindowCreation :: proc(window : ^ImGuiWindow)
{
	window.Hidden = true
	window.HiddenFramesCanSkipItems = window.Active ? 1 : 2
}

DockNodeAddWindow :: proc(node : ^ImGuiDockNode, window : ^ImGuiWindow, add_to_tab_bar : bool)
{
	g : ^ImGuiContext = GImGui; _ = g
	if window.DockNode != nil {
		// Can overwrite an existing window->DockNode (e.g. pointing to a disabled DockSpace node)
		IM_ASSERT(window.DockNode.ID != node.ID)
		DockNodeRemoveWindow(window.DockNode, window, 0)
	}
	IM_ASSERT(window.DockNode == nil || window.DockNodeAsHost == nil)
	IMGUI_DEBUG_LOG_DOCKING(g, "[docking] DockNodeAddWindow node 0x%08X window '%s'\n", node.ID, window.Name)

	// If more than 2 windows appeared on the same frame leading to the creation of a new hosting window,
	// we'll hide windows until the host window is ready. Hide the 1st window after its been output (so it is not visible for one frame).
	// We will call DockNodeHideWindowDuringHostWindowCreation() on ourselves in Begin()
	if node.HostWindow == nil && node.Windows.Size == 1 && node.Windows.Data[0].WasActive == false { DockNodeHideWindowDuringHostWindowCreation(node.Windows.Data[0]) }

	push_back(&node.Windows, window)
	node.WantHiddenTabBarUpdate = true
	window.DockNode = node
	window.DockId = node.ID
	window.DockIsActive = (node.Windows.Size > 1)
	window.DockTabWantClose = false

	// When reactivating a node with one or two loose window, the window pos/size/viewport are authoritative over the node storage.
	// In particular it is important we init the viewport from the first window so we don't create two viewports and drop one.
	if node.HostWindow == nil && IsFloatingNode(node) {
		if node.AuthorityForPos == ImGuiDataAuthority_.ImGuiDataAuthority_Auto { node.AuthorityForPos = ImGuiDataAuthority_.ImGuiDataAuthority_Window }
		if node.AuthorityForSize == ImGuiDataAuthority_.ImGuiDataAuthority_Auto { node.AuthorityForSize = ImGuiDataAuthority_.ImGuiDataAuthority_Window }
		if node.AuthorityForViewport == ImGuiDataAuthority_.ImGuiDataAuthority_Auto { node.AuthorityForViewport = ImGuiDataAuthority_.ImGuiDataAuthority_Window }
	}

	// Add to tab bar if requested
	if add_to_tab_bar {
		if node.TabBar == nil {
			DockNodeAddTabBar(node)
			node.TabBar.NextSelectedTabId = node.SelectedTabId; node.TabBar.SelectedTabId = node.TabBar.NextSelectedTabId

			// Add existing windows
			for n : i32 = 0; n < node.Windows.Size - 1; n += 1 { TabBarAddTab(node.TabBar, ImGuiTabItemFlags_.ImGuiTabItemFlags_None, node.Windows.Data[n]) }
		}
		TabBarAddTab(node.TabBar, cast(ImGuiTabItemFlags)ImGuiTabItemFlagsPrivate_.ImGuiTabItemFlags_Unsorted, window)
	}

	DockNodeUpdateVisibleFlag(node)

	// Update this without waiting for the next time we Begin() in the window, so our host window will have the proper title bar color on its first frame.
	if node.HostWindow != nil { UpdateWindowParentAndRootLinks(window, window.Flags | ImGuiWindowFlags_.ImGuiWindowFlags_ChildWindow, node.HostWindow) }
}

DockNodeRemoveWindow :: proc(node : ^ImGuiDockNode, window : ^ImGuiWindow, save_dock_id : ImGuiID)
{
	g : ^ImGuiContext = GImGui
	IM_ASSERT(window.DockNode == node)
	//IM_ASSERT(window->RootWindowDockTree == node->HostWindow);
	//IM_ASSERT(window->LastFrameActive < g.FrameCount);    // We may call this from Begin()
	IM_ASSERT(save_dock_id == 0 || save_dock_id == node.ID)
	IMGUI_DEBUG_LOG_DOCKING(g, "[docking] DockNodeRemoveWindow node 0x%08X window '%s'\n", node.ID, window.Name)

	window.DockNode = nil
	window.DockTabWantClose = false; window.DockIsActive = window.DockTabWantClose
	window.DockId = save_dock_id
	window.Flags &= cast(ImGuiWindowFlags)~cast(i32)ImGuiWindowFlags_.ImGuiWindowFlags_ChildWindow
	if window.ParentWindow != nil { find_erase(&window.ParentWindow.DC.ChildWindows, window) }
	UpdateWindowParentAndRootLinks(window, window.Flags, nil); // Update immediately

	if node.HostWindow != nil && node.HostWindow.ViewportOwned {
		// When undocking from a user interaction this will always run in NewFrame() and have not much effect.
		// But mid-frame, if we clear viewport we need to mark window as hidden as well.
		window.Viewport = nil
		window.ViewportId = 0
		window.ViewportOwned = false
		window.Hidden = true
	}

	// Remove window
	erased : bool = false
	for n : i32 = 0; n < node.Windows.Size; n += 1 { if node.Windows.Data[n] == window {
	erase(&node.Windows, &node.Windows.Data[n])
	erased = true
	break
} }

	if !erased { IM_ASSERT(erased) }
	if node.VisibleWindow == window { node.VisibleWindow = nil }

	// Remove tab and possibly tab bar
	node.WantHiddenTabBarUpdate = true
	if node.TabBar != nil {
		TabBarRemoveTab(node.TabBar, window.TabId)
		tab_count_threshold_for_tab_bar : i32 = IsCentralNode(node) ? 1 : 2
		if node.Windows.Size < tab_count_threshold_for_tab_bar { DockNodeRemoveTabBar(node) }
	}

	if node.Windows.Size == 0 && !IsCentralNode(node) && !IsDockSpace(node) && window.DockId != node.ID {
		// Automatic dock node delete themselves if they are not holding at least one tab
		DockContextRemoveNode(g, node, true)
		return
	}

	if node.Windows.Size == 1 && !IsCentralNode(node) && node.HostWindow != nil {
		remaining_window : ^ImGuiWindow = node.Windows.Data[0]
		// Note: we used to transport viewport ownership here.
		remaining_window.Collapsed = node.HostWindow.Collapsed
	}

	// Update visibility immediately is required so the DockNodeUpdateRemoveInactiveChilds() processing can reflect changes up the tree
	DockNodeUpdateVisibleFlag(node)
}

DockNodeMoveChildNodes :: proc(dst_node : ^ImGuiDockNode, src_node : ^ImGuiDockNode)
{
	IM_ASSERT(dst_node.Windows.Size == 0)
	dst_node.ChildNodes[0] = src_node.ChildNodes[0]
	dst_node.ChildNodes[1] = src_node.ChildNodes[1]
	if dst_node.ChildNodes[0] != nil { dst_node.ChildNodes[0].ParentNode = dst_node }
	if dst_node.ChildNodes[1] != nil { dst_node.ChildNodes[1].ParentNode = dst_node }
	dst_node.SplitAxis = src_node.SplitAxis
	dst_node.SizeRef = src_node.SizeRef
	src_node.ChildNodes[1] = nil; src_node.ChildNodes[0] = src_node.ChildNodes[1]
}

DockNodeMoveWindows :: proc(dst_node : ^ImGuiDockNode, src_node : ^ImGuiDockNode)
{
	// Insert tabs in the same orders as currently ordered (node->Windows isn't ordered)
	IM_ASSERT(src_node != nil && dst_node != nil && dst_node != src_node)
	src_tab_bar : ^ImGuiTabBar = src_node.TabBar
	if src_tab_bar != nil { IM_ASSERT(src_node.Windows.Size <= src_node.TabBar.Tabs.Size) }

	// If the dst_node is empty we can just move the entire tab bar (to preserve selection, scrolling, etc.)
	move_tab_bar : bool = (src_tab_bar != nil) && (dst_node.TabBar == nil)
	if move_tab_bar {
		dst_node.TabBar = src_node.TabBar
		src_node.TabBar = nil
	}

	// Tab order is not important here, it is preserved by sorting in DockNodeUpdateTabBar().
	for window in src_node.Windows.Data[:src_node.Windows.Size] {
		window.DockNode = nil
		window.DockIsActive = false
		DockNodeAddWindow(dst_node, window, !move_tab_bar)
	}

	clear(&src_node.Windows)

	if !move_tab_bar && src_node.TabBar != nil {
		if dst_node.TabBar != nil { dst_node.TabBar.SelectedTabId = src_node.TabBar.SelectedTabId }
		DockNodeRemoveTabBar(src_node)
	}
}

DockNodeApplyPosSizeToWindows :: proc(node : ^ImGuiDockNode)
{
	for window in node.Windows.Data[:node.Windows.Size] {
		SetWindowPos(window, node.Pos, ImGuiCond_.ImGuiCond_Always); // We don't assign directly to Pos because it can break the calculation of SizeContents on next frame
		SetWindowSize(window, node.Size, ImGuiCond_.ImGuiCond_Always)
	}
}

DockNodeHideHostWindow :: proc(node : ^ImGuiDockNode)
{
	if node.HostWindow != nil {
		if node.HostWindow.DockNodeAsHost == node { node.HostWindow.DockNodeAsHost = nil }
		node.HostWindow = nil
	}

	if node.Windows.Size == 1 {
		node.VisibleWindow = node.Windows.Data[0]
		node.Windows.Data[0].DockIsActive = false
	}

	if node.TabBar != nil { DockNodeRemoveTabBar(node) }
}

// Search function called once by root node in DockNodeUpdate()
ImGuiDockNodeTreeInfo :: struct {
	CentralNode : ^ImGuiDockNode,
	FirstNodeWithWindows : ^ImGuiDockNode,
	CountNodesWithWindows : i32,
}

//ImGuiWindowClass  WindowClassForMerges;

ImGuiDockNodeTreeInfo_init :: proc(this : ^ImGuiDockNodeTreeInfo) { this^ = {} }

DockNodeFindInfo :: proc(node : ^ImGuiDockNode, info : ^ImGuiDockNodeTreeInfo)
{
	if node.Windows.Size > 0 {
		if info.FirstNodeWithWindows == nil { info.FirstNodeWithWindows = node }
		post_incr(&info.CountNodesWithWindows)
	}
	if IsCentralNode(node) {
		IM_ASSERT(info.CentralNode == nil); // Should be only one
		IM_ASSERT(IsLeafNode(node), "If you get this assert: please submit .ini file + repro of actions leading to this.")
		info.CentralNode = node
	}
	if info.CountNodesWithWindows > 1 && info.CentralNode != nil { return }
	if node.ChildNodes[0] != nil { DockNodeFindInfo(node.ChildNodes[0], info) }
	if node.ChildNodes[1] != nil { DockNodeFindInfo(node.ChildNodes[1], info) }
}

DockNodeFindWindowByID :: proc(node : ^ImGuiDockNode, id : ImGuiID) -> ^ImGuiWindow
{
	IM_ASSERT(id != 0)
	for window in node.Windows.Data[:node.Windows.Size] { if window.ID == id { return window } }

	return nil
}

// - Remove inactive windows/nodes.
// - Update visibility flag.
DockNodeUpdateFlagsAndCollapse :: proc(node : ^ImGuiDockNode)
{
	g : ^ImGuiContext = GImGui
	IM_ASSERT(node.ParentNode == nil || node.ParentNode.ChildNodes[0] == node || node.ParentNode.ChildNodes[1] == node)

	// Inherit most flags
	if node.ParentNode != nil { node.SharedFlags = node.ParentNode.SharedFlags & cast(ImGuiDockNodeFlags) ImGuiDockNodeFlagsPrivate_.ImGuiDockNodeFlags_SharedFlagsInheritMask_ }

	// Recurse into children
	// There is the possibility that one of our child becoming empty will delete itself and moving its sibling contents into 'node'.
	// If 'node->ChildNode[0]' delete itself, then 'node->ChildNode[1]->Windows' will be moved into 'node'
	// If 'node->ChildNode[1]' delete itself, then 'node->ChildNode[0]->Windows' will be moved into 'node' and the "remove inactive windows" loop will have run twice on those windows (harmless)
	node.HasCentralNodeChild = false
	if node.ChildNodes[0] != nil { DockNodeUpdateFlagsAndCollapse(node.ChildNodes[0]) }
	if node.ChildNodes[1] != nil { DockNodeUpdateFlagsAndCollapse(node.ChildNodes[1]) }

	// Remove inactive windows, collapse nodes
	// Merge node flags overrides stored in windows
	node.LocalFlagsInWindows = ImGuiDockNodeFlags_.ImGuiDockNodeFlags_None
	for window_n : i32 = 0; window_n < node.Windows.Size; window_n += 1 {
		window : ^ImGuiWindow = node.Windows.Data[window_n]
		IM_ASSERT(window.DockNode == node)

		node_was_active : bool = (node.LastFrameActive + 1 == g.FrameCount)
		remove : bool = false
		remove |= node_was_active && (window.LastFrameActive + 1 < g.FrameCount)
		remove |= node_was_active && (node.WantCloseAll || node.WantCloseTabId == window.TabId) && window.HasCloseButton && (window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_UnsavedDocument) == {}; // Submit all _expected_ closure from last frame
		remove |= (window.DockTabWantClose)
		if remove {
			window.DockTabWantClose = false
			if node.Windows.Size == 1 && !IsCentralNode(node) {
				DockNodeHideHostWindow(node)
				node.State = ImGuiDockNodeState.ImGuiDockNodeState_HostWindowHiddenBecauseSingleWindow
				DockNodeRemoveWindow(node, window, node.ID); // Will delete the node so it'll be invalid on return
				return
			}
			DockNodeRemoveWindow(node, window, node.ID)
			post_decr(&window_n)
			continue
		}

		// FIXME-DOCKING: Missing policies for conflict resolution, hence the "Experimental" tag on this.
		//node->LocalFlagsInWindow &= ~window->WindowClass.DockNodeFlagsOverrideClear;
		node.LocalFlagsInWindows |= window.WindowClass.DockNodeFlagsOverrideSet
	}

	UpdateMergedFlags(node)

	// Auto-hide tab bar option
	node_flags : ImGuiDockNodeFlags = node.MergedFlags
	if node.WantHiddenTabBarUpdate && node.Windows.Size == 1 && (node_flags & ImGuiDockNodeFlags_.ImGuiDockNodeFlags_AutoHideTabBar) != {} && !IsHiddenTabBar(node) { node.WantHiddenTabBarToggle = true }
	node.WantHiddenTabBarUpdate = false

	// Cancel toggling if we know our tab bar is enforced to be hidden at all times
	if node.WantHiddenTabBarToggle && node.VisibleWindow != nil && (node.VisibleWindow.WindowClass.DockNodeFlagsOverrideSet & cast(ImGuiDockNodeFlags)ImGuiDockNodeFlagsPrivate_.ImGuiDockNodeFlags_HiddenTabBar) != {} { node.WantHiddenTabBarToggle = false }

	// Apply toggles at a single point of the frame (here!)
	if node.Windows.Size > 1 { SetLocalFlags(node, node.LocalFlags & cast(ImGuiDockNodeFlags)~cast(i32)ImGuiDockNodeFlagsPrivate_.ImGuiDockNodeFlags_HiddenTabBar) }
	else if node.WantHiddenTabBarToggle { SetLocalFlags(node, node.LocalFlags ~ cast(ImGuiDockNodeFlags)ImGuiDockNodeFlagsPrivate_.ImGuiDockNodeFlags_HiddenTabBar) }
	node.WantHiddenTabBarToggle = false

	DockNodeUpdateVisibleFlag(node)
}

// This is rarely called as DockNodeUpdateForRootNode() generally does it most frames.
DockNodeUpdateHasCentralNodeChild :: proc(node : ^ImGuiDockNode)
{
	node.HasCentralNodeChild = false
	if node.ChildNodes[0] != nil { DockNodeUpdateHasCentralNodeChild(node.ChildNodes[0]) }
	if node.ChildNodes[1] != nil { DockNodeUpdateHasCentralNodeChild(node.ChildNodes[1]) }
	if IsRootNode(node) {
		mark_node : ^ImGuiDockNode = node.CentralNode
		for mark_node != nil {
			mark_node.HasCentralNodeChild = true
			mark_node = mark_node.ParentNode
		}
	}
}

DockNodeUpdateVisibleFlag :: proc(node : ^ImGuiDockNode)
{
	// Update visibility flag
	is_visible : bool = (node.ParentNode == nil) ? IsDockSpace(node) : IsCentralNode(node)
	is_visible |= (node.Windows.Size > 0)
	is_visible |= (node.ChildNodes[0] != nil && node.ChildNodes[0].IsVisible)
	is_visible |= (node.ChildNodes[1] != nil && node.ChildNodes[1].IsVisible)
	node.IsVisible = is_visible
}

DockNodeStartMouseMovingWindow :: proc(node : ^ImGuiDockNode, window : ^ImGuiWindow)
{
	g : ^ImGuiContext = GImGui
	IM_ASSERT(node.WantMouseMove == true)
	StartMouseMovingWindow(window)
	g.ActiveIdClickOffset = g.IO.MouseClickedPos[0] - node.Pos
	g.MovingWindow = window; // If we are docked into a non moveable root window, StartMouseMovingWindow() won't set g.MovingWindow. Override that decision.
	node.WantMouseMove = false
}

// Update CentralNode, OnlyNodeWithWindows, LastFocusedNodeID. Copy window class.
DockNodeUpdateForRootNode :: proc(node : ^ImGuiDockNode)
{
	DockNodeUpdateFlagsAndCollapse(node)

	// - Setup central node pointers
	// - Find if there's only a single visible window in the hierarchy (in which case we need to display a regular title bar -> FIXME-DOCK: that last part is not done yet!)
	// Cannot merge this with DockNodeUpdateFlagsAndCollapse() because FirstNodeWithWindows is found after window removal and child collapsing
	info : ImGuiDockNodeTreeInfo
	DockNodeFindInfo(node, &info)
	node.CentralNode = info.CentralNode
	node.OnlyNodeWithWindows = (info.CountNodesWithWindows == 1) ? info.FirstNodeWithWindows : nil
	node.CountNodeWithWindows = info.CountNodesWithWindows
	if node.LastFocusedNodeId == 0 && info.FirstNodeWithWindows != nil { node.LastFocusedNodeId = info.FirstNodeWithWindows.ID }

	// Copy the window class from of our first window so it can be used for proper dock filtering.
	// When node has mixed windows, prioritize the class with the most constraint (DockingAllowUnclassed = false) as the reference to copy.
	// FIXME-DOCK: We don't recurse properly, this code could be reworked to work from DockNodeUpdateScanRec.
	if first_node_with_windows : ^ImGuiDockNode = info.FirstNodeWithWindows; first_node_with_windows != nil {
		node.WindowClass = first_node_with_windows.Windows.Data[0].WindowClass
		for n : i32 = 1; n < first_node_with_windows.Windows.Size; n += 1 { if first_node_with_windows.Windows.Data[n].WindowClass.DockingAllowUnclassed == false {
	node.WindowClass = first_node_with_windows.Windows.Data[n].WindowClass
	break
} }
	}

	mark_node : ^ImGuiDockNode = node.CentralNode
	for mark_node != nil {
		mark_node.HasCentralNodeChild = true
		mark_node = mark_node.ParentNode
	}
}

DockNodeSetupHostWindow :: proc(node : ^ImGuiDockNode, host_window : ^ImGuiWindow)
{
	// Remove ourselves from any previous different host window
	// This can happen if a user mistakenly does (see #4295 for details):
	//  - N+0: DockBuilderAddNode(id, 0)    // missing ImGuiDockNodeFlags_DockSpace
	//  - N+1: NewFrame()                   // will create floating host window for that node
	//  - N+1: DockSpace(id)                // requalify node as dockspace, moving host window
	if node.HostWindow != nil && node.HostWindow != host_window && node.HostWindow.DockNodeAsHost == node { node.HostWindow.DockNodeAsHost = nil }

	host_window.DockNodeAsHost = node
	node.HostWindow = host_window
}

DockNodeUpdate :: proc(node : ^ImGuiDockNode)
{
	g : ^ImGuiContext = GImGui
	IM_ASSERT(node.LastFrameActive != g.FrameCount)
	node.LastFrameAlive = g.FrameCount
	node.IsBgDrawnThisFrame = false

	node.OnlyNodeWithWindows = nil; node.CentralNode = node.OnlyNodeWithWindows
	if IsRootNode(node) { DockNodeUpdateForRootNode(node) }

	// Remove tab bar if not needed
	if node.TabBar != nil && IsNoTabBar(node) { DockNodeRemoveTabBar(node) }

	// Early out for hidden root dock nodes (when all DockId references are in inactive windows, or there is only 1 floating window holding on the DockId)
	want_to_hide_host_window : bool = false
	if IsFloatingNode(node) {
		if node.Windows.Size <= 1 && IsLeafNode(node) { if !g.IO.ConfigDockingAlwaysTabBar && (node.Windows.Size == 0 || !node.Windows.Data[0].WindowClass.DockingAlwaysTabBar) { want_to_hide_host_window = true } }
		if node.CountNodeWithWindows == 0 { want_to_hide_host_window = true }
	}
	if want_to_hide_host_window {
		if node.Windows.Size == 1 {
			// Floating window pos/size is authoritative
			single_window : ^ImGuiWindow = node.Windows.Data[0]
			node.Pos = single_window.Pos
			node.Size = single_window.SizeFull
			node.AuthorityForViewport = ImGuiDataAuthority_.ImGuiDataAuthority_Window; node.AuthorityForSize = node.AuthorityForViewport; node.AuthorityForPos = node.AuthorityForSize

			// Transfer focus immediately so when we revert to a regular window it is immediately selected
			if node.HostWindow != nil && g.NavWindow == node.HostWindow { FocusWindow(single_window) }
			if node.HostWindow != nil {
				IMGUI_DEBUG_LOG_VIEWPORT(g, "[viewport] Node %08X transfer Viewport %08X->%08X to Window '%s'\n", node.ID, node.HostWindow.Viewport.ID, single_window.ID, single_window.Name)
				single_window.Viewport = node.HostWindow.Viewport
				single_window.ViewportId = node.HostWindow.ViewportId
				if node.HostWindow.ViewportOwned {
					single_window.Viewport.ID = single_window.ID
					single_window.Viewport.Window = single_window
					single_window.ViewportOwned = true
				}
			}
			node.RefViewportId = single_window.ViewportId
		}

		DockNodeHideHostWindow(node)
		node.State = ImGuiDockNodeState.ImGuiDockNodeState_HostWindowHiddenBecauseSingleWindow
		node.WantCloseAll = false
		node.WantCloseTabId = 0
		node.HasWindowMenuButton = false; node.HasCloseButton = node.HasWindowMenuButton
		node.LastFrameActive = g.FrameCount

		if node.WantMouseMove && node.Windows.Size == 1 { DockNodeStartMouseMovingWindow(node, node.Windows.Data[0]) }
		return
	}

	// In some circumstance we will defer creating the host window (so everything will be kept hidden),
	// while the expected visible window is resizing itself.
	// This is important for first-time (no ini settings restored) single window when io.ConfigDockingAlwaysTabBar is enabled,
	// otherwise the node ends up using the minimum window size. Effectively those windows will take an extra frame to show up:
	//   N+0: Begin(): window created (with no known size), node is created
	//   N+1: DockNodeUpdate(): node skip creating host window / Begin(): window size applied, not visible
	//   N+2: DockNodeUpdate(): node can create host window / Begin(): window becomes visible
	// We could remove this frame if we could reliably calculate the expected window size during node update, before the Begin() code.
	// It would require a generalization of CalcWindowExpectedSize(), probably extracting code away from Begin().
	// In reality it isn't very important as user quickly ends up with size data in .ini file.
	if node.IsVisible && node.HostWindow == nil && IsFloatingNode(node) && IsLeafNode(node) {
		IM_ASSERT(node.Windows.Size > 0)
		ref_window : ^ImGuiWindow = nil
		if node.SelectedTabId != 0 {
			// Note that we prune single-window-node settings on .ini loading, so this is generally 0 for them!
			ref_window = DockNodeFindWindowByID(node, node.SelectedTabId)
		}
		if ref_window == nil { ref_window = node.Windows.Data[0] }
		if ref_window.AutoFitFramesX > 0 || ref_window.AutoFitFramesY > 0 {
			node.State = ImGuiDockNodeState.ImGuiDockNodeState_HostWindowHiddenBecauseWindowsAreResizing
			return
		}
	}

	node_flags : ImGuiDockNodeFlags = node.MergedFlags

	// Decide if the node will have a close button and a window menu button
	node.HasWindowMenuButton = (node.Windows.Size > 0) && (node_flags & cast(ImGuiDockNodeFlags) ImGuiDockNodeFlagsPrivate_.ImGuiDockNodeFlags_NoWindowMenuButton) == {}
	node.HasCloseButton = false
	for window in node.Windows.Data[:node.Windows.Size] {
		// FIXME-DOCK: Setting DockIsActive here means that for single active window in a leaf node, DockIsActive will be cleared until the next Begin() call.
		node.HasCloseButton |= window.HasCloseButton
		window.DockIsActive = (node.Windows.Size > 1)
	}

	if (node_flags & cast(ImGuiDockNodeFlags) ImGuiDockNodeFlagsPrivate_.ImGuiDockNodeFlags_NoCloseButton) != {} { node.HasCloseButton = false }

	// Bind or create host window
	host_window : ^ImGuiWindow = nil
	beginned_into_host_window : bool = false
	if IsDockSpace(node) {
		// [Explicit root dockspace node]
		IM_ASSERT(node.HostWindow != nil)
		host_window = node.HostWindow
	}
	else {
		// [Automatic root or child nodes]
		if IsRootNode(node) && node.IsVisible {
			ref_window : ^ImGuiWindow = (node.Windows.Size > 0) ? node.Windows.Data[0] : nil

			// Sync Pos
			if node.AuthorityForPos == ImGuiDataAuthority_.ImGuiDataAuthority_Window && ref_window != nil { SetNextWindowPos(ref_window.Pos) }
			else if node.AuthorityForPos == ImGuiDataAuthority_.ImGuiDataAuthority_DockNode { SetNextWindowPos(node.Pos) }

			// Sync Size
			if node.AuthorityForSize == ImGuiDataAuthority_.ImGuiDataAuthority_Window && ref_window != nil { SetNextWindowSize(ref_window.SizeFull) }
			else if node.AuthorityForSize == ImGuiDataAuthority_.ImGuiDataAuthority_DockNode { SetNextWindowSize(node.Size) }

			// Sync Collapsed
			if node.AuthorityForSize == ImGuiDataAuthority_.ImGuiDataAuthority_Window && ref_window != nil { SetNextWindowCollapsed(ref_window.Collapsed) }

			// Sync Viewport
			if node.AuthorityForViewport == ImGuiDataAuthority_.ImGuiDataAuthority_Window && ref_window != nil { SetNextWindowViewport(ref_window.ViewportId) }
			else if node.AuthorityForViewport == ImGuiDataAuthority_.ImGuiDataAuthority_Window && node.RefViewportId != 0 { SetNextWindowViewport(node.RefViewportId) }

			SetNextWindowClass(&node.WindowClass)

			// Begin into the host window
			window_label : [20]u8
			DockNodeGetHostWindowTitle(node, window_label[:])
			window_flags : ImGuiWindowFlags = ImGuiWindowFlags_.ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_.ImGuiWindowFlags_NoScrollWithMouse | ImGuiWindowFlags_.ImGuiWindowFlags_DockNodeHost
			window_flags |= ImGuiWindowFlags_.ImGuiWindowFlags_NoFocusOnAppearing
			window_flags |= ImGuiWindowFlags_.ImGuiWindowFlags_NoSavedSettings | ImGuiWindowFlags_.ImGuiWindowFlags_NoNavFocus | ImGuiWindowFlags_.ImGuiWindowFlags_NoCollapse
			window_flags |= ImGuiWindowFlags_.ImGuiWindowFlags_NoTitleBar

			SetNextWindowBgAlpha(0.0); // Don't set ImGuiWindowFlags_NoBackground because it disables borders
			PushStyleVar(ImGuiStyleVar_.ImGuiStyleVar_WindowPadding, ImVec2{0, 0})
			Begin(string_from_slice(window_label[:]), nil, window_flags)
			PopStyleVar()
			beginned_into_host_window = true

			host_window = g.CurrentWindow
			DockNodeSetupHostWindow(node, host_window)
			host_window.DC.CursorPos = host_window.Pos
			node.Pos = host_window.Pos
			node.Size = host_window.Size

			// We set ImGuiWindowFlags_NoFocusOnAppearing because we don't want the host window to take full focus (e.g. steal NavWindow)
			// But we still it bring it to the front of display. There's no way to choose this precise behavior via window flags.
			// One simple case to ponder if: window A has a toggle to create windows B/C/D. Dock B/C/D together, clear the toggle and enable it again.
			// When reappearing B/C/D will request focus and be moved to the top of the display pile, but they are not linked to the dock host window
			// during the frame they appear. The dock host window would keep its old display order, and the sorting in EndFrame would move B/C/D back
			// after the dock host window, losing their top-most status.
			if node.HostWindow.Appearing { BringWindowToDisplayFront(node.HostWindow) }

			node.AuthorityForViewport = ImGuiDataAuthority_.ImGuiDataAuthority_Auto; node.AuthorityForSize = node.AuthorityForViewport; node.AuthorityForPos = node.AuthorityForSize
		}
		else if node.ParentNode != nil {
			host_window = node.ParentNode.HostWindow; node.HostWindow = host_window
			node.AuthorityForViewport = ImGuiDataAuthority_.ImGuiDataAuthority_Auto; node.AuthorityForSize = node.AuthorityForViewport; node.AuthorityForPos = node.AuthorityForSize
		}
		if node.WantMouseMove && node.HostWindow != nil { DockNodeStartMouseMovingWindow(node, node.HostWindow) }
	}
	node.RefViewportId = 0; // Clear when we have a host window

	// Update focused node (the one whose title bar is highlight) within a node tree
	if IsSplitNode(node) { IM_ASSERT(node.TabBar == nil) }
	if IsRootNode(node) { if p_window : ^ImGuiWindow = g.NavWindow != nil ? g.NavWindow.RootWindow : nil; p_window != nil { for p_window != nil && p_window.DockNode != nil {
	p_node : ^ImGuiDockNode = DockNodeGetRootNode(p_window.DockNode)
	if p_node == node {
		node.LastFocusedNodeId = p_window.DockNode.ID; // Note: not using root node ID!
		break
	}
	p_window = p_node.HostWindow != nil ? p_node.HostWindow.RootWindow : nil
} } }

	// Register a hit-test hole in the window unless we are currently dragging a window that is compatible with our dockspace
	central_node : ^ImGuiDockNode = node.CentralNode
	central_node_hole : bool = IsRootNode(node) && host_window != nil && (node_flags & ImGuiDockNodeFlags_.ImGuiDockNodeFlags_PassthruCentralNode) != {} && central_node != nil && IsEmpty(central_node)
	central_node_hole_register_hit_test_hole : bool = central_node_hole
	if central_node_hole { if payload : ^ImGuiPayload = GetDragDropPayload(); payload != nil { if IsDataType(payload, IMGUI_PAYLOAD_TYPE_WINDOW) && DockNodeIsDropAllowed(host_window, (cast(^^ImGuiWindow) payload.Data)^) { central_node_hole_register_hit_test_hole = false } } }
	if central_node_hole_register_hit_test_hole {
		// We add a little padding to match the "resize from edges" behavior and allow grabbing the splitter easily.
		// (But we only add it if there's something else on the other side of the hole, otherwise for e.g. fullscreen
		// covering passthru node we'd have a gap on the edge not covered by the hole)
		IM_ASSERT(IsDockSpace(node)); // We cannot pass this flag without the DockSpace() api. Testing this because we also setup the hole in host_window->ParentNode
		root_node : ^ImGuiDockNode = DockNodeGetRootNode(central_node)
		root_rect : ImRect; init(&root_rect, root_node.Pos, root_node.Pos + root_node.Size)
		hole_rect : ImRect; init(&hole_rect, central_node.Pos, central_node.Pos + central_node.Size)
		if hole_rect.Min.x > root_rect.Min.x { hole_rect.Min.x += WINDOWS_HOVER_PADDING }
		if hole_rect.Max.x < root_rect.Max.x { hole_rect.Max.x -= WINDOWS_HOVER_PADDING }
		if hole_rect.Min.y > root_rect.Min.y { hole_rect.Min.y += WINDOWS_HOVER_PADDING }
		if hole_rect.Max.y < root_rect.Max.y { hole_rect.Max.y -= WINDOWS_HOVER_PADDING }
		//GetForegroundDrawList()->AddRect(hole_rect.Min, hole_rect.Max, IM_COL32(255, 0, 0, 255));
		if central_node_hole && !IsInverted(hole_rect) {
			SetWindowHitTestHole(host_window, hole_rect.Min, hole_rect.Max - hole_rect.Min)
			if host_window.ParentWindow != nil { SetWindowHitTestHole(host_window.ParentWindow, hole_rect.Min, hole_rect.Max - hole_rect.Min) }
		}
	}

	// Update position/size, process and draw resizing splitters
	if IsRootNode(node) && host_window != nil {
		DockNodeTreeUpdatePosSize(node, host_window.Pos, host_window.Size)
		PushStyleColor(ImGuiCol_.ImGuiCol_Separator, g.Style.Colors[ImGuiCol_.ImGuiCol_Border])
		PushStyleColor(ImGuiCol_.ImGuiCol_SeparatorActive, g.Style.Colors[ImGuiCol_.ImGuiCol_ResizeGripActive])
		PushStyleColor(ImGuiCol_.ImGuiCol_SeparatorHovered, g.Style.Colors[ImGuiCol_.ImGuiCol_ResizeGripHovered])
		DockNodeTreeUpdateSplitter(node)
		PopStyleColor(3)
	}

	// Draw empty node background (currently can only be the Central Node)
	if host_window != nil && IsEmpty(node) && node.IsVisible {
		ChannelsSetCurrent(host_window.DrawList, DOCKING_HOST_DRAW_CHANNEL_BG)
		node.LastBgColor = (node_flags & ImGuiDockNodeFlags_.ImGuiDockNodeFlags_PassthruCentralNode) != {} ? 0 : GetColorU32(ImGuiCol_.ImGuiCol_DockingEmptyBg)
		if node.LastBgColor != 0 { AddRectFilled(host_window.DrawList, node.Pos, node.Pos + node.Size, node.LastBgColor) }
		node.IsBgDrawnThisFrame = true
	}

	// Draw whole dockspace background if ImGuiDockNodeFlags_PassthruCentralNode if set.
	// We need to draw a background at the root level if requested by ImGuiDockNodeFlags_PassthruCentralNode, but we will only know the correct pos/size
	// _after_ processing the resizing splitters. So we are using the DrawList channel splitting facility to submit drawing primitives out of order!
	render_dockspace_bg : bool = IsRootNode(node) && host_window != nil && (node_flags & ImGuiDockNodeFlags_.ImGuiDockNodeFlags_PassthruCentralNode) != {}
	if render_dockspace_bg && node.IsVisible {
		ChannelsSetCurrent(host_window.DrawList, DOCKING_HOST_DRAW_CHANNEL_BG)
		if central_node_hole { RenderRectFilledWithHole(host_window.DrawList, Rect(node), Rect(central_node), GetColorU32(ImGuiCol_.ImGuiCol_WindowBg), 0.0) }
		else { AddRectFilled(host_window.DrawList, node.Pos, node.Pos + node.Size, GetColorU32(ImGuiCol_.ImGuiCol_WindowBg), 0.0) }
	}

	// Draw and populate Tab Bar
	if host_window != nil { ChannelsSetCurrent(host_window.DrawList, DOCKING_HOST_DRAW_CHANNEL_FG) }
	if host_window != nil && node.Windows.Size > 0 {
		DockNodeUpdateTabBar(node, host_window)
	}
	else {
		node.WantCloseAll = false
		node.WantCloseTabId = 0
		node.IsFocused = false
	}
	if node.TabBar != nil && node.TabBar.SelectedTabId != 0 { node.SelectedTabId = node.TabBar.SelectedTabId }
	else if node.Windows.Size > 0 { node.SelectedTabId = node.Windows.Data[0].TabId }

	// Draw payload drop target
	if host_window != nil && node.IsVisible { if IsRootNode(node) && (g.MovingWindow == nil || g.MovingWindow.RootWindowDockTree != host_window) { BeginDockableDragDropTarget(host_window) } }

	// We update this after DockNodeUpdateTabBar()
	node.LastFrameActive = g.FrameCount

	// Recurse into children
	// FIXME-DOCK FIXME-OPT: Should not need to recurse into children
	if host_window != nil {
		if node.ChildNodes[0] != nil { DockNodeUpdate(node.ChildNodes[0]) }
		if node.ChildNodes[1] != nil { DockNodeUpdate(node.ChildNodes[1]) }

		// Render outer borders last (after the tab bar)
		if IsRootNode(node) { RenderWindowOuterBorders(host_window) }
	}

	// End host window
	if beginned_into_host_window {
		//-V1020
		End()
	}
}

// Compare TabItem nodes given the last known DockOrder (will persist in .ini file as hint), used to sort tabs when multiple tabs are added on the same frame.
TabItemComparerByDockOrder :: proc(lhs, rhs : ImGuiTabItem) -> slice.Ordering
{
	a : ^ImGuiWindow = lhs.Window
	b : ^ImGuiWindow = rhs.Window
	if d : i32 = ((a.DockOrder == -1) ? INT_MAX : i32(a.DockOrder)) - ((b.DockOrder == -1) ? INT_MAX : i32(b.DockOrder)); d != 0 { return slice.Ordering(d) }
	return slice.Ordering(a.BeginOrderWithinContext - b.BeginOrderWithinContext)
}

// Default handler for g.DockNodeWindowMenuHandler(): display the list of windows for a given dock-node.
// This is exceptionally stored in a function pointer to also user applications to tweak this menu (undocumented)
// Custom overrides may want to decorate, group, sort entries.
// Please note those are internal structures: if you copy this expect occasional breakage.
// (if you don't need to modify the "Tabs.Size == 1" behavior/path it is recommend you call this function in your handler)
DockNodeWindowMenuHandler_Default :: proc(ctx : ^ImGuiContext, node : ^ImGuiDockNode, tab_bar : ^ImGuiTabBar)
{
	IM_UNUSED(ctx)
	if tab_bar.Tabs.Size == 1 {
		// "Hide tab bar" option. Being one of our rare user-facing string we pull it from a table.
		if MenuItem(LocalizeGetMsg(ImGuiLocKey.ImGuiLocKey_DockingHideTabBar), "", IsHiddenTabBar(node)) { node.WantHiddenTabBarToggle = true }
	}
	else {
		// Display a selectable list of windows in this docking node
		for tab_n : i32 = 0; tab_n < tab_bar.Tabs.Size; tab_n += 1 {
			tab : ^ImGuiTabItem = &tab_bar.Tabs.Data[tab_n]
			if (tab.Flags & cast(ImGuiTabItemFlags) ImGuiTabItemFlagsPrivate_.ImGuiTabItemFlags_Button) != {} { continue }
			if Selectable(TabBarGetTabName(tab_bar, tab), tab.ID == tab_bar.SelectedTabId) { TabBarQueueFocus(tab_bar, tab) }
			SameLine()
			Text("   ")
		}
	}
}

DockNodeWindowMenuUpdate :: proc(node : ^ImGuiDockNode, tab_bar : ^ImGuiTabBar)
{
	// Try to position the menu so it is more likely to stays within the same viewport
	g : ^ImGuiContext = GImGui
	if g.Style.WindowMenuButtonPosition == ImGuiDir.ImGuiDir_Left { SetNextWindowPos(ImVec2{node.Pos.x, node.Pos.y + GetFrameHeight()}, ImGuiCond_.ImGuiCond_Always, ImVec2{0.0, 0.0}) }
	else { SetNextWindowPos(ImVec2{node.Pos.x + node.Size.x, node.Pos.y + GetFrameHeight()}, ImGuiCond_.ImGuiCond_Always, ImVec2{1.0, 0.0}) }
	if BeginPopup("#WindowMenu") {
		node.IsFocused = true
		g.DockNodeWindowMenuHandler(g, node, tab_bar)
		EndPopup()
	}
}

// User helper to append/amend into a dock node tab bar. Most commonly used to add e.g. a "+" button.
DockNodeBeginAmendTabBar :: proc(node : ^ImGuiDockNode) -> bool
{
	if node.TabBar == nil || node.HostWindow == nil { return false }
	if (node.MergedFlags & ImGuiDockNodeFlags_.ImGuiDockNodeFlags_KeepAliveOnly) != {} { return false }
	if node.TabBar.ID == 0 { return false }
	Begin(node.HostWindow.Name)
	PushOverrideID(node.ID)
	ret : bool = BeginTabBarEx(node.TabBar, node.TabBar.BarRect, node.TabBar.Flags)
	IM_UNUSED(ret)
	IM_ASSERT(ret)
	return true
}

DockNodeEndAmendTabBar :: proc()
{
	EndTabBar()
	PopID()
	End()
}

IsDockNodeTitleBarHighlighted :: proc(node : ^ImGuiDockNode, root_node : ^ImGuiDockNode) -> bool
{
	// CTRL+Tab highlight (only highlighting leaf node, not whole hierarchy)
	g : ^ImGuiContext = GImGui
	if g.NavWindowingTarget != nil { return (g.NavWindowingTarget.DockNode == node) }

	// FIXME-DOCKING: May want alternative to treat central node void differently? e.g. if (g.NavWindow == host_window)
	if g.NavWindow != nil && root_node.LastFocusedNodeId == node.ID {
		// FIXME: This could all be backed in RootWindowForTitleBarHighlight? Probably need to reorganize for both dock nodes + other RootWindowForTitleBarHighlight users (not-node)
		parent_window : ^ImGuiWindow = g.NavWindow.RootWindow
		for (parent_window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_ChildMenu) != {} { parent_window = parent_window.ParentWindow.RootWindow }

		start_parent_node : ^ImGuiDockNode = parent_window.DockNodeAsHost != nil ? parent_window.DockNodeAsHost : parent_window.DockNode
		for parent_node := start_parent_node; parent_node != nil; parent_node = parent_node.HostWindow != nil ? parent_node.HostWindow.RootWindow.DockNode : nil {
			parent_node = DockNodeGetRootNode(parent_node)
			if parent_node == root_node { return true }
		}
	}
	return false
}

// Submit the tab bar corresponding to a dock node and various housekeeping details.
DockNodeUpdateTabBar :: proc(node : ^ImGuiDockNode, host_window : ^ImGuiWindow)
{
	g : ^ImGuiContext = GImGui
	style : ^ImGuiStyle = &g.Style

	node_was_active : bool = (node.LastFrameActive + 1 == g.FrameCount)
	closed_all : bool = node.WantCloseAll && node_was_active
	closed_one : ImGuiID = node.WantCloseTabId != 0 && node_was_active ? 1 : 0
	node.WantCloseAll = false
	node.WantCloseTabId = 0

	// Decide if we should use a focused title bar color
	is_focused : bool = false
	root_node : ^ImGuiDockNode = DockNodeGetRootNode(node)
	if IsDockNodeTitleBarHighlighted(node, root_node) { is_focused = true }

	// Hidden tab bar will show a triangle on the upper-left (in Begin)
	if IsHiddenTabBar(node) || IsNoTabBar(node) {
		node.VisibleWindow = (node.Windows.Size > 0) ? node.Windows.Data[0] : nil
		node.IsFocused = is_focused
		if is_focused { node.LastFrameFocused = g.FrameCount }
		if node.VisibleWindow != nil {
			// Notify root of visible window (used to display title in OS task bar)
			if is_focused || root_node.VisibleWindow == nil { root_node.VisibleWindow = node.VisibleWindow }
			if node.TabBar != nil { node.TabBar.VisibleTabId = node.VisibleWindow.TabId }
		}
		return
	}

	// Move ourselves to the Menu layer (so we can be accessed by tapping Alt) + undo SkipItems flag in order to draw over the title bar even if the window is collapsed
	backup_skip_item : bool = host_window.SkipItems
	if !IsDockSpace(node) {
		host_window.SkipItems = false
		host_window.DC.NavLayerCurrent = ImGuiNavLayer.ImGuiNavLayer_Menu
	}

	// Use PushOverrideID() instead of PushID() to use the node id _without_ the host window ID.
	// This is to facilitate computing those ID from the outside, and will affect more or less only the ID of the collapse button, popup and tabs,
	// as docked windows themselves will override the stack with their own root ID.
	PushOverrideID(node.ID)
	tab_bar : ^ImGuiTabBar = node.TabBar
	tab_bar_is_recreated : bool = (tab_bar == nil); // Tab bar are automatically destroyed when a node gets hidden
	if tab_bar == nil {
		DockNodeAddTabBar(node)
		tab_bar = node.TabBar
	}

	focus_tab_id : ImGuiID = 0
	node.IsFocused = is_focused

	node_flags : ImGuiDockNodeFlags = node.MergedFlags
	has_window_menu_button : bool = (node_flags & cast(ImGuiDockNodeFlags) ImGuiDockNodeFlagsPrivate_.ImGuiDockNodeFlags_NoWindowMenuButton) == {} && (style.WindowMenuButtonPosition != ImGuiDir.ImGuiDir_None)

	// In a dock node, the Collapse Button turns into the Window Menu button.
	// FIXME-DOCK FIXME-OPT: Could we recycle popups id across multiple dock nodes?
	if has_window_menu_button && IsPopupOpen("#WindowMenu") {
		next_selected_tab_id : ImGuiID = tab_bar.NextSelectedTabId
		DockNodeWindowMenuUpdate(node, tab_bar)
		if tab_bar.NextSelectedTabId != 0 && tab_bar.NextSelectedTabId != next_selected_tab_id { focus_tab_id = tab_bar.NextSelectedTabId }
		is_focused |= node.IsFocused
	}

	// Layout
	title_bar_rect : ImRect; tab_bar_rect : ImRect
	window_menu_button_pos : ImVec2
	close_button_pos : ImVec2
	DockNodeCalcTabBarLayout(node, &title_bar_rect, &tab_bar_rect, &window_menu_button_pos, &close_button_pos)

	// Submit new tabs, they will be added as Unsorted and sorted below based on relative DockOrder value.
	tabs_count_old : i32 = tab_bar.Tabs.Size
	for window_n : i32 = 0; window_n < node.Windows.Size; window_n += 1 {
		window : ^ImGuiWindow = node.Windows.Data[window_n]
		if TabBarFindTabByID(tab_bar, window.TabId) == nil { TabBarAddTab(tab_bar, cast(ImGuiTabItemFlags)ImGuiTabItemFlagsPrivate_.ImGuiTabItemFlags_Unsorted, window) }
	}

	// Title bar
	if is_focused { node.LastFrameFocused = g.FrameCount }
	title_bar_col : ImU32 = GetColorU32(host_window.Collapsed ? ImGuiCol_.ImGuiCol_TitleBgCollapsed : is_focused ? ImGuiCol_.ImGuiCol_TitleBgActive : ImGuiCol_.ImGuiCol_TitleBg)
	rounding_flags : ImDrawFlags = CalcRoundingFlagsForRectInRect(title_bar_rect, Rect(host_window), g.Style.DockingSeparatorSize)
	AddRectFilled(host_window.DrawList, title_bar_rect.Min, title_bar_rect.Max, title_bar_col, host_window.WindowRounding, rounding_flags)

	// Docking/Collapse button
	if has_window_menu_button {
		if CollapseButton(GetID(host_window, "#COLLAPSE"), window_menu_button_pos, node) {
			// == DockNodeGetWindowMenuButtonId(node)
			OpenPopup("#WindowMenu")
		}
		if IsItemActive() { focus_tab_id = tab_bar.SelectedTabId }
		if IsItemHovered(ImGuiHoveredFlags_.ImGuiHoveredFlags_ForTooltip | ImGuiHoveredFlags_.ImGuiHoveredFlags_DelayNormal) && g.HoveredIdTimer > 0.5 { SetTooltip("%s", LocalizeGetMsg(ImGuiLocKey.ImGuiLocKey_DockingDragToUndockOrMoveNode)) }
	}

	// If multiple tabs are appearing on the same frame, sort them based on their persistent DockOrder value
	tabs_unsorted_start : i32 = tab_bar.Tabs.Size
	for tab_n : i32 = tab_bar.Tabs.Size - 1; tab_n >= 0 && (tab_bar.Tabs.Data[tab_n].Flags & cast(ImGuiTabItemFlags) ImGuiTabItemFlagsPrivate_.ImGuiTabItemFlags_Unsorted) != {}; tab_n -= 1 {
		// FIXME-DOCK: Consider only clearing the flag after the tab has been alive for a few consecutive frames, allowing late comers to not break sorting?
		tab_bar.Tabs.Data[tab_n].Flags &= cast(ImGuiTabItemFlags)~cast(i32)ImGuiTabItemFlagsPrivate_.ImGuiTabItemFlags_Unsorted
		tabs_unsorted_start = tab_n
	}

	if tab_bar.Tabs.Size > tabs_unsorted_start {
		IMGUI_DEBUG_LOG_DOCKING(g, "[docking] In node 0x%08X: %d new appearing tabs:%s\n", node.ID, tab_bar.Tabs.Size - tabs_unsorted_start, (tab_bar.Tabs.Size > tabs_unsorted_start + 1) ? " (will sort)" : "")
		for tab_n : i32 = tabs_unsorted_start; tab_n < tab_bar.Tabs.Size; tab_n += 1 {
			tab : ^ImGuiTabItem = &tab_bar.Tabs.Data[tab_n]
			IM_UNUSED(tab)
			IMGUI_DEBUG_LOG_DOCKING(g, "[docking] - Tab 0x%08X '%s' Order %d\n", tab.ID, TabBarGetTabName(tab_bar, tab), tab.Window != nil ? tab.Window.DockOrder : -1)
		}

		IMGUI_DEBUG_LOG_DOCKING(g, "[docking] SelectedTabId = 0x%08X, NavWindow->TabId = 0x%08X\n", node.SelectedTabId, g.NavWindow != nil ? g.NavWindow.TabId : ~u32(0))
		if tab_bar.Tabs.Size > tabs_unsorted_start + 1 { ImQsort(tab_bar.Tabs.Data[tabs_unsorted_start:tab_bar.Tabs.Size], TabItemComparerByDockOrder) }
	}

	// Apply NavWindow focus back to the tab bar
	if g.NavWindow != nil && g.NavWindow.RootWindow.DockNode == node { tab_bar.SelectedTabId = g.NavWindow.RootWindow.TabId }

	// Selected newly added tabs, or persistent tab ID if the tab bar was just recreated
	if tab_bar_is_recreated && TabBarFindTabByID(tab_bar, node.SelectedTabId) != nil { tab_bar.NextSelectedTabId = node.SelectedTabId; tab_bar.SelectedTabId = tab_bar.NextSelectedTabId }
	else if tab_bar.Tabs.Size > tabs_count_old { tab_bar.NextSelectedTabId = back(&tab_bar.Tabs).Window.TabId; tab_bar.SelectedTabId = tab_bar.NextSelectedTabId }

	// Begin tab bar
	tab_bar_flags : ImGuiTabBarFlags = ImGuiTabBarFlags_.ImGuiTabBarFlags_Reorderable | ImGuiTabBarFlags_.ImGuiTabBarFlags_AutoSelectNewTabs; // | ImGuiTabBarFlags_NoTabListScrollingButtons);
	tab_bar_flags |= cast(ImGuiTabBarFlags) (ImGuiTabBarFlagsPrivate_.ImGuiTabBarFlags_SaveSettings | ImGuiTabBarFlagsPrivate_.ImGuiTabBarFlags_DockNode); // | ImGuiTabBarFlags_FittingPolicyScroll;
	tab_bar_flags |= ImGuiTabBarFlags_.ImGuiTabBarFlags_DrawSelectedOverline
	if !host_window.Collapsed && is_focused { tab_bar_flags |= cast(ImGuiTabBarFlags) ImGuiTabBarFlagsPrivate_.ImGuiTabBarFlags_IsFocused }
	tab_bar.ID = GetID("#TabBar")
	tab_bar.SeparatorMinX = node.Pos.x + host_window.WindowBorderSize; // Separator cover the whole node width
	tab_bar.SeparatorMaxX = node.Pos.x + node.Size.x - host_window.WindowBorderSize
	BeginTabBarEx(tab_bar, tab_bar_rect, tab_bar_flags)
	//host_window->DrawList->AddRect(tab_bar_rect.Min, tab_bar_rect.Max, IM_COL32(255,0,255,255));

	// Backup style colors
	backup_style_cols : [ImGuiWindowDockStyleCol.ImGuiWindowDockStyleCol_COUNT]ImVec4
	for color_n : i32 = 0; color_n < cast(i32)ImGuiWindowDockStyleCol.ImGuiWindowDockStyleCol_COUNT; color_n += 1 { backup_style_cols[color_n] = g.Style.Colors[GWindowDockStyleColors[color_n]] }

	// Submit actual tabs
	node.VisibleWindow = nil
	for window_n : i32 = 0; window_n < node.Windows.Size; window_n += 1 {
		window : ^ImGuiWindow = node.Windows.Data[window_n]
		if (closed_all || closed_one == window.TabId) && window.HasCloseButton && (window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_UnsavedDocument) == {} { continue }
		if window.LastFrameActive + 1 >= g.FrameCount || !node_was_active {
			tab_item_flags : ImGuiTabItemFlags = {}
			tab_item_flags |= window.WindowClass.TabItemFlagsOverrideSet
			if (window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_UnsavedDocument) != {} { tab_item_flags |= ImGuiTabItemFlags_.ImGuiTabItemFlags_UnsavedDocument }
			if (tab_bar.Flags & ImGuiTabBarFlags_.ImGuiTabBarFlags_NoCloseWithMiddleMouseButton) != {} { tab_item_flags |= ImGuiTabItemFlags_.ImGuiTabItemFlags_NoCloseWithMiddleMouseButton }

			// Apply stored style overrides for the window
			for color_n : i32 = 0; color_n < cast(i32)ImGuiWindowDockStyleCol.ImGuiWindowDockStyleCol_COUNT; color_n += 1 { g.Style.Colors[GWindowDockStyleColors[color_n]] = ColorConvertU32ToFloat4(window.DockStyle.Colors[color_n]) }

			// Note that TabItemEx() calls TabBarCalcTabID() so our tab item ID will ignore the current ID stack (rightly so)
			tab_open : bool = true
			TabItemEx(tab_bar, window.Name, window.HasCloseButton ? &tab_open : nil, tab_item_flags, window)
			if !tab_open { node.WantCloseTabId = window.TabId }
			if tab_bar.VisibleTabId == window.TabId { node.VisibleWindow = window }

			// Store last item data so it can be queried with IsItemXXX functions after the user Begin() call
			window.DockTabItemStatusFlags = g.LastItemData.StatusFlags
			window.DockTabItemRect = g.LastItemData.Rect

			// Update navigation ID on menu layer
			if g.NavWindow != nil && g.NavWindow.RootWindow == window && (window.DC.NavLayersActiveMask & (1 << cast(u32)ImGuiNavLayer.ImGuiNavLayer_Menu)) == 0 { host_window.NavLastIds[1] = window.TabId }
		}
	}

	// Restore style colors
	for color_n : i32 = 0; color_n < cast(i32)ImGuiWindowDockStyleCol.ImGuiWindowDockStyleCol_COUNT; color_n += 1 { g.Style.Colors[GWindowDockStyleColors[color_n]] = backup_style_cols[color_n] }

	// Notify root of visible window (used to display title in OS task bar)
	if node.VisibleWindow != nil { if is_focused || root_node.VisibleWindow == nil { root_node.VisibleWindow = node.VisibleWindow } }

	// Close button (after VisibleWindow was updated)
	// Note that VisibleWindow may have been overrided by CTRL+Tabbing, so VisibleWindow->TabId may be != from tab_bar->SelectedTabId
	close_button_is_enabled : bool = node.HasCloseButton && node.VisibleWindow != nil && node.VisibleWindow.HasCloseButton
	close_button_is_visible : bool = node.HasCloseButton
	//const bool close_button_is_visible = close_button_is_enabled; // Most people would expect this behavior of not even showing the button (leaving a hole since we can't claim that space as other windows in the tba bar have one)
	if close_button_is_visible {
		if !close_button_is_enabled {
			PushItemFlag(cast(ImGuiItemFlags)ImGuiItemFlagsPrivate_.ImGuiItemFlags_Disabled, true)
			PushStyleColor(ImGuiCol_.ImGuiCol_Text, style.Colors[ImGuiCol_.ImGuiCol_Text] * ImVec4{1.0, 1.0, 1.0, 0.4})
		}
		if CloseButton(GetID(host_window, "#CLOSE"), close_button_pos) {
			node.WantCloseAll = true
			for n : i32 = 0; n < tab_bar.Tabs.Size; n += 1 { TabBarCloseTab(tab_bar, &tab_bar.Tabs.Data[n]) }
		}
		//if (IsItemActive())
		//    focus_tab_id = tab_bar->SelectedTabId;
		if !close_button_is_enabled {
			PopStyleColor()
			PopItemFlag()
		}
	}

	// When clicking on the title bar outside of tabs, we still focus the selected tab for that node
	// FIXME: TabItems submitted earlier use AllowItemOverlap so we manually perform a more specific test for now (hovered || held) in order to not cover them.
	title_bar_id : ImGuiID = GetID(host_window, "#TITLEBAR")
	if g.HoveredId == 0 || g.HoveredId == title_bar_id || g.ActiveId == title_bar_id {
		// AllowOverlap mode required for appending into dock node tab bar,
		// otherwise dragging window will steal HoveredId and amended tabs cannot get them.
		held : bool
		KeepAliveID(title_bar_id)
		ButtonBehavior(title_bar_rect, title_bar_id, nil, &held, cast(ImGuiButtonFlags)ImGuiButtonFlagsPrivate_.ImGuiButtonFlags_AllowOverlap)
		if g.HoveredId == title_bar_id {
			g.LastItemData.ID = title_bar_id
		}
		if held {
			if IsMouseClicked(cast(ImGuiMouseButton) 0) { focus_tab_id = tab_bar.SelectedTabId }

			// Forward moving request to selected window
			if tab : ^ImGuiTabItem = TabBarFindTabByID(tab_bar, tab_bar.SelectedTabId); tab != nil {
				// Undock from tab bar empty space
				StartMouseMovingWindowOrNode(tab.Window != nil ? tab.Window : node.HostWindow, node, false)
			}
		}
	}

	// Forward focus from host node to selected window
	//if (is_focused && g.NavWindow == host_window && !g.NavWindowingTarget)
	//    focus_tab_id = tab_bar->SelectedTabId;

	// When clicked on a tab we requested focus to the docked child
	// This overrides the value set by "forward focus from host node to selected window".
	if tab_bar.NextSelectedTabId != 0 { focus_tab_id = tab_bar.NextSelectedTabId }

	// Apply navigation focus
	if focus_tab_id != 0 { if tab : ^ImGuiTabItem = TabBarFindTabByID(tab_bar, focus_tab_id); tab != nil { if tab.Window != nil {
	FocusWindow(tab.Window)
	NavInitWindow(tab.Window, false)
} } }

	EndTabBar()
	PopID()

	// Restore SkipItems flag
	if !IsDockSpace(node) {
		host_window.DC.NavLayerCurrent = ImGuiNavLayer.ImGuiNavLayer_Main
		host_window.SkipItems = backup_skip_item
	}
}

DockNodeAddTabBar :: proc(node : ^ImGuiDockNode)
{
	IM_ASSERT(node.TabBar == nil)
	node.TabBar = IM_NEW(ImGuiTabBar)
}

DockNodeRemoveTabBar :: proc(node : ^ImGuiDockNode)
{
	if node.TabBar == nil { return }
	IM_DELETE(node.TabBar)
	node.TabBar = nil
}

DockNodeIsDropAllowedOne :: proc(payload : ^ImGuiWindow, host_window : ^ImGuiWindow) -> bool
{
	if host_window.DockNodeAsHost != nil && IsDockSpace(host_window.DockNodeAsHost) && payload.BeginOrderWithinContext < host_window.BeginOrderWithinContext { return false }

	host_class : ^ImGuiWindowClass = host_window.DockNodeAsHost != nil ? &host_window.DockNodeAsHost.WindowClass : &host_window.WindowClass
	payload_class : ^ImGuiWindowClass = &payload.WindowClass
	if host_class.ClassId != payload_class.ClassId {
		pass : bool = false
		if host_class.ClassId != 0 && host_class.DockingAllowUnclassed && payload_class.ClassId == 0 { pass = true }
		if payload_class.ClassId != 0 && payload_class.DockingAllowUnclassed && host_class.ClassId == 0 { pass = true }
		if !pass { return false }
	}

	// Prevent docking any window created above a popup
	// Technically we should support it (e.g. in the case of a long-lived modal window that had fancy docking features),
	// by e.g. adding a 'if (!ImGui::IsWindowWithinBeginStackOf(host_window, popup_window))' test.
	// But it would requires more work on our end because the dock host windows is technically created in NewFrame()
	// and our ->ParentXXX and ->RootXXX pointers inside windows are currently mislading or lacking.
	g : ^ImGuiContext = GImGui
	for i : i32 = g.OpenPopupStack.Size - 1; i >= 0; i -= 1 {
		if popup_window : ^ImGuiWindow = g.OpenPopupStack.Data[i].Window; popup_window != nil {
			if IsWindowWithinBeginStackOf(payload, popup_window) {
				// Payload is created from within a popup begin stack.
				return false
			}
		}
	}

	return true
}

DockNodeIsDropAllowed :: proc(host_window : ^ImGuiWindow, root_payload : ^ImGuiWindow) -> bool
{
	if root_payload.DockNodeAsHost != nil && IsSplitNode(root_payload.DockNodeAsHost) {
		// FIXME-DOCK: Missing filtering
		return true
	}

	payload_count : i32 = root_payload.DockNodeAsHost != nil ? root_payload.DockNodeAsHost.Windows.Size : 1
	for payload_n : i32 = 0; payload_n < payload_count; payload_n += 1 {
		payload : ^ImGuiWindow = root_payload.DockNodeAsHost != nil ? root_payload.DockNodeAsHost.Windows.Data[payload_n] : root_payload
		if DockNodeIsDropAllowedOne(payload, host_window) { return true }
	}

	return false
}

// window menu button == collapse button when not in a dock node.
// FIXME: This is similar to RenderWindowTitleBarContents(), may want to share code.
DockNodeCalcTabBarLayout :: proc(node : ^ImGuiDockNode, out_title_rect : ^ImRect, out_tab_bar_rect : ^ImRect, out_window_menu_button_pos : ^ImVec2, out_close_button_pos : ^ImVec2)
{
	g : ^ImGuiContext = GImGui
	style : ^ImGuiStyle = &g.Style

	r : ImRect = ImRect{node.Pos.xy, {node.Pos.x + node.Size.x, node.Pos.y + g.FontSize + g.Style.FramePadding.y * 2.0}}
	if out_title_rect != nil { out_title_rect^ = r }

	r.Min.x += style.WindowBorderSize
	r.Max.x -= style.WindowBorderSize

	button_sz : f32 = g.FontSize
	r.Min.x += style.FramePadding.x
	r.Max.x -= style.FramePadding.x
	window_menu_button_pos : ImVec2 = ImVec2{r.Min.x, r.Min.y + style.FramePadding.y}
	if node.HasCloseButton {
		if out_close_button_pos != nil { out_close_button_pos^ = ImVec2{r.Max.x - button_sz, r.Min.y + style.FramePadding.y} }
		r.Max.x -= button_sz + style.ItemInnerSpacing.x
	}
	if node.HasWindowMenuButton && style.WindowMenuButtonPosition == ImGuiDir.ImGuiDir_Left {
		r.Min.x += button_sz + style.ItemInnerSpacing.x
	}
	else if node.HasWindowMenuButton && style.WindowMenuButtonPosition == ImGuiDir.ImGuiDir_Right {
		window_menu_button_pos = ImVec2{r.Max.x - button_sz, r.Min.y + style.FramePadding.y}
		r.Max.x -= button_sz + style.ItemInnerSpacing.x
	}
	if out_tab_bar_rect != nil { out_tab_bar_rect^ = r }
	if out_window_menu_button_pos != nil { out_window_menu_button_pos^ = window_menu_button_pos }
}

DockNodeCalcSplitRects :: proc(pos_old : ^ImVec2, size_old : ^ImVec2, pos_new : ^ImVec2, size_new : ^ImVec2, dir : ImGuiDir, size_new_desired : ImVec2)
{
	g : ^ImGuiContext = GImGui
	dock_spacing : f32 = g.Style.ItemInnerSpacing.x
	axis : ImGuiAxis = (dir == ImGuiDir.ImGuiDir_Left || dir == ImGuiDir.ImGuiDir_Right) ? ImGuiAxis.ImGuiAxis_X : ImGuiAxis.ImGuiAxis_Y
	pos_new[cast(i32)axis ~ 1] = pos_old[cast(i32)axis ~ 1]
	size_new[cast(i32)axis ~ 1] = size_old[cast(i32)axis ~ 1]

	// Distribute size on given axis (with a desired size or equally)
	w_avail : f32 = size_old[axis] - dock_spacing
	if size_new_desired[axis] > 0.0 && size_new_desired[axis] <= w_avail * 0.5 {
		size_new[axis] = size_new_desired[axis]
		size_old[axis] = IM_TRUNC(w_avail - size_new[axis])
	}
	else {
		size_new[axis] = IM_TRUNC(w_avail * 0.5)
		size_old[axis] = IM_TRUNC(w_avail - size_new[axis])
	}

	// Position each node
	if dir == ImGuiDir.ImGuiDir_Right || dir == ImGuiDir.ImGuiDir_Down {
		pos_new[axis] = pos_old[axis] + size_old[axis] + dock_spacing
	}
	else if dir == ImGuiDir.ImGuiDir_Left || dir == ImGuiDir.ImGuiDir_Up {
		pos_new[axis] = pos_old[axis]
		pos_old[axis] = pos_new[axis] + size_new[axis] + dock_spacing
	}
}

// Retrieve the drop rectangles for a given direction or for the center + perform hit testing.
DockNodeCalcDropRectsAndTestMousePos :: proc(parent : ImRect, dir : ImGuiDir, out_r : ^ImRect, outer_docking : bool, test_mouse_pos : ^ImVec2) -> bool
{
	g : ^ImGuiContext = GImGui

	parent_smaller_axis : f32 = ImMin(GetWidth(parent), GetHeight(parent))
	hs_for_central_nodes : f32 = ImMin(g.FontSize * 1.5, ImMax(g.FontSize * 0.5, parent_smaller_axis / 8.0))
	hs_w : f32; // Half-size, longer axis
	hs_h : f32; // Half-size, smaller axis
	off : ImVec2; // Distance from edge or center
	if outer_docking {
		//hs_w = ImTrunc(ImClamp(parent_smaller_axis - hs_for_central_nodes * 4.0f, g.FontSize * 0.5f, g.FontSize * 8.0f));
		//hs_h = ImTrunc(hs_w * 0.15f);
		//off = ImVec2(ImTrunc(parent.GetWidth() * 0.5f - GetFrameHeightWithSpacing() * 1.4f - hs_h), ImTrunc(parent.GetHeight() * 0.5f - GetFrameHeightWithSpacing() * 1.4f - hs_h));
		hs_w = ImTrunc(hs_for_central_nodes * 1.50)
		hs_h = ImTrunc(hs_for_central_nodes * 0.80)
		off = ImTrunc(ImVec2{GetWidth(parent) * 0.5 - hs_h, GetHeight(parent) * 0.5 - hs_h})
	}
	else {
		hs_w = ImTrunc(hs_for_central_nodes)
		hs_h = ImTrunc(hs_for_central_nodes * 0.90)
		off = ImTrunc(ImVec2{hs_w * 2.40, hs_w * 2.40})
	}

	c : ImVec2 = ImTrunc(GetCenter(parent))
	if dir == ImGuiDir.ImGuiDir_None { out_r^ = ImRect{{c.x - hs_w, c.y - hs_w}, {c.x + hs_w, c.y + hs_w} }}
	else if dir == ImGuiDir.ImGuiDir_Up { out_r^ = ImRect{{c.x - hs_w, c.y - off.y - hs_h}, {c.x + hs_w, c.y - off.y + hs_h}} }
	else if dir == ImGuiDir.ImGuiDir_Down { out_r^ = ImRect{{c.x - hs_w, c.y + off.y - hs_h}, {c.x + hs_w, c.y + off.y + hs_h} }}
	else if dir == ImGuiDir.ImGuiDir_Left { out_r^ = ImRect{{c.x - off.x - hs_h, c.y - hs_w}, {c.x - off.x + hs_h, c.y + hs_w} }}
	else if dir == ImGuiDir.ImGuiDir_Right { out_r^ = ImRect{{c.x + off.x - hs_h, c.y - hs_w}, {c.x + off.x + hs_h, c.y + hs_w} }}

	if test_mouse_pos == nil { return false }

	hit_r : ImRect = out_r^
	if !outer_docking {
		// Custom hit testing for the 5-way selection, designed to reduce flickering when moving diagonally between sides
		Expand(&hit_r, ImTrunc(hs_w * 0.30))
		mouse_delta : ImVec2 = (test_mouse_pos^ - c)
		mouse_delta_len2 : f32 = ImLengthSqr(mouse_delta)
		r_threshold_center : f32 = hs_w * 1.4
		r_threshold_sides : f32 = hs_w * (1.4 + 1.2)
		if mouse_delta_len2 < r_threshold_center * r_threshold_center { return (dir == ImGuiDir.ImGuiDir_None) }
		if mouse_delta_len2 < r_threshold_sides * r_threshold_sides { return (dir == ImGetDirQuadrantFromDelta(mouse_delta.x, mouse_delta.y)) }
	}
	return Contains(hit_r, test_mouse_pos^)
}

// host_node may be NULL if the window doesn't have a DockNode already.
// FIXME-DOCK: This is misnamed since it's also doing the filtering.
DockNodePreviewDockSetup :: proc(host_window : ^ImGuiWindow, host_node : ^ImGuiDockNode, payload_window : ^ImGuiWindow, payload_node : ^ImGuiDockNode, data : ^ImGuiDockPreviewData, is_explicit_target : bool, is_outer_docking : bool)
{
	g : ^ImGuiContext = GImGui

	payload_node := payload_node
	// There is an edge case when docking into a dockspace which only has inactive nodes.
	// In this case DockNodeTreeFindNodeByPos() will have selected a leaf node which is inactive.
	// Because the inactive leaf node doesn't have proper pos/size yet, we'll use the root node as reference.
	if payload_node == nil { payload_node = payload_window.DockNodeAsHost }
	ref_node_for_rect : ^ImGuiDockNode = (host_node != nil && !host_node.IsVisible) ? DockNodeGetRootNode(host_node) : host_node
	if ref_node_for_rect != nil { IM_ASSERT(ref_node_for_rect.IsVisible == true) }

	// Filter, figure out where we are allowed to dock
	src_node_flags : ImGuiDockNodeFlags = payload_node != nil ? payload_node.MergedFlags : payload_window.WindowClass.DockNodeFlagsOverrideSet
	dst_node_flags : ImGuiDockNodeFlags = host_node != nil ? host_node.MergedFlags : host_window.WindowClass.DockNodeFlagsOverrideSet
	data.IsCenterAvailable = true
	if is_outer_docking { data.IsCenterAvailable = false }
	else if (dst_node_flags & cast(ImGuiDockNodeFlags) ImGuiDockNodeFlagsPrivate_.ImGuiDockNodeFlags_NoDockingOverMe) != {} { data.IsCenterAvailable = false }
	else if host_node != nil && (dst_node_flags & ImGuiDockNodeFlags_.ImGuiDockNodeFlags_NoDockingOverCentralNode) != {} && IsCentralNode(host_node) { data.IsCenterAvailable = false }
	else if (host_node == nil || !IsEmpty(host_node)) && payload_node != nil && IsSplitNode(payload_node) && (payload_node.OnlyNodeWithWindows == nil) {
		// Is _visibly_ split?
		data.IsCenterAvailable = false
	}
	else if (src_node_flags & cast(ImGuiDockNodeFlags) ImGuiDockNodeFlagsPrivate_.ImGuiDockNodeFlags_NoDockingOverOther) != {} && (host_node == nil || !IsEmpty(host_node)) { data.IsCenterAvailable = false }
	else if (src_node_flags & cast(ImGuiDockNodeFlags) ImGuiDockNodeFlagsPrivate_.ImGuiDockNodeFlags_NoDockingOverEmpty) != {} && host_node != nil && IsEmpty(host_node) { data.IsCenterAvailable = false }

	data.IsSidesAvailable = true
	if (dst_node_flags & ImGuiDockNodeFlags_.ImGuiDockNodeFlags_NoDockingSplit) != {} || g.IO.ConfigDockingNoSplit { data.IsSidesAvailable = false }
	else if !is_outer_docking && host_node != nil && host_node.ParentNode == nil && IsCentralNode(host_node) { data.IsSidesAvailable = false }
	else if (src_node_flags & cast(ImGuiDockNodeFlags) ImGuiDockNodeFlagsPrivate_.ImGuiDockNodeFlags_NoDockingSplitOther) != {} { data.IsSidesAvailable = false }

	// Build a tentative future node (reuse same structure because it is practical. Shape will be readjusted when previewing a split)
	data.FutureNode.HasCloseButton = (host_node != nil ? host_node.HasCloseButton : host_window.HasCloseButton) || (payload_window.HasCloseButton)
	data.FutureNode.HasWindowMenuButton = host_node != nil ? true : ((host_window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoCollapse) == {})
	data.FutureNode.Pos = ref_node_for_rect != nil ? ref_node_for_rect.Pos : host_window.Pos
	data.FutureNode.Size = ref_node_for_rect != nil ? ref_node_for_rect.Size : host_window.Size

	// Calculate drop shapes geometry for allowed splitting directions
	IM_ASSERT(ImGuiDir.ImGuiDir_None == cast(ImGuiDir)-1)
	data.SplitNode = host_node
	data.SplitDir = ImGuiDir.ImGuiDir_None
	data.IsSplitDirExplicit = false
	if !host_window.Collapsed { for dir := ImGuiDir.ImGuiDir_None; dir < ImGuiDir.ImGuiDir_COUNT; dir += cast(ImGuiDir)1 {
	if dir == ImGuiDir.ImGuiDir_None && !data.IsCenterAvailable { continue }
	if dir != ImGuiDir.ImGuiDir_None && !data.IsSidesAvailable { continue }
	if DockNodeCalcDropRectsAndTestMousePos(Rect(&data.FutureNode), cast(ImGuiDir) dir, &data.DropRectsDraw[cast(i32)dir + 1], is_outer_docking, &g.IO.MousePos) {
		data.SplitDir = cast(ImGuiDir) dir
		data.IsSplitDirExplicit = true
	}
} }

	// When docking without holding Shift, we only allow and preview docking when hovering over a drop rect or over the title bar
	data.IsDropAllowed = (data.SplitDir != ImGuiDir.ImGuiDir_None) || (data.IsCenterAvailable)
	if !is_explicit_target && !data.IsSplitDirExplicit && !g.IO.ConfigDockingWithShift { data.IsDropAllowed = false }

	// Calculate split area
	data.SplitRatio = 0.0
	if data.SplitDir != ImGuiDir.ImGuiDir_None {
		split_dir : ImGuiDir = data.SplitDir
		split_axis : ImGuiAxis = (split_dir == ImGuiDir.ImGuiDir_Left || split_dir == ImGuiDir.ImGuiDir_Right) ? ImGuiAxis.ImGuiAxis_X : ImGuiAxis.ImGuiAxis_Y
		pos_new : ImVec2; pos_old : ImVec2 = data.FutureNode.Pos
		size_new : ImVec2; size_old : ImVec2 = data.FutureNode.Size
		DockNodeCalcSplitRects(&pos_old, &size_old, &pos_new, &size_new, split_dir, payload_window.Size)

		// Calculate split ratio so we can pass it down the docking request
		split_ratio : f32 = ImSaturate(size_new[split_axis] / data.FutureNode.Size[split_axis])
		data.FutureNode.Pos = pos_new
		data.FutureNode.Size = size_new
		data.SplitRatio = (split_dir == ImGuiDir.ImGuiDir_Right || split_dir == ImGuiDir.ImGuiDir_Down) ? (1.0 - split_ratio) : (split_ratio)
	}
}

DockNodePreviewDockRender :: proc(host_window : ^ImGuiWindow, host_node : ^ImGuiDockNode, root_payload : ^ImGuiWindow, data : ^ImGuiDockPreviewData)
{
	g : ^ImGuiContext = GImGui
	IM_ASSERT(g.CurrentWindow == host_window); // Because we rely on font size to calculate tab sizes

	// With this option, we only display the preview on the target viewport, and the payload viewport is made transparent.
	// To compensate for the single layer obstructed by the payload, we'll increase the alpha of the preview nodes.
	is_transparent_payload : bool = g.IO.ConfigDockingTransparentPayload

	// In case the two windows involved are on different viewports, we will draw the overlay on each of them.
	overlay_draw_lists_count : i32 = 0
	overlay_draw_lists : [2]^ImDrawList
	overlay_draw_lists[post_incr(&overlay_draw_lists_count)] = GetForegroundDrawList(host_window.Viewport)
	if host_window.Viewport != root_payload.Viewport && !is_transparent_payload { overlay_draw_lists[post_incr(&overlay_draw_lists_count)] = GetForegroundDrawList(root_payload.Viewport) }

	// Draw main preview rectangle
	overlay_col_main : ImU32 = GetColorU32(ImGuiCol_.ImGuiCol_DockingPreview, is_transparent_payload ? 0.60 : 0.40)
	overlay_col_drop : ImU32 = GetColorU32(ImGuiCol_.ImGuiCol_DockingPreview, is_transparent_payload ? 0.90 : 0.70)
	overlay_col_drop_hovered : ImU32 = GetColorU32(ImGuiCol_.ImGuiCol_DockingPreview, is_transparent_payload ? 1.20 : 1.00)
	overlay_col_lines : ImU32 = GetColorU32(ImGuiCol_.ImGuiCol_NavWindowingHighlight, is_transparent_payload ? 0.80 : 0.60)

	// Display area preview
	can_preview_tabs : bool = (root_payload.DockNodeAsHost == nil || root_payload.DockNodeAsHost.Windows.Size > 0)
	if data.IsDropAllowed {
		overlay_rect : ImRect = Rect(&data.FutureNode)
		if data.SplitDir == ImGuiDir.ImGuiDir_None && can_preview_tabs { overlay_rect.Min.y += GetFrameHeight() }
		if data.SplitDir != ImGuiDir.ImGuiDir_None || data.IsCenterAvailable { for overlay_n : i32 = 0; overlay_n < overlay_draw_lists_count; overlay_n += 1 { AddRectFilled(overlay_draw_lists[overlay_n], overlay_rect.Min, overlay_rect.Max, overlay_col_main, host_window.WindowRounding, CalcRoundingFlagsForRectInRect(overlay_rect, Rect(host_window), g.Style.DockingSeparatorSize)) } }
	}

	// Display tab shape/label preview unless we are splitting node (it generally makes the situation harder to read)
	if data.IsDropAllowed && can_preview_tabs && data.SplitDir == ImGuiDir.ImGuiDir_None && data.IsCenterAvailable {
		// Compute target tab bar geometry so we can locate our preview tabs
		tab_bar_rect : ImRect
		DockNodeCalcTabBarLayout(&data.FutureNode, nil, &tab_bar_rect, nil, nil)
		tab_pos : ImVec2 = tab_bar_rect.Min
		if host_node != nil && host_node.TabBar != nil {
			if !IsHiddenTabBar(host_node) && !IsNoTabBar(host_node) {
				// We don't use OffsetNewTab because when using non-persistent-order tab bar it is incremented with each Tab submission.
				tab_pos.x += host_node.TabBar.WidthAllTabs + g.Style.ItemInnerSpacing.x
			}
			else { tab_pos.x += g.Style.ItemInnerSpacing.x + TabItemCalcSize(host_node.Windows.Data[0]).x }
		}
		else if (host_window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_DockNodeHost) == {} {
			tab_pos.x += g.Style.ItemInnerSpacing.x + TabItemCalcSize(host_window).x; // Account for slight offset which will be added when changing from title bar to tab bar
		}

		// Draw tab shape/label preview (payload may be a loose window or a host window carrying multiple tabbed windows)
		if root_payload.DockNodeAsHost != nil { IM_ASSERT(root_payload.DockNodeAsHost.Windows.Size <= root_payload.DockNodeAsHost.TabBar.Tabs.Size) }
		tab_bar_with_payload : ^ImGuiTabBar = root_payload.DockNodeAsHost != nil ? root_payload.DockNodeAsHost.TabBar : nil
		payload_count : i32 = tab_bar_with_payload != nil ? tab_bar_with_payload.Tabs.Size : 1
		for payload_n : i32 = 0; payload_n < payload_count; payload_n += 1 {
			// DockNode's TabBar may have non-window Tabs manually appended by user
			payload_window : ^ImGuiWindow = tab_bar_with_payload != nil ? tab_bar_with_payload.Tabs.Data[payload_n].Window : root_payload
			if tab_bar_with_payload != nil && payload_window == nil { continue }
			if !DockNodeIsDropAllowedOne(payload_window, host_window) { continue }

			// Calculate the tab bounding box for each payload window
			tab_size : ImVec2 = TabItemCalcSize(payload_window)
			tab_bb : ImRect; init(&tab_bb, tab_pos.x, tab_pos.y, tab_pos.x + tab_size.x, tab_pos.y + tab_size.y)
			tab_pos.x += tab_size.x + g.Style.ItemInnerSpacing.x
			overlay_col_text : ImU32 = GetColorU32(payload_window.DockStyle.Colors[ImGuiWindowDockStyleCol.ImGuiWindowDockStyleCol_Text])
			overlay_col_tabs : ImU32 = GetColorU32(payload_window.DockStyle.Colors[ImGuiWindowDockStyleCol.ImGuiWindowDockStyleCol_TabSelected])
			PushStyleColor(ImGuiCol_.ImGuiCol_Text, overlay_col_text)
			for overlay_n : i32 = 0; overlay_n < overlay_draw_lists_count; overlay_n += 1 {
				tab_flags : ImGuiTabItemFlags = (payload_window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_UnsavedDocument) != {} ? ImGuiTabItemFlags_.ImGuiTabItemFlags_UnsavedDocument : {}
				if !Contains(tab_bar_rect, tab_bb) { PushClipRect(overlay_draw_lists[overlay_n], tab_bar_rect.Min, tab_bar_rect.Max) }
				TabItemBackground(overlay_draw_lists[overlay_n], tab_bb, tab_flags, overlay_col_tabs)
				TabItemLabelAndCloseButton(overlay_draw_lists[overlay_n], tab_bb, tab_flags, g.Style.FramePadding, payload_window.Name, 0, 0, false, nil, nil)
				if !Contains(tab_bar_rect, tab_bb) { PopClipRect(overlay_draw_lists[overlay_n]) }
			}

			PopStyleColor()
		}
	}

	// Display drop boxes
	overlay_rounding : f32 = ImMax(f32(3.0), g.Style.FrameRounding)
	for dir := ImGuiDir.ImGuiDir_None; dir < ImGuiDir.ImGuiDir_COUNT; dir += ImGuiDir(1) {
		if !IsInverted(data.DropRectsDraw[dir + ImGuiDir(1)])  {
			draw_r : ImRect = data.DropRectsDraw[dir + ImGuiDir(1)]
			draw_r_in : ImRect = draw_r
			Expand(&draw_r_in, -2.0)
			overlay_col : ImU32 = (data.SplitDir == cast(ImGuiDir) dir && data.IsSplitDirExplicit) ? overlay_col_drop_hovered : overlay_col_drop
			for overlay_n : i32 = 0; overlay_n < overlay_draw_lists_count; overlay_n += 1 {
				center : ImVec2 = ImFloor(GetCenter(draw_r_in))
				AddRectFilled(overlay_draw_lists[overlay_n], draw_r.Min, draw_r.Max, overlay_col, overlay_rounding)
				AddRect(overlay_draw_lists[overlay_n], draw_r_in.Min, draw_r_in.Max, overlay_col_lines, overlay_rounding)
				if dir == ImGuiDir.ImGuiDir_Left || dir == ImGuiDir.ImGuiDir_Right { AddLine(overlay_draw_lists[overlay_n], ImVec2{center.x, draw_r_in.Min.y}, ImVec2{center.x, draw_r_in.Max.y}, overlay_col_lines) }
				if dir == ImGuiDir.ImGuiDir_Up || dir == ImGuiDir.ImGuiDir_Down { AddLine(overlay_draw_lists[overlay_n], ImVec2{draw_r_in.Min.x, center.y}, ImVec2{draw_r_in.Max.x, center.y}, overlay_col_lines) }
			}
		}

		// Stop after ImGuiDir_None
		if (host_node != nil && (host_node.MergedFlags & ImGuiDockNodeFlags_.ImGuiDockNodeFlags_NoDockingSplit) != {}) || g.IO.ConfigDockingNoSplit { return }
	}
}

// ImGuiDockNode tree manipulations
//-----------------------------------------------------------------------------
// Docking: ImGuiDockNode Tree manipulation functions
//-----------------------------------------------------------------------------
// - DockNodeTreeSplit()
// - DockNodeTreeMerge()
// - DockNodeTreeUpdatePosSize()
// - DockNodeTreeUpdateSplitterFindTouchingNode()
// - DockNodeTreeUpdateSplitter()
// - DockNodeTreeFindFallbackLeafNode()
// - DockNodeTreeFindNodeByPos()
//-----------------------------------------------------------------------------

DockNodeTreeSplit :: proc(ctx : ^ImGuiContext, parent_node : ^ImGuiDockNode, split_axis : ImGuiAxis, split_inheritor_child_idx : i32, split_ratio : f32, new_node : ^ImGuiDockNode)
{
	g : ^ImGuiContext = GImGui
	IM_ASSERT(split_axis != ImGuiAxis.ImGuiAxis_None)

	child_0 : ^ImGuiDockNode = (new_node != nil && split_inheritor_child_idx != 0) ? new_node : DockContextAddNode(ctx, 0)
	child_0.ParentNode = parent_node

	child_1 : ^ImGuiDockNode = (new_node != nil && split_inheritor_child_idx != 1) ? new_node : DockContextAddNode(ctx, 0)
	child_1.ParentNode = parent_node

	child_inheritor : ^ImGuiDockNode = (split_inheritor_child_idx == 0) ? child_0 : child_1
	DockNodeMoveChildNodes(child_inheritor, parent_node)
	parent_node.ChildNodes[0] = child_0
	parent_node.ChildNodes[1] = child_1
	parent_node.ChildNodes[split_inheritor_child_idx].VisibleWindow = parent_node.VisibleWindow
	parent_node.SplitAxis = split_axis
	parent_node.VisibleWindow = nil
	parent_node.AuthorityForSize = ImGuiDataAuthority_.ImGuiDataAuthority_DockNode; parent_node.AuthorityForPos = parent_node.AuthorityForSize

	size_avail : f32 = (parent_node.Size[split_axis] - g.Style.DockingSeparatorSize)
	size_avail = ImMax(size_avail, g.Style.WindowMinSize[split_axis] * 2.0)
	IM_ASSERT(size_avail > 0.0); // If you created a node manually with DockBuilderAddNode(), you need to also call DockBuilderSetNodeSize() before splitting.
	child_1.SizeRef = parent_node.Size; child_0.SizeRef = child_1.SizeRef
	child_0.SizeRef[split_axis] = ImTrunc(size_avail * split_ratio)
	child_1.SizeRef[split_axis] = ImTrunc(size_avail - child_0.SizeRef[split_axis])

	DockNodeMoveWindows(parent_node.ChildNodes[split_inheritor_child_idx], parent_node)
	DockSettingsRenameNodeReferences(parent_node.ID, parent_node.ChildNodes[split_inheritor_child_idx].ID)
	DockNodeUpdateHasCentralNodeChild(DockNodeGetRootNode(parent_node))
	DockNodeTreeUpdatePosSize(parent_node, parent_node.Pos, parent_node.Size)

	// Flags transfer (e.g. this is where we transfer the ImGuiDockNodeFlags_CentralNode property)
	child_0.SharedFlags = parent_node.SharedFlags & cast(ImGuiDockNodeFlags) ImGuiDockNodeFlagsPrivate_.ImGuiDockNodeFlags_SharedFlagsInheritMask_
	child_1.SharedFlags = parent_node.SharedFlags & cast(ImGuiDockNodeFlags) ImGuiDockNodeFlagsPrivate_.ImGuiDockNodeFlags_SharedFlagsInheritMask_
	child_inheritor.LocalFlags = parent_node.LocalFlags & cast(ImGuiDockNodeFlags) ImGuiDockNodeFlagsPrivate_.ImGuiDockNodeFlags_LocalFlagsTransferMask_
	parent_node.LocalFlags &= cast(ImGuiDockNodeFlags)~cast(i32)ImGuiDockNodeFlagsPrivate_.ImGuiDockNodeFlags_LocalFlagsTransferMask_
	UpdateMergedFlags(child_0)
	UpdateMergedFlags(child_1)
	UpdateMergedFlags(parent_node)
	if IsCentralNode(child_inheritor) { DockNodeGetRootNode(parent_node).CentralNode = child_inheritor }
}

DockNodeTreeMerge :: proc(ctx : ^ImGuiContext, parent_node : ^ImGuiDockNode, merge_lead_child : ^ImGuiDockNode)
{
	// When called from DockContextProcessUndockNode() it is possible that one of the child is NULL.
	g : ^ImGuiContext = GImGui
	child_0 : ^ImGuiDockNode = parent_node.ChildNodes[0]
	child_1 : ^ImGuiDockNode = parent_node.ChildNodes[1]
	IM_ASSERT(child_0 != nil || child_1 != nil)
	IM_ASSERT(merge_lead_child == child_0 || merge_lead_child == child_1)
	if (child_0 != nil && child_0.Windows.Size > 0) || (child_1 != nil && child_1.Windows.Size > 0) {
		IM_ASSERT(parent_node.TabBar == nil)
		IM_ASSERT(parent_node.Windows.Size == 0)
	}
	IMGUI_DEBUG_LOG_DOCKING(g, "[docking] DockNodeTreeMerge: 0x%08X + 0x%08X back into parent 0x%08X\n", child_0 != nil ? child_0.ID : 0, child_1 != nil ? child_1.ID : 0, parent_node.ID)

	backup_last_explicit_size : ImVec2 = parent_node.SizeRef
	DockNodeMoveChildNodes(parent_node, merge_lead_child)
	if child_0 != nil {
		DockNodeMoveWindows(parent_node, child_0); // Generally only 1 of the 2 child node will have windows
		DockSettingsRenameNodeReferences(child_0.ID, parent_node.ID)
	}
	if child_1 != nil {
		DockNodeMoveWindows(parent_node, child_1)
		DockSettingsRenameNodeReferences(child_1.ID, parent_node.ID)
	}
	DockNodeApplyPosSizeToWindows(parent_node)
	parent_node.AuthorityForViewport = ImGuiDataAuthority_.ImGuiDataAuthority_Auto; parent_node.AuthorityForSize = parent_node.AuthorityForViewport; parent_node.AuthorityForPos = parent_node.AuthorityForSize
	parent_node.VisibleWindow = merge_lead_child.VisibleWindow
	parent_node.SizeRef = backup_last_explicit_size

	// Flags transfer
	parent_node.LocalFlags &= cast(ImGuiDockNodeFlags)~cast(i32)ImGuiDockNodeFlagsPrivate_.ImGuiDockNodeFlags_LocalFlagsTransferMask_; // Preserve Dockspace flag
	parent_node.LocalFlags |= (child_0 != nil ? child_0.LocalFlags : {}) & cast(ImGuiDockNodeFlags)ImGuiDockNodeFlagsPrivate_.ImGuiDockNodeFlags_LocalFlagsTransferMask_
	parent_node.LocalFlags |= (child_1 != nil ? child_1.LocalFlags : {}) & cast(ImGuiDockNodeFlags)ImGuiDockNodeFlagsPrivate_.ImGuiDockNodeFlags_LocalFlagsTransferMask_
	parent_node.LocalFlagsInWindows = (child_0 != nil ? child_0.LocalFlagsInWindows : {}) | (child_1 != nil ? child_1.LocalFlagsInWindows : {}); // FIXME: Would be more consistent to update from actual windows
	UpdateMergedFlags(parent_node)

	if child_0 != nil {
		SetVoidPtr(&ctx.DockContext.Nodes, child_0.ID, nil)
		IM_DELETE(child_0)
	}
	if child_1 != nil {
		SetVoidPtr(&ctx.DockContext.Nodes, child_1.ID, nil)
		IM_DELETE(child_1)
	}
}

// Update Pos/Size for a node hierarchy (don't affect child Windows yet)
// (Depth-first, Pre-Order)
DockNodeTreeUpdatePosSize :: proc(node : ^ImGuiDockNode, pos : ImVec2, size : ImVec2, only_write_to_single_node : ^ImGuiDockNode = nil)
{
	// During the regular dock node update we write to all nodes.
	// 'only_write_to_single_node' is only set when turning a node visible mid-frame and we need its size right-away.
	g : ^ImGuiContext = GImGui
	write_to_node : bool = only_write_to_single_node == nil || only_write_to_single_node == node
	if write_to_node {
		node.Pos = pos
		node.Size = size
	}

	if IsLeafNode(node) { return }

	child_0 : ^ImGuiDockNode = node.ChildNodes[0]
	child_1 : ^ImGuiDockNode = node.ChildNodes[1]
	child_0_pos : ImVec2 = pos; child_1_pos : ImVec2 = pos
	child_0_size : ImVec2 = size; child_1_size : ImVec2 = size

	child_0_is_toward_single_node : bool = (only_write_to_single_node != nil && DockNodeIsInHierarchyOf(only_write_to_single_node, child_0))
	child_1_is_toward_single_node : bool = (only_write_to_single_node != nil && DockNodeIsInHierarchyOf(only_write_to_single_node, child_1))
	child_0_is_or_will_be_visible : bool = child_0.IsVisible || child_0_is_toward_single_node
	child_1_is_or_will_be_visible : bool = child_1.IsVisible || child_1_is_toward_single_node

	if child_0_is_or_will_be_visible && child_1_is_or_will_be_visible {
		spacing : f32 = g.Style.DockingSeparatorSize
		axis : ImGuiAxis = cast(ImGuiAxis) node.SplitAxis
		size_avail : f32 = ImMax(size[axis] - spacing, 0.0)

		// Size allocation policy
		// 1) The first 0..WindowMinSize[axis]*2 are allocated evenly to both windows.
		size_min_each : f32 = ImTrunc(ImMin(size_avail, g.Style.WindowMinSize[axis] * 2.0) * 0.5)

		// FIXME: Blocks 2) and 3) are essentially doing nearly the same thing.
		// Difference are: write-back to SizeRef; application of a minimum size; rounding before ImTrunc()
		// Clarify and rework differences between Size & SizeRef and purpose of WantLockSizeOnce

		// 2) Process locked absolute size (during a splitter resize we preserve the child of nodes not touching the splitter edge)
		if child_0.WantLockSizeOnce && !child_1.WantLockSizeOnce {
			child_0.SizeRef[axis] = ImMin(size_avail - 1.0, child_0.Size[axis]); child_0_size[axis] = child_0.SizeRef[axis]
			child_1.SizeRef[axis] = (size_avail - child_0_size[axis]); child_1_size[axis] = child_1.SizeRef[axis]
			IM_ASSERT(child_0.SizeRef[axis] > 0.0 && child_1.SizeRef[axis] > 0.0)
		}
		else if child_1.WantLockSizeOnce && !child_0.WantLockSizeOnce {
			child_1.SizeRef[axis] = ImMin(size_avail - 1.0, child_1.Size[axis]); child_1_size[axis] = child_1.SizeRef[axis]
			child_0.SizeRef[axis] = (size_avail - child_1_size[axis]); child_0_size[axis] = child_0.SizeRef[axis]
			IM_ASSERT(child_0.SizeRef[axis] > 0.0 && child_1.SizeRef[axis] > 0.0)
		}
		else if child_0.WantLockSizeOnce && child_1.WantLockSizeOnce {
			// FIXME-DOCK: We cannot honor the requested size, so apply ratio.
			// Currently this path will only be taken if code programmatically sets WantLockSizeOnce
			split_ratio : f32 = child_0_size[axis] / (child_0_size[axis] + child_1_size[axis])
			child_0.SizeRef[axis] = ImTrunc(size_avail * split_ratio); child_0_size[axis] = child_0.SizeRef[axis]
			child_1.SizeRef[axis] = (size_avail - child_0_size[axis]); child_1_size[axis] = child_1.SizeRef[axis]
			IM_ASSERT(child_0.SizeRef[axis] > 0.0 && child_1.SizeRef[axis] > 0.0)
		}
		else if child_0.SizeRef[axis] != 0.0 && child_1.HasCentralNodeChild {
			// 3) If one window is the central node (~ use remaining space, should be made explicit!), use explicit size from the other, and remainder for the central node
			child_0_size[axis] = ImMin(size_avail - size_min_each, child_0.SizeRef[axis])
			child_1_size[axis] = (size_avail - child_0_size[axis])
		}
		else if child_1.SizeRef[axis] != 0.0 && child_0.HasCentralNodeChild {
			child_1_size[axis] = ImMin(size_avail - size_min_each, child_1.SizeRef[axis])
			child_0_size[axis] = (size_avail - child_1_size[axis])
		}
		else {
			// 4) Otherwise distribute according to the relative ratio of each SizeRef value
			split_ratio : f32 = child_0.SizeRef[axis] / (child_0.SizeRef[axis] + child_1.SizeRef[axis])
			child_0_size[axis] = ImMax(size_min_each, ImTrunc(size_avail * split_ratio + 0.5))
			child_1_size[axis] = (size_avail - child_0_size[axis])
		}

		child_1_pos[axis] += spacing + child_0_size[axis]
	}

	if only_write_to_single_node == nil { child_1.WantLockSizeOnce = false; child_0.WantLockSizeOnce = child_1.WantLockSizeOnce }

	child_0_recurse : bool = only_write_to_single_node != nil ? child_0_is_toward_single_node : child_0.IsVisible
	child_1_recurse : bool = only_write_to_single_node != nil ? child_1_is_toward_single_node : child_1.IsVisible
	if child_0_recurse { DockNodeTreeUpdatePosSize(child_0, child_0_pos, child_0_size) }
	if child_1_recurse { DockNodeTreeUpdatePosSize(child_1, child_1_pos, child_1_size) }
}

DockNodeTreeUpdateSplitterFindTouchingNode :: proc(node : ^ImGuiDockNode, axis : ImGuiAxis, side : i32, touching_nodes : ^ImVector(^ImGuiDockNode))
{
	if IsLeafNode(node) {
		push_back(touching_nodes, node)
		return
	}
	if node.ChildNodes[0].IsVisible { if node.SplitAxis != axis || side == 0 || !node.ChildNodes[1].IsVisible { DockNodeTreeUpdateSplitterFindTouchingNode(node.ChildNodes[0], axis, side, touching_nodes) } }
	if node.ChildNodes[1].IsVisible { if node.SplitAxis != axis || side == 1 || !node.ChildNodes[0].IsVisible { DockNodeTreeUpdateSplitterFindTouchingNode(node.ChildNodes[1], axis, side, touching_nodes) } }
}

// (Depth-First, Pre-Order)
DockNodeTreeUpdateSplitter :: proc(node : ^ImGuiDockNode)
{
	if IsLeafNode(node) { return }

	g : ^ImGuiContext = GImGui

	child_0 : ^ImGuiDockNode = node.ChildNodes[0]
	child_1 : ^ImGuiDockNode = node.ChildNodes[1]
	if child_0.IsVisible && child_1.IsVisible {
		// Bounding box of the splitter cover the space between both nodes (w = Spacing, h = Size[xy^1] for when splitting horizontally)
		axis : ImGuiAxis = cast(ImGuiAxis) node.SplitAxis
		IM_ASSERT(axis != ImGuiAxis.ImGuiAxis_None)
		bb : ImRect
		bb.Min = child_0.Pos
		bb.Max = child_1.Pos
		bb.Min[axis] += child_0.Size[axis]
		bb.Max[axis ~ ImGuiAxis(1)] += child_1.Size[axis ~ ImGuiAxis(1)]
		//if (g.IO.KeyCtrl) GetForegroundDrawList(g.CurrentWindow->Viewport)->AddRect(bb.Min, bb.Max, IM_COL32(255,0,255,255));

		merged_flags : ImGuiDockNodeFlags = child_0.MergedFlags | child_1.MergedFlags; // Merged flags for BOTH childs
		no_resize_axis_flag : ImGuiDockNodeFlags = ImGuiDockNodeFlags((axis == ImGuiAxis.ImGuiAxis_X) ? ImGuiDockNodeFlagsPrivate_.ImGuiDockNodeFlags_NoResizeX : ImGuiDockNodeFlagsPrivate_.ImGuiDockNodeFlags_NoResizeY)
		if (merged_flags & ImGuiDockNodeFlags_.ImGuiDockNodeFlags_NoResize) != {} || (merged_flags & no_resize_axis_flag) != {} {
			window : ^ImGuiWindow = g.CurrentWindow
			AddRectFilled(window.DrawList, bb.Min, bb.Max, GetColorU32(ImGuiCol_.ImGuiCol_Separator), g.Style.FrameRounding)
		}
		else {
			//bb.Min[axis] += 1; // Display a little inward so highlight doesn't connect with nearby tabs on the neighbor node.
			//bb.Max[axis] -= 1;
			PushID(cast(i32)node.ID)

			// Find resizing limits by gathering list of nodes that are touching the splitter line.
			touching_nodes : [2]ImVector(^ImGuiDockNode)
			min_size : f32 = g.Style.WindowMinSize[axis]
			resize_limits : [2]f32
			resize_limits[0] = node.ChildNodes[0].Pos[axis] + min_size
			resize_limits[1] = node.ChildNodes[1].Pos[axis] + node.ChildNodes[1].Size[axis] - min_size

			splitter_id : ImGuiID = GetID("##Splitter")
			if g.ActiveId == splitter_id {
				// Only process when splitter is active
				DockNodeTreeUpdateSplitterFindTouchingNode(child_0, axis, 1, &touching_nodes[0])
				DockNodeTreeUpdateSplitterFindTouchingNode(child_1, axis, 0, &touching_nodes[1])
				for touching_node_n : i32 = 0; touching_node_n < touching_nodes[0].Size; touching_node_n += 1 { resize_limits[0] = ImMax(resize_limits[0], Rect(touching_nodes[0].Data[touching_node_n]).Min[axis] + min_size) }

				for touching_node_n : i32 = 0; touching_node_n < touching_nodes[1].Size; touching_node_n += 1 { resize_limits[1] = ImMin(resize_limits[1], Rect(touching_nodes[1].Data[touching_node_n]).Max[axis] - min_size) }

				// [DEBUG] Render touching nodes & limits
				/*
                ImDrawList* draw_list = node->HostWindow ? GetForegroundDrawList(node->HostWindow) : GetForegroundDrawList(GetMainViewport());
                for (int n = 0; n < 2; n++)
                {
                    for (int touching_node_n = 0; touching_node_n < touching_nodes[n].Size; touching_node_n++)
                        draw_list->AddRect(touching_nodes[n][touching_node_n]->Pos, touching_nodes[n][touching_node_n]->Pos + touching_nodes[n][touching_node_n]->Size, IM_COL32(0, 255, 0, 255));
                    if (axis == ImGuiAxis_X)
                        draw_list->AddLine(ImVec2{resize_limits[n], node->ChildNodes[n]->Pos.y}, ImVec2{resize_limits[n], node->ChildNodes[n]->Pos.y + node->ChildNodes[n]->Size.y}, IM_COL32(255, 0, 255, 255), 3.0f);
                    else
                        draw_list->AddLine(ImVec2{node->ChildNodes[n]->Pos.x, resize_limits[n]}, ImVec2{node->ChildNodes[n]->Pos.x + node->ChildNodes[n]->Size.x, resize_limits[n]}, IM_COL32(255, 0, 255, 255), 3.0f);
                }
                */
			}

			// Use a short delay before highlighting the splitter (and changing the mouse cursor) in order for regular mouse movement to not highlight many splitters
			cur_size_0 : f32 = child_0.Size[axis]
			cur_size_1 : f32 = child_1.Size[axis]
			min_size_0 : f32 = resize_limits[0] - child_0.Pos[axis]
			min_size_1 : f32 = child_1.Pos[axis] + child_1.Size[axis] - resize_limits[1]
			bg_col : ImU32 = GetColorU32(ImGuiCol_.ImGuiCol_WindowBg)
			if SplitterBehavior(bb, GetID("##Splitter"), axis, &cur_size_0, &cur_size_1, min_size_0, min_size_1, WINDOWS_HOVER_PADDING, WINDOWS_RESIZE_FROM_EDGES_FEEDBACK_TIMER, bg_col) {
				if touching_nodes[0].Size > 0 && touching_nodes[1].Size > 0 {
					child_0.SizeRef[axis] = cur_size_0; child_0.Size[axis] = child_0.SizeRef[axis]
					child_1.Pos[axis] -= cur_size_1 - child_1.Size[axis]
					child_1.SizeRef[axis] = cur_size_1; child_1.Size[axis] = child_1.SizeRef[axis]

					// Lock the size of every node that is a sibling of the node we are touching
					// This might be less desirable if we can merge sibling of a same axis into the same parental level.
					for side_n : i32 = 0; side_n < 2; side_n += 1 { for touching_node_n : i32 = 0; touching_node_n < touching_nodes[side_n].Size; touching_node_n += 1 {
						touching_node : ^ImGuiDockNode = touching_nodes[side_n].Data[touching_node_n]
						//ImDrawList* draw_list = node->HostWindow ? GetForegroundDrawList(node->HostWindow) : GetForegroundDrawList(GetMainViewport());
						//draw_list->AddRect(touching_node->Pos, touching_node->Pos + touching_node->Size, IM_COL32(255, 128, 0, 255));
						for touching_node.ParentNode != node {
							if touching_node.ParentNode.SplitAxis == axis {
								// Mark other node so its size will be preserved during the upcoming call to DockNodeTreeUpdatePosSize().
								node_to_preserve : ^ImGuiDockNode = touching_node.ParentNode.ChildNodes[side_n]
								node_to_preserve.WantLockSizeOnce = true
								//draw_list->AddRect(touching_node->Pos, touching_node->Rect().Max, IM_COL32(255, 0, 0, 255));
								//draw_list->AddRectFilled(node_to_preserve->Pos, node_to_preserve->Rect().Max, IM_COL32(0, 255, 0, 100));
							}
							touching_node = touching_node.ParentNode
						}
					} }

					DockNodeTreeUpdatePosSize(child_0, child_0.Pos, child_0.Size)
					DockNodeTreeUpdatePosSize(child_1, child_1.Pos, child_1.Size)
					MarkIniSettingsDirty()
				}
			}
			PopID()
		}
	}

	if child_0.IsVisible { DockNodeTreeUpdateSplitter(child_0) }
	if child_1.IsVisible { DockNodeTreeUpdateSplitter(child_1) }
}

DockNodeTreeFindFallbackLeafNode :: proc(node : ^ImGuiDockNode) -> ^ImGuiDockNode
{
	if IsLeafNode(node) { return node }
	if leaf_node : ^ImGuiDockNode = DockNodeTreeFindFallbackLeafNode(node.ChildNodes[0]); leaf_node != nil { return leaf_node }
	if leaf_node : ^ImGuiDockNode = DockNodeTreeFindFallbackLeafNode(node.ChildNodes[1]); leaf_node != nil { return leaf_node }
	return nil
}

DockNodeTreeFindVisibleNodeByPos :: proc(node : ^ImGuiDockNode, pos : ImVec2) -> ^ImGuiDockNode
{
	if !node.IsVisible { return nil }

	dock_spacing : f32 = 0.0; // g.Style.ItemInnerSpacing.x; // FIXME: Relation to DOCKING_SPLITTER_SIZE?
	r : ImRect; init(&r, node.Pos, node.Pos + node.Size)
	Expand(&r, dock_spacing * 0.5)
	inside : bool = Contains(r, pos)
	if !inside { return nil }

	if IsLeafNode(node) { return node }
	if hovered_node : ^ImGuiDockNode = DockNodeTreeFindVisibleNodeByPos(node.ChildNodes[0], pos); hovered_node != nil { return hovered_node }
	if hovered_node : ^ImGuiDockNode = DockNodeTreeFindVisibleNodeByPos(node.ChildNodes[1], pos); hovered_node != nil { return hovered_node }

	// This means we are hovering over the splitter/spacing of a parent node
	return node
}

//-----------------------------------------------------------------------------
// Docking: Public Functions (SetWindowDock, DockSpace, DockSpaceOverViewport)
//-----------------------------------------------------------------------------
// - SetWindowDock() [Internal]
// - DockSpace()
// - DockSpaceOverViewport()
//-----------------------------------------------------------------------------

// [Internal] Called via SetNextWindowDockID()
SetWindowDock :: proc(window : ^ImGuiWindow, dock_id : ImGuiID, cond : ImGuiCond)
{
	dock_id := dock_id
	// Test condition (NB: bit 0 is always true) and clear flags for next time
	if cond != {} && (window.SetWindowDockAllowFlags & cond) == {} { return }
	window.SetWindowDockAllowFlags &= cast(ImGuiCond)~cast(i32)(ImGuiCond_.ImGuiCond_Once | ImGuiCond_.ImGuiCond_FirstUseEver | ImGuiCond_.ImGuiCond_Appearing)

	if window.DockId == dock_id { return }

	// If the user attempt to set a dock id that is a split node, we'll dig within to find a suitable docking spot
	g : ^ImGuiContext = GImGui
	if new_node : ^ImGuiDockNode = DockContextFindNodeByID(g, dock_id); new_node != nil { if IsSplitNode(new_node) {
	// Policy: Find central node or latest focused node. We first move back to our root node.
	new_node = DockNodeGetRootNode(new_node)
	if new_node.CentralNode != nil {
		IM_ASSERT(IsCentralNode(new_node.CentralNode))
		dock_id = new_node.CentralNode.ID
	}
	else {
		dock_id = new_node.LastFocusedNodeId
	}
} }

	if window.DockId == dock_id { return }

	if window.DockNode != nil { DockNodeRemoveWindow(window.DockNode, window, 0) }
	window.DockId = dock_id
}

// Docking
// [BETA API] Enable with io.ConfigFlags |= ImGuiConfigFlags_DockingEnable.
// Note: You can use most Docking facilities without calling any API. You DO NOT need to call DockSpace() to use Docking!
// - Drag from window title bar or their tab to dock/undock. Hold SHIFT to disable docking.
// - Drag from window menu button (upper-left button) to undock an entire node (all windows).
// - When io.ConfigDockingWithShift == true, you instead need to hold SHIFT to enable docking.
// About dockspaces:
// - Use DockSpaceOverViewport() to create a window covering the screen or a specific viewport + a dockspace inside it.
//   This is often used with ImGuiDockNodeFlags_PassthruCentralNode to make it transparent.
// - Use DockSpace() to create an explicit dock node _within_ an existing window. See Docking demo for details.
// - Important: Dockspaces need to be submitted _before_ any window they can host. Submit it early in your frame!
// - Important: Dockspaces need to be kept alive if hidden, otherwise windows docked into it will be undocked.
//   e.g. if you have multiple tabs with a dockspace inside each tab: submit the non-visible dockspaces with ImGuiDockNodeFlags_KeepAliveOnly.
// Create an explicit dockspace node within an existing window. Also expose dock node flags and creates a CentralNode by default.
// The Central Node is always displayed even when empty and shrink/extend according to the requested size of its neighbors.
// DockSpace() needs to be submitted _before_ any window they can host. If you use a dockspace, submit it early in your app.
// When ImGuiDockNodeFlags_KeepAliveOnly is set, nothing is submitted in the current window (function may be called from any location).
DockSpace :: proc(dockspace_id : ImGuiID, size_arg : ImVec2 = {}, flags : ImGuiDockNodeFlags = {}, window_class : ^ImGuiWindowClass = nil) -> ImGuiID
{
	g : ^ImGuiContext = GImGui
	window : ^ImGuiWindow = GetCurrentWindowRead()
	if (g.IO.ConfigFlags & ImGuiConfigFlags_.ImGuiConfigFlags_DockingEnable) == {} { return 0 }

	flags := flags
	// Early out if parent window is hidden/collapsed
	// This is faster but also DockNodeUpdateTabBar() relies on TabBarLayout() running (which won't if SkipItems=true) to set NextSelectedTabId = 0). See #2960.
	// If for whichever reason this is causing problem we would need to ensure that DockNodeUpdateTabBar() ends up clearing NextSelectedTabId even if SkipItems=true.
	if window.SkipItems { flags |= ImGuiDockNodeFlags_.ImGuiDockNodeFlags_KeepAliveOnly }
	if (flags & ImGuiDockNodeFlags_.ImGuiDockNodeFlags_KeepAliveOnly) == {} {
		// call to set window->WriteAccessed = true;
		window = GetCurrentWindow()
	}

	IM_ASSERT((flags & cast(ImGuiDockNodeFlags) ImGuiDockNodeFlagsPrivate_.ImGuiDockNodeFlags_DockSpace) == {}); // Flag is automatically set by DockSpace() as LocalFlags, not SharedFlags!
	IM_ASSERT((flags & cast(ImGuiDockNodeFlags) ImGuiDockNodeFlagsPrivate_.ImGuiDockNodeFlags_CentralNode) == {}); // Flag is automatically set by DockSpace() as LocalFlags, not SharedFlags! (#8145)

	IM_ASSERT(dockspace_id != 0)
	node : ^ImGuiDockNode = DockContextFindNodeByID(g, dockspace_id)
	if node == nil {
		IMGUI_DEBUG_LOG_DOCKING(g, "[docking] DockSpace: dockspace node 0x%08X created\n", dockspace_id)
		node = DockContextAddNode(g, dockspace_id)
		SetLocalFlags(node, cast(ImGuiDockNodeFlags)ImGuiDockNodeFlagsPrivate_.ImGuiDockNodeFlags_CentralNode)
	}
	if window_class != nil && window_class.ClassId != node.WindowClass.ClassId { IMGUI_DEBUG_LOG_DOCKING(g, "[docking] DockSpace: dockspace node 0x%08X: setup WindowClass 0x%08X -> 0x%08X\n", dockspace_id, node.WindowClass.ClassId, window_class.ClassId) }
	node.SharedFlags = flags
	if window_class != nil {
		node.WindowClass = window_class^
	}
	else {
		init(&node.WindowClass)
	}

	// When a DockSpace transitioned form implicit to explicit this may be called a second time
	// It is possible that the node has already been claimed by a docked window which appeared before the DockSpace() node, so we overwrite IsDockSpace again.
	if node.LastFrameActive == g.FrameCount && (flags & ImGuiDockNodeFlags_.ImGuiDockNodeFlags_KeepAliveOnly) == {} {
		IM_ASSERT(IsDockSpace(node) == false, "Cannot call DockSpace() twice a frame with the same ID")
		SetLocalFlags(node, node.LocalFlags | cast(ImGuiDockNodeFlags)ImGuiDockNodeFlagsPrivate_.ImGuiDockNodeFlags_DockSpace)
		return dockspace_id
	}
	SetLocalFlags(node, node.LocalFlags | cast(ImGuiDockNodeFlags)ImGuiDockNodeFlagsPrivate_.ImGuiDockNodeFlags_DockSpace)

	// Keep alive mode, this is allow windows docked into this node so stay docked even if they are not visible
	if (flags & ImGuiDockNodeFlags_.ImGuiDockNodeFlags_KeepAliveOnly) != {} {
		node.LastFrameAlive = g.FrameCount
		return dockspace_id
	}

	content_avail : ImVec2 = GetContentRegionAvail()
	size : ImVec2 = ImTrunc(size_arg)
	if size.x <= 0.0 {
		// Arbitrary minimum child size (0.0f causing too much issues)
		size.x = ImMax(content_avail.x + size.x, 4.0)
	}
	if size.y <= 0.0 { size.y = ImMax(content_avail.y + size.y, 4.0) }
	IM_ASSERT(size.x > 0.0 && size.y > 0.0)

	node.Pos = window.DC.CursorPos
	node.SizeRef = size; node.Size = node.SizeRef
	SetNextWindowPos(node.Pos)
	SetNextWindowSize(node.Size)
	g.NextWindowData.PosUndock = false

	// FIXME-DOCK: Why do we need a child window to host a dockspace, could we host it in the existing window?
	// FIXME-DOCK: What is the reason for not simply calling BeginChild()? (OK to have a reason but should be commented)
	window_flags : ImGuiWindowFlags = ImGuiWindowFlags_.ImGuiWindowFlags_ChildWindow | ImGuiWindowFlags_.ImGuiWindowFlags_DockNodeHost
	window_flags |= ImGuiWindowFlags_.ImGuiWindowFlags_NoSavedSettings | ImGuiWindowFlags_.ImGuiWindowFlags_NoResize | ImGuiWindowFlags_.ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_.ImGuiWindowFlags_NoTitleBar
	window_flags |= ImGuiWindowFlags_.ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_.ImGuiWindowFlags_NoScrollWithMouse
	window_flags |= ImGuiWindowFlags_.ImGuiWindowFlags_NoBackground

	title : [256]u8
	ImFormatString(title[:], "%s/DockSpace_%08X", window.Name, dockspace_id)

	PushStyleVar(ImGuiStyleVar_.ImGuiStyleVar_ChildBorderSize, 0.0)
	tit := string_from_slice(title[:])
	Begin(tit, nil, window_flags)
	PopStyleVar()

	host_window : ^ImGuiWindow = g.CurrentWindow
	DockNodeSetupHostWindow(node, host_window)
	host_window.ChildId = GetID(window, tit)
	node.OnlyNodeWithWindows = nil

	IM_ASSERT(IsRootNode(node))

	// We need to handle the rare case were a central node is missing.
	// This can happen if the node was first created manually with DockBuilderAddNode() but _without_ the ImGuiDockNodeFlags_Dockspace.
	// Doing it correctly would set the _CentralNode flags, which would then propagate according to subsequent split.
	// It would also be ambiguous to attempt to assign a central node while there are split nodes, so we wait until there's a single node remaining.
	// The specific sub-property of _CentralNode we are interested in recovering here is the "Don't delete when empty" property,
	// as it doesn't make sense for an empty dockspace to not have this property.
	if IsLeafNode(node) && !IsCentralNode(node) { SetLocalFlags(node, node.LocalFlags | cast(ImGuiDockNodeFlags)ImGuiDockNodeFlagsPrivate_.ImGuiDockNodeFlags_CentralNode) }

	// Update the node
	DockNodeUpdate(node)

	End()

	bb : ImRect; init(&bb, node.Pos, node.Pos + size)
	ItemSize(size)
	ItemAdd(bb, dockspace_id, nil, ImGuiItemFlags_.ImGuiItemFlags_NoNav); // Not a nav point (could be, would need to draw the nav rect and replicate/refactor activation from BeginChild(), but seems like CTRL+Tab works better here?)
	if (g.LastItemData.StatusFlags & ImGuiItemStatusFlags_.ImGuiItemStatusFlags_HoveredRect) != {} && IsWindowChildOf(g.HoveredWindow, host_window, false, true) {
		// To fullfill IsItemHovered(), similar to EndChild()
		g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_.ImGuiItemStatusFlags_HoveredWindow
	}

	return dockspace_id
}

// Tips: Use with ImGuiDockNodeFlags_PassthruCentralNode!
// The limitation with this call is that your window won't have a local menu bar, but you can also use BeginMainMenuBar().
// Even though we could pass window flags, it would also require the user to be able to call BeginMenuBar() somehow meaning we can't Begin/End in a single function.
// If you really want a menu bar inside the same window as the one hosting the dockspace, you will need to copy this code somewhere and tweak it.
DockSpaceOverViewport :: proc(dockspace_id : ImGuiID, viewport : ^ImGuiViewport, dockspace_flags : ImGuiDockNodeFlags, window_class : ^ImGuiWindowClass) -> ImGuiID
{
	viewport := viewport
	if viewport == nil { viewport = GetMainViewport() }

	// Submit a window filling the entire viewport
	SetNextWindowPos(viewport.WorkPos)
	SetNextWindowSize(viewport.WorkSize)
	SetNextWindowViewport(viewport.ID)

	host_window_flags : ImGuiWindowFlags = {}
	host_window_flags |= ImGuiWindowFlags_.ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_.ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_.ImGuiWindowFlags_NoResize | ImGuiWindowFlags_.ImGuiWindowFlags_NoMove | ImGuiWindowFlags_.ImGuiWindowFlags_NoDocking
	host_window_flags |= ImGuiWindowFlags_.ImGuiWindowFlags_NoBringToFrontOnFocus | ImGuiWindowFlags_.ImGuiWindowFlags_NoNavFocus
	if (dockspace_flags & ImGuiDockNodeFlags_.ImGuiDockNodeFlags_PassthruCentralNode) != {} { host_window_flags |= ImGuiWindowFlags_.ImGuiWindowFlags_NoBackground }

	// FIXME-OPT: When using ImGuiDockNodeFlags_KeepAliveOnly with DockSpaceOverViewport() we might be able to spare submitting the window,
	// since DockSpace() with that flag doesn't need a window. We'd only need to compute the default ID accordingly.
	if (dockspace_flags & ImGuiDockNodeFlags_.ImGuiDockNodeFlags_KeepAliveOnly) != {} { host_window_flags |= ImGuiWindowFlags_.ImGuiWindowFlags_NoMouseInputs }

	label : [32]u8
	ImFormatString(label[:], "WindowOverViewport_%08X", viewport.ID)

	PushStyleVar(ImGuiStyleVar_.ImGuiStyleVar_WindowRounding, 0.0)
	PushStyleVar(ImGuiStyleVar_.ImGuiStyleVar_WindowBorderSize, 0.0)
	PushStyleVar(ImGuiStyleVar_.ImGuiStyleVar_WindowPadding, ImVec2{0.0, 0.0})
	Begin(string_from_slice(label[:]), nil, host_window_flags)
	PopStyleVar(3)

	dockspace_id := dockspace_id
	// Submit the dockspace
	if dockspace_id == 0 { dockspace_id = GetID("DockSpace") }
	DockSpace(dockspace_id, ImVec2{0.0, 0.0}, dockspace_flags, window_class)

	End()

	return dockspace_id
}

// Docking - Builder function needs to be generally called before the node is used/submitted.
// - The DockBuilderXXX functions are designed to _eventually_ become a public API, but it is too early to expose it and guarantee stability.
// - Do not hold on ImGuiDockNode* pointers! They may be invalidated by any split/merge/remove operation and every frame.
// - To create a DockSpace() node, make sure to set the ImGuiDockNodeFlags_DockSpace flag when calling DockBuilderAddNode().
//   You can create dockspace nodes (attached to a window) _or_ floating nodes (carry its own window) with this API.
// - DockBuilderSplitNode() create 2 child nodes within 1 node. The initial node becomes a parent node.
// - If you intend to split the node immediately after creation using DockBuilderSplitNode(), make sure
//   to call DockBuilderSetNodeSize() beforehand. If you don't, the resulting split sizes may not be reliable.
// - Call DockBuilderFinish() after you are done.
//-----------------------------------------------------------------------------
// Docking: Builder Functions
//-----------------------------------------------------------------------------
// Very early end-user API to manipulate dock nodes.
// Only available in imgui_internal.h. Expect this API to change/break!
// It is expected that those functions are all called _before_ the dockspace node submission.
//-----------------------------------------------------------------------------
// - DockBuilderDockWindow()
// - DockBuilderGetNode()
// - DockBuilderSetNodePos()
// - DockBuilderSetNodeSize()
// - DockBuilderAddNode()
// - DockBuilderRemoveNode()
// - DockBuilderRemoveNodeChildNodes()
// - DockBuilderRemoveNodeDockedWindows()
// - DockBuilderSplitNode()
// - DockBuilderCopyNodeRec()
// - DockBuilderCopyNode()
// - DockBuilderCopyWindowSettings()
// - DockBuilderCopyDockSpace()
// - DockBuilderFinish()
//-----------------------------------------------------------------------------

DockBuilderDockWindow :: proc(window_name : string, node_id : ImGuiID)
{
	// We don't preserve relative order of multiple docked windows (by clearing DockOrder back to -1)
	g : ^ImGuiContext = GImGui; IM_UNUSED(g)
	IMGUI_DEBUG_LOG_DOCKING(g, "[docking] DockBuilderDockWindow '%s' to node 0x%08X\n", window_name, node_id)
	window_id : ImGuiID = ImHashStr(window_name)
	if window : ^ImGuiWindow = FindWindowByID(window_id); window != nil {
		// Apply to created window
		prev_node_id : ImGuiID = window.DockId
		SetWindowDock(window, node_id, ImGuiCond_.ImGuiCond_Always)
		if window.DockId != prev_node_id { window.DockOrder = -1 }
	}
	else {
		// Apply to settings
		settings : ^ImGuiWindowSettings = FindWindowSettingsByID(window_id)
		if settings == nil { settings = CreateNewWindowSettings(window_name) }
		if settings.DockId != node_id { settings.DockOrder = -1 }
		settings.DockId = node_id
	}
}

DockBuilderGetNode :: proc(node_id : ImGuiID) -> ^ImGuiDockNode
{
	g : ^ImGuiContext = GImGui
	return DockContextFindNodeByID(g, node_id)
}

DockBuilderSetNodePos :: proc(node_id : ImGuiID, pos : ImVec2)
{
	g : ^ImGuiContext = GImGui
	node : ^ImGuiDockNode = DockContextFindNodeByID(g, node_id)
	if node == nil { return }
	node.Pos = pos
	node.AuthorityForPos = ImGuiDataAuthority_.ImGuiDataAuthority_DockNode
}

DockBuilderSetNodeSize :: proc(node_id : ImGuiID, size : ImVec2)
{
	g : ^ImGuiContext = GImGui
	node : ^ImGuiDockNode = DockContextFindNodeByID(g, node_id)
	if node == nil { return }
	IM_ASSERT(size.x > 0.0 && size.y > 0.0)
	node.SizeRef = size; node.Size = node.SizeRef
	node.AuthorityForSize = ImGuiDataAuthority_.ImGuiDataAuthority_DockNode
}

// Make sure to use the ImGuiDockNodeFlags_DockSpace flag to create a dockspace node! Otherwise this will create a floating node!
// - Floating node: you can then call DockBuilderSetNodePos()/DockBuilderSetNodeSize() to position and size the floating node.
// - Dockspace node: calling DockBuilderSetNodePos() is unnecessary.
// - If you intend to split a node immediately after creation using DockBuilderSplitNode(), make sure to call DockBuilderSetNodeSize() beforehand!
//   For various reason, the splitting code currently needs a base size otherwise space may not be allocated as precisely as you would expect.
// - Use (id == 0) to let the system allocate a node identifier.
// - Existing node with a same id will be removed.
DockBuilderAddNode :: proc(node_id : ImGuiID, flags : ImGuiDockNodeFlags) -> ImGuiID
{
	g : ^ImGuiContext = GImGui; IM_UNUSED(g)
	IMGUI_DEBUG_LOG_DOCKING(g, "[docking] DockBuilderAddNode 0x%08X flags=%08X\n", node_id, flags)

	if node_id != 0 { DockBuilderRemoveNode(node_id) }

	node : ^ImGuiDockNode = nil
	if (flags & cast(ImGuiDockNodeFlags) ImGuiDockNodeFlagsPrivate_.ImGuiDockNodeFlags_DockSpace) != {} {
		DockSpace(node_id, ImVec2{0, 0}, (flags & cast(ImGuiDockNodeFlags)~cast(i32)ImGuiDockNodeFlagsPrivate_.ImGuiDockNodeFlags_DockSpace) | ImGuiDockNodeFlags_.ImGuiDockNodeFlags_KeepAliveOnly)
		node = DockContextFindNodeByID(g, node_id)
	}
	else {
		node = DockContextAddNode(g, node_id)
		SetLocalFlags(node, flags)
	}
	node.LastFrameAlive = g.FrameCount; // Set this otherwise BeginDocked will undock during the same frame.
	return node.ID
}

// Remove node and all its child, undock all windows
DockBuilderRemoveNode :: proc(node_id : ImGuiID)
{
	g : ^ImGuiContext = GImGui; IM_UNUSED(g)
	IMGUI_DEBUG_LOG_DOCKING(g, "[docking] DockBuilderRemoveNode 0x%08X\n", node_id)

	node : ^ImGuiDockNode = DockContextFindNodeByID(g, node_id)
	if node == nil { return }
	DockBuilderRemoveNodeDockedWindows(node_id, true)
	DockBuilderRemoveNodeChildNodes(node_id)
	// Node may have moved or deleted if e.g. any merge happened
	node = DockContextFindNodeByID(g, node_id)
	if node == nil { return }
	if IsCentralNode(node) && node.ParentNode != nil { SetLocalFlags(node.ParentNode, node.ParentNode.LocalFlags | cast(ImGuiDockNodeFlags)ImGuiDockNodeFlagsPrivate_.ImGuiDockNodeFlags_CentralNode) }
	DockContextRemoveNode(g, node, true)
}

// Remove all split/hierarchy. All remaining docked windows will be re-docked to the remaining root node (node_id).
// root_id = 0 to remove all, root_id != 0 to remove child of given node.
DockBuilderRemoveNodeChildNodes :: proc(root_id : ImGuiID)
{
	g : ^ImGuiContext = GImGui
	dc : ^ImGuiDockContext = &g.DockContext

	root_node : ^ImGuiDockNode = root_id != 0 ? DockContextFindNodeByID(g, root_id) : nil
	if root_id != 0 && root_node == nil { return }
	has_central_node : bool = false

	backup_root_node_authority_for_pos : ImGuiDataAuthority = root_node != nil ? root_node.AuthorityForPos : ImGuiDataAuthority_.ImGuiDataAuthority_Auto
	backup_root_node_authority_for_size : ImGuiDataAuthority = root_node != nil ? root_node.AuthorityForSize : ImGuiDataAuthority_.ImGuiDataAuthority_Auto

	// Process active windows
	nodes_to_remove : ImVector(^ImGuiDockNode)
	for n : i32 = 0; n < dc.Nodes.Data.Size; n += 1 { if node : ^ImGuiDockNode = cast(^ImGuiDockNode) dc.Nodes.Data.Data[n].val_p; node != nil {
	want_removal : bool = (root_id == 0) || (node.ID != root_id && DockNodeGetRootNode(node).ID == root_id)
	if want_removal {
		if IsCentralNode(node) { has_central_node = true }
		if root_id != 0 { DockContextQueueNotifyRemovedNode(g, node) }
		if root_node != nil {
			DockNodeMoveWindows(root_node, node)
			DockSettingsRenameNodeReferences(node.ID, root_node.ID)
		}
		push_back(&nodes_to_remove, node)
	}
} }

	// DockNodeMoveWindows->DockNodeAddWindow will normally set those when reaching two windows (which is only adequate during interactive merge)
	// Make sure we don't lose our current pos/size. (FIXME-DOCK: Consider tidying up that code in DockNodeAddWindow instead)
	if root_node != nil {
		root_node.AuthorityForPos = backup_root_node_authority_for_pos
		root_node.AuthorityForSize = backup_root_node_authority_for_size
	}

	// Apply to settings
	for settings : ^ImGuiWindowSettings = begin(&g.SettingsWindows); settings != nil; settings = next_chunk(&g.SettingsWindows, settings) { if window_settings_dock_id : ImGuiID = settings.DockId; window_settings_dock_id != 0 { for n : i32 = 0; n < nodes_to_remove.Size; n += 1 { if nodes_to_remove.Data[n].ID == window_settings_dock_id {
	settings.DockId = root_id
	break
} } } }

	// Not really efficient, but easier to destroy a whole hierarchy considering DockContextRemoveNode is attempting to merge nodes
	if nodes_to_remove.Size > 1 { ImQsort(nodes_to_remove.Data[:nodes_to_remove.Size], DockNodeComparerDepthMostFirst) }
	for n : i32 = 0; n < nodes_to_remove.Size; n += 1 { DockContextRemoveNode(g, nodes_to_remove.Data[n], false) }

	if root_id == 0 {
		Clear(&dc.Nodes)
		clear(&dc.Requests)
	}
	else if has_central_node {
		root_node.CentralNode = root_node
		SetLocalFlags(root_node, root_node.LocalFlags | cast(ImGuiDockNodeFlags)ImGuiDockNodeFlagsPrivate_.ImGuiDockNodeFlags_CentralNode)
	}
}

DockBuilderRemoveNodeDockedWindows :: proc(root_id : ImGuiID, clear_settings_refs : bool)
{
	// Clear references in settings
	g : ^ImGuiContext = GImGui
	if clear_settings_refs {
		for settings : ^ImGuiWindowSettings = begin(&g.SettingsWindows); settings != nil; settings = next_chunk(&g.SettingsWindows, settings) {
			want_removal : bool = (root_id == 0) || (settings.DockId == root_id)
			if !want_removal && settings.DockId != 0 { if node : ^ImGuiDockNode = DockContextFindNodeByID(g, settings.DockId); node != nil { if DockNodeGetRootNode(node).ID == root_id { want_removal = true } } }
			if want_removal { settings.DockId = 0 }
		}
	}

	// Clear references in windows
	for n : i32 = 0; n < g.Windows.Size; n += 1 {
		window : ^ImGuiWindow = g.Windows.Data[n]
		want_removal : bool = (root_id == 0) || (window.DockNode != nil && DockNodeGetRootNode(window.DockNode).ID == root_id) || (window.DockNodeAsHost != nil && window.DockNodeAsHost.ID == root_id)
		if want_removal {
			backup_dock_id : ImGuiID = window.DockId
			IM_UNUSED(backup_dock_id)
			DockContextProcessUndockWindow(g, window, clear_settings_refs)
			if !clear_settings_refs { IM_ASSERT(window.DockId == backup_dock_id) }
		}
	}
}

// Create 2 child nodes in this parent node.
// If 'out_id_at_dir' or 'out_id_at_opposite_dir' are non NULL, the function will write out the ID of the two new nodes created.
// Return value is ID of the node at the specified direction, so same as (*out_id_at_dir) if that pointer is set.
// FIXME-DOCK: We are not exposing nor using split_outer.
DockBuilderSplitNode :: proc(id : ImGuiID, split_dir : ImGuiDir, size_ratio_for_node_at_dir : f32, out_id_at_dir : ^ImGuiID, out_id_at_opposite_dir : ^ImGuiID) -> ImGuiID
{
	g : ^ImGuiContext = GImGui
	IM_ASSERT(split_dir != ImGuiDir.ImGuiDir_None)
	IMGUI_DEBUG_LOG_DOCKING(g, "[docking] DockBuilderSplitNode: node 0x%08X, split_dir %d\n", id, split_dir)

	node : ^ImGuiDockNode = DockContextFindNodeByID(g, id)
	if node == nil {
		IM_ASSERT(node != nil)
		return 0
	}

	IM_ASSERT(!IsSplitNode(node)); // Assert if already Split

	req : ImGuiDockRequest
	req.Type = ImGuiDockRequestType.ImGuiDockRequestType_Split
	req.DockTargetWindow = nil
	req.DockTargetNode = node
	req.DockPayload = nil
	req.DockSplitDir = split_dir
	req.DockSplitRatio = ImSaturate((split_dir == ImGuiDir.ImGuiDir_Left || split_dir == ImGuiDir.ImGuiDir_Up) ? size_ratio_for_node_at_dir : 1.0 - size_ratio_for_node_at_dir)
	req.DockSplitOuter = false
	DockContextProcessDock(g, &req)

	id_at_dir : ImGuiID = node.ChildNodes[(split_dir == ImGuiDir.ImGuiDir_Left || split_dir == ImGuiDir.ImGuiDir_Up) ? 0 : 1].ID
	id_at_opposite_dir : ImGuiID = node.ChildNodes[(split_dir == ImGuiDir.ImGuiDir_Left || split_dir == ImGuiDir.ImGuiDir_Up) ? 1 : 0].ID
	if out_id_at_dir != nil { out_id_at_dir^ = id_at_dir }
	if out_id_at_opposite_dir != nil { out_id_at_opposite_dir^ = id_at_opposite_dir }
	return id_at_dir
}

DockBuilderCopyNodeRec :: proc(src_node : ^ImGuiDockNode, dst_node_id_if_known : ImGuiID, out_node_remap_pairs : ^ImVector(ImGuiID)) -> ^ImGuiDockNode
{
	g : ^ImGuiContext = GImGui
	dst_node : ^ImGuiDockNode = DockContextAddNode(g, dst_node_id_if_known)
	dst_node.SharedFlags = src_node.SharedFlags
	dst_node.LocalFlags = src_node.LocalFlags
	dst_node.LocalFlagsInWindows = ImGuiDockNodeFlags_.ImGuiDockNodeFlags_None
	dst_node.Pos = src_node.Pos
	dst_node.Size = src_node.Size
	dst_node.SizeRef = src_node.SizeRef
	dst_node.SplitAxis = src_node.SplitAxis
	UpdateMergedFlags(dst_node)

	push_back(out_node_remap_pairs, src_node.ID)
	push_back(out_node_remap_pairs, dst_node.ID)

	for child_n : i32 = 0; child_n < cast(i32)IM_ARRAYSIZE(src_node.ChildNodes); child_n += 1 { if src_node.ChildNodes[child_n] != nil {
	dst_node.ChildNodes[child_n] = DockBuilderCopyNodeRec(src_node.ChildNodes[child_n], 0, out_node_remap_pairs)
	dst_node.ChildNodes[child_n].ParentNode = dst_node
} }

	IMGUI_DEBUG_LOG_DOCKING(g, "[docking] Fork node %08X -> %08X (%d childs)\n", src_node.ID, dst_node.ID, IsSplitNode(dst_node) ? 2 : 0)
	return dst_node
}

DockBuilderCopyNode :: proc(src_node_id : ImGuiID, dst_node_id : ImGuiID, out_node_remap_pairs : ^ImVector(ImGuiID))
{
	g : ^ImGuiContext = GImGui
	IM_ASSERT(src_node_id != 0)
	IM_ASSERT(dst_node_id != 0)
	IM_ASSERT(out_node_remap_pairs != nil)

	DockBuilderRemoveNode(dst_node_id)

	src_node : ^ImGuiDockNode = DockContextFindNodeByID(g, src_node_id)
	IM_ASSERT(src_node != nil)

	clear(out_node_remap_pairs)
	DockBuilderCopyNodeRec(src_node, dst_node_id, out_node_remap_pairs)

	IM_ASSERT((out_node_remap_pairs.Size % 2) == 0)
}

DockBuilderCopyWindowSettings :: proc(src_name : string, dst_name : string)
{
	src_window : ^ImGuiWindow = FindWindowByName(src_name)
	if src_window == nil { return }
	if dst_window : ^ImGuiWindow = FindWindowByName(dst_name); dst_window != nil {
		dst_window.Pos = src_window.Pos
		dst_window.Size = src_window.Size
		dst_window.SizeFull = src_window.SizeFull
		dst_window.Collapsed = src_window.Collapsed
	}
	else {
		dst_settings : ^ImGuiWindowSettings = FindWindowSettingsByID(ImHashStr(dst_name))
		if dst_settings == nil { dst_settings = CreateNewWindowSettings(dst_name) }
		window_pos_2ih : ImVec2ih = ImVec2ih{cast(i16)src_window.Pos.x, cast(i16)src_window.Pos.y}
		if src_window.ViewportId != 0 && src_window.ViewportId != IMGUI_VIEWPORT_DEFAULT_ID {
			dst_settings.ViewportPos = window_pos_2ih
			dst_settings.ViewportId = src_window.ViewportId
			dst_settings.Pos = ImVec2ih{}
		}
		else {
			dst_settings.Pos = window_pos_2ih
		}
		dst_settings.Size = ImVec2ih{cast(i16)src_window.SizeFull.x, cast(i16)src_window.SizeFull.y}
		dst_settings.Collapsed = src_window.Collapsed
	}
}

// FIXME: Will probably want to change this signature, in particular how the window remapping pairs are passed.
DockBuilderCopyDockSpace :: proc(src_dockspace_id : ImGuiID, dst_dockspace_id : ImGuiID, in_window_remap_pairs : ^ImVector(string))
{
	g : ^ImGuiContext = GImGui
	IM_ASSERT(src_dockspace_id != 0)
	IM_ASSERT(dst_dockspace_id != 0)
	IM_ASSERT(in_window_remap_pairs != nil)
	IM_ASSERT((in_window_remap_pairs.Size % 2) == 0)

	// Duplicate entire dock
	// FIXME: When overwriting dst_dockspace_id, windows that aren't part of our dockspace window class but that are docked in a same node will be split apart,
	// whereas we could attempt to at least keep them together in a new, same floating node.
	node_remap_pairs : ImVector(ImGuiID)
	DockBuilderCopyNode(src_dockspace_id, dst_dockspace_id, &node_remap_pairs)

	// Attempt to transition all the upcoming windows associated to dst_dockspace_id into the newly created hierarchy of dock nodes
	// (The windows associated to src_dockspace_id are staying in place)
	src_windows : ImVector(ImGuiID)
	for remap_window_n : i32 = 0; remap_window_n < in_window_remap_pairs.Size; remap_window_n += 2 {
		src_window_name := (in_window_remap_pairs^).Data[remap_window_n]
		dst_window_name := (in_window_remap_pairs^).Data[remap_window_n + 1]
		src_window_id : ImGuiID = ImHashStr(src_window_name)
		push_back(&src_windows, src_window_id)

		// Search in the remapping tables
		src_dock_id : ImGuiID = 0
		if src_window : ^ImGuiWindow = FindWindowByID(src_window_id); src_window != nil { src_dock_id = src_window.DockId }
		else if src_window_settings : ^ImGuiWindowSettings = FindWindowSettingsByID(src_window_id); src_window_settings != nil { src_dock_id = src_window_settings.DockId }
		dst_dock_id : ImGuiID = 0
		for dock_remap_n : i32 = 0; dock_remap_n < node_remap_pairs.Size; dock_remap_n += 2 {
			if node_remap_pairs.Data[dock_remap_n] == src_dock_id {
				dst_dock_id = node_remap_pairs.Data[dock_remap_n + 1]
				//node_remap_pairs[dock_remap_n] = node_remap_pairs[dock_remap_n + 1] = 0; // Clear
				break
			}
		}

		if dst_dock_id != 0 {
			// Docked windows gets redocked into the new node hierarchy.
			IMGUI_DEBUG_LOG_DOCKING(g, "[docking] Remap live window '%s' 0x%08X -> '%s' 0x%08X\n", src_window_name, src_dock_id, dst_window_name, dst_dock_id)
			DockBuilderDockWindow(dst_window_name, dst_dock_id)
		}
		else {
			// Floating windows gets their settings transferred (regardless of whether the new window already exist or not)
			// When this is leading to a Copy and not a Move, we would get two overlapping floating windows. Could we possibly dock them together?
			IMGUI_DEBUG_LOG_DOCKING(g, "[docking] Remap window settings '%s' -> '%s'\n", src_window_name, dst_window_name)
			DockBuilderCopyWindowSettings(src_window_name, dst_window_name)
		}
	}

	// Anything else in the source nodes of 'node_remap_pairs' are windows that are not included in the remapping list.
	// Find those windows and move to them to the cloned dock node. This may be optional?
	// Dock those are a second step as undocking would invalidate source dock nodes.
	DockRemainingWindowTask :: struct { Window : ^ImGuiWindow, DockId : ImGuiID, }

	DockRemainingWindowTask_init :: proc(this : ^DockRemainingWindowTask, window : ^ImGuiWindow, dock_id : ImGuiID)
	{
		this.Window = window; this.DockId = dock_id
	}

	dock_remaining_windows : ImVector(DockRemainingWindowTask)
	for dock_remap_n : i32 = 0; dock_remap_n < node_remap_pairs.Size; dock_remap_n += 2 {
		if src_dock_id : ImGuiID = node_remap_pairs.Data[dock_remap_n]; src_dock_id != 0 {
			dst_dock_id : ImGuiID = node_remap_pairs.Data[dock_remap_n + 1]
			node : ^ImGuiDockNode = DockBuilderGetNode(src_dock_id)
			for window_n : i32 = 0; window_n < node.Windows.Size; window_n += 1 {
				window : ^ImGuiWindow = node.Windows.Data[window_n]
				if contains(src_windows, window.ID) { continue }

				// Docked windows gets redocked into the new node hierarchy.
				IMGUI_DEBUG_LOG_DOCKING(g, "[docking] Remap window '%s' %08X -> %08X\n", window.Name, src_dock_id, dst_dock_id)
				t : DockRemainingWindowTask
				DockRemainingWindowTask_init(&t, window, dst_dock_id)
				push_back(&dock_remaining_windows, t)
			}
		}
	}

	for task in dock_remaining_windows.Data[:dock_remaining_windows.Size] { DockBuilderDockWindow(task.Window.Name, task.DockId) }
}

// FIXME-DOCK: This is awkward because in series of split user is likely to loose access to its root node.
DockBuilderFinish :: proc(root_id : ImGuiID)
{
	g : ^ImGuiContext = GImGui
	//DockContextRebuild(&g);
	DockContextBuildAddWindowsToNodes(g, root_id)
}

//-----------------------------------------------------------------------------
// Docking: Begin/End Support Functions (called from Begin/End)
//-----------------------------------------------------------------------------
// - GetWindowAlwaysWantOwnTabBar()
// - DockContextBindNodeToWindow()
// - BeginDocked()
// - BeginDockableDragDropSource()
// - BeginDockableDragDropTarget()
//-----------------------------------------------------------------------------

GetWindowAlwaysWantOwnTabBar :: proc(window : ^ImGuiWindow) -> bool
{
	g : ^ImGuiContext = GImGui
	if g.IO.ConfigDockingAlwaysTabBar || window.WindowClass.DockingAlwaysTabBar { if (window.Flags & (ImGuiWindowFlags_.ImGuiWindowFlags_ChildWindow | ImGuiWindowFlags_.ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_.ImGuiWindowFlags_NoDocking)) == {} { if !window.IsFallbackWindow {
		// We don't support AlwaysTabBar on the fallback/implicit window to avoid unused dock-node overhead/noise
		return true
	} } }
	return false
}

DockContextBindNodeToWindow :: proc(ctx : ^ImGuiContext, window : ^ImGuiWindow) -> ^ImGuiDockNode
{
	g : ^ImGuiContext = ctx
	node : ^ImGuiDockNode = DockContextFindNodeByID(ctx, window.DockId)
	IM_ASSERT(window.DockNode == nil)

	// We should not be docking into a split node (SetWindowDock should avoid this)
	if node != nil && IsSplitNode(node) {
		DockContextProcessUndockWindow(ctx, window)
		return nil
	}

	// Create node
	if node == nil {
		node = DockContextAddNode(ctx, window.DockId)
		node.AuthorityForViewport = ImGuiDataAuthority_.ImGuiDataAuthority_Window; node.AuthorityForSize = node.AuthorityForViewport; node.AuthorityForPos = node.AuthorityForSize
		node.LastFrameAlive = g.FrameCount
	}

	// If the node just turned visible and is part of a hierarchy, it doesn't have a Size assigned by DockNodeTreeUpdatePosSize() yet,
	// so we're forcing a Pos/Size update from the first ancestor that is already visible (often it will be the root node).
	// If we don't do this, the window will be assigned a zero-size on its first frame, which won't ideally warm up the layout.
	// This is a little wonky because we don't normally update the Pos/Size of visible node mid-frame.
	if !node.IsVisible {
		ancestor_node : ^ImGuiDockNode = node
		for !ancestor_node.IsVisible && ancestor_node.ParentNode != nil { ancestor_node = ancestor_node.ParentNode }

		IM_ASSERT(ancestor_node.Size.x > 0.0 && ancestor_node.Size.y > 0.0)
		DockNodeUpdateHasCentralNodeChild(DockNodeGetRootNode(ancestor_node))
		DockNodeTreeUpdatePosSize(ancestor_node, ancestor_node.Pos, ancestor_node.Size, node)
	}

	// Add window to node
	node_was_visible : bool = node.IsVisible
	DockNodeAddWindow(node, window, true)
	node.IsVisible = node_was_visible; // Don't mark visible right away (so DockContextEndFrame() doesn't render it, maybe other side effects? will see)
	IM_ASSERT(node == window.DockNode)
	return node
}

StoreDockStyleForWindow :: proc(window : ^ImGuiWindow)
{
	g : ^ImGuiContext = GImGui
	for color_n : i32 = 0; color_n < cast(i32)ImGuiWindowDockStyleCol.ImGuiWindowDockStyleCol_COUNT; color_n += 1 { window.DockStyle.Colors[color_n] = ColorConvertFloat4ToU32(g.Style.Colors[GWindowDockStyleColors[color_n]]) }
}

BeginDocked :: proc(window : ^ImGuiWindow, p_open : ^bool)
{
	g : ^ImGuiContext = GImGui

	// Clear fields ahead so most early-out paths don't have to do it
	window.DockTabIsVisible = false; window.DockNodeIsVisible = window.DockTabIsVisible; window.DockIsActive = window.DockNodeIsVisible

	auto_dock_node : bool = GetWindowAlwaysWantOwnTabBar(window)
	if auto_dock_node {
		if window.DockId == 0 {
			IM_ASSERT(window.DockNode == nil)
			window.DockId = DockContextGenNodeID(g)
		}
	}
	else {
		// Calling SetNextWindowPos() undock windows by default (by setting PosUndock)
		want_undock : bool = false
		want_undock |= (window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoDocking) != {}
		want_undock |= (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_.ImGuiNextWindowDataFlags_HasPos) != {} && (window.SetWindowPosAllowFlags & g.NextWindowData.PosCond) != {} && g.NextWindowData.PosUndock
		if want_undock {
			DockContextProcessUndockWindow(g, window)
			return
		}
	}

	// Bind to our dock node
	node : ^ImGuiDockNode = window.DockNode
	if node != nil { IM_ASSERT(window.DockId == node.ID) }
	if window.DockId != 0 && node == nil {
		node = DockContextBindNodeToWindow(g, window)
		if node == nil { return }
	}



	// Undock if our dockspace node disappeared
	// Note how we are testing for LastFrameAlive and NOT LastFrameActive. A DockSpace node can be maintained alive while being inactive with ImGuiDockNodeFlags_KeepAliveOnly.
	if node.LastFrameAlive < g.FrameCount {
		// If the window has been orphaned, transition the docknode to an implicit node processed in DockContextNewFrameUpdateDocking()
		root_node : ^ImGuiDockNode = DockNodeGetRootNode(node)
		if root_node.LastFrameAlive < g.FrameCount { DockContextProcessUndockWindow(g, window) }
		else { window.DockIsActive = true }
		return
	}

	// Store style overrides
	StoreDockStyleForWindow(window)

	// Fast path return. It is common for windows to hold on a persistent DockId but be the only visible window,
	// and never create neither a host window neither a tab bar.
	// FIXME-DOCK: replace ->HostWindow NULL compare with something more explicit (~was initially intended as a first frame test)
	if node.HostWindow == nil {
		if node.State == ImGuiDockNodeState.ImGuiDockNodeState_HostWindowHiddenBecauseWindowsAreResizing { window.DockIsActive = true }
		if node.Windows.Size > 1 && window.Appearing {
			// Only hide appearing window
			DockNodeHideWindowDuringHostWindowCreation(window)
		}
		return
	}

	// We can have zero-sized nodes (e.g. children of a small-size dockspace)
	IM_ASSERT(node.HostWindow != nil)
	IM_ASSERT(IsLeafNode(node))
	IM_ASSERT(node.Size.x >= 0.0 && node.Size.y >= 0.0)
	node.State = ImGuiDockNodeState.ImGuiDockNodeState_HostWindowVisible

	// Undock if we are submitted earlier than the host window
	if (node.MergedFlags & ImGuiDockNodeFlags_.ImGuiDockNodeFlags_KeepAliveOnly) == {} && window.BeginOrderWithinContext < node.HostWindow.BeginOrderWithinContext {
		DockContextProcessUndockWindow(g, window)
		return
	}

	// Position/Size window
	SetNextWindowPos(node.Pos)
	SetNextWindowSize(node.Size)
	g.NextWindowData.PosUndock = false; // Cancel implicit undocking of SetNextWindowPos()
	window.DockIsActive = true
	window.DockNodeIsVisible = true
	window.DockTabIsVisible = false
	if (node.MergedFlags & ImGuiDockNodeFlags_.ImGuiDockNodeFlags_KeepAliveOnly) != {} { return }

	// When the window is selected we mark it as visible.
	if node.VisibleWindow == window { window.DockTabIsVisible = true }

	// Update window flag
	IM_ASSERT((window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_ChildWindow) == {})
	window.Flags |= ImGuiWindowFlags_.ImGuiWindowFlags_ChildWindow | ImGuiWindowFlags_.ImGuiWindowFlags_NoResize
	window.ChildFlags |= ImGuiChildFlags_.ImGuiChildFlags_AlwaysUseWindowPadding
	if IsHiddenTabBar(node) || IsNoTabBar(node) { window.Flags |= ImGuiWindowFlags_.ImGuiWindowFlags_NoTitleBar }
	else {
		// Clear the NoTitleBar flag in case the user set it: confusingly enough we need a title bar height so we are correctly offset, but it won't be displayed!
		window.Flags &= cast(ImGuiWindowFlags)~cast(i32)ImGuiWindowFlags_.ImGuiWindowFlags_NoTitleBar
	}

	// Save new dock order only if the window has been visible once already
	// This allows multiple windows to be created in the same frame and have their respective dock orders preserved.
	if node.TabBar != nil && window.WasActive { window.DockOrder = cast(i16) DockNodeGetTabOrder(window) }

	if (node.WantCloseAll || node.WantCloseTabId == window.TabId) && p_open != nil { p_open^ = false }

	// Update ChildId to allow returning from Child to Parent with Escape
	parent_window : ^ImGuiWindow = window.DockNode.HostWindow
	window.ChildId = GetID(parent_window, window.Name)
}

BeginDockableDragDropSource :: proc(window : ^ImGuiWindow)
{
	g : ^ImGuiContext = GImGui
	IM_ASSERT(g.ActiveId == window.MoveId)
	IM_ASSERT(g.MovingWindow == window)
	IM_ASSERT(g.CurrentWindow == window)

	// 0: Hold SHIFT to disable docking, 1: Hold SHIFT to enable docking.
	if g.IO.ConfigDockingWithShift != g.IO.KeyShift {
		// When ConfigDockingWithShift is set, display a tooltip to increase UI affordance.
		// We cannot set for HoveredWindowUnderMovingWindow != NULL here, as it is only valid/useful when drag and drop is already active
		// (because of the 'is_mouse_dragging_with_an_expected_destination' logic in UpdateViewportsNewFrame() function)
		IM_ASSERT(g.NextWindowData.Flags == {})
		if g.IO.ConfigDockingWithShift && g.MouseStationaryTimer >= 1.0 && g.ActiveId >= 1.0 { SetTooltip("%s", LocalizeGetMsg(ImGuiLocKey.ImGuiLocKey_DockingHoldShiftToDock)) }
		return
	}

	g.LastItemData.ID = window.MoveId
	window := window.RootWindowDockTree
	IM_ASSERT((window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoDocking) == {})
	is_drag_docking : bool = (g.IO.ConfigDockingWithShift) || Contains(ImRect{{0, 0}, {window.SizeFull.x, GetFrameHeight()}}, g.ActiveIdClickOffset); // FIXME-DOCKING: Need to make this stateful and explicit
	drag_drop_flags : ImGuiDragDropFlags = ImGuiDragDropFlags_.ImGuiDragDropFlags_SourceNoPreviewTooltip | ImGuiDragDropFlags_.ImGuiDragDropFlags_SourceNoHoldToOpenOthers | ImGuiDragDropFlags_.ImGuiDragDropFlags_PayloadAutoExpire | ImGuiDragDropFlags_.ImGuiDragDropFlags_PayloadNoCrossContext | ImGuiDragDropFlags_.ImGuiDragDropFlags_PayloadNoCrossProcess
	if is_drag_docking && BeginDragDropSource(drag_drop_flags) {
		SetDragDropPayload(IMGUI_PAYLOAD_TYPE_WINDOW, &window, size_of(window))
		EndDragDropSource()
		StoreDockStyleForWindow(window); // Store style overrides while dragging (even when not docked) because docking preview may need it.
	}
}

BeginDockableDragDropTarget :: proc(window : ^ImGuiWindow)
{
	g : ^ImGuiContext = GImGui

	//IM_ASSERT(window->RootWindowDockTree == window); // May also be a DockSpace
	IM_ASSERT((window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoDocking) == {})
	if !g.DragDropActive { return }
	//GetForegroundDrawList(window)->AddRect(window->Pos, window->Pos + window->Size, IM_COL32(255, 255, 0, 255));
	if !BeginDragDropTargetCustom(Rect(window), window.ID) { return }

	// Peek into the payload before calling AcceptDragDropPayload() so we can handle overlapping dock nodes with filtering
	// (this is a little unusual pattern, normally most code would call AcceptDragDropPayload directly)
	payload : ^ImGuiPayload = &g.DragDropPayload
	if !IsDataType(payload, IMGUI_PAYLOAD_TYPE_WINDOW) || !DockNodeIsDropAllowed(window, (cast(^^ImGuiWindow) payload.Data)^) {
		EndDragDropTarget()
		return
	}

	payload_window : ^ImGuiWindow = (cast(^^ImGuiWindow) payload.Data)^
	if AcceptDragDropPayload(IMGUI_PAYLOAD_TYPE_WINDOW, ImGuiDragDropFlags_.ImGuiDragDropFlags_AcceptBeforeDelivery | ImGuiDragDropFlags_.ImGuiDragDropFlags_AcceptNoDrawDefaultRect) != nil {
		// Select target node
		// (Important: we cannot use g.HoveredDockNode here! Because each of our target node have filters based on payload, each candidate drop target will do its own evaluation)
		dock_into_floating_window : bool = false
		node : ^ImGuiDockNode = nil
		if window.DockNodeAsHost != nil {
			// Cannot assume that node will != NULL even though we passed the rectangle test: it depends on padding/spacing handled by DockNodeTreeFindVisibleNodeByPos().
			node = DockNodeTreeFindVisibleNodeByPos(window.DockNodeAsHost, g.IO.MousePos)

			// There is an edge case when docking into a dockspace which only has _inactive_ nodes (because none of the windows are active)
			// In this case we need to fallback into any leaf mode, possibly the central node.
			// FIXME-20181220: We should not have to test for IsLeafNode() here but we have another bug to fix first.
			if node != nil && IsDockSpace(node) && IsRootNode(node) { node = (node.CentralNode != nil && IsLeafNode(node)) ? node.CentralNode : DockNodeTreeFindFallbackLeafNode(node) }
		}
		else {
			if window.DockNode != nil { node = window.DockNode }
			else {
				// Dock into a regular window
				dock_into_floating_window = true
			}
		}

		explicit_target_rect : ImRect = (node != nil && node.TabBar != nil && !IsHiddenTabBar(node) && !IsNoTabBar(node)) ? node.TabBar.BarRect : ImRect{window.Pos, window.Pos + ImVec2{window.Size.x, GetFrameHeight()}}
		is_explicit_target : bool = g.IO.ConfigDockingWithShift || IsMouseHoveringRect(explicit_target_rect.Min, explicit_target_rect.Max)

		// Preview docking request and find out split direction/ratio
		//const bool do_preview = true;     // Ignore testing for payload->IsPreview() which removes one frame of delay, but breaks overlapping drop targets within the same window.
		do_preview : bool = IsPreview(payload) || IsDelivery(payload)
		if do_preview && (node != nil || dock_into_floating_window) {
			// If we have a non-leaf node it means we are hovering the border of a parent node, in which case only outer markers will appear.
			split_inner : ImGuiDockPreviewData
			split_outer : ImGuiDockPreviewData
			split_data : ^ImGuiDockPreviewData = &split_inner
			if node != nil && (node.ParentNode != nil || IsCentralNode(node) || !IsLeafNode(node)) { if root_node : ^ImGuiDockNode = DockNodeGetRootNode(node); root_node != nil {
	DockNodePreviewDockSetup(window, root_node, payload_window, nil, &split_outer, is_explicit_target, true)
	if split_outer.IsSplitDirExplicit { split_data = &split_outer }
} }
			if node == nil || IsLeafNode(node) { DockNodePreviewDockSetup(window, node, payload_window, nil, &split_inner, is_explicit_target, false) }
			if split_data == &split_outer { split_inner.IsDropAllowed = false }

			// Draw inner then outer, so that previewed tab (in inner data) will be behind the outer drop boxes
			DockNodePreviewDockRender(window, node, payload_window, &split_inner)
			DockNodePreviewDockRender(window, node, payload_window, &split_outer)

			// Queue docking request
			if split_data.IsDropAllowed && IsDelivery(payload) { DockContextQueueDock(g, window, split_data.SplitNode, payload_window, split_data.SplitDir, split_data.SplitRatio, split_data == &split_outer) }
		}
	}
	EndDragDropTarget()
}

// Settings
//-----------------------------------------------------------------------------
// Docking: Settings
//-----------------------------------------------------------------------------
// - DockSettingsRenameNodeReferences()
// - DockSettingsRemoveNodeReferences()
// - DockSettingsFindNodeSettings()
// - DockSettingsHandler_ApplyAll()
// - DockSettingsHandler_ReadOpen()
// - DockSettingsHandler_ReadLine()
// - DockSettingsHandler_DockNodeToSettings()
// - DockSettingsHandler_WriteAll()
//-----------------------------------------------------------------------------

DockSettingsRenameNodeReferences :: proc(old_node_id : ImGuiID, new_node_id : ImGuiID)
{
	g : ^ImGuiContext = GImGui
	IMGUI_DEBUG_LOG_DOCKING(g, "[docking] DockSettingsRenameNodeReferences: from 0x%08X -> to 0x%08X\n", old_node_id, new_node_id)
	for window_n : i32 = 0; window_n < g.Windows.Size; window_n += 1 {
		window : ^ImGuiWindow = g.Windows.Data[window_n]
		if window.DockId == old_node_id && window.DockNode == nil { window.DockId = new_node_id }
	}

	//// FIXME-OPT: We could remove this loop by storing the index in the map
	for settings : ^ImGuiWindowSettings = begin(&g.SettingsWindows); settings != nil; settings = next_chunk(&g.SettingsWindows, settings) { if settings.DockId == old_node_id { settings.DockId = new_node_id } }
}

// Remove references stored in ImGuiWindowSettings to the given ImGuiDockNodeSettings
DockSettingsRemoveNodeReferences :: proc(node_ids : []ImGuiID)
{
	g : ^ImGuiContext = GImGui
	found : i32 = 0
	//// FIXME-OPT: We could remove this loop by storing the index in the map
	for settings : ^ImGuiWindowSettings = begin(&g.SettingsWindows); settings != nil; settings = next_chunk(&g.SettingsWindows, settings) {
		for node_id in node_ids {
			if settings.DockId == node_id {
			settings.DockId = 0
			settings.DockOrder = -1
			if pre_incr(&found) < cast(i32)len(node_ids) { break }
				return
			}
		}
	}
}

DockSettingsFindNodeSettings :: proc(ctx : ^ImGuiContext, id : ImGuiID) -> ^ImGuiDockNodeSettings
{
	// FIXME-OPT
	dc : ^ImGuiDockContext = &ctx.DockContext
	for n : i32 = 0; n < dc.NodesSettings.Size; n += 1 { if dc.NodesSettings.Data[n].ID == id { return &dc.NodesSettings.Data[n] } }

	return nil
}

// Clear settings data
DockSettingsHandler_ClearAll :: proc(ctx : ^ImGuiContext, _ : ^ImGuiSettingsHandler)
{
	dc : ^ImGuiDockContext = &ctx.DockContext
	clear(&dc.NodesSettings)
	DockContextClearNodes(ctx, 0, true)
}

// Recreate nodes based on settings data
DockSettingsHandler_ApplyAll :: proc(ctx : ^ImGuiContext, _ : ^ImGuiSettingsHandler)
{
	// Prune settings at boot time only
	dc : ^ImGuiDockContext = &ctx.DockContext
	if ctx.Windows.Size == 0 { DockContextPruneUnusedSettingsNodes(ctx) }
	DockContextBuildNodesFromSettings(ctx, dc.NodesSettings.Data, dc.NodesSettings.Size)
	DockContextBuildAddWindowsToNodes(ctx, 0)
}

DockSettingsHandler_ReadOpen :: proc(_ : ^ImGuiContext, _ : ^ImGuiSettingsHandler, name : string) -> rawptr
{
	if name != "Data" { return nil }
	return cast(rawptr) uintptr(1)
}

DockSettingsHandler_ReadLine :: proc(ctx : ^ImGuiContext, _ : ^ImGuiSettingsHandler, _ : rawptr, line : string)
{
	// Parsing, e.g.
	// " DockNode   ID=0x00000001 Pos=383,193 Size=201,322 Split=Y,0.506 "
	// "   DockNode ID=0x00000002 Parent=0x00000001 "
	// Important: this code expect currently fields in a fixed order.
	node : ImGuiDockNodeSettings
	line := ImStrSkipBlank(line)
	if strncmp(line, "DockNode", 8) == 0 {
		line = ImStrSkipBlank(line[len("DockNode"):])
	}
	else if strncmp(line, "DockSpace", 9) == 0 {
		line = ImStrSkipBlank(line[len("DockSpace"):])
		node.Flags |= cast(ImGuiDockNodeFlags) ImGuiDockNodeFlagsPrivate_.ImGuiDockNodeFlags_DockSpace
	}
	else { return }

	c : u8; o : int; x, y : i64
	if parse_int_prefixed(line, &o, "ID=", &x, 16) { node.ID = u32(x) } else { return }
	if parse_int_prefixed(line, &o, " Parent=", &x, 16) { node.ParentNodeId = u32(x); if node.ParentNodeId == 0 { return } }
	if parse_int_prefixed(line, &o, " Window=", &x, 16) { node.ParentWindowId = u32(x); if node.ParentWindowId == 0 { return } }
	if node.ParentNodeId == 0 {
		if parse_int_pair_prefixed(line, &o, " Pos=", &x, 10, &y, 10) { node.Pos = ImVec2ih{cast(i16) x, cast(i16) y} } else { return }
		if parse_int_pair_prefixed(line, &o, " Size=", &x, 10, &y, 10) { node.Size = ImVec2ih{cast(i16) x, cast(i16) y} } else { return }
	}
	else {
		if parse_int_pair_prefixed(line, &o, " SizeRef=", &x, 10, &y, 10) { node.SizeRef = ImVec2ih{cast(i16) x, cast(i16) y} }
	}
	if parse_char_prefixed(line, &o, " Split=", &c) {
		if c == 'X' { node.SplitAxis = cast(i8)ImGuiAxis.ImGuiAxis_X }
		else if c == 'Y' { node.SplitAxis = cast(i8)ImGuiAxis.ImGuiAxis_Y }
	}
	if parse_int_prefixed(line, &o, " NoResize=", &x, 10) { if x != 0 { node.Flags |= ImGuiDockNodeFlags_.ImGuiDockNodeFlags_NoResize } }
	if parse_int_prefixed(line, &o, " CentralNode=", &x, 10) { if x != 0 { node.Flags |= cast(ImGuiDockNodeFlags) ImGuiDockNodeFlagsPrivate_.ImGuiDockNodeFlags_CentralNode } }
	if parse_int_prefixed(line, &o, " NoTabBar=", &x, 10) { if x != 0 { node.Flags |= cast(ImGuiDockNodeFlags) ImGuiDockNodeFlagsPrivate_.ImGuiDockNodeFlags_NoTabBar } }
	if parse_int_prefixed(line, &o, " HiddenTabBar=", &x, 10) { if x != 0 { node.Flags |= cast(ImGuiDockNodeFlags) ImGuiDockNodeFlagsPrivate_.ImGuiDockNodeFlags_HiddenTabBar } }
	if parse_int_prefixed(line, &o, " NoWindowMenuButton=", &x, 10) { if x != 0 { node.Flags |= cast(ImGuiDockNodeFlags) ImGuiDockNodeFlagsPrivate_.ImGuiDockNodeFlags_NoWindowMenuButton } }
	if parse_int_prefixed(line, &o, " NoCloseButton=", &x, 10) { if x != 0 { node.Flags |= cast(ImGuiDockNodeFlags) ImGuiDockNodeFlagsPrivate_.ImGuiDockNodeFlags_NoCloseButton } }
	if parse_int_prefixed(line, &o, " Selected=", &x, 16) { node.SelectedTabId = u32(x) }
	if node.ParentNodeId != 0 { if parent_settings : ^ImGuiDockNodeSettings = DockSettingsFindNodeSettings(ctx, node.ParentNodeId); parent_settings != nil { node.Depth = parent_settings.Depth + 1 } }
	push_back(&ctx.DockContext.NodesSettings, node)
}

DockSettingsHandler_DockNodeToSettings :: proc(dc : ^ImGuiDockContext, node : ^ImGuiDockNode, depth : i32)
{
	node_settings : ImGuiDockNodeSettings
	IM_ASSERT(depth < (1 << (size_of(node_settings.Depth) << 3)))
	node_settings.ID = node.ID
	node_settings.ParentNodeId = node.ParentNode != nil ? node.ParentNode.ID : 0
	node_settings.ParentWindowId = (IsDockSpace(node) && node.HostWindow != nil && node.HostWindow.ParentWindow != nil) ? node.HostWindow.ParentWindow.ID : 0
	node_settings.SelectedTabId = node.SelectedTabId
	node_settings.SplitAxis = cast(i8) (IsSplitNode(node) ? node.SplitAxis : ImGuiAxis.ImGuiAxis_None)
	node_settings.Depth = cast(u8) depth
	node_settings.Flags = (node.LocalFlags & cast(ImGuiDockNodeFlags) ImGuiDockNodeFlagsPrivate_.ImGuiDockNodeFlags_SavedFlagsMask_)
	node_settings.Pos = ImVec2ih{cast(i16)node.Pos.x, cast(i16)node.Pos.y}
	node_settings.Size = ImVec2ih{cast(i16)node.Size.x, cast(i16)node.Size.y}
	node_settings.SizeRef = ImVec2ih{cast(i16)node.SizeRef.x, cast(i16)node.SizeRef.y}
	push_back(&dc.NodesSettings, node_settings)
	if node.ChildNodes[0] != nil { DockSettingsHandler_DockNodeToSettings(dc, node.ChildNodes[0], depth + 1) }
	if node.ChildNodes[1] != nil { DockSettingsHandler_DockNodeToSettings(dc, node.ChildNodes[1], depth + 1) }
}

DockSettingsHandler_WriteAll :: proc(ctx : ^ImGuiContext, handler : ^ImGuiSettingsHandler, buf : ^ImGuiTextBuffer)
{
	g : ^ImGuiContext = ctx
	dc : ^ImGuiDockContext = &ctx.DockContext
	if (g.IO.ConfigFlags & ImGuiConfigFlags_.ImGuiConfigFlags_DockingEnable) == {} { return }

	// Gather settings data
	// (unlike our windows settings, because nodes are always built we can do a full rewrite of the SettingsNode buffer)
	resize(&dc.NodesSettings, 0)
	reserve(&dc.NodesSettings, dc.Nodes.Data.Size)
	for n : i32 = 0; n < dc.Nodes.Data.Size; n += 1 { if node : ^ImGuiDockNode = cast(^ImGuiDockNode) dc.Nodes.Data.Data[n].val_p; node != nil { if IsRootNode(node) { DockSettingsHandler_DockNodeToSettings(dc, node, 0) } } }

	max_depth : i32 = 0
	for node_n : i32 = 0; node_n < dc.NodesSettings.Size; node_n += 1 { max_depth = ImMax(cast(i32) dc.NodesSettings.Data[node_n].Depth, max_depth) }

	// Write to text buffer
	appendf(buf, "[%s][Data]\n", handler.TypeName)
	for node_n : i32 = 0; node_n < dc.NodesSettings.Size; node_n += 1 {
		line_start_pos : i32 = size(buf); _ = line_start_pos
		node_settings : ^ImGuiDockNodeSettings = &dc.NodesSettings.Data[node_n]
		appendf(buf, "%*s%s%*s", node_settings.Depth * 2, "", (node_settings.Flags & cast(ImGuiDockNodeFlags) ImGuiDockNodeFlagsPrivate_.ImGuiDockNodeFlags_DockSpace) != {} ? "DockSpace" : "DockNode ", (max_depth - i32(node_settings.Depth)) * 2, ""); // Text align nodes to facilitate looking at .ini file
		appendf(buf, " ID=0x%08X", node_settings.ID)
		if node_settings.ParentNodeId != 0 {
			appendf(buf, " Parent=0x%08X SizeRef=%d,%d", node_settings.ParentNodeId, node_settings.SizeRef.x, node_settings.SizeRef.y)
		}
		else {
			if node_settings.ParentWindowId != 0 { appendf(buf, " Window=0x%08X", node_settings.ParentWindowId) }
			appendf(buf, " Pos=%d,%d Size=%d,%d", node_settings.Pos.x, node_settings.Pos.y, node_settings.Size.x, node_settings.Size.y)
		}
		if node_settings.SplitAxis != cast(i8)ImGuiAxis.ImGuiAxis_None { appendf(buf, " Split=%c", (node_settings.SplitAxis == cast(i8)ImGuiAxis.ImGuiAxis_X) ? 'X' : 'Y') }
		if (node_settings.Flags & ImGuiDockNodeFlags_.ImGuiDockNodeFlags_NoResize) != {} { appendf(buf, " NoResize=1") }
		if (node_settings.Flags & cast(ImGuiDockNodeFlags) ImGuiDockNodeFlagsPrivate_.ImGuiDockNodeFlags_CentralNode) != {} { appendf(buf, " CentralNode=1") }
		if (node_settings.Flags & cast(ImGuiDockNodeFlags) ImGuiDockNodeFlagsPrivate_.ImGuiDockNodeFlags_NoTabBar) != {} { appendf(buf, " NoTabBar=1") }
		if (node_settings.Flags & cast(ImGuiDockNodeFlags) ImGuiDockNodeFlagsPrivate_.ImGuiDockNodeFlags_HiddenTabBar) != {} { appendf(buf, " HiddenTabBar=1") }
		if (node_settings.Flags & cast(ImGuiDockNodeFlags) ImGuiDockNodeFlagsPrivate_.ImGuiDockNodeFlags_NoWindowMenuButton) != {} { appendf(buf, " NoWindowMenuButton=1") }
		if (node_settings.Flags & cast(ImGuiDockNodeFlags) ImGuiDockNodeFlagsPrivate_.ImGuiDockNodeFlags_NoCloseButton) != {} { appendf(buf, " NoCloseButton=1") }
		if node_settings.SelectedTabId != 0 { appendf(buf, " Selected=0x%08X", node_settings.SelectedTabId) }

		// [DEBUG] Include comments in the .ini file to ease debugging (this makes saving slower!)
		if g.IO.ConfigDebugIniSettings { if node : ^ImGuiDockNode = DockContextFindNodeByID(ctx, node_settings.ID); node != nil {
	appendf(buf, "%*s", ImMax(i32(2), (line_start_pos + 92) - size(buf)), ""); // Align everything
	if IsDockSpace(node) && node.HostWindow != nil && node.HostWindow.ParentWindow != nil { appendf(buf, " ; in '%s'", node.HostWindow.ParentWindow.Name) }
	// Iterate settings so we can give info about windows that didn't exist during the session.
	contains_window : i32 = 0
	for settings : ^ImGuiWindowSettings = begin(&g.SettingsWindows); settings != nil; settings = next_chunk(&g.SettingsWindows, settings) { if settings.DockId == node_settings.ID {
	if post_incr(&contains_window) == 0 { appendf(buf, " ; contains ") }
	appendf(buf, "'%s' ", GetName(settings))
} }
} }

		appendf(buf, "\n")
	}

	appendf(buf, "\n")
}


//-----------------------------------------------------------------------------
// [SECTION] PLATFORM DEPENDENT HELPERS
//-----------------------------------------------------------------------------
// - Default clipboard handlers
// - Default shell function handlers
// - Default IME handlers
//-----------------------------------------------------------------------------

when ODIN_OS == .Windows && ! IMGUI_DISABLE_WIN32_FUNCTIONS && ! IMGUI_DISABLE_WIN32_DEFAULT_CLIPBOARD_FUNCTIONS {

// Platform Dependents default implementation for ImGuiPlatformIO functions
// Win32 clipboard implementation
// We use g.ClipboardHandlerData for temporary storage to ensure it is freed on Shutdown()
Platform_GetClipboardTextFn_DefaultImpl :: proc(ctx : ^ImGuiContext) -> string
{
	g : ^ImGuiContext = ctx
	clear(&g.ClipboardHandlerData); buf_len : i32
	if !win32.OpenClipboard(nil) { return "" }
	wbuf_handle := cast(win32.HGLOBAL) win32.GetClipboardData(win32.CF_UNICODETEXT)
	if wbuf_handle == nil {
		win32.CloseClipboard()
		return ""
	}
	if wbuf_global := cast(cstring16) win32.GlobalLock(wbuf_handle); wbuf_global != nil {
		buf_len = win32.WideCharToMultiByte(win32.CP_UTF8, 0, wbuf_global, -1, nil, 0, nil, nil)
		resize(&g.ClipboardHandlerData, buf_len)
		win32.WideCharToMultiByte(win32.CP_UTF8, 0, wbuf_global, -1, g.ClipboardHandlerData.Data, buf_len, nil, nil)
	}
	win32.GlobalUnlock(wbuf_handle)
	win32.CloseClipboard()
	return string_from_slice(g.ClipboardHandlerData.Data[:buf_len])
}

Platform_SetClipboardTextFn_DefaultImpl :: proc(_ : ^ImGuiContext, text : string)
{
	if !win32.OpenClipboard(nil) { return }
	wbuf_length : i32 = win32.MultiByteToWideChar(win32.CP_UTF8, 0, raw_data(text), cast(i32) len(text), nil, 0)
	wbuf_handle := cast(win32.HGLOBAL) win32.GlobalAlloc(win32.GMEM_MOVEABLE, cast(win32.SIZE_T) wbuf_length * size_of(win32.WCHAR))
	if wbuf_handle == nil {
		win32.CloseClipboard()
		return
	}
	wbuf_global : ^win32.WCHAR = cast(^win32.WCHAR) win32.GlobalLock(wbuf_handle)
	win32.MultiByteToWideChar(win32.CP_UTF8, 0, raw_data(text), cast(i32) len(text), wbuf_global, wbuf_length)
	win32.GlobalUnlock(wbuf_handle)
	win32.EmptyClipboard()
	if win32.SetClipboardData(win32.CF_UNICODETEXT, cast(win32.HANDLE) wbuf_handle) == nil { win32.GlobalFree(wbuf_handle) }
	win32.CloseClipboard()
}

} else when defined ( __APPLE__ ) && TARGET_OS_OSX && defined ( IMGUI_ENABLE_OSX_DEFAULT_CLIPBOARD_FUNCTIONS ) {

main_clipboard : PasteboardRef = 0

// OSX clipboard implementation
// If you enable this you will need to add '-framework ApplicationServices' to your linker command-line!
Platform_SetClipboardTextFn_DefaultImpl :: proc(_ : ^ImGuiContext, text : ^u8)
{
	if main_clipboard == {} { PasteboardCreate(kPasteboardClipboard, &main_clipboard) }
	PasteboardClear(main_clipboard)
	cf_data : CFDataRef = CFDataCreate(kCFAllocatorDefault, cast(^UInt8) text, strlen(text))
	if cf_data != {} {
		PasteboardPutItemFlavor(main_clipboard, cast(PasteboardItemID) 1, CFSTR("public.utf8-plain-text"), cf_data, 0)
		CFRelease(cf_data)
	}
}

// Platform Dependents default implementation for ImGuiPlatformIO functions
// Win32 clipboard implementation
// We use g.ClipboardHandlerData for temporary storage to ensure it is freed on Shutdown()
Platform_GetClipboardTextFn_DefaultImpl :: proc(ctx : ^ImGuiContext) -> ^u8
{
	g : ^ImGuiContext = ctx
	if main_clipboard == {} { PasteboardCreate(kPasteboardClipboard, &main_clipboard) }
	PasteboardSynchronize(main_clipboard)

	item_count : ItemCount = 0
	PasteboardGetItemCount(main_clipboard, &item_count)
	for i : ItemCount = 0; i < item_count; i += 1 {
		item_id : PasteboardItemID = 0
		PasteboardGetItemIdentifier(main_clipboard, i + 1, &item_id)
		flavor_type_array : CFArrayRef = 0
		PasteboardCopyItemFlavors(main_clipboard, item_id, &flavor_type_array)
		for j, nj : CFIndex = 0, CFArrayGetCount(flavor_type_array); j < nj; j += 1 {
			cf_data : CFDataRef
			if PasteboardCopyItemFlavorData(main_clipboard, item_id, CFSTR("public.utf8-plain-text"), &cf_data) == noErr {
				clear(&g.ClipboardHandlerData)
				length : i32 = cast(i32) CFDataGetLength(cf_data)
				resize(&g.ClipboardHandlerData, length + 1)
				CFDataGetBytes(cf_data, CFRangeMake(0, length), cast(^UInt8) g.ClipboardHandlerData.Data)
				g.ClipboardHandlerData[length] = 0
				CFRelease(cf_data)
				return g.ClipboardHandlerData.Data
			}
		}
	}

	return nil
}

} else { // preproc else

// Platform Dependents default implementation for ImGuiPlatformIO functions
// Win32 clipboard implementation
// We use g.ClipboardHandlerData for temporary storage to ensure it is freed on Shutdown()
// Local Dear ImGui-only clipboard implementation, if user hasn't defined better clipboard handlers.
Platform_GetClipboardTextFn_DefaultImpl :: proc(ctx : ^ImGuiContext) -> ^u8
{
	g : ^ImGuiContext = ctx
	return empty(&g.ClipboardHandlerData) ? nil : begin(&g.ClipboardHandlerData)
}

// OSX clipboard implementation
// If you enable this you will need to add '-framework ApplicationServices' to your linker command-line!
Platform_SetClipboardTextFn_DefaultImpl :: proc(ctx : ^ImGuiContext, text : ^u8)
{
	g : ^ImGuiContext = ctx
	clear(&g.ClipboardHandlerData)
	text_end : ^u8 = text + strlen(text)
	resize(&g.ClipboardHandlerData, cast(i32) (text_end - text) + 1)
	memcpy(&g.ClipboardHandlerData[0], text, cast(uint) (text_end - text))
	g.ClipboardHandlerData[cast(i32) (text_end - text)] = 0
}

} // preproc endif// Default clipboard handlers

//-----------------------------------------------------------------------------

when ! IMGUI_DISABLE_DEFAULT_SHELL_FUNCTIONS { // @gen ifndef
when ODIN_OS == .Windows { // @gen ifdef
Platform_OpenInShellFn_DefaultImpl :: proc(_ : ^ImGuiContext, path : string) -> bool
{
	return cast(win32.INT_PTR) cast(uintptr) win32shell.ShellExecuteA(nil, "open", str.clone_to_cstring(path), nil, nil, win32.SW_SHOWDEFAULT) > 32
}
} else { // preproc else
Platform_OpenInShellFn_DefaultImpl :: proc(_ : ^ImGuiContext, path : string) -> bool
{
	when ODIN_OS == .Darwin {
	args : [^]^u8 = {"open", "--", path, nil}
	} else { // preproc else
	args : [^]^u8 = {"xdg-open", path, nil}
	} // preproc endif
	pid : pid_t = fork()
	if pid < 0 { return false }
	if pid == {} {
		execvp(args[0], transmute(^^u8) args)
		exit(-1)
	}
	else {
		status : i32
		waitpid(pid, &status, 0)
		return WEXITSTATUS(status) == 0
	}
}
} // preproc endif
} else { // preproc else
Platform_OpenInShellFn_DefaultImpl :: proc(_ : ^ImGuiContext, _ : ^u8) -> bool { return false }
} // preproc endif// Default shell handlers

//-----------------------------------------------------------------------------

// Win32 API IME support (for Asian languages, etc.)
when ODIN_OS == .Windows && ! IMGUI_DISABLE_WIN32_FUNCTIONS && !IMGUI_DISABLE_WIN32_DEFAULT_IME_FUNCTIONS {

Platform_SetImeDataFn_DefaultImpl :: proc(_ : ^ImGuiContext, viewport : ^ImGuiViewport, data : ^ImGuiPlatformImeData)
{
	// Notify OS Input Method Editor of text input position
	hwnd := cast(win32.HWND) viewport.PlatformHandleRaw
	if hwnd == {} { return }

	//::ImmAssociateContextEx(hwnd, NULL, data->WantVisible ? IACE_DEFAULT : 0);
	if himc := win32imm.ImmGetContext(hwnd); himc != {} {
		composition_form : win32imm.COMPOSITIONFORM = {}
		composition_form.ptCurrentPos.x = cast(win32.LONG) (data.InputPos.x - viewport.Pos.x)
		composition_form.ptCurrentPos.y = cast(win32.LONG) (data.InputPos.y - viewport.Pos.y)
		composition_form.dwStyle = win32imm.CFS_FORCE_POSITION
		win32imm.ImmSetCompositionWindow(himc, &composition_form)
		candidate_form : win32imm.CANDIDATEFORM = {}
		candidate_form.dwStyle = win32imm.CFS_CANDIDATEPOS
		candidate_form.ptCurrentPos.x = cast(win32.LONG) (data.InputPos.x - viewport.Pos.x)
		candidate_form.ptCurrentPos.y = cast(win32.LONG) (data.InputPos.y - viewport.Pos.y)
		win32imm.ImmSetCandidateWindow(himc, &candidate_form)
		win32imm.ImmReleaseContext(hwnd, himc)
	}
}

} else { // preproc else

Platform_SetImeDataFn_DefaultImpl :: proc(_ : ^ImGuiContext, _ : ^ImGuiViewport, _ : ^ImGuiPlatformImeData) { }

} // preproc endif// Default IME handlers

//-----------------------------------------------------------------------------
// [SECTION] METRICS/DEBUGGER WINDOW
//-----------------------------------------------------------------------------
// - DebugRenderViewportThumbnail() [Internal]
// - RenderViewportsThumbnails() [Internal]
// - DebugTextEncoding()
// - MetricsHelpMarker() [Internal]
// - ShowFontAtlas() [Internal]
// - ShowMetricsWindow()
// - DebugNodeColumns() [Internal]
// - DebugNodeDockNode() [Internal]
// - DebugNodeDrawList() [Internal]
// - DebugNodeDrawCmdShowMeshAndBoundingBox() [Internal]
// - DebugNodeFont() [Internal]
// - DebugNodeFontGlyph() [Internal]
// - DebugNodeStorage() [Internal]
// - DebugNodeTabBar() [Internal]
// - DebugNodeViewport() [Internal]
// - DebugNodeWindow() [Internal]
// - DebugNodeWindowSettings() [Internal]
// - DebugNodeWindowsList() [Internal]
// - DebugNodeWindowsListByBeginStackParent() [Internal]
//-----------------------------------------------------------------------------

when ! IMGUI_DISABLE_DEBUG_TOOLS { /* @gen ifndef */

DebugRenderViewportThumbnail :: proc(draw_list : ^ImDrawList, viewport : ^ImGuiViewportP, bb : ImRect)
{
	g : ^ImGuiContext = GImGui
	window : ^ImGuiWindow = g.CurrentWindow

	scale : ImVec2 = GetSize(bb) / viewport.Size
	off : ImVec2 = bb.Min - viewport.Pos * scale
	alpha_mul : f32 = (viewport.Flags & ImGuiViewportFlags_.ImGuiViewportFlags_IsMinimized) != {} ? 0.30 : 1.00
	AddRectFilled(window.DrawList, bb.Min, bb.Max, GetColorU32(ImGuiCol_.ImGuiCol_Border, alpha_mul * 0.40))
	for thumb_window in g.Windows.Data[:g.Windows.Size] {
		if !thumb_window.WasActive || (thumb_window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_ChildWindow) != {} { continue }
		if thumb_window.Viewport != viewport { continue }

		thumb_r : ImRect = Rect(thumb_window)
		title_r : ImRect = TitleBarRect(thumb_window)
		thumb_r = ImRect{ImTrunc(off + thumb_r.Min * scale), ImTrunc(off + thumb_r.Max * scale)}
		title_r = ImRect{ImTrunc(off + title_r.Min * scale), ImTrunc(off + ImVec2{title_r.Max.x, title_r.Min.y + GetHeight(title_r) * 3.0} * scale)}; // Exaggerate title bar height
		ClipWithFull(&thumb_r, bb)
		ClipWithFull(&title_r, bb)
		window_is_focused : bool = (g.NavWindow != nil && thumb_window.RootWindowForTitleBarHighlight == g.NavWindow.RootWindowForTitleBarHighlight)
		AddRectFilled(window.DrawList, thumb_r.Min, thumb_r.Max, GetColorU32(ImGuiCol_.ImGuiCol_WindowBg, alpha_mul))
		AddRectFilled(window.DrawList, title_r.Min, title_r.Max, GetColorU32(window_is_focused ? ImGuiCol_.ImGuiCol_TitleBgActive : ImGuiCol_.ImGuiCol_TitleBg, alpha_mul))
		AddRect(window.DrawList, thumb_r.Min, thumb_r.Max, GetColorU32(ImGuiCol_.ImGuiCol_Border, alpha_mul))
		AddText(window.DrawList, g.Font, g.FontSize * 1.0, title_r.Min, GetColorU32(ImGuiCol_.ImGuiCol_Text, alpha_mul), thumb_window.Name[:FindRenderedTextEnd(thumb_window.Name)])
	}

	AddRect(draw_list, bb.Min, bb.Max, GetColorU32(ImGuiCol_.ImGuiCol_Border, alpha_mul))
	if viewport.ID == g.DebugMetricsConfig.HighlightViewportID { AddRect(window.DrawList, bb.Min, bb.Max, IM_COL32(255, 255, 0, 255)) }
}

RenderViewportsThumbnails :: proc()
{
	g : ^ImGuiContext = GImGui
	window : ^ImGuiWindow = g.CurrentWindow

	// Draw monitor and calculate their boundaries
	SCALE : f32 = 1.0 / 8.0
	bb_full : ImRect; init(&bb_full, FLT_MAX, FLT_MAX, -FLT_MAX, -FLT_MAX)
	for monitor in g.PlatformIO.Monitors.Data[:g.PlatformIO.Monitors.Size] { Add(&bb_full, ImRect{monitor.MainPos, monitor.MainPos + monitor.MainSize}) }

	p : ImVec2 = window.DC.CursorPos
	off : ImVec2 = p - bb_full.Min * SCALE
	for &monitor in g.PlatformIO.Monitors.Data[:g.PlatformIO.Monitors.Size] {
		monitor_draw_bb : ImRect; init(&monitor_draw_bb, off + (monitor.MainPos) * SCALE, off + (monitor.MainPos + monitor.MainSize) * SCALE)
		AddRect(window.DrawList, monitor_draw_bb.Min, monitor_draw_bb.Max, (g.DebugMetricsConfig.HighlightMonitorIdx == index_from_ptr(&g.PlatformIO.Monitors, &monitor)) ? IM_COL32(255, 255, 0, 255) : GetColorU32(ImGuiCol_.ImGuiCol_Border), 4.0)
		AddRectFilled(window.DrawList, monitor_draw_bb.Min, monitor_draw_bb.Max, GetColorU32(ImGuiCol_.ImGuiCol_Border, 0.10), 4.0)
	}

	// Draw viewports
	for viewport in g.Viewports.Data[:g.Viewports.Size] {
		viewport_draw_bb : ImRect; init(&viewport_draw_bb, off + (viewport.Pos) * SCALE, off + (viewport.Pos + viewport.Size) * SCALE)
		DebugRenderViewportThumbnail(window.DrawList, viewport, viewport_draw_bb)
	}

	Dummy(GetSize(bb_full) * SCALE)
}

ViewportComparerByLastFocusedStampCount :: proc(a, b : ^ImGuiViewportP) -> slice.Ordering
{
	return slice.Ordering(b.LastFocusedStampCount - a.LastFocusedStampCount)
}

// Draw an arbitrary US keyboard layout to visualize translated keys
DebugRenderKeyboardPreview :: proc(draw_list : ^ImDrawList)
{
	scale : f32 = GetFontSize() / 13.0
	key_size : ImVec2 = ImVec2{35.0, 35.0} * scale
	key_rounding : f32 = 3.0 * scale
	key_face_size : ImVec2 = ImVec2{25.0, 25.0} * scale
	key_face_pos : ImVec2 = ImVec2{5.0, 3.0} * scale
	key_face_rounding : f32 = 2.0 * scale
	key_label_pos : ImVec2 = ImVec2{7.0, 4.0} * scale
	key_step : ImVec2 = ImVec2{key_size.x - 1.0, key_size.y - 1.0}
	key_row_offset : f32 = 9.0 * scale

	board_min : ImVec2 = GetCursorScreenPos()
	board_max : ImVec2 = ImVec2{board_min.x + 3 * key_step.x + 2 * key_row_offset + 10.0, board_min.y + 3 * key_step.y + 10.0}
	start_pos : ImVec2 = ImVec2{board_min.x + 5.0 - key_step.x, board_min.y}

	KeyLayoutData :: struct { Row : i32, Col : i32, label : string, Key : ImGuiKey, }
	keys_to_display := [?]KeyLayoutData {
		{0, 0, "", ImGuiKey.ImGuiKey_Tab}, {0, 1, "Q", ImGuiKey.ImGuiKey_Q}, {0, 2, "W", ImGuiKey.ImGuiKey_W}, {0, 3, "E", ImGuiKey.ImGuiKey_E}, {0, 4, "R", ImGuiKey.ImGuiKey_R},
		{1, 0, "", ImGuiKey.ImGuiKey_CapsLock}, {1, 1, "A", ImGuiKey.ImGuiKey_A}, {1, 2, "S", ImGuiKey.ImGuiKey_S}, {1, 3, "D", ImGuiKey.ImGuiKey_D}, {1, 4, "F", ImGuiKey.ImGuiKey_F},
		{2, 0, "", ImGuiKey.ImGuiKey_LeftShift}, {2, 1, "Z", ImGuiKey.ImGuiKey_Z}, {2, 2, "X", ImGuiKey.ImGuiKey_X}, {2, 3, "C", ImGuiKey.ImGuiKey_C}, {2, 4, "V", ImGuiKey.ImGuiKey_V},
	}

	// Elements rendered manually via ImDrawList API are not clipped automatically.
	// While not strictly necessary, here IsItemVisible() is used to avoid rendering these shapes when they are out of view.
	Dummy(board_max - board_min)
	if !IsItemVisible() { return }
	PushClipRect(draw_list, board_min, board_max, true)
	for n : i32 = 0; n < cast(i32)IM_ARRAYSIZE(keys_to_display); n += 1 {
		key_data : ^KeyLayoutData = &keys_to_display[n]
		key_min : ImVec2 = ImVec2{start_pos.x + f32(key_data.Col) * key_step.x + f32(key_data.Row) * key_row_offset, start_pos.y + f32(key_data.Row) * key_step.y}
		key_max : ImVec2 = key_min + key_size
		AddRectFilled(draw_list, key_min, key_max, IM_COL32(204, 204, 204, 255), key_rounding)
		AddRect(draw_list, key_min, key_max, IM_COL32(24, 24, 24, 255), key_rounding)
		face_min : ImVec2 = ImVec2{key_min.x + key_face_pos.x, key_min.y + key_face_pos.y}
		face_max : ImVec2 = ImVec2{face_min.x + key_face_size.x, face_min.y + key_face_size.y}
		AddRect(draw_list, face_min, face_max, IM_COL32(193, 193, 193, 255), key_face_rounding, ImDrawFlags_.ImDrawFlags_None, 2.0)
		AddRectFilled(draw_list, face_min, face_max, IM_COL32(252, 252, 252, 255), key_face_rounding)
		label_min : ImVec2 = ImVec2{key_min.x + key_label_pos.x, key_min.y + key_label_pos.y}
		AddText(draw_list, label_min, IM_COL32(64, 64, 64, 255), key_data.label)
		if IsKeyDown(key_data.Key) { AddRectFilled(draw_list, key_min, key_max, IM_COL32(255, 0, 0, 128), key_rounding) }
	}

	PopClipRect(draw_list)
}

// Debug Utilities
// - Your main debugging friend is the ShowMetricsWindow() function, which is also accessible from Demo->Tools->Metrics Debugger
// Helper tool to diagnose between text encoding issues and font loading issues. Pass your UTF-8 string and verify that there are correct.
DebugTextEncoding :: proc(str : string)
{
	Text("Text: \"%s\"", str)
	if !BeginTable("##DebugTextEncoding", 4, ImGuiTableFlags_.ImGuiTableFlags_Borders | ImGuiTableFlags_.ImGuiTableFlags_RowBg | ImGuiTableFlags_.ImGuiTableFlags_SizingFixedFit | ImGuiTableFlags_.ImGuiTableFlags_Resizable) { return }
	TableSetupColumn("Offset")
	TableSetupColumn("UTF-8")
	TableSetupColumn("Glyph")
	TableSetupColumn("Codepoint")
	TableHeadersRow()
	start := raw_data(str)
	for p := start; p[0] != 0;  {
		c : u32
		c_utf8_len : i32 = ImTextCharFromUtf8(&c, p, nil)
		TableNextColumn()
		Text("%d", cast(i32) mem.ptr_sub(p, start))
		TableNextColumn()
		for byte_index : i32 = 0; byte_index < c_utf8_len; byte_index += 1 {
			if byte_index > 0 { SameLine() }
			Text("0x%02X", cast(i32) cast(u8) p[byte_index])
		}

		TableNextColumn()
		if FindGlyphNoFallback(GetFont(), cast(ImWchar) c) != nil { TextUnformatted(string_from_slice(p[:c_utf8_len], false)) }
		else { TextUnformatted((c == IM_UNICODE_CODEPOINT_INVALID) ? "[invalid]" : "[missing]") }
		TableNextColumn()
		Text("U+%04X", cast(i32) c)
		p = p[c_utf8_len:]
	}

	EndTable()
}

DebugFlashStyleColorStop :: proc()
{
	g : ^ImGuiContext = GImGui
	if g.DebugFlashStyleColorIdx != ImGuiCol_.ImGuiCol_COUNT { g.Style.Colors[g.DebugFlashStyleColorIdx] = g.DebugFlashStyleColorBackup }
	g.DebugFlashStyleColorIdx = ImGuiCol_.ImGuiCol_COUNT
}

// Flash a given style color for some + inhibit modifications of this color via PushStyleColor() calls.
DebugFlashStyleColor :: proc(idx : ImGuiCol)
{
	g : ^ImGuiContext = GImGui
	DebugFlashStyleColorStop()
	g.DebugFlashStyleColorTime = 0.5
	g.DebugFlashStyleColorIdx = idx
	g.DebugFlashStyleColorBackup = g.Style.Colors[idx]
}

UpdateDebugToolFlashStyleColor :: proc()
{
	g : ^ImGuiContext = GImGui
	if g.DebugFlashStyleColorTime <= 0.0 { return }
	ColorConvertHSVtoRGB(ImCos(g.DebugFlashStyleColorTime * 6.0) * 0.5 + 0.5, 0.5, 0.5, &g.Style.Colors[g.DebugFlashStyleColorIdx].x, &g.Style.Colors[g.DebugFlashStyleColorIdx].y, &g.Style.Colors[g.DebugFlashStyleColorIdx].z)
	g.Style.Colors[g.DebugFlashStyleColorIdx].w = 1.0
	g.DebugFlashStyleColorTime -= g.IO.DeltaTime
	if g.DebugFlashStyleColorTime <= 0.0 { DebugFlashStyleColorStop() }
}

FormatTextureIDForDebugDisplay :: proc(buf : []u8, tex_id : ImTextureID) -> string
{
	tex_id_opaque : struct #raw_union { ptr : rawptr, integer : i32, }
	tex_id := tex_id
	memcpy(&tex_id_opaque, &tex_id, ImMin(size_of(rawptr), size_of(tex_id)))
	if size_of(tex_id) >= size_of(rawptr) { ImFormatString(buf, "0x%p", tex_id_opaque.ptr) }
	else { ImFormatString(buf, "0x%04X", tex_id_opaque.integer) }
	return string_from_slice(buf)
}

// Avoid naming collision with imgui_demo.cpp's HelpMarker() for unity builds.
MetricsHelpMarker :: proc(desc : string)
{
	TextDisabled("(?)")
	if BeginItemTooltip() {
		PushTextWrapPos(GetFontSize() * 35.0)
		TextUnformatted(desc)
		PopTextWrapPos()
		EndTooltip()
	}
}

// [DEBUG] List fonts in a font atlas and display its texture
ShowFontAtlas :: proc(atlas : ^ImFontAtlas)
{
	for font in atlas.Fonts.Data[:atlas.Fonts.Size] {
		PushID(font)
		DebugNodeFont(font)
		PopID()
	}

	if TreeNode("Font Atlas", "Font Atlas (%dx%d pixels)", atlas.TexWidth, atlas.TexHeight) {
		g : ^ImGuiContext = GImGui
		cfg : ^ImGuiMetricsConfig = &g.DebugMetricsConfig
		Checkbox("Tint with Text Color", &cfg.ShowAtlasTintedWithTextColor); // Using text color ensure visibility of core atlas data, but will alter custom colored icons
		tint_col : ImVec4 = cfg.ShowAtlasTintedWithTextColor ? GetStyleColorVec4(ImGuiCol_.ImGuiCol_Text) : ImVec4{1.0, 1.0, 1.0, 1.0}
		border_col : ImVec4 = GetStyleColorVec4(ImGuiCol_.ImGuiCol_Border)
		Image(atlas.TexID, ImVec2{cast(f32) atlas.TexWidth, cast(f32) atlas.TexHeight}, ImVec2{0.0, 0.0}, ImVec2{1.0, 1.0}, tint_col, border_col)
		TreePop()
	}
}

// create Metrics/Debugger window. display Dear ImGui internals: windows, draw commands, various internal state, etc.
ShowMetricsWindow :: proc(p_open : ^bool)
{
	g : ^ImGuiContext = GImGui
	io : ^ImGuiIO = &g.IO
	cfg : ^ImGuiMetricsConfig = &g.DebugMetricsConfig
	if cfg.ShowDebugLog { ShowDebugLogWindow(&cfg.ShowDebugLog) }
	if cfg.ShowIDStackTool { ShowIDStackToolWindow(&cfg.ShowIDStackTool) }

	if !Begin("Dear ImGui Metrics/Debugger", p_open) || GetCurrentWindow().BeginCount > 1 {
		End()
		return
	}

	// [DEBUG] Clear debug breaks hooks after exactly one cycle.
	DebugBreakClearData()

	// Basic info
	Text("Dear ImGui %s (%d)", IMGUI_VERSION, IMGUI_VERSION_NUM)
	if g.ContextName[0] != 0 {
		SameLine()
		Text("(Context Name: \"%s\")", g.ContextName)
	}
	Text("Application average %.3f ms/frame (%.1f FPS)", 1000.0 / io.Framerate, io.Framerate)
	Text("%d vertices, %d indices (%d triangles)", io.MetricsRenderVertices, io.MetricsRenderIndices, io.MetricsRenderIndices / 3)
	Text("%d visible windows, %d current allocations", io.MetricsRenderWindows, g.DebugAllocInfo.TotalAllocCount - g.DebugAllocInfo.TotalFreeCount)
	//SameLine(); if (SmallButton("GC")) { g.GcCompactAll = true; }

	Separator()

	// Debugging enums
	E0 :: enum i32 { WRT_OuterRect, WRT_OuterRectClipped, WRT_InnerRect, WRT_InnerClipRect, WRT_WorkRect, WRT_Content, WRT_ContentIdeal, WRT_ContentRegionRect, WRT_Count, }// Windows Rect Type
	wrt_rects_names : [E0.WRT_Count]string = {"OuterRect", "OuterRectClipped", "InnerRect", "InnerClipRect", "WorkRect", "Content", "ContentIdeal", "ContentRegionRect"}
	E1 :: enum i32 { TRT_OuterRect, TRT_InnerRect, TRT_WorkRect, TRT_HostClipRect, TRT_InnerClipRect, TRT_BackgroundClipRect, TRT_ColumnsRect, TRT_ColumnsWorkRect, TRT_ColumnsClipRect, TRT_ColumnsContentHeadersUsed, TRT_ColumnsContentHeadersIdeal, TRT_ColumnsContentFrozen, TRT_ColumnsContentUnfrozen, TRT_Count, }// Tables Rect Type
	trt_rects_names : [E1.TRT_Count]string = {"OuterRect", "InnerRect", "WorkRect", "HostClipRect", "InnerClipRect", "BackgroundClipRect", "ColumnsRect", "ColumnsWorkRect", "ColumnsClipRect", "ColumnsContentHeadersUsed", "ColumnsContentHeadersIdeal", "ColumnsContentFrozen", "ColumnsContentUnfrozen"}
	if cfg.ShowWindowsRectsType < 0 { cfg.ShowWindowsRectsType = cast(i32)E0.WRT_WorkRect }
	if cfg.ShowTablesRectsType < 0 { cfg.ShowTablesRectsType = cast(i32)E1.TRT_WorkRect }

	Funcs_GetTableRect :: proc(table : ^ImGuiTable, rect_type : E1, n : i32) -> ImRect
	{
		table_instance : ^ImGuiTableInstanceData = TableGetInstanceData(table, i32(table.InstanceCurrent)); // Always using last submitted instance
		if rect_type == E1.TRT_OuterRect { return table.OuterRect }
		else if rect_type == E1.TRT_InnerRect { return table.InnerRect }
		else if rect_type == E1.TRT_WorkRect { return table.WorkRect }
		else if rect_type == E1.TRT_HostClipRect { return table.HostClipRect }
		else if rect_type == E1.TRT_InnerClipRect { return table.InnerClipRect }
		else if rect_type == E1.TRT_BackgroundClipRect { return table.BgClipRect }
		else if rect_type == E1.TRT_ColumnsRect {c : ^ImGuiTableColumn = &table.Columns.Data[n]; return ImRect{{c.MinX, table.InnerClipRect.Min.y}, {c.MaxX, table.InnerClipRect.Min.y + table_instance.LastOuterHeight}} }
		else if rect_type == E1.TRT_ColumnsWorkRect {c : ^ImGuiTableColumn = &table.Columns.Data[n]; return ImRect{{c.WorkMinX, table.WorkRect.Min.y}, {c.WorkMaxX, table.WorkRect.Max.y}} }
		else if rect_type == E1.TRT_ColumnsClipRect {c : ^ImGuiTableColumn = &table.Columns.Data[n]; return c.ClipRect }
		else if rect_type == E1.TRT_ColumnsContentHeadersUsed {
			// Note: y1/y2 not always accurate
			c : ^ImGuiTableColumn = &table.Columns.Data[n]; return ImRect{{c.WorkMinX, table.InnerClipRect.Min.y}, {c.ContentMaxXHeadersUsed, table.InnerClipRect.Min.y + table_instance.LastTopHeadersRowHeight}}
		}
		else if rect_type == E1.TRT_ColumnsContentHeadersIdeal {c : ^ImGuiTableColumn = &table.Columns.Data[n]; return ImRect{{c.WorkMinX, table.InnerClipRect.Min.y}, {c.ContentMaxXHeadersIdeal, table.InnerClipRect.Min.y + table_instance.LastTopHeadersRowHeight}} }
		else if rect_type == E1.TRT_ColumnsContentFrozen {c : ^ImGuiTableColumn = &table.Columns.Data[n]; return ImRect{{c.WorkMinX, table.InnerClipRect.Min.y}, {c.ContentMaxXFrozen, table.InnerClipRect.Min.y + table_instance.LastFrozenHeight}} }
		else if rect_type == E1.TRT_ColumnsContentUnfrozen {c : ^ImGuiTableColumn = &table.Columns.Data[n]; return ImRect{{c.WorkMinX, table.InnerClipRect.Min.y + table_instance.LastFrozenHeight}, {c.ContentMaxXUnfrozen, table.InnerClipRect.Max.y}} }
		IM_ASSERT(false)
		return ImRect{}
	}

	Funcs_GetWindowRect :: proc(window : ^ImGuiWindow, rect_type : E0) -> ImRect
	{
		if rect_type == E0.WRT_OuterRect { return Rect(window) }
		else if rect_type == E0.WRT_OuterRectClipped { return window.OuterRectClipped }
		else if rect_type == E0.WRT_InnerRect { return window.InnerRect }
		else if rect_type == E0.WRT_InnerClipRect { return window.InnerClipRect }
		else if rect_type == E0.WRT_WorkRect { return window.WorkRect }
		else if rect_type == E0.WRT_Content {min : ImVec2 = window.InnerRect.Min - window.Scroll + window.WindowPadding; return ImRect{min, min + window.ContentSize} }
		else if rect_type == E0.WRT_ContentIdeal {min : ImVec2 = window.InnerRect.Min - window.Scroll + window.WindowPadding; return ImRect{min, min + window.ContentSizeIdeal} }
		else if rect_type == E0.WRT_ContentRegionRect { return window.ContentRegionRect }
		IM_ASSERT(false)
		return ImRect{}
	}

	// Tools
	if TreeNode("Tools") {
		// Debug Break features
		// The Item Picker tool is super useful to visually select an item and break into the call-stack of where it was submitted.
		SeparatorTextEx(0, "Debug breaks", CalcTextSize("(?)").x + g.Style.SeparatorTextPadding.x)
		SameLine()
		MetricsHelpMarker("Will call the IM_DEBUG_BREAK() macro to break in debugger.\nWarning: If you don't have a debugger attached, this will probably crash.")
		if Checkbox("Show Item Picker", &g.DebugItemPickerActive) && g.DebugItemPickerActive { DebugStartItemPicker() }
		Checkbox("Show \"Debug Break\" buttons in other sections (io.ConfigDebugIsDebuggerPresent)", &g.IO.ConfigDebugIsDebuggerPresent)

		SeparatorText("Visualize")

		Checkbox("Show Debug Log", &cfg.ShowDebugLog)
		SameLine()
		MetricsHelpMarker("You can also call ImGui::ShowDebugLogWindow() from your code.")

		Checkbox("Show ID Stack Tool", &cfg.ShowIDStackTool)
		SameLine()
		MetricsHelpMarker("You can also call ImGui::ShowIDStackToolWindow() from your code.")

		Checkbox("Show windows begin order", &cfg.ShowWindowsBeginOrder)
		Checkbox("Show windows rectangles", &cfg.ShowWindowsRects)
		SameLine()
		SetNextItemWidth(GetFontSize() * 12)
		cfg.ShowWindowsRects |= Combo("##show_windows_rect_type", &cfg.ShowWindowsRectsType, wrt_rects_names[:], i32(E0.WRT_Count))
		if cfg.ShowWindowsRects && g.NavWindow != nil {
			BulletText("'%s':", g.NavWindow.Name)
			Indent()
			for rect_n := E0(0); rect_n < E0.WRT_Count; rect_n += E0(1) {
				r : ImRect = Funcs_GetWindowRect(g.NavWindow, rect_n)
				Text("(%6.1f,%6.1f) (%6.1f,%6.1f) Size (%6.1f,%6.1f) %s", r.Min.x, r.Min.y, r.Max.x, r.Max.y, GetWidth(r), GetHeight(r), wrt_rects_names[rect_n])
			}

			Unindent()
		}

		Checkbox("Show tables rectangles", &cfg.ShowTablesRects)
		SameLine()
		SetNextItemWidth(GetFontSize() * 12)
		cfg.ShowTablesRects |= Combo("##show_table_rects_type", &cfg.ShowTablesRectsType, trt_rects_names[:], i32(E1.TRT_Count))
		if cfg.ShowTablesRects && g.NavWindow != nil {
			for table_n : i32 = 0; table_n < GetMapSize(&g.Tables); table_n += 1 {
				table : ^ImGuiTable = TryGetMapData(&g.Tables, table_n)
				if table == nil || table.LastFrameActive < g.FrameCount - 1 || (table.OuterWindow != g.NavWindow && table.InnerWindow != g.NavWindow) { continue }

				BulletText("Table 0x%08X (%d columns, in '%s')", table.ID, table.ColumnsCount, table.OuterWindow.Name)
				if IsItemHovered() { AddRect(GetForegroundDrawList(), table.OuterRect.Min - ImVec2{1, 1}, table.OuterRect.Max + ImVec2{1, 1}, IM_COL32(255, 255, 0, 255), 0.0, {}, 2.0) }
				Indent()
				buf : [128]u8
				for rect_n := E1(0); rect_n < E1.TRT_Count; rect_n += E1(1) {
					if rect_n >= E1.TRT_ColumnsRect {
						if rect_n != E1.TRT_ColumnsRect && rect_n != E1.TRT_ColumnsClipRect { continue }
						for column_n : i32 = 0; column_n < table.ColumnsCount; column_n += 1 {
							r : ImRect = Funcs_GetTableRect(table, rect_n, column_n)
							l := ImFormatString(buf[:], "(%6.1f,%6.1f) (%6.1f,%6.1f) Size (%6.1f,%6.1f) Col %d %s", r.Min.x, r.Min.y, r.Max.x, r.Max.y, GetWidth(r), GetHeight(r), column_n, trt_rects_names[rect_n])
							Selectable(string_from_slice(buf[:l], false))
							if IsItemHovered() { AddRect(GetForegroundDrawList(), r.Min - ImVec2{1, 1}, r.Max + ImVec2{1, 1}, IM_COL32(255, 255, 0, 255), 0.0, {}, 2.0) }
						}
					}
					else {
						r : ImRect = Funcs_GetTableRect(table, rect_n, -1)
						l := ImFormatString(buf[:], "(%6.1f,%6.1f) (%6.1f,%6.1f) Size (%6.1f,%6.1f) %s", r.Min.x, r.Min.y, r.Max.x, r.Max.y, GetWidth(r), GetHeight(r), trt_rects_names[rect_n])
						Selectable(string_from_slice(buf[:l], false))
						if IsItemHovered() { AddRect(GetForegroundDrawList(), r.Min - ImVec2{1, 1}, r.Max + ImVec2{1, 1}, IM_COL32(255, 255, 0, 255), 0.0, {}, 2.0) }
					}
				}

				Unindent()
			}
		}
		Checkbox("Show groups rectangles", &g.DebugShowGroupRects); // Storing in context as this is used by group code and prefers to be in hot-data

		SeparatorText("Validate")

		Checkbox("Debug Begin/BeginChild return value", &io.ConfigDebugBeginReturnValueLoop)
		SameLine()
		MetricsHelpMarker("Some calls to Begin()/BeginChild() will return false.\n\nWill cycle through window depths then repeat. Windows should be flickering while running.")

		Checkbox("UTF-8 Encoding viewer", &cfg.ShowTextEncodingViewer)
		SameLine()
		MetricsHelpMarker("You can also call ImGui::DebugTextEncoding() from your code with a given string to test that your UTF-8 encoding settings are correct.")
		if cfg.ShowTextEncodingViewer {
			buf : [64]u8
			SetNextItemWidth(-FLT_MIN)
			InputText("##DebugTextEncodingBuf", buf[:])
			if buf[0] != 0 { DebugTextEncoding(string_from_slice(buf[:])) }
		}

		TreePop()
	}

	// Windows
	if TreeNode("Windows", "Windows (%d)", g.Windows.Size) {
		//SetNextItemOpen(true, ImGuiCond_Once);
		DebugNodeWindowsList(&g.Windows, "By display order")
		DebugNodeWindowsList(&g.WindowsFocusOrder, "By focus order (root windows)")
		if TreeNode("By submission order (begin stack)") {
			// Here we display windows in their submitted order/hierarchy, however note that the Begin stack doesn't constitute a Parent<>Child relationship!
			temp_buffer : ^ImVector(^ImGuiWindow) = &g.WindowsTempSortBuffer
			resize(temp_buffer, 0)
			for window in g.Windows.Data[:g.Windows.Size] { if window.LastFrameActive + 1 >= g.FrameCount { push_back(temp_buffer, window) } }

			Func_WindowComparerByBeginOrder :: proc(lhs, rhs : ^ImGuiWindow) -> slice.Ordering { return slice.Ordering(lhs.BeginOrderWithinContext - rhs.BeginOrderWithinContext) }

			ImQsort(temp_buffer.Data[:temp_buffer.Size], Func_WindowComparerByBeginOrder)
			DebugNodeWindowsListByBeginStackParent(temp_buffer.Data[:temp_buffer.Size], nil)
			TreePop()
		}

		TreePop()
	}

	// DrawLists
	drawlist_count : i32 = 0
	for viewport in g.Viewports.Data[:g.Viewports.Size] { drawlist_count += viewport.DrawDataP.CmdLists.Size }

	if TreeNode("DrawLists", "DrawLists (%d)", drawlist_count) {
		Checkbox("Show ImDrawCmd mesh when hovering", &cfg.ShowDrawCmdMesh)
		Checkbox("Show ImDrawCmd bounding boxes when hovering", &cfg.ShowDrawCmdBoundingBoxes)
		for viewport in g.Viewports.Data[:g.Viewports.Size] {
			viewport_has_drawlist : bool = false
			for draw_list in viewport.DrawDataP.CmdLists.Data[:viewport.DrawDataP.CmdLists.Size] {
				if !viewport_has_drawlist { Text("Active DrawLists in Viewport #%d, ID: 0x%08X", viewport.Idx, viewport.ID) }
				viewport_has_drawlist = true
				DebugNodeDrawList(nil, viewport, draw_list, "DrawList")
			}
		}

		TreePop()
	}

	// Viewports
	if TreeNode("Viewports", "Viewports (%d)", g.Viewports.Size) {
		cfg.HighlightMonitorIdx = -1
		open : bool = TreeNode("Monitors", "Monitors (%d)", g.PlatformIO.Monitors.Size)
		SameLine()
		MetricsHelpMarker("Dear ImGui uses monitor data:\n- to query DPI settings on a per monitor basis\n- to position popup/tooltips so they don't straddle monitors.")
		if open {
			for i : i32 = 0; i < g.PlatformIO.Monitors.Size; i += 1 {
				DebugNodePlatformMonitor(&g.PlatformIO.Monitors.Data[i], "Monitor", i)
				if IsItemHovered() { cfg.HighlightMonitorIdx = i }
			}

			DebugNodePlatformMonitor(&g.FallbackMonitor, "Fallback", 0)
			TreePop()
		}

		SetNextItemOpen(true, ImGuiCond_.ImGuiCond_Once)
		if TreeNode("Windows Minimap") {
			RenderViewportsThumbnails()
			TreePop()
		}
		cfg.HighlightViewportID = 0

		BulletText("MouseViewport: 0x%08X (UserHovered 0x%08X, LastHovered 0x%08X)", g.MouseViewport != nil ? g.MouseViewport.ID : 0, g.IO.MouseHoveredViewport, g.MouseLastHoveredViewport != nil ? g.MouseLastHoveredViewport.ID : 0)
		if TreeNode("Inferred Z order (front-to-back)") {
			viewports : ImVector(^ImGuiViewportP)
			resize(&viewports, g.Viewports.Size)
			memcpy(viewports.Data, g.Viewports.Data, cast(int)size_in_bytes(&g.Viewports))
			if viewports.Size > 1 { ImQsort(viewports.Data[:viewports.Size], ViewportComparerByLastFocusedStampCount) }
			for viewport in viewports.Data[:viewports.Size] {
				BulletText("Viewport #%d, ID: 0x%08X, LastFocused = %08d, PlatformFocused = %s, Window: \"%s\"", viewport.Idx, viewport.ID, viewport.LastFocusedStampCount, (g.PlatformIO.Platform_GetWindowFocus != nil && viewport.PlatformWindowCreated) ? (g.PlatformIO.Platform_GetWindowFocus(viewport) ? "1" : "0") : "N/A", viewport.Window != nil ? viewport.Window.Name : "N/A")
				if IsItemHovered() { cfg.HighlightViewportID = viewport.ID }
			}

			TreePop()
		}

		for viewport in g.Viewports.Data[:g.Viewports.Size] { DebugNodeViewport(viewport) }

		TreePop()
	}

	// Details for Popups
	if TreeNode("Popups", "Popups (%d)", g.OpenPopupStack.Size) {
		for popup_data in g.OpenPopupStack.Data[:g.OpenPopupStack.Size] {
			// As it's difficult to interact with tree nodes while popups are open, we display everything inline.
			window : ^ImGuiWindow = popup_data.Window
			BulletText("PopupID: %08x, Window: '%s' (%s%s), RestoreNavWindow '%s', ParentWindow '%s'", popup_data.PopupId, window != nil ? window.Name : "NULL", window != nil && (window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_ChildWindow) != {} ? "Child;" : "", window != nil && (window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_ChildMenu) != {} ? "Menu;" : "", popup_data.RestoreNavWindow != nil ? popup_data.RestoreNavWindow.Name : "NULL", window != nil && window.ParentWindow != nil ? window.ParentWindow.Name : "NULL")
		}

		TreePop()
	}

	// Details for TabBars
	if TreeNode("TabBars", "Tab Bars (%d)", GetAliveCount(&g.TabBars)) {
		for n : i32 = 0; n < GetMapSize(&g.TabBars); n += 1 { if tab_bar : ^ImGuiTabBar = TryGetMapData(&g.TabBars, n); tab_bar != nil {
	PushID(tab_bar)
	DebugNodeTabBar(tab_bar, "TabBar")
	PopID()
} }

		TreePop()
	}

	// Details for Tables
	if TreeNode("Tables", "Tables (%d)", GetAliveCount(&g.Tables)) {
		for n : i32 = 0; n < GetMapSize(&g.Tables); n += 1 { if table : ^ImGuiTable = TryGetMapData(&g.Tables, n); table != nil { DebugNodeTable(table) } }

		TreePop()
	}

	// Details for Fonts
	atlas : ^ImFontAtlas = g.IO.Fonts
	if TreeNode("Fonts", "Fonts (%d)", atlas.Fonts.Size) {
		ShowFontAtlas(atlas)
		TreePop()
	}

	// Details for InputText
	if TreeNode("InputText") {
		DebugNodeInputTextState(&g.InputTextState)
		TreePop()
	}

	// Details for TypingSelect
	if TreeNode("TypingSelect", "TypingSelect (%d)", g.TypingSelectState.SearchBuffer[0] != 0 ? 1 : 0) {
		DebugNodeTypingSelectState(&g.TypingSelectState)
		TreePop()
	}

	// Details for MultiSelect
	if TreeNode("MultiSelect", "MultiSelect (%d)", GetAliveCount(&g.MultiSelectStorage)) {
		bs : ^ImGuiBoxSelectState = &g.BoxSelectState
		BulletText("BoxSelect ID=0x%08X, Starting = %d, Active %d", bs.ID, bs.IsStarting, bs.IsActive)
		for n : i32 = 0; n < GetMapSize(&g.MultiSelectStorage); n += 1 { if state : ^ImGuiMultiSelectState = TryGetMapData(&g.MultiSelectStorage, n); state != nil { DebugNodeMultiSelectState(state) } }

		TreePop()
	}

	// Details for Docking
	when IMGUI_HAS_DOCK { /* @gen ifdef */
	if TreeNode("Docking") {
		root_nodes_only : bool = true
		dc : ^ImGuiDockContext = &g.DockContext
		Checkbox("List root nodes", &root_nodes_only)
		Checkbox("Ctrl shows window dock info", &cfg.ShowDockingNodes)
		if SmallButton("Clear nodes") { DockContextClearNodes(g, 0, true) }
		SameLine()
		if SmallButton("Rebuild all") { dc.WantFullRebuild = true }
		for n : i32 = 0; n < dc.Nodes.Data.Size; n += 1 { if node : ^ImGuiDockNode = cast(^ImGuiDockNode) dc.Nodes.Data.Data[n].val_p; node != nil { if !root_nodes_only || IsRootNode(node) { DebugNodeDockNode(node, "Node") } } }

		TreePop()
	}
	} // preproc endif// #ifdef IMGUI_HAS_DOCK

	// Settings
	if TreeNode("Settings") {
		if SmallButton("Clear") { ClearIniSettings() }
		SameLine()
		if SmallButton("Save to memory") { SaveIniSettingsToMemory() }
		SameLine()
		if SmallButton("Save to disk") { SaveIniSettingsToDisk(g.IO.IniFilename) }
		SameLine()
		if g.IO.IniFilename != "" { Text("\"%s\"", g.IO.IniFilename) }
		else { TextUnformatted("<NULL>") }
		Checkbox("io.ConfigDebugIniSettings", &io.ConfigDebugIniSettings)
		Text("SettingsDirtyTimer %.2f", g.SettingsDirtyTimer)
		if TreeNode("SettingsHandlers", "Settings handlers: (%d)", g.SettingsHandlers.Size) {
			for handler in g.SettingsHandlers.Data[:g.SettingsHandlers.Size] { BulletText("\"%s\"", handler.TypeName) }

			TreePop()
		}
		if TreeNode("SettingsWindows", "Settings packed data: Windows: %d bytes", size(&g.SettingsWindows)) {
			for settings : ^ImGuiWindowSettings = begin(&g.SettingsWindows); settings != nil; settings = next_chunk(&g.SettingsWindows, settings) { DebugNodeWindowSettings(settings) }

			TreePop()
		}

		if TreeNode("SettingsTables", "Settings packed data: Tables: %d bytes", size(&g.SettingsTables)) {
			for settings : ^ImGuiTableSettings = begin(&g.SettingsTables); settings != nil; settings = next_chunk(&g.SettingsTables, settings) { DebugNodeTableSettings(settings) }

			TreePop()
		}

		when IMGUI_HAS_DOCK { /* @gen ifdef */
		if TreeNode("SettingsDocking", "Settings packed data: Docking") {
			dc : ^ImGuiDockContext = &g.DockContext
			Text("In SettingsWindows:")
			for settings : ^ImGuiWindowSettings = begin(&g.SettingsWindows); settings != nil; settings = next_chunk(&g.SettingsWindows, settings) { if settings.DockId != 0 { BulletText("Window '%s' -> DockId %08X DockOrder=%d", GetName(settings), settings.DockId, settings.DockOrder) } }

			Text("In SettingsNodes:")
			for n : i32 = 0; n < dc.NodesSettings.Size; n += 1 {
				settings : ^ImGuiDockNodeSettings = &dc.NodesSettings.Data[n]
				selected_tab_name : string
				if settings.SelectedTabId != 0 {
					if window : ^ImGuiWindow = FindWindowByID(settings.SelectedTabId); window != nil { selected_tab_name = window.Name }
					else if window_settings : ^ImGuiWindowSettings = FindWindowSettingsByID(settings.SelectedTabId); window_settings != nil { selected_tab_name = string_from_cstr(cast(cstring) GetName(window_settings)) }
				}
				BulletText("Node %08X, Parent %08X, SelectedTab %08X ('%s')", settings.ID, settings.ParentNodeId, settings.SelectedTabId, selected_tab_name != "" ? selected_tab_name : settings.SelectedTabId != 0 ? "N/A" : "")
			}

			TreePop()
		}
		} // preproc endif// #ifdef IMGUI_HAS_DOCK

		if TreeNode("SettingsIniData", "Settings unpacked data (.ini): %d bytes", size(&g.SettingsIniData)) {
			InputTextMultiline("##Ini", c_str(&g.SettingsIniData)[:g.SettingsIniData.Buf.Size], ImVec2{-FLT_MIN, GetTextLineHeight() * 20}, ImGuiInputTextFlags_.ImGuiInputTextFlags_ReadOnly)
			TreePop()
		}
		TreePop()
	}

	// Settings
	if TreeNode("Memory allocations") {
		info : ^ImGuiDebugAllocInfo = &g.DebugAllocInfo
		Text("%d current allocations", info.TotalAllocCount - info.TotalFreeCount)
		if SmallButton("GC now") { g.GcCompactAll = true }
		Text("Recent frames with allocations:")
		buf_size := cast(i32)IM_ARRAYSIZE(info.LastEntriesBuf)
		for n : i32 = buf_size - 1; n >= 0; n -= 1 {
			entry : ^ImGuiDebugAllocEntry = &info.LastEntriesBuf[(i32(info.LastEntriesIdx) - n + buf_size) % buf_size]
			BulletText("Frame %06d: %+3d ( %2d alloc, %2d free )", entry.FrameCount, entry.AllocCount - entry.FreeCount, entry.AllocCount, entry.FreeCount)
			if n == 0 {
				SameLine()
				Text("<- %d frames ago", g.FrameCount - entry.FrameCount)
			}
		}

		TreePop()
	}

	if TreeNode("Inputs") {
		Text("KEYBOARD/GAMEPAD/MOUSE KEYS")
		{
		// User code should never have to go through such hoops! You can generally iterate between ImGuiKey_NamedKey_BEGIN and ImGuiKey_NamedKey_END.
		Indent()
		Text("Keys down:"); for key : ImGuiKey = ImGuiKey.ImGuiKey_NamedKey_BEGIN; key < ImGuiKey.ImGuiKey_NamedKey_END; key += ImGuiKey(1) {if !IsKeyDown(key) { continue }; SameLine(); Text(IsNamedKey(key) ? "\"%s\"" : "\"%s\" %d", GetKeyName(key), key); SameLine(); Text("(%.02f)", GetKeyData(key).DownDuration)		}

		Text("Keys pressed:"); for key : ImGuiKey = ImGuiKey.ImGuiKey_NamedKey_BEGIN; key < ImGuiKey.ImGuiKey_NamedKey_END; key += ImGuiKey(1) {if !IsKeyPressed(key) { continue }; SameLine(); Text(IsNamedKey(key) ? "\"%s\"" : "\"%s\" %d", GetKeyName(key), key)		}

		Text("Keys released:"); for key : ImGuiKey = ImGuiKey.ImGuiKey_NamedKey_BEGIN; key < ImGuiKey.ImGuiKey_NamedKey_END; key += ImGuiKey(1) {if !IsKeyReleased(key) { continue }; SameLine(); Text(IsNamedKey(key) ? "\"%s\"" : "\"%s\" %d", GetKeyName(key), key)		}

		Text("Keys mods: %s%s%s%s", io.KeyCtrl ? "CTRL " : "", io.KeyShift ? "SHIFT " : "", io.KeyAlt ? "ALT " : "", io.KeySuper ? "SUPER " : "")
		Text("Chars queue:"); for i : i32 = 0; i < io.InputQueueCharacters.Size; i += 1 {c : ImWchar = io.InputQueueCharacters.Data[i]; SameLine(); Text("\'%c\' (0x%04X)", (c > ' ' && c <= 255) ? cast(u8) c : '?', c)		}; 

// FIXME: We should convert 'c' to UTF-8 here but the functions are not public.
		DebugRenderKeyboardPreview(GetWindowDrawList())
		Unindent()
		}

		Text("MOUSE STATE")
		{
		Indent()
		if IsMousePosValid() { Text("Mouse pos: (%g, %g)", io.MousePos.x, io.MousePos.y) }
		else { Text("Mouse pos: <INVALID>") }
		Text("Mouse delta: (%g, %g)", io.MouseDelta.x, io.MouseDelta.y)
		count : i32 = cast(i32)IM_ARRAYSIZE(io.MouseDown)
		Text("Mouse down:"); for i : i32 = 0; i < count; i += 1 { if IsMouseDown(ImGuiMouseButton(i)) {SameLine(); Text("b%d (%.02f secs)", i, io.MouseDownDuration[i]) } }

		Text("Mouse clicked:"); for i : i32 = 0; i < count; i += 1 { if IsMouseClicked(ImGuiMouseButton(i)) {SameLine(); Text("b%d (%d)", i, io.MouseClickedCount[i]) } }

		Text("Mouse released:"); for i : i32 = 0; i < count; i += 1 { if IsMouseReleased(ImGuiMouseButton(i)) {SameLine(); Text("b%d", i) } }

		Text("Mouse wheel: %.1f", io.MouseWheel)
		Text("MouseStationaryTimer: %.2f", g.MouseStationaryTimer)
		Text("Mouse source: %s", GetMouseSourceName(io.MouseSource))
		Text("Pen Pressure: %.1f", io.PenPressure); // Note: currently unused
		Unindent()
		}

		Text("MOUSE WHEELING")
		{
		Indent()
		Text("WheelingWindow: '%s'", g.WheelingWindow != nil ? g.WheelingWindow.Name : "NULL")
		Text("WheelingWindowReleaseTimer: %.2f", g.WheelingWindowReleaseTimer)
		Text("WheelingAxisAvg[] = { %.3f, %.3f }, Main Axis: %s", g.WheelingAxisAvg.x, g.WheelingAxisAvg.y, (g.WheelingAxisAvg.x > g.WheelingAxisAvg.y) ? "X" : (g.WheelingAxisAvg.x < g.WheelingAxisAvg.y) ? "Y" : "<none>")
		Unindent()
		}

		Text("KEY OWNERS")
		{
		Indent()
		if BeginChild("##owners", ImVec2{-FLT_MIN, GetTextLineHeightWithSpacing() * 8}, ImGuiChildFlags_.ImGuiChildFlags_FrameStyle | ImGuiChildFlags_.ImGuiChildFlags_ResizeY, ImGuiWindowFlags_.ImGuiWindowFlags_NoSavedSettings) { for key : ImGuiKey = ImGuiKey.ImGuiKey_NamedKey_BEGIN; key < ImGuiKey.ImGuiKey_NamedKey_END; key += ImGuiKey(1) {
	owner_data : ^ImGuiKeyOwnerData = GetKeyOwnerData(g, key)
	if owner_data.OwnerCurr == ImGuiKeyOwner_NoOwner { continue }
	Text("%s: 0x%08X%s", GetKeyName(key), owner_data.OwnerCurr, owner_data.LockUntilRelease ? " LockUntilRelease" : owner_data.LockThisFrame ? " LockThisFrame" : "")
	DebugLocateItemOnHover(owner_data.OwnerCurr)
} }
		EndChild()
		Unindent()
		}
		Text("SHORTCUT ROUTING")
		SameLine()
		MetricsHelpMarker("Declared shortcut routes automatically set key owner when mods matches.")
		{
		Indent()
		if BeginChild("##routes", ImVec2{-FLT_MIN, GetTextLineHeightWithSpacing() * 8}, ImGuiChildFlags_.ImGuiChildFlags_FrameStyle | ImGuiChildFlags_.ImGuiChildFlags_ResizeY, ImGuiWindowFlags_.ImGuiWindowFlags_NoSavedSettings) { for key : ImGuiKey = ImGuiKey.ImGuiKey_NamedKey_BEGIN; key < ImGuiKey.ImGuiKey_NamedKey_END; key += key + ImGuiKey(1) {
	rt : ^ImGuiKeyRoutingTable = &g.KeysRoutingTable
	for idx : ImGuiKeyRoutingIndex = rt.Index[key - ImGuiKey.ImGuiKey_NamedKey_BEGIN]; idx != -1;  {
		routing_data : ^ImGuiKeyRoutingData = &rt.Entries.Data[idx]
		key_chord : ImGuiKeyChord = ImGuiKeyChord(key) | ImGuiKeyChord(routing_data.Mods)
		Text("%s: 0x%08X (scored %d)", GetKeyChordName(key_chord), routing_data.RoutingCurr, routing_data.RoutingCurrScore)
		DebugLocateItemOnHover(routing_data.RoutingCurr)
		if g.IO.ConfigDebugIsDebuggerPresent {
			SameLine()
			if DebugBreakButton("**DebugBreak**", "in SetShortcutRouting() for this KeyChord") { g.DebugBreakInShortcutRouting = key_chord }
		}
		idx = routing_data.NextEntryIndex
	}
} }
		EndChild()
		Text("(ActiveIdUsing: AllKeyboardKeys: %d, NavDirMask: 0x%X)", g.ActiveIdUsingAllKeyboardKeys, g.ActiveIdUsingNavDirMask)
		Unindent()
		}
		TreePop()
	}

	if TreeNode("Internal state") {
		Text("WINDOWING")
		Indent()
		Text("HoveredWindow: '%s'", g.HoveredWindow != nil ? g.HoveredWindow.Name : "NULL")
		Text("HoveredWindow->Root: '%s'", g.HoveredWindow != nil ? g.HoveredWindow.RootWindowDockTree.Name : "NULL")
		Text("HoveredWindowUnderMovingWindow: '%s'", g.HoveredWindowUnderMovingWindow != nil ? g.HoveredWindowUnderMovingWindow.Name : "NULL")
		Text("HoveredDockNode: 0x%08X", g.DebugHoveredDockNode != nil ? g.DebugHoveredDockNode.ID : 0)
		Text("MovingWindow: '%s'", g.MovingWindow != nil ? g.MovingWindow.Name : "NULL")
		Text("MouseViewport: 0x%08X (UserHovered 0x%08X, LastHovered 0x%08X)", g.MouseViewport.ID, g.IO.MouseHoveredViewport, g.MouseLastHoveredViewport != nil ? g.MouseLastHoveredViewport.ID : 0)
		Unindent()

		Text("ITEMS")
		Indent()
		Text("ActiveId: 0x%08X/0x%08X (%.2f sec), AllowOverlap: %d, Source: %s", g.ActiveId, g.ActiveIdPreviousFrame, g.ActiveIdTimer, g.ActiveIdAllowOverlap, GetInputSourceName(g.ActiveIdSource))
		DebugLocateItemOnHover(g.ActiveId)
		Text("ActiveIdWindow: '%s'", g.ActiveIdWindow != nil ? g.ActiveIdWindow.Name : "NULL")
		Text("ActiveIdUsing: AllKeyboardKeys: %d, NavDirMask: %X", g.ActiveIdUsingAllKeyboardKeys, g.ActiveIdUsingNavDirMask)
		Text("HoveredId: 0x%08X (%.2f sec), AllowOverlap: %d", g.HoveredIdPreviousFrame, g.HoveredIdTimer, g.HoveredIdAllowOverlap); // Not displaying g.HoveredId as it is update mid-frame
		Text("HoverItemDelayId: 0x%08X, Timer: %.2f, ClearTimer: %.2f", g.HoverItemDelayId, g.HoverItemDelayTimer, g.HoverItemDelayClearTimer)
		Text("DragDrop: %d, SourceId = 0x%08X, Payload \"%s\" (%d bytes)", g.DragDropActive, g.DragDropPayload.SourceId, g.DragDropPayload.DataType, g.DragDropPayload.DataSize)
		DebugLocateItemOnHover(g.DragDropPayload.SourceId)
		Unindent()

		Text("NAV,FOCUS")
		Indent()
		Text("NavWindow: '%s'", g.NavWindow != nil ? g.NavWindow.Name : "NULL")
		Text("NavId: 0x%08X, NavLayer: %d", g.NavId, g.NavLayer)
		DebugLocateItemOnHover(g.NavId)
		Text("NavInputSource: %s", GetInputSourceName(g.NavInputSource))
		Text(")", g.NavLastValidSelectionUserData, g.NavLastValidSelectionUserData)
		Text("NavActive: %d, NavVisible: %d", g.IO.NavActive, g.IO.NavVisible)
		Text("NavActivateId/DownId/PressedId: %08X/%08X/%08X", g.NavActivateId, g.NavActivateDownId, g.NavActivatePressedId)
		Text("NavActivateFlags: %04X", g.NavActivateFlags)
		Text("NavCursorVisible: %d, NavHighlightItemUnderNav: %d", g.NavCursorVisible, g.NavHighlightItemUnderNav)
		Text("NavFocusScopeId = 0x%08X", g.NavFocusScopeId)
		Text("NavFocusRoute[] = ")
		for path_n : i32 = g.NavFocusRoute.Size - 1; path_n >= 0; path_n -= 1 {
			focus_scope : ^ImGuiFocusScopeData = &g.NavFocusRoute.Data[path_n]
			SameLine(0.0, 0.0)
			Text("0x%08X/", focus_scope.ID)
			SetItemTooltip("In window \"%s\"", FindWindowByID(focus_scope.WindowID).Name)
		}

		Text("NavWindowingTarget: '%s'", g.NavWindowingTarget != nil ? g.NavWindowingTarget.Name : "NULL")
		Unindent()

		TreePop()
	}

	// Overlay: Display windows Rectangles and Begin Order
	if cfg.ShowWindowsRects || cfg.ShowWindowsBeginOrder {
		for window in g.Windows.Data[:g.Windows.Size] {
			if !window.WasActive { continue }
			draw_list : ^ImDrawList = GetForegroundDrawList(window)
			if cfg.ShowWindowsRects {
				r : ImRect = Funcs_GetWindowRect(window, cast(E0)cfg.ShowWindowsRectsType)
				AddRect(draw_list, r.Min, r.Max, IM_COL32(255, 0, 128, 255))
			}
			if cfg.ShowWindowsBeginOrder && (window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_ChildWindow) == {} {
				buf : [32]u8
				l := ImFormatString(buf[:], "%d", window.BeginOrderWithinContext)
				font_size : f32 = GetFontSize()
				AddRectFilled(draw_list, window.Pos, window.Pos + ImVec2{font_size, font_size}, IM_COL32(200, 100, 100, 255))
				AddText(draw_list, window.Pos, IM_COL32(255, 255, 255, 255), string_from_slice(buf[:l], false))
			}
		}
	}

	// Overlay: Display Tables Rectangles
	if cfg.ShowTablesRects {
		for table_n : i32 = 0; table_n < GetMapSize(&g.Tables); table_n += 1 {
			table : ^ImGuiTable = TryGetMapData(&g.Tables, table_n)
			if table == nil || table.LastFrameActive < g.FrameCount - 1 { continue }
			draw_list : ^ImDrawList = GetForegroundDrawList(table.OuterWindow)
			if E1(cfg.ShowTablesRectsType) >= E1.TRT_ColumnsRect {
				for column_n : i32 = 0; column_n < table.ColumnsCount; column_n += 1 {
					r : ImRect = Funcs_GetTableRect(table, E1(cfg.ShowTablesRectsType), column_n)
					col : ImU32 = (i32(table.HoveredColumnBody) == column_n) ? IM_COL32(255, 255, 128, 255) : IM_COL32(255, 0, 128, 255)
					thickness : f32 = (i32(table.HoveredColumnBody) == column_n) ? 3.0 : 1.0
					AddRect(draw_list, r.Min, r.Max, col, 0.0, {}, thickness)
				}
			}
			else {
				r : ImRect = Funcs_GetTableRect(table, E1(cfg.ShowTablesRectsType), -1)
				AddRect(draw_list, r.Min, r.Max, IM_COL32(255, 0, 128, 255))
			}
		}
	}

	when IMGUI_HAS_DOCK { /* @gen ifdef */
	// Overlay: Display Docking info
	if cfg.ShowDockingNodes && g.IO.KeyCtrl && g.DebugHoveredDockNode != nil {
		buf : [64]u8
		p : [^]u8 = raw_data(&buf)
		end := &p[len(buf)]
		node : ^ImGuiDockNode = g.DebugHoveredDockNode
		overlay_draw_list : ^ImDrawList = node.HostWindow != nil ? GetForegroundDrawList(node.HostWindow) : GetForegroundDrawList(GetMainViewport())
		p = p[ImFormatString(slice_from_se(p, end), "DockId: %X%s\n", node.ID, IsCentralNode(node) ? " *CentralNode*" : ""):]
		p = p[ImFormatString(slice_from_se(p, end), "WindowClass: %08X\n", node.WindowClass.ClassId):]
		p = p[ImFormatString(slice_from_se(p, end), "Size: (%.0f, %.0f)\n", node.Size.x, node.Size.y):]
		p = p[ImFormatString(slice_from_se(p, end), "SizeRef: (%.0f, %.0f)\n", node.SizeRef.x, node.SizeRef.y):]
		depth : i32 = DockNodeGetDepth(node)
		AddRect(overlay_draw_list, node.Pos + ImVec2{3, 3} * cast(f32) depth, node.Pos + node.Size - ImVec2{3, 3} * cast(f32) depth, IM_COL32(200, 100, 100, 255))
		pos : ImVec2 = node.Pos + ImVec2{3, 3} * cast(f32) depth
		txt := string_from_se(raw_data(&buf), p)
		AddRectFilled(overlay_draw_list, pos - ImVec2{1, 1}, pos + CalcTextSize(txt) + ImVec2{1, 1}, IM_COL32(200, 100, 100, 255))
		AddText(overlay_draw_list, nil, 0.0, pos, IM_COL32(255, 255, 255, 255), txt)
	}
	} // preproc endif// #ifdef IMGUI_HAS_DOCK

	End()
}

DebugBreakClearData :: proc()
{
	// Those fields are scattered in their respective subsystem to stay in hot-data locations
	g : ^ImGuiContext = GImGui
	g.DebugBreakInWindow = 0
	g.DebugBreakInTable = 0
	g.DebugBreakInShortcutRouting = ImGuiKey.ImGuiKey_None
}

DebugBreakButtonTooltip :: proc(keyboard_only : bool, description_of_location : string)
{
	if !BeginItemTooltip() { return }
	Text("To call IM_DEBUG_BREAK() %s:", description_of_location)
	Separator()
	TextUnformatted(keyboard_only ? "- Press 'Pause/Break' on keyboard." : "- Press 'Pause/Break' on keyboard.\n- or Click (may alter focus/active id).\n- or navigate using keyboard and press space.")
	Separator()
	TextUnformatted("Choose one way that doesn't interfere with what you are trying to debug!\nYou need a debugger attached or this will crash!")
	EndTooltip()
}

// Special button that doesn't take focus, doesn't take input owner, and can be activated without a click etc.
// In order to reduce interferences with the contents we are trying to debug into.
DebugBreakButton :: proc(label : string, description_of_location : string) -> bool
{
	window : ^ImGuiWindow = GetCurrentWindow()
	if window.SkipItems { return false }

	g : ^ImGuiContext = GImGui
	id : ImGuiID = GetID(window, label)
	label_size : ImVec2 = CalcTextSize(label, true)
	pos : ImVec2 = window.DC.CursorPos + ImVec2{0.0, window.DC.CurrLineTextBaseOffset}
	size : ImVec2 = ImVec2{label_size.x + g.Style.FramePadding.x * 2.0, label_size.y}

	bb : ImRect; init(&bb, pos, pos + size)
	ItemSize(size, 0.0)
	if !ItemAdd(bb, id) { return false }

	// WE DO NOT USE ButtonEx() or ButtonBehavior() in order to reduce our side-effects.
	hovered : bool = ItemHoverable(bb, id, g.CurrentItemFlags)
	pressed : bool = hovered && (IsKeyChordPressed(g.DebugBreakKeyChord) || IsMouseClicked(cast(ImGuiMouseButton) 0) || g.NavActivateId == id)
	DebugBreakButtonTooltip(false, description_of_location)

	col4f : ImVec4 = GetStyleColorVec4(hovered ? ImGuiCol_.ImGuiCol_ButtonHovered : ImGuiCol_.ImGuiCol_Button)
	hsv : ImVec4
	ColorConvertRGBtoHSV(col4f.x, col4f.y, col4f.z, &hsv.x, &hsv.y, &hsv.z)
	ColorConvertHSVtoRGB(hsv.x + 0.20, hsv.y, hsv.z, &col4f.x, &col4f.y, &col4f.z)

	RenderNavCursor(bb, id)
	RenderFrame(bb.Min, bb.Max, GetColorU32(col4f), true, g.Style.FrameRounding)
	RenderTextClipped(bb.Min, bb.Max, label, &label_size, &g.Style.ButtonTextAlign, &bb)

	IMGUI_TEST_ENGINE_ITEM_INFO(g, id, label, g.LastItemData.StatusFlags)
	return pressed
}

// [DEBUG] Display contents of Columns
DebugNodeColumns :: proc(columns : ^ImGuiOldColumns)
{
	if !TreeNode(cast(rawptr) cast(uintptr) columns.ID, "Columns Id: 0x%08X, Count: %d, Flags: 0x%04X", columns.ID, columns.Count, columns.Flags) { return }
	BulletText("Width: %.1f (MinX: %.1f, MaxX: %.1f)", columns.OffMaxX - columns.OffMinX, columns.OffMinX, columns.OffMaxX)
	for &column in columns.Columns.Data[:columns.Columns.Size] {
		BulletText("Column %02d: OffsetNorm %.3f (= %.1f px)", cast(i32) index_from_ptr(&columns.Columns, &column), column.OffsetNorm, GetColumnOffsetFromNorm(columns, column.OffsetNorm))
	}

	TreePop()
}

DebugNodeDockNodeFlags :: proc(p_flags : ^ImGuiDockNodeFlags, label : string, enabled : bool)
{
	PushID(label)
	PushStyleVar(ImGuiStyleVar_.ImGuiStyleVar_FramePadding, ImVec2{0.0, 0.0})
	Text("%s:", label)
	if !enabled { BeginDisabled() }
	CheckboxFlags("NoResize", p_flags, ImGuiDockNodeFlags_.ImGuiDockNodeFlags_NoResize)
	CheckboxFlags("NoResizeX", p_flags, cast(ImGuiDockNodeFlags)ImGuiDockNodeFlagsPrivate_.ImGuiDockNodeFlags_NoResizeX)
	CheckboxFlags("NoResizeY", p_flags, cast(ImGuiDockNodeFlags)ImGuiDockNodeFlagsPrivate_.ImGuiDockNodeFlags_NoResizeY)
	CheckboxFlags("NoTabBar", p_flags, cast(ImGuiDockNodeFlags)ImGuiDockNodeFlagsPrivate_.ImGuiDockNodeFlags_NoTabBar)
	CheckboxFlags("HiddenTabBar", p_flags, cast(ImGuiDockNodeFlags)ImGuiDockNodeFlagsPrivate_.ImGuiDockNodeFlags_HiddenTabBar)
	CheckboxFlags("NoWindowMenuButton", p_flags, cast(ImGuiDockNodeFlags)ImGuiDockNodeFlagsPrivate_.ImGuiDockNodeFlags_NoWindowMenuButton)
	CheckboxFlags("NoCloseButton", p_flags, cast(ImGuiDockNodeFlags)ImGuiDockNodeFlagsPrivate_.ImGuiDockNodeFlags_NoCloseButton)
	CheckboxFlags("DockedWindowsInFocusRoute", p_flags, cast(ImGuiDockNodeFlags)ImGuiDockNodeFlagsPrivate_.ImGuiDockNodeFlags_DockedWindowsInFocusRoute)
	CheckboxFlags("NoDocking", p_flags, cast(ImGuiDockNodeFlags)ImGuiDockNodeFlagsPrivate_.ImGuiDockNodeFlags_NoDocking); // Multiple flags
	CheckboxFlags("NoDockingSplit", p_flags, ImGuiDockNodeFlags_.ImGuiDockNodeFlags_NoDockingSplit)
	CheckboxFlags("NoDockingSplitOther", p_flags, cast(ImGuiDockNodeFlags)ImGuiDockNodeFlagsPrivate_.ImGuiDockNodeFlags_NoDockingSplitOther)
	CheckboxFlags("NoDockingOver", p_flags, cast(ImGuiDockNodeFlags)ImGuiDockNodeFlagsPrivate_.ImGuiDockNodeFlags_NoDockingOverMe)
	CheckboxFlags("NoDockingOverOther", p_flags, cast(ImGuiDockNodeFlags)ImGuiDockNodeFlagsPrivate_.ImGuiDockNodeFlags_NoDockingOverOther)
	CheckboxFlags("NoDockingOverEmpty", p_flags, cast(ImGuiDockNodeFlags)ImGuiDockNodeFlagsPrivate_.ImGuiDockNodeFlags_NoDockingOverEmpty)
	CheckboxFlags("NoUndocking", p_flags, ImGuiDockNodeFlags_.ImGuiDockNodeFlags_NoUndocking)
	if !enabled { EndDisabled() }
	PopStyleVar()
	PopID()
}

// [DEBUG] Display contents of ImDockNode
DebugNodeDockNode :: proc(node : ^ImGuiDockNode, label : string)
{
	g : ^ImGuiContext = GImGui
	is_alive : bool = (g.FrameCount - node.LastFrameAlive < 2); // Submitted with ImGuiDockNodeFlags_KeepAliveOnly
	is_active : bool = (g.FrameCount - node.LastFrameActive < 2); // Submitted
	if !is_alive { PushStyleColor(ImGuiCol_.ImGuiCol_Text, GetStyleColorVec4(ImGuiCol_.ImGuiCol_TextDisabled)) }
	open : bool
	tree_node_flags : ImGuiTreeNodeFlags = node.IsFocused ? ImGuiTreeNodeFlags_.ImGuiTreeNodeFlags_Selected : ImGuiTreeNodeFlags_.ImGuiTreeNodeFlags_None
	if node.Windows.Size > 0 { open = TreeNodeEx(cast(rawptr) cast(uintptr) node.ID, tree_node_flags, "%s 0x%04X%s: %d windows (vis: '%s')", label, node.ID, node.IsVisible ? "" : " (hidden)", node.Windows.Size, node.VisibleWindow != nil ? node.VisibleWindow.Name : "NULL") }
	else { open = TreeNodeEx(cast(rawptr) cast(uintptr) node.ID, tree_node_flags, "%s 0x%04X%s: %s (vis: '%s')", label, node.ID, node.IsVisible ? "" : " (hidden)", (node.SplitAxis == ImGuiAxis.ImGuiAxis_X) ? "horizontal split" : (node.SplitAxis == ImGuiAxis.ImGuiAxis_Y) ? "vertical split" : "empty", node.VisibleWindow != nil ? node.VisibleWindow.Name : "NULL") }
	if !is_alive { PopStyleColor() }
	if is_active && IsItemHovered() { if window : ^ImGuiWindow = node.HostWindow != nil ? node.HostWindow : node.VisibleWindow; window != nil { AddRect(GetForegroundDrawList(window), node.Pos, node.Pos + node.Size, IM_COL32(255, 255, 0, 255)) } }
	if open {
		IM_ASSERT(node.ChildNodes[0] == nil || node.ChildNodes[0].ParentNode == node)
		IM_ASSERT(node.ChildNodes[1] == nil || node.ChildNodes[1].ParentNode == node)
		BulletText("Pos (%.0f,%.0f), Size (%.0f, %.0f) Ref (%.0f, %.0f)", node.Pos.x, node.Pos.y, node.Size.x, node.Size.y, node.SizeRef.x, node.SizeRef.y)
		DebugNodeWindow(node.HostWindow, "HostWindow")
		DebugNodeWindow(node.VisibleWindow, "VisibleWindow")
		BulletText("SelectedTabID: 0x%08X, LastFocusedNodeID: 0x%08X", node.SelectedTabId, node.LastFocusedNodeId)
		BulletText("Misc:%s%s%s%s%s%s%s", IsDockSpace(node) ? " IsDockSpace" : "", IsCentralNode(node) ? " IsCentralNode" : "", is_alive ? " IsAlive" : "", is_active ? " IsActive" : "", node.IsFocused ? " IsFocused" : "", node.WantLockSizeOnce ? " WantLockSizeOnce" : "", node.HasCentralNodeChild ? " HasCentralNodeChild" : "")
		if TreeNode("flags", "Flags Merged: 0x%04X, Local: 0x%04X, InWindows: 0x%04X, Shared: 0x%04X", node.MergedFlags, node.LocalFlags, node.LocalFlagsInWindows, node.SharedFlags) {
			if BeginTable("flags", 4) {
				TableNextColumn(); DebugNodeDockNodeFlags(&node.MergedFlags, "MergedFlags", false)
				TableNextColumn(); DebugNodeDockNodeFlags(&node.LocalFlags, "LocalFlags", true)
				TableNextColumn(); DebugNodeDockNodeFlags(&node.LocalFlagsInWindows, "LocalFlagsInWindows", false)
				TableNextColumn(); DebugNodeDockNodeFlags(&node.SharedFlags, "SharedFlags", true)
				EndTable()
			}
			TreePop()
		}
		if node.ParentNode != nil { DebugNodeDockNode(node.ParentNode, "ParentNode") }
		if node.ChildNodes[0] != nil { DebugNodeDockNode(node.ChildNodes[0], "Child[0]") }
		if node.ChildNodes[1] != nil { DebugNodeDockNode(node.ChildNodes[1], "Child[1]") }
		if node.TabBar != nil { DebugNodeTabBar(node.TabBar, "TabBar") }
		DebugNodeWindowsList(&node.Windows, "Windows")

		TreePop()
	}
}

// [DEBUG] Display contents of ImDrawList
// Note that both 'window' and 'viewport' may be NULL here. Viewport is generally null of destroyed popups which previously owned a viewport.
DebugNodeDrawList :: proc(window : ^ImGuiWindow, viewport : ^ImGuiViewportP, draw_list : ^ImDrawList, label : string)
{
	g : ^ImGuiContext = GImGui
	cfg : ^ImGuiMetricsConfig = &g.DebugMetricsConfig
	cmd_count : i32 = draw_list.CmdBuffer.Size
	if cmd_count > 0 && back(&draw_list.CmdBuffer).ElemCount == 0 && back(&draw_list.CmdBuffer).UserCallback == nil { post_decr(&cmd_count) }
	node_open : bool = TreeNode(draw_list, "%s: '%s' %d vtx, %d indices, %d cmds", label, draw_list._OwnerName != "" ? draw_list._OwnerName : "", draw_list.VtxBuffer.Size, draw_list.IdxBuffer.Size, cmd_count)
	if draw_list == GetWindowDrawList() {
		SameLine()
		TextColored(ImVec4{1.0, 0.4, 0.4, 1.0}, "CURRENTLY APPENDING"); // Can't display stats for active draw list! (we don't have the data double-buffered)
		if node_open { TreePop() }
		return
	}

	fg_draw_list : ^ImDrawList = viewport != nil ? GetForegroundDrawList(viewport) : nil; // Render additional visuals into the top-most draw list
	if window != nil && IsItemHovered() && fg_draw_list != nil { AddRect(fg_draw_list, window.Pos, window.Pos + window.Size, IM_COL32(255, 255, 0, 255)) }
	if !node_open { return }

	if window != nil && !window.WasActive { TextDisabled("Warning: owning Window is inactive. This DrawList is not being rendered!") }

	for pcmd : ^ImDrawCmd = draw_list.CmdBuffer.Data; pcmd < &draw_list.CmdBuffer.Data[cmd_count]; pcmd = mem.ptr_offset(pcmd, 1) {
		if pcmd.UserCallback != {} {
			BulletText("Callback %p, user_data %p", pcmd.UserCallback, pcmd.UserCallbackData)
			continue
		}

		texid_desc : [20]u8
		FormatTextureIDForDebugDisplay(texid_desc[:], pcmd.TextureId)
		buf : [300]u8
		ImFormatString(buf[:], "DrawCmd:%5d tris, Tex %s, ClipRect (%4.0f,%4.0f)-(%4.0f,%4.0f)", pcmd.ElemCount / 3, texid_desc, pcmd.ClipRect.x, pcmd.ClipRect.y, pcmd.ClipRect.z, pcmd.ClipRect.w)
		pcmd_node_open : bool = TreeNode(cast(rawptr) cast(uintptr) mem.ptr_sub(pcmd, cast(^ImDrawCmd) begin(&draw_list.CmdBuffer)), "%s", buf)
		if IsItemHovered() && (cfg.ShowDrawCmdMesh || cfg.ShowDrawCmdBoundingBoxes) && fg_draw_list != nil { DebugNodeDrawCmdShowMeshAndBoundingBox(fg_draw_list, draw_list, pcmd, cfg.ShowDrawCmdMesh, cfg.ShowDrawCmdBoundingBoxes) }
		if !pcmd_node_open { continue }

		// Calculate approximate coverage area (touched pixel count)
		// This will be in pixels squared as long there's no post-scaling happening to the renderer output.
		idx_buffer : [^]ImDrawIdx = (draw_list.IdxBuffer.Size > 0) ? draw_list.IdxBuffer.Data : nil
		vtx_buffer : [^]ImDrawVert = draw_list.VtxBuffer.Data[pcmd.VtxOffset:]
		total_area : f32 = 0.0
		for idx_n : u32 = pcmd.IdxOffset; idx_n < pcmd.IdxOffset + pcmd.ElemCount;  {
			triangle : [3]ImVec2
			for n : i32 = 0; n < 3; n, idx_n = n + 1, idx_n + 1 { triangle[n] = vtx_buffer[idx_buffer != nil ? u32(idx_buffer[idx_n]) : idx_n].pos }

			total_area += ImTriangleArea(triangle[0], triangle[1], triangle[2])
		}

		// Display vertex information summary. Hover to get all triangles drawn in wire-frame
		ImFormatString(buf[:], "Mesh: ElemCount: %d, VtxOffset: +%d, IdxOffset: +%d, Area: ~%0.f px", pcmd.ElemCount, pcmd.VtxOffset, pcmd.IdxOffset, total_area)
		Selectable(string_from_slice(buf[:]))
		if IsItemHovered() && fg_draw_list != nil { DebugNodeDrawCmdShowMeshAndBoundingBox(fg_draw_list, draw_list, pcmd, true, false) }

		// Display individual triangles/vertices. Hover on to get the corresponding triangle highlighted.
		clipper : ImGuiListClipper
		Begin(&clipper, pcmd.ElemCount / 3); // Manually coarse clip our print out of individual vertices to save CPU, only items that may be visible.
		for Step(&clipper) { for prim, idx_i : i32 = clipper.DisplayStart, i32(pcmd.IdxOffset) + clipper.DisplayStart * 3; prim < clipper.DisplayEnd; prim += 1 {
		buf_p := raw_data(&buf); buf_end := raw_data(&buf)[len(buf):]
		triangle : [3]ImVec2
		for n : i32 = 0; n < 3; n, idx_i = n + 1, idx_i + 1 {
			v : ^ImDrawVert = &vtx_buffer[idx_buffer != nil ? i32(idx_buffer[idx_i]) : idx_i]
			triangle[n] = v.pos
			buf_p = buf_p[ImFormatString(buf_p[:mem.ptr_sub(buf_end, buf_p)], "%s %04d: pos (%8.2f,%8.2f), uv (%.6f,%.6f), col %08X\n", (n == 0) ? "Vert:" : "     ", idx_i, v.pos.x, v.pos.y, v.uv.x, v.uv.y, v.col):]
		}

		Selectable(string_from_slice(buf[:]), false)
		if fg_draw_list != nil && IsItemHovered() {
			backup_flags : ImDrawListFlags = fg_draw_list.Flags
			fg_draw_list.Flags &= cast(ImDrawListFlags)~cast(i32)ImDrawListFlags_.ImDrawListFlags_AntiAliasedLines; // Disable AA on triangle outlines is more readable for very large and thin triangles.
			AddPolyline(fg_draw_list, triangle[:], IM_COL32(255, 255, 0, 255), ImDrawFlags_.ImDrawFlags_Closed, 1.0)
			fg_draw_list.Flags = backup_flags
		}
	} }

		TreePop()
	}

	TreePop()
}

// [DEBUG] Display mesh/aabb of a ImDrawCmd
DebugNodeDrawCmdShowMeshAndBoundingBox :: proc(out_draw_list : ^ImDrawList, draw_list : ^ImDrawList, draw_cmd : ^ImDrawCmd, show_mesh : bool, show_aabb : bool)
{
	IM_ASSERT(show_mesh || show_aabb)

	// Draw wire-frame version of all triangles
	clip_rect : ImRect = transmute(ImRect)draw_cmd.ClipRect
	vtxs_rect : ImRect; init(&vtxs_rect, FLT_MAX, FLT_MAX, -FLT_MAX, -FLT_MAX)
	backup_flags : ImDrawListFlags = out_draw_list.Flags
	out_draw_list.Flags &= cast(ImDrawListFlags)~cast(i32)ImDrawListFlags_.ImDrawListFlags_AntiAliasedLines; // Disable AA on triangle outlines is more readable for very large and thin triangles.
	for idx_n, idx_end : u32 = draw_cmd.IdxOffset, draw_cmd.IdxOffset + draw_cmd.ElemCount; idx_n < idx_end;  {
		idx_buffer := (draw_list.IdxBuffer.Size > 0) ? draw_list.IdxBuffer.Data : nil; // We don't hold on those pointers past iterations as ->AddPolyline() may invalidate them if out_draw_list==draw_list
		vtx_buffer := draw_list.VtxBuffer.Data[draw_cmd.VtxOffset:]

		triangle : [3]ImVec2
		for n : i32 = 0; n < 3; n, idx_n = n + 1, idx_n + 1 {
			triangle[n] = vtx_buffer[idx_buffer != nil ? u32(idx_buffer[idx_n]) : idx_n].pos
			Add(&vtxs_rect, triangle[n])
		}

		if show_mesh {
			// In yellow: mesh triangles
			AddPolyline(out_draw_list, triangle[:], IM_COL32(255, 255, 0, 255), ImDrawFlags_.ImDrawFlags_Closed, 1.0)
		}
	}

	// Draw bounding boxes
	if show_aabb {
		AddRect(out_draw_list, ImTrunc(clip_rect.Min), ImTrunc(clip_rect.Max), IM_COL32(255, 0, 255, 255)); // In pink: clipping rectangle submitted to GPU
		AddRect(out_draw_list, ImTrunc(vtxs_rect.Min), ImTrunc(vtxs_rect.Max), IM_COL32(0, 255, 255, 255)); // In cyan: bounding box of triangles
	}
	out_draw_list.Flags = backup_flags
}

// [DEBUG] Display details for a single font, called by ShowStyleEditor().
DebugNodeFont :: proc(font : ^ImFont)
{
	opened : bool = TreeNode(font, "Font: \"%s\"\n%.2f px, %d glyphs, %d file(s)", font.ConfigData != nil ? string_from_slice(font.ConfigData[0].Name[:]) : "", font.FontSize, font.Glyphs.Size, font.ConfigDataCount)
	SameLine()
	if SmallButton("Set as default") { GetIO().FontDefault = font }
	if !opened { return }

	// Display preview text
	PushFont(font)
	Text("The quick brown fox jumps over the lazy dog")
	PopFont()

	// Display details
	SetNextItemWidth(GetFontSize() * 8)
	DragFloat("Font scale", &font.Scale, 0.005, 0.3, 2.0, "%.1f")
	SameLine(); MetricsHelpMarker("(Glimmer of hope: the atlas system will be rewritten in the future to make scaling more flexible.)")
	Text("Ascent: %f, Descent: %f, Height: %f", font.Ascent, font.Descent, font.Ascent - font.Descent)
	c_str : [5]u8
	Text("Fallback character: '%s' (U+%04X)", ImTextCharToUtf8(&c_str, u32(font.FallbackChar)), font.FallbackChar)
	Text("Ellipsis character: '%s' (U+%04X)", ImTextCharToUtf8(&c_str, u32(font.EllipsisChar)), font.EllipsisChar)
	surface_sqrt : i32 = cast(i32) ImSqrt(cast(f32) font.MetricsTotalSurface)
	Text("Texture Area: about %d px ~%dx%d px", font.MetricsTotalSurface, surface_sqrt, surface_sqrt)
	for config_i : i16 = 0; config_i < font.ConfigDataCount; config_i += 1 { if font.ConfigData != nil { if cfg : ^ImFontConfig = &font.ConfigData[config_i]; cfg != nil { BulletText("Input %d: \'%s\', Oversample: (%d,%d), PixelSnapH: %d, Offset: (%.1f,%.1f)", config_i, cfg.Name, cfg.OversampleH, cfg.OversampleV, cfg.PixelSnapH, cfg.GlyphOffset.x, cfg.GlyphOffset.y) } } }

	// Display all glyphs of the fonts in separate pages of 256 characters
	if TreeNode("Glyphs", "Glyphs (%d)", font.Glyphs.Size) {
		draw_list : ^ImDrawList = GetWindowDrawList()
		glyph_col : ImU32 = GetColorU32(ImGuiCol_.ImGuiCol_Text)
		cell_size : f32 = font.FontSize * 1
		cell_spacing : f32 = GetStyle().ItemSpacing.y
		for base : u32 = 0; base <= IM_UNICODE_CODEPOINT_MAX; base += 256 {
			// Skip ahead if a large bunch of glyphs are not present in the font (test in chunks of 4k)
			// This is only a small optimization to reduce the number of iterations when IM_UNICODE_MAX_CODEPOINT
			// is large // (if ImWchar==ImWchar32 we will do at least about 272 queries here)
			if (base & 4095) == 0 && IsGlyphRangeUnused(font, base, base + 4095) {
				base += 4096 - 256
				continue
			}

			count : i32 = 0
			for n : u32 = 0; n < 256; n += 1 { if FindGlyphNoFallback(font, cast(ImWchar) (base + n)) != nil { post_incr(&count) } }

			if count <= 0 { continue }
			if !TreeNode(cast(rawptr) cast(uintptr) base, "U+%04X..U+%04X (%d %s)", base, base + 255, count, count > 1 ? "glyphs" : "glyph") { continue }

			// Draw a 16x16 grid of glyphs
			base_pos : ImVec2 = GetCursorScreenPos()
			for n : u32 = 0; n < 256; n += 1 {
				// We use ImFont::RenderChar as a shortcut because we don't have UTF-8 conversion functions
				// available here and thus cannot easily generate a zero-terminated UTF-8 encoded string.
				cell_p1 := ImVec2{ base_pos.x + f32(n % 16) * (cell_size + cell_spacing), base_pos.y + f32(n / 16) * (cell_size + cell_spacing) }
				cell_p2 := ImVec2{ cell_p1.x + cell_size, cell_p1.y + cell_size }
				glyph : ^ImFontGlyph = FindGlyphNoFallback(font, cast(ImWchar) (base + n))
				AddRect(draw_list, cell_p1, cell_p2, glyph != nil ? IM_COL32(255, 255, 255, 100) : IM_COL32(255, 255, 255, 50))
				if glyph == nil { continue }
				RenderChar(font, draw_list, cell_size, cell_p1, glyph_col, cast(ImWchar) (base + n))
				if IsMouseHoveringRect(cell_p1, cell_p2) && BeginTooltip() {
					DebugNodeFontGlyph(font, glyph)
					EndTooltip()
				}
			}

			Dummy(ImVec2{(cell_size + cell_spacing) * 16, (cell_size + cell_spacing) * 16})
			TreePop()
		}

		TreePop()
	}
	TreePop()
}

DebugNodeFontGlyph :: proc(_ : ^ImFont, glyph : ^ImFontGlyph)
{
	Text("Codepoint: U+%04X", glyph.Codepoint)
	Separator()
	Text("Visible: %d", glyph.Visible)
	Text("AdvanceX: %.1f", glyph.AdvanceX)
	Text("Pos: (%.2f,%.2f)->(%.2f,%.2f)", glyph.X0, glyph.Y0, glyph.X1, glyph.Y1)
	Text("UV: (%.3f,%.3f)->(%.3f,%.3f)", glyph.U0, glyph.V0, glyph.U1, glyph.V1)
}

// [DEBUG] Display contents of ImGuiStorage
DebugNodeStorage :: proc(storage : ^ImGuiStorage, label : string)
{
	if !TreeNode(label, "%s: %d entries, %d bytes", label, storage.Data.Size, size_in_bytes(&storage.Data)) { return }
	for p in storage.Data.Data[:storage.Data.Size] {
		BulletText("Key 0x%08X Value { i: %d }", p.key, p.val_i); // Important: we currently don't store a type, real value may not be integer.
		DebugLocateItemOnHover(p.key)
	}

	TreePop()
}

// [DEBUG] Display contents of ImGuiTabBar
DebugNodeTabBar :: proc(tab_bar : ^ImGuiTabBar, label : string)
{
	// Standalone tab bars (not associated to docking/windows functionality) currently hold no discernible strings.
	buf : [256]u8
	p := raw_data(&buf)
	buf_end := raw_data(&buf)[len(buf):]
	is_active : bool = (tab_bar.PrevFrameVisible >= GetFrameCount() - 2)
	p = p[ImFormatString(slice_from_se(p, buf_end), "%s 0x%08X (%d tabs)%s  {", label, tab_bar.ID, tab_bar.Tabs.Size, is_active ? "" : " *Inactive*"):]
	for tab_n : i32 = 0; tab_n < ImMin(tab_bar.Tabs.Size, 3); tab_n += 1 {
		tab : ^ImGuiTabItem = &tab_bar.Tabs.Data[tab_n]
		p = p[ImFormatString(slice_from_se(p, buf_end), "%s'%s'", tab_n > 0 ? ", " : "", TabBarGetTabName(tab_bar, tab)):]
	}

	p = p[ImFormatString(slice_from_se(p, buf_end), (tab_bar.Tabs.Size > 3) ? " ... }" : " } "):]
	if !is_active { PushStyleColor(ImGuiCol_.ImGuiCol_Text, GetStyleColorVec4(ImGuiCol_.ImGuiCol_TextDisabled)) }
	open : bool = TreeNode(label, "%s", buf)
	if !is_active { PopStyleColor() }
	if is_active && IsItemHovered() {
		draw_list : ^ImDrawList = GetForegroundDrawList()
		AddRect(draw_list, tab_bar.BarRect.Min, tab_bar.BarRect.Max, IM_COL32(255, 255, 0, 255))
		AddLine(draw_list, ImVec2{tab_bar.ScrollingRectMinX, tab_bar.BarRect.Min.y}, ImVec2{tab_bar.ScrollingRectMinX, tab_bar.BarRect.Max.y}, IM_COL32(0, 255, 0, 255))
		AddLine(draw_list, ImVec2{tab_bar.ScrollingRectMaxX, tab_bar.BarRect.Min.y}, ImVec2{tab_bar.ScrollingRectMaxX, tab_bar.BarRect.Max.y}, IM_COL32(0, 255, 0, 255))
	}
	if open {
		for tab_n : i32 = 0; tab_n < tab_bar.Tabs.Size; tab_n += 1 {
			tab : ^ImGuiTabItem = &tab_bar.Tabs.Data[tab_n]
			PushID(tab)
			if SmallButton("<") { TabBarQueueReorder(tab_bar, tab, -1) }; SameLine(0, 2)
			if SmallButton(">") { TabBarQueueReorder(tab_bar, tab, +1) }; SameLine()
			Text("%02d%c Tab 0x%08X '%s' Offset: %.2f, Width: %.2f/%.2f", tab_n, (tab.ID == tab_bar.SelectedTabId) ? '*' : ' ', tab.ID, TabBarGetTabName(tab_bar, tab), tab.Offset, tab.Width, tab.ContentWidth)
			PopID()
		}

		TreePop()
	}
}

DebugNodeViewport :: proc(viewport : ^ImGuiViewportP)
{
	g : ^ImGuiContext = GImGui
	SetNextItemOpen(true, ImGuiCond_.ImGuiCond_Once)
	open : bool = TreeNode(cast(rawptr) cast(uintptr) viewport.ID, "Viewport #%d, ID: 0x%08X, Parent: 0x%08X, Window: \"%s\"", viewport.Idx, viewport.ID, viewport.ParentViewportId, viewport.Window != nil ? viewport.Window.Name : "N/A")
	if IsItemHovered() { g.DebugMetricsConfig.HighlightViewportID = viewport.ID }
	if open {
		flags := viewport.Flags
		BulletText("Main Pos: (%.0f,%.0f), Size: (%.0f,%.0f)\nWorkArea Inset Left: %.0f Top: %.0f, Right: %.0f, Bottom: %.0f\nMonitor: %d, DpiScale: %.0f%%", viewport.Pos.x, viewport.Pos.y, viewport.Size.x, viewport.Size.y, viewport.WorkInsetMin.x, viewport.WorkInsetMin.y, viewport.WorkInsetMax.x, viewport.WorkInsetMax.y, viewport.PlatformMonitor, viewport.DpiScale * 100.0)
		if viewport.Idx > 0 {SameLine(); if SmallButton("Reset Pos") {viewport.Pos = ImVec2{200, 200}; UpdateWorkRect(viewport); if viewport.Window != nil { viewport.Window.Pos = viewport.Pos }
			}
		}
		BulletText("Flags: 0x%04X =%s%s%s%s%s%s%s%s%s%s%s%s%s", viewport.Flags, (flags & ImGuiViewportFlags_.ImGuiViewportFlags_IsPlatformMonitor) != {} ? " IsPlatformMonitor" : "", (flags & ImGuiViewportFlags_.ImGuiViewportFlags_IsMinimized) != {} ? " IsMinimized" : "", (flags & ImGuiViewportFlags_.ImGuiViewportFlags_IsFocused) != {} ? " IsFocused" : "", (flags & ImGuiViewportFlags_.ImGuiViewportFlags_OwnedByApp) != {} ? " OwnedByApp" : "", (flags & ImGuiViewportFlags_.ImGuiViewportFlags_NoDecoration) != {} ? " NoDecoration" : "", (flags & ImGuiViewportFlags_.ImGuiViewportFlags_NoTaskBarIcon) != {} ? " NoTaskBarIcon" : "", (flags & ImGuiViewportFlags_.ImGuiViewportFlags_NoFocusOnAppearing) != {} ? " NoFocusOnAppearing" : "", (flags & ImGuiViewportFlags_.ImGuiViewportFlags_NoFocusOnClick) != {} ? " NoFocusOnClick" : "", (flags & ImGuiViewportFlags_.ImGuiViewportFlags_NoInputs) != {} ? " NoInputs" : "", (flags & ImGuiViewportFlags_.ImGuiViewportFlags_NoRendererClear) != {} ? " NoRendererClear" : "", (flags & ImGuiViewportFlags_.ImGuiViewportFlags_NoAutoMerge) != {} ? " NoAutoMerge" : "", (flags & ImGuiViewportFlags_.ImGuiViewportFlags_TopMost) != {} ? " TopMost" : "", (flags & ImGuiViewportFlags_.ImGuiViewportFlags_CanHostOtherWindows) != {} ? " CanHostOtherWindows" : "")
		for draw_list in viewport.DrawDataP.CmdLists.Data[:viewport.DrawDataP.CmdLists.Size] { DebugNodeDrawList(nil, viewport, draw_list, "DrawList") }

		TreePop()
	}
}

DebugNodePlatformMonitor :: proc(monitor : ^ImGuiPlatformMonitor, label : string, idx : i32)
{
	BulletText("%s %d: DPI %.0f%%\n MainMin (%.0f,%.0f), MainMax (%.0f,%.0f), MainSize (%.0f,%.0f)\n WorkMin (%.0f,%.0f), WorkMax (%.0f,%.0f), WorkSize (%.0f,%.0f)", label, idx, monitor.DpiScale * 100.0, monitor.MainPos.x, monitor.MainPos.y, monitor.MainPos.x + monitor.MainSize.x, monitor.MainPos.y + monitor.MainSize.y, monitor.MainSize.x, monitor.MainSize.y, monitor.WorkPos.x, monitor.WorkPos.y, monitor.WorkPos.x + monitor.WorkSize.x, monitor.WorkPos.y + monitor.WorkSize.y, monitor.WorkSize.x, monitor.WorkSize.y)
}

DebugNodeWindow :: proc(window : ^ImGuiWindow, label : string)
{
	if window == nil {
		BulletText("%s: NULL", label)
		return
	}

	g : ^ImGuiContext = GImGui
	is_active : bool = window.WasActive
	tree_node_flags : ImGuiTreeNodeFlags = (window == g.NavWindow) ? ImGuiTreeNodeFlags_.ImGuiTreeNodeFlags_Selected : ImGuiTreeNodeFlags_.ImGuiTreeNodeFlags_None
	if !is_active { PushStyleColor(ImGuiCol_.ImGuiCol_Text, GetStyleColorVec4(ImGuiCol_.ImGuiCol_TextDisabled)) }
	open : bool = TreeNodeEx(label, tree_node_flags, "%s '%s'%s", label, window.Name, is_active ? "" : " *Inactive*")
	if !is_active { PopStyleColor() }
	if IsItemHovered() && is_active { AddRect(GetForegroundDrawList(window), window.Pos, window.Pos + window.Size, IM_COL32(255, 255, 0, 255)) }
	if !open { return }

	if window.MemoryCompacted { TextDisabled("Note: some memory buffers have been compacted/freed.") }

	if g.IO.ConfigDebugIsDebuggerPresent && DebugBreakButton("**DebugBreak**", "in Begin()") { g.DebugBreakInWindow = window.ID }

	flags : ImGuiWindowFlags = window.Flags
	DebugNodeDrawList(window, window.Viewport, window.DrawList, "DrawList")
	BulletText("Pos: (%.1f,%.1f), Size: (%.1f,%.1f), ContentSize (%.1f,%.1f) Ideal (%.1f,%.1f)", window.Pos.x, window.Pos.y, window.Size.x, window.Size.y, window.ContentSize.x, window.ContentSize.y, window.ContentSizeIdeal.x, window.ContentSizeIdeal.y)
	BulletText("Flags: 0x%08X (%s%s%s%s%s%s%s%s%s..)", flags, (flags & ImGuiWindowFlags_.ImGuiWindowFlags_ChildWindow) != {} ? "Child " : "", (flags & ImGuiWindowFlags_.ImGuiWindowFlags_Tooltip) != {} ? "Tooltip " : "", (flags & ImGuiWindowFlags_.ImGuiWindowFlags_Popup) != {} ? "Popup " : "", (flags & ImGuiWindowFlags_.ImGuiWindowFlags_Modal) != {} ? "Modal " : "", (flags & ImGuiWindowFlags_.ImGuiWindowFlags_ChildMenu) != {} ? "ChildMenu " : "", (flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoSavedSettings) != {} ? "NoSavedSettings " : "", (flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoMouseInputs) != {} ? "NoMouseInputs" : "", (flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoNavInputs) != {} ? "NoNavInputs" : "", (flags & ImGuiWindowFlags_.ImGuiWindowFlags_AlwaysAutoResize) != {} ? "AlwaysAutoResize" : "")
	if (flags & ImGuiWindowFlags_.ImGuiWindowFlags_ChildWindow) != {} { BulletText("ChildFlags: 0x%08X (%s%s%s%s..)", window.ChildFlags, (window.ChildFlags & ImGuiChildFlags_.ImGuiChildFlags_Borders) != {} ? "Borders " : "", (window.ChildFlags & ImGuiChildFlags_.ImGuiChildFlags_ResizeX) != {} ? "ResizeX " : "", (window.ChildFlags & ImGuiChildFlags_.ImGuiChildFlags_ResizeY) != {} ? "ResizeY " : "", (window.ChildFlags & ImGuiChildFlags_.ImGuiChildFlags_NavFlattened) != {} ? "NavFlattened " : "") }
	BulletText("WindowClassId: 0x%08X", window.WindowClass.ClassId)
	BulletText("Scroll: (%.2f/%.2f,%.2f/%.2f) Scrollbar:%s%s", window.Scroll.x, window.ScrollMax.x, window.Scroll.y, window.ScrollMax.y, window.ScrollbarX ? "X" : "", window.ScrollbarY ? "Y" : "")
	BulletText("Active: %d/%d, WriteAccessed: %d, BeginOrderWithinContext: %d", window.Active, window.WasActive, window.WriteAccessed, (window.Active || window.WasActive) ? window.BeginOrderWithinContext : -1)
	BulletText("Appearing: %d, Hidden: %d (CanSkip %d Cannot %d), SkipItems: %d", window.Appearing, window.Hidden, window.HiddenFramesCanSkipItems, window.HiddenFramesCannotSkipItems, window.SkipItems)
	for layer : i32 = 0; layer < cast(i32)ImGuiNavLayer.ImGuiNavLayer_COUNT; layer += 1 {
		r : ImRect = window.NavRectRel[layer]
		if r.Min.x >= r.Max.x && r.Min.y >= r.Max.y { BulletText("NavLastIds[%d]: 0x%08X", layer, window.NavLastIds[layer]) }
		else { BulletText("NavLastIds[%d]: 0x%08X at +(%.1f,%.1f)(%.1f,%.1f)", layer, window.NavLastIds[layer], r.Min.x, r.Min.y, r.Max.x, r.Max.y) }
		DebugLocateItemOnHover(window.NavLastIds[layer])
	}

	pr := &window.NavPreferredScoringPosRel
	for layer : i32 = 0; layer < cast(i32)ImGuiNavLayer.ImGuiNavLayer_COUNT; layer += 1 { BulletText("NavPreferredScoringPosRel[%d] = {%.1f,%.1f)", layer, (pr[layer].x == FLT_MAX ? -99999.0 : pr[layer].x), (pr[layer].y == FLT_MAX ? -99999.0 : pr[layer].y)) }; 

// Display as 99999.0f so it looks neater.
	BulletText("NavLayersActiveMask: %X, NavLastChildNavWindow: %s", window.DC.NavLayersActiveMask, window.NavLastChildNavWindow != nil ? window.NavLastChildNavWindow.Name : "NULL")

	BulletText("Viewport: %d%s, ViewportId: 0x%08X, ViewportPos: (%.1f,%.1f)", window.Viewport != nil ? window.Viewport.Idx : -1, window.ViewportOwned ? " (Owned)" : "", window.ViewportId, window.ViewportPos.x, window.ViewportPos.y)
	BulletText("ViewportMonitor: %d", window.Viewport != nil ? window.Viewport.PlatformMonitor : -1)
	BulletText("DockId: 0x%04X, DockOrder: %d, Act: %d, Vis: %d", window.DockId, window.DockOrder, window.DockIsActive, window.DockTabIsVisible)
	if window.DockNode != nil || window.DockNodeAsHost != nil { DebugNodeDockNode(window.DockNodeAsHost != nil ? window.DockNodeAsHost : window.DockNode, window.DockNodeAsHost != nil ? "DockNodeAsHost" : "DockNode") }

	if window.RootWindow != window { DebugNodeWindow(window.RootWindow, "RootWindow") }
	if window.RootWindowDockTree != window.RootWindow { DebugNodeWindow(window.RootWindowDockTree, "RootWindowDockTree") }
	if window.ParentWindow != nil { DebugNodeWindow(window.ParentWindow, "ParentWindow") }
	if window.ParentWindowForFocusRoute != nil { DebugNodeWindow(window.ParentWindowForFocusRoute, "ParentWindowForFocusRoute") }
	if window.DC.ChildWindows.Size > 0 { DebugNodeWindowsList(&window.DC.ChildWindows, "ChildWindows") }
	if window.ColumnsStorage.Size > 0 && TreeNode("Columns", "Columns sets (%d)", window.ColumnsStorage.Size) {
		for &columns in window.ColumnsStorage.Data[:window.ColumnsStorage.Size] { DebugNodeColumns(&columns) }

		TreePop()
	}
	DebugNodeStorage(&window.StateStorage, "Storage")
	TreePop()
}

DebugNodeWindowSettings :: proc(settings : ^ImGuiWindowSettings)
{
	if settings.WantDelete { BeginDisabled() }
	Text("0x%08X \"%s\" Pos (%d,%d) Size (%d,%d) Collapsed=%d", settings.ID, GetName(settings), settings.Pos.x, settings.Pos.y, settings.Size.x, settings.Size.y, settings.Collapsed)
	if settings.WantDelete { EndDisabled() }
}

DebugNodeWindowsList :: proc(windows : ^ImVector(^ImGuiWindow), label : string)
{
	if !TreeNode(label, "%s (%d)", label, windows.Size) { return }
	for i : i32 = windows.Size - 1; i >= 0; i -= 1 {
		PushID(windows.Data[i])
		DebugNodeWindow(windows.Data[i], "Window")
		PopID()
	}

	TreePop()
}

// FIXME-OPT: This is technically suboptimal, but it is simpler this way.
DebugNodeWindowsListByBeginStackParent :: proc(windows : []^ImGuiWindow, parent_in_begin_stack : ^ImGuiWindow)
{
	for i : i32 = 0; i < cast(i32)len(windows); i += 1 {
		window : ^ImGuiWindow = windows[i]
		if window.ParentWindowInBeginStack != parent_in_begin_stack { continue }
		buf : [20]u8
		ImFormatString(buf[:], "[%04d] Window", window.BeginOrderWithinContext)
		//BulletText("[%04d] Window '%s'", window->BeginOrderWithinContext, window->Name);
		DebugNodeWindow(window, string_from_slice(buf[:]))
		Indent()
		DebugNodeWindowsListByBeginStackParent(windows[i + 1:], window)
		Unindent()
	}
}

// Call via IMGUI_DEBUG_LOG() for maximum stripping in caller code!
//-----------------------------------------------------------------------------
// [SECTION] DEBUG LOG WINDOW
//-----------------------------------------------------------------------------

DebugLogV :: #force_inline proc(fmt : string, args : []any) { DebugLog(fmt, ..args) }

DebugLog :: proc(fmt : string, args : ..any)
{
	g : ^ImGuiContext = GImGui
	old_size : i32 = size(&g.DebugLogBuf)
	if g.ContextName[0] != 0 { appendf(&g.DebugLogBuf, "[%s] [%05d] ", g.ContextName, g.FrameCount) }
	else { appendf(&g.DebugLogBuf, "[%05d] ", g.FrameCount) }
	appendfv(&g.DebugLogBuf, fmt, args)
	append(&g.DebugLogIndex, c_str(&g.DebugLogBuf), old_size, size(&g.DebugLogBuf))
	if (g.DebugLogFlags & ImGuiDebugLogFlags_.ImGuiDebugLogFlags_OutputToTTY) != {} { IMGUI_DEBUG_PRINTF("%s", mem.ptr_offset(begin(&g.DebugLogBuf), old_size)) }	when IMGUI_ENABLE_TEST_ENGINE { /* @gen ifdef */
	// IMGUI_TEST_ENGINE_LOG() adds a trailing \n automatically
	new_size : i32 = size(&g.DebugLogBuf)
	trailing_carriage_return : bool = (g.DebugLogBuf.Data[new_size - 1] == '\n')
	if (g.DebugLogFlags & ImGuiDebugLogFlags_.ImGuiDebugLogFlags_OutputToTestEngine) != {} { IMGUI_TEST_ENGINE_LOG("%.*s", new_size - old_size - (trailing_carriage_return ? 1 : 0), begin(&g.DebugLogBuf) + old_size) }
	} // preproc endif
}

// FIXME-LAYOUT: To be done automatically via layout mode once we rework ItemSize/ItemAdd into ItemLayout.
SameLineOrWrap :: proc(size : ImVec2)
{
	g : ^ImGuiContext = GImGui
	window : ^ImGuiWindow = g.CurrentWindow
	pos := ImVec2{ window.DC.CursorPosPrevLine.x + g.Style.ItemSpacing.x, window.DC.CursorPosPrevLine.y }
	if Contains(window.WorkRect, ImRect{pos, pos + size}) { SameLine() }
}

ShowDebugLogFlag :: proc(name : string, flags : ImGuiDebugLogFlags)
{
	g : ^ImGuiContext = GImGui
	size := ImVec2{ GetFrameHeight() + g.Style.ItemInnerSpacing.x + CalcTextSize(name).x, GetFrameHeight() }
	SameLineOrWrap(size); // FIXME-LAYOUT: To be done automatically once we rework ItemSize/ItemAdd into ItemLayout.

	highlight_errors : bool = (flags == ImGuiDebugLogFlags_.ImGuiDebugLogFlags_EventError && g.DebugLogSkippedErrors > 0)
	if highlight_errors { PushStyleColor(ImGuiCol_.ImGuiCol_Text, ImLerp(g.Style.Colors[ImGuiCol_.ImGuiCol_Text], ImVec4{1.0, 0.0, 0.0, 1.0}, 0.30)) }
	if CheckboxFlags(name, &g.DebugLogFlags, flags) && g.IO.KeyShift && (g.DebugLogFlags & flags) != {} {
		g.DebugLogAutoDisableFrames = 2
		g.DebugLogAutoDisableFlags |= flags
	}
	if highlight_errors {
		PopStyleColor()
		SetItemTooltip("%d past errors skipped.", g.DebugLogSkippedErrors)
	}
	else {
		SetItemTooltip("Hold SHIFT when clicking to enable for 2 frames only (useful for spammy log entries)")
	}
}

// create Debug Log window. display a simplified log of important dear imgui events.
ShowDebugLogWindow :: proc(p_open : ^bool)
{
	g : ^ImGuiContext = GImGui
	if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_.ImGuiNextWindowDataFlags_HasSize) == {} { SetNextWindowSize(ImVec2{0.0, GetFontSize() * 12.0}, ImGuiCond_.ImGuiCond_FirstUseEver) }
	if !Begin("Dear ImGui Debug Log", p_open) || GetCurrentWindow().BeginCount > 1 {
		End()
		return
	}

	all_enable_flags : ImGuiDebugLogFlags = ImGuiDebugLogFlags_.ImGuiDebugLogFlags_EventMask_ & cast(ImGuiDebugLogFlags)~cast(i32)ImGuiDebugLogFlags_.ImGuiDebugLogFlags_EventInputRouting
	CheckboxFlags("All", &g.DebugLogFlags, all_enable_flags)
	SetItemTooltip("(except InputRouting which is spammy)")

	ShowDebugLogFlag("Errors", ImGuiDebugLogFlags_.ImGuiDebugLogFlags_EventError)
	ShowDebugLogFlag("ActiveId", ImGuiDebugLogFlags_.ImGuiDebugLogFlags_EventActiveId)
	ShowDebugLogFlag("Clipper", ImGuiDebugLogFlags_.ImGuiDebugLogFlags_EventClipper)
	ShowDebugLogFlag("Docking", ImGuiDebugLogFlags_.ImGuiDebugLogFlags_EventDocking)
	ShowDebugLogFlag("Focus", ImGuiDebugLogFlags_.ImGuiDebugLogFlags_EventFocus)
	ShowDebugLogFlag("IO", ImGuiDebugLogFlags_.ImGuiDebugLogFlags_EventIO)
	//ShowDebugLogFlag("Font", ImGuiDebugLogFlags_EventFont);
	ShowDebugLogFlag("Nav", ImGuiDebugLogFlags_.ImGuiDebugLogFlags_EventNav)
	ShowDebugLogFlag("Popup", ImGuiDebugLogFlags_.ImGuiDebugLogFlags_EventPopup)
	ShowDebugLogFlag("Selection", ImGuiDebugLogFlags_.ImGuiDebugLogFlags_EventSelection)
	ShowDebugLogFlag("Viewport", ImGuiDebugLogFlags_.ImGuiDebugLogFlags_EventViewport)
	ShowDebugLogFlag("InputRouting", ImGuiDebugLogFlags_.ImGuiDebugLogFlags_EventInputRouting)

	if SmallButton("Clear") {
		clear(&g.DebugLogBuf)
		clear(&g.DebugLogIndex)
		g.DebugLogSkippedErrors = 0
	}
	SameLine()
	if SmallButton("Copy") { SetClipboardText(string_from_cstr(cast(cstring)c_str(&g.DebugLogBuf))) }
	SameLine()
	if SmallButton("Configure Outputs..") { OpenPopup("Outputs") }
	if BeginPopup("Outputs") {
		CheckboxFlags("OutputToTTY", &g.DebugLogFlags, ImGuiDebugLogFlags_.ImGuiDebugLogFlags_OutputToTTY)
		when ! IMGUI_ENABLE_TEST_ENGINE { /* @gen ifndef */
		BeginDisabled()
		} // preproc endif
		CheckboxFlags("OutputToTestEngine", &g.DebugLogFlags, ImGuiDebugLogFlags_.ImGuiDebugLogFlags_OutputToTestEngine)
		when ! IMGUI_ENABLE_TEST_ENGINE { /* @gen ifndef */
		EndDisabled()
		} // preproc endif
		EndPopup()
	}

	BeginChild("##log", ImVec2{0.0, 0.0}, ImGuiChildFlags_.ImGuiChildFlags_Borders, ImGuiWindowFlags_.ImGuiWindowFlags_AlwaysVerticalScrollbar | ImGuiWindowFlags_.ImGuiWindowFlags_AlwaysHorizontalScrollbar)

	backup_log_flags : ImGuiDebugLogFlags = g.DebugLogFlags
	g.DebugLogFlags &= cast(ImGuiDebugLogFlags)~cast(i32)ImGuiDebugLogFlags_.ImGuiDebugLogFlags_EventClipper

	clipper : ImGuiListClipper
	Begin(&clipper, size(&g.DebugLogIndex))
	for Step(&clipper) {
		for line_no : i32 = clipper.DisplayStart; line_no < clipper.DisplayEnd; line_no += 1 {
			DebugTextUnformattedWithLocateItem(get_line_begin(&g.DebugLogIndex, c_str(&g.DebugLogBuf), line_no), get_line_end(&g.DebugLogIndex, c_str(&g.DebugLogBuf), line_no))
		}
	}

	g.DebugLogFlags = backup_log_flags
	if GetScrollY() >= GetScrollMaxY() { SetScrollHereY(1.0) }
	EndChild()

	End()
}

// Display line, search for 0xXXXXXXXX identifiers and call DebugLocateItemOnHover() when hovered.
DebugTextUnformattedWithLocateItem :: proc(line_begin : [^]u8, line_end : ^u8)
{
	TextUnformatted(string_from_se(line_begin, line_end))
	if !IsItemHovered(ImGuiHoveredFlags_.ImGuiHoveredFlags_AllowWhenBlockedByPopup | ImGuiHoveredFlags_.ImGuiHoveredFlags_AllowWhenBlockedByActiveItem) { return }
	g : ^ImGuiContext = GImGui
	text_rect : ImRect = g.LastItemData.Rect
	for p := line_begin; cast(^u8)p <= mem.ptr_offset(line_end, -10); p = p[1:] {
		id : i64 = 0
		o := 0
		if p[0] != '0' || (p[1] != 'x' && p[1] != 'X') || parse_int(string_from_se(p[2:], line_end), &o, &id, 16) != true || ImCharIsXdigitA(p[10]) { continue }
		p0 : ImVec2 = CalcTextSize(string_from_se(line_begin, p))
		p1 : ImVec2 = CalcTextSize(string_from_se(p, &p[10]))
		g.LastItemData.Rect = ImRect{text_rect.Min + ImVec2{p0.x, 0.0}, text_rect.Min + ImVec2{p0.x + p1.x, p1.y}}
		if IsMouseHoveringRect(g.LastItemData.Rect.Min, g.LastItemData.Rect.Max, true) { DebugLocateItemOnHover(ImGuiID(id)) }
		p = p[10:]
	}
}

//-----------------------------------------------------------------------------
// [SECTION] OTHER DEBUG TOOLS (ITEM PICKER, ID STACK TOOL)
//-----------------------------------------------------------------------------

// Draw a small cross at current CursorPos in current window's DrawList
DebugDrawCursorPos :: proc(col : ImU32)
{
	g : ^ImGuiContext = GImGui
	window : ^ImGuiWindow = g.CurrentWindow
	pos : ImVec2 = window.DC.CursorPos
	AddLine(window.DrawList, ImVec2{pos.x, pos.y - 3.0}, ImVec2{pos.x, pos.y + 4.0}, col, 1.0)
	AddLine(window.DrawList, ImVec2{pos.x - 3.0, pos.y}, ImVec2{pos.x + 4.0, pos.y}, col, 1.0)
}

// Draw a 10px wide rectangle around CurposPos.x using Line Y1/Y2 in current window's DrawList
DebugDrawLineExtents :: proc(col : ImU32)
{
	g : ^ImGuiContext = GImGui
	window : ^ImGuiWindow = g.CurrentWindow
	curr_x : f32 = window.DC.CursorPos.x
	line_y1 : f32 = (window.DC.IsSameLine ? window.DC.CursorPosPrevLine.y : window.DC.CursorPos.y)
	line_y2 : f32 = line_y1 + (window.DC.IsSameLine ? window.DC.PrevLineSize.y : window.DC.CurrLineSize.y)
	AddLine(window.DrawList, ImVec2{curr_x - 5.0, line_y1}, ImVec2{curr_x + 5.0, line_y1}, col, 1.0)
	AddLine(window.DrawList, ImVec2{curr_x - 0.5, line_y1}, ImVec2{curr_x - 0.5, line_y2}, col, 1.0)
	AddLine(window.DrawList, ImVec2{curr_x - 5.0, line_y2}, ImVec2{curr_x + 5.0, line_y2}, col, 1.0)
}

// Draw last item rect in ForegroundDrawList (so it is always visible)
DebugDrawItemRect :: proc(col : ImU32)
{
	g : ^ImGuiContext = GImGui
	window : ^ImGuiWindow = g.CurrentWindow
	AddRect(GetForegroundDrawList(window), g.LastItemData.Rect.Min, g.LastItemData.Rect.Max, col)
}

// [DEBUG] Locate item position/rectangle given an ID.
DEBUG_LOCATE_ITEM_COLOR : ImU32 = IM_COL32(0, 255, 0, 255); // Green

DebugLocateItem :: proc(target_id : ImGuiID)
{
	g : ^ImGuiContext = GImGui
	g.DebugLocateId = target_id
	g.DebugLocateFrames = 2
	g.DebugBreakInLocateId = false
}

// Only call on reaction to a mouse Hover: because only 1 at the same time!
// FIXME: Doesn't work over through a modal window, because they clear HoveredWindow.
DebugLocateItemOnHover :: proc(target_id : ImGuiID)
{
	if target_id == 0 || !IsItemHovered(ImGuiHoveredFlags_.ImGuiHoveredFlags_AllowWhenBlockedByActiveItem | ImGuiHoveredFlags_.ImGuiHoveredFlags_AllowWhenBlockedByPopup) { return }
	g : ^ImGuiContext = GImGui
	DebugLocateItem(target_id)
	AddRect(GetForegroundDrawList(g.CurrentWindow), g.LastItemData.Rect.Min - ImVec2{3.0, 3.0}, g.LastItemData.Rect.Max + ImVec2{3.0, 3.0}, DEBUG_LOCATE_ITEM_COLOR)

	// Can't easily use a context menu here because it will mess with focus, active id etc.
	if g.IO.ConfigDebugIsDebuggerPresent && g.MouseStationaryTimer > 1.0 {
		DebugBreakButtonTooltip(false, "in ItemAdd()")
		if IsKeyChordPressed(g.DebugBreakKeyChord) { g.DebugBreakInLocateId = true }
	}
}

DebugLocateItemResolveWithLastItem :: proc()
{
	g : ^ImGuiContext = GImGui

	// [DEBUG] Debug break requested by user
	if g.DebugBreakInLocateId { IM_DEBUG_BREAK() }

	item_data : ImGuiLastItemData = g.LastItemData
	g.DebugLocateId = 0
	draw_list : ^ImDrawList = GetForegroundDrawList(g.CurrentWindow)
	r : ImRect = item_data.Rect
	Expand(&r, 3.0)
	p1 : ImVec2 = g.IO.MousePos
	p2 : ImVec2 = ImVec2{(p1.x < r.Min.x) ? r.Min.x : (p1.x > r.Max.x) ? r.Max.x : p1.x, (p1.y < r.Min.y) ? r.Min.y : (p1.y > r.Max.y) ? r.Max.y : p1.y}
	AddRect(draw_list, r.Min, r.Max, DEBUG_LOCATE_ITEM_COLOR)
	AddLine(draw_list, p1, p2, DEBUG_LOCATE_ITEM_COLOR)
}

DebugStartItemPicker :: proc()
{
	g : ^ImGuiContext = GImGui
	g.DebugItemPickerActive = true
}

// [DEBUG] Item picker tool - start with DebugStartItemPicker() - useful to visually select an item and break into its call-stack.
UpdateDebugToolItemPicker :: proc()
{
	g : ^ImGuiContext = GImGui
	g.DebugItemPickerBreakId = 0
	if !g.DebugItemPickerActive { return }

	hovered_id : ImGuiID = g.HoveredIdPreviousFrame
	SetMouseCursor(ImGuiMouseCursor_.ImGuiMouseCursor_Hand)
	if IsKeyPressed(ImGuiKey.ImGuiKey_Escape) { g.DebugItemPickerActive = false }
	change_mapping : bool = g.IO.KeyMods == (ImGuiKey.ImGuiMod_Ctrl | ImGuiKey.ImGuiMod_Shift)
	if !change_mapping && IsMouseClicked(cast(ImGuiMouseButton)g.DebugItemPickerMouseButton) && hovered_id != 0 {
		g.DebugItemPickerBreakId = hovered_id
		g.DebugItemPickerActive = false
	}
	for mouse_button : i32 = 0; mouse_button < 3; mouse_button += 1 { if change_mapping && IsMouseClicked(cast(ImGuiMouseButton)mouse_button) { g.DebugItemPickerMouseButton = cast(ImU8) mouse_button } }

	SetNextWindowBgAlpha(0.70)
	if !BeginTooltip() { return }
	Text("HoveredId: 0x%08X", hovered_id)
	Text("Press ESC to abort picking.")
	mouse_button_names := [?]string {"Left", "Right", "Middle"}
	if change_mapping { Text("Remap w/ Ctrl+Shift: click anywhere to select new mouse button.") }
	else { TextColored(GetStyleColorVec4(hovered_id != 0 ? ImGuiCol_.ImGuiCol_Text : ImGuiCol_.ImGuiCol_TextDisabled), "Click %s Button to break in debugger! (remap w/ Ctrl+Shift)", mouse_button_names[g.DebugItemPickerMouseButton]) }
	EndTooltip()
}

// [DEBUG] ID Stack Tool: update queries. Called by NewFrame()
UpdateDebugToolStackQueries :: proc()
{
	g : ^ImGuiContext = GImGui
	tool : ^ImGuiIDStackTool = &g.DebugIDStackTool

	// Clear hook when id stack tool is not visible
	g.DebugHookIdInfo = 0
	if g.FrameCount != tool.LastActiveFrame + 1 { return }

	// Update queries. The steps are: -1: query Stack, >= 0: query each stack item
	// We can only perform 1 ID Info query every frame. This is designed so the GetID() tests are cheap and constant-time
	query_id : ImGuiID = g.HoveredIdPreviousFrame != 0 ? g.HoveredIdPreviousFrame : g.ActiveId
	if tool.QueryId != query_id {
		tool.QueryId = query_id
		tool.StackLevel = -1
		resize(&tool.Results, 0)
	}
	if query_id == 0 { return }

	// Advance to next stack level when we got our result, or after 2 frames (in case we never get a result)
	stack_level : i32 = tool.StackLevel
	if stack_level >= 0 && stack_level < tool.Results.Size { if tool.Results.Data[stack_level].QuerySuccess || tool.Results.Data[stack_level].QueryFrameCount > 2 { post_incr(&tool.StackLevel) } }

	// Update hook
	stack_level = tool.StackLevel
	if stack_level == -1 { g.DebugHookIdInfo = query_id }
	if stack_level >= 0 && stack_level < tool.Results.Size {
		g.DebugHookIdInfo = tool.Results.Data[stack_level].ID
		post_incr(&tool.Results.Data[stack_level].QueryFrameCount)
	}
}

// [DEBUG] ID Stack tool: hooks called by GetID() family functions
DebugHookIdInfo :: proc(id : ImGuiID, data_type : ImGuiDataType, data_id : rawptr, data_id_end : rawptr)
{
	g : ^ImGuiContext = GImGui
	window : ^ImGuiWindow = g.CurrentWindow
	tool : ^ImGuiIDStackTool = &g.DebugIDStackTool

	// Step 0: stack query
	// This assumes that the ID was computed with the current ID stack, which tends to be the case for our widget.
	if tool.StackLevel == -1 {
		post_incr(&tool.StackLevel)
		resize(&tool.Results, window.IDStack.Size + 1, ImGuiStackLevelInfo{})
		for n : i32 = 0; n < window.IDStack.Size + 1; n += 1 { tool.Results.Data[n].ID = (n < window.IDStack.Size) ? window.IDStack.Data[n] : id }

		return
	}

	// Step 1+: query for individual level
	IM_ASSERT(tool.StackLevel >= 0)
	if tool.StackLevel != window.IDStack.Size { return }
	info : ^ImGuiStackLevelInfo = &tool.Results.Data[tool.StackLevel]
	IM_ASSERT(info.ID == id && info.QueryFrameCount > 0)

	#partial switch data_type {
		case .ImGuiDataType_S32:
			ImFormatString(info.Desc[:], "%d", cast(i32) cast(uintptr) data_id)
			break

		case .ImGuiDataType_String:
			ImFormatString(info.Desc[:], "%.*s", data_id_end != nil ? cast(i32) mem.ptr_sub(cast(^u8) data_id_end, cast(^u8) data_id) : cast(i32) strlen(cast([^]u8) data_id), cast(^u8) data_id)
			break

		case cast(ImGuiDataType_) ImGuiDataTypePrivate_.ImGuiDataType_Pointer:
			ImFormatString(info.Desc[:], "(void*)0x%p", data_id)
			break

		case cast(ImGuiDataType_) ImGuiDataTypePrivate_.ImGuiDataType_ID:
			if info.Desc[0] != 0 {
				// PushOverrideID() is often used to avoid hashing twice, which would lead to 2 calls to DebugHookIdInfo(). We prioritize the first one.
				return
			}
			ImFormatString(info.Desc[:], "0x%08X [override]", id)
			break

		case:
			IM_ASSERT(false)
	}
	info.QuerySuccess = true
	info.DataType = data_type
}

StackToolFormatLevelInfo :: proc(tool : ^ImGuiIDStackTool, n : i32, format_for_ui : bool, buf : []u8) -> i32
{
	info : ^ImGuiStackLevelInfo = &tool.Results.Data[n]
	window : ^ImGuiWindow = (info.Desc[0] == 0 && n == 0) ? FindWindowByID(info.ID) : nil
	if window != nil {
		// Source: window name (because the root ID don't call GetID() and so doesn't get hooked)
		return ImFormatString(buf, format_for_ui ? "\"%s\" [window]" : "%s", window.Name)
	}
	if info.QuerySuccess {
		// Source: GetID() hooks (prioritize over ItemInfo() because we frequently use patterns like: PushID(str), Button("") where they both have same id)
		return ImFormatString(buf, (format_for_ui && info.DataType == ImGuiDataType_.ImGuiDataType_String) ? "\"%s\"" : "%s", info.Desc)
	}
	if tool.StackLevel < tool.Results.Size {
		// Only start using fallback below when all queries are done, so during queries we don't flickering ??? markers.
		buf[0] = 0
		return 0
	}
	when IMGUI_ENABLE_TEST_ENGINE { /* @gen ifdef */
	if label : string = ImGuiTestEngine_FindItemDebugLabel(GImGui, info.ID); label != nil {
		// Source: ImGuiTestEngine's ItemInfo()
		return ImFormatString(buf, format_for_ui ? "??? \"%s\"" : "%s", label)
	}
	} // preproc endif
	return ImFormatString(buf, "???")
}

// create Stack Tool window. hover items with mouse to query information about the source of their unique ID.
// ID Stack Tool: Display UI
ShowIDStackToolWindow :: proc(p_open : ^bool)
{
	g : ^ImGuiContext = GImGui
	if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_.ImGuiNextWindowDataFlags_HasSize) == {} { SetNextWindowSize(ImVec2{0.0, GetFontSize() * 8.0}, ImGuiCond_.ImGuiCond_FirstUseEver) }
	if !Begin("Dear ImGui ID Stack Tool", p_open) || GetCurrentWindow().BeginCount > 1 {
		End()
		return
	}

	// Display hovered/active status
	tool : ^ImGuiIDStackTool = &g.DebugIDStackTool
	hovered_id : ImGuiID = g.HoveredIdPreviousFrame
	active_id : ImGuiID = g.ActiveId
	when IMGUI_ENABLE_TEST_ENGINE { /* @gen ifdef */
	Text("HoveredId: 0x%08X (\"%s\"), ActiveId:  0x%08X (\"%s\")", hovered_id, hovered_id != 0 ? ImGuiTestEngine_FindItemDebugLabel(g, hovered_id) : "", active_id, active_id != 0 ? ImGuiTestEngine_FindItemDebugLabel(g, active_id) : "")
	} else { // preproc else
	Text("HoveredId: 0x%08X, ActiveId:  0x%08X", hovered_id, active_id)
	} // preproc endif
	SameLine()
	MetricsHelpMarker("Hover an item with the mouse to display elements of the ID Stack leading to the item's final ID.\nEach level of the stack correspond to a PushID() call.\nAll levels of the stack are hashed together to make the final ID of a widget (ID displayed at the bottom level of the stack).\nRead FAQ entry about the ID stack for details.")

	// CTRL+C to copy path
	time_since_copy : f32 = cast(f32) g.Time - tool.CopyToClipboardLastTime
	Checkbox("Ctrl+C: copy path to clipboard", &tool.CopyToClipboardOnCtrlC)
	SameLine()
	TextColored((time_since_copy >= 0.0 && time_since_copy < 0.75 && ImFmod(time_since_copy, 0.25) < 0.25 * 0.5) ? ImVec4{1., 1., 0.3, 1.} : ImVec4{}, "*COPIED*")
	if tool.CopyToClipboardOnCtrlC && Shortcut(ImGuiKey.ImGuiMod_Ctrl | ImGuiKey.ImGuiKey_C, ImGuiInputFlags_.ImGuiInputFlags_RouteGlobal | ImGuiInputFlags_.ImGuiInputFlags_RouteOverFocused) {
		tool.CopyToClipboardLastTime = cast(f32) g.Time
		p := g.TempBuffer.Data
		p_end := p[g.TempBuffer.Size:]
		for stack_n : i32 = 0; stack_n < tool.Results.Size && p[3:] < p_end; stack_n += 1 {
			post_incr(&p)^ = '/'
			level_desc : [256]u8
			StackToolFormatLevelInfo(tool, stack_n, false, level_desc[:])
			for n : i32 = 0; level_desc[n] != 0 && p[2:] < p_end; n += 1 {
				if level_desc[n] == '/' { post_incr(&p)^ = '\\' }
				post_incr(&p)^ = level_desc[n]
			}
		}

		p[0] = 0
		SetClipboardText(string_from_cstr(cast(cstring)g.TempBuffer.Data))
	}

	// Display decorated stack
	tool.LastActiveFrame = g.FrameCount
	if tool.Results.Size > 0 && BeginTable("##table", 3, ImGuiTableFlags_.ImGuiTableFlags_Borders) {
		id_width : f32 = CalcTextSize("0xDDDDDDDD").x
		TableSetupColumn("Seed", ImGuiTableColumnFlags_.ImGuiTableColumnFlags_WidthFixed, id_width)
		TableSetupColumn("PushID", ImGuiTableColumnFlags_.ImGuiTableColumnFlags_WidthStretch)
		TableSetupColumn("Result", ImGuiTableColumnFlags_.ImGuiTableColumnFlags_WidthFixed, id_width)
		TableHeadersRow()
		for n : i32 = 0; n < tool.Results.Size; n += 1 {
			info : ^ImGuiStackLevelInfo = &tool.Results.Data[n]
			TableNextColumn()
			Text("0x%08X", (n > 0) ? tool.Results.Data[n - 1].ID : 0)
			TableNextColumn()
			StackToolFormatLevelInfo(tool, n, true, g.TempBuffer.Data[:g.TempBuffer.Size])
			TextUnformatted(string_from_slice(g.TempBuffer.Data[:g.TempBuffer.Size]))
			TableNextColumn()
			Text("0x%08X", info.ID)
			if n == tool.Results.Size - 1 { TableSetBgColor(ImGuiTableBgTarget_.ImGuiTableBgTarget_CellBg, GetColorU32(ImGuiCol_.ImGuiCol_Header)) }
		}

		EndTable()
	}
	End()
}

} else { // preproc else

// create Metrics/Debugger window. display Dear ImGui internals: windows, draw commands, various internal state, etc.
ShowMetricsWindow :: proc(_ : ^bool) { }
ShowFontAtlas :: proc(_ : ^ImFontAtlas) { }
DebugNodeColumns :: proc(_ : ^ImGuiOldColumns) { }
DebugNodeDrawList :: proc(_ : ^ImGuiWindow, _ : ^ImGuiViewportP, _ : ^ImDrawList, _ : ^u8) { }
DebugNodeDrawCmdShowMeshAndBoundingBox :: proc(_ : ^ImDrawList, _ : ^ImDrawList, _ : ^ImDrawCmd, _ : bool, _ : bool) { }
DebugNodeFont :: proc(_ : ^ImFont) { }
DebugNodeStorage :: proc(_ : ^ImGuiStorage, _ : ^u8) { }
DebugNodeTabBar :: proc(_ : ^ImGuiTabBar, _ : ^u8) { }
DebugNodeWindow :: proc(_ : ^ImGuiWindow, _ : ^u8) { }
DebugNodeWindowSettings :: proc(_ : ^ImGuiWindowSettings) { }
DebugNodeWindowsList :: proc(_ : ^ImVector(^ImGuiWindow), _ : ^u8) { }
DebugNodeViewport :: proc(_ : ^ImGuiViewportP) { }

// create Debug Log window. display a simplified log of important dear imgui events.
ShowDebugLogWindow :: proc(_ : ^bool) { }
// create Stack Tool window. hover items with mouse to query information about the source of their unique ID.
ShowIDStackToolWindow :: proc(_ : ^bool) { }
DebugStartItemPicker :: proc() { }
DebugHookIdInfo :: proc(_ : ImGuiID, _ : ImGuiDataType, _ : rawptr, _ : rawptr) { }

} // preproc endif// #ifndef IMGUI_DISABLE_DEBUG_TOOLS

//-----------------------------------------------------------------------------

//
// imgui_draw.cpp
//
// dear imgui, v1.91.7 WIP
// (drawing and font code)

/*

Index of this file:

// [SECTION] STB libraries implementation
// [SECTION] Style functions
// [SECTION] ImDrawList
// [SECTION] ImTriangulator, ImDrawList concave polygon fill
// [SECTION] ImDrawListSplitter
// [SECTION] ImDrawData
// [SECTION] Helpers ShadeVertsXXX functions
// [SECTION] ImFontConfig
// [SECTION] ImFontAtlas
// [SECTION] ImFontAtlas: glyph ranges helpers
// [SECTION] ImFontGlyphRangesBuilder
// [SECTION] ImFont
// [SECTION] ImGui Internal Render Helpers
// [SECTION] Decompression code
// [SECTION] Default font data (ProggyClean.ttf)

*/


when IMGUI_ENABLE_FREETYPE { /* @gen ifdef */
// dear imgui: FreeType font builder (used as a replacement for the stb_truetype builder)
// (headers)

// Hinting greatly impacts visuals (and glyph sizes).
// - By default, hinting is enabled and the font's native hinter is preferred over the auto-hinter.
// - When disabled, FreeType generates blurrier glyphs, more or less matches the stb_truetype.h
// - The Default hinting mode usually looks good, but may distort glyphs in an unusual way.
// - The Light hinting mode generates fuzzier glyphs but better matches Microsoft's rasterizer.
// You can set those flags globaly in ImFontAtlas::FontBuilderFlags
// You can set those flags on a per font basis in ImFontConfig::FontBuilderFlags
ImGuiFreeTypeBuilderFlags :: enum i32 {
	ImGuiFreeTypeBuilderFlags_NoHinting = 1 << 0, // Disable hinting. This generally generates 'blurrier' bitmap glyphs when the glyph are rendered in any of the anti-aliased modes.
	ImGuiFreeTypeBuilderFlags_NoAutoHint = 1 << 1, // Disable auto-hinter.
	ImGuiFreeTypeBuilderFlags_ForceAutoHint = 1 << 2, // Indicates that the auto-hinter is preferred over the font's native hinter.
	ImGuiFreeTypeBuilderFlags_LightHinting = 1 << 3, // A lighter hinting algorithm for gray-level modes. Many generated glyphs are fuzzier but better resemble their original shape. This is achieved by snapping glyphs to the pixel grid only vertically (Y-axis), as is done by Microsoft's ClearType and Adobe's proprietary font renderer. This preserves inter-glyph spacing in horizontal text.
	ImGuiFreeTypeBuilderFlags_MonoHinting = 1 << 4, // Strong hinting algorithm that should only be used for monochrome output.
	ImGuiFreeTypeBuilderFlags_Bold = 1 << 5, // Styling: Should we artificially embolden the font?
	ImGuiFreeTypeBuilderFlags_Oblique = 1 << 6, // Styling: Should we slant the font, emulating italic style?
	ImGuiFreeTypeBuilderFlags_Monochrome = 1 << 7, // Disable anti-aliasing. Combine this with MonoHinting for best results!
	ImGuiFreeTypeBuilderFlags_LoadColor = 1 << 8, // Enable FreeType color-layered glyphs
	ImGuiFreeTypeBuilderFlags_Bitmap = 1 << 9,
}

// Obsolete names (will be removed soon)

} // preproc endif


//-------------------------------------------------------------------------
// [SECTION] STB libraries implementation (for stb_truetype and stb_rect_pack)
//-------------------------------------------------------------------------

STBRP_STATIC :: true // @cleanup
STBRP_ASSERT :: IM_ASSERT

STBRP_SORT :: ImQsort

when IMGUI_ENABLE_STB_TRUETYPE { /* @gen ifdef */
STBTT_malloc :: #force_inline proc "contextless" (x : $T0, u : $T1) -> rawptr
{
	_ = u
	return IM_ALLOC(x)
}

STBTT_free :: #force_inline proc "contextless" (x : ^$T0, u : $T1)
{
	_ = u
	IM_FREE(x)
}

STBTT_assert :: IM_ASSERT

STBTT_fmod :: ImFmod

STBTT_sqrt :: ImSqrt

STBTT_pow :: ImPow

STBTT_fabs :: ImFabs

STBTT_ifloor :: #force_inline proc "contextless" (x : $T0) -> i32
{
	return cast(i32)ImFloor(x)
}

STBTT_iceil :: #force_inline proc "contextless" (x : $T0) -> i32
{
	return cast(int)ImCeil(x)
}
} // preproc endif

//-----------------------------------------------------------------------------
// [SECTION] Style functions
//-----------------------------------------------------------------------------

StyleColorsDark :: proc(dst : ^ImGuiStyle = nil)
{
	style : ^ImGuiStyle = dst != nil ? dst : GetStyle()
	colors := &style.Colors

	colors[ImGuiCol_.ImGuiCol_Text] = ImVec4{1.00, 1.00, 1.00, 1.00}
	colors[ImGuiCol_.ImGuiCol_TextDisabled] = ImVec4{0.50, 0.50, 0.50, 1.00}
	colors[ImGuiCol_.ImGuiCol_WindowBg] = ImVec4{0.06, 0.06, 0.06, 0.94}
	colors[ImGuiCol_.ImGuiCol_ChildBg] = ImVec4{0.00, 0.00, 0.00, 0.00}
	colors[ImGuiCol_.ImGuiCol_PopupBg] = ImVec4{0.08, 0.08, 0.08, 0.94}
	colors[ImGuiCol_.ImGuiCol_Border] = ImVec4{0.43, 0.43, 0.50, 0.50}
	colors[ImGuiCol_.ImGuiCol_BorderShadow] = ImVec4{0.00, 0.00, 0.00, 0.00}
	colors[ImGuiCol_.ImGuiCol_FrameBg] = ImVec4{0.16, 0.29, 0.48, 0.54}
	colors[ImGuiCol_.ImGuiCol_FrameBgHovered] = ImVec4{0.26, 0.59, 0.98, 0.40}
	colors[ImGuiCol_.ImGuiCol_FrameBgActive] = ImVec4{0.26, 0.59, 0.98, 0.67}
	colors[ImGuiCol_.ImGuiCol_TitleBg] = ImVec4{0.04, 0.04, 0.04, 1.00}
	colors[ImGuiCol_.ImGuiCol_TitleBgActive] = ImVec4{0.16, 0.29, 0.48, 1.00}
	colors[ImGuiCol_.ImGuiCol_TitleBgCollapsed] = ImVec4{0.00, 0.00, 0.00, 0.51}
	colors[ImGuiCol_.ImGuiCol_MenuBarBg] = ImVec4{0.14, 0.14, 0.14, 1.00}
	colors[ImGuiCol_.ImGuiCol_ScrollbarBg] = ImVec4{0.02, 0.02, 0.02, 0.53}
	colors[ImGuiCol_.ImGuiCol_ScrollbarGrab] = ImVec4{0.31, 0.31, 0.31, 1.00}
	colors[ImGuiCol_.ImGuiCol_ScrollbarGrabHovered] = ImVec4{0.41, 0.41, 0.41, 1.00}
	colors[ImGuiCol_.ImGuiCol_ScrollbarGrabActive] = ImVec4{0.51, 0.51, 0.51, 1.00}
	colors[ImGuiCol_.ImGuiCol_CheckMark] = ImVec4{0.26, 0.59, 0.98, 1.00}
	colors[ImGuiCol_.ImGuiCol_SliderGrab] = ImVec4{0.24, 0.52, 0.88, 1.00}
	colors[ImGuiCol_.ImGuiCol_SliderGrabActive] = ImVec4{0.26, 0.59, 0.98, 1.00}
	colors[ImGuiCol_.ImGuiCol_Button] = ImVec4{0.26, 0.59, 0.98, 0.40}
	colors[ImGuiCol_.ImGuiCol_ButtonHovered] = ImVec4{0.26, 0.59, 0.98, 1.00}
	colors[ImGuiCol_.ImGuiCol_ButtonActive] = ImVec4{0.06, 0.53, 0.98, 1.00}
	colors[ImGuiCol_.ImGuiCol_Header] = ImVec4{0.26, 0.59, 0.98, 0.31}
	colors[ImGuiCol_.ImGuiCol_HeaderHovered] = ImVec4{0.26, 0.59, 0.98, 0.80}
	colors[ImGuiCol_.ImGuiCol_HeaderActive] = ImVec4{0.26, 0.59, 0.98, 1.00}
	colors[ImGuiCol_.ImGuiCol_Separator] = colors[ImGuiCol_.ImGuiCol_Border]
	colors[ImGuiCol_.ImGuiCol_SeparatorHovered] = ImVec4{0.10, 0.40, 0.75, 0.78}
	colors[ImGuiCol_.ImGuiCol_SeparatorActive] = ImVec4{0.10, 0.40, 0.75, 1.00}
	colors[ImGuiCol_.ImGuiCol_ResizeGrip] = ImVec4{0.26, 0.59, 0.98, 0.20}
	colors[ImGuiCol_.ImGuiCol_ResizeGripHovered] = ImVec4{0.26, 0.59, 0.98, 0.67}
	colors[ImGuiCol_.ImGuiCol_ResizeGripActive] = ImVec4{0.26, 0.59, 0.98, 0.95}
	colors[ImGuiCol_.ImGuiCol_TabHovered] = colors[ImGuiCol_.ImGuiCol_HeaderHovered]
	colors[ImGuiCol_.ImGuiCol_Tab] = ImLerp(colors[ImGuiCol_.ImGuiCol_Header], colors[ImGuiCol_.ImGuiCol_TitleBgActive], 0.80)
	colors[ImGuiCol_.ImGuiCol_TabSelected] = ImLerp(colors[ImGuiCol_.ImGuiCol_HeaderActive], colors[ImGuiCol_.ImGuiCol_TitleBgActive], 0.60)
	colors[ImGuiCol_.ImGuiCol_TabSelectedOverline] = colors[ImGuiCol_.ImGuiCol_HeaderActive]
	colors[ImGuiCol_.ImGuiCol_TabDimmed] = ImLerp(colors[ImGuiCol_.ImGuiCol_Tab], colors[ImGuiCol_.ImGuiCol_TitleBg], 0.80)
	colors[ImGuiCol_.ImGuiCol_TabDimmedSelected] = ImLerp(colors[ImGuiCol_.ImGuiCol_TabSelected], colors[ImGuiCol_.ImGuiCol_TitleBg], 0.40)
	colors[ImGuiCol_.ImGuiCol_TabDimmedSelectedOverline] = ImVec4{0.50, 0.50, 0.50, 0.00}
	colors[ImGuiCol_.ImGuiCol_DockingPreview] = colors[ImGuiCol_.ImGuiCol_HeaderActive] * ImVec4{1.0, 1.0, 1.0, 0.7}
	colors[ImGuiCol_.ImGuiCol_DockingEmptyBg] = ImVec4{0.20, 0.20, 0.20, 1.00}
	colors[ImGuiCol_.ImGuiCol_PlotLines] = ImVec4{0.61, 0.61, 0.61, 1.00}
	colors[ImGuiCol_.ImGuiCol_PlotLinesHovered] = ImVec4{1.00, 0.43, 0.35, 1.00}
	colors[ImGuiCol_.ImGuiCol_PlotHistogram] = ImVec4{0.90, 0.70, 0.00, 1.00}
	colors[ImGuiCol_.ImGuiCol_PlotHistogramHovered] = ImVec4{1.00, 0.60, 0.00, 1.00}
	colors[ImGuiCol_.ImGuiCol_TableHeaderBg] = ImVec4{0.19, 0.19, 0.20, 1.00}
	colors[ImGuiCol_.ImGuiCol_TableBorderStrong] = ImVec4{0.31, 0.31, 0.35, 1.00}; // Prefer using Alpha=1.0 here
	colors[ImGuiCol_.ImGuiCol_TableBorderLight] = ImVec4{0.23, 0.23, 0.25, 1.00}; // Prefer using Alpha=1.0 here
	colors[ImGuiCol_.ImGuiCol_TableRowBg] = ImVec4{0.00, 0.00, 0.00, 0.00}
	colors[ImGuiCol_.ImGuiCol_TableRowBgAlt] = ImVec4{1.00, 1.00, 1.00, 0.06}
	colors[ImGuiCol_.ImGuiCol_TextLink] = colors[ImGuiCol_.ImGuiCol_HeaderActive]
	colors[ImGuiCol_.ImGuiCol_TextSelectedBg] = ImVec4{0.26, 0.59, 0.98, 0.35}
	colors[ImGuiCol_.ImGuiCol_DragDropTarget] = ImVec4{1.00, 1.00, 0.00, 0.90}
	colors[ImGuiCol_.ImGuiCol_NavCursor] = ImVec4{0.26, 0.59, 0.98, 1.00}
	colors[ImGuiCol_.ImGuiCol_NavWindowingHighlight] = ImVec4{1.00, 1.00, 1.00, 0.70}
	colors[ImGuiCol_.ImGuiCol_NavWindowingDimBg] = ImVec4{0.80, 0.80, 0.80, 0.20}
	colors[ImGuiCol_.ImGuiCol_ModalWindowDimBg] = ImVec4{0.80, 0.80, 0.80, 0.35}
}

StyleColorsClassic :: proc(dst : ^ImGuiStyle = nil)
{
	style : ^ImGuiStyle = dst != nil ? dst : GetStyle()
	colors := &style.Colors

	colors[ImGuiCol_.ImGuiCol_Text] = ImVec4{0.90, 0.90, 0.90, 1.00}
	colors[ImGuiCol_.ImGuiCol_TextDisabled] = ImVec4{0.60, 0.60, 0.60, 1.00}
	colors[ImGuiCol_.ImGuiCol_WindowBg] = ImVec4{0.00, 0.00, 0.00, 0.85}
	colors[ImGuiCol_.ImGuiCol_ChildBg] = ImVec4{0.00, 0.00, 0.00, 0.00}
	colors[ImGuiCol_.ImGuiCol_PopupBg] = ImVec4{0.11, 0.11, 0.14, 0.92}
	colors[ImGuiCol_.ImGuiCol_Border] = ImVec4{0.50, 0.50, 0.50, 0.50}
	colors[ImGuiCol_.ImGuiCol_BorderShadow] = ImVec4{0.00, 0.00, 0.00, 0.00}
	colors[ImGuiCol_.ImGuiCol_FrameBg] = ImVec4{0.43, 0.43, 0.43, 0.39}
	colors[ImGuiCol_.ImGuiCol_FrameBgHovered] = ImVec4{0.47, 0.47, 0.69, 0.40}
	colors[ImGuiCol_.ImGuiCol_FrameBgActive] = ImVec4{0.42, 0.41, 0.64, 0.69}
	colors[ImGuiCol_.ImGuiCol_TitleBg] = ImVec4{0.27, 0.27, 0.54, 0.83}
	colors[ImGuiCol_.ImGuiCol_TitleBgActive] = ImVec4{0.32, 0.32, 0.63, 0.87}
	colors[ImGuiCol_.ImGuiCol_TitleBgCollapsed] = ImVec4{0.40, 0.40, 0.80, 0.20}
	colors[ImGuiCol_.ImGuiCol_MenuBarBg] = ImVec4{0.40, 0.40, 0.55, 0.80}
	colors[ImGuiCol_.ImGuiCol_ScrollbarBg] = ImVec4{0.20, 0.25, 0.30, 0.60}
	colors[ImGuiCol_.ImGuiCol_ScrollbarGrab] = ImVec4{0.40, 0.40, 0.80, 0.30}
	colors[ImGuiCol_.ImGuiCol_ScrollbarGrabHovered] = ImVec4{0.40, 0.40, 0.80, 0.40}
	colors[ImGuiCol_.ImGuiCol_ScrollbarGrabActive] = ImVec4{0.41, 0.39, 0.80, 0.60}
	colors[ImGuiCol_.ImGuiCol_CheckMark] = ImVec4{0.90, 0.90, 0.90, 0.50}
	colors[ImGuiCol_.ImGuiCol_SliderGrab] = ImVec4{1.00, 1.00, 1.00, 0.30}
	colors[ImGuiCol_.ImGuiCol_SliderGrabActive] = ImVec4{0.41, 0.39, 0.80, 0.60}
	colors[ImGuiCol_.ImGuiCol_Button] = ImVec4{0.35, 0.40, 0.61, 0.62}
	colors[ImGuiCol_.ImGuiCol_ButtonHovered] = ImVec4{0.40, 0.48, 0.71, 0.79}
	colors[ImGuiCol_.ImGuiCol_ButtonActive] = ImVec4{0.46, 0.54, 0.80, 1.00}
	colors[ImGuiCol_.ImGuiCol_Header] = ImVec4{0.40, 0.40, 0.90, 0.45}
	colors[ImGuiCol_.ImGuiCol_HeaderHovered] = ImVec4{0.45, 0.45, 0.90, 0.80}
	colors[ImGuiCol_.ImGuiCol_HeaderActive] = ImVec4{0.53, 0.53, 0.87, 0.80}
	colors[ImGuiCol_.ImGuiCol_Separator] = ImVec4{0.50, 0.50, 0.50, 0.60}
	colors[ImGuiCol_.ImGuiCol_SeparatorHovered] = ImVec4{0.60, 0.60, 0.70, 1.00}
	colors[ImGuiCol_.ImGuiCol_SeparatorActive] = ImVec4{0.70, 0.70, 0.90, 1.00}
	colors[ImGuiCol_.ImGuiCol_ResizeGrip] = ImVec4{1.00, 1.00, 1.00, 0.10}
	colors[ImGuiCol_.ImGuiCol_ResizeGripHovered] = ImVec4{0.78, 0.82, 1.00, 0.60}
	colors[ImGuiCol_.ImGuiCol_ResizeGripActive] = ImVec4{0.78, 0.82, 1.00, 0.90}
	colors[ImGuiCol_.ImGuiCol_TabHovered] = colors[ImGuiCol_.ImGuiCol_HeaderHovered]
	colors[ImGuiCol_.ImGuiCol_Tab] = ImLerp(colors[ImGuiCol_.ImGuiCol_Header], colors[ImGuiCol_.ImGuiCol_TitleBgActive], 0.80)
	colors[ImGuiCol_.ImGuiCol_TabSelected] = ImLerp(colors[ImGuiCol_.ImGuiCol_HeaderActive], colors[ImGuiCol_.ImGuiCol_TitleBgActive], 0.60)
	colors[ImGuiCol_.ImGuiCol_TabSelectedOverline] = colors[ImGuiCol_.ImGuiCol_HeaderActive]
	colors[ImGuiCol_.ImGuiCol_TabDimmed] = ImLerp(colors[ImGuiCol_.ImGuiCol_Tab], colors[ImGuiCol_.ImGuiCol_TitleBg], 0.80)
	colors[ImGuiCol_.ImGuiCol_TabDimmedSelected] = ImLerp(colors[ImGuiCol_.ImGuiCol_TabSelected], colors[ImGuiCol_.ImGuiCol_TitleBg], 0.40)
	colors[ImGuiCol_.ImGuiCol_TabDimmedSelectedOverline] = ImVec4{0.53, 0.53, 0.87, 0.00}
	colors[ImGuiCol_.ImGuiCol_DockingPreview] = colors[ImGuiCol_.ImGuiCol_Header] * ImVec4{1.0, 1.0, 1.0, 0.7}
	colors[ImGuiCol_.ImGuiCol_DockingEmptyBg] = ImVec4{0.20, 0.20, 0.20, 1.00}
	colors[ImGuiCol_.ImGuiCol_PlotLines] = ImVec4{1.00, 1.00, 1.00, 1.00}
	colors[ImGuiCol_.ImGuiCol_PlotLinesHovered] = ImVec4{0.90, 0.70, 0.00, 1.00}
	colors[ImGuiCol_.ImGuiCol_PlotHistogram] = ImVec4{0.90, 0.70, 0.00, 1.00}
	colors[ImGuiCol_.ImGuiCol_PlotHistogramHovered] = ImVec4{1.00, 0.60, 0.00, 1.00}
	colors[ImGuiCol_.ImGuiCol_TableHeaderBg] = ImVec4{0.27, 0.27, 0.38, 1.00}
	colors[ImGuiCol_.ImGuiCol_TableBorderStrong] = ImVec4{0.31, 0.31, 0.45, 1.00}; // Prefer using Alpha=1.0 here
	colors[ImGuiCol_.ImGuiCol_TableBorderLight] = ImVec4{0.26, 0.26, 0.28, 1.00}; // Prefer using Alpha=1.0 here
	colors[ImGuiCol_.ImGuiCol_TableRowBg] = ImVec4{0.00, 0.00, 0.00, 0.00}
	colors[ImGuiCol_.ImGuiCol_TableRowBgAlt] = ImVec4{1.00, 1.00, 1.00, 0.07}
	colors[ImGuiCol_.ImGuiCol_TextLink] = colors[ImGuiCol_.ImGuiCol_HeaderActive]
	colors[ImGuiCol_.ImGuiCol_TextSelectedBg] = ImVec4{0.00, 0.00, 1.00, 0.35}
	colors[ImGuiCol_.ImGuiCol_DragDropTarget] = ImVec4{1.00, 1.00, 0.00, 0.90}
	colors[ImGuiCol_.ImGuiCol_NavCursor] = colors[ImGuiCol_.ImGuiCol_HeaderHovered]
	colors[ImGuiCol_.ImGuiCol_NavWindowingHighlight] = ImVec4{1.00, 1.00, 1.00, 0.70}
	colors[ImGuiCol_.ImGuiCol_NavWindowingDimBg] = ImVec4{0.80, 0.80, 0.80, 0.20}
	colors[ImGuiCol_.ImGuiCol_ModalWindowDimBg] = ImVec4{0.20, 0.20, 0.20, 0.35}
}

// Those light colors are better suited with a thicker font than the default one + FrameBorder
StyleColorsLight :: proc(dst : ^ImGuiStyle = nil)
{
	style : ^ImGuiStyle = dst != nil ? dst : GetStyle()
	colors := &style.Colors

	colors[ImGuiCol_.ImGuiCol_Text] = ImVec4{0.00, 0.00, 0.00, 1.00}
	colors[ImGuiCol_.ImGuiCol_TextDisabled] = ImVec4{0.60, 0.60, 0.60, 1.00}
	colors[ImGuiCol_.ImGuiCol_WindowBg] = ImVec4{0.94, 0.94, 0.94, 1.00}
	colors[ImGuiCol_.ImGuiCol_ChildBg] = ImVec4{0.00, 0.00, 0.00, 0.00}
	colors[ImGuiCol_.ImGuiCol_PopupBg] = ImVec4{1.00, 1.00, 1.00, 0.98}
	colors[ImGuiCol_.ImGuiCol_Border] = ImVec4{0.00, 0.00, 0.00, 0.30}
	colors[ImGuiCol_.ImGuiCol_BorderShadow] = ImVec4{0.00, 0.00, 0.00, 0.00}
	colors[ImGuiCol_.ImGuiCol_FrameBg] = ImVec4{1.00, 1.00, 1.00, 1.00}
	colors[ImGuiCol_.ImGuiCol_FrameBgHovered] = ImVec4{0.26, 0.59, 0.98, 0.40}
	colors[ImGuiCol_.ImGuiCol_FrameBgActive] = ImVec4{0.26, 0.59, 0.98, 0.67}
	colors[ImGuiCol_.ImGuiCol_TitleBg] = ImVec4{0.96, 0.96, 0.96, 1.00}
	colors[ImGuiCol_.ImGuiCol_TitleBgActive] = ImVec4{0.82, 0.82, 0.82, 1.00}
	colors[ImGuiCol_.ImGuiCol_TitleBgCollapsed] = ImVec4{1.00, 1.00, 1.00, 0.51}
	colors[ImGuiCol_.ImGuiCol_MenuBarBg] = ImVec4{0.86, 0.86, 0.86, 1.00}
	colors[ImGuiCol_.ImGuiCol_ScrollbarBg] = ImVec4{0.98, 0.98, 0.98, 0.53}
	colors[ImGuiCol_.ImGuiCol_ScrollbarGrab] = ImVec4{0.69, 0.69, 0.69, 0.80}
	colors[ImGuiCol_.ImGuiCol_ScrollbarGrabHovered] = ImVec4{0.49, 0.49, 0.49, 0.80}
	colors[ImGuiCol_.ImGuiCol_ScrollbarGrabActive] = ImVec4{0.49, 0.49, 0.49, 1.00}
	colors[ImGuiCol_.ImGuiCol_CheckMark] = ImVec4{0.26, 0.59, 0.98, 1.00}
	colors[ImGuiCol_.ImGuiCol_SliderGrab] = ImVec4{0.26, 0.59, 0.98, 0.78}
	colors[ImGuiCol_.ImGuiCol_SliderGrabActive] = ImVec4{0.46, 0.54, 0.80, 0.60}
	colors[ImGuiCol_.ImGuiCol_Button] = ImVec4{0.26, 0.59, 0.98, 0.40}
	colors[ImGuiCol_.ImGuiCol_ButtonHovered] = ImVec4{0.26, 0.59, 0.98, 1.00}
	colors[ImGuiCol_.ImGuiCol_ButtonActive] = ImVec4{0.06, 0.53, 0.98, 1.00}
	colors[ImGuiCol_.ImGuiCol_Header] = ImVec4{0.26, 0.59, 0.98, 0.31}
	colors[ImGuiCol_.ImGuiCol_HeaderHovered] = ImVec4{0.26, 0.59, 0.98, 0.80}
	colors[ImGuiCol_.ImGuiCol_HeaderActive] = ImVec4{0.26, 0.59, 0.98, 1.00}
	colors[ImGuiCol_.ImGuiCol_Separator] = ImVec4{0.39, 0.39, 0.39, 0.62}
	colors[ImGuiCol_.ImGuiCol_SeparatorHovered] = ImVec4{0.14, 0.44, 0.80, 0.78}
	colors[ImGuiCol_.ImGuiCol_SeparatorActive] = ImVec4{0.14, 0.44, 0.80, 1.00}
	colors[ImGuiCol_.ImGuiCol_ResizeGrip] = ImVec4{0.35, 0.35, 0.35, 0.17}
	colors[ImGuiCol_.ImGuiCol_ResizeGripHovered] = ImVec4{0.26, 0.59, 0.98, 0.67}
	colors[ImGuiCol_.ImGuiCol_ResizeGripActive] = ImVec4{0.26, 0.59, 0.98, 0.95}
	colors[ImGuiCol_.ImGuiCol_TabHovered] = colors[ImGuiCol_.ImGuiCol_HeaderHovered]
	colors[ImGuiCol_.ImGuiCol_Tab] = ImLerp(colors[ImGuiCol_.ImGuiCol_Header], colors[ImGuiCol_.ImGuiCol_TitleBgActive], 0.90)
	colors[ImGuiCol_.ImGuiCol_TabSelected] = ImLerp(colors[ImGuiCol_.ImGuiCol_HeaderActive], colors[ImGuiCol_.ImGuiCol_TitleBgActive], 0.60)
	colors[ImGuiCol_.ImGuiCol_TabSelectedOverline] = colors[ImGuiCol_.ImGuiCol_HeaderActive]
	colors[ImGuiCol_.ImGuiCol_TabDimmed] = ImLerp(colors[ImGuiCol_.ImGuiCol_Tab], colors[ImGuiCol_.ImGuiCol_TitleBg], 0.80)
	colors[ImGuiCol_.ImGuiCol_TabDimmedSelected] = ImLerp(colors[ImGuiCol_.ImGuiCol_TabSelected], colors[ImGuiCol_.ImGuiCol_TitleBg], 0.40)
	colors[ImGuiCol_.ImGuiCol_TabDimmedSelectedOverline] = ImVec4{0.26, 0.59, 1.00, 0.00}
	colors[ImGuiCol_.ImGuiCol_DockingPreview] = colors[ImGuiCol_.ImGuiCol_Header] * ImVec4{1.0, 1.0, 1.0, 0.7}
	colors[ImGuiCol_.ImGuiCol_DockingEmptyBg] = ImVec4{0.20, 0.20, 0.20, 1.00}
	colors[ImGuiCol_.ImGuiCol_PlotLines] = ImVec4{0.39, 0.39, 0.39, 1.00}
	colors[ImGuiCol_.ImGuiCol_PlotLinesHovered] = ImVec4{1.00, 0.43, 0.35, 1.00}
	colors[ImGuiCol_.ImGuiCol_PlotHistogram] = ImVec4{0.90, 0.70, 0.00, 1.00}
	colors[ImGuiCol_.ImGuiCol_PlotHistogramHovered] = ImVec4{1.00, 0.45, 0.00, 1.00}
	colors[ImGuiCol_.ImGuiCol_TableHeaderBg] = ImVec4{0.78, 0.87, 0.98, 1.00}
	colors[ImGuiCol_.ImGuiCol_TableBorderStrong] = ImVec4{0.57, 0.57, 0.64, 1.00}; // Prefer using Alpha=1.0 here
	colors[ImGuiCol_.ImGuiCol_TableBorderLight] = ImVec4{0.68, 0.68, 0.74, 1.00}; // Prefer using Alpha=1.0 here
	colors[ImGuiCol_.ImGuiCol_TableRowBg] = ImVec4{0.00, 0.00, 0.00, 0.00}
	colors[ImGuiCol_.ImGuiCol_TableRowBgAlt] = ImVec4{0.30, 0.30, 0.30, 0.09}
	colors[ImGuiCol_.ImGuiCol_TextLink] = colors[ImGuiCol_.ImGuiCol_HeaderActive]
	colors[ImGuiCol_.ImGuiCol_TextSelectedBg] = ImVec4{0.26, 0.59, 0.98, 0.35}
	colors[ImGuiCol_.ImGuiCol_DragDropTarget] = ImVec4{0.26, 0.59, 0.98, 0.95}
	colors[ImGuiCol_.ImGuiCol_NavCursor] = colors[ImGuiCol_.ImGuiCol_HeaderHovered]
	colors[ImGuiCol_.ImGuiCol_NavWindowingHighlight] = ImVec4{0.70, 0.70, 0.70, 0.70}
	colors[ImGuiCol_.ImGuiCol_NavWindowingDimBg] = ImVec4{0.20, 0.20, 0.20, 0.20}
	colors[ImGuiCol_.ImGuiCol_ModalWindowDimBg] = ImVec4{0.20, 0.20, 0.20, 0.35}
}

//-----------------------------------------------------------------------------
// [SECTION] ImDrawList
//-----------------------------------------------------------------------------

ImDrawListSharedData_init :: proc(this : ^ImDrawListSharedData)
{
	this^ = {}
	for i : i32 = 0; i < cast(i32)IM_ARRAYSIZE(this.ArcFastVtx); i += 1 {
		a : f32 = (cast(f32) i * 2 * IM_PI) / cast(f32) IM_ARRAYSIZE(this.ArcFastVtx)
		this.ArcFastVtx[i] = ImVec2{ImCos(a), ImSin(a)}
	}

	this.ArcFastRadiusCutoff = IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_CALC_R(IM_DRAWLIST_ARCFAST_SAMPLE_MAX, this.CircleSegmentMaxError)
}

ImDrawListSharedData_SetCircleTessellationMaxError :: proc(this : ^ImDrawListSharedData, max_error : f32)
{
	if this.CircleSegmentMaxError == max_error { return }

	IM_ASSERT(max_error > 0.0)
	this.CircleSegmentMaxError = max_error
	for i : i32 = 0; i < cast(i32)IM_ARRAYSIZE(this.CircleSegmentCounts); i += 1 {
		radius : f32 = cast(f32) i
		this.CircleSegmentCounts[i] = cast(ImU8) ((i > 0) ? IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_CALC(radius, this.CircleSegmentMaxError) : IM_DRAWLIST_ARCFAST_SAMPLE_MAX)
	}

	this.ArcFastRadiusCutoff = IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_CALC_R(IM_DRAWLIST_ARCFAST_SAMPLE_MAX, this.CircleSegmentMaxError)
}

ImDrawList_init :: proc(this : ^ImDrawList, shared_data : ^ImDrawListSharedData)
{
	this^ = {}
	this._Data = shared_data
}

ImDrawList_deinit :: proc(this : ^ImDrawList)
{
	deinit(&this.CmdBuffer)
	deinit(&this.IdxBuffer)
	deinit(&this.VtxBuffer)
	deinit(&this._Path)
	deinit(&this._Splitter)
	deinit(&this._ClipRectStack)
	deinit(&this._TextureIdStack)
	deinit(&this._CallbacksDataBuf)
	ImDrawList__ClearFreeMemory(this)
}

// Obsolete names
//inline  void  AddEllipse(const ImVec2& center, float radius_x, float radius_y, ImU32 col, float rot = 0.0f, int num_segments = 0, float thickness = 1.0f) { AddEllipse(center, ImVec2{radius_x, radius_y}, col, rot, num_segments, thickness); } // OBSOLETED in 1.90.5 (Mar 2024)
//inline  void  AddEllipseFilled(const ImVec2& center, float radius_x, float radius_y, ImU32 col, float rot = 0.0f, int num_segments = 0) { AddEllipseFilled(center, ImVec2{radius_x, radius_y}, col, rot, num_segments); }                        // OBSOLETED in 1.90.5 (Mar 2024)
//inline  void  PathEllipticalArcTo(const ImVec2& center, float radius_x, float radius_y, float rot, float a_min, float a_max, int num_segments = 0) { PathEllipticalArcTo(center, ImVec2{radius_x, radius_y}, rot, a_min, a_max, num_segments); } // OBSOLETED in 1.90.5 (Mar 2024)
//inline  void  AddBezierCurve(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, const ImVec2& p4, ImU32 col, float thickness, int num_segments = 0) { AddBezierCubic(p1, p2, p3, p4, col, thickness, num_segments); }                         // OBSOLETED in 1.80 (Jan 2021)
//inline  void  PathBezierCurveTo(const ImVec2& p2, const ImVec2& p3, const ImVec2& p4, int num_segments = 0) { PathBezierCubicCurveTo(p2, p3, p4, num_segments); }                                                                                // OBSOLETED in 1.80 (Jan 2021)

// [Internal helpers]
// Initialize before use in a new frame. We always have a command ready in the buffer.
// In the majority of cases, you would want to call PushClipRect() and PushTextureID() after this.
ImDrawList__ResetForNewFrame :: proc(this : ^ImDrawList)
{
	// Verify that the ImDrawCmd fields we want to memcmp() are contiguous in memory.
	#assert(offset_of(ImDrawCmd, ClipRect) == 0)
	#assert(offset_of(ImDrawCmd, TextureId) == size_of(ImVec4))
	#assert(offset_of(ImDrawCmd, VtxOffset) == size_of(ImVec4) + size_of(ImTextureID))
	if this._Splitter._Count > 1 { Merge(&this._Splitter, this) }

	resize(&this.CmdBuffer, 0)
	resize(&this.IdxBuffer, 0)
	resize(&this.VtxBuffer, 0)
	this.Flags = this._Data.InitialFlags
	memset(&this._CmdHeader, 0, size_of(this._CmdHeader))
	this._VtxCurrentIdx = 0
	this._VtxWritePtr = nil
	this._IdxWritePtr = nil
	resize(&this._ClipRectStack, 0)
	resize(&this._TextureIdStack, 0)
	resize(&this._CallbacksDataBuf, 0)
	resize(&this._Path, 0)
	Clear(&this._Splitter)
	push_back(&this.CmdBuffer, ImDrawCmd{})
	this._FringeScale = 1.0
}

ImDrawList__ClearFreeMemory :: proc(this : ^ImDrawList)
{
	clear(&this.CmdBuffer)
	clear(&this.IdxBuffer)
	clear(&this.VtxBuffer)
	this.Flags = ImDrawListFlags_.ImDrawListFlags_None
	this._VtxCurrentIdx = 0
	this._VtxWritePtr = nil
	this._IdxWritePtr = nil
	clear(&this._ClipRectStack)
	clear(&this._TextureIdStack)
	clear(&this._CallbacksDataBuf)
	clear(&this._Path)
	ClearFreeMemory(&this._Splitter)
}

// Create a clone of the CmdBuffer/IdxBuffer/VtxBuffer.
ImDrawList_CloneOutput :: proc(this : ^ImDrawList) -> ^ImDrawList
{
	dst : ^ImDrawList = IM_NEW_MEM(ImDrawList); init(dst, this._Data)
	dst.CmdBuffer = this.CmdBuffer
	dst.IdxBuffer = this.IdxBuffer
	dst.VtxBuffer = this.VtxBuffer
	dst.Flags = this.Flags
	return dst
}

// Advanced: Miscellaneous
// This is useful if you need to forcefully create a new draw call (to allow for dependent rendering / blending). Otherwise primitives are merged into the same draw-call as much as possible
ImDrawList_AddDrawCmd :: proc(this : ^ImDrawList)
{
	draw_cmd : ImDrawCmd
	draw_cmd.ClipRect = this._CmdHeader.ClipRect; // Same as calling ImDrawCmd_HeaderCopy()
	draw_cmd.TextureId = this._CmdHeader.TextureId
	draw_cmd.VtxOffset = this._CmdHeader.VtxOffset
	draw_cmd.IdxOffset = cast(u32) this.IdxBuffer.Size

	IM_ASSERT(draw_cmd.ClipRect.x <= draw_cmd.ClipRect.z && draw_cmd.ClipRect.y <= draw_cmd.ClipRect.w)
	push_back(&this.CmdBuffer, draw_cmd)
}

// Pop trailing draw command (used before merging or presenting to user)
// Note that this leaves the ImDrawList in a state unfit for further commands, as most code assume that CmdBuffer.Size > 0 && CmdBuffer.back().UserCallback == NULL
ImDrawList__PopUnusedDrawCmd :: proc(this : ^ImDrawList)
{
	for this.CmdBuffer.Size > 0 {
		curr_cmd : ^ImDrawCmd = &this.CmdBuffer.Data[this.CmdBuffer.Size - 1]
		if curr_cmd.ElemCount != 0 || curr_cmd.UserCallback != nil {
			// break;
			return
		}
		pop_back(&this.CmdBuffer)
	}
}

// Advanced: Draw Callbacks
// - May be used to alter render state (change sampler, blending, current shader). May be used to emit custom rendering commands (difficult to do correctly, but possible).
// - Use special ImDrawCallback_ResetRenderState callback to instruct backend to reset its render state to the default.
// - Your rendering loop must check for 'UserCallback' in ImDrawCmd and call the function instead of rendering triangles. All standard backends are honoring this.
// - For some backends, the callback may access selected render-states exposed by the backend in a ImGui_ImplXXXX_RenderState structure pointed to by platform_io.Renderer_RenderState.
// - IMPORTANT: please be mindful of the different level of indirection between using size==0 (copying argument) and using size>0 (copying pointed data into a buffer).
//   - If userdata_size == 0: we copy/store the 'userdata' argument as-is. It will be available unmodified in ImDrawCmd::UserCallbackData during render.
//   - If userdata_size > 0,  we copy/store 'userdata_size' bytes pointed to by 'userdata'. We store them in a buffer stored inside the drawlist. ImDrawCmd::UserCallbackData will point inside that buffer so you have to retrieve data from there. Your callback may need to use ImDrawCmd::UserCallbackDataSize if you expect dynamically-sized data.
//   - Support for userdata_size > 0 was added in v1.91.4, October 2024. So earlier code always only allowed to copy/store a simple void*.
ImDrawList_AddCallback :: proc(this : ^ImDrawList, callback : ImDrawCallback, userdata : rawptr, userdata_size : uint = 0)
{
	IM_ASSERT_PARANOID(this.CmdBuffer.Size > 0)
	curr_cmd : ^ImDrawCmd = &this.CmdBuffer.Data[this.CmdBuffer.Size - 1]
	IM_ASSERT(curr_cmd.UserCallback == nil)
	if curr_cmd.ElemCount != 0 {
		ImDrawList_AddDrawCmd(this)
		curr_cmd = &this.CmdBuffer.Data[this.CmdBuffer.Size - 1]
	}

	curr_cmd.UserCallback = callback
	if userdata_size == 0 {
		// Store user data directly in command (no indirection)
		curr_cmd.UserCallbackData = userdata
		curr_cmd.UserCallbackDataSize = 0
		curr_cmd.UserCallbackDataOffset = -1
	}
	else {
		// Copy and store user data in a buffer
		IM_ASSERT(userdata != nil)
		IM_ASSERT(userdata_size < (1 << 31))
		curr_cmd.UserCallbackData = nil; // Will be resolved during Render()
		curr_cmd.UserCallbackDataSize = cast(i32) userdata_size
		curr_cmd.UserCallbackDataOffset = this._CallbacksDataBuf.Size
		resize(&this._CallbacksDataBuf, this._CallbacksDataBuf.Size + cast(i32) userdata_size)
		memcpy(this._CallbacksDataBuf.Data[cast(uint) curr_cmd.UserCallbackDataOffset:], userdata, cast(int)userdata_size)
	}

	ImDrawList_AddDrawCmd(this); // Force a new command after us (see comment below)
}

// Compare ClipRect, TextureId and VtxOffset with a single memcmp()
ImDrawCmd_HeaderSize :: offset_of(ImDrawCmd, VtxOffset) + size_of(u32)
ImDrawCmd_HeaderCompare :: #force_inline proc (CMD_LHS : ^$T0, CMD_RHS : ^$T1) -> i32
{
	return memcmp(CMD_LHS, CMD_RHS, ImDrawCmd_HeaderSize) // Compare ClipRect, TextureId, VtxOffset
}

ImDrawCmd_HeaderCopy :: #force_inline proc(CMD_DST : ^$T0, CMD_SRC : ^$T1)
{
	memcpy(CMD_DST, CMD_SRC, cast(int)ImDrawCmd_HeaderSize) // Copy ClipRect, TextureId, VtxOffset
}

ImDrawCmd_AreSequentialIdxOffset :: #force_inline proc "contextless" (CMD_0 : $T0, CMD_1 : $T1) -> bool
{
	return CMD_0.IdxOffset + CMD_0.ElemCount == CMD_1.IdxOffset
}


// Try to merge two last draw commands
ImDrawList__TryMergeDrawCmds :: proc(this : ^ImDrawList)
{
	IM_ASSERT_PARANOID(this.CmdBuffer.Size > 0)
	curr_cmd : ^ImDrawCmd = &this.CmdBuffer.Data[this.CmdBuffer.Size - 1]
	prev_cmd : ^ImDrawCmd = mem.ptr_offset(curr_cmd, -1)
	if ImDrawCmd_HeaderCompare(curr_cmd, prev_cmd) == 0 && ImDrawCmd_AreSequentialIdxOffset(prev_cmd, curr_cmd) && curr_cmd.UserCallback == nil && prev_cmd.UserCallback == nil {
		prev_cmd.ElemCount += curr_cmd.ElemCount
		pop_back(&this.CmdBuffer)
	}
}

// Our scheme may appears a bit unusual, basically we want the most-common calls AddLine AddRect etc. to not have to perform any check so we always have a command ready in the stack.
// The cost of figuring out if a new command has to be added or if we can merge is paid in those Update** functions only.
ImDrawList__OnChangedClipRect :: proc(this : ^ImDrawList)
{
	// If current command is used with different settings we need to add a new command
	IM_ASSERT_PARANOID(this.CmdBuffer.Size > 0)
	curr_cmd : ^ImDrawCmd = &this.CmdBuffer.Data[this.CmdBuffer.Size - 1]
	if curr_cmd.ElemCount != 0 && memcmp(&curr_cmd.ClipRect, &this._CmdHeader.ClipRect, size_of(ImVec4)) != 0 {
		ImDrawList_AddDrawCmd(this)
		return
	}
	IM_ASSERT(curr_cmd.UserCallback == nil)

	// Try to merge with previous command if it matches, else use current command
	prev_cmd : ^ImDrawCmd = mem.ptr_offset(curr_cmd, -1)
	if curr_cmd.ElemCount == 0 && this.CmdBuffer.Size > 1 && ImDrawCmd_HeaderCompare(&this._CmdHeader, prev_cmd) == 0 && ImDrawCmd_AreSequentialIdxOffset(prev_cmd, curr_cmd) && prev_cmd.UserCallback == nil {
		pop_back(&this.CmdBuffer)
		return
	}
	curr_cmd.ClipRect = this._CmdHeader.ClipRect
}

ImDrawList__OnChangedTextureID :: proc(this : ^ImDrawList)
{
	// If current command is used with different settings we need to add a new command
	IM_ASSERT_PARANOID(this.CmdBuffer.Size > 0)
	curr_cmd : ^ImDrawCmd = &this.CmdBuffer.Data[this.CmdBuffer.Size - 1]
	if curr_cmd.ElemCount != 0 && curr_cmd.TextureId != this._CmdHeader.TextureId {
		ImDrawList_AddDrawCmd(this)
		return
	}
	IM_ASSERT(curr_cmd.UserCallback == nil)

	// Try to merge with previous command if it matches, else use current command
	prev_cmd : ^ImDrawCmd = mem.ptr_offset(curr_cmd, -1)
	if curr_cmd.ElemCount == 0 && this.CmdBuffer.Size > 1 && ImDrawCmd_HeaderCompare(&this._CmdHeader, prev_cmd) == 0 && ImDrawCmd_AreSequentialIdxOffset(prev_cmd, curr_cmd) && prev_cmd.UserCallback == nil {
		pop_back(&this.CmdBuffer)
		return
	}
	curr_cmd.TextureId = this._CmdHeader.TextureId
}

ImDrawList__OnChangedVtxOffset :: proc(this : ^ImDrawList)
{
	// We don't need to compare curr_cmd->VtxOffset != _CmdHeader.VtxOffset because we know it'll be different at the time we call this.
	this._VtxCurrentIdx = 0
	IM_ASSERT_PARANOID(this.CmdBuffer.Size > 0)
	curr_cmd : ^ImDrawCmd = &this.CmdBuffer.Data[this.CmdBuffer.Size - 1]
	//IM_ASSERT(curr_cmd->VtxOffset != _CmdHeader.VtxOffset); // See #3349
	if curr_cmd.ElemCount != 0 {
		ImDrawList_AddDrawCmd(this)
		return
	}
	IM_ASSERT(curr_cmd.UserCallback == nil)
	curr_cmd.VtxOffset = this._CmdHeader.VtxOffset
}

ImDrawList__CalcCircleAutoSegmentCount :: proc(this : ^ImDrawList, radius : f32) -> i32
{
	// Automatic segment count
	radius_idx : i32 = cast(i32) (radius + 0.999999); // ceil to never reduce accuracy
	if radius_idx >= 0 && radius_idx < len(this._Data.CircleSegmentCounts) {
		// Use cached value
		return cast(i32) this._Data.CircleSegmentCounts[radius_idx]
	}
	else { return cast(i32) IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_CALC(radius, this._Data.CircleSegmentMaxError) }
}

// Render-level scissoring. This is passed down to your render function but not used for CPU-side coarse clipping. Prefer using higher-level ImGui::PushClipRect() to affect logic (hit-testing and widget culling)
// Render-level scissoring. This is passed down to your render function but not used for CPU-side coarse clipping. Prefer using higher-level ImGui::PushClipRect() to affect logic (hit-testing and widget culling)
ImDrawList_PushClipRect :: proc(this : ^ImDrawList, cr_min : ImVec2, cr_max : ImVec2, intersect_with_current_clip_rect : bool = false)
{
	cr : ImVec4 = {cr_min.x, cr_min.y, cr_max.x, cr_max.y}
	if intersect_with_current_clip_rect {
		current : ImVec4 = this._CmdHeader.ClipRect
		if cr.x < current.x { cr.x = current.x }
		if cr.y < current.y { cr.y = current.y }
		if cr.z > current.z { cr.z = current.z }
		if cr.w > current.w { cr.w = current.w }
	}
	cr.z = ImMax(cr.x, cr.z)
	cr.w = ImMax(cr.y, cr.w)

	push_back(&this._ClipRectStack, cr)
	this._CmdHeader.ClipRect = cr
	ImDrawList__OnChangedClipRect(this)
}

ImDrawList_PushClipRectFullScreen :: proc(this : ^ImDrawList)
{
	ImDrawList_PushClipRect(this, ImVec2{this._Data.ClipRectFullscreen.x, this._Data.ClipRectFullscreen.y}, ImVec2{this._Data.ClipRectFullscreen.z, this._Data.ClipRectFullscreen.w})
}

ImDrawList_PopClipRect :: proc(this : ^ImDrawList)
{
	pop_back(&this._ClipRectStack)
	this._CmdHeader.ClipRect = (this._ClipRectStack.Size == 0) ? this._Data.ClipRectFullscreen : this._ClipRectStack.Data[this._ClipRectStack.Size - 1]
	ImDrawList__OnChangedClipRect(this)
}

ImDrawList_PushTextureID :: proc(this : ^ImDrawList, texture_id : ImTextureID)
{
	push_back(&this._TextureIdStack, texture_id)
	this._CmdHeader.TextureId = texture_id
	ImDrawList__OnChangedTextureID(this)
}

ImDrawList_PopTextureID :: proc(this : ^ImDrawList)
{
	pop_back(&this._TextureIdStack)
	this._CmdHeader.TextureId = (this._TextureIdStack.Size == 0) ? cast(ImTextureID) 0 : this._TextureIdStack.Data[this._TextureIdStack.Size - 1]
	ImDrawList__OnChangedTextureID(this)
}

// This is used by ImGui::PushFont()/PopFont(). It works because we never use _TextureIdStack[] elsewhere than in PushTextureID()/PopTextureID().
ImDrawList__SetTextureID :: proc(this : ^ImDrawList, texture_id : ImTextureID)
{
	if this._CmdHeader.TextureId == texture_id { return }
	this._CmdHeader.TextureId = texture_id
	ImDrawList__OnChangedTextureID(this)
}

// Advanced: Primitives allocations
// - We render triangles (three vertices)
// - All primitives needs to be reserved via PrimReserve() beforehand.
// Reserve space for a number of vertices and indices.
// You must finish filling your reserved data before calling PrimReserve() again, as it may reallocate or
// submit the intermediate results. PrimUnreserve() can be used to release unused allocations.
ImDrawList_PrimReserve :: proc(this : ^ImDrawList, idx_count : i32, vtx_count : i32)
{
	// Large mesh support (when enabled)
	IM_ASSERT_PARANOID(idx_count >= 0 && vtx_count >= 0)
	if size_of(ImDrawIdx) == 2 && (this._VtxCurrentIdx + cast(u32) vtx_count >= (1 << 16)) && (this.Flags & ImDrawListFlags_.ImDrawListFlags_AllowVtxOffset) != {} {
		// FIXME: In theory we should be testing that vtx_count <64k here.
		// In practice, RenderText() relies on reserving ahead for a worst case scenario so it is currently useful for us
		// to not make that check until we rework the text functions to handle clipping and large horizontal lines better.
		this._CmdHeader.VtxOffset = cast(u32) this.VtxBuffer.Size
		ImDrawList__OnChangedVtxOffset(this)
	}

	draw_cmd : ^ImDrawCmd = &this.CmdBuffer.Data[this.CmdBuffer.Size - 1]
	draw_cmd.ElemCount += cast(u32) idx_count

	vtx_buffer_old_size : i32 = this.VtxBuffer.Size
	resize(&this.VtxBuffer, vtx_buffer_old_size + vtx_count)
	this._VtxWritePtr = this.VtxBuffer.Data[vtx_buffer_old_size:]

	idx_buffer_old_size : i32 = this.IdxBuffer.Size
	resize(&this.IdxBuffer, idx_buffer_old_size + idx_count)
	this._IdxWritePtr = this.IdxBuffer.Data[idx_buffer_old_size:]
}

// Release the number of reserved vertices/indices from the end of the last reservation made with PrimReserve().
ImDrawList_PrimUnreserve :: proc(this : ^ImDrawList, idx_count : i32, vtx_count : i32)
{
	IM_ASSERT_PARANOID(idx_count >= 0 && vtx_count >= 0)

	draw_cmd : ^ImDrawCmd = &this.CmdBuffer.Data[this.CmdBuffer.Size - 1]
	draw_cmd.ElemCount -= cast(u32)idx_count
	shrink(&this.VtxBuffer, this.VtxBuffer.Size - vtx_count)
	shrink(&this.IdxBuffer, this.IdxBuffer.Size - idx_count)
}

// Axis aligned rectangle (composed of two triangles)
// Fully unrolled with inline call to keep our debug builds decently fast.
ImDrawList_PrimRect :: proc(this : ^ImDrawList, a : ImVec2, c : ImVec2, col : ImU32)
{
	b := ImVec2{c.x, a.y}; d := ImVec2{a.x, c.y}; uv : ImVec2 = this._Data.TexUvWhitePixel
	idx : ImDrawIdx = cast(ImDrawIdx) this._VtxCurrentIdx
	this._IdxWritePtr[0] = idx; this._IdxWritePtr[1] = cast(ImDrawIdx) (idx + 1); this._IdxWritePtr[2] = cast(ImDrawIdx) (idx + 2)
	this._IdxWritePtr[3] = idx; this._IdxWritePtr[4] = cast(ImDrawIdx) (idx + 2); this._IdxWritePtr[5] = cast(ImDrawIdx) (idx + 3)
	this._VtxWritePtr[0].pos = a; this._VtxWritePtr[0].uv = uv; this._VtxWritePtr[0].col = col
	this._VtxWritePtr[1].pos = b; this._VtxWritePtr[1].uv = uv; this._VtxWritePtr[1].col = col
	this._VtxWritePtr[2].pos = c; this._VtxWritePtr[2].uv = uv; this._VtxWritePtr[2].col = col
	this._VtxWritePtr[3].pos = d; this._VtxWritePtr[3].uv = uv; this._VtxWritePtr[3].col = col
	this._VtxWritePtr = this._VtxWritePtr[4:]
	this._VtxCurrentIdx += 4
	this._IdxWritePtr = this._IdxWritePtr[6:]
}

ImDrawList_PrimRectUV :: proc(this : ^ImDrawList, a : ImVec2, c : ImVec2, uv_a : ImVec2, uv_c : ImVec2, col : ImU32)
{
	b := ImVec2{ c.x, a.y }; d := ImVec2{a.x, c.y}; uv_b := ImVec2{uv_c.x, uv_a.y}; uv_d := ImVec2 { uv_a.x, uv_c.y }
	idx : ImDrawIdx = cast(ImDrawIdx) this._VtxCurrentIdx
	this._IdxWritePtr[0] = idx; this._IdxWritePtr[1] = cast(ImDrawIdx) (idx + 1); this._IdxWritePtr[2] = cast(ImDrawIdx) (idx + 2)
	this._IdxWritePtr[3] = idx; this._IdxWritePtr[4] = cast(ImDrawIdx) (idx + 2); this._IdxWritePtr[5] = cast(ImDrawIdx) (idx + 3)
	this._VtxWritePtr[0].pos = a; this._VtxWritePtr[0].uv = uv_a; this._VtxWritePtr[0].col = col
	this._VtxWritePtr[1].pos = b; this._VtxWritePtr[1].uv = uv_b; this._VtxWritePtr[1].col = col
	this._VtxWritePtr[2].pos = c; this._VtxWritePtr[2].uv = uv_c; this._VtxWritePtr[2].col = col
	this._VtxWritePtr[3].pos = d; this._VtxWritePtr[3].uv = uv_d; this._VtxWritePtr[3].col = col
	this._VtxWritePtr = this._VtxWritePtr[4:]
	this._VtxCurrentIdx += 4
	this._IdxWritePtr = this._IdxWritePtr[6:]
}

ImDrawList_PrimQuadUV :: proc(this : ^ImDrawList, a : ImVec2, b : ImVec2, c : ImVec2, d : ImVec2, uv_a : ImVec2, uv_b : ImVec2, uv_c : ImVec2, uv_d : ImVec2, col : ImU32)
{
	idx : ImDrawIdx = cast(ImDrawIdx) this._VtxCurrentIdx
	this._IdxWritePtr[0] = idx; this._IdxWritePtr[1] = cast(ImDrawIdx) (idx + 1); this._IdxWritePtr[2] = cast(ImDrawIdx) (idx + 2)
	this._IdxWritePtr[3] = idx; this._IdxWritePtr[4] = cast(ImDrawIdx) (idx + 2); this._IdxWritePtr[5] = cast(ImDrawIdx) (idx + 3)
	this._VtxWritePtr[0].pos = a; this._VtxWritePtr[0].uv = uv_a; this._VtxWritePtr[0].col = col
	this._VtxWritePtr[1].pos = b; this._VtxWritePtr[1].uv = uv_b; this._VtxWritePtr[1].col = col
	this._VtxWritePtr[2].pos = c; this._VtxWritePtr[2].uv = uv_c; this._VtxWritePtr[2].col = col
	this._VtxWritePtr[3].pos = d; this._VtxWritePtr[3].uv = uv_d; this._VtxWritePtr[3].col = col
	this._VtxWritePtr = this._VtxWritePtr[4:]
	this._VtxCurrentIdx += 4
	this._IdxWritePtr = this._IdxWritePtr[6:]
}

// On AddPolyline() and AddConvexPolyFilled() we intentionally avoid using ImVec2 and superfluous function calls to optimize debug/non-inlined builds.
// - Those macros expects l-values and need to be used as their own statement.
// - Those macros are intentionally not surrounded by the 'do {} while (0)' idiom because even that translates to runtime with debug compilers.
IM_NORMALIZE2F_OVER_ZERO :: #force_inline proc "contextless" (VX : ^f32, VY : ^f32)
{
	d2 : f32 = VX^ * VX^ + VY^ * VY^
	if d2 > 0.0 {
		inv_len := ImRsqrt(d2)
		VX^ *= inv_len
		VY^ *= inv_len
	}
}

IM_FIXNORMAL2F_MAX_INVLEN2 :: 100.0// 500.0f (see #4053, #3366)
IM_FIXNORMAL2F :: #force_inline proc "contextless" (VX : ^f32, VY : ^f32)
{
	d2 := VX^ * VX^ + VY^ * VY^;
	if d2 > 0.000001 {
		inv_len2 := 1.0/d2
		if inv_len2 > IM_FIXNORMAL2F_MAX_INVLEN2 { inv_len2 = IM_FIXNORMAL2F_MAX_INVLEN2 }
		VX^ *= inv_len2
		VY^ *= inv_len2
	}
}


// General polygon
// - Only simple polygons are supported by filling functions (no self-intersections, no holes).
// - Concave polygon fill is more expensive than convex one: it has O(N^2) complexity. Provided as a convenience fo user but not used by main library.
// TODO: Thickness anti-aliased lines cap are missing their AA fringe.
// We avoid using the ImVec2 math operators here to reduce cost to a minimum for debug/non-inlined builds.
ImDrawList_AddPolyline :: proc(this : ^ImDrawList, points : []ImVec2, col : ImU32, flags : ImDrawFlags, thickness : f32)
{
	points_count := cast(i32)len(points)
	if points_count < 2 || (col & IM_COL32_A_MASK) == 0 { return }

	thickness := thickness

	closed : bool = (flags & ImDrawFlags_.ImDrawFlags_Closed) != {}
	opaque_uv : ImVec2 = this._Data.TexUvWhitePixel
	count : i32 = closed ? points_count : points_count - 1; // The number of line segments we need to draw
	thick_line : bool = (thickness > this._FringeScale)

	if (this.Flags & ImDrawListFlags_.ImDrawListFlags_AntiAliasedLines) != {} {
		// Anti-aliased stroke
		AA_SIZE : f32 = this._FringeScale
		col_trans : ImU32 = col & ~ImU32(IM_COL32_A_MASK)

		// Thicknesses <1.0 should behave like thickness 1.0
		thickness = ImMax(thickness, 1.0)
		integer_thickness : i32 = cast(i32) thickness
		fractional_thickness : f32 = thickness - cast(f32) integer_thickness

		// Do we want to draw this line using a texture?
		// - For now, only draw integer-width lines using textures to avoid issues with the way scaling occurs, could be improved.
		// - If AA_SIZE is not 1.0f we cannot use the texture path.
		use_texture : bool = (this.Flags & ImDrawListFlags_.ImDrawListFlags_AntiAliasedLinesUseTex) != {} && (integer_thickness < IM_DRAWLIST_TEX_LINES_WIDTH_MAX) && (fractional_thickness <= 0.00001) && (AA_SIZE == 1.0)

		// We should never hit this, because NewFrame() doesn't set ImDrawListFlags_AntiAliasedLinesUseTex unless ImFontAtlasFlags_NoBakedLines is off
		IM_ASSERT_PARANOID(!use_texture || (this._Data.Font.ContainerAtlas.Flags & ImFontAtlasFlags_.ImFontAtlasFlags_NoBakedLines) == {})

		idx_count : i32 = use_texture ? (count * 6) : (thick_line ? count * 18 : count * 12)
		vtx_count : i32 = use_texture ? (points_count * 2) : (thick_line ? points_count * 4 : points_count * 3)
		ImDrawList_PrimReserve(this, idx_count, vtx_count)

		// Temporary buffer
		// The first <points_count> items are normals at each line point, then after that there are either 2 or 4 temp points for each line point
		reserve_discard(&this._Data.TempBuffer, points_count * ((use_texture || !thick_line) ? 3 : 5))
		temp_normals := this._Data.TempBuffer.Data
		temp_points := temp_normals[points_count:]

		// Calculate normals (tangents) for each line segment
		for i1 : i32 = 0; i1 < count; i1 += 1 {
			i2 : i32 = (i1 + 1) == points_count ? 0 : i1 + 1
			dx : f32 = points[i2].x - points[i1].x
			dy : f32 = points[i2].y - points[i1].y
			IM_NORMALIZE2F_OVER_ZERO(&dx, &dy)
			temp_normals[i1].x = dy
			temp_normals[i1].y = -dx
		}

		if !closed { temp_normals[points_count - 1] = temp_normals[points_count - 2] }

		// If we are drawing a one-pixel-wide line without a texture, or a textured line of any width, we only need 2 or 3 vertices per point
		if use_texture || !thick_line {
			// [PATH 1] Texture-based lines (thick or non-thick)
			// [PATH 2] Non texture-based lines (non-thick)

			// The width of the geometry we need to draw - this is essentially <thickness> pixels for the line itself, plus "one pixel" for AA.
			// - In the texture-based path, we don't use AA_SIZE here because the +1 is tied to the generated texture
			//   (see ImFontAtlasBuildRenderLinesTexData() function), and so alternate values won't work without changes to that code.
			// - In the non texture-based paths, we would allow AA_SIZE to potentially be != 1.0f with a patch (e.g. fringe_scale patch to
			//   allow scaling geometry while preserving one-screen-pixel AA fringe).
			half_draw_size : f32 = use_texture ? ((thickness * 0.5) + 1) : AA_SIZE

			// If line is not closed, the first and last points need to be generated differently as there are no normals to blend
			if !closed {
				temp_points[0] = points[0] + temp_normals[0] * half_draw_size
				temp_points[1] = points[0] - temp_normals[0] * half_draw_size
				temp_points[(points_count - 1) * 2 + 0] = points[points_count - 1] + temp_normals[points_count - 1] * half_draw_size
				temp_points[(points_count - 1) * 2 + 1] = points[points_count - 1] - temp_normals[points_count - 1] * half_draw_size
			}

			// Generate the indices to form a number of triangles for each line segment, and the vertices for the line edges
			// This takes points n and n+1 and writes into n+1, with the first point in a closed line being generated from the final one (as n+1 wraps)
			// FIXME-OPT: Merge the different loops, possibly remove the temporary buffer.
			idx1 : u32 = this._VtxCurrentIdx; // Vertex index for start of line segment
			for i1 : i32 = 0; i1 < count; i1 += 1 {
				i2 : i32 = (i1 + 1) == points_count ? 0 : i1 + 1; // i2 is the second point of the line segment
				idx2 : u32 = ((i1 + 1) == points_count) ? this._VtxCurrentIdx : (idx1 + (use_texture ? 2 : 3)); // Vertex index for end of segment

				// Average normals
				dm_x : f32 = (temp_normals[i1].x + temp_normals[i2].x) * 0.5
				dm_y : f32 = (temp_normals[i1].y + temp_normals[i2].y) * 0.5
				IM_FIXNORMAL2F(&dm_x, &dm_y)
				dm_x *= half_draw_size; // dm_x, dm_y are offset to the outer edge of the AA area
				dm_y *= half_draw_size

				// Add temporary vertexes for the outer edges
				out_vtx : [^]ImVec2 = temp_points[i2 * 2:]
				out_vtx[0].x = points[i2].x + dm_x
				out_vtx[0].y = points[i2].y + dm_y
				out_vtx[1].x = points[i2].x - dm_x
				out_vtx[1].y = points[i2].y - dm_y

				if use_texture {
					// Add indices for two triangles
					this._IdxWritePtr[0] = cast(ImDrawIdx) (idx2 + 0); this._IdxWritePtr[1] = cast(ImDrawIdx) (idx1 + 0); this._IdxWritePtr[2] = cast(ImDrawIdx) (idx1 + 1); // Right tri
					this._IdxWritePtr[3] = cast(ImDrawIdx) (idx2 + 1); this._IdxWritePtr[4] = cast(ImDrawIdx) (idx1 + 1); this._IdxWritePtr[5] = cast(ImDrawIdx) (idx2 + 0); // Left tri
					this._IdxWritePtr = this._IdxWritePtr[6:]
				}
				else {
					// Add indexes for four triangles
					this._IdxWritePtr[0] = cast(ImDrawIdx) (idx2 + 0); this._IdxWritePtr[1] = cast(ImDrawIdx) (idx1 + 0); this._IdxWritePtr[2] = cast(ImDrawIdx) (idx1 + 2); // Right tri 1
					this._IdxWritePtr[3] = cast(ImDrawIdx) (idx1 + 2); this._IdxWritePtr[4] = cast(ImDrawIdx) (idx2 + 2); this._IdxWritePtr[5] = cast(ImDrawIdx) (idx2 + 0); // Right tri 2
					this._IdxWritePtr[6] = cast(ImDrawIdx) (idx2 + 1); this._IdxWritePtr[7] = cast(ImDrawIdx) (idx1 + 1); this._IdxWritePtr[8] = cast(ImDrawIdx) (idx1 + 0); // Left tri 1
					this._IdxWritePtr[9] = cast(ImDrawIdx) (idx1 + 0); this._IdxWritePtr[10] = cast(ImDrawIdx) (idx2 + 0); this._IdxWritePtr[11] = cast(ImDrawIdx) (idx2 + 1); // Left tri 2
					this._IdxWritePtr = this._IdxWritePtr[12:]
				}

				idx1 = idx2
			}

			// Add vertexes for each point on the line
			if use_texture {
				// If we're using textures we only need to emit the left/right edge vertices
				tex_uvs : ImVec4 = this._Data.TexUvLines[integer_thickness]
				/*if (fractional_thickness != 0.0f) // Currently always zero when use_texture==false!
                {
                    const ImVec4 tex_uvs_1 = _Data->TexUvLines[integer_thickness + 1];
                    tex_uvs.x = tex_uvs.x + (tex_uvs_1.x - tex_uvs.x) * fractional_thickness; // inlined ImLerp()
                    tex_uvs.y = tex_uvs.y + (tex_uvs_1.y - tex_uvs.y) * fractional_thickness;
                    tex_uvs.z = tex_uvs.z + (tex_uvs_1.z - tex_uvs.z) * fractional_thickness;
                    tex_uvs.w = tex_uvs.w + (tex_uvs_1.w - tex_uvs.w) * fractional_thickness;
                }*/
				tex_uv0 := ImVec2{ tex_uvs.x, tex_uvs.y }
				tex_uv1 := ImVec2{ tex_uvs.z, tex_uvs.w }
				for i : i32 = 0; i < points_count; i += 1 {
					this._VtxWritePtr[0].pos = temp_points[i * 2 + 0]; this._VtxWritePtr[0].uv = tex_uv0; this._VtxWritePtr[0].col = col; // Left-side outer edge
					this._VtxWritePtr[1].pos = temp_points[i * 2 + 1]; this._VtxWritePtr[1].uv = tex_uv1; this._VtxWritePtr[1].col = col; // Right-side outer edge
					this._VtxWritePtr = this._VtxWritePtr[2:]
				}
			}
			else {
				// If we're not using a texture, we need the center vertex as well
				for i : i32 = 0; i < points_count; i += 1 {
					this._VtxWritePtr[0].pos = points[i]; this._VtxWritePtr[0].uv = opaque_uv; this._VtxWritePtr[0].col = col; // Center of line
					this._VtxWritePtr[1].pos = temp_points[i * 2 + 0]; this._VtxWritePtr[1].uv = opaque_uv; this._VtxWritePtr[1].col = col_trans; // Left-side outer edge
					this._VtxWritePtr[2].pos = temp_points[i * 2 + 1]; this._VtxWritePtr[2].uv = opaque_uv; this._VtxWritePtr[2].col = col_trans; // Right-side outer edge
					this._VtxWritePtr = this._VtxWritePtr[3:]
				}
			}
		}
		else {
			// [PATH 2] Non texture-based lines (thick): we need to draw the solid line core and thus require four vertices per point
			half_inner_thickness : f32 = (thickness - AA_SIZE) * 0.5

			// If line is not closed, the first and last points need to be generated differently as there are no normals to blend
			if !closed {
				points_last : i32 = points_count - 1
				temp_points[0] = points[0] + temp_normals[0] * (half_inner_thickness + AA_SIZE)
				temp_points[1] = points[0] + temp_normals[0] * (half_inner_thickness)
				temp_points[2] = points[0] - temp_normals[0] * (half_inner_thickness)
				temp_points[3] = points[0] - temp_normals[0] * (half_inner_thickness + AA_SIZE)
				temp_points[points_last * 4 + 0] = points[points_last] + temp_normals[points_last] * (half_inner_thickness + AA_SIZE)
				temp_points[points_last * 4 + 1] = points[points_last] + temp_normals[points_last] * (half_inner_thickness)
				temp_points[points_last * 4 + 2] = points[points_last] - temp_normals[points_last] * (half_inner_thickness)
				temp_points[points_last * 4 + 3] = points[points_last] - temp_normals[points_last] * (half_inner_thickness + AA_SIZE)
			}

			// Generate the indices to form a number of triangles for each line segment, and the vertices for the line edges
			// This takes points n and n+1 and writes into n+1, with the first point in a closed line being generated from the final one (as n+1 wraps)
			// FIXME-OPT: Merge the different loops, possibly remove the temporary buffer.
			idx1 : u32 = this._VtxCurrentIdx; // Vertex index for start of line segment
			for i1 : i32 = 0; i1 < count; i1 += 1 {
				i2 : i32 = (i1 + 1) == points_count ? 0 : (i1 + 1); // i2 is the second point of the line segment
				idx2 : u32 = (i1 + 1) == points_count ? this._VtxCurrentIdx : (idx1 + 4); // Vertex index for end of segment

				// Average normals
				dm_x : f32 = (temp_normals[i1].x + temp_normals[i2].x) * 0.5
				dm_y : f32 = (temp_normals[i1].y + temp_normals[i2].y) * 0.5
				IM_FIXNORMAL2F(&dm_x, &dm_y)
				dm_out_x : f32 = dm_x * (half_inner_thickness + AA_SIZE)
				dm_out_y : f32 = dm_y * (half_inner_thickness + AA_SIZE)
				dm_in_x : f32 = dm_x * half_inner_thickness
				dm_in_y : f32 = dm_y * half_inner_thickness

				// Add temporary vertices
				out_vtx := temp_points[i2 * 4:]
				out_vtx[0].x = points[i2].x + dm_out_x
				out_vtx[0].y = points[i2].y + dm_out_y
				out_vtx[1].x = points[i2].x + dm_in_x
				out_vtx[1].y = points[i2].y + dm_in_y
				out_vtx[2].x = points[i2].x - dm_in_x
				out_vtx[2].y = points[i2].y - dm_in_y
				out_vtx[3].x = points[i2].x - dm_out_x
				out_vtx[3].y = points[i2].y - dm_out_y

				// Add indexes
				this._IdxWritePtr[0] = cast(ImDrawIdx) (idx2 + 1); this._IdxWritePtr[1] = cast(ImDrawIdx) (idx1 + 1); this._IdxWritePtr[2] = cast(ImDrawIdx) (idx1 + 2)
				this._IdxWritePtr[3] = cast(ImDrawIdx) (idx1 + 2); this._IdxWritePtr[4] = cast(ImDrawIdx) (idx2 + 2); this._IdxWritePtr[5] = cast(ImDrawIdx) (idx2 + 1)
				this._IdxWritePtr[6] = cast(ImDrawIdx) (idx2 + 1); this._IdxWritePtr[7] = cast(ImDrawIdx) (idx1 + 1); this._IdxWritePtr[8] = cast(ImDrawIdx) (idx1 + 0)
				this._IdxWritePtr[9] = cast(ImDrawIdx) (idx1 + 0); this._IdxWritePtr[10] = cast(ImDrawIdx) (idx2 + 0); this._IdxWritePtr[11] = cast(ImDrawIdx) (idx2 + 1)
				this._IdxWritePtr[12] = cast(ImDrawIdx) (idx2 + 2); this._IdxWritePtr[13] = cast(ImDrawIdx) (idx1 + 2); this._IdxWritePtr[14] = cast(ImDrawIdx) (idx1 + 3)
				this._IdxWritePtr[15] = cast(ImDrawIdx) (idx1 + 3); this._IdxWritePtr[16] = cast(ImDrawIdx) (idx2 + 3); this._IdxWritePtr[17] = cast(ImDrawIdx) (idx2 + 2)
				this._IdxWritePtr = this._IdxWritePtr[18:]

				idx1 = idx2
			}

			// Add vertices
			for i : i32 = 0; i < points_count; i += 1 {
				this._VtxWritePtr[0].pos = temp_points[i * 4 + 0]; this._VtxWritePtr[0].uv = opaque_uv; this._VtxWritePtr[0].col = col_trans
				this._VtxWritePtr[1].pos = temp_points[i * 4 + 1]; this._VtxWritePtr[1].uv = opaque_uv; this._VtxWritePtr[1].col = col
				this._VtxWritePtr[2].pos = temp_points[i * 4 + 2]; this._VtxWritePtr[2].uv = opaque_uv; this._VtxWritePtr[2].col = col
				this._VtxWritePtr[3].pos = temp_points[i * 4 + 3]; this._VtxWritePtr[3].uv = opaque_uv; this._VtxWritePtr[3].col = col_trans
				this._VtxWritePtr = this._VtxWritePtr[4:]
			}
		}
		this._VtxCurrentIdx = cast(u32) cast(ImDrawIdx) vtx_count
	}
	else {
		// [PATH 4] Non texture-based, Non anti-aliased lines
		idx_count : i32 = count * 6
		vtx_count : i32 = count * 4; // FIXME-OPT: Not sharing edges
		ImDrawList_PrimReserve(this, idx_count, vtx_count)

		for i1 : i32 = 0; i1 < count; i1 += 1 {
			i2 : i32 = (i1 + 1) == points_count ? 0 : i1 + 1
			p1 : ImVec2 = points[i1]
			p2 : ImVec2 = points[i2]

			dx : f32 = p2.x - p1.x
			dy : f32 = p2.y - p1.y
			IM_NORMALIZE2F_OVER_ZERO(&dx, &dy)
			dx *= (thickness * 0.5)
			dy *= (thickness * 0.5)

			this._VtxWritePtr[0].pos.x = p1.x + dy; this._VtxWritePtr[0].pos.y = p1.y - dx; this._VtxWritePtr[0].uv = opaque_uv; this._VtxWritePtr[0].col = col
			this._VtxWritePtr[1].pos.x = p2.x + dy; this._VtxWritePtr[1].pos.y = p2.y - dx; this._VtxWritePtr[1].uv = opaque_uv; this._VtxWritePtr[1].col = col
			this._VtxWritePtr[2].pos.x = p2.x - dy; this._VtxWritePtr[2].pos.y = p2.y + dx; this._VtxWritePtr[2].uv = opaque_uv; this._VtxWritePtr[2].col = col
			this._VtxWritePtr[3].pos.x = p1.x - dy; this._VtxWritePtr[3].pos.y = p1.y + dx; this._VtxWritePtr[3].uv = opaque_uv; this._VtxWritePtr[3].col = col
			this._VtxWritePtr = this._VtxWritePtr[4:]

			this._IdxWritePtr[0] = cast(ImDrawIdx) (this._VtxCurrentIdx); this._IdxWritePtr[1] = cast(ImDrawIdx) (this._VtxCurrentIdx + 1); this._IdxWritePtr[2] = cast(ImDrawIdx) (this._VtxCurrentIdx + 2)
			this._IdxWritePtr[3] = cast(ImDrawIdx) (this._VtxCurrentIdx); this._IdxWritePtr[4] = cast(ImDrawIdx) (this._VtxCurrentIdx + 2); this._IdxWritePtr[5] = cast(ImDrawIdx) (this._VtxCurrentIdx + 3)
			this._IdxWritePtr = this._IdxWritePtr[6:]
			this._VtxCurrentIdx += 4
		}
	}
}

// - We intentionally avoid using ImVec2 and its math operators here to reduce cost to a minimum for debug/non-inlined builds.
// - Filled shapes must always use clockwise winding order. The anti-aliasing fringe depends on it. Counter-clockwise shapes will have "inward" anti-aliasing.
ImDrawList_AddConvexPolyFilled :: proc(this : ^ImDrawList, points : [^]ImVec2, points_count : i32, col : ImU32)
{
	if points_count < 3 || (col & IM_COL32_A_MASK) == 0 { return }

	uv : ImVec2 = this._Data.TexUvWhitePixel

	if (this.Flags & ImDrawListFlags_.ImDrawListFlags_AntiAliasedFill) != {} {
		// Anti-aliased Fill
		AA_SIZE : f32 = this._FringeScale
		col_trans : ImU32 = col & ~ImU32(IM_COL32_A_MASK)
		idx_count : i32 = (points_count - 2) * 3 + points_count * 6
		vtx_count : i32 = (points_count * 2)
		ImDrawList_PrimReserve(this, idx_count, vtx_count)

		// Add indexes for fill
		vtx_inner_idx : u32 = this._VtxCurrentIdx
		vtx_outer_idx : u32 = this._VtxCurrentIdx + 1
		for i : u32 = 2; i < cast(u32) points_count; i += 1 {
			this._IdxWritePtr[0] = cast(ImDrawIdx) (vtx_inner_idx); this._IdxWritePtr[1] = cast(ImDrawIdx) (vtx_inner_idx + ((i - 1) << 1)); this._IdxWritePtr[2] = cast(ImDrawIdx) (vtx_inner_idx + (i << 1))
			this._IdxWritePtr = this._IdxWritePtr[3:]
		}

		// Compute normals
		reserve_discard(&this._Data.TempBuffer, points_count)
		temp_normals : [^]ImVec2 = this._Data.TempBuffer.Data
		for i0, i1 : i32 = points_count - 1, 0; i1 < points_count; i0 = post_incr(&i1) {
			p0 : ImVec2 = points[i0]
			p1 : ImVec2 = points[i1]
			dx : f32 = p1.x - p0.x
			dy : f32 = p1.y - p0.y
			IM_NORMALIZE2F_OVER_ZERO(&dx, &dy)
			temp_normals[i0].x = dy
			temp_normals[i0].y = -dx
		}

		for i0, i1 : i32 = points_count - 1, 0; i1 < points_count; i0 = post_incr(&i1) {
			// Average normals
			n0 : ImVec2 = temp_normals[i0]
			n1 : ImVec2 = temp_normals[i1]
			dm_x : f32 = (n0.x + n1.x) * 0.5
			dm_y : f32 = (n0.y + n1.y) * 0.5
			IM_FIXNORMAL2F(&dm_x, &dm_y)
			dm_x *= AA_SIZE * 0.5
			dm_y *= AA_SIZE * 0.5

			// Add vertices
			this._VtxWritePtr[0].pos.x = (points[i1].x - dm_x); this._VtxWritePtr[0].pos.y = (points[i1].y - dm_y); this._VtxWritePtr[0].uv = uv; this._VtxWritePtr[0].col = col; // Inner
			this._VtxWritePtr[1].pos.x = (points[i1].x + dm_x); this._VtxWritePtr[1].pos.y = (points[i1].y + dm_y); this._VtxWritePtr[1].uv = uv; this._VtxWritePtr[1].col = col_trans; // Outer
			this._VtxWritePtr = this._VtxWritePtr[2:]

			// Add indexes for fringes
			this._IdxWritePtr[0] = cast(ImDrawIdx) (vtx_inner_idx + (cast(u32) i1 << 1)); this._IdxWritePtr[1] = cast(ImDrawIdx) (vtx_inner_idx + (cast(u32) i0 << 1)); this._IdxWritePtr[2] = cast(ImDrawIdx) (vtx_outer_idx + (cast(u32) i0 << 1))
			this._IdxWritePtr[3] = cast(ImDrawIdx) (vtx_outer_idx + (cast(u32) i0 << 1)); this._IdxWritePtr[4] = cast(ImDrawIdx) (vtx_outer_idx + (cast(u32) i1 << 1)); this._IdxWritePtr[5] = cast(ImDrawIdx) (vtx_inner_idx + (cast(u32) i1 << 1))
			this._IdxWritePtr = this._IdxWritePtr[6:]
		}

		this._VtxCurrentIdx += cast(u32) cast(ImDrawIdx) vtx_count
	}
	else {
		// Non Anti-aliased Fill
		idx_count : i32 = (points_count - 2) * 3
		vtx_count : i32 = points_count
		ImDrawList_PrimReserve(this, idx_count, vtx_count)
		for i : i32 = 0; i < vtx_count; i += 1 {
			this._VtxWritePtr[0].pos = points[i]; this._VtxWritePtr[0].uv = uv; this._VtxWritePtr[0].col = col
			post_incr(&this._VtxWritePtr)
		}

		for i : i32 = 2; i < points_count; i += 1 {
			this._IdxWritePtr[0] = cast(ImDrawIdx) (this._VtxCurrentIdx); this._IdxWritePtr[1] = cast(ImDrawIdx) (this._VtxCurrentIdx + cast(u32) i - 1); this._IdxWritePtr[2] = cast(ImDrawIdx) (this._VtxCurrentIdx + cast(u32) i)
			this._IdxWritePtr = this._IdxWritePtr[3:]
		}

		this._VtxCurrentIdx += cast(u32) cast(ImDrawIdx) vtx_count
	}
}

ImDrawList__PathArcToFastEx :: proc(this : ^ImDrawList, center : ImVec2, radius : f32, a_min_sample : i32, a_max_sample : i32, a_step : i32)
{
	if radius < 0.5 {
		push_back(&this._Path, center)
		return
	}

	a_step := a_step
	// Calculate arc auto segment step size
	if a_step <= 0 { a_step = IM_DRAWLIST_ARCFAST_SAMPLE_MAX / ImDrawList__CalcCircleAutoSegmentCount(this, radius) }

	// Make sure we never do steps larger than one quarter of the circle
	a_step = ImClamp(a_step, 1, IM_DRAWLIST_ARCFAST_TABLE_SIZE / 4)

	sample_range : i32 = ImAbs(a_max_sample - a_min_sample)
	a_next_step : i32 = a_step

	samples : i32 = sample_range + 1
	extra_max_sample : bool = false
	if a_step > 1 {
		samples = sample_range / a_step + 1
		overstep : i32 = sample_range % a_step

		if overstep > 0 {
			extra_max_sample = true
			post_incr(&samples)

			// When we have overstep to avoid awkwardly looking one long line and one tiny one at the end,
			// distribute first step range evenly between them by reducing first step size.
			if sample_range > 0 { a_step -= (a_step - overstep) / 2 }
		}
	}

	resize(&this._Path, this._Path.Size + samples)
	out_ptr : ^ImVec2 = &this._Path.Data[this._Path.Size - samples]

	sample_index : i32 = a_min_sample
	if sample_index < 0 || sample_index >= IM_DRAWLIST_ARCFAST_SAMPLE_MAX {
		sample_index = sample_index % IM_DRAWLIST_ARCFAST_SAMPLE_MAX
		if sample_index < 0 { sample_index += IM_DRAWLIST_ARCFAST_SAMPLE_MAX }
	}

	if a_max_sample >= a_min_sample {
		for a : i32 = a_min_sample; a <= a_max_sample; a, sample_index, a_step = a + a_step, sample_index + a_step, a_next_step {
			// a_step is clamped to IM_DRAWLIST_ARCFAST_SAMPLE_MAX, so we have guaranteed that it will not wrap over range twice or more
			if sample_index >= IM_DRAWLIST_ARCFAST_SAMPLE_MAX { sample_index -= IM_DRAWLIST_ARCFAST_SAMPLE_MAX }

			s : ImVec2 = this._Data.ArcFastVtx[sample_index]
			out_ptr.x = center.x + s.x * radius
			out_ptr.y = center.y + s.y * radius
			post_incr(&out_ptr)
		}
	}
	else {
		for a : i32 = a_min_sample; a >= a_max_sample; a, sample_index, a_step = a - a_step, sample_index - a_step, a_next_step {
			// a_step is clamped to IM_DRAWLIST_ARCFAST_SAMPLE_MAX, so we have guaranteed that it will not wrap over range twice or more
			if sample_index < 0 { sample_index += IM_DRAWLIST_ARCFAST_SAMPLE_MAX }

			s : ImVec2 = this._Data.ArcFastVtx[sample_index]
			out_ptr.x = center.x + s.x * radius
			out_ptr.y = center.y + s.y * radius
			post_incr(&out_ptr)
		}
	}

	if extra_max_sample {
		normalized_max_sample : i32 = a_max_sample % IM_DRAWLIST_ARCFAST_SAMPLE_MAX
		if normalized_max_sample < 0 { normalized_max_sample += IM_DRAWLIST_ARCFAST_SAMPLE_MAX }

		s : ImVec2 = this._Data.ArcFastVtx[normalized_max_sample]
		out_ptr.x = center.x + s.x * radius
		out_ptr.y = center.y + s.y * radius
		post_incr(&out_ptr)
	}

	IM_ASSERT_PARANOID(&this._Path.Data[this._Path.Size] == out_ptr)
}

ImDrawList__PathArcToN :: proc(this : ^ImDrawList, center : ImVec2, radius : f32, a_min : f32, a_max : f32, num_segments : i32)
{
	if radius < 0.5 {
		push_back(&this._Path, center)
		return
	}

	// Note that we are adding a point at both a_min and a_max.
	// If you are trying to draw a full closed circle you don't want the overlapping points!
	reserve(&this._Path, this._Path.Size + (num_segments + 1))
	for i : i32 = 0; i <= num_segments; i += 1 {
		a : f32 = a_min + (cast(f32) i / cast(f32) num_segments) * (a_max - a_min)
		push_back(&this._Path, ImVec2{center.x + ImCos(a) * radius, center.y + ImSin(a) * radius})
	}
}

// Use precomputed angles for a 12 steps circle
// 0: East, 3: South, 6: West, 9: North, 12: East
ImDrawList_PathArcToFast :: proc(this : ^ImDrawList, center : ImVec2, radius : f32, a_min_of_12 : i32, a_max_of_12 : i32)
{
	if radius < 0.5 {
		push_back(&this._Path, center)
		return
	}
	ImDrawList__PathArcToFastEx(this, center, radius, a_min_of_12 * IM_DRAWLIST_ARCFAST_SAMPLE_MAX / 12, a_max_of_12 * IM_DRAWLIST_ARCFAST_SAMPLE_MAX / 12, 0)
}

ImDrawList_PathArcTo :: proc(this : ^ImDrawList, center : ImVec2, radius : f32, a_min : f32, a_max : f32, num_segments : i32 = 0)
{
	if radius < 0.5 {
		push_back(&this._Path, center)
		return
	}

	if num_segments > 0 {
		ImDrawList__PathArcToN(this, center, radius, a_min, a_max, num_segments)
		return
	}

	// Automatic segment count
	if radius <= this._Data.ArcFastRadiusCutoff {
		a_is_reverse : bool = a_max < a_min

		// We are going to use precomputed values for mid samples.
		// Determine first and last sample in lookup table that belong to the arc.
		a_min_sample_f : f32 = IM_DRAWLIST_ARCFAST_SAMPLE_MAX * a_min / (IM_PI * 2.0)
		a_max_sample_f : f32 = IM_DRAWLIST_ARCFAST_SAMPLE_MAX * a_max / (IM_PI * 2.0)

		a_min_sample : i32 = a_is_reverse ? cast(i32) ImFloor(a_min_sample_f) : cast(i32) ImCeil(a_min_sample_f)
		a_max_sample : i32 = a_is_reverse ? cast(i32) ImCeil(a_max_sample_f) : cast(i32) ImFloor(a_max_sample_f)
		a_mid_samples : i32 = a_is_reverse ? ImMax(a_min_sample - a_max_sample, 0) : ImMax(a_max_sample - a_min_sample, 0)

		a_min_segment_angle : f32 = f32(a_min_sample) * IM_PI * 2.0 / IM_DRAWLIST_ARCFAST_SAMPLE_MAX
		a_max_segment_angle : f32 = f32(a_max_sample) * IM_PI * 2.0 / IM_DRAWLIST_ARCFAST_SAMPLE_MAX
		a_emit_start : bool = ImAbs(a_min_segment_angle - a_min) >= 1e-5
		a_emit_end : bool = ImAbs(a_max - a_max_segment_angle) >= 1e-5

		reserve(&this._Path, this._Path.Size + (a_mid_samples + 1 + (a_emit_start ? 1 : 0) + (a_emit_end ? 1 : 0)))
		if a_emit_start { push_back(&this._Path, ImVec2{center.x + ImCos(a_min) * radius, center.y + ImSin(a_min) * radius}) }
		if a_mid_samples > 0 { ImDrawList__PathArcToFastEx(this, center, radius, a_min_sample, a_max_sample, 0) }
		if a_emit_end { push_back(&this._Path, ImVec2{center.x + ImCos(a_max) * radius, center.y + ImSin(a_max) * radius}) }
	}
	else {
		arc_length : f32 = ImAbs(a_max - a_min)
		circle_segment_count : i32 = ImDrawList__CalcCircleAutoSegmentCount(this, radius)
		arc_segment_count : i32 = ImMax(cast(i32) ImCeil(f32(circle_segment_count) * arc_length / (IM_PI * 2.0)), cast(i32) (2.0 * IM_PI / arc_length))
		ImDrawList__PathArcToN(this, center, radius, a_min, a_max, arc_segment_count)
	}
}

// Ellipse
ImDrawList_PathEllipticalArcTo :: proc(this : ^ImDrawList, center : ImVec2, radius : ImVec2, rot : f32, a_min : f32, a_max : f32, num_segments : i32 = 0)
{
	num_segments := num_segments
	if num_segments <= 0 {
		// A bit pessimistic, maybe there's a better computation to do here.
		num_segments = ImDrawList__CalcCircleAutoSegmentCount(this, ImMax(radius.x, radius.y))
	}

	reserve(&this._Path, this._Path.Size + (num_segments + 1))

	cos_rot : f32 = ImCos(rot)
	sin_rot : f32 = ImSin(rot)
	for i : i32 = 0; i <= num_segments; i += 1 {
		a : f32 = a_min + (cast(f32) i / cast(f32) num_segments) * (a_max - a_min)
		point := ImVec2{ ImCos(a) * radius.x, ImSin(a) * radius.y }
		rel := ImVec2{ (point.x * cos_rot) - (point.y * sin_rot), (point.x * sin_rot) + (point.y * cos_rot) }
		point.x = rel.x + center.x
		point.y = rel.y + center.y
		push_back(&this._Path, point)
	}
}

// Helpers: Geometry
ImBezierCubicCalc :: proc(p1 : ImVec2, p2 : ImVec2, p3 : ImVec2, p4 : ImVec2, t : f32) -> ImVec2
{
	u : f32 = 1.0 - t
	w1 : f32 = u * u * u
	w2 : f32 = 3 * u * u * t
	w3 : f32 = 3 * u * t * t
	w4 : f32 = t * t * t
	return ImVec2{w1 * p1.x + w2 * p2.x + w3 * p3.x + w4 * p4.x, w1 * p1.y + w2 * p2.y + w3 * p3.y + w4 * p4.y}
}

ImBezierQuadraticCalc :: proc(p1 : ImVec2, p2 : ImVec2, p3 : ImVec2, t : f32) -> ImVec2
{
	u : f32 = 1.0 - t
	w1 : f32 = u * u
	w2 : f32 = 2 * u * t
	w3 : f32 = t * t
	return ImVec2{w1 * p1.x + w2 * p2.x + w3 * p3.x, w1 * p1.y + w2 * p2.y + w3 * p3.y}
}

// Closely mimics ImBezierCubicClosestPointCasteljau() in imgui.cpp
PathBezierCubicCurveToCasteljau :: proc(path : ^ImVector(ImVec2), x1 : f32, y1 : f32, x2 : f32, y2 : f32, x3 : f32, y3 : f32, x4 : f32, y4 : f32, tess_tol : f32, level : i32)
{
	dx : f32 = x4 - x1
	dy : f32 = y4 - y1
	d2 : f32 = (x2 - x4) * dy - (y2 - y4) * dx
	d3 : f32 = (x3 - x4) * dy - (y3 - y4) * dx
	d2 = (d2 >= 0) ? d2 : -d2
	d3 = (d3 >= 0) ? d3 : -d3
	if (d2 + d3) * (d2 + d3) < tess_tol * (dx * dx + dy * dy) {
		push_back(path, ImVec2{x4, y4})
	}
	else if level < 10 {
		x12 : f32 = (x1 + x2) * 0.5; y12 : f32 = (y1 + y2) * 0.5
		x23 : f32 = (x2 + x3) * 0.5; y23 : f32 = (y2 + y3) * 0.5
		x34 : f32 = (x3 + x4) * 0.5; y34 : f32 = (y3 + y4) * 0.5
		x123 : f32 = (x12 + x23) * 0.5; y123 : f32 = (y12 + y23) * 0.5
		x234 : f32 = (x23 + x34) * 0.5; y234 : f32 = (y23 + y34) * 0.5
		x1234 : f32 = (x123 + x234) * 0.5; y1234 : f32 = (y123 + y234) * 0.5
		PathBezierCubicCurveToCasteljau(path, x1, y1, x12, y12, x123, y123, x1234, y1234, tess_tol, level + 1)
		PathBezierCubicCurveToCasteljau(path, x1234, y1234, x234, y234, x34, y34, x4, y4, tess_tol, level + 1)
	}
}

PathBezierQuadraticCurveToCasteljau :: proc(path : ^ImVector(ImVec2), x1 : f32, y1 : f32, x2 : f32, y2 : f32, x3 : f32, y3 : f32, tess_tol : f32, level : i32)
{
	dx : f32 = x3 - x1; dy : f32 = y3 - y1
	det : f32 = (x2 - x3) * dy - (y2 - y3) * dx
	if det * det * 4.0 < tess_tol * (dx * dx + dy * dy) {
		push_back(path, ImVec2{x3, y3})
	}
	else if level < 10 {
		x12 : f32 = (x1 + x2) * 0.5; y12 : f32 = (y1 + y2) * 0.5
		x23 : f32 = (x2 + x3) * 0.5; y23 : f32 = (y2 + y3) * 0.5
		x123 : f32 = (x12 + x23) * 0.5; y123 : f32 = (y12 + y23) * 0.5
		PathBezierQuadraticCurveToCasteljau(path, x1, y1, x12, y12, x123, y123, tess_tol, level + 1)
		PathBezierQuadraticCurveToCasteljau(path, x123, y123, x23, y23, x3, y3, tess_tol, level + 1)
	}
}

// Cubic Bezier (4 control points)
ImDrawList_PathBezierCubicCurveTo :: proc(this : ^ImDrawList, p2 : ImVec2, p3 : ImVec2, p4 : ImVec2, num_segments : i32 = 0)
{
	p1 : ImVec2 = back(&this._Path)^
	if num_segments == 0 {
		IM_ASSERT(this._Data.CurveTessellationTol > 0.0)
		PathBezierCubicCurveToCasteljau(&this._Path, p1.x, p1.y, p2.x, p2.y, p3.x, p3.y, p4.x, p4.y, this._Data.CurveTessellationTol, 0); // Auto-tessellated
	}
	else {
		t_step : f32 = 1.0 / cast(f32) num_segments
		for i_step : i32 = 1; i_step <= num_segments; i_step += 1 { push_back(&this._Path, ImBezierCubicCalc(p1, p2, p3, p4, t_step * f32(i_step))) }
	}
}

// Quadratic Bezier (3 control points)
ImDrawList_PathBezierQuadraticCurveTo :: proc(this : ^ImDrawList, p2 : ImVec2, p3 : ImVec2, num_segments : i32 = 0)
{
	p1 : ImVec2 = back(&this._Path)^
	if num_segments == 0 {
		IM_ASSERT(this._Data.CurveTessellationTol > 0.0)
		PathBezierQuadraticCurveToCasteljau(&this._Path, p1.x, p1.y, p2.x, p2.y, p3.x, p3.y, this._Data.CurveTessellationTol, 0); // Auto-tessellated
	}
	else {
		t_step : f32 = 1.0 / cast(f32) num_segments
		for i_step : i32 = 1; i_step <= num_segments; i_step += 1 { push_back(&this._Path, ImBezierQuadraticCalc(p1, p2, p3, t_step * f32(i_step))) }
	}
}

FixRectCornerFlags :: #force_inline proc(flags : ImDrawFlags) -> ImDrawFlags
{
	/*
    IM_STATIC_ASSERT(ImDrawFlags_RoundCornersTopLeft == (1 << 4));
#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
    // Obsoleted in 1.82 (from February 2021). This code was stripped/simplified and mostly commented in 1.90 (from September 2023)
    // - Legacy Support for hard coded ~0 (used to be a suggested equivalent to ImDrawCornerFlags_All)
    if (flags == ~0)                    { return ImDrawFlags_RoundCornersAll; }
    // - Legacy Support for hard coded 0x01 to 0x0F (matching 15 out of 16 old flags combinations). Read details in older version of this code.
    if (flags >= 0x01 && flags <= 0x0F) { return (flags << 4); }
    // We cannot support hard coded 0x00 with 'float rounding > 0.0f' --> replace with ImDrawFlags_RoundCornersNone or use 'float rounding = 0.0f'
#endif
    */
	// If this assert triggers, please update your code replacing hardcoded values with new ImDrawFlags_RoundCorners* values.
	// Note that ImDrawFlags_Closed (== 0x01) is an invalid flag for AddRect(), AddRectFilled(), PathRect() etc. anyway.
	// See details in 1.82 Changelog as well as 2021/03/12 and 2023/09/08 entries in "API BREAKING CHANGES" section.
	IM_ASSERT((flags & ImDrawFlags(0x0F)) == {}, "Misuse of legacy hardcoded ImDrawCornerFlags values!")

	flags := flags
	if (flags & ImDrawFlags_.ImDrawFlags_RoundCornersMask_) == {} { flags |= ImDrawFlags_.ImDrawFlags_RoundCornersAll }

	return flags
}

ImDrawList_PathRect :: proc(this : ^ImDrawList, a : ImVec2, b : ImVec2, rounding : f32 = 0.0, flags : ImDrawFlags = {})
{
	flags := flags
	rounding := rounding
	if rounding >= 0.5 {
		flags = FixRectCornerFlags(flags)
		rounding = ImMin(rounding, ImFabs(b.x - a.x) * (((flags & ImDrawFlags_.ImDrawFlags_RoundCornersTop) == ImDrawFlags_.ImDrawFlags_RoundCornersTop) || ((flags & ImDrawFlags_.ImDrawFlags_RoundCornersBottom) == ImDrawFlags_.ImDrawFlags_RoundCornersBottom) ? 0.5 : 1.0) - 1.0)
		rounding = ImMin(rounding, ImFabs(b.y - a.y) * (((flags & ImDrawFlags_.ImDrawFlags_RoundCornersLeft) == ImDrawFlags_.ImDrawFlags_RoundCornersLeft) || ((flags & ImDrawFlags_.ImDrawFlags_RoundCornersRight) == ImDrawFlags_.ImDrawFlags_RoundCornersRight) ? 0.5 : 1.0) - 1.0)
	}
	if rounding < 0.5 || (flags & ImDrawFlags_.ImDrawFlags_RoundCornersMask_) == ImDrawFlags_.ImDrawFlags_RoundCornersNone {
		ImDrawList_PathLineTo(this, a)
		ImDrawList_PathLineTo(this, ImVec2{b.x, a.y})
		ImDrawList_PathLineTo(this, b)
		ImDrawList_PathLineTo(this, ImVec2{a.x, b.y})
	}
	else {
		rounding_tl : f32 = (flags & ImDrawFlags_.ImDrawFlags_RoundCornersTopLeft) != {} ? rounding : 0.0
		rounding_tr : f32 = (flags & ImDrawFlags_.ImDrawFlags_RoundCornersTopRight) != {} ? rounding : 0.0
		rounding_br : f32 = (flags & ImDrawFlags_.ImDrawFlags_RoundCornersBottomRight) != {} ? rounding : 0.0
		rounding_bl : f32 = (flags & ImDrawFlags_.ImDrawFlags_RoundCornersBottomLeft) != {} ? rounding : 0.0
		ImDrawList_PathArcToFast(this, ImVec2{a.x + rounding_tl, a.y + rounding_tl}, rounding_tl, 6, 9)
		ImDrawList_PathArcToFast(this, ImVec2{b.x - rounding_tr, a.y + rounding_tr}, rounding_tr, 9, 12)
		ImDrawList_PathArcToFast(this, ImVec2{b.x - rounding_br, b.y - rounding_br}, rounding_br, 0, 3)
		ImDrawList_PathArcToFast(this, ImVec2{a.x + rounding_bl, b.y - rounding_bl}, rounding_bl, 3, 6)
	}
}

// Primitives
// - Filled shapes must always use clockwise winding order. The anti-aliasing fringe depends on it. Counter-clockwise shapes will have "inward" anti-aliasing.
// - For rectangular primitives, "p_min" and "p_max" represent the upper-left and lower-right corners.
// - For circle primitives, use "num_segments == 0" to automatically calculate tessellation (preferred).
//   In older versions (until Dear ImGui 1.77) the AddCircle functions defaulted to num_segments == 12.
//   In future versions we will use textures to provide cheaper and higher-quality circles.
//   Use AddNgon() and AddNgonFilled() functions if you need to guarantee a specific number of sides.
ImDrawList_AddLine :: proc(this : ^ImDrawList, p1 : ImVec2, p2 : ImVec2, col : ImU32, thickness : f32 = 1.0)
{
	if (col & IM_COL32_A_MASK) == 0 { return }
	ImDrawList_PathLineTo(this, p1 + ImVec2{0.5, 0.5})
	ImDrawList_PathLineTo(this, p2 + ImVec2{0.5, 0.5})
	ImDrawList_PathStroke(this, col, {}, thickness)
}

// a: upper-left, b: lower-right (== upper-left + size)
// p_min = upper-left, p_max = lower-right
// Note we don't render 1 pixels sized rectangles properly.
ImDrawList_AddRect :: proc(this : ^ImDrawList, p_min : ImVec2, p_max : ImVec2, col : ImU32, rounding : f32 = 0.0, flags : ImDrawFlags = {}, thickness : f32 = 1.0)
{
	if (col & IM_COL32_A_MASK) == 0 { return }
	if (this.Flags & ImDrawListFlags_.ImDrawListFlags_AntiAliasedLines) != {} { ImDrawList_PathRect(this, p_min + ImVec2{0.50, 0.50}, p_max - ImVec2{0.50, 0.50}, rounding, flags) }
	else {
		// Better looking lower-right corner and rounded non-AA shapes.
		ImDrawList_PathRect(this, p_min + ImVec2{0.50, 0.50}, p_max - ImVec2{0.49, 0.49}, rounding, flags)
	}
	ImDrawList_PathStroke(this, col, ImDrawFlags_.ImDrawFlags_Closed, thickness)
}

// a: upper-left, b: lower-right (== upper-left + size)
ImDrawList_AddRectFilled :: proc(this : ^ImDrawList, p_min : ImVec2, p_max : ImVec2, col : ImU32, rounding : f32 = 0.0, flags : ImDrawFlags = {})
{
	if (col & IM_COL32_A_MASK) == 0 { return }
	if rounding < 0.5 || (flags & ImDrawFlags_.ImDrawFlags_RoundCornersMask_) == ImDrawFlags_.ImDrawFlags_RoundCornersNone {
		ImDrawList_PrimReserve(this, 6, 4)
		ImDrawList_PrimRect(this, p_min, p_max, col)
	}
	else {
		ImDrawList_PathRect(this, p_min, p_max, rounding, flags)
		ImDrawList_PathFillConvex(this, col)
	}
}

// p_min = upper-left, p_max = lower-right
ImDrawList_AddRectFilledMultiColor :: proc(this : ^ImDrawList, p_min : ImVec2, p_max : ImVec2, col_upr_left : ImU32, col_upr_right : ImU32, col_bot_right : ImU32, col_bot_left : ImU32)
{
	if ((col_upr_left | col_upr_right | col_bot_right | col_bot_left) & IM_COL32_A_MASK) == 0 { return }

	uv : ImVec2 = this._Data.TexUvWhitePixel
	ImDrawList_PrimReserve(this, 6, 4)
	ImDrawList_PrimWriteIdx(this, cast(ImDrawIdx) (this._VtxCurrentIdx)); ImDrawList_PrimWriteIdx(this, cast(ImDrawIdx) (this._VtxCurrentIdx + 1)); ImDrawList_PrimWriteIdx(this, cast(ImDrawIdx) (this._VtxCurrentIdx + 2))
	ImDrawList_PrimWriteIdx(this, cast(ImDrawIdx) (this._VtxCurrentIdx)); ImDrawList_PrimWriteIdx(this, cast(ImDrawIdx) (this._VtxCurrentIdx + 2)); ImDrawList_PrimWriteIdx(this, cast(ImDrawIdx) (this._VtxCurrentIdx + 3))
	ImDrawList_PrimWriteVtx(this, p_min, uv, col_upr_left)
	ImDrawList_PrimWriteVtx(this, ImVec2{p_max.x, p_min.y}, uv, col_upr_right)
	ImDrawList_PrimWriteVtx(this, p_max, uv, col_bot_right)
	ImDrawList_PrimWriteVtx(this, ImVec2{p_min.x, p_max.y}, uv, col_bot_left)
}

ImDrawList_AddQuad :: proc(this : ^ImDrawList, p1 : ImVec2, p2 : ImVec2, p3 : ImVec2, p4 : ImVec2, col : ImU32, thickness : f32 = 1.0)
{
	if (col & IM_COL32_A_MASK) == 0 { return }

	ImDrawList_PathLineTo(this, p1)
	ImDrawList_PathLineTo(this, p2)
	ImDrawList_PathLineTo(this, p3)
	ImDrawList_PathLineTo(this, p4)
	ImDrawList_PathStroke(this, col, ImDrawFlags_.ImDrawFlags_Closed, thickness)
}

ImDrawList_AddQuadFilled :: proc(this : ^ImDrawList, p1 : ImVec2, p2 : ImVec2, p3 : ImVec2, p4 : ImVec2, col : ImU32)
{
	if (col & IM_COL32_A_MASK) == 0 { return }

	ImDrawList_PathLineTo(this, p1)
	ImDrawList_PathLineTo(this, p2)
	ImDrawList_PathLineTo(this, p3)
	ImDrawList_PathLineTo(this, p4)
	ImDrawList_PathFillConvex(this, col)
}

ImDrawList_AddTriangle :: proc(this : ^ImDrawList, p1 : ImVec2, p2 : ImVec2, p3 : ImVec2, col : ImU32, thickness : f32 = 1.0)
{
	if (col & IM_COL32_A_MASK) == 0 { return }

	ImDrawList_PathLineTo(this, p1)
	ImDrawList_PathLineTo(this, p2)
	ImDrawList_PathLineTo(this, p3)
	ImDrawList_PathStroke(this, col, ImDrawFlags_.ImDrawFlags_Closed, thickness)
}

ImDrawList_AddTriangleFilled :: proc(this : ^ImDrawList, p1 : ImVec2, p2 : ImVec2, p3 : ImVec2, col : ImU32)
{
	if (col & IM_COL32_A_MASK) == 0 { return }

	ImDrawList_PathLineTo(this, p1)
	ImDrawList_PathLineTo(this, p2)
	ImDrawList_PathLineTo(this, p3)
	ImDrawList_PathFillConvex(this, col)
}

ImDrawList_AddCircle :: proc(this : ^ImDrawList, center : ImVec2, radius : f32, col : ImU32, num_segments : i32 = 0, thickness : f32 = 1.0)
{
	if (col & IM_COL32_A_MASK) == 0 || radius < 0.5 { return }

	if num_segments <= 0 {
		// Use arc with automatic segment count
		ImDrawList__PathArcToFastEx(this, center, radius - 0.5, 0, IM_DRAWLIST_ARCFAST_SAMPLE_MAX, 0)
		post_decr(&this._Path.Size)
	}
	else {
		// Explicit segment count (still clamp to avoid drawing insanely tessellated shapes)
		num_segments := ImClamp(num_segments, 3, IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_MAX)

		// Because we are filling a closed shape we remove 1 from the count of segments/points
		a_max : f32 = (IM_PI * 2.0) * (cast(f32) num_segments - 1.0) / cast(f32) num_segments
		ImDrawList_PathArcTo(this, center, radius - 0.5, 0.0, a_max, num_segments - 1)
	}

	ImDrawList_PathStroke(this, col, ImDrawFlags_.ImDrawFlags_Closed, thickness)
}

ImDrawList_AddCircleFilled :: proc(this : ^ImDrawList, center : ImVec2, radius : f32, col : ImU32, num_segments : i32 = 0)
{
	if (col & IM_COL32_A_MASK) == 0 || radius < 0.5 { return }

	if num_segments <= 0 {
		// Use arc with automatic segment count
		ImDrawList__PathArcToFastEx(this, center, radius, 0, IM_DRAWLIST_ARCFAST_SAMPLE_MAX, 0)
		post_decr(&this._Path.Size)
	}
	else {
		// Explicit segment count (still clamp to avoid drawing insanely tessellated shapes)
		num_segments := ImClamp(num_segments, 3, IM_DRAWLIST_CIRCLE_AUTO_SEGMENT_MAX)

		// Because we are filling a closed shape we remove 1 from the count of segments/points
		a_max : f32 = (IM_PI * 2.0) * (cast(f32) num_segments - 1.0) / cast(f32) num_segments
		ImDrawList_PathArcTo(this, center, radius, 0.0, a_max, num_segments - 1)
	}

	ImDrawList_PathFillConvex(this, col)
}

// Guaranteed to honor 'num_segments'
ImDrawList_AddNgon :: proc(this : ^ImDrawList, center : ImVec2, radius : f32, col : ImU32, num_segments : i32, thickness : f32 = 1.0)
{
	if (col & IM_COL32_A_MASK) == 0 || num_segments <= 2 { return }

	// Because we are filling a closed shape we remove 1 from the count of segments/points
	a_max : f32 = (IM_PI * 2.0) * (cast(f32) num_segments - 1.0) / cast(f32) num_segments
	ImDrawList_PathArcTo(this, center, radius - 0.5, 0.0, a_max, num_segments - 1)
	ImDrawList_PathStroke(this, col, ImDrawFlags_.ImDrawFlags_Closed, thickness)
}

// Guaranteed to honor 'num_segments'
ImDrawList_AddNgonFilled :: proc(this : ^ImDrawList, center : ImVec2, radius : f32, col : ImU32, num_segments : i32)
{
	if (col & IM_COL32_A_MASK) == 0 || num_segments <= 2 { return }

	// Because we are filling a closed shape we remove 1 from the count of segments/points
	a_max : f32 = (IM_PI * 2.0) * (cast(f32) num_segments - 1.0) / cast(f32) num_segments
	ImDrawList_PathArcTo(this, center, radius, 0.0, a_max, num_segments - 1)
	ImDrawList_PathFillConvex(this, col)
}

// Ellipse
ImDrawList_AddEllipse :: proc(this : ^ImDrawList, center : ImVec2, radius : ImVec2, col : ImU32, rot : f32 = 0.0, num_segments : i32 = 0, thickness : f32 = 1.0)
{
	if (col & IM_COL32_A_MASK) == 0 { return }

	num_segments := num_segments
	if num_segments <= 0 {
		// A bit pessimistic, maybe there's a better computation to do here.
		num_segments = ImDrawList__CalcCircleAutoSegmentCount(this, ImMax(radius.x, radius.y))
	}

	// Because we are filling a closed shape we remove 1 from the count of segments/points
	a_max : f32 = IM_PI * 2.0 * (cast(f32) num_segments - 1.0) / cast(f32) num_segments
	ImDrawList_PathEllipticalArcTo(this, center, radius, rot, 0.0, a_max, num_segments - 1)
	ImDrawList_PathStroke(this, col, ImDrawFlags(1), thickness)
}

ImDrawList_AddEllipseFilled :: proc(this : ^ImDrawList, center : ImVec2, radius : ImVec2, col : ImU32, rot : f32 = 0.0, num_segments : i32 = 0)
{
	if (col & IM_COL32_A_MASK) == 0 { return }

	num_segments := num_segments
	if num_segments <= 0 {
		// A bit pessimistic, maybe there's a better computation to do here.
		num_segments = ImDrawList__CalcCircleAutoSegmentCount(this, ImMax(radius.x, radius.y))
	}

	// Because we are filling a closed shape we remove 1 from the count of segments/points
	a_max : f32 = IM_PI * 2.0 * (cast(f32) num_segments - 1.0) / cast(f32) num_segments
	ImDrawList_PathEllipticalArcTo(this, center, radius, rot, 0.0, a_max, num_segments - 1)
	ImDrawList_PathFillConvex(this, col)
}

// Cubic Bezier (4 control points)
// Cubic Bezier takes 4 controls points
ImDrawList_AddBezierCubic :: proc(this : ^ImDrawList, p1 : ImVec2, p2 : ImVec2, p3 : ImVec2, p4 : ImVec2, col : ImU32, thickness : f32, num_segments : i32 = 0)
{
	if (col & IM_COL32_A_MASK) == 0 { return }

	ImDrawList_PathLineTo(this, p1)
	ImDrawList_PathBezierCubicCurveTo(this, p2, p3, p4, num_segments)
	ImDrawList_PathStroke(this, col, {}, thickness)
}

// Quadratic Bezier (3 control points)
// Quadratic Bezier takes 3 controls points
ImDrawList_AddBezierQuadratic :: proc(this : ^ImDrawList, p1 : ImVec2, p2 : ImVec2, p3 : ImVec2, col : ImU32, thickness : f32, num_segments : i32 = 0)
{
	if (col & IM_COL32_A_MASK) == 0 { return }

	ImDrawList_PathLineTo(this, p1)
	ImDrawList_PathBezierQuadraticCurveTo(this, p2, p3, num_segments)
	ImDrawList_PathStroke(this, col, {}, thickness)
}

ImDrawList_AddText_0 :: proc(this : ^ImDrawList, font : ^ImFont, font_size : f32, pos : ImVec2, col : ImU32, text : string, wrap_width : f32 = 0, cpu_fine_clip_rect : ^ImVec4 = nil)
{
	if (col & IM_COL32_A_MASK) == 0 { return }

	// Accept null ranges
	if len(text) == 0 { return }

	// Pull default font/size from the shared ImDrawListSharedData instance
	font := font; if font == nil { font = this._Data.Font }
	font_size := font_size; if font_size == 0.0 { font_size = this._Data.FontSize }

	IM_ASSERT(font.ContainerAtlas.TexID == this._CmdHeader.TextureId); // Use high-level ImGui::PushFont() or low-level ImDrawList::PushTextureId() to change font.

	clip_rect : ImVec4 = this._CmdHeader.ClipRect
	if cpu_fine_clip_rect != nil {
		clip_rect.x = ImMax(clip_rect.x, cpu_fine_clip_rect.x)
		clip_rect.y = ImMax(clip_rect.y, cpu_fine_clip_rect.y)
		clip_rect.z = ImMin(clip_rect.z, cpu_fine_clip_rect.z)
		clip_rect.w = ImMin(clip_rect.w, cpu_fine_clip_rect.w)
	}
	ImFont_RenderText(font, this, font_size, pos, col, clip_rect, text, wrap_width, cpu_fine_clip_rect != nil)
}

ImDrawList_AddText_1 :: proc(this : ^ImDrawList, pos : ImVec2, col : ImU32, text : string)
{
	ImDrawList_AddText(this, nil, 0.0, pos, col, text)
}

// Image primitives
// - Read FAQ to understand what ImTextureID is.
// - "p_min" and "p_max" represent the upper-left and lower-right corners of the rectangle.
// - "uv_min" and "uv_max" represent the normalized texture coordinates to use for those corners. Using (0,0)->(1,1) texture coordinates will generally display the entire texture.
ImDrawList_AddImage :: proc(this : ^ImDrawList, user_texture_id : ImTextureID, p_min : ImVec2, p_max : ImVec2, uv_min : ImVec2 = {0, 0}, uv_max : ImVec2 = {1, 1}, col : ImU32 = IM_COL32_WHITE)
{
	if (col & IM_COL32_A_MASK) == 0 { return }

	push_texture_id : bool = user_texture_id != this._CmdHeader.TextureId
	if push_texture_id { ImDrawList_PushTextureID(this, user_texture_id) }

	ImDrawList_PrimReserve(this, 6, 4)
	ImDrawList_PrimRectUV(this, p_min, p_max, uv_min, uv_max, col)

	if push_texture_id { ImDrawList_PopTextureID(this) }
}

ImDrawList_AddImageQuad :: proc(this : ^ImDrawList, user_texture_id : ImTextureID, p1 : ImVec2, p2 : ImVec2, p3 : ImVec2, p4 : ImVec2, uv1 : ImVec2 = {0, 0}, uv2 : ImVec2 = {1, 0}, uv3 : ImVec2 = {1, 1}, uv4 : ImVec2 = {0, 1}, col : ImU32 = IM_COL32_WHITE)
{
	if (col & IM_COL32_A_MASK) == 0 { return }

	push_texture_id : bool = user_texture_id != this._CmdHeader.TextureId
	if push_texture_id { ImDrawList_PushTextureID(this, user_texture_id) }

	ImDrawList_PrimReserve(this, 6, 4)
	ImDrawList_PrimQuadUV(this, p1, p2, p3, p4, uv1, uv2, uv3, uv4, col)

	if push_texture_id { ImDrawList_PopTextureID(this) }
}

ImDrawList_AddImageRounded :: proc(this : ^ImDrawList, user_texture_id : ImTextureID, p_min : ImVec2, p_max : ImVec2, uv_min : ImVec2, uv_max : ImVec2, col : ImU32, rounding : f32, flags : ImDrawFlags = {})
{
	if (col & IM_COL32_A_MASK) == 0 { return }

	flags := FixRectCornerFlags(flags)
	if rounding < 0.5 || (flags & ImDrawFlags_.ImDrawFlags_RoundCornersMask_) == ImDrawFlags_.ImDrawFlags_RoundCornersNone {
		ImDrawList_AddImage(this, user_texture_id, p_min, p_max, uv_min, uv_max, col)
		return
	}

	push_texture_id : bool = user_texture_id != this._CmdHeader.TextureId
	if push_texture_id { ImDrawList_PushTextureID(this, user_texture_id) }

	vert_start_idx : i32 = this.VtxBuffer.Size
	ImDrawList_PathRect(this, p_min, p_max, rounding, flags)
	ImDrawList_PathFillConvex(this, col)
	vert_end_idx : i32 = this.VtxBuffer.Size
	ShadeVertsLinearUV(this, vert_start_idx, vert_end_idx, p_min, p_max, uv_min, uv_max, true)

	if push_texture_id { ImDrawList_PopTextureID(this) }
}

//-----------------------------------------------------------------------------
// [SECTION] ImTriangulator, ImDrawList concave polygon fill
//-----------------------------------------------------------------------------
// Triangulate concave polygons. Based on "Triangulation by Ear Clipping" paper, O(N^2) complexity.
// Reference: https://www.geometrictools.com/Documentation/TriangulationByEarClipping.pdf
// Provided as a convenience for user but not used by main library.
//-----------------------------------------------------------------------------
// - ImTriangulator [Internal]
// - AddConcavePolyFilled()
//-----------------------------------------------------------------------------

ImTriangulatorNodeType :: enum i32 {
	ImTriangulatorNodeType_Convex,
	ImTriangulatorNodeType_Ear,
	ImTriangulatorNodeType_Reflex,
}

ImTriangulatorNode :: struct {
	Type : ImTriangulatorNodeType,
	Index : i32,
	Pos : ImVec2,
	Next : ^ImTriangulatorNode,
	Prev : ^ImTriangulatorNode,
}

ImTriangulatorNode_Unlink :: proc(this : ^ImTriangulatorNode)
{
	this.Next.Prev = this.Prev; this.Prev.Next = this.Next
}

ImTriangulatorNodeSpan :: struct {
	Data : [^]^ImTriangulatorNode,
	Size : i32,
}

ImTriangulatorNodeSpan_push_back :: proc(this : ^ImTriangulatorNodeSpan, node : ^ImTriangulatorNode) { this.Data[post_incr(&this.Size)] = node }

ImTriangulatorNodeSpan_find_erase_unsorted :: proc(this : ^ImTriangulatorNodeSpan, idx : i32) { for i : i32 = this.Size - 1; i >= 0; i -= 1 { if this.Data[i].Index == idx {this.Data[i] = this.Data[this.Size - 1]; post_decr(&this.Size); return
} } }

ImTriangulatorNodeSpan_init :: proc(this : ^ImTriangulatorNodeSpan)
{
this.Data = nil
this.Size = 0

}

ImTriangulator :: struct {
	// Internal members
	_TrianglesLeft : i32,
	_Nodes : [^]ImTriangulatorNode,
	_Ears : ImTriangulatorNodeSpan,
	_Reflexes : ImTriangulatorNodeSpan,
}

ImTriangulator_EstimateTriangleCount :: proc(#any_int points_count : i32) -> i32 { return (points_count < 3) ? 0 : points_count - 2 }

ImTriangulator_EstimateScratchBufferSize :: proc(points_count : i32) -> i32 { return size_of(ImTriangulatorNode) * points_count + size_of(^ImTriangulatorNode) * points_count * 2 }

ImTriangulator_init :: proc(this : ^ImTriangulator)
{
	this._TrianglesLeft = 0
	this._Nodes = nil
	init(&this._Ears)
	init(&this._Reflexes)
}

// Distribute storage for nodes, ears and reflexes.
// FIXME-OPT: if everything is convex, we could report it to caller and let it switch to an convex renderer
// (this would require first building reflexes to bail to convex if empty, without even building nodes)
ImTriangulator_Init :: proc(this : ^ImTriangulator, points : []ImVec2, scratch_buffer : rawptr)
{
	IM_ASSERT(scratch_buffer != nil && len(points) >= 3)
	this._TrianglesLeft = ImTriangulator_EstimateTriangleCount(len(points))
	this._Nodes = cast(^ImTriangulatorNode) scratch_buffer; // points_count x Node
	this._Ears.Data = cast([^]^ImTriangulatorNode) (this._Nodes[len(points):]); // points_count x Node*
	this._Reflexes.Data = (cast([^]^ImTriangulatorNode) (this._Nodes[len(points):]))[len(points):]; // points_count x Node*
	ImTriangulator_BuildNodes(this, points)
	ImTriangulator_BuildReflexes(this)
	ImTriangulator_BuildEars(this)
}

// Internal functions
ImTriangulator_BuildNodes :: proc(this : ^ImTriangulator, points : []ImVec2)
{
	for i : i32 = 0; i < cast(i32)len(points); i += 1 {
		this._Nodes[i].Type = ImTriangulatorNodeType.ImTriangulatorNodeType_Convex
		this._Nodes[i].Index = i
		this._Nodes[i].Pos = points[i]
		this._Nodes[i].Next = &this._Nodes[i + 1]
		this._Nodes[i].Prev = &this._Nodes[i - 1]
	}

	this._Nodes[0].Prev = &this._Nodes[len(points) - 1]
	this._Nodes[len(points) - 1].Next = this._Nodes
}

ImTriangulator_BuildReflexes :: proc(this : ^ImTriangulator)
{
	n1 : ^ImTriangulatorNode = this._Nodes
	for i : i32 = this._TrianglesLeft; i >= 0; i, n1 = i - 1, n1.Next {
		if ImTriangleIsClockwise(n1.Prev.Pos, n1.Pos, n1.Next.Pos) { continue }
		n1.Type = ImTriangulatorNodeType.ImTriangulatorNodeType_Reflex
		push_back(&this._Reflexes, n1)
	}
}

ImTriangulator_BuildEars :: proc(this : ^ImTriangulator)
{
	n1 : ^ImTriangulatorNode = this._Nodes
	for i : i32 = this._TrianglesLeft; i >= 0; i, n1 = i - 1, n1.Next {
		if n1.Type != ImTriangulatorNodeType.ImTriangulatorNodeType_Convex { continue }
		if !ImTriangulator_IsEar(this, n1.Prev.Index, n1.Index, n1.Next.Index, n1.Prev.Pos, n1.Pos, n1.Next.Pos) { continue }
		n1.Type = ImTriangulatorNodeType.ImTriangulatorNodeType_Ear
		push_back(&this._Ears, n1)
	}
}

// Return relative indexes for next triangle
ImTriangulator_GetNextTriangle :: proc(this : ^ImTriangulator, out_triangle : ^[3]u32)
{
	if this._Ears.Size == 0 {
		ImTriangulator_FlipNodeList(this)

		node : ^ImTriangulatorNode = this._Nodes
		for i : i32 = this._TrianglesLeft; i >= 0; i, node = i - 1, node.Next { node.Type = ImTriangulatorNodeType.ImTriangulatorNodeType_Convex }

		this._Reflexes.Size = 0
		ImTriangulator_BuildReflexes(this)
		ImTriangulator_BuildEars(this)

		// If we still don't have ears, it means geometry is degenerated.
		if this._Ears.Size == 0 {
			// Return first triangle available, mimicking the behavior of convex fill.
			IM_ASSERT(this._TrianglesLeft > 0); // Geometry is degenerated
			this._Ears.Data[0] = this._Nodes
			this._Ears.Size = 1
		}
	}

	ear : ^ImTriangulatorNode = this._Ears.Data[pre_decr(&this._Ears.Size)]
	out_triangle[0] = cast(u32)ear.Prev.Index
	out_triangle[1] = cast(u32)ear.Index
	out_triangle[2] = cast(u32)ear.Next.Index

	Unlink(ear)
	if ear == this._Nodes { this._Nodes = ear.Next }

	ImTriangulator_ReclassifyNode(this, ear.Prev)
	ImTriangulator_ReclassifyNode(this, ear.Next)
	post_decr(&this._TrianglesLeft)
}

ImTriangulator_FlipNodeList :: proc(this : ^ImTriangulator)
{
	prev : ^ImTriangulatorNode = this._Nodes
	temp : ^ImTriangulatorNode = this._Nodes
	current : ^ImTriangulatorNode = this._Nodes[0].Next
	prev.Next = prev
	prev.Prev = prev
	for current != this._Nodes {
		temp = current.Next

		current.Next = prev
		prev.Prev = current
		this._Nodes[0].Next = current
		current.Prev = this._Nodes

		prev = current
		current = temp
	}

	this._Nodes = prev
}

// A triangle is an ear is no other vertex is inside it. We can test reflexes vertices only (see reference algorithm)
ImTriangulator_IsEar :: proc(this : ^ImTriangulator, i0 : i32, i1 : i32, i2 : i32, v0 : ImVec2, v1 : ImVec2, v2 : ImVec2) -> bool
{
	p_end : [^]^ImTriangulatorNode = this._Reflexes.Data[this._Reflexes.Size:]
	for p : [^]^ImTriangulatorNode = this._Reflexes.Data; p < p_end; p = p[1:] {
		reflex := p[0]
		if reflex.Index != i0 && reflex.Index != i1 && reflex.Index != i2 { if ImTriangleContainsPoint(v0, v1, v2, reflex.Pos) { return false } }
	}

	return true
}

ImTriangulator_ReclassifyNode :: proc(this : ^ImTriangulator, n1 : ^ImTriangulatorNode)
{
	// Classify node
	type : ImTriangulatorNodeType
	n0 : ^ImTriangulatorNode = n1.Prev
	n2 : ^ImTriangulatorNode = n1.Next
	if !ImTriangleIsClockwise(n0.Pos, n1.Pos, n2.Pos) { type = ImTriangulatorNodeType.ImTriangulatorNodeType_Reflex }
	else if ImTriangulator_IsEar(this, n0.Index, n1.Index, n2.Index, n0.Pos, n1.Pos, n2.Pos) { type = ImTriangulatorNodeType.ImTriangulatorNodeType_Ear }
	else { type = ImTriangulatorNodeType.ImTriangulatorNodeType_Convex }

	// Update lists when a type changes
	if type == n1.Type { return }
	if n1.Type == ImTriangulatorNodeType.ImTriangulatorNodeType_Reflex { find_erase_unsorted(&this._Reflexes, n1.Index) }
	else if n1.Type == ImTriangulatorNodeType.ImTriangulatorNodeType_Ear { find_erase_unsorted(&this._Ears, n1.Index) }
	if type == ImTriangulatorNodeType.ImTriangulatorNodeType_Reflex { push_back(&this._Reflexes, n1) }
	else if type == ImTriangulatorNodeType.ImTriangulatorNodeType_Ear { push_back(&this._Ears, n1) }
	n1.Type = type
}

// Use ear-clipping algorithm to triangulate a simple polygon (no self-interaction, no holes).
// (Reminder: we don't perform any coarse clipping/culling in ImDrawList layer!
// It is up to caller to ensure not making costly calls that will be outside of visible area.
// As concave fill is noticeably more expensive than other primitives, be mindful of this...
// Caller can build AABB of points, and avoid filling if 'draw_list->_CmdHeader.ClipRect.Overlays(points_bb) == false')
ImDrawList_AddConcavePolyFilled :: proc(this : ^ImDrawList, points : []ImVec2, col : ImU32)
{
	points_count := cast(i32)len(points)
	if points_count < 3 || (col & IM_COL32_A_MASK) == 0 { return }

	uv : ImVec2 = this._Data.TexUvWhitePixel
	triangulator : ImTriangulator
	triangle : [3]u32
	if (this.Flags & ImDrawListFlags_.ImDrawListFlags_AntiAliasedFill) != {} {
		// Anti-aliased Fill
		AA_SIZE : f32 = this._FringeScale
		col_trans : ImU32 = col & ~ImU32(IM_COL32_A_MASK)
		idx_count : i32 = (points_count - 2) * 3 + points_count * 6
		vtx_count : i32 = (points_count * 2)
		ImDrawList_PrimReserve(this, idx_count, vtx_count)

		// Add indexes for fill
		vtx_inner_idx : u32 = this._VtxCurrentIdx
		vtx_outer_idx : u32 = this._VtxCurrentIdx + 1

		reserve_discard(&this._Data.TempBuffer, (ImTriangulator_EstimateScratchBufferSize(cast(i32) points_count) + size_of(ImVec2)) / size_of(ImVec2))
		Init(&triangulator, points, this._Data.TempBuffer.Data)
		for triangulator._TrianglesLeft > 0 {
			GetNextTriangle(&triangulator, &triangle)
			this._IdxWritePtr[0] = cast(ImDrawIdx) (vtx_inner_idx + (triangle[0] << 1)); this._IdxWritePtr[1] = cast(ImDrawIdx) (vtx_inner_idx + (triangle[1] << 1)); this._IdxWritePtr[2] = cast(ImDrawIdx) (vtx_inner_idx + (triangle[2] << 1))
			this._IdxWritePtr = this._IdxWritePtr[3:]
		}

		// Compute normals
		reserve_discard(&this._Data.TempBuffer, cast(i32) points_count)
		temp_normals := this._Data.TempBuffer.Data
		for i0, i1 : i32 = points_count - 1, 0; i1 < points_count; i0 = post_incr(&i1) {
			p0 : ImVec2 = points[i0]
			p1 : ImVec2 = points[i1]
			dx : f32 = p1.x - p0.x
			dy : f32 = p1.y - p0.y
			IM_NORMALIZE2F_OVER_ZERO(&dx, &dy)
			temp_normals[i0].x = dy
			temp_normals[i0].y = -dx
		}

		for i0, i1 : i32 = points_count - 1, 0; i1 < points_count; i0 = post_incr(&i1) {
			// Average normals
			n0 := temp_normals[i0]
			n1 := temp_normals[i1]
			dm_x : f32 = (n0.x + n1.x) * 0.5
			dm_y : f32 = (n0.y + n1.y) * 0.5
			IM_FIXNORMAL2F(&dm_x, &dm_y)
			dm_x *= AA_SIZE * 0.5
			dm_y *= AA_SIZE * 0.5

			// Add vertices
			this._VtxWritePtr[0].pos.x = (points[i1].x - dm_x); this._VtxWritePtr[0].pos.y = (points[i1].y - dm_y); this._VtxWritePtr[0].uv = uv; this._VtxWritePtr[0].col = col; // Inner
			this._VtxWritePtr[1].pos.x = (points[i1].x + dm_x); this._VtxWritePtr[1].pos.y = (points[i1].y + dm_y); this._VtxWritePtr[1].uv = uv; this._VtxWritePtr[1].col = col_trans; // Outer
			this._VtxWritePtr = this._VtxWritePtr[2:]

			// Add indexes for fringes
			this._IdxWritePtr[0] = cast(ImDrawIdx) (vtx_inner_idx + u32(i1 << 1))
			this._IdxWritePtr[1] = cast(ImDrawIdx) (vtx_inner_idx + u32(i0 << 1))
			this._IdxWritePtr[2] = cast(ImDrawIdx) (vtx_outer_idx + u32(i0 << 1))
			this._IdxWritePtr[3] = cast(ImDrawIdx) (vtx_outer_idx + u32(i0 << 1))
			this._IdxWritePtr[4] = cast(ImDrawIdx) (vtx_outer_idx + u32(i1 << 1))
			this._IdxWritePtr[5] = cast(ImDrawIdx) (vtx_inner_idx + u32(i1 << 1))
			this._IdxWritePtr = this._IdxWritePtr[6:]
		}

		this._VtxCurrentIdx += cast(u32) cast(ImDrawIdx) vtx_count
	}
	else {
		// Non Anti-aliased Fill
		idx_count : i32 = (points_count - 2) * 3
		vtx_count : i32 = points_count
		ImDrawList_PrimReserve(this, idx_count, vtx_count)
		for i : i32 = 0; i < vtx_count; i += 1 {
			this._VtxWritePtr[0].pos = points[i]; this._VtxWritePtr[0].uv = uv; this._VtxWritePtr[0].col = col
			post_incr(&this._VtxWritePtr)
		}

		reserve_discard(&this._Data.TempBuffer, (ImTriangulator_EstimateScratchBufferSize(points_count) + size_of(ImVec2)) / size_of(ImVec2))
		Init(&triangulator, points, this._Data.TempBuffer.Data)
		for triangulator._TrianglesLeft > 0 {
			GetNextTriangle(&triangulator, &triangle)
			this._IdxWritePtr[0] = cast(ImDrawIdx) (this._VtxCurrentIdx + triangle[0]); this._IdxWritePtr[1] = cast(ImDrawIdx) (this._VtxCurrentIdx + triangle[1]); this._IdxWritePtr[2] = cast(ImDrawIdx) (this._VtxCurrentIdx + triangle[2])
			this._IdxWritePtr = this._IdxWritePtr[3:]
		}

		this._VtxCurrentIdx += cast(u32) cast(ImDrawIdx) vtx_count
	}
}

//-----------------------------------------------------------------------------
// [SECTION] ImDrawListSplitter
//-----------------------------------------------------------------------------
// FIXME: This may be a little confusing, trying to be a little too low-level/optimal instead of just doing vector swap..
//-----------------------------------------------------------------------------

ImDrawListSplitter_ClearFreeMemory :: proc(this : ^ImDrawListSplitter)
{
	for i : i32 = 0; i < this._Channels.Size; i += 1 {
		if i == this._Current {
			// Current channel is a copy of CmdBuffer/IdxBuffer, don't destruct again
			this._Channels.Data[i] = {}
		}
		clear(&this._Channels.Data[i]._CmdBuffer)
		clear(&this._Channels.Data[i]._IdxBuffer)
	}

	this._Current = 0
	this._Count = 1
	clear(&this._Channels)
}

ImDrawListSplitter_Split :: proc(this : ^ImDrawListSplitter, draw_list : ^ImDrawList, channels_count : i32)
{
	IM_UNUSED(draw_list)
	IM_ASSERT(this._Current == 0 && this._Count <= 1, "Nested channel splitting is not supported. Please use separate instances of ImDrawListSplitter.")
	old_channels_count : i32 = this._Channels.Size
	if old_channels_count < channels_count {
		reserve(&this._Channels, channels_count); // Avoid over reserving since this is likely to stay stable
		resize(&this._Channels, channels_count)
	}
	this._Count = channels_count

	// Channels[] (24/32 bytes each) hold storage that we'll swap with draw_list->_CmdBuffer/_IdxBuffer
	// The content of Channels[0] at this point doesn't matter. We clear it to make state tidy in a debugger but we don't strictly need to.
	// When we switch to the next channel, we'll copy draw_list->_CmdBuffer/_IdxBuffer into Channels[0] and then Channels[1] into draw_list->CmdBuffer/_IdxBuffer
	memset(&this._Channels.Data[0], 0, size_of(ImDrawChannel))
	for i : i32 = 1; i < channels_count; i += 1 {
		if i >= old_channels_count {
			this._Channels.Data[i] = {}
		}
		else {
			resize(&this._Channels.Data[i]._CmdBuffer, 0)
			resize(&this._Channels.Data[i]._IdxBuffer, 0)
		}
	}
}

ImDrawListSplitter_Merge :: proc(this : ^ImDrawListSplitter, draw_list : ^ImDrawList)
{
	// Note that we never use or rely on _Channels.Size because it is merely a buffer that we never shrink back to 0 to keep all sub-buffers ready for use.
	if this._Count <= 1 { return }

	ImDrawListSplitter_SetCurrentChannel(this, draw_list, 0)
	_PopUnusedDrawCmd(draw_list)

	// Calculate our final buffer sizes. Also fix the incorrect IdxOffset values in each command.
	new_cmd_buffer_count : i32 = 0
	new_idx_buffer_count : i32 = 0
	last_cmd : ^ImDrawCmd = (this._Count > 0 && draw_list.CmdBuffer.Size > 0) ? back(&draw_list.CmdBuffer) : nil
	idx_offset := last_cmd != nil ? last_cmd.IdxOffset + last_cmd.ElemCount : 0
	for i : i32 = 1; i < this._Count; i += 1 {
		ch : ^ImDrawChannel = &this._Channels.Data[i]
		if ch._CmdBuffer.Size > 0 && back(&ch._CmdBuffer).ElemCount == 0 && back(&ch._CmdBuffer).UserCallback == nil {
			// Equivalent of PopUnusedDrawCmd()
			pop_back(&ch._CmdBuffer)
		}

		if ch._CmdBuffer.Size > 0 && last_cmd != nil {
			// Do not include ImDrawCmd_AreSequentialIdxOffset() in the compare as we rebuild IdxOffset values ourselves.
			// Manipulating IdxOffset (e.g. by reordering draw commands like done by RenderDimmedBackgroundBehindWindow()) is not supported within a splitter.
			next_cmd : ^ImDrawCmd = &ch._CmdBuffer.Data[0]
			if ImDrawCmd_HeaderCompare(last_cmd, next_cmd) == 0 && last_cmd.UserCallback == nil && next_cmd.UserCallback == nil {
				// Merge previous channel last draw command with current channel first draw command if matching.
				last_cmd.ElemCount += next_cmd.ElemCount
				idx_offset += next_cmd.ElemCount
				erase(&ch._CmdBuffer, ch._CmdBuffer.Data); // FIXME-OPT: Improve for multiple merges.
			}
		}
		if ch._CmdBuffer.Size > 0 { last_cmd = back(&ch._CmdBuffer) }
		new_cmd_buffer_count += ch._CmdBuffer.Size
		new_idx_buffer_count += ch._IdxBuffer.Size
		for cmd_n : i32 = 0; cmd_n < ch._CmdBuffer.Size; cmd_n += 1 {
			ch._CmdBuffer.Data[cmd_n].IdxOffset = idx_offset
			idx_offset += ch._CmdBuffer.Data[cmd_n].ElemCount
		}
	}

	resize(&draw_list.CmdBuffer, draw_list.CmdBuffer.Size + new_cmd_buffer_count)
	resize(&draw_list.IdxBuffer, draw_list.IdxBuffer.Size + new_idx_buffer_count)

	// Write commands and indices in order (they are fairly small structures, we don't copy vertices only indices)
	cmd_write : [^]ImDrawCmd = &draw_list.CmdBuffer.Data[draw_list.CmdBuffer.Size - new_cmd_buffer_count]
	idx_write : [^]ImDrawIdx = &draw_list.IdxBuffer.Data[draw_list.IdxBuffer.Size - new_idx_buffer_count]
	for i : i32 = 1; i < this._Count; i += 1 {
		ch : ^ImDrawChannel = &this._Channels.Data[i]
		if sz : i32 = ch._CmdBuffer.Size; sz != 0 {memcpy(cmd_write, ch._CmdBuffer.Data, int(sz) * size_of(ImDrawCmd)); cmd_write = cmd_write[sz:] }
		if sz : i32 = ch._IdxBuffer.Size; sz != 0 {memcpy(idx_write, ch._IdxBuffer.Data, int(sz) * size_of(ImDrawIdx)); idx_write = idx_write[sz:] }
	}

	draw_list._IdxWritePtr = idx_write

	// Ensure there's always a non-callback draw command trailing the command-buffer
	if draw_list.CmdBuffer.Size == 0 || back(&draw_list.CmdBuffer).UserCallback != nil { AddDrawCmd(draw_list) }

	// If current command is used with different settings we need to add a new command
	curr_cmd : ^ImDrawCmd = &draw_list.CmdBuffer.Data[draw_list.CmdBuffer.Size - 1]
	if curr_cmd.ElemCount == 0 {
		// Copy ClipRect, TextureId, VtxOffset
		ImDrawCmd_HeaderCopy(curr_cmd, &draw_list._CmdHeader)
	}
	else if ImDrawCmd_HeaderCompare(curr_cmd, &draw_list._CmdHeader) != 0 { AddDrawCmd(draw_list) }

	this._Count = 1
}

ImDrawListSplitter_SetCurrentChannel :: proc(this : ^ImDrawListSplitter, draw_list : ^ImDrawList, idx : i32)
{
	IM_ASSERT(idx >= 0 && idx < this._Count)
	if this._Current == idx { return }

	// Overwrite ImVector (12/16 bytes), four times. This is merely a silly optimization instead of doing .swap()
	memcpy(&this._Channels.Data[this._Current]._CmdBuffer, &draw_list.CmdBuffer, size_of(draw_list.CmdBuffer))
	memcpy(&this._Channels.Data[this._Current]._IdxBuffer, &draw_list.IdxBuffer, size_of(draw_list.IdxBuffer))
	this._Current = idx
	memcpy(&draw_list.CmdBuffer, &this._Channels.Data[idx]._CmdBuffer, size_of(draw_list.CmdBuffer))
	memcpy(&draw_list.IdxBuffer, &this._Channels.Data[idx]._IdxBuffer, size_of(draw_list.IdxBuffer))
	draw_list._IdxWritePtr = draw_list.IdxBuffer.Data[draw_list.IdxBuffer.Size:]

	// If current command is used with different settings we need to add a new command
	curr_cmd : ^ImDrawCmd = (draw_list.CmdBuffer.Size == 0) ? nil : &draw_list.CmdBuffer.Data[draw_list.CmdBuffer.Size - 1]
	if curr_cmd == nil { AddDrawCmd(draw_list) }
	else if curr_cmd.ElemCount == 0 {
		// Copy ClipRect, TextureId, VtxOffset
		ImDrawCmd_HeaderCopy(curr_cmd, &draw_list._CmdHeader)
	}
	else if ImDrawCmd_HeaderCompare(curr_cmd, &draw_list._CmdHeader) != 0 { AddDrawCmd(draw_list) }
}

//-----------------------------------------------------------------------------
// [SECTION] ImDrawData
//-----------------------------------------------------------------------------

ImDrawData_Clear :: proc(this : ^ImDrawData)
{
	this.Valid = false
	this.TotalVtxCount = 0; this.TotalIdxCount = this.TotalVtxCount; this.CmdListsCount = this.TotalIdxCount
	resize(&this.CmdLists, 0); // The ImDrawList are NOT owned by ImDrawData but e.g. by ImGuiContext, so we don't clear them.
	this.FramebufferScale = ImVec2{0.0, 0.0}; this.DisplaySize = this.FramebufferScale; this.DisplayPos = this.DisplaySize
	this.OwnerViewport = nil
}

// Important: 'out_list' is generally going to be draw_data->CmdLists, but may be another temporary list
// as long at it is expected that the result will be later merged into draw_data->CmdLists[].
AddDrawListToDrawDataEx :: proc(draw_data : ^ImDrawData, out_list : ^ImVector(^ImDrawList), draw_list : ^ImDrawList)
{
	if draw_list.CmdBuffer.Size == 0 { return }
	if draw_list.CmdBuffer.Size == 1 && draw_list.CmdBuffer.Data[0].ElemCount == 0 && draw_list.CmdBuffer.Data[0].UserCallback == nil { return }

	// Draw list sanity check. Detect mismatch between PrimReserve() calls and incrementing _VtxCurrentIdx, _VtxWritePtr etc.
	// May trigger for you if you are using PrimXXX functions incorrectly.
	IM_ASSERT(draw_list.VtxBuffer.Size == 0 || draw_list._VtxWritePtr == draw_list.VtxBuffer.Data[draw_list.VtxBuffer.Size:])
	IM_ASSERT(draw_list.IdxBuffer.Size == 0 || draw_list._IdxWritePtr == draw_list.IdxBuffer.Data[draw_list.IdxBuffer.Size:])
	if (draw_list.Flags & ImDrawListFlags_.ImDrawListFlags_AllowVtxOffset) == {} { IM_ASSERT(cast(i32) draw_list._VtxCurrentIdx == draw_list.VtxBuffer.Size) }

	// Check that draw_list doesn't use more vertices than indexable (default ImDrawIdx = unsigned short = 2 bytes = 64K vertices per ImDrawList = per window)
	// If this assert triggers because you are drawing lots of stuff manually:
	// - First, make sure you are coarse clipping yourself and not trying to draw many things outside visible bounds.
	//   Be mindful that the lower-level ImDrawList API doesn't filter vertices. Use the Metrics/Debugger window to inspect draw list contents.
	// - If you want large meshes with more than 64K vertices, you can either:
	//   (A) Handle the ImDrawCmd::VtxOffset value in your renderer backend, and set 'io.BackendFlags |= ImGuiBackendFlags_RendererHasVtxOffset'.
	//       Most example backends already support this from 1.71. Pre-1.71 backends won't.
	//       Some graphics API such as GL ES 1/2 don't have a way to offset the starting vertex so it is not supported for them.
	//   (B) Or handle 32-bit indices in your renderer backend, and uncomment '#define ImDrawIdx unsigned int' line in imconfig.h.
	//       Most example backends already support this. For example, the OpenGL example code detect index size at compile-time:
	//         glDrawElements(GL_TRIANGLES, (GLsizei)pcmd->ElemCount, sizeof(ImDrawIdx) == 2 ? GL_UNSIGNED_SHORT : GL_UNSIGNED_INT, idx_buffer_offset);
	//       Your own engine or render API may use different parameters or function calls to specify index sizes.
	//       2 and 4 bytes indices are generally supported by most graphics API.
	// - If for some reason neither of those solutions works for you, a workaround is to call BeginChild()/EndChild() before reaching
	//   the 64K limit to split your draw commands in multiple draw lists.
	if size_of(ImDrawIdx) == 2 { IM_ASSERT(draw_list._VtxCurrentIdx < (1 << 16), "Too many vertices in ImDrawList using 16-bit indices. Read comment above") }

	// Resolve callback data pointers
	if draw_list._CallbacksDataBuf.Size > 0 { for &cmd in draw_list.CmdBuffer.Data[:draw_list.CmdBuffer.Size] { if cmd.UserCallback != nil && cmd.UserCallbackDataOffset != -1 && cmd.UserCallbackDataSize > 0 { cmd.UserCallbackData = &draw_list._CallbacksDataBuf.Data[cmd.UserCallbackDataOffset] } } }

	// Add to output list + records state in ImDrawData
	push_back(out_list, draw_list)
	post_incr(&draw_data.CmdListsCount)
	draw_data.TotalVtxCount += draw_list.VtxBuffer.Size
	draw_data.TotalIdxCount += draw_list.IdxBuffer.Size
}

// Helper to add an external draw list into an existing ImDrawData.
ImDrawData_AddDrawList :: proc(this : ^ImDrawData, draw_list : ^ImDrawList)
{
	IM_ASSERT(this.CmdLists.Size == this.CmdListsCount)
	_PopUnusedDrawCmd(draw_list)
	AddDrawListToDrawDataEx(this, &this.CmdLists, draw_list)
}

// Helper to convert all buffers from indexed to non-indexed, in case you cannot render indexed. Note: this is slow and most likely a waste of resources. Always prefer indexed rendering!
// For backward compatibility: convert all buffers from indexed to de-indexed, in case you cannot render indexed. Note: this is slow and most likely a waste of resources. Always prefer indexed rendering!
ImDrawData_DeIndexAllBuffers :: proc(this : ^ImDrawData)
{
	new_vtx_buffer : ImVector(ImDrawVert)
	this.TotalIdxCount = 0; this.TotalVtxCount = this.TotalIdxCount
	for i : i32 = 0; i < this.CmdListsCount; i += 1 {
		cmd_list : ^ImDrawList = this.CmdLists.Data[i]
		if empty(&cmd_list.IdxBuffer) { continue }
		resize(&new_vtx_buffer, cmd_list.IdxBuffer.Size)
		for j : i32 = 0; j < cmd_list.IdxBuffer.Size; j += 1 { new_vtx_buffer.Data[j] = cmd_list.VtxBuffer.Data[cmd_list.IdxBuffer.Data[j]] }

		swap(&cmd_list.VtxBuffer, &new_vtx_buffer)
		resize(&cmd_list.IdxBuffer, 0)
		this.TotalVtxCount += cmd_list.VtxBuffer.Size
	}
}

// Helper to scale the ClipRect field of each ImDrawCmd. Use if your final output buffer is at a different scale than Dear ImGui expects, or if there is a difference between your window resolution and framebuffer resolution.
// Helper to scale the ClipRect field of each ImDrawCmd.
// Use if your final output buffer is at a different scale than draw_data->DisplaySize,
// or if there is a difference between your window resolution and framebuffer resolution.
ImDrawData_ScaleClipRects :: proc(this : ^ImDrawData, fb_scale : ^ImVec2)
{
	for draw_list in this.CmdLists.Data[:this.CmdLists.Size] { for &cmd in draw_list.CmdBuffer.Data[:draw_list.CmdBuffer.Size] { cmd.ClipRect = ImVec4{cmd.ClipRect.x * fb_scale.x, cmd.ClipRect.y * fb_scale.y, cmd.ClipRect.z * fb_scale.x, cmd.ClipRect.w * fb_scale.y} } }
}

//-----------------------------------------------------------------------------
// [SECTION] Helpers ShadeVertsXXX functions
//-----------------------------------------------------------------------------

// Generic linear color gradient, write to RGB fields, leave A untouched.
ShadeVertsLinearColorGradientKeepAlpha :: proc(draw_list : ^ImDrawList, vert_start_idx : i32, vert_end_idx : i32, gradient_p0 : ImVec2, gradient_p1 : ImVec2, col0 : ImU32, col1 : ImU32)
{
	gradient_extent : ImVec2 = gradient_p1 - gradient_p0
	gradient_inv_length2 : f32 = 1.0 / ImLengthSqr(gradient_extent)
	vert_start := draw_list.VtxBuffer.Data[vert_start_idx:]
	vert_end := &draw_list.VtxBuffer.Data[vert_end_idx]
	col0_r : i32 = cast(i32) (col0 >> IM_COL32_R_SHIFT) & 0xFF
	col0_g : i32 = cast(i32) (col0 >> IM_COL32_G_SHIFT) & 0xFF
	col0_b : i32 = cast(i32) (col0 >> IM_COL32_B_SHIFT) & 0xFF
	col_delta_r : i32 = (cast(i32) (col1 >> IM_COL32_R_SHIFT) & 0xFF) - col0_r
	col_delta_g : i32 = (cast(i32) (col1 >> IM_COL32_G_SHIFT) & 0xFF) - col0_g
	col_delta_b : i32 = (cast(i32) (col1 >> IM_COL32_B_SHIFT) & 0xFF) - col0_b
	for vert : ^ImDrawVert = vert_start; vert < vert_end; vert = mem.ptr_offset(vert, 1) {
		d : f32 = ImDot(vert.pos - gradient_p0, gradient_extent)
		t : f32 = ImClamp(d * gradient_inv_length2, 0.0, 1.0)
		r : u32 = cast(u32) (f32(col0_r) + f32(col_delta_r) * t)
		g : u32 = cast(u32) (f32(col0_g) + f32(col_delta_g) * t)
		b : u32 = cast(u32) (f32(col0_b) + f32(col_delta_b) * t)
		vert.col = (r << IM_COL32_R_SHIFT) | (g << IM_COL32_G_SHIFT) | (b << IM_COL32_B_SHIFT) | (vert.col & IM_COL32_A_MASK)
	}
}

// Distribute UV over (a, b) rectangle
ShadeVertsLinearUV :: proc(draw_list : ^ImDrawList, vert_start_idx : i32, vert_end_idx : i32, a : ImVec2, b : ImVec2, uv_a : ImVec2, uv_b : ImVec2, clamp : bool)
{
	size : ImVec2 = b - a
	uv_size : ImVec2 = uv_b - uv_a
	scale : ImVec2 = ImVec2{size.x != 0.0 ? (uv_size.x / size.x) : 0.0, size.y != 0.0 ? (uv_size.y / size.y) : 0.0}

	vert_start : ^ImDrawVert = &draw_list.VtxBuffer.Data[vert_start_idx]
	vert_end : ^ImDrawVert = &draw_list.VtxBuffer.Data[vert_end_idx]
	if clamp {
		min : ImVec2 = ImMin(uv_a, uv_b)
		max : ImVec2 = ImMax(uv_a, uv_b)
		for vertex : ^ImDrawVert = vert_start; vertex < vert_end; vertex = mem.ptr_offset(vertex, 1) { vertex.uv = ImClamp(uv_a + ImMul(ImVec2{vertex.pos.x, vertex.pos.y} - a, scale), min, max) }
	}
	else {
		for vertex : ^ImDrawVert = vert_start; vertex < vert_end; vertex = mem.ptr_offset(vertex, 1) { vertex.uv = uv_a + ImMul(ImVec2{vertex.pos.x, vertex.pos.y} - a, scale) }
	}
}

ShadeVertsTransformPos :: proc(draw_list : ^ImDrawList, vert_start_idx : i32, vert_end_idx : i32, pivot_in : ImVec2, cos_a : f32, sin_a : f32, pivot_out : ImVec2)
{
	vert_start := draw_list.VtxBuffer.Data[vert_start_idx:]
	vert_end := draw_list.VtxBuffer.Data[vert_end_idx:]
	for vertex : ^ImDrawVert = vert_start; vertex < vert_end; vertex = mem.ptr_offset(vertex, 1) { vertex.pos = ImRotate(vertex.pos - pivot_in, cos_a, sin_a) + pivot_out }
}

//-----------------------------------------------------------------------------
// [SECTION] ImFontConfig
//-----------------------------------------------------------------------------

ImFontConfig_init :: proc(this : ^ImFontConfig)
{
	this^ = {}
	this.FontDataOwnedByAtlas = true
	this.OversampleH = 2
	this.OversampleV = 1
	this.GlyphMaxAdvanceX = FLT_MAX
	this.RasterizerMultiply = 1.0
	this.RasterizerDensity = 1.0
	this.EllipsisChar = 0
}

//-----------------------------------------------------------------------------
// [SECTION] ImFontAtlas
//-----------------------------------------------------------------------------
// - Default texture data encoded in ASCII
// - ImFontAtlas::ClearInputData()
// - ImFontAtlas::ClearTexData()
// - ImFontAtlas::ClearFonts()
// - ImFontAtlas::Clear()
// - ImFontAtlas::GetTexDataAsAlpha8()
// - ImFontAtlas::GetTexDataAsRGBA32()
// - ImFontAtlas::AddFont()
// - ImFontAtlas::AddFontDefault()
// - ImFontAtlas::AddFontFromFileTTF()
// - ImFontAtlas::AddFontFromMemoryTTF()
// - ImFontAtlas::AddFontFromMemoryCompressedTTF()
// - ImFontAtlas::AddFontFromMemoryCompressedBase85TTF()
// - ImFontAtlas::AddCustomRectRegular()
// - ImFontAtlas::AddCustomRectFontGlyph()
// - ImFontAtlas::CalcCustomRectUV()
// - ImFontAtlas::GetMouseCursorTexData()
// - ImFontAtlas::Build()
// - ImFontAtlasBuildMultiplyCalcLookupTable()
// - ImFontAtlasBuildMultiplyRectAlpha8()
// - ImFontAtlasBuildWithStbTruetype()
// - ImFontAtlasGetBuilderForStbTruetype()
// - ImFontAtlasUpdateConfigDataPointers()
// - ImFontAtlasBuildSetupFont()
// - ImFontAtlasBuildPackCustomRects()
// - ImFontAtlasBuildRender8bppRectFromString()
// - ImFontAtlasBuildRender32bppRectFromString()
// - ImFontAtlasBuildRenderDefaultTexData()
// - ImFontAtlasBuildRenderLinesTexData()
// - ImFontAtlasBuildInit()
// - ImFontAtlasBuildFinish()
//-----------------------------------------------------------------------------

// A work of art lies ahead! (. = white layer, X = black layer, others are blank)
// The 2x2 white texels on the top left are the ones we'll use everywhere in Dear ImGui to render filled shapes.
// (This is used when io.MouseDrawCursor = true)
FONT_ATLAS_DEFAULT_TEX_DATA_W : i32 : 122; // Actual texture will be 2 times that + 1 spacing.
FONT_ATLAS_DEFAULT_TEX_DATA_H : i32 : 27
FONT_ATLAS_DEFAULT_TEX_DATA_PIXELS : [FONT_ATLAS_DEFAULT_TEX_DATA_W * FONT_ATLAS_DEFAULT_TEX_DATA_H]u8 = (
	"..-         -XXXXXXX-    X    -           X           -XXXXXXX          -          XXXXXXX-     XX          - XX       XX " + \
	"..-         -X.....X-   X.X   -          X.X          -X.....X          -          X.....X-    X..X         -X..X     X..X" + \
	"---         -XXX.XXX-  X...X  -         X...X         -X....X           -           X....X-    X..X         -X...X   X...X" + \
	"X           -  X.X  - X.....X -        X.....X        -X...X            -            X...X-    X..X         - X...X X...X " + \
	"XX          -  X.X  -X.......X-       X.......X       -X..X.X           -           X.X..X-    X..X         -  X...X...X  " + \
	"X.X         -  X.X  -XXXX.XXXX-       XXXX.XXXX       -X.X X.X          -          X.X X.X-    X..XXX       -   X.....X   " + \
	"X..X        -  X.X  -   X.X   -          X.X          -XX   X.X         -         X.X   XX-    X..X..XXX    -    X...X    " + \
	"X...X       -  X.X  -   X.X   -    XX    X.X    XX    -      X.X        -        X.X      -    X..X..X..XX  -     X.X     " + \
	"X....X      -  X.X  -   X.X   -   X.X    X.X    X.X   -       X.X       -       X.X       -    X..X..X..X.X -    X...X    " + \
	"X.....X     -  X.X  -   X.X   -  X..X    X.X    X..X  -        X.X      -      X.X        -XXX X..X..X..X..X-   X.....X   " + \
	"X......X    -  X.X  -   X.X   - X...XXXXXX.XXXXXX...X -         X.X   XX-XX   X.X         -X..XX........X..X-  X...X...X  " + \
	"X.......X   -  X.X  -   X.X   -X.....................X-          X.X X.X-X.X X.X          -X...X...........X- X...X X...X " + \
	"X........X  -  X.X  -   X.X   - X...XXXXXX.XXXXXX...X -           X.X..X-X..X.X           - X..............X-X...X   X...X" + \
	"X.........X -XXX.XXX-   X.X   -  X..X    X.X    X..X  -            X...X-X...X            -  X.............X-X..X     X..X" + \
	"X..........X-X.....X-   X.X   -   X.X    X.X    X.X   -           X....X-X....X           -  X.............X- XX       XX " + \
	"X......XXXXX-XXXXXXX-   X.X   -    XX    X.X    XX    -          X.....X-X.....X          -   X............X--------------" + \
	"X...X..X    ---------   X.X   -          X.X          -          XXXXXXX-XXXXXXX          -   X...........X -             " + \
	"X..X X..X   -       -XXXX.XXXX-       XXXX.XXXX       -------------------------------------    X..........X -             " + \
	"X.X  X..X   -       -X.......X-       X.......X       -    XX           XX    -           -    X..........X -             " + \
	"XX    X..X  -       - X.....X -        X.....X        -   X.X           X.X   -           -     X........X  -             " + \
	"      X..X  -       -  X...X  -         X...X         -  X..X           X..X  -           -     X........X  -             " + \
	"       XX   -       -   X.X   -          X.X          - X...XXXXXXXXXXXXX...X -           -     XXXXXXXXXX  -             " + \
	"-------------       -    X    -           X           -X.....................X-           -------------------             " + \
	"                    ----------------------------------- X...XXXXXXXXXXXXX...X -                                           " + \
	"                                                      -  X..X           X..X  -                                           " + \
	"                                                      -   X.X           X.X   -                                           " + \
	"                                                      -    XX           XX    -                                           " \
)

FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA : [ImGuiMouseCursor_.ImGuiMouseCursor_COUNT][3]ImVec2 = {
	// Pos ........ Size ......... Offset ......
	{ImVec2{0  , 3 }, ImVec2{12, 19}, ImVec2{0 , 0 }}, // ImGuiMouseCursor_Arrow
	{ImVec2{13 , 0 }, ImVec2{7 , 16}, ImVec2{1 , 8 }}, // ImGuiMouseCursor_TextInput
	{ImVec2{31 , 0 }, ImVec2{23, 23}, ImVec2{11, 11}}, // ImGuiMouseCursor_ResizeAll
	{ImVec2{21 , 0 }, ImVec2{9 , 23}, ImVec2{4 , 11}}, // ImGuiMouseCursor_ResizeNS
	{ImVec2{55 , 18}, ImVec2{23, 9 }, ImVec2{11, 4 }}, // ImGuiMouseCursor_ResizeEW
	{ImVec2{73 , 0 }, ImVec2{17, 17}, ImVec2{8 , 8 }}, // ImGuiMouseCursor_ResizeNESW
	{ImVec2{55 , 0 }, ImVec2{17, 17}, ImVec2{8 , 8 }}, // ImGuiMouseCursor_ResizeNWSE
	{ImVec2{91 , 0 }, ImVec2{17, 22}, ImVec2{5 , 0 }}, // ImGuiMouseCursor_Hand
	{ImVec2{109, 0 }, ImVec2{13, 15}, ImVec2{6 , 7 }}, // ImGuiMouseCursor_NotAllowed
}

ImFontAtlas_init :: proc(this : ^ImFontAtlas)
{
	this^ = {}
	this.TexGlyphPadding = 1
	this.PackIdLines = -1; this.PackIdMouseCursors = this.PackIdLines
}

ImFontAtlas_deinit :: proc(this : ^ImFontAtlas)
{
	IM_ASSERT(!this.Locked, "Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!")
	ImFontAtlas_Clear(this)
	deinit(&this.Fonts)
	deinit(&this.CustomRects)
	deinit(&this.ConfigData)
}

// Clear input data (all ImFontConfig structures including sizes, TTF data, glyph ranges, etc.) = all the data used to build the texture and fonts.
ImFontAtlas_ClearInputData :: proc(this : ^ImFontAtlas)
{
	IM_ASSERT(!this.Locked, "Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!")
	for &font_cfg in this.ConfigData.Data[:this.ConfigData.Size] {
		if font_cfg.FontData != nil && font_cfg.FontDataOwnedByAtlas {
			IM_FREE(font_cfg.FontData)
			font_cfg.FontData = nil
		}
	}

	// When clearing this we lose access to the font name and other information used to build the font.
	for &font in this.Fonts.Data[:this.Fonts.Size] {
		if font.ConfigData >= this.ConfigData.Data && font.ConfigData < &this.ConfigData.Data[this.ConfigData.Size] {
			font.ConfigData = nil
			font.ConfigDataCount = 0
		}
	}

	clear(&this.ConfigData)
	clear(&this.CustomRects)
	this.PackIdLines = -1; this.PackIdMouseCursors = this.PackIdLines
	// Important: we leave TexReady untouched
}

// Clear output texture data (CPU side). Saves RAM once the texture has been copied to graphics memory.
ImFontAtlas_ClearTexData :: proc(this : ^ImFontAtlas)
{
	IM_ASSERT(!this.Locked, "Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!")
	if this.TexPixelsAlpha8 != nil { IM_FREE(this.TexPixelsAlpha8) }
	if this.TexPixelsRGBA32 != nil { IM_FREE(this.TexPixelsRGBA32) }
	this.TexPixelsAlpha8 = nil
	this.TexPixelsRGBA32 = nil
	this.TexPixelsUseColors = false
	// Important: we leave TexReady untouched
}

// Clear output font data (glyphs storage, UV coordinates).
ImFontAtlas_ClearFonts :: proc(this : ^ImFontAtlas)
{
	IM_ASSERT(!this.Locked, "Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!")
	clear_delete(&this.Fonts)
	this.TexReady = false
}

// Clear all input and output.
ImFontAtlas_Clear :: proc(this : ^ImFontAtlas)
{
	ImFontAtlas_ClearInputData(this)
	ImFontAtlas_ClearTexData(this)
	ImFontAtlas_ClearFonts(this)
}

// 1 byte per-pixel
ImFontAtlas_GetTexDataAsAlpha8 :: proc(this : ^ImFontAtlas, out_pixels : ^^u8, out_width : ^i32, out_height : ^i32, out_bytes_per_pixel : ^i32 = nil)
{
	// Build atlas on demand
	if this.TexPixelsAlpha8 == nil { ImFontAtlas_Build(this) }

	out_pixels^ = this.TexPixelsAlpha8
	if out_width != nil { out_width^ = this.TexWidth }
	if out_height != nil { out_height^ = this.TexHeight }
	if out_bytes_per_pixel != nil { out_bytes_per_pixel^ = 1 }
}

// 4 bytes-per-pixel
ImFontAtlas_GetTexDataAsRGBA32 :: proc(this : ^ImFontAtlas, out_pixels : ^^u8, out_width : ^i32, out_height : ^i32, out_bytes_per_pixel : ^i32 = nil)
{
	// Convert to RGBA32 format on demand
	// Although it is likely to be the most commonly used format, our font rendering is 1 channel / 8 bpp
	if this.TexPixelsRGBA32 == nil {
		pixels : ^u8 = nil
		ImFontAtlas_GetTexDataAsAlpha8(this, &pixels, nil, nil)
		if pixels != nil {
			this.TexPixelsRGBA32 = cast(^u32) IM_ALLOC(cast(uint) this.TexWidth * cast(uint) this.TexHeight * 4)
			src : ^u8 = pixels
			dst : ^u32 = this.TexPixelsRGBA32
			for n : i32 = this.TexWidth * this.TexHeight; n > 0; n -= 1 { post_incr(&dst)^ = IM_COL32(255, 255, 255, cast(u32) (post_incr(&src)^)) }
		}
	}

	out_pixels^ = cast(^u8) this.TexPixelsRGBA32
	if out_width != nil { out_width^ = this.TexWidth }
	if out_height != nil { out_height^ = this.TexHeight }
	if out_bytes_per_pixel != nil { out_bytes_per_pixel^ = 4 }
}

ImFontAtlas_AddFont :: proc(this : ^ImFontAtlas, font_cfg : ^ImFontConfig) -> ^ImFont
{
	IM_ASSERT(!this.Locked, "Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!")
	IM_ASSERT(font_cfg.FontData != nil && font_cfg.FontDataSize > 0)
	IM_ASSERT(font_cfg.SizePixels > 0.0, "Is ImFontConfig struct correctly initialized?")
	IM_ASSERT(font_cfg.OversampleH > 0 && font_cfg.OversampleV > 0, "Is ImFontConfig struct correctly initialized?")
	IM_ASSERT(font_cfg.RasterizerDensity > 0.0)

	// Create new font
	if !font_cfg.MergeMode { push_back(&this.Fonts, IM_NEW(ImFont)) }
	else {
		// When using MergeMode make sure that a font has already been added before. You can use ImGui::GetIO().Fonts->AddFontDefault() to add the default imgui font.
		IM_ASSERT(this.Fonts.Size > 0, "Cannot use MergeMode for the first font")
	}

	push_back(&this.ConfigData, font_cfg^)
	new_font_cfg : ^ImFontConfig = back(&this.ConfigData)
	if new_font_cfg.DstFont == nil { new_font_cfg.DstFont = back(&this.Fonts)^ }
	if !new_font_cfg.FontDataOwnedByAtlas {
		new_font_cfg.FontData = IM_ALLOC(new_font_cfg.FontDataSize)
		new_font_cfg.FontDataOwnedByAtlas = true
		memcpy(new_font_cfg.FontData, font_cfg.FontData, cast(int) new_font_cfg.FontDataSize)
	}

	// Round font size
	// - We started rounding in 1.90 WIP (18991) as our layout system currently doesn't support non-rounded font size well yet.
	// - Note that using io.FontGlobalScale or SetWindowFontScale(), with are legacy-ish, partially supported features, can still lead to unrounded sizes.
	// - We may support it better later and remove this rounding.
	new_font_cfg.SizePixels = ImTrunc(new_font_cfg.SizePixels)

	// Pointers to ConfigData and BuilderData are otherwise dangling
	ImFontAtlasUpdateConfigDataPointers(this)

	// Invalidate texture
	this.TexReady = false
	ImFontAtlas_ClearTexData(this)
	return new_font_cfg.DstFont
}

Decode85Byte :: proc(c : u8) -> u32 { return u32(c >= '\\' ? c - 36 : c - 35) }
Decode85 :: proc(src : [^]u8, dst : [^]u8)
{
	src, dst := src, dst
	for src[0] != 0 {
		tmp : u32 = Decode85Byte(src[0]) + 85 * (Decode85Byte(src[1]) + 85 * (Decode85Byte(src[2]) + 85 * (Decode85Byte(src[3]) + 85 * Decode85Byte(src[4]))))
		dst[0] = u8((tmp >> 0) & 0xFF); dst[1] = u8((tmp >> 8) & 0xFF); dst[2] = u8((tmp >> 16) & 0xFF); dst[3] = u8((tmp >> 24) & 0xFF); // We can't assume little-endianness.
		src = src[5:]
		dst = dst[4:]
	}
}

// Load embedded ProggyClean.ttf at size 13, disable oversampling
ImFontAtlas_AddFontDefault :: proc(this : ^ImFontAtlas, font_cfg_template : ^ImFontConfig = nil) -> ^ImFont
{
	when ! IMGUI_DISABLE_DEFAULT_FONT { /* @gen ifndef */
	font_cfg : ImFontConfig
	if(font_cfg_template != nil) { font_cfg = font_cfg_template^ } else { init(&font_cfg) }
	if font_cfg_template == nil {
		font_cfg.OversampleV = 1; font_cfg.OversampleH = font_cfg.OversampleV
		font_cfg.PixelSnapH = true
	}
	if font_cfg.SizePixels <= 0.0 { font_cfg.SizePixels = 13.0 * 1.0 }
	if font_cfg.Name[0] == 0 { ImFormatString(font_cfg.Name[:], "ProggyClean.ttf, %dpx", cast(i32) font_cfg.SizePixels) }
	font_cfg.EllipsisChar = cast(ImWchar) 0x0085
	font_cfg.GlyphOffset.y = 1.0 * IM_TRUNC(font_cfg.SizePixels / 13.0); // Add +1 offset per 13 units

	ttf_compressed_size : i32 = 0
	ttf_compressed : ^u8 = GetDefaultCompressedFontDataTTF(&ttf_compressed_size)
	glyph_ranges : ^ImWchar = font_cfg.GlyphRanges != nil ? font_cfg.GlyphRanges : ImFontAtlas_GetGlyphRangesDefault(this)
	font : ^ImFont = ImFontAtlas_AddFontFromMemoryCompressedTTF(this, ttf_compressed, ttf_compressed_size, font_cfg.SizePixels, &font_cfg, glyph_ranges)
	return font
	} else { // preproc else
	IM_ASSERT(false, "AddFontDefault() disabled in this build.")
	IM_UNUSED(font_cfg_template)
	return nil
	} // preproc endif// #ifndef IMGUI_DISABLE_DEFAULT_FONT
}

ImFontAtlas_AddFontFromFileTTF :: proc(this : ^ImFontAtlas, filename : string, size_pixels : f32, font_cfg_template : ^ImFontConfig = nil, glyph_ranges : ^ImWchar = nil) -> ^ImFont
{
	IM_ASSERT(!this.Locked, "Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!")
	data_size : uint = 0
	data : rawptr = ImFileLoadToMemory(filename, "rb", &data_size, 0)
	if data == nil {
		IM_ASSERT_USER_ERROR(false, "Could not load font file!")
		return nil
	}
	font_cfg : ImFontConfig
	if(font_cfg_template != nil) { font_cfg = font_cfg_template^ } else { init(&font_cfg) }
	if font_cfg.Name[0] == 0 {
		// Store a short copy of filename into into the font name for convenience
		p : [^]u8
		for p = raw_data(filename)[len(filename):]; p > raw_data(filename) && p[-1] != '/' && p[-1] != '\\'; p = p[-1:] { }

		ImFormatString(font_cfg.Name[:], "%s, %.0fpx", p, size_pixels)
	}
	return ImFontAtlas_AddFontFromMemoryTTF(this, data, cast(i32) data_size, size_pixels, &font_cfg, glyph_ranges)
}

// Note: Transfer ownership of 'ttf_data' to ImFontAtlas! Will be deleted after destruction of the atlas. Set font_cfg->FontDataOwnedByAtlas=false to keep ownership of your data and it won't be freed.
// NB: Transfer ownership of 'ttf_data' to ImFontAtlas, unless font_cfg_template->FontDataOwnedByAtlas == false. Owned TTF buffer will be deleted after Build().
ImFontAtlas_AddFontFromMemoryTTF :: proc(this : ^ImFontAtlas, font_data : rawptr, font_data_size : i32, size_pixels : f32, font_cfg_template : ^ImFontConfig = nil, glyph_ranges : ^ImWchar = nil) -> ^ImFont
{
	IM_ASSERT(!this.Locked, "Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!")
	font_cfg : ImFontConfig
	if(font_cfg_template != nil) { font_cfg = font_cfg_template^ } else { init(&font_cfg) }
	IM_ASSERT(font_cfg.FontData == nil)
	IM_ASSERT(font_data_size > 100, "Incorrect value for font_data_size!"); // Heuristic to prevent accidentally passing a wrong value to font_data_size.
	font_cfg.FontData = font_data
	font_cfg.FontDataSize = font_data_size
	font_cfg.SizePixels = size_pixels > 0.0 ? size_pixels : font_cfg.SizePixels
	if glyph_ranges != nil { font_cfg.GlyphRanges = glyph_ranges }
	return ImFontAtlas_AddFont(this, &font_cfg)
}

// 'compressed_font_data' still owned by caller. Compress with binary_to_compressed_c.cpp.
ImFontAtlas_AddFontFromMemoryCompressedTTF :: proc(this : ^ImFontAtlas, compressed_ttf_data : rawptr, compressed_ttf_size : i32, size_pixels : f32, font_cfg_template : ^ImFontConfig = nil, glyph_ranges : ^ImWchar = nil) -> ^ImFont
{
	buf_decompressed_size : u32 = stb_decompress_length(cast(^u8) compressed_ttf_data)
	buf_decompressed_data : ^u8 = cast(^u8) IM_ALLOC(buf_decompressed_size)
	stb_decompress(buf_decompressed_data, cast(^u8) compressed_ttf_data, cast(u32) compressed_ttf_size)

	font_cfg : ImFontConfig
	if(font_cfg_template != nil) { font_cfg = font_cfg_template^ } else { init(&font_cfg) }
	IM_ASSERT(font_cfg.FontData == nil)
	font_cfg.FontDataOwnedByAtlas = true
	return ImFontAtlas_AddFontFromMemoryTTF(this, buf_decompressed_data, cast(i32) buf_decompressed_size, size_pixels, &font_cfg, glyph_ranges)
}

// 'compressed_font_data_base85' still owned by caller. Compress with binary_to_compressed_c.cpp with -base85 parameter.
ImFontAtlas_AddFontFromMemoryCompressedBase85TTF :: proc(this : ^ImFontAtlas, compressed_ttf_data_base85 : ^u8, size_pixels : f32, font_cfg : ^ImFontConfig = nil, glyph_ranges : ^ImWchar = nil) -> ^ImFont
{
	compressed_ttf_size : i32 = ((cast(i32) strlen(compressed_ttf_data_base85) + 4) / 5) * 4
	compressed_ttf : rawptr = IM_ALLOC(cast(uint) compressed_ttf_size)
	Decode85(cast(^u8) compressed_ttf_data_base85, cast(^u8) compressed_ttf)
	font : ^ImFont = ImFontAtlas_AddFontFromMemoryCompressedTTF(this, compressed_ttf, compressed_ttf_size, size_pixels, font_cfg, glyph_ranges)
	IM_FREE(compressed_ttf)
	return font
}

//-------------------------------------------
// [BETA] Custom Rectangles/Glyphs API
//-------------------------------------------

// You can request arbitrary rectangles to be packed into the atlas, for your own purposes.
// - After calling Build(), you can query the rectangle position and render your pixels.
// - If you render colored output, set 'atlas->TexPixelsUseColors = true' as this may help some backends decide of preferred texture format.
// - You can also request your rectangles to be mapped as font glyph (given a font + Unicode point),
//   so you can render e.g. custom colorful icons and use them as regular glyphs.
// - Read docs/FONTS.md for more details about using colorful icons.
// - Note: this API may be redesigned later in order to support multi-monitor varying DPI settings.
ImFontAtlas_AddCustomRectRegular :: proc(this : ^ImFontAtlas, width : i32, height : i32) -> i32
{
	IM_ASSERT(width > 0 && width <= 0xFFFF)
	IM_ASSERT(height > 0 && height <= 0xFFFF)
	r : ImFontAtlasCustomRect
	r.Width = cast(u16) width
	r.Height = cast(u16) height
	push_back(&this.CustomRects, r)
	return this.CustomRects.Size - 1// Return index
}

ImFontAtlas_AddCustomRectFontGlyph :: proc(this : ^ImFontAtlas, font : ^ImFont, id : ImWchar, width : i32, height : i32, advance_x : f32, offset : ImVec2 = ImVec2{0, 0}) -> i32
{
	when IMGUI_USE_WCHAR32 { /* @gen ifdef */
	IM_ASSERT(id <= IM_UNICODE_CODEPOINT_MAX)
	} // preproc endif
	IM_ASSERT(font != nil)
	IM_ASSERT(width > 0 && width <= 0xFFFF)
	IM_ASSERT(height > 0 && height <= 0xFFFF)
	r : ImFontAtlasCustomRect
	r.Width = cast(u16) width
	r.Height = cast(u16) height
	r.GlyphID = u32(id)
	r.GlyphColored = 0; // Set to 1 manually to mark glyph as colored // FIXME: No official API for that (#8133)
	r.GlyphAdvanceX = advance_x
	r.GlyphOffset = offset
	r.Font = font
	push_back(&this.CustomRects, r)
	return this.CustomRects.Size - 1// Return index
}

// [Internal]
ImFontAtlas_CalcCustomRectUV :: proc(this : ^ImFontAtlas, rect : ImFontAtlasCustomRect, out_uv_min : ^ImVec2, out_uv_max : ^ImVec2)
{
	IM_ASSERT(this.TexWidth > 0 && this.TexHeight > 0); // Font atlas needs to be built before we can calculate UV coordinates
	IM_ASSERT(IsPacked(rect)); // Make sure the rectangle has been packed
	out_uv_min^ = ImVec2{cast(f32) rect.X * this.TexUvScale.x, cast(f32) rect.Y * this.TexUvScale.y}
	out_uv_max^ = ImVec2{cast(f32) (rect.X + rect.Width) * this.TexUvScale.x, cast(f32) (rect.Y + rect.Height) * this.TexUvScale.y}
}

ImFontAtlas_GetMouseCursorTexData :: proc(this : ^ImFontAtlas, cursor_type : ImGuiMouseCursor, out_offset : ^ImVec2, out_size : ^ImVec2, out_uv_border : ^[2]ImVec2, out_uv_fill : ^[2]ImVec2) -> bool
{
	if cursor_type <= ImGuiMouseCursor_.ImGuiMouseCursor_None || cursor_type >= ImGuiMouseCursor_.ImGuiMouseCursor_COUNT { return false }
	if (this.Flags & ImFontAtlasFlags_.ImFontAtlasFlags_NoMouseCursors) != {} { return false }

	IM_ASSERT(this.PackIdMouseCursors != -1)
	r : ^ImFontAtlasCustomRect = ImFontAtlas_GetCustomRectByIndex(this, this.PackIdMouseCursors)
	pos : ImVec2 = FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA[cursor_type][0] + ImVec2{cast(f32) r.X, cast(f32) r.Y}
	size : ImVec2 = FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA[cursor_type][1]
	out_size^ = size
	out_offset^ = FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA[cursor_type][2]
	out_uv_border[0] = (pos) * this.TexUvScale
	out_uv_border[1] = (pos + size) * this.TexUvScale
	pos.x += f32(FONT_ATLAS_DEFAULT_TEX_DATA_W + 1)
	out_uv_fill[0] = (pos) * this.TexUvScale
	out_uv_fill[1] = (pos + size) * this.TexUvScale
	return true
}

// Build atlas, retrieve pixel data.
// User is in charge of copying the pixels into graphics memory (e.g. create a texture with your engine). Then store your texture handle with SetTexID().
// The pitch is always = Width * BytesPerPixels (1 or 4)
// Building in RGBA32 format is provided for convenience and compatibility, but note that unless you manually manipulate or copy color data into
// the texture (e.g. when using the AddCustomRect*** api), then the RGB pixels emitted will always be white (~75% of memory/bandwidth waste.
// Build pixels data. This is called automatically for you by the GetTexData*** functions.
ImFontAtlas_Build :: proc(this : ^ImFontAtlas) -> bool
{
	IM_ASSERT(!this.Locked, "Cannot modify a locked ImFontAtlas between NewFrame() and EndFrame/Render()!")

	// Default font is none are specified
	if this.ConfigData.Size == 0 { ImFontAtlas_AddFontDefault(this) }

	// Select builder
	// - Note that we do not reassign to atlas->FontBuilderIO, since it is likely to point to static data which
	//   may mess with some hot-reloading schemes. If you need to assign to this (for dynamic selection) AND are
	//   using a hot-reloading scheme that messes up static data, store your own instance of ImFontBuilderIO somewhere
	//   and point to it instead of pointing directly to return value of the GetBuilderXXX functions.
	builder_io : ^ImFontBuilderIO = this.FontBuilderIO
	if builder_io == nil {
		when IMGUI_ENABLE_FREETYPE { /* @gen ifdef */
		builder_io = ImGuiFreeType_GetBuilderForFreeType()
		} else when IMGUI_ENABLE_STB_TRUETYPE {
		builder_io = ImFontAtlasGetBuilderForStbTruetype()
		} else { // preproc else
		IM_ASSERT(false); // Invalid Build function
		} // preproc endif
	}

	// Build
	return builder_io.FontBuilder_Build(this)
}

ImFontAtlasBuildMultiplyCalcLookupTable :: proc(out_table : ^[256]u8, in_brighten_factor : f32)
{
	for i : u32 = 0; i < 256; i += 1 {
		value : u32 = cast(u32) (f32(i) * in_brighten_factor)
		out_table[i] = value > 255 ? 255 : u8(value & 0xFF)
	}
}

ImFontAtlasBuildMultiplyRectAlpha8 :: proc(table : [256]u8, pixels : [^]u8, x : i32, y : i32, w : i32, h : i32, stride : i32)
{
	IM_ASSERT_PARANOID(w <= stride)
	data := pixels[x + y * stride:]
	for j : i32 = h; j > 0; j, data = j - 1, data[stride - w:] { for i : i32 = w; i > 0; i, data = i - 1, data[1:] { data[0] = table[data[0]] } }
}

when IMGUI_ENABLE_STB_TRUETYPE { /* @gen ifdef */

stbtt_pack_range :: struct {
	font_size:                        f32,
	first_unicode_codepoint_in_range: i32,
	array_of_unicode_codepoints:      [^]rune,
	num_chars:                        i32,
	chardata_for_range:               ^stbtt.packedchar,
	h_oversample, v_oversample: u8, // used internally to store oversample info
}

// Temporary data for one source font (multiple source fonts can be merged into one destination ImFont)
// (C++03 doesn't allow instancing ImVector<> with function-local types so we declare the type here.)
ImFontBuildSrcData :: struct {
	FontInfo : stbtt.fontinfo,
	PackRange : stbtt.pack_range, // Hold the list of codepoints to pack (essentially points to Codepoints.Data)
	Rects : [^]stbrp.Rect, // Rectangle to pack. We first fill in their size and the packer will give us their position.
	PackedChars : [^]stbtt.packedchar, // Output glyphs
	SrcRanges : [^]ImWchar, // Ranges as requested by user (user is allowed to request too much, e.g. 0x0020..0xFFFF)
	DstIndex : i32, // Index into atlas->Fonts.Data[] and dst_tmp_array[]
	GlyphsHighest : i32, // Highest requested codepoint
	GlyphsCount : i32, // Glyph count (excluding missing glyphs and glyphs already set by an earlier source font)
	GlyphsSet : ImBitVector, // Glyph bit map (random access, 1-bit per codepoint. This will be a maximum of 8KB)
	GlyphsList : ImVector(rune), // Glyph codepoints list (flattened version of GlyphsSet)
}

ImFontBuildSrcData_deinit :: proc(this : ^ImFontBuildSrcData)
{
	deinit(&this.GlyphsSet)
	deinit(&this.GlyphsList)
}

ImFontBuildSrcData_init :: proc(this : ^ImFontBuildSrcData)
{
	init(&this.GlyphsSet)
	init(&this.GlyphsList)
}

// Temporary data for one destination ImFont* (multiple source fonts can be merged into one destination ImFont)
ImFontBuildDstData :: struct {
	SrcCount : i32, // Number of source fonts targeting this destination font.
	GlyphsHighest : i32,
	GlyphsCount : i32,
	GlyphsSet : ImBitVector, // This is used to resolve collision when multiple sources are merged into a same destination font.
}

ImFontBuildDstData_deinit :: proc(this : ^ImFontBuildDstData) { deinit(&this.GlyphsSet) }

ImFontBuildDstData_init :: proc(this : ^ImFontBuildDstData) { init(&this.GlyphsSet) }

UnpackBitVectorToFlatIndexList :: proc(in_ : ^ImBitVector, out : ^ImVector(rune))
{
	IM_ASSERT(size_of(in_.Storage.Data[0]) == size_of(i32))
	it_begin := begin(&in_.Storage)
	it_end := end(&in_.Storage)
	for it := it_begin; it < it_end; it = it[1:] {
		if entries_32 := it[0]; entries_32 != 0 {
			for bit_n : ImU32 = 0; bit_n < 32; bit_n += 1 {
				if (entries_32 & (ImU32(1) << bit_n)) != 0 {
					push_back(out, rune(u32(mem.ptr_sub(it, it_begin) << 5) + bit_n))
				}
			}
		}
	}
}

ImFontAtlasBuildWithStbTruetype :: proc(atlas : ^ImFontAtlas) -> bool
{
	IM_ASSERT(atlas.ConfigData.Size > 0)

	ImFontAtlasBuildInit(atlas)

	// Clear atlas
	atlas.TexID = cast(ImTextureID) 0
	atlas.TexHeight = 0; atlas.TexWidth = atlas.TexHeight
	atlas.TexUvScale = ImVec2{0.0, 0.0}
	atlas.TexUvWhitePixel = ImVec2{0.0, 0.0}
	ClearTexData(atlas)

	// Temporary storage for building
	src_tmp_array : ImVector(ImFontBuildSrcData)
	dst_tmp_array : ImVector(ImFontBuildDstData)
	resize(&src_tmp_array, atlas.ConfigData.Size)
	resize(&dst_tmp_array, atlas.Fonts.Size)
	memset(src_tmp_array.Data, 0, cast(int) size_in_bytes(&src_tmp_array))
	memset(dst_tmp_array.Data, 0, cast(int) size_in_bytes(&dst_tmp_array))

	// 1. Initialize font loading structure, check font data validity
	for src_i : i32 = 0; src_i < atlas.ConfigData.Size; src_i += 1 {
		src_tmp : ^ImFontBuildSrcData = &src_tmp_array.Data[src_i]
		cfg : ^ImFontConfig = &atlas.ConfigData.Data[src_i]
		IM_ASSERT(cfg.DstFont != nil && (!IsLoaded(cfg.DstFont) || cfg.DstFont.ContainerAtlas == atlas))

		// Find index from cfg.DstFont (we allow the user to set cfg.DstFont. Also it makes casual debugging nicer than when storing indices)
		src_tmp.DstIndex = -1
		for output_i : i32 = 0; output_i < atlas.Fonts.Size && src_tmp.DstIndex == -1; output_i += 1 { if cfg.DstFont == atlas.Fonts.Data[output_i] { src_tmp.DstIndex = output_i } }

		if src_tmp.DstIndex == -1 {
			IM_ASSERT(src_tmp.DstIndex != -1); // cfg.DstFont not pointing within atlas->Fonts.Data[] array?
			return false
		}
		// Initialize helper structure for font loading and verify that the TTF/OTF data is correct
		font_offset : i32 = stbtt.GetFontOffsetForIndex(cast([^]u8) cfg.FontData, cfg.FontNo)
		IM_ASSERT(font_offset >= 0, "FontData is incorrect, or FontNo cannot be found.")
		if stbtt.InitFont(&src_tmp.FontInfo, cast([^]u8) cfg.FontData, font_offset) == false {
			IM_ASSERT(false, "stbtt_InitFont(): failed to parse FontData. It is correct and complete? Check FontDataSize.")
			return false
		}

		// Measure highest codepoints
		dst_tmp : ^ImFontBuildDstData = &dst_tmp_array.Data[src_tmp.DstIndex]
		src_tmp.SrcRanges = cfg.GlyphRanges != nil ? cfg.GlyphRanges : GetGlyphRangesDefault(atlas)
		for src_range : [^]ImWchar = src_tmp.SrcRanges; src_range[0] != 0 && src_range[1] != 0; src_range = src_range[2:] {
			// Check for valid range. This may also help detect *some* dangling pointers, because a common
			// user error is to setup ImFontConfig::GlyphRanges with a pointer to data that isn't persistent,
			// or to forget to zero-terminate the glyph range array.
			IM_ASSERT(src_range[0] <= src_range[1], "Invalid range: is your glyph range array persistent? it is zero-terminated?")
			src_tmp.GlyphsHighest = ImMax(src_tmp.GlyphsHighest, cast(i32) src_range[1])
		}

		post_incr(&dst_tmp.SrcCount)
		dst_tmp.GlyphsHighest = ImMax(dst_tmp.GlyphsHighest, src_tmp.GlyphsHighest)
	}

	// 2. For every requested codepoint, check for their presence in the font data, and handle redundancy or overlaps between source fonts to avoid unused glyphs.
	total_glyphs_count : i32 = 0
	for src_i : i32 = 0; src_i < src_tmp_array.Size; src_i += 1 {
		src_tmp : ^ImFontBuildSrcData = &src_tmp_array.Data[src_i]
		dst_tmp : ^ImFontBuildDstData = &dst_tmp_array.Data[src_tmp.DstIndex]
		Create(&src_tmp.GlyphsSet, src_tmp.GlyphsHighest + 1)
		if empty(&dst_tmp.GlyphsSet.Storage) { Create(&dst_tmp.GlyphsSet, dst_tmp.GlyphsHighest + 1) }

		for src_range : [^]ImWchar = src_tmp.SrcRanges; src_range[0] != 0 && src_range[1] != 0; src_range = src_range[2:] {
			for codepoint := src_range[0]; codepoint <= src_range[1]; codepoint += 1 {
				if TestBit(&dst_tmp.GlyphsSet, cast(u32) codepoint) {
					// Don't overwrite existing glyphs. We could make this an option for MergeMode (e.g. MergeOverwrite==true)
					continue
				}
				if stbtt.FindGlyphIndex(&src_tmp.FontInfo, cast(rune)codepoint) == 0 {
					// It is actually in the font?
					continue
				}

				// Add to avail set/counters
				post_incr(&src_tmp.GlyphsCount)
				post_incr(&dst_tmp.GlyphsCount)
				SetBit(&src_tmp.GlyphsSet, cast(u32) codepoint)
				SetBit(&dst_tmp.GlyphsSet, cast(u32) codepoint)
				post_incr(&total_glyphs_count)
			}
		}
	}

	// 3. Unpack our bit map into a flat list (we now have all the Unicode points that we know are requested _and_ available _and_ not overlapping another)
	for src_i : i32 = 0; src_i < src_tmp_array.Size; src_i += 1 {
		src_tmp : ^ImFontBuildSrcData = &src_tmp_array.Data[src_i]
		reserve(&src_tmp.GlyphsList, src_tmp.GlyphsCount)
		UnpackBitVectorToFlatIndexList(&src_tmp.GlyphsSet, &src_tmp.GlyphsList)
		Clear(&src_tmp.GlyphsSet)
		IM_ASSERT(src_tmp.GlyphsList.Size == src_tmp.GlyphsCount)
	}

	for dst_i : i32 = 0; dst_i < dst_tmp_array.Size; dst_i += 1 { Clear(&dst_tmp_array.Data[dst_i].GlyphsSet) }

	clear(&dst_tmp_array)

	// Allocate packing character data and flag packed characters buffer as non-packed (x0=y0=x1=y1=0)
	// (We technically don't need to zero-clear buf_rects, but let's do it for the sake of sanity)
	buf_rects : ImVector(stbrp.Rect)
	buf_packedchars : ImVector(stbtt.packedchar)
	resize(&buf_rects, total_glyphs_count)
	resize(&buf_packedchars, total_glyphs_count)
	memset(buf_rects.Data, 0, cast(int) size_in_bytes(&buf_rects))
	memset(buf_packedchars.Data, 0, cast(int) size_in_bytes(&buf_packedchars))

	// 4. Gather glyphs sizes so we can pack them in our virtual canvas.
	total_surface : i32 = 0
	buf_rects_out_n : i32 = 0
	buf_packedchars_out_n : i32 = 0
	pack_padding : i32 = atlas.TexGlyphPadding
	for src_i : i32 = 0; src_i < src_tmp_array.Size; src_i += 1 {
		src_tmp : ^ImFontBuildSrcData = &src_tmp_array.Data[src_i]
		if src_tmp.GlyphsCount == 0 { continue }

		src_tmp.Rects = &buf_rects.Data[buf_rects_out_n]
		src_tmp.PackedChars = &buf_packedchars.Data[buf_packedchars_out_n]
		buf_rects_out_n += src_tmp.GlyphsCount
		buf_packedchars_out_n += src_tmp.GlyphsCount

		// Convert our ranges in the format stb_truetype wants
		cfg : ^ImFontConfig = &atlas.ConfigData.Data[src_i]
		src_tmp.PackRange.font_size = cfg.SizePixels * cfg.RasterizerDensity
		src_tmp.PackRange.first_unicode_codepoint_in_range = 0
		src_tmp.PackRange.array_of_unicode_codepoints = src_tmp.GlyphsList.Data
		src_tmp.PackRange.num_chars = src_tmp.GlyphsList.Size
		src_tmp.PackRange.chardata_for_range = src_tmp.PackedChars
		(^stbtt_pack_range)(&src_tmp.PackRange).h_oversample = cast(u8) cfg.OversampleH
		(^stbtt_pack_range)(&src_tmp.PackRange).v_oversample = cast(u8) cfg.OversampleV

		// Gather the sizes of all rectangles we will need to pack (this loop is based on stbtt_PackFontRangesGatherRects)
		scale : f32 = (cfg.SizePixels > 0.0) ? stbtt.ScaleForPixelHeight(&src_tmp.FontInfo, cfg.SizePixels * cfg.RasterizerDensity) : stbtt.ScaleForMappingEmToPixels(&src_tmp.FontInfo, -cfg.SizePixels * cfg.RasterizerDensity)
		for glyph_i : i32 = 0; glyph_i < src_tmp.GlyphsList.Size; glyph_i += 1 {
			x0 : i32; y0 : i32; x1 : i32; y1 : i32
			glyph_index_in_font : i32 = stbtt.FindGlyphIndex(&src_tmp.FontInfo, src_tmp.GlyphsList.Data[glyph_i])
			IM_ASSERT(glyph_index_in_font != 0)
			stbtt.GetGlyphBitmapBoxSubpixel(&src_tmp.FontInfo, glyph_index_in_font, scale * f32(cfg.OversampleH), scale * f32(cfg.OversampleV), 0, 0, &x0, &y0, &x1, &y1)
			src_tmp.Rects[glyph_i].w = cast(stbrp.Coord) (x1 - x0 + pack_padding + cfg.OversampleH - 1)
			src_tmp.Rects[glyph_i].h = cast(stbrp.Coord) (y1 - y0 + pack_padding + cfg.OversampleV - 1)
			total_surface += i32(src_tmp.Rects[glyph_i].w * src_tmp.Rects[glyph_i].h)
		}
	}

	for i : i32 = 0; i < atlas.CustomRects.Size; i += 1 {
		total_surface += (i32(atlas.CustomRects.Data[i].Width) + pack_padding) * (i32(atlas.CustomRects.Data[i].Height) + pack_padding)
	}

	// We need a width for the skyline algorithm, any width!
	// The exact width doesn't really matter much, but some API/GPU have texture size limitations and increasing width can decrease height.
	// User can override TexDesiredWidth and TexGlyphPadding if they wish, otherwise we use a simple heuristic to select the width based on expected surface.
	surface_sqrt : i32 = cast(i32) ImSqrt(cast(f32) total_surface) + 1
	atlas.TexHeight = 0
	if atlas.TexDesiredWidth > 0 { atlas.TexWidth = atlas.TexDesiredWidth }
	else { atlas.TexWidth = (surface_sqrt >= cast(i32)ImFloor(4096.0 * 0.7)) ? 4096 : (surface_sqrt >= cast(i32)ImFloor(2048.0 * 0.7)) ? 2048 : (surface_sqrt >= cast(i32)ImFloor(1024.0 * 0.7)) ? 1024 : 512 }

	// 5. Start packing
	// Pack our extra data rectangles first, so it will be on the upper-left corner of our texture (UV will have small values).
	TEX_HEIGHT_MAX : i32 = 1024 * 32
	spc : stbtt.pack_context = {}
	stbtt.PackBegin(&spc, nil, atlas.TexWidth, TEX_HEIGHT_MAX, 0, 0, nil)
	spc.padding = atlas.TexGlyphPadding; // Because we mixup stbtt_PackXXX and stbrp_PackXXX there's a bit of a hack here, not passing the value to stbtt_PackBegin() allows us to still pack a TexWidth-1 wide item. (#8107)
	ImFontAtlasBuildPackCustomRects(atlas, spc.pack_info)

	// 6. Pack each source font. No rendering yet, we are working with rectangles in an infinitely tall texture at this point.
	for src_i : i32 = 0; src_i < src_tmp_array.Size; src_i += 1 {
		src_tmp : ^ImFontBuildSrcData = &src_tmp_array.Data[src_i]
		if src_tmp.GlyphsCount == 0 { continue }

		stbrp.pack_rects(cast(^stbrp.Context) spc.pack_info, src_tmp.Rects, src_tmp.GlyphsCount)

		// Extend texture height and mark missing glyphs as non-packed so we won't render them.
		// FIXME: We are not handling packing failure here (would happen if we got off TEX_HEIGHT_MAX or if a single if larger than TexWidth?)
		for glyph_i : i32 = 0; glyph_i < src_tmp.GlyphsCount; glyph_i += 1 {
			if src_tmp.Rects[glyph_i].was_packed != false {
				atlas.TexHeight = ImMax(atlas.TexHeight, i32(src_tmp.Rects[glyph_i].y + src_tmp.Rects[glyph_i].h))
			}
		}
	}

	// 7. Allocate texture
	atlas.TexHeight = (atlas.Flags & ImFontAtlasFlags_.ImFontAtlasFlags_NoPowerOfTwoHeight) != {} ? (atlas.TexHeight + 1) : ImUpperPowerOfTwo(atlas.TexHeight)
	atlas.TexUvScale = ImVec2{1.0 / f32(atlas.TexWidth), 1.0 / f32(atlas.TexHeight)}
	atlas.TexPixelsAlpha8 = cast([^]u8) IM_ALLOC(atlas.TexWidth * atlas.TexHeight)
	memset(atlas.TexPixelsAlpha8, 0, int(atlas.TexWidth * atlas.TexHeight))
	spc.pixels = atlas.TexPixelsAlpha8
	spc.height = atlas.TexHeight

	// 8. Render/rasterize font characters into the texture
	for src_i : i32 = 0; src_i < src_tmp_array.Size; src_i += 1 {
		cfg : ^ImFontConfig = &atlas.ConfigData.Data[src_i]
		src_tmp : ^ImFontBuildSrcData = &src_tmp_array.Data[src_i]
		if src_tmp.GlyphsCount == 0 { continue }

		stbtt.PackFontRangesRenderIntoRects(&spc, &src_tmp.FontInfo, &src_tmp.PackRange, 1, src_tmp.Rects)

		// Apply multiply operator
		if cfg.RasterizerMultiply != 1.0 {
			multiply_table : [256]u8
			ImFontAtlasBuildMultiplyCalcLookupTable(&multiply_table, cfg.RasterizerMultiply)
			r : ^stbrp.Rect = &src_tmp.Rects[0]
			for glyph_i : i32 = 0; glyph_i < src_tmp.GlyphsCount; glyph_i, r = glyph_i + 1, mem.ptr_offset(r, 1) { if r.was_packed != false { ImFontAtlasBuildMultiplyRectAlpha8(multiply_table, atlas.TexPixelsAlpha8, i32(r.x), i32(r.y), i32(r.w), i32(r.h), atlas.TexWidth * 1) } }
		}
		src_tmp.Rects = nil
	}

	// End packing
	stbtt.PackEnd(&spc)
	clear(&buf_rects)

	// 9. Setup ImFont and glyphs for runtime
	for src_i : i32 = 0; src_i < src_tmp_array.Size; src_i += 1 {
		// When merging fonts with MergeMode=true:
		// - We can have multiple input fonts writing into a same destination font.
		// - dst_font->ConfigData is != from cfg which is our source configuration.
		src_tmp : ^ImFontBuildSrcData = &src_tmp_array.Data[src_i]
		cfg : ^ImFontConfig = &atlas.ConfigData.Data[src_i]
		dst_font : ^ImFont = cfg.DstFont

		font_scale : f32 = stbtt.ScaleForPixelHeight(&src_tmp.FontInfo, cfg.SizePixels)
		unscaled_ascent : i32; unscaled_descent : i32; unscaled_line_gap : i32
		stbtt.GetFontVMetrics(&src_tmp.FontInfo, &unscaled_ascent, &unscaled_descent, &unscaled_line_gap)

		ascent : f32 = ImCeil(f32(unscaled_ascent) * font_scale)
		descent : f32 = ImFloor(f32(unscaled_descent) * font_scale)
		ImFontAtlasBuildSetupFont(atlas, dst_font, cfg, ascent, descent)
		font_off_x : f32 = cfg.GlyphOffset.x
		font_off_y : f32 = cfg.GlyphOffset.y + IM_ROUND(dst_font.Ascent)

		inv_rasterization_scale : f32 = 1.0 / cfg.RasterizerDensity

		for glyph_i : i32 = 0; glyph_i < src_tmp.GlyphsCount; glyph_i += 1 {
			// Register glyph
			codepoint : i32 = cast(i32) src_tmp.GlyphsList.Data[glyph_i]
			pc : ^stbtt.packedchar = &src_tmp.PackedChars[glyph_i]
			q : stbtt.aligned_quad
			unused_x : f32 = 0.0; unused_y : f32 = 0.0
			stbtt.GetPackedQuad(src_tmp.PackedChars, atlas.TexWidth, atlas.TexHeight, glyph_i, &unused_x, &unused_y, &q, false)
			x0 : f32 = q.x0 * inv_rasterization_scale + font_off_x
			y0 : f32 = q.y0 * inv_rasterization_scale + font_off_y
			x1 : f32 = q.x1 * inv_rasterization_scale + font_off_x
			y1 : f32 = q.y1 * inv_rasterization_scale + font_off_y
			AddGlyph(dst_font, cfg, cast(ImWchar) codepoint, x0, y0, x1, y1, q.s0, q.t0, q.s1, q.t1, pc.xadvance * inv_rasterization_scale)
		}
	}

	// Cleanup
	clear_destruct(&src_tmp_array)

	ImFontAtlasBuildFinish(atlas)
	return true
}

ImFontAtlasGetBuilderForStbTruetype :: proc() -> ^ImFontBuilderIO
{
	@(static) io : ImFontBuilderIO
	io.FontBuilder_Build = ImFontAtlasBuildWithStbTruetype
	return &io
}

} // preproc endif// IMGUI_ENABLE_STB_TRUETYPE

ImFontAtlasUpdateConfigDataPointers :: proc(atlas : ^ImFontAtlas)
{
	for &font_cfg in atlas.ConfigData.Data[:atlas.ConfigData.Size] {
		font : ^ImFont = font_cfg.DstFont
		if !font_cfg.MergeMode {
			font.ConfigData = &font_cfg
			font.ConfigDataCount = 0
		}
		post_incr(&font.ConfigDataCount)
	}
}

ImFontAtlasBuildSetupFont :: proc(atlas : ^ImFontAtlas, font : ^ImFont, font_config : ^ImFontConfig, ascent : f32, descent : f32)
{
	if !font_config.MergeMode {
		ClearOutputData(font)
		font.FontSize = font_config.SizePixels
		IM_ASSERT(font.ConfigData == font_config)
		font.ContainerAtlas = atlas
		font.Ascent = ascent
		font.Descent = descent
	}
}

ImFontAtlasBuildPackCustomRects :: proc(atlas : ^ImFontAtlas, stbrp_context_opaque : rawptr)
{
	pack_context := cast(^stbrp.Context) stbrp_context_opaque
	IM_ASSERT(pack_context != nil)

	user_rects : ^ImVector(ImFontAtlasCustomRect) = &atlas.CustomRects
	IM_ASSERT(user_rects.Size >= 1); // We expect at least the default custom rects to be registered, else something went wrong.

	pack_padding : i32 = atlas.TexGlyphPadding
	pack_rects : ImVector(stbrp.Rect)
	resize(&pack_rects, user_rects.Size)
	memset(pack_rects.Data, 0, cast(int) size_in_bytes(&pack_rects))
	for i : i32 = 0; i < user_rects.Size; i += 1 {
		pack_rects.Data[i].w = stbrp.Coord(i32(user_rects.Data[i].Width) + pack_padding)
		pack_rects.Data[i].h = stbrp.Coord(i32(user_rects.Data[i].Height) + pack_padding)
	}

	stbrp.pack_rects(pack_context, &pack_rects.Data[0], pack_rects.Size)
	for i : i32 = 0; i < pack_rects.Size; i += 1 { if pack_rects.Data[i].was_packed != false {
		user_rects.Data[i].X = cast(u16) pack_rects.Data[i].x
		user_rects.Data[i].Y = cast(u16) pack_rects.Data[i].y
		IM_ASSERT(pack_rects.Data[i].w == stbrp.Coord(i32(user_rects.Data[i].Width) + pack_padding) && pack_rects.Data[i].h == stbrp.Coord(i32(user_rects.Data[i].Height) + pack_padding))
		atlas.TexHeight = ImMax(atlas.TexHeight, i32(pack_rects.Data[i].y + pack_rects.Data[i].h))
	} }
}

ImFontAtlasBuildRender8bppRectFromString :: proc(atlas : ^ImFontAtlas, x : i32, y : i32, w : i32, h : i32, in_str : [^]u8, in_marker_char : u8, in_marker_pixel_value : u8)
{
	IM_ASSERT(x >= 0 && x + w <= atlas.TexWidth)
	IM_ASSERT(y >= 0 && y + h <= atlas.TexHeight)
	out_pixel := atlas.TexPixelsAlpha8[x + (y * atlas.TexWidth):]
	in_str := in_str
	for off_y : i32 = 0; off_y < h; off_y, out_pixel, in_str = off_y + 1, out_pixel[atlas.TexWidth:], in_str[w:] {
		for off_x : i32 = 0; off_x < w; off_x += 1 {
			out_pixel[off_x] = (in_str[off_x] == in_marker_char) ? in_marker_pixel_value : 0x00
		}
	}
}

ImFontAtlasBuildRender32bppRectFromString :: proc(atlas : ^ImFontAtlas, x : i32, y : i32, w : i32, h : i32, in_str : [^]u8, in_marker_char : u8, in_marker_pixel_value : u32)
{
	IM_ASSERT(x >= 0 && x + w <= atlas.TexWidth)
	IM_ASSERT(y >= 0 && y + h <= atlas.TexHeight)
	out_pixel := atlas.TexPixelsRGBA32[x + (y * atlas.TexWidth):]
	in_str := in_str
	for off_y : i32 = 0; off_y < h; off_y, out_pixel, in_str = off_y + 1, out_pixel[atlas.TexWidth:], in_str[w:] {
		for off_x : i32 = 0; off_x < w; off_x += 1 {
			out_pixel[off_x] = (in_str[off_x] == in_marker_char) ? in_marker_pixel_value : IM_COL32_BLACK_TRANS
		}
	}
}

ImFontAtlasBuildRenderDefaultTexData :: proc(atlas : ^ImFontAtlas)
{
	r := GetCustomRectByIndex(atlas, atlas.PackIdMouseCursors)^
	IM_ASSERT(IsPacked(r))

	w : i32 = atlas.TexWidth
	if (atlas.Flags & ImFontAtlasFlags_.ImFontAtlasFlags_NoMouseCursors) != {} {
		// White pixels only
		IM_ASSERT(r.Width == 2 && r.Height == 2)
		offset : i32 = cast(i32) r.X + cast(i32) r.Y * w
		if atlas.TexPixelsAlpha8 != nil {
			atlas.TexPixelsAlpha8[offset + w + 1] = 0xFF; atlas.TexPixelsAlpha8[offset + w] = atlas.TexPixelsAlpha8[offset + w + 1]; atlas.TexPixelsAlpha8[offset + 1] = atlas.TexPixelsAlpha8[offset + w]; atlas.TexPixelsAlpha8[offset] = atlas.TexPixelsAlpha8[offset + 1]
		}
		else {
			atlas.TexPixelsRGBA32[offset + w + 1] = IM_COL32_WHITE; atlas.TexPixelsRGBA32[offset + w] = atlas.TexPixelsRGBA32[offset + w + 1]; atlas.TexPixelsRGBA32[offset + 1] = atlas.TexPixelsRGBA32[offset + w]; atlas.TexPixelsRGBA32[offset] = atlas.TexPixelsRGBA32[offset + 1]
		}
	}
	else {
		// White pixels and mouse cursor
		IM_ASSERT(r.Width == u16(FONT_ATLAS_DEFAULT_TEX_DATA_W * 2 + 1) && r.Height == u16(FONT_ATLAS_DEFAULT_TEX_DATA_H))
		x_for_white := i32(r.X)
		x_for_black := i32(r.X) + FONT_ATLAS_DEFAULT_TEX_DATA_W + 1
		if atlas.TexPixelsAlpha8 != nil {
			ImFontAtlasBuildRender8bppRectFromString(atlas, x_for_white, i32(r.Y), FONT_ATLAS_DEFAULT_TEX_DATA_W, FONT_ATLAS_DEFAULT_TEX_DATA_H, raw_data(&FONT_ATLAS_DEFAULT_TEX_DATA_PIXELS), '.', 0xFF)
			ImFontAtlasBuildRender8bppRectFromString(atlas, x_for_black, i32(r.Y), FONT_ATLAS_DEFAULT_TEX_DATA_W, FONT_ATLAS_DEFAULT_TEX_DATA_H, raw_data(&FONT_ATLAS_DEFAULT_TEX_DATA_PIXELS), 'X', 0xFF)
		}
		else {
			ImFontAtlasBuildRender32bppRectFromString(atlas, x_for_white, i32(r.Y), FONT_ATLAS_DEFAULT_TEX_DATA_W, FONT_ATLAS_DEFAULT_TEX_DATA_H, raw_data(&FONT_ATLAS_DEFAULT_TEX_DATA_PIXELS), '.', IM_COL32_WHITE)
			ImFontAtlasBuildRender32bppRectFromString(atlas, x_for_black, i32(r.Y), FONT_ATLAS_DEFAULT_TEX_DATA_W, FONT_ATLAS_DEFAULT_TEX_DATA_H, raw_data(&FONT_ATLAS_DEFAULT_TEX_DATA_PIXELS), 'X', IM_COL32_WHITE)
		}
	}
	atlas.TexUvWhitePixel = ImVec2{(f32(r.X) + 0.5) * atlas.TexUvScale.x, (f32(r.Y) + 0.5) * atlas.TexUvScale.y}
}

ImFontAtlasBuildRenderLinesTexData :: proc(atlas : ^ImFontAtlas)
{
	if (atlas.Flags & ImFontAtlasFlags_.ImFontAtlasFlags_NoBakedLines) != {} { return }

	// This generates a triangular shape in the texture, with the various line widths stacked on top of each other to allow interpolation between them
	r := GetCustomRectByIndex(atlas, atlas.PackIdLines)^
	IM_ASSERT(IsPacked(r))
	for n : i32 = 0; n < IM_DRAWLIST_TEX_LINES_WIDTH_MAX + 1; n += 1 {
		// Each line consists of at least two empty pixels at the ends, with a line of solid pixels in the middle
		y : i32 = n
		line_width : i32 = n
		pad_left : i32 = (i32(r.Width) - line_width) / 2
		pad_right : i32 = i32(r.Width) - (pad_left + line_width)

		// Write each slice
		IM_ASSERT(pad_left + line_width + pad_right == i32(r.Width) && y < i32(r.Height)); // Make sure we're inside the texture bounds before we start writing pixels
		if atlas.TexPixelsAlpha8 != nil {
			write_ptr := atlas.TexPixelsAlpha8[i32(r.X) + ((i32(r.Y) + y) * atlas.TexWidth):]
			for i : i32 = 0; i < pad_left; i += 1 { write_ptr[i] = 0x00 }
			for i : i32 = 0; i < line_width; i += 1 { write_ptr[pad_left + i] = 0xFF }
			for i : i32 = 0; i < pad_right; i += 1 { write_ptr[pad_left + line_width + i] = 0x00 }
		}
		else {
			write_ptr := atlas.TexPixelsRGBA32[i32(r.X) + ((i32(r.Y) + y) * atlas.TexWidth):]
			for i : i32 = 0; i < pad_left; i += 1 { write_ptr[i] = IM_COL32(255, 255, 255, 0) }
			for i : i32 = 0; i < line_width; i += 1 { write_ptr[pad_left + i] = IM_COL32_WHITE }
			for i : i32 = 0; i < pad_right; i += 1 { write_ptr[pad_left + line_width + i] = IM_COL32(255, 255, 255, 0) }
		}

		// Calculate UVs for this line
		uv0 : ImVec2 = ImVec2{cast(f32) (i32(r.X) + pad_left - 1), cast(f32) (i32(r.Y) + y)} * atlas.TexUvScale
		uv1 : ImVec2 = ImVec2{cast(f32) (i32(r.X) + pad_left + line_width + 1), cast(f32) (i32(r.Y) + y + 1)} * atlas.TexUvScale
		half_v : f32 = (uv0.y + uv1.y) * 0.5; // Calculate a constant V in the middle of the row to avoid sampling artifacts
		atlas.TexUvLines[n] = ImVec4{uv0.x, half_v, uv1.x, half_v}
	}
}

// Note: this is called / shared by both the stb_truetype and the FreeType builder
ImFontAtlasBuildInit :: proc(atlas : ^ImFontAtlas)
{
	// Register texture region for mouse cursors or standard white pixels
	if atlas.PackIdMouseCursors < 0 {
		if (atlas.Flags & ImFontAtlasFlags_.ImFontAtlasFlags_NoMouseCursors) == {} { atlas.PackIdMouseCursors = AddCustomRectRegular(atlas, FONT_ATLAS_DEFAULT_TEX_DATA_W * 2 + 1, FONT_ATLAS_DEFAULT_TEX_DATA_H) }
		else { atlas.PackIdMouseCursors = AddCustomRectRegular(atlas, 2, 2) }
	}

	// Register texture region for thick lines
	// The +2 here is to give space for the end caps, whilst height +1 is to accommodate the fact we have a zero-width row
	if atlas.PackIdLines < 0 {
		if (atlas.Flags & ImFontAtlasFlags_.ImFontAtlasFlags_NoBakedLines) == {} { atlas.PackIdLines = AddCustomRectRegular(atlas, IM_DRAWLIST_TEX_LINES_WIDTH_MAX + 2, IM_DRAWLIST_TEX_LINES_WIDTH_MAX + 1) }
	}
}

// This is called/shared by both the stb_truetype and the FreeType builder.
ImFontAtlasBuildFinish :: proc(atlas : ^ImFontAtlas)
{
	// Render into our custom data blocks
	IM_ASSERT(atlas.TexPixelsAlpha8 != nil || atlas.TexPixelsRGBA32 != nil)
	ImFontAtlasBuildRenderDefaultTexData(atlas)
	ImFontAtlasBuildRenderLinesTexData(atlas)

	// Register custom rectangle glyphs
	for i : i32 = 0; i < atlas.CustomRects.Size; i += 1 {
		r : ^ImFontAtlasCustomRect = &atlas.CustomRects.Data[i]
		if r.Font == nil || r.GlyphID == 0 { continue }

		// Will ignore ImFontConfig settings: GlyphMinAdvanceX, GlyphMinAdvanceY, GlyphExtraSpacing, PixelSnapH
		IM_ASSERT(r.Font.ContainerAtlas == atlas)
		uv0 : ImVec2; uv1 : ImVec2
		CalcCustomRectUV(atlas, r^, &uv0, &uv1)
		AddGlyph(r.Font, nil, cast(ImWchar) r.GlyphID, r.GlyphOffset.x, r.GlyphOffset.y, r.GlyphOffset.x + f32(r.Width), r.GlyphOffset.y + f32(r.Height), uv0.x, uv0.y, uv1.x, uv1.y, r.GlyphAdvanceX)
		if r.GlyphColored != 0 { back(&r.Font.Glyphs).Colored = 1 }
	}

	// Build all fonts lookup tables
	for font in atlas.Fonts.Data[:atlas.Fonts.Size] { if font.DirtyLookupTables { BuildLookupTable(font) } }

	atlas.TexReady = true
}

//-------------------------------------------
// Glyph Ranges
//-------------------------------------------

// Helpers to retrieve list of common Unicode ranges (2 value per range, values are inclusive, zero-terminated list)
// NB: Make sure that your string are UTF-8 and NOT in your local code page.
// Read https://github.com/ocornut/imgui/blob/master/docs/FONTS.md/#about-utf-8-encoding for details.
// NB: Consider using ImFontGlyphRangesBuilder to build glyph ranges from textual data.
// Basic Latin, Extended Latin
//-------------------------------------------------------------------------
// [SECTION] ImFontAtlas: glyph ranges helpers
//-------------------------------------------------------------------------
// - GetGlyphRangesDefault()
// - GetGlyphRangesGreek()
// - GetGlyphRangesKorean()
// - GetGlyphRangesChineseFull()
// - GetGlyphRangesChineseSimplifiedCommon()
// - GetGlyphRangesJapanese()
// - GetGlyphRangesCyrillic()
// - GetGlyphRangesThai()
// - GetGlyphRangesVietnamese()
//-----------------------------------------------------------------------------

// Retrieve list of range (2 int per range, values are inclusive)
ImFontAtlas_GetGlyphRangesDefault :: proc(this : ^ImFontAtlas) -> [^]ImWchar
{
	@(static) ranges := [?]ImWchar {
		0x0020, 0x00FF, // Basic Latin + Latin Supplement
		0,
	}
	return raw_data(&ranges)
}

// Default + Greek and Coptic
ImFontAtlas_GetGlyphRangesGreek :: proc(this : ^ImFontAtlas) -> [^]ImWchar
{
	@(static) ranges := [?]ImWchar {
		0x0020, 0x00FF, // Basic Latin + Latin Supplement
		0x0370, 0x03FF, // Greek and Coptic
		0,
	}
	return raw_data(&ranges)
}

// Default + Korean characters
ImFontAtlas_GetGlyphRangesKorean :: proc(this : ^ImFontAtlas) -> [^]ImWchar
{
	@(static) ranges := [?]ImWchar {
		0x0020, 0x00FF, // Basic Latin + Latin Supplement
		0x3131, 0x3163, // Korean alphabets
		0xAC00, 0xD7A3, // Korean characters
		0xFFFD, 0xFFFD, // Invalid
		0,
	}
	return raw_data(&ranges)
}

// Default + Half-Width + Japanese Hiragana/Katakana + full set of about 21000 CJK Unified Ideographs
ImFontAtlas_GetGlyphRangesChineseFull :: proc(this : ^ImFontAtlas) -> [^]ImWchar
{
	@(static) ranges := [?]ImWchar {
		0x0020, 0x00FF, // Basic Latin + Latin Supplement
		0x2000, 0x206F, // General Punctuation
		0x3000, 0x30FF, // CJK Symbols and Punctuations, Hiragana, Katakana
		0x31F0, 0x31FF, // Katakana Phonetic Extensions
		0xFF00, 0xFFEF, // Half-width characters
		0xFFFD, 0xFFFD, // Invalid
		0x4e00, 0x9FAF, // CJK Ideograms
		0,
	}
	return raw_data(&ranges)
}

UnpackAccumulativeOffsetsIntoRanges :: proc(base_codepoint : i32, accumulative_offsets : []i16, out_ranges : [^]ImWchar)
{
	out_ranges := out_ranges
	base_codepoint := base_codepoint

	for offset, n in accumulative_offsets {
		out_ranges[1] = cast(ImWchar) (base_codepoint + i32(accumulative_offsets[n])); out_ranges[0] = out_ranges[1]
		base_codepoint += i32(accumulative_offsets[n])
		out_ranges = out_ranges[2:]
	}

	out_ranges[0] = 0
}

// Default + Half-Width + Japanese Hiragana/Katakana + set of 2500 CJK Unified Ideographs for common simplified Chinese
ImFontAtlas_GetGlyphRangesChineseSimplifiedCommon :: proc(this : ^ImFontAtlas) -> [^]ImWchar
{
	// Store 2500 regularly used characters for Simplified Chinese.
	// Sourced from https://zh.wiktionary.org/wiki/%E9%99%84%E5%BD%95:%E7%8E%B0%E4%BB%A3%E6%B1%89%E8%AF%AD%E5%B8%B8%E7%94%A8%E5%AD%97%E8%A1%A8
	// This table covers 97.97% of all characters used during the month in July, 1987.
	// You can use ImFontGlyphRangesBuilder to create your own ranges derived from this, by merging existing ranges or adding new characters.
	// (Stored as accumulative offsets from the initial unicode codepoint 0x4E00. This encoding is designed to helps us compact the source code size.)
	@(static) accumulative_offsets_from_0x4E00 := [?]i16 {
		0, 1, 2, 4, 1, 1, 1, 1, 2, 1, 3, 2, 1, 2, 2, 1, 1, 1, 1, 1, 5, 2, 1, 2, 3, 3, 3, 2, 2, 4, 1, 1, 1, 2, 1, 5, 2, 3, 1, 2, 1, 2, 1, 1, 2, 1, 1, 2, 2, 1, 4, 1, 1, 1, 1, 5, 10, 1, 2, 19, 2, 1, 2, 1, 2, 1, 2, 1, 2,
		1, 5, 1, 6, 3, 2, 1, 2, 2, 1, 1, 1, 4, 8, 5, 1, 1, 4, 1, 1, 3, 1, 2, 1, 5, 1, 2, 1, 1, 1, 10, 1, 1, 5, 2, 4, 6, 1, 4, 2, 2, 2, 12, 2, 1, 1, 6, 1, 1, 1, 4, 1, 1, 4, 6, 5, 1, 4, 2, 2, 4, 10, 7, 1, 1, 4, 2, 4,
		2, 1, 4, 3, 6, 10, 12, 5, 7, 2, 14, 2, 9, 1, 1, 6, 7, 10, 4, 7, 13, 1, 5, 4, 8, 4, 1, 1, 2, 28, 5, 6, 1, 1, 5, 2, 5, 20, 2, 2, 9, 8, 11, 2, 9, 17, 1, 8, 6, 8, 27, 4, 6, 9, 20, 11, 27, 6, 68, 2, 2, 1, 1,
		1, 2, 1, 2, 2, 7, 6, 11, 3, 3, 1, 1, 3, 1, 2, 1, 1, 1, 1, 1, 3, 1, 1, 8, 3, 4, 1, 5, 7, 2, 1, 4, 4, 8, 4, 2, 1, 2, 1, 1, 4, 5, 6, 3, 6, 2, 12, 3, 1, 3, 9, 2, 4, 3, 4, 1, 5, 3, 3, 1, 3, 7, 1, 5, 1, 1, 1, 1, 2,
		3, 4, 5, 2, 3, 2, 6, 1, 1, 2, 1, 7, 1, 7, 3, 4, 5, 15, 2, 2, 1, 5, 3, 22, 19, 2, 1, 1, 1, 1, 2, 5, 1, 1, 1, 6, 1, 1, 12, 8, 2, 9, 18, 22, 4, 1, 1, 5, 1, 16, 1, 2, 7, 10, 15, 1, 1, 6, 2, 4, 1, 2, 4, 1, 6,
		1, 1, 3, 2, 4, 1, 6, 4, 5, 1, 2, 1, 1, 2, 1, 10, 3, 1, 3, 2, 1, 9, 3, 2, 5, 7, 2, 19, 4, 3, 6, 1, 1, 1, 1, 1, 4, 3, 2, 1, 1, 1, 2, 5, 3, 1, 1, 1, 2, 2, 1, 1, 2, 1, 1, 2, 1, 3, 1, 1, 1, 3, 7, 1, 4, 1, 1, 2, 1,
		1, 2, 1, 2, 4, 4, 3, 8, 1, 1, 1, 2, 1, 3, 5, 1, 3, 1, 3, 4, 6, 2, 2, 14, 4, 6, 6, 11, 9, 1, 15, 3, 1, 28, 5, 2, 5, 5, 3, 1, 3, 4, 5, 4, 6, 14, 3, 2, 3, 5, 21, 2, 7, 20, 10, 1, 2, 19, 2, 4, 28, 28, 2, 3,
		2, 1, 14, 4, 1, 26, 28, 42, 12, 40, 3, 52, 79, 5, 14, 17, 3, 2, 2, 11, 3, 4, 6, 3, 1, 8, 2, 23, 4, 5, 8, 10, 4, 2, 7, 3, 5, 1, 1, 6, 3, 1, 2, 2, 2, 5, 28, 1, 1, 7, 7, 20, 5, 3, 29, 3, 17, 26, 1, 8, 4,
		27, 3, 6, 11, 23, 5, 3, 4, 6, 13, 24, 16, 6, 5, 10, 25, 35, 7, 3, 2, 3, 3, 14, 3, 6, 2, 6, 1, 4, 2, 3, 8, 2, 1, 1, 3, 3, 3, 4, 1, 1, 13, 2, 2, 4, 5, 2, 1, 14, 14, 1, 2, 2, 1, 4, 5, 2, 3, 1, 14, 3, 12,
		3, 17, 2, 16, 5, 1, 2, 1, 8, 9, 3, 19, 4, 2, 2, 4, 17, 25, 21, 20, 28, 75, 1, 10, 29, 103, 4, 1, 2, 1, 1, 4, 2, 4, 1, 2, 3, 24, 2, 2, 2, 1, 1, 2, 1, 3, 8, 1, 1, 1, 2, 1, 1, 3, 1, 1, 1, 6, 1, 5, 3, 1, 1,
		1, 3, 4, 1, 1, 5, 2, 1, 5, 6, 13, 9, 16, 1, 1, 1, 1, 3, 2, 3, 2, 4, 5, 2, 5, 2, 2, 3, 7, 13, 7, 2, 2, 1, 1, 1, 1, 2, 3, 3, 2, 1, 6, 4, 9, 2, 1, 14, 2, 14, 2, 1, 18, 3, 4, 14, 4, 11, 41, 15, 23, 15, 23,
		176, 1, 3, 4, 1, 1, 1, 1, 5, 3, 1, 2, 3, 7, 3, 1, 1, 2, 1, 2, 4, 4, 6, 2, 4, 1, 9, 7, 1, 10, 5, 8, 16, 29, 1, 1, 2, 2, 3, 1, 3, 5, 2, 4, 5, 4, 1, 1, 2, 2, 3, 3, 7, 1, 6, 10, 1, 17, 1, 44, 4, 6, 2, 1, 1, 6,
		5, 4, 2, 10, 1, 6, 9, 2, 8, 1, 24, 1, 2, 13, 7, 8, 8, 2, 1, 4, 1, 3, 1, 3, 3, 5, 2, 5, 10, 9, 4, 9, 12, 2, 1, 6, 1, 10, 1, 1, 7, 7, 4, 10, 8, 3, 1, 13, 4, 3, 1, 6, 1, 3, 5, 2, 1, 2, 17, 16, 5, 2, 16, 6,
		1, 4, 2, 1, 3, 3, 6, 8, 5, 11, 11, 1, 3, 3, 2, 4, 6, 10, 9, 5, 7, 4, 7, 4, 7, 1, 1, 4, 2, 1, 3, 6, 8, 7, 1, 6, 11, 5, 5, 3, 24, 9, 4, 2, 7, 13, 5, 1, 8, 82, 16, 61, 1, 1, 1, 4, 2, 2, 16, 10, 3, 8, 1, 1,
		6, 4, 2, 1, 3, 1, 1, 1, 4, 3, 8, 4, 2, 2, 1, 1, 1, 1, 1, 6, 3, 5, 1, 1, 4, 6, 9, 2, 1, 1, 1, 2, 1, 7, 2, 1, 6, 1, 5, 4, 4, 3, 1, 8, 1, 3, 3, 1, 3, 2, 2, 2, 2, 3, 1, 6, 1, 2, 1, 2, 1, 3, 7, 1, 8, 2, 1, 2, 1, 5,
		2, 5, 3, 5, 10, 1, 2, 1, 1, 3, 2, 5, 11, 3, 9, 3, 5, 1, 1, 5, 9, 1, 2, 1, 5, 7, 9, 9, 8, 1, 3, 3, 3, 6, 8, 2, 3, 2, 1, 1, 32, 6, 1, 2, 15, 9, 3, 7, 13, 1, 3, 10, 13, 2, 14, 1, 13, 10, 2, 1, 3, 10, 4, 15,
		2, 15, 15, 10, 1, 3, 9, 6, 9, 32, 25, 26, 47, 7, 3, 2, 3, 1, 6, 3, 4, 3, 2, 8, 5, 4, 1, 9, 4, 2, 2, 19, 10, 6, 2, 3, 8, 1, 2, 2, 4, 2, 1, 9, 4, 4, 4, 6, 4, 8, 9, 2, 3, 1, 1, 1, 1, 3, 5, 5, 1, 3, 8, 4, 6,
		2, 1, 4, 12, 1, 5, 3, 7, 13, 2, 5, 8, 1, 6, 1, 2, 5, 14, 6, 1, 5, 2, 4, 8, 15, 5, 1, 23, 6, 62, 2, 10, 1, 1, 8, 1, 2, 2, 10, 4, 2, 2, 9, 2, 1, 1, 3, 2, 3, 1, 5, 3, 3, 2, 1, 3, 8, 1, 1, 1, 11, 3, 1, 1, 4,
		3, 7, 1, 14, 1, 2, 3, 12, 5, 2, 5, 1, 6, 7, 5, 7, 14, 11, 1, 3, 1, 8, 9, 12, 2, 1, 11, 8, 4, 4, 2, 6, 10, 9, 13, 1, 1, 3, 1, 5, 1, 3, 2, 4, 4, 1, 18, 2, 3, 14, 11, 4, 29, 4, 2, 7, 1, 3, 13, 9, 2, 2, 5,
		3, 5, 20, 7, 16, 8, 5, 72, 34, 6, 4, 22, 12, 12, 28, 45, 36, 9, 7, 39, 9, 191, 1, 1, 1, 4, 11, 8, 4, 9, 2, 3, 22, 1, 1, 1, 1, 4, 17, 1, 7, 7, 1, 11, 31, 10, 2, 4, 8, 2, 3, 2, 1, 4, 2, 16, 4, 32, 2,
		3, 19, 13, 4, 9, 1, 5, 2, 14, 8, 1, 1, 3, 6, 19, 6, 5, 1, 16, 6, 2, 10, 8, 5, 1, 2, 3, 1, 5, 5, 1, 11, 6, 6, 1, 3, 3, 2, 6, 3, 8, 1, 1, 4, 10, 7, 5, 7, 7, 5, 8, 9, 2, 1, 3, 4, 1, 1, 3, 1, 3, 3, 2, 6, 16,
		1, 4, 6, 3, 1, 10, 6, 1, 3, 15, 2, 9, 2, 10, 25, 13, 9, 16, 6, 2, 2, 10, 11, 4, 3, 9, 1, 2, 6, 6, 5, 4, 30, 40, 1, 10, 7, 12, 14, 33, 6, 3, 6, 7, 3, 1, 3, 1, 11, 14, 4, 9, 5, 12, 11, 49, 18, 51, 31,
		140, 31, 2, 2, 1, 5, 1, 8, 1, 10, 1, 4, 4, 3, 24, 1, 10, 1, 3, 6, 6, 16, 3, 4, 5, 2, 1, 4, 2, 57, 10, 6, 22, 2, 22, 3, 7, 22, 6, 10, 11, 36, 18, 16, 33, 36, 2, 5, 5, 1, 1, 1, 4, 10, 1, 4, 13, 2, 7,
		5, 2, 9, 3, 4, 1, 7, 43, 3, 7, 3, 9, 14, 7, 9, 1, 11, 1, 1, 3, 7, 4, 18, 13, 1, 14, 1, 3, 6, 10, 73, 2, 2, 30, 6, 1, 11, 18, 19, 13, 22, 3, 46, 42, 37, 89, 7, 3, 16, 34, 2, 2, 3, 9, 1, 7, 1, 1, 1, 2,
		2, 4, 10, 7, 3, 10, 3, 9, 5, 28, 9, 2, 6, 13, 7, 3, 1, 3, 10, 2, 7, 2, 11, 3, 6, 21, 54, 85, 2, 1, 4, 2, 2, 1, 39, 3, 21, 2, 2, 5, 1, 1, 1, 4, 1, 1, 3, 4, 15, 1, 3, 2, 4, 4, 2, 3, 8, 2, 20, 1, 8, 7, 13,
		4, 1, 26, 6, 2, 9, 34, 4, 21, 52, 10, 4, 4, 1, 5, 12, 2, 11, 1, 7, 2, 30, 12, 44, 2, 30, 1, 1, 3, 6, 16, 9, 17, 39, 82, 2, 2, 24, 7, 1, 7, 3, 16, 9, 14, 44, 2, 1, 2, 1, 2, 3, 5, 2, 4, 1, 6, 7, 5, 3,
		2, 6, 1, 11, 5, 11, 2, 1, 18, 19, 8, 1, 3, 24, 29, 2, 1, 3, 5, 2, 2, 1, 13, 6, 5, 1, 46, 11, 3, 5, 1, 1, 5, 8, 2, 10, 6, 12, 6, 3, 7, 11, 2, 4, 16, 13, 2, 5, 1, 1, 2, 2, 5, 2, 28, 5, 2, 23, 10, 8, 4,
		4, 22, 39, 95, 38, 8, 14, 9, 5, 1, 13, 5, 4, 3, 13, 12, 11, 1, 9, 1, 27, 37, 2, 5, 4, 4, 63, 211, 95, 2, 2, 2, 1, 3, 5, 2, 1, 1, 2, 2, 1, 1, 1, 3, 2, 4, 1, 2, 1, 1, 5, 2, 2, 1, 1, 2, 3, 1, 3, 1, 1, 1,
		3, 1, 4, 2, 1, 3, 6, 1, 1, 3, 7, 15, 5, 3, 2, 5, 3, 9, 11, 4, 2, 22, 1, 6, 3, 8, 7, 1, 4, 28, 4, 16, 3, 3, 25, 4, 4, 27, 27, 1, 4, 1, 2, 2, 7, 1, 3, 5, 2, 28, 8, 2, 14, 1, 8, 6, 16, 25, 3, 3, 3, 14, 3,
		3, 1, 1, 2, 1, 4, 6, 3, 8, 4, 1, 1, 1, 2, 3, 6, 10, 6, 2, 3, 18, 3, 2, 5, 5, 4, 3, 1, 5, 2, 5, 4, 23, 7, 6, 12, 6, 4, 17, 11, 9, 5, 1, 1, 10, 5, 12, 1, 1, 11, 26, 33, 7, 3, 6, 1, 17, 7, 1, 5, 12, 1, 11,
		2, 4, 1, 8, 14, 17, 23, 1, 2, 1, 7, 8, 16, 11, 9, 6, 5, 2, 6, 4, 16, 2, 8, 14, 1, 11, 8, 9, 1, 1, 1, 9, 25, 4, 11, 19, 7, 2, 15, 2, 12, 8, 52, 7, 5, 19, 2, 16, 4, 36, 8, 1, 16, 8, 24, 26, 4, 6, 2, 9,
		5, 4, 36, 3, 28, 12, 25, 15, 37, 27, 17, 12, 59, 38, 5, 32, 127, 1, 2, 9, 17, 14, 4, 1, 2, 1, 1, 8, 11, 50, 4, 14, 2, 19, 16, 4, 17, 5, 4, 5, 26, 12, 45, 2, 23, 45, 104, 30, 12, 8, 3, 10, 2, 2,
		3, 3, 1, 4, 20, 7, 2, 9, 6, 15, 2, 20, 1, 3, 16, 4, 11, 15, 6, 134, 2, 5, 59, 1, 2, 2, 2, 1, 9, 17, 3, 26, 137, 10, 211, 59, 1, 2, 4, 1, 4, 1, 1, 1, 2, 6, 2, 3, 1, 1, 2, 3, 2, 3, 1, 3, 4, 4, 2, 3, 3,
		1, 4, 3, 1, 7, 2, 2, 3, 1, 2, 1, 3, 3, 3, 2, 2, 3, 2, 1, 3, 14, 6, 1, 3, 2, 9, 6, 15, 27, 9, 34, 145, 1, 1, 2, 1, 1, 1, 1, 2, 1, 1, 1, 1, 2, 2, 2, 3, 1, 2, 1, 1, 1, 2, 3, 5, 8, 3, 5, 2, 4, 1, 3, 2, 2, 2, 12,
		4, 1, 1, 1, 10, 4, 5, 1, 20, 4, 16, 1, 15, 9, 5, 12, 2, 9, 2, 5, 4, 2, 26, 19, 7, 1, 26, 4, 30, 12, 15, 42, 1, 6, 8, 172, 1, 1, 4, 2, 1, 1, 11, 2, 2, 4, 2, 1, 2, 1, 10, 8, 1, 2, 1, 4, 5, 1, 2, 5, 1, 8,
		4, 1, 3, 4, 2, 1, 6, 2, 1, 3, 4, 1, 2, 1, 1, 1, 1, 12, 5, 7, 2, 4, 3, 1, 1, 1, 3, 3, 6, 1, 2, 2, 3, 3, 3, 2, 1, 2, 12, 14, 11, 6, 6, 4, 12, 2, 8, 1, 7, 10, 1, 35, 7, 4, 13, 15, 4, 3, 23, 21, 28, 52, 5,
		26, 5, 6, 1, 7, 10, 2, 7, 53, 3, 2, 1, 1, 1, 2, 163, 532, 1, 10, 11, 1, 3, 3, 4, 8, 2, 8, 6, 2, 2, 23, 22, 4, 2, 2, 4, 2, 1, 3, 1, 3, 3, 5, 9, 8, 2, 1, 2, 8, 1, 10, 2, 12, 21, 20, 15, 105, 2, 3, 1, 1,
		3, 2, 3, 1, 1, 2, 5, 1, 4, 15, 11, 19, 1, 1, 1, 1, 5, 4, 5, 1, 1, 2, 5, 3, 5, 12, 1, 2, 5, 1, 11, 1, 1, 15, 9, 1, 4, 5, 3, 26, 8, 2, 1, 3, 1, 1, 15, 19, 2, 12, 1, 2, 5, 2, 7, 2, 19, 2, 20, 6, 26, 7, 5,
		2, 2, 7, 34, 21, 13, 70, 2, 128, 1, 1, 2, 1, 1, 2, 1, 1, 3, 2, 2, 2, 15, 1, 4, 1, 3, 4, 42, 10, 6, 1, 49, 85, 8, 1, 2, 1, 1, 4, 4, 2, 3, 6, 1, 5, 7, 4, 3, 211, 4, 1, 2, 1, 2, 5, 1, 2, 4, 2, 2, 6, 5, 6,
		10, 3, 4, 48, 100, 6, 2, 16, 296, 5, 27, 387, 2, 2, 3, 7, 16, 8, 5, 38, 15, 39, 21, 9, 10, 3, 7, 59, 13, 27, 21, 47, 5, 21, 6,
	}
	@(static) base_ranges := [?]ImWchar {
		0x0020, 0x00FF, // Basic Latin + Latin Supplement
		0x2000, 0x206F, // General Punctuation
		0x3000, 0x30FF, // CJK Symbols and Punctuations, Hiragana, Katakana
		0x31F0, 0x31FF, // Katakana Phonetic Extensions
		0xFF00, 0xFFEF, // Half-width characters
		0xFFFD, 0xFFFD, // Invalid
	}
	@(static) full_ranges : [len(base_ranges) + len(accumulative_offsets_from_0x4E00) * 2 + 1]ImWchar = {}
	if full_ranges[0] == {} {
		memcpy(raw_data(&full_ranges), raw_data(&base_ranges), size_of(base_ranges))
		UnpackAccumulativeOffsetsIntoRanges(0x4E00, accumulative_offsets_from_0x4E00[:], raw_data(&full_ranges)[len(base_ranges):])
	}
	return raw_data(&full_ranges)
}

// Default + Hiragana, Katakana, Half-Width, Selection of 2999 Ideographs
ImFontAtlas_GetGlyphRangesJapanese :: proc(this : ^ImFontAtlas) -> [^]ImWchar
{
	// 2999 ideograms code points for Japanese
	// - 2136 Joyo (meaning "for regular use" or "for common use") Kanji code points
	// - 863 Jinmeiyo (meaning "for personal name") Kanji code points
	// - Sourced from official information provided by the government agencies of Japan:
	//   - List of Joyo Kanji by the Agency for Cultural Affairs
	//     - https://www.bunka.go.jp/kokugo_nihongo/sisaku/joho/joho/kijun/naikaku/kanji/
	//   - List of Jinmeiyo Kanji by the Ministry of Justice
	//     - http://www.moj.go.jp/MINJI/minji86.html
	//   - Available under the terms of the Creative Commons Attribution 4.0 International (CC BY 4.0).
	//     - https://creativecommons.org/licenses/by/4.0/legalcode
	// - You can generate this code by the script at:
	//   - https://github.com/vaiorabbit/everyday_use_kanji
	// - References:
	//   - List of Joyo Kanji
	//     - (Wikipedia) https://en.wikipedia.org/wiki/List_of_j%C5%8Dy%C5%8D_kanji
	//   - List of Jinmeiyo Kanji
	//     - (Wikipedia) https://en.wikipedia.org/wiki/Jinmeiy%C5%8D_kanji
	// - Missing 1 Joyo Kanji: U+20B9F (Kun'yomi: Shikaru, On'yomi: Shitsu,shichi), see https://github.com/ocornut/imgui/pull/3627 for details.
	// You can use ImFontGlyphRangesBuilder to create your own ranges derived from this, by merging existing ranges or adding new characters.
	// (Stored as accumulative offsets from the initial unicode codepoint 0x4E00. This encoding is designed to helps us compact the source code size.)
	@(static) accumulative_offsets_from_0x4E00 := [?]i16 {
		0, 1, 2, 4, 1, 1, 1, 1, 2, 1, 3, 3, 2, 2, 1, 5, 3, 5, 7, 5, 6, 1, 2, 1, 7, 2, 6, 3, 1, 8, 1, 1, 4, 1, 1, 18, 2, 11, 2, 6, 2, 1, 2, 1, 5, 1, 2, 1, 3, 1, 2, 1, 2, 3, 3, 1, 1, 2, 3, 1, 1, 1, 12, 7, 9, 1, 4, 5, 1,
		1, 2, 1, 10, 1, 1, 9, 2, 2, 4, 5, 6, 9, 3, 1, 1, 1, 1, 9, 3, 18, 5, 2, 2, 2, 2, 1, 6, 3, 7, 1, 1, 1, 1, 2, 2, 4, 2, 1, 23, 2, 10, 4, 3, 5, 2, 4, 10, 2, 4, 13, 1, 6, 1, 9, 3, 1, 1, 6, 6, 7, 6, 3, 1, 2, 11, 3,
		2, 2, 3, 2, 15, 2, 2, 5, 4, 3, 6, 4, 1, 2, 5, 2, 12, 16, 6, 13, 9, 13, 2, 1, 1, 7, 16, 4, 7, 1, 19, 1, 5, 1, 2, 2, 7, 7, 8, 2, 6, 5, 4, 9, 18, 7, 4, 5, 9, 13, 11, 8, 15, 2, 1, 1, 1, 2, 1, 2, 2, 1, 2, 2, 8,
		2, 9, 3, 3, 1, 1, 4, 4, 1, 1, 1, 4, 9, 1, 4, 3, 5, 5, 2, 7, 5, 3, 4, 8, 2, 1, 13, 2, 3, 3, 1, 14, 1, 1, 4, 5, 1, 3, 6, 1, 5, 2, 1, 1, 3, 3, 3, 3, 1, 1, 2, 7, 6, 6, 7, 1, 4, 7, 6, 1, 1, 1, 1, 1, 12, 3, 3, 9, 5,
		2, 6, 1, 5, 6, 1, 2, 3, 18, 2, 4, 14, 4, 1, 3, 6, 1, 1, 6, 3, 5, 5, 3, 2, 2, 2, 2, 12, 3, 1, 4, 2, 3, 2, 3, 11, 1, 7, 4, 1, 2, 1, 3, 17, 1, 9, 1, 24, 1, 1, 4, 2, 2, 4, 1, 2, 7, 1, 1, 1, 3, 1, 2, 2, 4, 15, 1,
		1, 2, 1, 1, 2, 1, 5, 2, 5, 20, 2, 5, 9, 1, 10, 8, 7, 6, 1, 1, 1, 1, 1, 1, 6, 2, 1, 2, 8, 1, 1, 1, 1, 5, 1, 1, 3, 1, 1, 1, 1, 3, 1, 1, 12, 4, 1, 3, 1, 1, 1, 1, 1, 10, 3, 1, 7, 5, 13, 1, 2, 3, 4, 6, 1, 1, 30,
		2, 9, 9, 1, 15, 38, 11, 3, 1, 8, 24, 7, 1, 9, 8, 10, 2, 1, 9, 31, 2, 13, 6, 2, 9, 4, 49, 5, 2, 15, 2, 1, 10, 2, 1, 1, 1, 2, 2, 6, 15, 30, 35, 3, 14, 18, 8, 1, 16, 10, 28, 12, 19, 45, 38, 1, 3, 2, 3,
		13, 2, 1, 7, 3, 6, 5, 3, 4, 3, 1, 5, 7, 8, 1, 5, 3, 18, 5, 3, 6, 1, 21, 4, 24, 9, 24, 40, 3, 14, 3, 21, 3, 2, 1, 2, 4, 2, 3, 1, 15, 15, 6, 5, 1, 1, 3, 1, 5, 6, 1, 9, 7, 3, 3, 2, 1, 4, 3, 8, 21, 5, 16, 4,
		5, 2, 10, 11, 11, 3, 6, 3, 2, 9, 3, 6, 13, 1, 2, 1, 1, 1, 1, 11, 12, 6, 6, 1, 4, 2, 6, 5, 2, 1, 1, 3, 3, 6, 13, 3, 1, 1, 5, 1, 2, 3, 3, 14, 2, 1, 2, 2, 2, 5, 1, 9, 5, 1, 1, 6, 12, 3, 12, 3, 4, 13, 2, 14,
		2, 8, 1, 17, 5, 1, 16, 4, 2, 2, 21, 8, 9, 6, 23, 20, 12, 25, 19, 9, 38, 8, 3, 21, 40, 25, 33, 13, 4, 3, 1, 4, 1, 2, 4, 1, 2, 5, 26, 2, 1, 1, 2, 1, 3, 6, 2, 1, 1, 1, 1, 1, 1, 2, 3, 1, 1, 1, 9, 2, 3, 1, 1,
		1, 3, 6, 3, 2, 1, 1, 6, 6, 1, 8, 2, 2, 2, 1, 4, 1, 2, 3, 2, 7, 3, 2, 4, 1, 2, 1, 2, 2, 1, 1, 1, 1, 1, 3, 1, 2, 5, 4, 10, 9, 4, 9, 1, 1, 1, 1, 1, 1, 5, 3, 2, 1, 6, 4, 9, 6, 1, 10, 2, 31, 17, 8, 3, 7, 5, 40, 1,
		7, 7, 1, 6, 5, 2, 10, 7, 8, 4, 15, 39, 25, 6, 28, 47, 18, 10, 7, 1, 3, 1, 1, 2, 1, 1, 1, 3, 3, 3, 1, 1, 1, 3, 4, 2, 1, 4, 1, 3, 6, 10, 7, 8, 6, 2, 2, 1, 3, 3, 2, 5, 8, 7, 9, 12, 2, 15, 1, 1, 4, 1, 2, 1, 1,
		1, 3, 2, 1, 3, 3, 5, 6, 2, 3, 2, 10, 1, 4, 2, 8, 1, 1, 1, 11, 6, 1, 21, 4, 16, 3, 1, 3, 1, 4, 2, 3, 6, 5, 1, 3, 1, 1, 3, 3, 4, 6, 1, 1, 10, 4, 2, 7, 10, 4, 7, 4, 2, 9, 4, 3, 1, 1, 1, 4, 1, 8, 3, 4, 1, 3, 1,
		6, 1, 4, 2, 1, 4, 7, 2, 1, 8, 1, 4, 5, 1, 1, 2, 2, 4, 6, 2, 7, 1, 10, 1, 1, 3, 4, 11, 10, 8, 21, 4, 6, 1, 3, 5, 2, 1, 2, 28, 5, 5, 2, 3, 13, 1, 2, 3, 1, 4, 2, 1, 5, 20, 3, 8, 11, 1, 3, 3, 3, 1, 8, 10, 9, 2,
		10, 9, 2, 3, 1, 1, 2, 4, 1, 8, 3, 6, 1, 7, 8, 6, 11, 1, 4, 29, 8, 4, 3, 1, 2, 7, 13, 1, 4, 1, 6, 2, 6, 12, 12, 2, 20, 3, 2, 3, 6, 4, 8, 9, 2, 7, 34, 5, 1, 18, 6, 1, 1, 4, 4, 5, 7, 9, 1, 2, 2, 4, 3, 4, 1, 7,
		2, 2, 2, 6, 2, 3, 25, 5, 3, 6, 1, 4, 6, 7, 4, 2, 1, 4, 2, 13, 6, 4, 4, 3, 1, 5, 3, 4, 4, 3, 2, 1, 1, 4, 1, 2, 1, 1, 3, 1, 11, 1, 6, 3, 1, 7, 3, 6, 2, 8, 8, 6, 9, 3, 4, 11, 3, 2, 10, 12, 2, 5, 11, 1, 6, 4, 5,
		3, 1, 8, 5, 4, 6, 6, 3, 5, 1, 1, 3, 2, 1, 2, 2, 6, 17, 12, 1, 10, 1, 6, 12, 1, 6, 6, 19, 9, 6, 16, 1, 13, 4, 4, 15, 7, 17, 6, 11, 9, 15, 12, 6, 7, 2, 1, 2, 2, 15, 9, 3, 21, 4, 6, 49, 18, 7, 3, 2, 3, 1,
		6, 8, 2, 2, 6, 2, 9, 1, 3, 6, 4, 4, 1, 2, 16, 2, 5, 2, 1, 6, 2, 3, 5, 3, 1, 2, 5, 1, 2, 1, 9, 3, 1, 8, 6, 4, 8, 11, 3, 1, 1, 1, 1, 3, 1, 13, 8, 4, 1, 3, 2, 2, 1, 4, 1, 11, 1, 5, 2, 1, 5, 2, 5, 8, 6, 1, 1, 7,
		4, 3, 8, 3, 2, 7, 2, 1, 5, 1, 5, 2, 4, 7, 6, 2, 8, 5, 1, 11, 4, 5, 3, 6, 18, 1, 2, 13, 3, 3, 1, 21, 1, 1, 4, 1, 4, 1, 1, 1, 8, 1, 2, 2, 7, 1, 2, 4, 2, 2, 9, 2, 1, 1, 1, 4, 3, 6, 3, 12, 5, 1, 1, 1, 5, 6, 3, 2,
		4, 8, 2, 2, 4, 2, 7, 1, 8, 9, 5, 2, 3, 2, 1, 3, 2, 13, 7, 14, 6, 5, 1, 1, 2, 1, 4, 2, 23, 2, 1, 1, 6, 3, 1, 4, 1, 15, 3, 1, 7, 3, 9, 14, 1, 3, 1, 4, 1, 1, 5, 8, 1, 3, 8, 3, 8, 15, 11, 4, 14, 4, 4, 2, 5, 5,
		1, 7, 1, 6, 14, 7, 7, 8, 5, 15, 4, 8, 6, 5, 6, 2, 1, 13, 1, 20, 15, 11, 9, 2, 5, 6, 2, 11, 2, 6, 2, 5, 1, 5, 8, 4, 13, 19, 25, 4, 1, 1, 11, 1, 34, 2, 5, 9, 14, 6, 2, 2, 6, 1, 1, 14, 1, 3, 14, 13, 1, 6,
		12, 21, 14, 14, 6, 32, 17, 8, 32, 9, 28, 1, 2, 4, 11, 8, 3, 1, 14, 2, 5, 15, 1, 1, 1, 1, 3, 6, 4, 1, 3, 4, 11, 3, 1, 1, 11, 30, 1, 5, 1, 4, 1, 5, 8, 1, 1, 3, 2, 4, 3, 17, 35, 2, 6, 12, 17, 3, 1, 6, 2,
		1, 1, 12, 2, 7, 3, 3, 2, 1, 16, 2, 8, 3, 6, 5, 4, 7, 3, 3, 8, 1, 9, 8, 5, 1, 2, 1, 3, 2, 8, 1, 2, 9, 12, 1, 1, 2, 3, 8, 3, 24, 12, 4, 3, 7, 5, 8, 3, 3, 3, 3, 3, 3, 1, 23, 10, 3, 1, 2, 2, 6, 3, 1, 16, 1, 16,
		22, 3, 10, 4, 11, 6, 9, 7, 7, 3, 6, 2, 2, 2, 4, 10, 2, 1, 1, 2, 8, 7, 1, 6, 4, 1, 3, 3, 3, 5, 10, 12, 12, 2, 3, 12, 8, 15, 1, 1, 16, 6, 6, 1, 5, 9, 11, 4, 11, 4, 2, 6, 12, 1, 17, 5, 13, 1, 4, 9, 5, 1, 11,
		2, 1, 8, 1, 5, 7, 28, 8, 3, 5, 10, 2, 17, 3, 38, 22, 1, 2, 18, 12, 10, 4, 38, 18, 1, 4, 44, 19, 4, 1, 8, 4, 1, 12, 1, 4, 31, 12, 1, 14, 7, 75, 7, 5, 10, 6, 6, 13, 3, 2, 11, 11, 3, 2, 5, 28, 15, 6, 18,
		18, 5, 6, 4, 3, 16, 1, 7, 18, 7, 36, 3, 5, 3, 1, 7, 1, 9, 1, 10, 7, 2, 4, 2, 6, 2, 9, 7, 4, 3, 32, 12, 3, 7, 10, 2, 23, 16, 3, 1, 12, 3, 31, 4, 11, 1, 3, 8, 9, 5, 1, 30, 15, 6, 12, 3, 2, 2, 11, 19, 9,
		14, 2, 6, 2, 3, 19, 13, 17, 5, 3, 3, 25, 3, 14, 1, 1, 1, 36, 1, 3, 2, 19, 3, 13, 36, 9, 13, 31, 6, 4, 16, 34, 2, 5, 4, 2, 3, 3, 5, 1, 1, 1, 4, 3, 1, 17, 3, 2, 3, 5, 3, 1, 3, 2, 3, 5, 6, 3, 12, 11, 1, 3,
		1, 2, 26, 7, 12, 7, 2, 14, 3, 3, 7, 7, 11, 25, 25, 28, 16, 4, 36, 1, 2, 1, 6, 2, 1, 9, 3, 27, 17, 4, 3, 4, 13, 4, 1, 3, 2, 2, 1, 10, 4, 2, 4, 6, 3, 8, 2, 1, 18, 1, 1, 24, 2, 2, 4, 33, 2, 3, 63, 7, 1, 6,
		40, 7, 3, 4, 4, 2, 4, 15, 18, 1, 16, 1, 1, 11, 2, 41, 14, 1, 3, 18, 13, 3, 2, 4, 16, 2, 17, 7, 15, 24, 7, 18, 13, 44, 2, 2, 3, 6, 1, 1, 7, 5, 1, 7, 1, 4, 3, 3, 5, 10, 8, 2, 3, 1, 8, 1, 1, 27, 4, 2, 1,
		12, 1, 2, 1, 10, 6, 1, 6, 7, 5, 2, 3, 7, 11, 5, 11, 3, 6, 6, 2, 3, 15, 4, 9, 1, 1, 2, 1, 2, 11, 2, 8, 12, 8, 5, 4, 2, 3, 1, 5, 2, 2, 1, 14, 1, 12, 11, 4, 1, 11, 17, 17, 4, 3, 2, 5, 5, 7, 3, 1, 5, 9, 9, 8,
		2, 5, 6, 6, 13, 13, 2, 1, 2, 6, 1, 2, 2, 49, 4, 9, 1, 2, 10, 16, 7, 8, 4, 3, 2, 23, 4, 58, 3, 29, 1, 14, 19, 19, 11, 11, 2, 7, 5, 1, 3, 4, 6, 2, 18, 5, 12, 12, 17, 17, 3, 3, 2, 4, 1, 6, 2, 3, 4, 3, 1,
		1, 1, 1, 5, 1, 1, 9, 1, 3, 1, 3, 6, 1, 8, 1, 1, 2, 6, 4, 14, 3, 1, 4, 11, 4, 1, 3, 32, 1, 2, 4, 13, 4, 1, 2, 4, 2, 1, 3, 1, 11, 1, 4, 2, 1, 4, 4, 6, 3, 5, 1, 6, 5, 7, 6, 3, 23, 3, 5, 3, 5, 3, 3, 13, 3, 9, 10,
		1, 12, 10, 2, 3, 18, 13, 7, 160, 52, 4, 2, 2, 3, 2, 14, 5, 4, 12, 4, 6, 4, 1, 20, 4, 11, 6, 2, 12, 27, 1, 4, 1, 2, 2, 7, 4, 5, 2, 28, 3, 7, 25, 8, 3, 19, 3, 6, 10, 2, 2, 1, 10, 2, 5, 4, 1, 3, 4, 1, 5,
		3, 2, 6, 9, 3, 6, 2, 16, 3, 3, 16, 4, 5, 5, 3, 2, 1, 2, 16, 15, 8, 2, 6, 21, 2, 4, 1, 22, 5, 8, 1, 1, 21, 11, 2, 1, 11, 11, 19, 13, 12, 4, 2, 3, 2, 3, 6, 1, 8, 11, 1, 4, 2, 9, 5, 2, 1, 11, 2, 9, 1, 1, 2,
		14, 31, 9, 3, 4, 21, 14, 4, 8, 1, 7, 2, 2, 2, 5, 1, 4, 20, 3, 3, 4, 10, 1, 11, 9, 8, 2, 1, 4, 5, 14, 12, 14, 2, 17, 9, 6, 31, 4, 14, 1, 20, 13, 26, 5, 2, 7, 3, 6, 13, 2, 4, 2, 19, 6, 2, 2, 18, 9, 3, 5,
		12, 12, 14, 4, 6, 2, 3, 6, 9, 5, 22, 4, 5, 25, 6, 4, 8, 5, 2, 6, 27, 2, 35, 2, 16, 3, 7, 8, 8, 6, 6, 5, 9, 17, 2, 20, 6, 19, 2, 13, 3, 1, 1, 1, 4, 17, 12, 2, 14, 7, 1, 4, 18, 12, 38, 33, 2, 10, 1, 1,
		2, 13, 14, 17, 11, 50, 6, 33, 20, 26, 74, 16, 23, 45, 50, 13, 38, 33, 6, 6, 7, 4, 4, 2, 1, 3, 2, 5, 8, 7, 8, 9, 3, 11, 21, 9, 13, 1, 3, 10, 6, 7, 1, 2, 2, 18, 5, 5, 1, 9, 9, 2, 68, 9, 19, 13, 2, 5,
		1, 4, 4, 7, 4, 13, 3, 9, 10, 21, 17, 3, 26, 2, 1, 5, 2, 4, 5, 4, 1, 7, 4, 7, 3, 4, 2, 1, 6, 1, 1, 20, 4, 1, 9, 2, 2, 1, 3, 3, 2, 3, 2, 1, 1, 1, 20, 2, 3, 1, 6, 2, 3, 6, 2, 4, 8, 1, 3, 2, 10, 3, 5, 3, 4, 4,
		3, 4, 16, 1, 6, 1, 10, 2, 4, 2, 1, 1, 2, 10, 11, 2, 2, 3, 1, 24, 31, 4, 10, 10, 2, 5, 12, 16, 164, 15, 4, 16, 7, 9, 15, 19, 17, 1, 2, 1, 1, 5, 1, 1, 1, 1, 1, 3, 1, 4, 3, 1, 3, 1, 3, 1, 2, 1, 1, 3, 3, 7,
		2, 8, 1, 2, 2, 2, 1, 3, 4, 3, 7, 8, 12, 92, 2, 10, 3, 1, 3, 14, 5, 25, 16, 42, 4, 7, 7, 4, 2, 21, 5, 27, 26, 27, 21, 25, 30, 31, 2, 1, 5, 13, 3, 22, 5, 6, 6, 11, 9, 12, 1, 5, 9, 7, 5, 5, 22, 60, 3, 5,
		13, 1, 1, 8, 1, 1, 3, 3, 2, 1, 9, 3, 3, 18, 4, 1, 2, 3, 7, 6, 3, 1, 2, 3, 9, 1, 3, 1, 3, 2, 1, 3, 1, 1, 1, 2, 1, 11, 3, 1, 6, 9, 1, 3, 2, 3, 1, 2, 1, 5, 1, 1, 4, 3, 4, 1, 2, 2, 4, 4, 1, 7, 2, 1, 2, 2, 3, 5, 13,
		18, 3, 4, 14, 9, 9, 4, 16, 3, 7, 5, 8, 2, 6, 48, 28, 3, 1, 1, 4, 2, 14, 8, 2, 9, 2, 1, 15, 2, 4, 3, 2, 10, 16, 12, 8, 7, 1, 1, 3, 1, 1, 1, 2, 7, 4, 1, 6, 4, 38, 39, 16, 23, 7, 15, 15, 3, 2, 12, 7, 21,
		37, 27, 6, 5, 4, 8, 2, 10, 8, 8, 6, 5, 1, 2, 1, 3, 24, 1, 16, 17, 9, 23, 10, 17, 6, 1, 51, 55, 44, 13, 294, 9, 3, 6, 2, 4, 2, 2, 15, 1, 1, 1, 13, 21, 17, 68, 14, 8, 9, 4, 1, 4, 9, 3, 11, 7, 1, 1, 1,
		5, 6, 3, 2, 1, 1, 1, 2, 3, 8, 1, 2, 2, 4, 1, 5, 5, 2, 1, 4, 3, 7, 13, 4, 1, 4, 1, 3, 1, 1, 1, 5, 5, 10, 1, 6, 1, 5, 2, 1, 5, 2, 4, 1, 4, 5, 7, 3, 18, 2, 9, 11, 32, 4, 3, 3, 2, 4, 7, 11, 16, 9, 11, 8, 13, 38,
		32, 8, 4, 2, 1, 1, 2, 1, 2, 4, 4, 1, 1, 1, 4, 1, 21, 3, 11, 1, 16, 1, 1, 6, 1, 3, 2, 4, 9, 8, 57, 7, 44, 1, 3, 3, 13, 3, 10, 1, 1, 7, 5, 2, 7, 21, 47, 63, 3, 15, 4, 7, 1, 16, 1, 1, 2, 8, 2, 3, 42, 15, 4,
		1, 29, 7, 22, 10, 3, 78, 16, 12, 20, 18, 4, 67, 11, 5, 1, 3, 15, 6, 21, 31, 32, 27, 18, 13, 71, 35, 5, 142, 4, 10, 1, 2, 50, 19, 33, 16, 35, 37, 16, 19, 27, 7, 1, 133, 19, 1, 4, 8, 7, 20, 1, 4,
		4, 1, 10, 3, 1, 6, 1, 2, 51, 5, 40, 15, 24, 43, 22928, 11, 1, 13, 154, 70, 3, 1, 1, 7, 4, 10, 1, 2, 1, 1, 2, 1, 2, 1, 2, 2, 1, 1, 2, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1,
		3, 2, 1, 1, 1, 1, 2, 1, 1,
	}
	@(static) base_ranges := [?]ImWchar {
		0x0020, 0x00FF, // Basic Latin + Latin Supplement
		0x3000, 0x30FF, // CJK Symbols and Punctuations, Hiragana, Katakana
		0x31F0, 0x31FF, // Katakana Phonetic Extensions
		0xFF00, 0xFFEF, // Half-width characters
		0xFFFD, 0xFFFD, // Invalid
	}
	@(static) full_ranges : [len(base_ranges) + len(accumulative_offsets_from_0x4E00) * 2 + 1]ImWchar = {}
	if full_ranges[0] == {} {
		memcpy(raw_data(&full_ranges), raw_data(&base_ranges), size_of(base_ranges))
		UnpackAccumulativeOffsetsIntoRanges(0x4E00, accumulative_offsets_from_0x4E00[:], raw_data(&full_ranges)[len(base_ranges):])
	}
	return raw_data(&full_ranges)
}

// Default + about 400 Cyrillic characters
ImFontAtlas_GetGlyphRangesCyrillic :: proc(this : ^ImFontAtlas) -> [^]ImWchar
{
	@(static) ranges := [?]ImWchar {
		0x0020, 0x00FF, // Basic Latin + Latin Supplement
		0x0400, 0x052F, // Cyrillic + Cyrillic Supplement
		0x2DE0, 0x2DFF, // Cyrillic Extended-A
		0xA640, 0xA69F, // Cyrillic Extended-B
		0,
	}
	return raw_data(&ranges)
}

// Default + Thai characters
ImFontAtlas_GetGlyphRangesThai :: proc(this : ^ImFontAtlas) -> [^]ImWchar
{
	@(static) ranges := [?]ImWchar {
		0x0020, 0x00FF, // Basic Latin
		0x2010, 0x205E, // Punctuations
		0x0E00, 0x0E7F, // Thai
		0,
	}
	return raw_data(&ranges)
}

// Default + Vietnamese characters
ImFontAtlas_GetGlyphRangesVietnamese :: proc(this : ^ImFontAtlas) -> [^]ImWchar
{
	@(static) ranges := [?]ImWchar {
		0x0020, 0x00FF, // Basic Latin
		0x0102, 0x0103,
		0x0110, 0x0111,
		0x0128, 0x0129,
		0x0168, 0x0169,
		0x01A0, 0x01A1,
		0x01AF, 0x01B0,
		0x1EA0, 0x1EF9,
		0,
	}
	return raw_data(&ranges)
}

// Add string (each character of the UTF-8 string are added)
//-----------------------------------------------------------------------------
// [SECTION] ImFontGlyphRangesBuilder
//-----------------------------------------------------------------------------

ImFontGlyphRangesBuilder_AddText :: proc(this : ^ImFontGlyphRangesBuilder, text : [^]u8, text_end : ^u8 = nil)
{
	text := text
	for text_end != nil ? (cast(^u8)text < text_end) : text[0] != 0 {
		c : u32 = 0
		c_len : i32 = ImTextCharFromUtf8(&c, text, text_end)
		text = text[c_len:]
		if c_len == 0 { break }
		ImFontGlyphRangesBuilder_AddChar(this, cast(ImWchar) c)
	}
}

// Add ranges, e.g. builder.AddRanges(ImFontAtlas::GetGlyphRangesDefault()) to force add all of ASCII/Latin+Ext
ImFontGlyphRangesBuilder_AddRanges :: proc(this : ^ImFontGlyphRangesBuilder, ranges : [^]ImWchar)
{
	for ranges := ranges ; ranges[0] != {}; ranges = ranges[2:] {
		for c := ranges[0]; c <= ranges[1] && c <= IM_UNICODE_CODEPOINT_MAX; c += 1 {
			ImFontGlyphRangesBuilder_AddChar(this, cast(ImWchar) c)
		}
	}
}

// Output new ranges
ImFontGlyphRangesBuilder_BuildRanges :: proc(this : ^ImFontGlyphRangesBuilder, out_ranges : ^ImVector(ImWchar))
{
	max_codepoint : i32 = IM_UNICODE_CODEPOINT_MAX
	for n : i32 = 0; n <= max_codepoint; n += 1 {
		if ImFontGlyphRangesBuilder_GetBit(this, uint(n)) {
			push_back(out_ranges, cast(ImWchar) n)
			for n < max_codepoint && ImFontGlyphRangesBuilder_GetBit(this, uint(n + 1)) { post_incr(&n) }

			push_back(out_ranges, cast(ImWchar) n)
		}
	}

	push_back(out_ranges, 0)
}

//-----------------------------------------------------------------------------
// [SECTION] ImFont
//-----------------------------------------------------------------------------

ImFont_init :: proc(this : ^ImFont)
{
	init(&this.IndexAdvanceX)
	init(&this.IndexLookup)
	init(&this.Glyphs)
	this.FontSize = 0.0
	this.FallbackAdvanceX = 0.0
	this.FallbackChar = 0
	this.EllipsisChar = 0
	this.EllipsisCharStep = 0.0; this.EllipsisWidth = this.EllipsisCharStep
	this.EllipsisCharCount = 0
	this.FallbackGlyph = nil
	this.ContainerAtlas = nil
	this.ConfigData = nil
	this.ConfigDataCount = 0
	this.DirtyLookupTables = false
	this.Scale = 1.0
	this.Descent = 0.0; this.Ascent = this.Descent
	this.MetricsTotalSurface = 0
	memset(raw_data(&this.Used4kPagesMap), 0, size_of(this.Used4kPagesMap))
}

ImFont_deinit :: proc(this : ^ImFont)
{
	ImFont_ClearOutputData(this)
	deinit(&this.IndexAdvanceX)
	deinit(&this.IndexLookup)
	deinit(&this.Glyphs)
}

ImFont_ClearOutputData :: proc(this : ^ImFont)
{
	this.FontSize = 0.0
	this.FallbackAdvanceX = 0.0
	clear(&this.Glyphs)
	clear(&this.IndexAdvanceX)
	clear(&this.IndexLookup)
	this.FallbackGlyph = nil
	this.ContainerAtlas = nil
	this.DirtyLookupTables = true
	this.Descent = 0.0; this.Ascent = this.Descent
	this.MetricsTotalSurface = 0
	memset(raw_data(&this.Used4kPagesMap), 0, size_of(this.Used4kPagesMap))
}

FindFirstExistingGlyph :: proc(font : ^ImFont, candidate_chars : []ImWchar) -> ImWchar
{
	for c in candidate_chars { if FindGlyphNoFallback(font, c) != nil { return c } }
	return 0
}

// [Internal] Don't use!
ImFont_BuildLookupTable :: proc(this : ^ImFont)
{
	max_codepoint : i32 = 0
	for i : i32 = 0; i != this.Glyphs.Size; i += 1 { max_codepoint = ImMax(max_codepoint, cast(i32) this.Glyphs.Data[i].Codepoint) }

	// Build lookup table
	IM_ASSERT(this.Glyphs.Size > 0, "Font has not loaded glyph!")
	IM_ASSERT(this.Glyphs.Size < 0xFFFF); // -1 is reserved
	clear(&this.IndexAdvanceX)
	clear(&this.IndexLookup)
	this.DirtyLookupTables = false
	memset(raw_data(&this.Used4kPagesMap), 0, size_of(this.Used4kPagesMap))
	ImFont_GrowIndex(this, max_codepoint + 1)
	for i : i32 = 0; i < this.Glyphs.Size; i += 1 {
		codepoint := cast(u32) this.Glyphs.Data[i].Codepoint
		this.IndexAdvanceX.Data[codepoint] = this.Glyphs.Data[i].AdvanceX
		this.IndexLookup.Data[codepoint] = cast(ImWchar) i

		// Mark 4K page as used
		page_n := codepoint / 4096
		this.Used4kPagesMap[page_n >> 3] |= 1 << (page_n & 7)
	}

	// Create a glyph to handle TAB
	// FIXME: Needs proper TAB handling but it needs to be contextualized (or we could arbitrary say that each string starts at "column 0" ?)
	if ImFont_FindGlyph(this, cast(ImWchar) ' ') != nil {
		if back(&this.Glyphs).Codepoint != '\t' {
			// So we can call this function multiple times (FIXME: Flaky)
			resize(&this.Glyphs, this.Glyphs.Size + 1)
		}
		tab_glyph : ^ImFontGlyph = back(&this.Glyphs)
		tab_glyph = ImFont_FindGlyph(this, cast(ImWchar) ' ')
		tab_glyph.Codepoint = '\t'
		tab_glyph.AdvanceX *= IM_TABSIZE
		this.IndexAdvanceX.Data[cast(i32) tab_glyph.Codepoint] = cast(f32) tab_glyph.AdvanceX
		this.IndexLookup.Data[cast(i32) tab_glyph.Codepoint] = cast(ImWchar) (this.Glyphs.Size - 1)
	}

	// Mark special glyphs as not visible (note that AddGlyph already mark as non-visible glyphs with zero-size polygons)
	ImFont_SetGlyphVisible(this, cast(ImWchar) ' ', false)
	ImFont_SetGlyphVisible(this, cast(ImWchar) '\t', false)

	// Setup Fallback character
	fallback_chars := [?]ImWchar { IM_UNICODE_CODEPOINT_INVALID, '?', ' '}
	this.FallbackGlyph = ImFont_FindGlyphNoFallback(this, this.FallbackChar)
	if this.FallbackGlyph == nil {
		this.FallbackChar = FindFirstExistingGlyph(this, fallback_chars[:])
		this.FallbackGlyph = ImFont_FindGlyphNoFallback(this, this.FallbackChar)
		if this.FallbackGlyph == nil {
			this.FallbackGlyph = back(&this.Glyphs)
			this.FallbackChar = cast(ImWchar) this.FallbackGlyph.Codepoint
		}
	}
	this.FallbackAdvanceX = this.FallbackGlyph.AdvanceX
	for i : i32 = 0; i < max_codepoint + 1; i += 1 { if this.IndexAdvanceX.Data[i] < 0.0 { this.IndexAdvanceX.Data[i] = this.FallbackAdvanceX } }

	// Setup Ellipsis character. It is required for rendering elided text. We prefer using U+2026 (horizontal ellipsis).
	// However some old fonts may contain ellipsis at U+0085. Here we auto-detect most suitable ellipsis character.
	// FIXME: Note that 0x2026 is rarely included in our font ranges. Because of this we are more likely to use three individual dots.
	ellipsis_chars := [?]ImWchar { this.ConfigData[0].EllipsisChar, 0x2026, 0x0085 }
	dots_chars := [?]ImWchar { '.', 0xFF0E }
	if this.EllipsisChar == {} { this.EllipsisChar = FindFirstExistingGlyph(this, ellipsis_chars[:]) }
	dot_char : ImWchar = FindFirstExistingGlyph(this, dots_chars[:])
	if this.EllipsisChar != {} {
		this.EllipsisCharCount = 1
		this.EllipsisCharStep = ImFont_FindGlyph(this, this.EllipsisChar).X1; this.EllipsisWidth = this.EllipsisCharStep
	}
	else if dot_char != {} {
		dot_glyph : ^ImFontGlyph = ImFont_FindGlyph(this, dot_char)
		this.EllipsisChar = dot_char
		this.EllipsisCharCount = 3
		this.EllipsisCharStep = cast(f32) cast(i32) (dot_glyph.X1 - dot_glyph.X0) + 1.0
		this.EllipsisWidth = ImMax(dot_glyph.AdvanceX, dot_glyph.X0 + this.EllipsisCharStep * 3.0 - 1.0); // FIXME: Slightly odd for normally mono-space fonts but since this is used for trailing contents.
	}
}

// API is designed this way to avoid exposing the 4K page size
// e.g. use with IsGlyphRangeUnused(0, 255)
ImFont_IsGlyphRangeUnused :: proc(this : ^ImFont, c_begin : u32, c_last : u32) -> bool
{
	page_begin : u32 = (c_begin / 4096)
	page_last : u32 = (c_last / 4096)
	for page_n : u32 = page_begin; page_n <= page_last; page_n += 1 { if (page_n >> 3) < size_of(this.Used4kPagesMap) { if (this.Used4kPagesMap[page_n >> 3] & (1 << (page_n & 7))) != 0 { return false } } }

	return true
}

ImFont_SetGlyphVisible :: proc(this : ^ImFont, c : ImWchar, visible : bool)
{
	if glyph : ^ImFontGlyph = cast(^ImFontGlyph) cast(rawptr) ImFont_FindGlyph(this, cast(ImWchar) c); glyph != nil { glyph.Visible = visible ? 1 : 0 }
}

ImFont_GrowIndex :: proc(this : ^ImFont, new_size : i32)
{
	IM_ASSERT(this.IndexAdvanceX.Size == this.IndexLookup.Size)
	if new_size <= this.IndexLookup.Size { return }
	resize(&this.IndexAdvanceX, new_size, -1.0)
	resize(&this.IndexLookup, new_size, ~ImWchar(0))
}

// x0/y0/x1/y1 are offset from the character upper-left layout position, in pixels. Therefore x0/y0 are often fairly close to zero.
// Not to be mistaken with texture coordinates, which are held by u0/v0/u1/v1 in normalized format (0.0..1.0 on each texture axis).
// 'cfg' is not necessarily == 'this->ConfigData' because multiple source fonts+configs can be used to build one target font.
ImFont_AddGlyph :: proc(this : ^ImFont, cfg : ^ImFontConfig, codepoint : ImWchar, x0 : f32, y0 : f32, x1 : f32, y1 : f32, u0 : f32, v0 : f32, u1 : f32, v1 : f32, advance_x : f32)
{

	advance_x, x0, x1 := advance_x, x0, x1

	if cfg != nil {
		// Clamp & recenter if needed
		advance_x_original : f32 = advance_x
		advance_x = ImClamp(advance_x, cfg.GlyphMinAdvanceX, cfg.GlyphMaxAdvanceX)
		if advance_x != advance_x_original {
			char_off_x : f32 = cfg.PixelSnapH ? ImTrunc((advance_x - advance_x_original) * 0.5) : (advance_x - advance_x_original) * 0.5
			x0 += char_off_x
			x1 += char_off_x
		}

		// Snap to pixel
		if cfg.PixelSnapH { advance_x = IM_ROUND(advance_x) }

		// Bake spacing
		advance_x += cfg.GlyphExtraSpacing.x
	}

	glyph_idx : i32 = this.Glyphs.Size
	resize(&this.Glyphs, this.Glyphs.Size + 1)
	glyph : ^ImFontGlyph = &this.Glyphs.Data[glyph_idx]
	glyph.Codepoint = cast(u32) codepoint
	glyph.Visible = (x0 != x1) && (y0 != y1) ? 1 : 0
	glyph.Colored = 0
	glyph.X0 = x0
	glyph.Y0 = y0
	glyph.X1 = x1
	glyph.Y1 = y1
	glyph.U0 = u0
	glyph.V0 = v0
	glyph.U1 = u1
	glyph.V1 = v1
	glyph.AdvanceX = advance_x

	// Compute rough surface usage metrics (+1 to account for average padding, +0.99 to round)
	// We use (U1-U0)*TexWidth instead of X1-X0 to account for oversampling.
	pad : f32 = f32(this.ContainerAtlas.TexGlyphPadding) + 0.99
	this.DirtyLookupTables = true
	this.MetricsTotalSurface += cast(i32) ((glyph.U1 - glyph.U0) * f32(this.ContainerAtlas.TexWidth) + pad) * cast(i32) ((glyph.V1 - glyph.V0) * f32(this.ContainerAtlas.TexHeight) + pad)
}

// Makes 'dst' character/glyph points to 'src' character/glyph. Currently needs to be called AFTER fonts have been built.
ImFont_AddRemapChar :: proc(this : ^ImFont, dst : ImWchar, src : ImWchar, overwrite_dst : bool = true)
{
	IM_ASSERT(this.IndexLookup.Size > 0); // Currently this can only be called AFTER the font has been built, aka after calling ImFontAtlas::GetTexDataAs*() function.
	index_size := cast(ImWchar) this.IndexLookup.Size

	if dst < index_size && this.IndexLookup.Data[dst] == ~ImWchar(0) && !overwrite_dst {
		// 'dst' already exists
		return
	}
	if src >= index_size && dst >= index_size {
		// both 'dst' and 'src' don't exist -> no-op
		return
	}

	ImFont_GrowIndex(this, i32(dst) + 1)
	this.IndexLookup.Data[dst] = (src < index_size) ? this.IndexLookup.Data[src] : ~ImWchar(0)
	this.IndexAdvanceX.Data[dst] = (src < index_size) ? this.IndexAdvanceX.Data[src] : 1.0
}

// Find glyph, return fallback if missing
ImFont_FindGlyph :: proc(this : ^ImFont, c : ImWchar) -> ^ImFontGlyph
{
	if cast(uint) c >= cast(uint) this.IndexLookup.Size { return this.FallbackGlyph }
	i : ImWchar = this.IndexLookup.Data[c]
	if i == ~ImWchar(0) { return this.FallbackGlyph }
	return &this.Glyphs.Data[i]
}

ImFont_FindGlyphNoFallback :: proc(this : ^ImFont, c : ImWchar) -> ^ImFontGlyph
{
	if cast(uint) c >= cast(uint) this.IndexLookup.Size { return nil }
	i : ImWchar = this.IndexLookup.Data[c]
	if i == ~ImWchar(0) { return nil }
	return &this.Glyphs.Data[i]
}

// Trim trailing space and find beginning of next line
CalcWordWrapNextLineStartA :: #force_inline proc(text : [^]u8, text_end : ^u8) -> [^]u8
{
	text := text
	for text < text_end && ImCharIsBlankA(text[0]) { post_incr(&text) }

	if text[0] == '\n' { post_incr(&text) }
	return text
}

ImFontGetCharAdvanceX :: #force_inline proc "contextless" (_FONT : $T0, _CH : $T1) -> f32
{
	return (cast(i32) _CH < _FONT.IndexAdvanceX.Size ? _FONT.IndexAdvanceX.Data[_CH] : _FONT.FallbackAdvanceX)
}


// Simple word-wrapping for English, not full-featured. Please submit failing cases!
// This will return the next location to wrap from. If no wrapping if necessary, this will fast-forward to e.g. text_end.
// FIXME: Much possible improvements (don't cut things like "word !", "word!!!" but cut within "word,,,,", more sensible support for punctuations, support for Unicode punctuations, etc.)
ImFont_CalcWordWrapPositionA :: proc(this : ^ImFont, scale : f32, text : [^]u8, text_end : ^u8, wrap_width : f32) -> ^u8
{
	// For references, possible wrap point marked with ^
	//  "aaa bbb, ccc,ddd. eee   fff. ggg!"
	//      ^    ^    ^   ^   ^__    ^    ^

	// List of hardcoded separators: .,;!?'"

	// Skip extra blanks after a line returns (that includes not counting them in width computation)
	// e.g. "Hello    world" --> "Hello" "World"

	// Cut words that cannot possibly fit within one line.
	// e.g.: "The tropical fish" with ~5 characters worth of width --> "The tr" "opical" "fish"
	line_width : f32 = 0.0
	word_width : f32 = 0.0
	blank_width : f32 = 0.0
	wrap_width := wrap_width; wrap_width /= scale; // We work with unscaled widths to avoid scaling every characters

	word_end : ^u8 = text
	prev_word_end : ^u8 = nil
	inside_word : bool = true

	s : [^]u8 = text
	IM_ASSERT(text_end != nil)
	for s < text_end {
		c : u32 = cast(u32) s[0]
		next_s : ^u8
		if c < 0x80 { next_s = s[1:] }
		else { next_s = s[ImTextCharFromUtf8(&c, s, text_end):] }

		if c < 32 {
			if c == '\n' {
				blank_width = 0.0; word_width = blank_width; line_width = word_width
				inside_word = true
				s = next_s
				continue
			}
			if c == '\r' {
				s = next_s
				continue
			}
		}

		char_width : f32 = ImFontGetCharAdvanceX(this, c)
		if ImCharIsBlankW(c) {
			if inside_word {
				line_width += blank_width
				blank_width = 0.0
				word_end = s
			}
			blank_width += char_width
			inside_word = false
		}
		else {
			word_width += char_width
			if inside_word {
				word_end = next_s
			}
			else {
				prev_word_end = word_end
				line_width += word_width + blank_width
				blank_width = 0.0; word_width = blank_width
			}

			// Allow wrapping after punctuation.
			inside_word = (c != '.' && c != ',' && c != ';' && c != '!' && c != '?' && c != '\"')
		}

		// We ignore blank width at the end of the line (they can be skipped)
		if line_width + word_width > wrap_width {
			// Words that cannot possibly fit within an entire line will be cut anywhere.
			if word_width < wrap_width { s = prev_word_end != nil ? prev_word_end : word_end }
			break
		}

		s = next_s
	}

	// Wrap_width is too small to fit anything. Force displaying 1 character to minimize the height discontinuity.
	// +1 may not be a character start point in UTF-8 but it's ok because caller loops use (text >= word_wrap_eol).
	if s == text && text < text_end { return s[1:] }
	return s
}

// 'max_width' stops rendering after a certain width (could be turned into a 2d size). FLT_MAX to disable.
// 'wrap_width' enable automatic word-wrapping across multiple lines to fit into given width. 0.0f to disable.
// utf8
ImFont_CalcTextSizeA :: proc(this : ^ImFont, size : f32, max_width : f32, wrap_width : f32, text_begin : [^]u8, text_end : ^u8 = nil, remaining : ^int = nil) -> ImVec2
{
	text_end := text_end
	if text_end == nil {
		// FIXME-OPT: Need to avoid this.
		text_end = text_begin[strlen(text_begin):]
	}

	line_height : f32 = size
	scale : f32 = size / this.FontSize

	text_size : ImVec2 = ImVec2{0, 0}
	line_width : f32 = 0.0

	word_wrap_enabled : bool = (wrap_width > 0.0)
	word_wrap_eol : ^u8 = nil

	s : [^]u8 = text_begin
	for s < text_end {
		if word_wrap_enabled {
			// Calculate how far we can render. Requires two passes on the string data but keeps the code simple and not intrusive for what's essentially an uncommon feature.
			if word_wrap_eol == nil { word_wrap_eol = ImFont_CalcWordWrapPositionA(this, scale, s, text_end, wrap_width - line_width) }

			if s >= word_wrap_eol {
				if text_size.x < line_width { text_size.x = line_width }
				text_size.y += line_height
				line_width = 0.0
				word_wrap_eol = nil
				s = CalcWordWrapNextLineStartA(s, text_end); // Wrapping skips upcoming blanks
				continue
			}
		}

		// Decode and advance source
		prev_s : ^u8 = s
		c : u32 = cast(u32) s[0]
		if c < 0x80 { s = s[1:] }
		else { s = s[ImTextCharFromUtf8(&c, s, text_end):] }

		if c < 32 {
			if c == '\n' {
				text_size.x = ImMax(text_size.x, line_width)
				text_size.y += line_height
				line_width = 0.0
				continue
			}
			if c == '\r' { continue }
		}

		char_width : f32 = ImFontGetCharAdvanceX(this, c) * scale
		if line_width + char_width >= max_width {
			s = prev_s
			break
		}

		line_width += char_width
	}

	if text_size.x < line_width { text_size.x = line_width }

	if line_width > 0 || text_size.y == 0.0 { text_size.y += line_height }

	if remaining != nil { remaining^ = mem.ptr_sub(s, text_begin) }

	return text_size
}

// Note: as with every ImDrawList drawing function, this expects that the font atlas texture is bound.
ImFont_RenderChar :: proc(this : ^ImFont, draw_list : ^ImDrawList, size : f32, pos : ImVec2, col : ImU32, c : ImWchar)
{
	col := col
	glyph : ^ImFontGlyph = ImFont_FindGlyph(this, c)
	if glyph == nil || glyph.Visible == 0 { return }
	if glyph.Colored != 0 { col |= ~ImU32(IM_COL32_A_MASK) }
	scale : f32 = (size >= 0.0) ? (size / this.FontSize) : 1.0
	x : f32 = IM_TRUNC(pos.x)
	y : f32 = IM_TRUNC(pos.y)
	PrimReserve(draw_list, 6, 4)
	PrimRectUV(draw_list, ImVec2{x + glyph.X0 * scale, y + glyph.Y0 * scale}, ImVec2{x + glyph.X1 * scale, y + glyph.Y1 * scale}, ImVec2{glyph.U0, glyph.V0}, ImVec2{glyph.U1, glyph.V1}, col)
}

// Note: as with every ImDrawList drawing function, this expects that the font atlas texture is bound.
ImFont_RenderText :: proc(this : ^ImFont, draw_list : ^ImDrawList, size : f32, pos : ImVec2, col : ImU32, clip_rect : ImVec4, text : string, wrap_width : f32 = 0.0, cpu_fine_clip : bool = false)
{
	text_begin := raw_data(text)
	text_end := mem.ptr_offset(cast(^u8)text_begin, len(text))

	// Align to be pixel perfect
	x : f32 = IM_TRUNC(pos.x)
	y : f32 = IM_TRUNC(pos.y)
	if y > clip_rect.w { return }

	scale : f32 = size / this.FontSize
	line_height : f32 = this.FontSize * scale
	origin_x : f32 = x
	word_wrap_enabled : bool = (wrap_width > 0.0)

	// Fast-forward to first visible line
	s : ^u8 = text_begin
	if y + line_height < clip_rect.y {
		for y + line_height < clip_rect.y && s < text_end {
			line_end, _ := ptr_to_first(s, text_end, '\n')
			if word_wrap_enabled {
				// FIXME-OPT: This is not optimal as do first do a search for \n before calling CalcWordWrapPositionA().
				// If the specs for CalcWordWrapPositionA() were reworked to optionally return on \n we could combine both.
				// However it is still better than nothing performing the fast-forward!
				s = ImFont_CalcWordWrapPositionA(this, scale, s, line_end != nil ? line_end : text_end, wrap_width)
				s = CalcWordWrapNextLineStartA(s, text_end)
			}
			else {
				s = line_end != nil ? mem.ptr_offset(line_end, 1) : text_end
			}
			y += line_height
		}
	}

	// For large text, scan for the last visible line in order to avoid over-reserving in the call to PrimReserve()
	// Note that very large horizontal line will still be affected by the issue (e.g. a one megabyte string buffer without a newline will likely crash atm)
	if mem.ptr_sub(text_end, s) > 10000 && !word_wrap_enabled {
		s_end : ^u8 = s
		y_end : f32 = y
		for y_end < clip_rect.w && s_end < text_end {
			s_end, _ = ptr_to_first(s_end, text_end, '\n')
			s_end = s_end != nil ? mem.ptr_offset(s_end, 1) : text_end
			y_end += line_height
		}

		text_end = s_end
	}
	if s == text_end { return }

	// Reserve vertices for remaining worse case (over-reserving is useful and easily amortized)
	vtx_count_max : i32 = cast(i32) mem.ptr_sub(text_end, s) * 4
	idx_count_max : i32 = cast(i32) mem.ptr_sub(text_end, s) * 6
	idx_expected_size : i32 = draw_list.IdxBuffer.Size + idx_count_max
	ImDrawList_PrimReserve(draw_list, idx_count_max, vtx_count_max)
	vtx_write : [^]ImDrawVert = draw_list._VtxWritePtr
	idx_write : [^]ImDrawIdx = draw_list._IdxWritePtr
	vtx_index : u32 = draw_list._VtxCurrentIdx

	col_untinted : ImU32 = col | ~ImU32(IM_COL32_A_MASK)
	word_wrap_eol : ^u8 = nil

	for s < text_end {
		if word_wrap_enabled {
			// Calculate how far we can render. Requires two passes on the string data but keeps the code simple and not intrusive for what's essentially an uncommon feature.
			if word_wrap_eol == nil { word_wrap_eol = ImFont_CalcWordWrapPositionA(this, scale, s, text_end, wrap_width - (x - origin_x)) }

			if s >= word_wrap_eol {
				x = origin_x
				y += line_height
				if y > clip_rect.w {
					// break out of main loop
					break
				}
				word_wrap_eol = nil
				s = CalcWordWrapNextLineStartA(s, text_end); // Wrapping skips upcoming blanks
				continue
			}
		}

		// Decode and advance source
		c : u32 = cast(u32) s^
		if c < 0x80 { s = mem.ptr_offset(s, 1) }
		else { s = mem.ptr_offset(s, ImTextCharFromUtf8(&c, s, text_end)) }

		if c < 32 {
			if c == '\n' {
				x = origin_x
				y += line_height
				if y > clip_rect.w {
					// break out of main loop
					break
				}
				continue
			}
			if c == '\r' { continue }
		}

		glyph : ^ImFontGlyph = ImFont_FindGlyph(this, cast(ImWchar) c)
		if glyph == nil { continue }

		char_width : f32 = glyph.AdvanceX * scale
		if glyph.Visible != 0 {
			// We don't do a second finer clipping test on the Y axis as we've already skipped anything before clip_rect.y and exit once we pass clip_rect.w
			x1 : f32 = x + glyph.X0 * scale
			x2 : f32 = x + glyph.X1 * scale
			y1 : f32 = y + glyph.Y0 * scale
			y2 : f32 = y + glyph.Y1 * scale
			if x1 <= clip_rect.z && x2 >= clip_rect.x {
				// Render a character
				u1 : f32 = glyph.U0
				v1 : f32 = glyph.V0
				u2 : f32 = glyph.U1
				v2 : f32 = glyph.V1

				// CPU side clipping used to fit text in their frame when the frame is too small. Only does clipping for axis aligned quads.
				if cpu_fine_clip {
					if x1 < clip_rect.x {
						u1 = u1 + (1.0 - (x2 - clip_rect.x) / (x2 - x1)) * (u2 - u1)
						x1 = clip_rect.x
					}
					if y1 < clip_rect.y {
						v1 = v1 + (1.0 - (y2 - clip_rect.y) / (y2 - y1)) * (v2 - v1)
						y1 = clip_rect.y
					}
					if x2 > clip_rect.z {
						u2 = u1 + ((clip_rect.z - x1) / (x2 - x1)) * (u2 - u1)
						x2 = clip_rect.z
					}
					if y2 > clip_rect.w {
						v2 = v1 + ((clip_rect.w - y1) / (y2 - y1)) * (v2 - v1)
						y2 = clip_rect.w
					}
					if y1 >= y2 {
						x += char_width
						continue
					}
				}

				// Support for untinted glyphs
				glyph_col : ImU32 = glyph.Colored != 0 ? col_untinted : col

				// We are NOT calling PrimRectUV() here because non-inlined causes too much overhead in a debug builds. Inlined here:
				{
				vtx_write[0].pos.x = x1; vtx_write[0].pos.y = y1; vtx_write[0].col = glyph_col; vtx_write[0].uv.x = u1; vtx_write[0].uv.y = v1
				vtx_write[1].pos.x = x2; vtx_write[1].pos.y = y1; vtx_write[1].col = glyph_col; vtx_write[1].uv.x = u2; vtx_write[1].uv.y = v1
				vtx_write[2].pos.x = x2; vtx_write[2].pos.y = y2; vtx_write[2].col = glyph_col; vtx_write[2].uv.x = u2; vtx_write[2].uv.y = v2
				vtx_write[3].pos.x = x1; vtx_write[3].pos.y = y2; vtx_write[3].col = glyph_col; vtx_write[3].uv.x = u1; vtx_write[3].uv.y = v2
				idx_write[0] = cast(ImDrawIdx) (vtx_index); idx_write[1] = cast(ImDrawIdx) (vtx_index + 1); idx_write[2] = cast(ImDrawIdx) (vtx_index + 2)
				idx_write[3] = cast(ImDrawIdx) (vtx_index); idx_write[4] = cast(ImDrawIdx) (vtx_index + 2); idx_write[5] = cast(ImDrawIdx) (vtx_index + 3)
				vtx_write = vtx_write[4:]
				vtx_index += 4
				idx_write = idx_write[6:]
				}
			}
		}
		x += char_width
	}

	// Give back unused vertices (clipped ones, blanks) ~ this is essentially a PrimUnreserve() action.
	draw_list.VtxBuffer.Size = cast(i32) mem.ptr_sub(vtx_write, draw_list.VtxBuffer.Data); // Same as calling shrink()
	draw_list.IdxBuffer.Size = cast(i32) mem.ptr_sub(idx_write, draw_list.IdxBuffer.Data)
	draw_list.CmdBuffer.Data[draw_list.CmdBuffer.Size - 1].ElemCount -= cast(u32) (idx_expected_size - draw_list.IdxBuffer.Size)
	draw_list._VtxWritePtr = vtx_write
	draw_list._IdxWritePtr = idx_write
	draw_list._VtxCurrentIdx = vtx_index
}

//-----------------------------------------------------------------------------
// [SECTION] ImGui Internal Render Helpers
//-----------------------------------------------------------------------------
// Vaguely redesigned to stop accessing ImGui global state:
// - RenderArrow()
// - RenderBullet()
// - RenderCheckMark()
// - RenderArrowDockMenu()
// - RenderArrowPointingAt()
// - RenderRectFilledRangeH()
// - RenderRectFilledWithHole()
//-----------------------------------------------------------------------------
// Function in need of a redesign (legacy mess)
// - RenderColorRectWithAlphaCheckerboard()
//-----------------------------------------------------------------------------

// Render an arrow aimed to be aligned with text (p_min is a position in the same space text would be positioned). To e.g. denote expanded/collapsed state
RenderArrow :: proc(draw_list : ^ImDrawList, pos : ImVec2, col : ImU32, dir : ImGuiDir, scale : f32 = 1)
{
	h : f32 = draw_list._Data.FontSize * 1.00
	r : f32 = h * 0.40 * scale
	center : ImVec2 = pos + ImVec2{h * 0.50, h * 0.50 * scale}

	a : ImVec2; b : ImVec2; c : ImVec2
	switch dir {
		case ImGuiDir.ImGuiDir_Up:
			fallthrough
		case ImGuiDir.ImGuiDir_Down:
			if dir == ImGuiDir.ImGuiDir_Up { r = -r }
			a = ImVec2{+0.000, +0.750} * r
			b = ImVec2{-0.866, -0.750} * r
			c = ImVec2{+0.866, -0.750} * r
			break

		case ImGuiDir.ImGuiDir_Left:
			fallthrough
		case ImGuiDir.ImGuiDir_Right:
			if dir == ImGuiDir.ImGuiDir_Left { r = -r }
			a = ImVec2{+0.750, +0.000} * r
			b = ImVec2{-0.750, +0.866} * r
			c = ImVec2{-0.750, -0.866} * r
			break

		case ImGuiDir.ImGuiDir_None:
			fallthrough
		case ImGuiDir.ImGuiDir_COUNT:
			IM_ASSERT(false)
			break
	}
	AddTriangleFilled(draw_list, center + a, center + b, center + c, col)
}

RenderBullet :: proc(draw_list : ^ImDrawList, pos : ImVec2, col : ImU32)
{
	// FIXME-OPT: This should be baked in font.
	ImDrawList_AddCircleFilled(draw_list, pos, draw_list._Data.FontSize * 0.20, col, 8)
}

RenderCheckMark :: proc(draw_list : ^ImDrawList, pos : ImVec2, col : ImU32, sz : f32)
{
	thickness : f32 = ImMax(sz / 5.0, 1.0)
	sz := sz; sz -= thickness * 0.5
	pos := pos; pos += ImVec2{thickness * 0.25, thickness * 0.25}

	third : f32 = sz / 3.0
	bx : f32 = pos.x + third
	by : f32 = pos.y + sz - third * 0.5
	PathLineTo(draw_list, ImVec2{bx - third, by - third})
	PathLineTo(draw_list, ImVec2{bx, by})
	PathLineTo(draw_list, ImVec2{bx + third * 2.0, by - third * 2.0})
	PathStroke(draw_list, col, {}, thickness)
}

// Render an arrow. 'pos' is position of the arrow tip. half_sz.x is length from base to tip. half_sz.y is length on each side.
RenderArrowPointingAt :: proc(draw_list : ^ImDrawList, pos : ImVec2, half_sz : ImVec2, direction : ImGuiDir, col : ImU32)
{
	switch direction {
		case .ImGuiDir_Left:AddTriangleFilled(draw_list, ImVec2{pos.x + half_sz.x, pos.y - half_sz.y}, ImVec2{pos.x + half_sz.x, pos.y + half_sz.y}, pos, col); return
		case .ImGuiDir_Right:AddTriangleFilled(draw_list, ImVec2{pos.x - half_sz.x, pos.y + half_sz.y}, ImVec2{pos.x - half_sz.x, pos.y - half_sz.y}, pos, col); return
		case .ImGuiDir_Up:AddTriangleFilled(draw_list, ImVec2{pos.x + half_sz.x, pos.y + half_sz.y}, ImVec2{pos.x - half_sz.x, pos.y + half_sz.y}, pos, col); return
		case .ImGuiDir_Down:AddTriangleFilled(draw_list, ImVec2{pos.x - half_sz.x, pos.y - half_sz.y}, ImVec2{pos.x + half_sz.x, pos.y - half_sz.y}, pos, col); return
		case .ImGuiDir_None: fallthrough
		case .ImGuiDir_COUNT: break; // Fix warnings
	}
}

// This is less wide than RenderArrow() and we use in dock nodes instead of the regular RenderArrow() to denote a change of functionality,
// and because the saved space means that the left-most tab label can stay at exactly the same position as the label of a loose window.
RenderArrowDockMenu :: proc(draw_list : ^ImDrawList, p_min : ImVec2, sz : f32, col : ImU32)
{
	AddRectFilled(draw_list, p_min + ImVec2{sz * 0.20, sz * 0.15}, p_min + ImVec2{sz * 0.80, sz * 0.30}, col)
	RenderArrowPointingAt(draw_list, p_min + ImVec2{sz * 0.50, sz * 0.85}, ImVec2{sz * 0.30, sz * 0.40}, ImGuiDir.ImGuiDir_Down, col)
}

ImAcos01 :: #force_inline proc(x : f32) -> f32
{
	if x <= 0.0 { return IM_PI * 0.5 }
	if x >= 1.0 { return 0.0 }
	return ImAcos(x)
	//return (-0.69813170079773212f * x * x - 0.87266462599716477f) * x + 1.5707963267948966f; // Cheap approximation, may be enough for what we do.
}

// FIXME: Cleanup and move code to ImDrawList.
RenderRectFilledRangeH :: proc(draw_list : ^ImDrawList, rect : ImRect, col : ImU32, x_start_norm : f32, x_end_norm : f32, rounding : f32)
{
	if x_end_norm == x_start_norm { return }
	x_start_norm, x_end_norm := x_start_norm, x_end_norm
	if x_start_norm > x_end_norm { ImSwap(&x_start_norm, &x_end_norm) }

	p0 : ImVec2 = ImVec2{ImLerp(rect.Min.x, rect.Max.x, x_start_norm), rect.Min.y}
	p1 : ImVec2 = ImVec2{ImLerp(rect.Min.x, rect.Max.x, x_end_norm), rect.Max.y}
	if rounding == 0.0 {
		AddRectFilled(draw_list, p0, p1, col, 0.0)
		return
	}

	rounding := ImClamp(ImMin((rect.Max.x - rect.Min.x) * 0.5, (rect.Max.y - rect.Min.y) * 0.5) - 1.0, 0.0, rounding)
	inv_rounding : f32 = 1.0 / rounding
	arc0_b : f32 = ImAcos01(1.0 - (p0.x - rect.Min.x) * inv_rounding)
	arc0_e : f32 = ImAcos01(1.0 - (p1.x - rect.Min.x) * inv_rounding)
	half_pi : f32 = IM_PI * 0.5; // We will == compare to this because we know this is the exact value ImAcos01 can return.
	x0 : f32 = ImMax(p0.x, rect.Min.x + rounding)
	if arc0_b == arc0_e {
		PathLineTo(draw_list, ImVec2{x0, p1.y})
		PathLineTo(draw_list, ImVec2{x0, p0.y})
	}
	else if arc0_b == 0.0 && arc0_e == half_pi {
		PathArcToFast(draw_list, ImVec2{x0, p1.y - rounding}, rounding, 3, 6); // BL
		PathArcToFast(draw_list, ImVec2{x0, p0.y + rounding}, rounding, 6, 9); // TR
	}
	else {
		PathArcTo(draw_list, ImVec2{x0, p1.y - rounding}, rounding, IM_PI - arc0_e, IM_PI - arc0_b); // BL
		PathArcTo(draw_list, ImVec2{x0, p0.y + rounding}, rounding, IM_PI + arc0_b, IM_PI + arc0_e); // TR
	}
	if p1.x > rect.Min.x + rounding {
		arc1_b : f32 = ImAcos01(1.0 - (rect.Max.x - p1.x) * inv_rounding)
		arc1_e : f32 = ImAcos01(1.0 - (rect.Max.x - p0.x) * inv_rounding)
		x1 : f32 = ImMin(p1.x, rect.Max.x - rounding)
		if arc1_b == arc1_e {
			PathLineTo(draw_list, ImVec2{x1, p0.y})
			PathLineTo(draw_list, ImVec2{x1, p1.y})
		}
		else if arc1_b == 0.0 && arc1_e == half_pi {
			PathArcToFast(draw_list, ImVec2{x1, p0.y + rounding}, rounding, 9, 12); // TR
			PathArcToFast(draw_list, ImVec2{x1, p1.y - rounding}, rounding, 0, 3); // BR
		}
		else {
			PathArcTo(draw_list, ImVec2{x1, p0.y + rounding}, rounding, -arc1_e, -arc1_b); // TR
			PathArcTo(draw_list, ImVec2{x1, p1.y - rounding}, rounding, +arc1_b, +arc1_e); // BR
		}
	}
	PathFillConvex(draw_list, col)
}

RenderRectFilledWithHole :: proc(draw_list : ^ImDrawList, outer : ImRect, inner : ImRect, col : ImU32, rounding : f32)
{
	fill_L : bool = (inner.Min.x > outer.Min.x)
	fill_R : bool = (inner.Max.x < outer.Max.x)
	fill_U : bool = (inner.Min.y > outer.Min.y)
	fill_D : bool = (inner.Max.y < outer.Max.y)
	if fill_L { AddRectFilled(draw_list, ImVec2{outer.Min.x, inner.Min.y}, ImVec2{inner.Min.x, inner.Max.y}, col, rounding, ImDrawFlags_.ImDrawFlags_RoundCornersNone | (fill_U ? {} : ImDrawFlags_.ImDrawFlags_RoundCornersTopLeft) | (fill_D ? {} : ImDrawFlags_.ImDrawFlags_RoundCornersBottomLeft)) }
	if fill_R { AddRectFilled(draw_list, ImVec2{inner.Max.x, inner.Min.y}, ImVec2{outer.Max.x, inner.Max.y}, col, rounding, ImDrawFlags_.ImDrawFlags_RoundCornersNone | (fill_U ? {} : ImDrawFlags_.ImDrawFlags_RoundCornersTopRight) | (fill_D ? {} : ImDrawFlags_.ImDrawFlags_RoundCornersBottomRight)) }
	if fill_U { AddRectFilled(draw_list, ImVec2{inner.Min.x, outer.Min.y}, ImVec2{inner.Max.x, inner.Min.y}, col, rounding, ImDrawFlags_.ImDrawFlags_RoundCornersNone | (fill_L ? {} : ImDrawFlags_.ImDrawFlags_RoundCornersTopLeft) | (fill_R ? {} : ImDrawFlags_.ImDrawFlags_RoundCornersTopRight)) }
	if fill_D { AddRectFilled(draw_list, ImVec2{inner.Min.x, inner.Max.y}, ImVec2{inner.Max.x, outer.Max.y}, col, rounding, ImDrawFlags_.ImDrawFlags_RoundCornersNone | (fill_L ? {} : ImDrawFlags_.ImDrawFlags_RoundCornersBottomLeft) | (fill_R ? {} : ImDrawFlags_.ImDrawFlags_RoundCornersBottomRight)) }
	if fill_L && fill_U { AddRectFilled(draw_list, ImVec2{outer.Min.x, outer.Min.y}, ImVec2{inner.Min.x, inner.Min.y}, col, rounding, ImDrawFlags_.ImDrawFlags_RoundCornersTopLeft) }
	if fill_R && fill_U { AddRectFilled(draw_list, ImVec2{inner.Max.x, outer.Min.y}, ImVec2{outer.Max.x, inner.Min.y}, col, rounding, ImDrawFlags_.ImDrawFlags_RoundCornersTopRight) }
	if fill_L && fill_D { AddRectFilled(draw_list, ImVec2{outer.Min.x, inner.Max.y}, ImVec2{inner.Min.x, outer.Max.y}, col, rounding, ImDrawFlags_.ImDrawFlags_RoundCornersBottomLeft) }
	if fill_R && fill_D { AddRectFilled(draw_list, ImVec2{inner.Max.x, inner.Max.y}, ImVec2{outer.Max.x, outer.Max.y}, col, rounding, ImDrawFlags_.ImDrawFlags_RoundCornersBottomRight) }
}

CalcRoundingFlagsForRectInRect :: proc(r_in : ImRect, r_outer : ImRect, threshold : f32) -> ImDrawFlags
{
	round_l : bool = r_in.Min.x <= r_outer.Min.x + threshold
	round_r : bool = r_in.Max.x >= r_outer.Max.x - threshold
	round_t : bool = r_in.Min.y <= r_outer.Min.y + threshold
	round_b : bool = r_in.Max.y >= r_outer.Max.y - threshold
	return ImDrawFlags_.ImDrawFlags_RoundCornersNone | ((round_t && round_l) ? ImDrawFlags_.ImDrawFlags_RoundCornersTopLeft : {}) | ((round_t && round_r) ? ImDrawFlags_.ImDrawFlags_RoundCornersTopRight : {}) | ((round_b && round_l) ? ImDrawFlags_.ImDrawFlags_RoundCornersBottomLeft : {}) | ((round_b && round_r) ? ImDrawFlags_.ImDrawFlags_RoundCornersBottomRight : {})
}

// Helper for ColorPicker4()
// NB: This is rather brittle and will show artifact when rounding this enabled if rounded corners overlap multiple cells. Caller currently responsible for avoiding that.
// Spent a non reasonable amount of time trying to getting this right for ColorButton with rounding+anti-aliasing+ImGuiColorEditFlags_HalfAlphaPreview flag + various grid sizes and offsets, and eventually gave up... probably more reasonable to disable rounding altogether.
// FIXME: uses ImGui::GetColorU32
RenderColorRectWithAlphaCheckerboard :: proc(draw_list : ^ImDrawList, p_min : ImVec2, p_max : ImVec2, col : ImU32, grid_step : f32, grid_off : ImVec2, rounding : f32 = 0, flags : ImDrawFlags = {})
{
	flags := flags
	if (flags & ImDrawFlags_.ImDrawFlags_RoundCornersMask_) == {} { flags = ImDrawFlags_.ImDrawFlags_RoundCornersDefault_ }
	if ((col & IM_COL32_A_MASK) >> IM_COL32_A_SHIFT) < 0xFF {
		col_bg1 : ImU32 = GetColorU32(ImAlphaBlendColors(IM_COL32(204, 204, 204, 255), col))
		col_bg2 : ImU32 = GetColorU32(ImAlphaBlendColors(IM_COL32(128, 128, 128, 255), col))
		AddRectFilled(draw_list, p_min, p_max, col_bg1, rounding, flags)

		yi : i32 = 0
		for y : f32 = p_min.y + grid_off.y; y < p_max.y; y, yi = y + grid_step, yi + 1 {
			y1 : f32 = ImClamp(y, p_min.y, p_max.y); y2 : f32 = ImMin(y + grid_step, p_max.y)
			if y2 <= y1 { continue }
			for x : f32 = p_min.x + grid_off.x + f32(yi & 1) * grid_step; x < p_max.x; x += grid_step * 2.0 {
				x1 : f32 = ImClamp(x, p_min.x, p_max.x); x2 : f32 = ImMin(x + grid_step, p_max.x)
				if x2 <= x1 { continue }
				cell_flags : ImDrawFlags = ImDrawFlags_.ImDrawFlags_RoundCornersNone
				if y1 <= p_min.y {if x1 <= p_min.x { cell_flags |= ImDrawFlags_.ImDrawFlags_RoundCornersTopLeft }; if x2 >= p_max.x { cell_flags |= ImDrawFlags_.ImDrawFlags_RoundCornersTopRight }
				}
				if y2 >= p_max.y {if x1 <= p_min.x { cell_flags |= ImDrawFlags_.ImDrawFlags_RoundCornersBottomLeft }; if x2 >= p_max.x { cell_flags |= ImDrawFlags_.ImDrawFlags_RoundCornersBottomRight }
				}

				// Combine flags
				cell_flags = (flags == ImDrawFlags_.ImDrawFlags_RoundCornersNone || cell_flags == ImDrawFlags_.ImDrawFlags_RoundCornersNone) ? ImDrawFlags_.ImDrawFlags_RoundCornersNone : (cell_flags & flags)
				AddRectFilled(draw_list, ImVec2{x1, y1}, ImVec2{x2, y2}, col_bg2, rounding, cell_flags)
			}
		}
	}
	else {
		AddRectFilled(draw_list, p_min, p_max, col, rounding, flags)
	}
}

// Default font TTF is compressed with stb_compress then base85 encoded (see misc/fonts/binary_to_compressed_c.cpp for encoder)
//-----------------------------------------------------------------------------
// [SECTION] Decompression code
//-----------------------------------------------------------------------------
// Compressed with stb_compress() then converted to a C array and encoded as base85.
// Use the program in misc/fonts/binary_to_compressed_c.cpp to create the array from a TTF file.
// The purpose of encoding as base85 instead of "0x00,0x01,..." style is only save on _source code_ size.
// Decompression from stb.h (public domain) by Sean Barrett https://github.com/nothings/stb/blob/master/stb.h
//-----------------------------------------------------------------------------

stb_decompress_length :: proc(input : [^]u8) -> u32
{
	return (u32(input[8]) << 24) + (u32(input[9]) << 16) + (u32(input[10]) << 8) + u32(input[11])
}

stb__barrier_out_e : [^]u8; stb__barrier_out_b : [^]u8
stb__barrier_in_b : [^]u8
stb__dout : [^]u8
stb__match :: proc(data : [^]u8, length : u32)
{
	// INVERSE of memmove... write each byte before copying the next...
	IM_ASSERT(stb__dout[length:] <= stb__barrier_out_e)
	if stb__dout[length:] > stb__barrier_out_e { stb__dout = stb__dout[length:]; return }
	if data < stb__barrier_out_b { stb__dout = stb__barrier_out_e[1:]; return }
	data, length := data, length
	for post_decr(&length) != 0 { post_incr(&stb__dout)^ = post_incr(&data)^ }
}

stb__lit :: proc(data : [^]u8, length : u32)
{
	IM_ASSERT(stb__dout[length:] <= stb__barrier_out_e)
	if stb__dout[length:] > stb__barrier_out_e { stb__dout = stb__dout[length:]; return }
	if data < stb__barrier_in_b { stb__dout = stb__barrier_out_e[1:]; return }
	memcpy(stb__dout, data, int(length))
	stb__dout = stb__dout[length:]
}

stb__in2 :: #force_inline proc "contextless" (i : [^]$T0, x : $T1) -> u32
{
	return (u32(i[x]) << 8) + u32(i[x + 1])
}

stb__in3 :: #force_inline proc "contextless" (i : [^]$T0, x : $T1) -> u32
{
	return  (u32(i[x]) << 16) + stb__in2(i, x + 1)
}

stb__in4 :: #force_inline proc "contextless" (i : [^]$T0, x : $T1) -> u32
{
	return (u32(i[x]) << 24) + stb__in3(i, x + 1)
}


stb_decompress_token :: proc(i : [^]u8) -> [^]u8
{
	i := i
	if i[0] >= 0x20 { // use fewer ifs for cases that expand small
		if i[0] >= 0x80       { stb__match(stb__dout[-i32(i[1]) - 1:], u32(i[0] - 0x80 + 1)); i = i[2:] }
		else if i[0] >= 0x40  { stb__match(stb__dout[-(stb__in2(i, 0) - 0x4000 + 1):], u32(i[2] + 1)); i = i[3:] }
		else /* *i >= 0x20 */ { stb__lit(i[1:], u32(i[0] - 0x20 + 1)); i = i[1 + (i[0] - 0x20 + 1):] }
	}
	else {// more ifs for cases that expand large, since overhead is amortized
		if i[0] >= 0x18      { stb__match(stb__dout[-(stb__in3(i, 0) - 0x180000 + 1):], u32(i[3] + 1)); i = i[4:] }
		else if i[0] >= 0x10 { stb__match(stb__dout[-(stb__in3(i, 0) - 0x100000 + 1):], stb__in2(i, 3) + 1); i = i[5:] }
		else if i[0] >= 0x08 { stb__lit(i[2:], stb__in2(i, 0) - 0x0800 + 1); i = i[2 + (stb__in2(i, 0) - 0x0800 + 1):] }
		else if i[0] == 0x07 { stb__lit(i[3:], stb__in2(i, 1) + 1); i = i[3 + (stb__in2(i, 1) + 1):] }
		else if i[0] == 0x06 { stb__match(stb__dout[-(stb__in3(i, 1) + 1):], u32(i[4] + 1)); i = i[5:] }
		else if i[0] == 0x04 { stb__match(stb__dout[-(stb__in3(i, 1) + 1):], stb__in2(i, 4) + 1); i = i[6:] }
	}
	return i
}

stb_adler32 :: proc(adler32 : u32, buffer : [^]u8, buflen : u32) -> u32
{
	buflen, buffer := buflen, buffer

	ADLER_MOD :: 65521
	s1 : u32 = adler32 & 0xffff; s2 : u32 = adler32 >> 16
	blocklen : u32 = buflen % 5552

	i : u32
	for buflen != 0 {
		for i = 0; i + 7 < blocklen; i += 8 {
			s1 += u32(buffer[0]); s2 += s1
			s1 += u32(buffer[1]); s2 += s1
			s1 += u32(buffer[2]); s2 += s1
			s1 += u32(buffer[3]); s2 += s1
			s1 += u32(buffer[4]); s2 += s1
			s1 += u32(buffer[5]); s2 += s1
			s1 += u32(buffer[6]); s2 += s1
			s1 += u32(buffer[7]); s2 += s1

			buffer = buffer[8:]
		}

		for ; i < blocklen; i += 1 { s1 += u32(post_incr(&buffer)^); s2 += s1 }

		s1 %= ADLER_MOD; s2 %= ADLER_MOD
		buflen -= blocklen
		blocklen = 5552
	}

	return cast(u32) (s2 << 16) + cast(u32) s1
}

stb_decompress :: proc(output : [^]u8, i : [^]u8, _ : u32) -> u32
{
	if stb__in4(i, 0) != 0x57bC0000 { return 0 }
	if stb__in4(i, 4) != 0 {
		// error! stream is > 4GB
		return 0
	}
	olen : u32 = stb_decompress_length(i)
	stb__barrier_in_b = i
	stb__barrier_out_e = output[olen:]
	stb__barrier_out_b = output
	i := i[16:]

	stb__dout = output
	for {
		old_i : ^u8 = i
		i = stb_decompress_token(i)
		if i == old_i {
			if i[0] == 0x05 && i[1] == 0xfa {
				IM_ASSERT(stb__dout == output[olen:])
				if stb__dout != output[olen:] { return 0 }
				if stb_adler32(1, output, olen) != cast(u32) stb__in4(i, 2) { return 0 }
				return olen
			}
			else {
				IM_ASSERT(false); /* NOTREACHED */
				return 0
			}
		}
		IM_ASSERT(stb__dout <= output[olen:])
		if stb__dout > output[olen:] { return 0 }
	}
}

//-----------------------------------------------------------------------------
// [SECTION] Default font data (ProggyClean.ttf)
//-----------------------------------------------------------------------------
// ProggyClean.ttf
// Copyright (c) 2004, 2005 Tristan Grimmer
// MIT license (see License.txt in http://www.proggyfonts.net/index.php?menu=download)
// Download and more information at http://www.proggyfonts.net or http://upperboundsinteractive.com/fonts.php
//-----------------------------------------------------------------------------

when ! IMGUI_DISABLE_DEFAULT_FONT { /* @gen ifndef */

// File: 'ProggyClean.ttf' (41208 bytes)
// Exported using binary_to_compressed_c.exe -u8 "ProggyClean.ttf" proggy_clean_ttf
proggy_clean_ttf_compressed_size : u32 = 9583
proggy_clean_ttf_compressed_data : [9583]u8 = {
	87, 188, 0, 0, 0, 0, 0, 0, 0, 0, 160, 248, 0, 4, 0, 0, 55, 0, 1, 0, 0, 0, 12, 0, 128, 0, 3, 0, 64, 79, 83, 47, 50, 136, 235, 116, 144, 0, 0, 1, 72, 130, 21, 44, 78, 99, 109, 97, 112, 2, 18, 35, 117, 0, 0, 3, 160, 130, 19, 36, 82, 99, 118, 116,
	32, 130, 23, 130, 2, 33, 4, 252, 130, 4, 56, 2, 103, 108, 121, 102, 18, 175, 137, 86, 0, 0, 7, 4, 0, 0, 146, 128, 104, 101, 97, 100, 215, 145, 102, 211, 130, 27, 32, 204, 130, 3, 33, 54, 104, 130, 16, 39, 8, 66, 1, 195, 0, 0, 1, 4, 130,
	15, 59, 36, 104, 109, 116, 120, 138, 0, 126, 128, 0, 0, 1, 152, 0, 0, 2, 6, 108, 111, 99, 97, 140, 115, 176, 216, 0, 0, 5, 130, 30, 41, 2, 4, 109, 97, 120, 112, 1, 174, 0, 218, 130, 31, 32, 40, 130, 16, 44, 32, 110, 97, 109, 101, 37, 89,
	187, 150, 0, 0, 153, 132, 130, 19, 44, 158, 112, 111, 115, 116, 166, 172, 131, 239, 0, 0, 155, 36, 130, 51, 44, 210, 112, 114, 101, 112, 105, 2, 1, 18, 0, 0, 4, 244, 130, 47, 32, 8, 132, 203, 46, 1, 0, 0, 60, 85, 233, 213, 95, 15, 60,
	245, 0, 3, 8, 0, 131, 0, 34, 183, 103, 119, 130, 63, 43, 0, 0, 189, 146, 166, 215, 0, 0, 254, 128, 3, 128, 131, 111, 130, 241, 33, 2, 0, 133, 0, 32, 1, 130, 65, 38, 192, 254, 64, 0, 0, 3, 128, 131, 16, 130, 5, 32, 1, 131, 7, 138, 3, 33, 2,
	0, 130, 17, 36, 1, 1, 0, 144, 0, 130, 121, 130, 23, 38, 2, 0, 8, 0, 64, 0, 10, 130, 9, 32, 118, 130, 9, 130, 6, 32, 0, 130, 59, 33, 1, 144, 131, 200, 35, 2, 188, 2, 138, 130, 16, 32, 143, 133, 7, 37, 1, 197, 0, 50, 2, 0, 131, 0, 33, 4, 9, 131,
	5, 145, 3, 43, 65, 108, 116, 115, 0, 64, 0, 0, 32, 172, 8, 0, 131, 0, 35, 5, 0, 1, 128, 131, 77, 131, 3, 33, 3, 128, 191, 1, 33, 1, 128, 130, 184, 35, 0, 0, 128, 0, 130, 3, 131, 11, 32, 1, 130, 7, 33, 0, 128, 131, 1, 32, 1, 136, 9, 32, 0, 132,
	15, 135, 5, 32, 1, 131, 13, 135, 27, 144, 35, 32, 1, 149, 25, 131, 21, 32, 0, 130, 0, 32, 128, 132, 103, 130, 35, 132, 39, 32, 0, 136, 45, 136, 97, 133, 17, 130, 5, 33, 0, 0, 136, 19, 34, 0, 128, 1, 133, 13, 133, 5, 32, 128, 130, 15, 132,
	131, 32, 3, 130, 5, 32, 3, 132, 27, 144, 71, 32, 0, 133, 27, 130, 29, 130, 31, 136, 29, 131, 63, 131, 3, 65, 63, 5, 132, 5, 132, 205, 130, 9, 33, 0, 0, 131, 9, 137, 119, 32, 3, 132, 19, 138, 243, 130, 55, 32, 1, 132, 35, 135, 19, 131, 201,
	136, 11, 132, 143, 137, 13, 130, 41, 32, 0, 131, 3, 144, 35, 33, 128, 0, 135, 1, 131, 223, 131, 3, 141, 17, 134, 13, 136, 63, 134, 15, 136, 53, 143, 15, 130, 96, 33, 0, 3, 131, 4, 130, 3, 34, 28, 0, 1, 130, 5, 34, 0, 0, 76, 130, 17, 131,
	9, 36, 28, 0, 4, 0, 48, 130, 17, 46, 8, 0, 8, 0, 2, 0, 0, 0, 127, 0, 255, 32, 172, 255, 255, 130, 9, 34, 0, 0, 129, 132, 9, 130, 102, 33, 223, 213, 134, 53, 132, 22, 33, 1, 6, 132, 6, 64, 4, 215, 32, 129, 165, 216, 39, 177, 0, 1, 141, 184,
	1, 255, 133, 134, 45, 33, 198, 0, 193, 1, 8, 190, 244, 1, 28, 1, 158, 2, 20, 2, 136, 2, 252, 3, 20, 3, 88, 3, 156, 3, 222, 4, 20, 4, 50, 4, 80, 4, 98, 4, 162, 5, 22, 5, 102, 5, 188, 6, 18, 6, 116, 6, 214, 7, 56, 7, 126, 7, 236, 8, 78, 8, 108,
	8, 150, 8, 208, 9, 16, 9, 74, 9, 136, 10, 22, 10, 128, 11, 4, 11, 86, 11, 200, 12, 46, 12, 130, 12, 234, 13, 94, 13, 164, 13, 234, 14, 80, 14, 150, 15, 40, 15, 176, 16, 18, 16, 116, 16, 224, 17, 82, 17, 182, 18, 4, 18, 110, 18, 196, 19,
	76, 19, 172, 19, 246, 20, 88, 20, 174, 20, 234, 21, 64, 21, 128, 21, 166, 21, 184, 22, 18, 22, 126, 22, 198, 23, 52, 23, 142, 23, 224, 24, 86, 24, 186, 24, 238, 25, 54, 25, 150, 25, 212, 26, 72, 26, 156, 26, 240, 27, 92, 27, 200, 28,
	4, 28, 76, 28, 150, 28, 234, 29, 42, 29, 146, 29, 210, 30, 64, 30, 142, 30, 224, 31, 36, 31, 118, 31, 166, 31, 166, 32, 16, 130, 1, 52, 46, 32, 138, 32, 178, 32, 200, 33, 20, 33, 116, 33, 152, 33, 238, 34, 98, 34, 134, 35, 12, 130, 1,
	33, 128, 35, 131, 1, 60, 152, 35, 176, 35, 216, 36, 0, 36, 74, 36, 104, 36, 144, 36, 174, 37, 6, 37, 96, 37, 130, 37, 248, 37, 248, 38, 88, 38, 170, 130, 1, 8, 190, 216, 39, 64, 39, 154, 40, 10, 40, 104, 40, 168, 41, 14, 41, 32, 41, 184,
	41, 248, 42, 54, 42, 96, 42, 96, 43, 2, 43, 42, 43, 94, 43, 172, 43, 230, 44, 32, 44, 52, 44, 154, 45, 40, 45, 92, 45, 120, 45, 170, 45, 232, 46, 38, 46, 166, 47, 38, 47, 182, 47, 244, 48, 94, 48, 200, 49, 62, 49, 180, 50, 30, 50, 158,
	51, 30, 51, 130, 51, 238, 52, 92, 52, 206, 53, 58, 53, 134, 53, 212, 54, 38, 54, 114, 54, 230, 55, 118, 55, 216, 56, 58, 56, 166, 57, 18, 57, 116, 57, 174, 58, 46, 58, 154, 59, 6, 59, 124, 59, 232, 60, 58, 60, 150, 61, 34, 61, 134, 61,
	236, 62, 86, 62, 198, 63, 42, 63, 154, 64, 18, 64, 106, 64, 208, 65, 54, 65, 162, 66, 8, 66, 64, 66, 122, 66, 184, 66, 240, 67, 98, 67, 204, 68, 42, 68, 138, 68, 238, 69, 88, 69, 182, 69, 226, 70, 84, 70, 180, 71, 20, 71, 122, 71, 218,
	72, 84, 72, 198, 73, 64, 0, 36, 70, 21, 8, 8, 77, 3, 0, 7, 0, 11, 0, 15, 0, 19, 0, 23, 0, 27, 0, 31, 0, 35, 0, 39, 0, 43, 0, 47, 0, 51, 0, 55, 0, 59, 0, 63, 0, 67, 0, 71, 0, 75, 0, 79, 0, 83, 0, 87, 0, 91, 0, 95, 0, 99, 0, 103, 0, 107, 0, 111, 0, 115,
	0, 119, 0, 123, 0, 127, 0, 131, 0, 135, 0, 139, 0, 143, 0, 0, 17, 53, 51, 21, 49, 150, 3, 32, 5, 130, 23, 32, 33, 130, 3, 211, 7, 151, 115, 32, 128, 133, 0, 37, 252, 128, 128, 2, 128, 128, 190, 5, 133, 74, 32, 4, 133, 6, 206, 5, 42, 0, 7,
	1, 128, 0, 0, 2, 0, 4, 0, 0, 65, 139, 13, 37, 0, 1, 53, 51, 21, 7, 146, 3, 32, 3, 130, 19, 32, 1, 141, 133, 32, 3, 141, 14, 131, 13, 38, 255, 0, 128, 128, 0, 6, 1, 130, 84, 35, 2, 128, 4, 128, 140, 91, 132, 89, 32, 51, 65, 143, 6, 139, 7, 33,
	1, 0, 130, 57, 32, 254, 130, 3, 32, 128, 132, 4, 32, 4, 131, 14, 138, 89, 35, 0, 0, 24, 0, 130, 0, 33, 3, 128, 144, 171, 66, 55, 33, 148, 115, 65, 187, 19, 32, 5, 130, 151, 143, 155, 163, 39, 32, 1, 136, 182, 32, 253, 134, 178, 132, 7,
	132, 200, 145, 17, 32, 3, 65, 48, 17, 165, 17, 39, 0, 0, 21, 0, 128, 255, 128, 3, 65, 175, 17, 65, 3, 27, 132, 253, 131, 217, 139, 201, 155, 233, 155, 27, 131, 67, 131, 31, 130, 241, 33, 255, 0, 131, 181, 137, 232, 132, 15, 132, 4, 138,
	247, 34, 255, 0, 128, 179, 238, 32, 0, 130, 0, 32, 20, 65, 239, 48, 33, 0, 19, 67, 235, 10, 32, 51, 65, 203, 14, 65, 215, 11, 32, 7, 154, 27, 135, 39, 32, 33, 130, 35, 33, 128, 128, 130, 231, 32, 253, 132, 231, 32, 128, 132, 232, 34,
	128, 128, 254, 133, 13, 136, 8, 32, 253, 65, 186, 5, 130, 36, 130, 42, 176, 234, 133, 231, 34, 128, 0, 0, 66, 215, 44, 33, 0, 1, 68, 235, 6, 68, 211, 19, 32, 49, 68, 239, 14, 139, 207, 139, 47, 66, 13, 7, 32, 51, 130, 47, 33, 1, 0, 130,
	207, 35, 128, 128, 1, 0, 131, 222, 131, 5, 130, 212, 130, 6, 131, 212, 32, 0, 130, 10, 133, 220, 130, 233, 130, 226, 32, 254, 133, 255, 178, 233, 39, 3, 1, 128, 3, 0, 2, 0, 4, 68, 15, 7, 68, 99, 12, 130, 89, 130, 104, 33, 128, 4, 133,
	93, 130, 10, 38, 0, 0, 11, 1, 0, 255, 0, 68, 63, 16, 70, 39, 9, 66, 215, 8, 32, 7, 68, 77, 6, 68, 175, 14, 32, 29, 68, 195, 6, 132, 7, 35, 2, 0, 128, 255, 131, 91, 132, 4, 65, 178, 5, 141, 111, 67, 129, 23, 165, 135, 140, 107, 142, 135, 33,
	21, 5, 69, 71, 6, 131, 7, 33, 1, 0, 140, 104, 132, 142, 130, 4, 137, 247, 140, 30, 68, 255, 12, 39, 11, 0, 128, 0, 128, 3, 0, 3, 69, 171, 15, 67, 251, 7, 65, 15, 8, 66, 249, 11, 65, 229, 7, 67, 211, 7, 66, 13, 7, 35, 1, 128, 128, 254, 133,
	93, 32, 254, 131, 145, 132, 4, 132, 18, 32, 2, 151, 128, 130, 23, 34, 0, 0, 9, 154, 131, 65, 207, 8, 68, 107, 15, 68, 51, 7, 32, 7, 70, 59, 7, 135, 121, 130, 82, 32, 128, 151, 111, 41, 0, 0, 4, 0, 128, 255, 0, 1, 128, 1, 137, 239, 33, 0,
	37, 70, 145, 10, 65, 77, 10, 65, 212, 14, 37, 0, 0, 0, 5, 0, 128, 66, 109, 5, 70, 123, 10, 33, 0, 19, 72, 33, 18, 133, 237, 70, 209, 11, 33, 0, 2, 130, 113, 137, 119, 136, 115, 33, 1, 0, 133, 43, 130, 5, 34, 0, 0, 10, 69, 135, 6, 70, 219,
	13, 66, 155, 7, 65, 9, 12, 66, 157, 11, 66, 9, 11, 32, 7, 130, 141, 132, 252, 66, 151, 9, 137, 9, 66, 15, 30, 36, 0, 20, 0, 128, 0, 130, 218, 71, 11, 42, 68, 51, 8, 65, 141, 7, 73, 19, 15, 69, 47, 23, 143, 39, 66, 81, 7, 32, 1, 66, 55, 6, 34,
	1, 128, 128, 68, 25, 5, 69, 32, 6, 137, 6, 136, 25, 32, 254, 131, 42, 32, 3, 66, 88, 26, 148, 26, 32, 0, 130, 0, 32, 14, 164, 231, 70, 225, 12, 66, 233, 7, 67, 133, 19, 71, 203, 15, 130, 161, 32, 255, 130, 155, 32, 254, 139, 127, 134,
	12, 164, 174, 33, 0, 15, 164, 159, 33, 59, 0, 65, 125, 20, 66, 25, 7, 32, 5, 68, 191, 6, 66, 29, 7, 144, 165, 65, 105, 9, 35, 128, 128, 255, 0, 137, 2, 133, 182, 164, 169, 33, 128, 128, 197, 171, 130, 155, 68, 235, 7, 32, 21, 70, 77, 19,
	66, 21, 10, 68, 97, 8, 66, 30, 5, 66, 4, 43, 34, 0, 17, 0, 71, 19, 41, 65, 253, 20, 71, 25, 23, 65, 91, 15, 65, 115, 7, 34, 2, 128, 128, 66, 9, 8, 130, 169, 33, 1, 0, 66, 212, 13, 132, 28, 72, 201, 43, 35, 0, 0, 0, 18, 66, 27, 38, 76, 231, 5,
	68, 157, 20, 135, 157, 32, 7, 68, 185, 13, 65, 129, 28, 66, 20, 5, 32, 253, 66, 210, 11, 65, 128, 49, 133, 61, 32, 0, 65, 135, 6, 74, 111, 37, 72, 149, 12, 66, 203, 19, 65, 147, 19, 68, 93, 7, 68, 85, 8, 76, 4, 5, 33, 255, 0, 133, 129, 34,
	254, 0, 128, 68, 69, 8, 181, 197, 34, 0, 0, 12, 65, 135, 32, 65, 123, 20, 69, 183, 27, 133, 156, 66, 50, 5, 72, 87, 10, 67, 137, 32, 33, 0, 19, 160, 139, 78, 251, 13, 68, 55, 20, 67, 119, 19, 65, 91, 36, 69, 177, 15, 32, 254, 143, 16, 65,
	98, 53, 32, 128, 130, 0, 32, 0, 66, 43, 54, 70, 141, 23, 66, 23, 15, 131, 39, 69, 47, 11, 131, 15, 70, 129, 19, 74, 161, 9, 36, 128, 255, 0, 128, 254, 130, 153, 65, 148, 32, 67, 41, 9, 34, 0, 0, 4, 79, 15, 5, 73, 99, 10, 71, 203, 8, 32, 3,
	72, 123, 6, 72, 43, 8, 32, 2, 133, 56, 131, 99, 130, 9, 34, 0, 0, 6, 72, 175, 5, 73, 159, 14, 144, 63, 135, 197, 132, 189, 133, 66, 33, 255, 0, 73, 6, 7, 70, 137, 12, 35, 0, 0, 0, 10, 130, 3, 73, 243, 25, 67, 113, 12, 65, 73, 7, 69, 161, 7,
	138, 7, 37, 21, 2, 0, 128, 128, 254, 134, 3, 73, 116, 27, 33, 128, 128, 130, 111, 39, 12, 0, 128, 1, 0, 3, 128, 2, 72, 219, 21, 35, 43, 0, 47, 0, 67, 47, 20, 130, 111, 33, 21, 1, 68, 167, 13, 81, 147, 8, 133, 230, 32, 128, 77, 73, 6, 32,
	128, 131, 142, 134, 18, 130, 6, 32, 255, 75, 18, 12, 131, 243, 37, 128, 0, 128, 3, 128, 3, 74, 231, 21, 135, 123, 32, 29, 134, 107, 135, 7, 32, 21, 74, 117, 7, 135, 7, 134, 96, 135, 246, 74, 103, 23, 132, 242, 33, 0, 10, 67, 151, 28,
	67, 133, 20, 66, 141, 11, 131, 11, 32, 3, 77, 71, 6, 32, 128, 130, 113, 32, 1, 81, 4, 6, 134, 218, 66, 130, 24, 131, 31, 34, 0, 26, 0, 130, 0, 77, 255, 44, 83, 15, 11, 148, 155, 68, 13, 7, 32, 49, 78, 231, 18, 79, 7, 11, 73, 243, 11, 32,
	33, 65, 187, 10, 130, 63, 65, 87, 8, 73, 239, 19, 35, 0, 128, 1, 0, 131, 226, 32, 252, 65, 100, 6, 32, 128, 139, 8, 33, 1, 0, 130, 21, 32, 253, 72, 155, 44, 73, 255, 20, 32, 128, 71, 67, 8, 81, 243, 39, 67, 15, 20, 74, 191, 23, 68, 121,
	27, 32, 1, 66, 150, 6, 32, 254, 79, 19, 11, 131, 214, 32, 128, 130, 215, 37, 2, 0, 128, 253, 0, 128, 136, 5, 65, 220, 24, 147, 212, 130, 210, 33, 0, 24, 72, 219, 42, 84, 255, 13, 67, 119, 16, 69, 245, 19, 72, 225, 19, 65, 3, 15, 69, 93,
	19, 131, 55, 132, 178, 71, 115, 14, 81, 228, 6, 142, 245, 33, 253, 0, 132, 43, 172, 252, 65, 16, 11, 75, 219, 8, 65, 219, 31, 66, 223, 24, 75, 223, 10, 33, 29, 1, 80, 243, 10, 66, 175, 8, 131, 110, 134, 203, 133, 172, 130, 16, 70, 30,
	7, 164, 183, 130, 163, 32, 20, 65, 171, 48, 65, 163, 36, 65, 143, 23, 65, 151, 19, 65, 147, 13, 65, 134, 17, 133, 17, 130, 216, 67, 114, 5, 164, 217, 65, 137, 12, 72, 147, 48, 79, 71, 19, 74, 169, 22, 80, 251, 8, 65, 173, 7, 66, 157,
	15, 74, 173, 15, 32, 254, 65, 170, 8, 71, 186, 45, 72, 131, 6, 77, 143, 40, 187, 195, 152, 179, 65, 123, 38, 68, 215, 57, 68, 179, 15, 65, 85, 7, 69, 187, 14, 32, 21, 66, 95, 15, 67, 19, 25, 32, 1, 83, 223, 6, 32, 2, 76, 240, 7, 77, 166,
	43, 65, 8, 5, 130, 206, 32, 0, 67, 39, 54, 143, 167, 66, 255, 19, 82, 193, 11, 151, 47, 85, 171, 5, 67, 27, 17, 132, 160, 69, 172, 11, 69, 184, 56, 66, 95, 6, 33, 12, 1, 130, 237, 32, 2, 68, 179, 27, 68, 175, 16, 80, 135, 15, 72, 55, 7,
	71, 87, 12, 73, 3, 12, 132, 12, 66, 75, 32, 76, 215, 5, 169, 139, 147, 135, 148, 139, 81, 12, 12, 81, 185, 36, 75, 251, 7, 65, 23, 27, 76, 215, 9, 87, 165, 12, 65, 209, 15, 72, 157, 7, 65, 245, 31, 32, 128, 71, 128, 6, 32, 1, 82, 125, 5,
	34, 0, 128, 254, 131, 169, 32, 254, 131, 187, 71, 180, 9, 132, 27, 32, 2, 88, 129, 44, 32, 0, 78, 47, 40, 65, 79, 23, 79, 171, 14, 32, 21, 71, 87, 8, 72, 15, 14, 65, 224, 33, 130, 139, 74, 27, 62, 93, 23, 7, 68, 31, 7, 75, 27, 7, 139, 15,
	74, 3, 7, 74, 23, 27, 65, 165, 11, 65, 177, 15, 67, 123, 5, 32, 1, 130, 221, 32, 252, 71, 96, 5, 74, 12, 12, 133, 244, 130, 25, 34, 1, 0, 128, 130, 2, 139, 8, 93, 26, 8, 65, 9, 32, 65, 57, 14, 140, 14, 32, 0, 73, 79, 67, 68, 119, 11, 135,
	11, 32, 51, 90, 75, 14, 139, 247, 65, 43, 7, 131, 19, 139, 11, 69, 159, 11, 65, 247, 6, 36, 1, 128, 128, 253, 0, 90, 71, 9, 33, 1, 0, 132, 14, 32, 128, 89, 93, 14, 69, 133, 6, 130, 44, 131, 30, 131, 6, 65, 20, 56, 33, 0, 16, 72, 179, 40,
	75, 47, 12, 65, 215, 19, 74, 95, 19, 65, 43, 11, 131, 168, 67, 110, 5, 75, 23, 17, 69, 106, 6, 75, 65, 5, 71, 204, 43, 32, 0, 80, 75, 47, 71, 203, 15, 159, 181, 68, 91, 11, 67, 197, 7, 73, 101, 13, 68, 85, 6, 33, 128, 128, 130, 214, 130,
	25, 32, 254, 74, 236, 48, 130, 194, 37, 0, 18, 0, 128, 255, 128, 77, 215, 40, 65, 139, 64, 32, 51, 80, 159, 10, 65, 147, 39, 130, 219, 84, 212, 43, 130, 46, 75, 19, 97, 74, 33, 11, 65, 201, 23, 65, 173, 31, 33, 1, 0, 79, 133, 6, 66, 150,
	5, 67, 75, 48, 85, 187, 6, 70, 207, 37, 32, 71, 87, 221, 13, 73, 163, 14, 80, 167, 15, 132, 15, 83, 193, 19, 82, 209, 8, 78, 99, 9, 72, 190, 11, 77, 110, 49, 89, 63, 5, 80, 91, 35, 99, 63, 32, 70, 235, 23, 81, 99, 10, 69, 148, 10, 65, 110,
	36, 32, 0, 65, 99, 47, 95, 219, 11, 68, 171, 51, 66, 87, 7, 72, 57, 7, 74, 45, 17, 143, 17, 65, 114, 50, 33, 14, 0, 65, 111, 40, 159, 195, 98, 135, 15, 35, 7, 53, 51, 21, 100, 78, 9, 95, 146, 16, 32, 254, 82, 114, 6, 32, 128, 67, 208, 37,
	130, 166, 99, 79, 58, 32, 17, 96, 99, 14, 72, 31, 19, 72, 87, 31, 82, 155, 7, 67, 47, 14, 32, 21, 131, 75, 134, 231, 72, 51, 17, 72, 78, 8, 133, 8, 80, 133, 6, 33, 253, 128, 88, 37, 9, 66, 124, 36, 72, 65, 12, 134, 12, 71, 55, 43, 66, 139,
	27, 85, 135, 10, 91, 33, 12, 65, 35, 11, 66, 131, 11, 71, 32, 8, 90, 127, 6, 130, 244, 71, 76, 11, 168, 207, 33, 0, 12, 66, 123, 32, 32, 0, 65, 183, 15, 68, 135, 11, 66, 111, 7, 67, 235, 11, 66, 111, 15, 32, 254, 97, 66, 12, 160, 154, 67,
	227, 52, 80, 33, 15, 87, 249, 15, 93, 45, 31, 75, 111, 12, 93, 45, 11, 77, 99, 9, 160, 184, 81, 31, 12, 32, 15, 98, 135, 30, 104, 175, 7, 77, 249, 36, 69, 73, 15, 78, 5, 12, 32, 254, 66, 151, 19, 34, 128, 128, 4, 87, 32, 12, 149, 35, 133,
	21, 96, 151, 31, 32, 19, 72, 35, 5, 98, 173, 15, 143, 15, 32, 21, 143, 99, 158, 129, 33, 0, 0, 65, 35, 52, 65, 11, 15, 147, 15, 98, 75, 11, 33, 1, 0, 143, 151, 132, 15, 32, 254, 99, 200, 37, 132, 43, 130, 4, 39, 0, 10, 0, 128, 1, 128, 3,
	0, 104, 151, 14, 97, 187, 20, 69, 131, 15, 67, 195, 11, 87, 227, 7, 33, 128, 128, 132, 128, 33, 254, 0, 68, 131, 9, 65, 46, 26, 42, 0, 0, 0, 7, 0, 0, 255, 128, 3, 128, 0, 88, 223, 15, 33, 0, 21, 89, 61, 22, 66, 209, 12, 65, 2, 12, 37, 0, 2,
	1, 0, 3, 128, 101, 83, 8, 36, 0, 1, 53, 51, 29, 130, 3, 34, 21, 1, 0, 66, 53, 8, 32, 0, 68, 215, 6, 100, 55, 25, 107, 111, 9, 66, 193, 11, 72, 167, 8, 73, 143, 31, 139, 31, 33, 1, 0, 131, 158, 32, 254, 132, 5, 33, 253, 128, 65, 16, 9, 133,
	17, 89, 130, 25, 141, 212, 33, 0, 0, 93, 39, 8, 90, 131, 25, 93, 39, 14, 66, 217, 6, 106, 179, 8, 159, 181, 71, 125, 15, 139, 47, 138, 141, 87, 11, 14, 76, 23, 14, 65, 231, 26, 140, 209, 66, 122, 8, 81, 179, 5, 101, 195, 26, 32, 47, 74,
	75, 13, 69, 159, 11, 83, 235, 11, 67, 21, 16, 136, 167, 131, 106, 130, 165, 130, 15, 32, 128, 101, 90, 24, 134, 142, 32, 0, 65, 103, 51, 108, 23, 11, 101, 231, 15, 75, 173, 23, 74, 237, 23, 66, 15, 6, 66, 46, 17, 66, 58, 17, 65, 105,
	49, 66, 247, 55, 71, 179, 12, 70, 139, 15, 86, 229, 7, 84, 167, 15, 32, 1, 95, 72, 12, 89, 49, 6, 33, 128, 128, 65, 136, 38, 66, 30, 9, 32, 0, 100, 239, 7, 66, 247, 29, 70, 105, 20, 65, 141, 19, 69, 81, 15, 130, 144, 32, 128, 83, 41, 5,
	32, 255, 131, 177, 68, 185, 5, 133, 126, 65, 97, 37, 32, 0, 130, 0, 33, 21, 0, 130, 55, 66, 195, 28, 67, 155, 13, 34, 79, 0, 83, 66, 213, 13, 73, 241, 19, 66, 59, 19, 65, 125, 11, 135, 201, 66, 249, 16, 32, 128, 66, 44, 11, 66, 56, 17,
	68, 143, 8, 68, 124, 38, 67, 183, 12, 96, 211, 9, 65, 143, 29, 112, 171, 5, 32, 0, 68, 131, 63, 34, 33, 53, 51, 71, 121, 11, 32, 254, 98, 251, 16, 32, 253, 74, 231, 10, 65, 175, 37, 133, 206, 37, 0, 0, 8, 1, 0, 0, 107, 123, 11, 113, 115,
	9, 33, 0, 1, 130, 117, 131, 3, 73, 103, 7, 66, 51, 18, 66, 44, 5, 133, 75, 70, 88, 5, 32, 254, 65, 39, 12, 68, 80, 9, 34, 12, 0, 128, 107, 179, 28, 68, 223, 6, 155, 111, 86, 147, 15, 32, 2, 131, 82, 141, 110, 33, 254, 0, 130, 15, 32, 4, 103,
	184, 15, 141, 35, 87, 176, 5, 83, 11, 5, 71, 235, 23, 114, 107, 11, 65, 189, 16, 70, 33, 15, 86, 153, 31, 135, 126, 86, 145, 30, 65, 183, 41, 32, 0, 130, 0, 32, 10, 65, 183, 24, 34, 35, 0, 39, 67, 85, 9, 65, 179, 15, 143, 15, 33, 1, 0, 65,
	28, 17, 157, 136, 130, 123, 32, 20, 130, 3, 32, 0, 97, 135, 24, 115, 167, 19, 80, 71, 12, 32, 51, 110, 163, 14, 78, 35, 19, 131, 19, 155, 23, 77, 229, 8, 78, 9, 17, 151, 17, 67, 231, 46, 94, 135, 8, 73, 31, 31, 93, 215, 56, 82, 171, 25,
	72, 77, 8, 162, 179, 169, 167, 99, 131, 11, 69, 85, 19, 66, 215, 15, 76, 129, 13, 68, 115, 22, 72, 79, 35, 67, 113, 5, 34, 0, 0, 19, 70, 31, 46, 65, 89, 52, 73, 223, 15, 85, 199, 33, 95, 33, 8, 132, 203, 73, 29, 32, 67, 48, 16, 177, 215,
	101, 13, 15, 65, 141, 43, 69, 141, 15, 75, 89, 5, 70, 0, 11, 70, 235, 21, 178, 215, 36, 10, 0, 128, 0, 0, 71, 207, 24, 33, 0, 19, 100, 67, 6, 80, 215, 11, 66, 67, 7, 80, 43, 12, 71, 106, 7, 80, 192, 5, 65, 63, 5, 66, 217, 26, 33, 0, 13, 156,
	119, 68, 95, 5, 72, 233, 12, 134, 129, 85, 81, 11, 76, 165, 20, 65, 43, 8, 73, 136, 8, 75, 10, 31, 38, 128, 128, 0, 0, 0, 13, 1, 130, 4, 32, 3, 106, 235, 29, 114, 179, 12, 66, 131, 23, 32, 7, 77, 133, 6, 67, 89, 12, 131, 139, 116, 60, 9,
	89, 15, 37, 32, 0, 74, 15, 7, 103, 11, 22, 65, 35, 5, 33, 55, 0, 93, 81, 28, 67, 239, 23, 78, 85, 5, 107, 93, 14, 66, 84, 17, 65, 193, 26, 74, 183, 10, 66, 67, 34, 143, 135, 79, 91, 15, 32, 7, 117, 111, 8, 75, 56, 9, 84, 212, 9, 154, 134,
	32, 0, 130, 0, 32, 18, 130, 3, 70, 171, 41, 83, 7, 16, 70, 131, 19, 84, 191, 15, 84, 175, 19, 84, 167, 30, 84, 158, 12, 154, 193, 68, 107, 15, 33, 0, 0, 65, 79, 42, 65, 71, 7, 73, 55, 7, 118, 191, 16, 83, 180, 9, 32, 255, 76, 166, 9, 154,
	141, 32, 0, 130, 0, 69, 195, 52, 65, 225, 15, 151, 15, 75, 215, 31, 80, 56, 10, 68, 240, 17, 100, 32, 9, 70, 147, 39, 65, 93, 12, 71, 71, 41, 92, 85, 15, 84, 135, 23, 78, 35, 15, 110, 27, 10, 84, 125, 8, 107, 115, 29, 136, 160, 38, 0, 0,
	14, 0, 128, 255, 0, 82, 155, 24, 67, 239, 8, 119, 255, 11, 69, 131, 11, 77, 29, 6, 112, 31, 8, 134, 27, 105, 203, 8, 32, 2, 75, 51, 11, 75, 195, 12, 74, 13, 29, 136, 161, 37, 128, 0, 0, 0, 11, 1, 130, 163, 82, 115, 8, 125, 191, 17, 69, 35,
	12, 74, 137, 15, 143, 15, 32, 1, 65, 157, 12, 136, 12, 161, 142, 65, 43, 40, 65, 199, 6, 65, 19, 24, 102, 185, 11, 76, 123, 11, 99, 6, 12, 135, 12, 32, 254, 130, 8, 161, 155, 101, 23, 9, 39, 8, 0, 0, 1, 128, 3, 128, 2, 78, 63, 17, 72, 245,
	12, 67, 41, 11, 90, 167, 9, 32, 128, 97, 49, 9, 32, 128, 109, 51, 14, 132, 97, 81, 191, 8, 130, 97, 125, 99, 12, 121, 35, 9, 127, 75, 15, 71, 79, 12, 81, 151, 23, 87, 97, 7, 70, 223, 15, 80, 245, 16, 105, 97, 15, 32, 254, 113, 17, 6, 32,
	128, 130, 8, 105, 105, 8, 76, 122, 18, 65, 243, 21, 74, 63, 7, 38, 4, 1, 0, 255, 0, 2, 0, 119, 247, 28, 133, 65, 32, 255, 141, 91, 35, 0, 0, 0, 16, 67, 63, 36, 34, 59, 0, 63, 77, 59, 9, 119, 147, 11, 143, 241, 66, 173, 15, 66, 31, 11, 67,
	75, 8, 81, 74, 16, 32, 128, 131, 255, 87, 181, 42, 127, 43, 5, 34, 255, 128, 2, 120, 235, 11, 37, 19, 0, 23, 0, 0, 37, 109, 191, 14, 118, 219, 7, 127, 43, 14, 65, 79, 14, 35, 0, 0, 0, 3, 73, 91, 5, 130, 5, 38, 3, 0, 7, 0, 11, 0, 0, 70, 205,
	11, 88, 221, 12, 32, 0, 73, 135, 7, 87, 15, 22, 73, 135, 10, 79, 153, 15, 97, 71, 19, 65, 49, 11, 32, 1, 131, 104, 121, 235, 11, 80, 65, 11, 142, 179, 144, 14, 81, 123, 46, 32, 1, 88, 217, 5, 112, 5, 8, 65, 201, 15, 83, 29, 15, 122, 147,
	11, 135, 179, 142, 175, 143, 185, 67, 247, 39, 66, 199, 7, 35, 5, 0, 128, 3, 69, 203, 15, 123, 163, 12, 67, 127, 7, 130, 119, 71, 153, 10, 141, 102, 70, 175, 8, 32, 128, 121, 235, 30, 136, 89, 100, 191, 11, 116, 195, 11, 111, 235, 15,
	72, 39, 7, 32, 2, 97, 43, 5, 132, 5, 94, 67, 8, 131, 8, 125, 253, 10, 32, 3, 65, 158, 16, 146, 16, 130, 170, 40, 0, 21, 0, 128, 0, 0, 3, 128, 5, 88, 219, 15, 24, 64, 159, 32, 135, 141, 65, 167, 15, 68, 163, 10, 97, 73, 49, 32, 255, 82, 58,
	7, 93, 80, 8, 97, 81, 16, 24, 67, 87, 52, 34, 0, 0, 5, 130, 231, 33, 128, 2, 80, 51, 13, 65, 129, 8, 113, 61, 6, 132, 175, 65, 219, 5, 130, 136, 77, 152, 17, 32, 0, 95, 131, 61, 70, 215, 6, 33, 21, 51, 90, 53, 10, 78, 97, 23, 105, 77, 31,
	65, 117, 7, 139, 75, 24, 68, 195, 9, 24, 64, 22, 9, 33, 0, 128, 130, 11, 33, 128, 128, 66, 25, 5, 121, 38, 5, 134, 5, 134, 45, 66, 40, 36, 66, 59, 18, 34, 128, 0, 0, 66, 59, 81, 135, 245, 123, 103, 19, 120, 159, 19, 77, 175, 12, 33, 255,
	0, 87, 29, 10, 94, 70, 21, 66, 59, 54, 39, 3, 1, 128, 3, 0, 2, 128, 4, 24, 65, 7, 15, 66, 47, 7, 72, 98, 12, 37, 0, 0, 0, 3, 1, 0, 24, 65, 55, 21, 131, 195, 32, 1, 67, 178, 6, 33, 4, 0, 77, 141, 8, 32, 6, 131, 47, 74, 67, 16, 24, 69, 3, 20, 24,
	65, 251, 7, 133, 234, 130, 229, 94, 108, 17, 35, 0, 0, 6, 0, 141, 175, 86, 59, 5, 162, 79, 85, 166, 8, 70, 112, 13, 32, 13, 24, 64, 67, 26, 24, 71, 255, 7, 123, 211, 12, 80, 121, 11, 69, 215, 15, 66, 217, 11, 69, 71, 10, 131, 113, 132,
	126, 119, 90, 9, 66, 117, 19, 132, 19, 32, 0, 130, 0, 24, 64, 47, 59, 33, 7, 0, 73, 227, 5, 68, 243, 15, 85, 13, 12, 76, 37, 22, 74, 254, 15, 130, 138, 33, 0, 4, 65, 111, 6, 137, 79, 65, 107, 16, 32, 1, 77, 200, 6, 34, 128, 128, 3, 75, 154,
	12, 37, 0, 16, 0, 0, 2, 0, 104, 115, 36, 140, 157, 68, 67, 19, 68, 51, 15, 106, 243, 15, 134, 120, 70, 37, 10, 68, 27, 10, 140, 152, 65, 121, 24, 32, 128, 94, 155, 7, 67, 11, 8, 24, 74, 11, 25, 65, 3, 12, 83, 89, 18, 82, 21, 37, 67, 200,
	5, 130, 144, 24, 64, 172, 12, 33, 4, 0, 134, 162, 74, 80, 14, 145, 184, 32, 0, 130, 0, 69, 251, 20, 32, 19, 81, 243, 5, 82, 143, 8, 33, 5, 53, 89, 203, 5, 133, 112, 79, 109, 15, 33, 0, 21, 130, 71, 80, 175, 41, 36, 75, 0, 79, 0, 83, 121,
	117, 9, 87, 89, 27, 66, 103, 11, 70, 13, 15, 75, 191, 11, 135, 67, 87, 97, 20, 109, 203, 5, 69, 246, 8, 108, 171, 5, 78, 195, 38, 65, 51, 13, 107, 203, 11, 77, 3, 17, 24, 75, 239, 17, 65, 229, 28, 79, 129, 39, 130, 175, 32, 128, 123, 253,
	7, 132, 142, 24, 65, 51, 15, 65, 239, 41, 36, 128, 128, 0, 0, 13, 65, 171, 5, 66, 163, 28, 136, 183, 118, 137, 11, 80, 255, 15, 67, 65, 7, 74, 111, 8, 32, 0, 130, 157, 32, 253, 24, 76, 35, 10, 103, 212, 5, 81, 175, 9, 69, 141, 7, 66, 150,
	29, 131, 158, 24, 75, 199, 28, 124, 185, 7, 76, 205, 15, 68, 124, 14, 32, 3, 123, 139, 16, 130, 16, 33, 128, 128, 108, 199, 6, 33, 0, 3, 65, 191, 35, 107, 11, 6, 73, 197, 11, 24, 70, 121, 15, 83, 247, 15, 24, 70, 173, 23, 69, 205, 14,
	32, 253, 131, 140, 32, 254, 136, 4, 94, 198, 9, 32, 3, 78, 4, 13, 66, 127, 13, 143, 13, 32, 0, 130, 0, 33, 16, 0, 24, 69, 59, 39, 109, 147, 12, 76, 253, 19, 24, 69, 207, 15, 69, 229, 15, 130, 195, 71, 90, 10, 139, 10, 130, 152, 73, 43,
	40, 91, 139, 10, 65, 131, 37, 35, 75, 0, 79, 0, 84, 227, 12, 143, 151, 68, 25, 15, 80, 9, 23, 95, 169, 11, 34, 128, 2, 128, 112, 186, 5, 130, 6, 83, 161, 19, 76, 50, 6, 130, 37, 65, 145, 44, 110, 83, 5, 32, 16, 67, 99, 6, 71, 67, 15, 76,
	55, 17, 140, 215, 67, 97, 23, 76, 69, 15, 77, 237, 11, 104, 211, 23, 77, 238, 11, 65, 154, 43, 33, 0, 10, 83, 15, 28, 83, 13, 20, 67, 145, 19, 67, 141, 14, 97, 149, 21, 68, 9, 15, 86, 251, 5, 66, 207, 5, 66, 27, 37, 82, 1, 23, 127, 71, 12,
	94, 235, 10, 110, 175, 24, 98, 243, 15, 132, 154, 132, 4, 24, 66, 69, 10, 32, 4, 67, 156, 43, 130, 198, 35, 2, 1, 0, 4, 75, 27, 9, 69, 85, 9, 95, 240, 7, 32, 128, 130, 35, 32, 28, 66, 43, 40, 24, 82, 63, 23, 83, 123, 12, 72, 231, 15, 127,
	59, 23, 116, 23, 19, 117, 71, 7, 24, 77, 99, 15, 67, 111, 15, 71, 101, 8, 36, 2, 128, 128, 252, 128, 127, 60, 11, 32, 1, 132, 16, 130, 18, 141, 24, 67, 107, 9, 32, 3, 68, 194, 15, 175, 15, 38, 0, 11, 0, 128, 1, 128, 2, 80, 63, 25, 32, 0,
	24, 65, 73, 11, 69, 185, 15, 83, 243, 16, 32, 0, 24, 81, 165, 8, 130, 86, 77, 35, 6, 155, 163, 88, 203, 5, 24, 66, 195, 30, 70, 19, 19, 24, 80, 133, 15, 32, 1, 75, 211, 8, 32, 254, 108, 133, 8, 79, 87, 20, 65, 32, 9, 41, 0, 0, 7, 0, 128, 0,
	0, 2, 128, 2, 68, 87, 15, 66, 1, 16, 92, 201, 16, 24, 76, 24, 17, 133, 17, 34, 128, 0, 30, 66, 127, 64, 34, 115, 0, 119, 73, 205, 9, 66, 43, 11, 109, 143, 15, 24, 79, 203, 11, 90, 143, 15, 131, 15, 155, 31, 65, 185, 15, 86, 87, 11, 35, 128,
	128, 253, 0, 69, 7, 6, 130, 213, 33, 1, 0, 119, 178, 15, 142, 17, 66, 141, 74, 83, 28, 6, 36, 7, 0, 0, 4, 128, 82, 39, 18, 76, 149, 12, 67, 69, 21, 32, 128, 79, 118, 15, 32, 0, 130, 0, 32, 8, 131, 206, 32, 2, 79, 83, 9, 100, 223, 14, 102,
	113, 23, 115, 115, 7, 24, 65, 231, 12, 130, 162, 32, 4, 68, 182, 19, 130, 102, 93, 143, 8, 69, 107, 29, 24, 77, 255, 12, 143, 197, 72, 51, 7, 76, 195, 15, 132, 139, 85, 49, 15, 130, 152, 131, 18, 71, 81, 23, 70, 14, 11, 36, 0, 10, 0, 128,
	2, 69, 59, 9, 89, 151, 15, 66, 241, 11, 76, 165, 12, 71, 43, 15, 75, 49, 13, 65, 12, 23, 132, 37, 32, 0, 179, 115, 130, 231, 95, 181, 16, 132, 77, 32, 254, 67, 224, 8, 65, 126, 20, 79, 171, 8, 32, 2, 89, 81, 5, 75, 143, 6, 80, 41, 8, 34,
	2, 0, 128, 24, 81, 72, 9, 32, 0, 130, 0, 35, 17, 0, 0, 255, 77, 99, 39, 95, 65, 36, 67, 109, 15, 24, 69, 93, 11, 77, 239, 5, 95, 77, 23, 35, 128, 1, 0, 128, 24, 86, 7, 8, 132, 167, 32, 2, 69, 198, 41, 130, 202, 33, 0, 26, 120, 75, 44, 24, 89,
	51, 15, 71, 243, 12, 70, 239, 11, 24, 84, 3, 11, 66, 7, 11, 71, 255, 10, 32, 21, 69, 155, 35, 88, 151, 12, 32, 128, 74, 38, 10, 65, 210, 8, 74, 251, 5, 65, 226, 5, 75, 201, 13, 32, 3, 65, 9, 41, 146, 41, 40, 0, 0, 0, 9, 1, 0, 1, 0, 2, 91, 99,
	19, 32, 35, 106, 119, 13, 70, 219, 15, 83, 239, 12, 137, 154, 32, 2, 67, 252, 19, 36, 128, 0, 0, 4, 1, 130, 196, 32, 2, 130, 8, 91, 107, 8, 32, 0, 135, 81, 24, 73, 211, 8, 132, 161, 73, 164, 13, 36, 0, 8, 0, 128, 2, 105, 123, 26, 139, 67,
	76, 99, 15, 34, 1, 0, 128, 135, 76, 83, 156, 20, 92, 104, 8, 67, 251, 30, 24, 86, 47, 27, 123, 207, 12, 24, 86, 7, 15, 71, 227, 8, 32, 4, 65, 20, 20, 131, 127, 32, 0, 130, 123, 32, 0, 71, 223, 26, 32, 19, 90, 195, 22, 71, 223, 15, 84, 200,
	6, 32, 128, 133, 241, 24, 84, 149, 9, 67, 41, 25, 36, 0, 0, 0, 22, 0, 88, 111, 49, 32, 87, 66, 21, 5, 77, 3, 27, 123, 75, 7, 71, 143, 19, 135, 183, 71, 183, 19, 130, 171, 74, 252, 5, 131, 5, 89, 87, 17, 32, 1, 132, 18, 130, 232, 68, 11, 10,
	33, 1, 128, 70, 208, 16, 66, 230, 18, 147, 18, 130, 254, 223, 255, 75, 27, 23, 65, 59, 15, 135, 39, 155, 255, 34, 128, 128, 254, 104, 92, 8, 33, 0, 128, 65, 32, 11, 65, 1, 58, 33, 26, 0, 130, 0, 72, 71, 18, 78, 55, 17, 76, 11, 19, 86, 101,
	12, 75, 223, 11, 89, 15, 11, 24, 76, 87, 15, 75, 235, 15, 131, 15, 72, 95, 7, 85, 71, 11, 72, 115, 11, 73, 64, 6, 34, 1, 128, 128, 66, 215, 9, 34, 128, 254, 128, 134, 14, 33, 128, 255, 67, 102, 5, 32, 0, 130, 16, 70, 38, 11, 66, 26, 57,
	88, 11, 8, 24, 76, 215, 34, 78, 139, 7, 95, 245, 7, 32, 7, 24, 73, 75, 23, 32, 128, 131, 167, 130, 170, 101, 158, 9, 82, 49, 22, 118, 139, 6, 32, 18, 67, 155, 44, 116, 187, 9, 108, 55, 14, 80, 155, 23, 66, 131, 15, 93, 77, 10, 131, 168,
	32, 128, 73, 211, 12, 24, 75, 187, 22, 32, 4, 96, 71, 20, 67, 108, 19, 132, 19, 120, 207, 8, 32, 5, 76, 79, 15, 66, 111, 21, 66, 95, 8, 32, 3, 190, 211, 111, 3, 8, 211, 212, 32, 20, 65, 167, 44, 34, 75, 0, 79, 97, 59, 13, 32, 33, 112, 63,
	10, 65, 147, 19, 69, 39, 19, 143, 39, 24, 66, 71, 9, 130, 224, 65, 185, 43, 94, 176, 12, 65, 183, 24, 71, 38, 8, 24, 72, 167, 7, 65, 191, 38, 136, 235, 24, 96, 167, 12, 65, 203, 62, 115, 131, 13, 65, 208, 42, 175, 235, 67, 127, 6, 32,
	4, 76, 171, 29, 114, 187, 5, 32, 71, 65, 211, 5, 65, 203, 68, 72, 51, 8, 164, 219, 32, 0, 172, 214, 71, 239, 58, 78, 3, 27, 66, 143, 15, 77, 19, 15, 147, 31, 35, 33, 53, 51, 21, 66, 183, 10, 173, 245, 66, 170, 30, 150, 30, 34, 0, 0, 23,
	80, 123, 54, 76, 1, 16, 73, 125, 15, 82, 245, 11, 167, 253, 24, 76, 85, 12, 70, 184, 5, 32, 254, 131, 185, 37, 254, 0, 128, 1, 0, 128, 133, 16, 117, 158, 18, 92, 27, 38, 65, 3, 17, 130, 251, 35, 17, 0, 128, 254, 24, 69, 83, 39, 140, 243,
	121, 73, 19, 109, 167, 7, 81, 41, 15, 24, 95, 175, 12, 102, 227, 15, 121, 96, 11, 24, 95, 189, 7, 32, 3, 145, 171, 154, 17, 24, 77, 47, 9, 33, 0, 5, 70, 71, 37, 68, 135, 7, 32, 29, 117, 171, 11, 69, 87, 15, 24, 79, 97, 19, 24, 79, 149, 23,
	131, 59, 32, 1, 75, 235, 5, 72, 115, 11, 72, 143, 7, 132, 188, 71, 27, 46, 131, 51, 32, 0, 69, 95, 6, 175, 215, 32, 21, 131, 167, 81, 15, 19, 151, 191, 151, 23, 131, 215, 71, 43, 5, 32, 254, 24, 79, 164, 24, 74, 109, 8, 77, 166, 13, 65,
	176, 26, 88, 162, 5, 98, 159, 6, 171, 219, 120, 247, 6, 79, 29, 8, 99, 169, 10, 103, 59, 19, 65, 209, 35, 131, 35, 91, 25, 19, 112, 94, 15, 83, 36, 8, 173, 229, 33, 20, 0, 88, 75, 43, 71, 31, 12, 65, 191, 71, 33, 1, 0, 130, 203, 32, 254,
	131, 4, 68, 66, 7, 67, 130, 6, 104, 61, 13, 173, 215, 38, 13, 1, 0, 0, 0, 2, 128, 67, 111, 28, 74, 129, 16, 104, 35, 19, 79, 161, 16, 87, 14, 7, 138, 143, 132, 10, 67, 62, 36, 114, 115, 5, 162, 151, 67, 33, 16, 108, 181, 15, 143, 151, 67,
	5, 5, 24, 100, 242, 15, 170, 153, 34, 0, 0, 14, 65, 51, 34, 32, 55, 79, 75, 9, 32, 51, 74, 7, 10, 65, 57, 38, 132, 142, 32, 254, 72, 0, 14, 139, 163, 32, 128, 80, 254, 8, 67, 158, 21, 65, 63, 7, 32, 4, 72, 227, 27, 95, 155, 12, 67, 119, 19,
	124, 91, 24, 149, 154, 72, 177, 34, 97, 223, 8, 155, 151, 24, 108, 227, 15, 88, 147, 16, 72, 117, 19, 68, 35, 11, 92, 253, 15, 70, 199, 15, 24, 87, 209, 17, 32, 2, 87, 233, 7, 32, 1, 24, 88, 195, 10, 119, 24, 8, 32, 3, 81, 227, 24, 65,
	125, 21, 35, 128, 128, 0, 25, 76, 59, 48, 24, 90, 187, 9, 97, 235, 12, 66, 61, 11, 91, 105, 19, 24, 79, 141, 11, 24, 79, 117, 15, 24, 79, 129, 27, 90, 53, 13, 130, 13, 32, 253, 131, 228, 24, 79, 133, 40, 69, 70, 8, 66, 137, 31, 65, 33,
	19, 96, 107, 8, 68, 119, 29, 66, 7, 5, 68, 125, 16, 65, 253, 19, 65, 241, 27, 24, 90, 179, 13, 24, 79, 143, 18, 33, 128, 128, 130, 246, 32, 254, 130, 168, 68, 154, 36, 77, 51, 9, 97, 47, 5, 167, 195, 32, 21, 131, 183, 78, 239, 27, 155,
	195, 78, 231, 14, 201, 196, 77, 11, 6, 32, 5, 73, 111, 37, 97, 247, 12, 77, 19, 31, 155, 207, 78, 215, 19, 162, 212, 69, 17, 14, 66, 91, 19, 80, 143, 57, 78, 203, 39, 159, 215, 32, 128, 93, 134, 8, 24, 80, 109, 24, 66, 113, 15, 169, 215,
	66, 115, 6, 32, 4, 69, 63, 33, 32, 0, 101, 113, 7, 86, 227, 35, 143, 211, 36, 49, 53, 51, 21, 1, 77, 185, 14, 65, 159, 28, 69, 251, 34, 67, 56, 8, 33, 9, 0, 24, 107, 175, 25, 90, 111, 12, 110, 251, 11, 119, 189, 24, 119, 187, 34, 87, 15,
	9, 32, 4, 66, 231, 37, 90, 39, 7, 66, 239, 8, 84, 219, 15, 69, 105, 23, 24, 85, 27, 27, 87, 31, 11, 33, 1, 128, 76, 94, 6, 32, 1, 85, 241, 7, 33, 128, 128, 106, 48, 10, 33, 128, 128, 69, 136, 11, 133, 13, 24, 79, 116, 49, 84, 236, 8, 24,
	91, 87, 9, 32, 5, 165, 255, 69, 115, 12, 66, 27, 15, 159, 15, 24, 72, 247, 12, 74, 178, 5, 24, 80, 64, 15, 33, 0, 128, 143, 17, 77, 89, 51, 130, 214, 24, 81, 43, 7, 170, 215, 74, 49, 8, 159, 199, 143, 31, 139, 215, 69, 143, 5, 32, 254,
	24, 81, 50, 35, 181, 217, 84, 123, 70, 143, 195, 159, 15, 65, 187, 16, 66, 123, 7, 65, 175, 15, 65, 193, 29, 68, 207, 39, 79, 27, 5, 70, 131, 6, 32, 4, 68, 211, 33, 33, 67, 0, 83, 143, 14, 159, 207, 143, 31, 140, 223, 33, 0, 128, 24, 80,
	82, 14, 24, 93, 16, 23, 32, 253, 65, 195, 5, 68, 227, 40, 133, 214, 107, 31, 7, 32, 5, 67, 115, 27, 87, 9, 8, 107, 31, 43, 66, 125, 6, 32, 0, 103, 177, 23, 131, 127, 72, 203, 36, 32, 0, 110, 103, 8, 155, 163, 73, 135, 6, 32, 19, 24, 112,
	99, 10, 65, 71, 11, 73, 143, 19, 143, 31, 126, 195, 5, 24, 85, 21, 9, 24, 76, 47, 14, 32, 254, 24, 93, 77, 36, 68, 207, 11, 39, 25, 0, 0, 255, 128, 3, 128, 4, 66, 51, 37, 95, 247, 13, 82, 255, 24, 76, 39, 19, 147, 221, 66, 85, 27, 24, 118,
	7, 8, 24, 74, 249, 12, 76, 74, 8, 91, 234, 8, 67, 80, 17, 131, 222, 33, 253, 0, 121, 30, 44, 73, 0, 16, 69, 15, 6, 32, 0, 65, 23, 38, 69, 231, 12, 65, 179, 6, 98, 131, 16, 86, 31, 27, 24, 108, 157, 14, 80, 160, 8, 24, 65, 46, 17, 33, 4, 0,
	96, 2, 18, 144, 191, 65, 226, 8, 68, 19, 5, 171, 199, 80, 9, 15, 180, 199, 67, 89, 5, 32, 255, 24, 79, 173, 28, 174, 201, 24, 79, 179, 50, 32, 1, 24, 122, 5, 10, 82, 61, 10, 180, 209, 83, 19, 8, 32, 128, 24, 80, 129, 27, 111, 248, 43, 131,
	71, 24, 115, 103, 8, 67, 127, 41, 78, 213, 24, 100, 247, 19, 66, 115, 39, 75, 107, 5, 32, 254, 165, 219, 78, 170, 40, 24, 112, 163, 49, 32, 1, 97, 203, 6, 65, 173, 64, 32, 0, 83, 54, 7, 133, 217, 88, 37, 12, 32, 254, 131, 28, 33, 128,
	3, 67, 71, 44, 84, 183, 6, 32, 5, 69, 223, 33, 96, 7, 7, 123, 137, 16, 192, 211, 24, 112, 14, 9, 32, 255, 67, 88, 29, 68, 14, 10, 84, 197, 38, 33, 0, 22, 116, 47, 50, 32, 87, 106, 99, 9, 116, 49, 15, 89, 225, 15, 97, 231, 23, 70, 41, 19,
	82, 85, 8, 93, 167, 6, 32, 253, 132, 236, 108, 190, 7, 89, 251, 5, 116, 49, 58, 33, 128, 128, 131, 234, 32, 15, 24, 74, 67, 38, 70, 227, 24, 24, 83, 45, 23, 89, 219, 12, 70, 187, 12, 89, 216, 19, 32, 2, 69, 185, 24, 141, 24, 70, 143, 66,
	24, 82, 119, 56, 78, 24, 10, 32, 253, 133, 149, 132, 6, 24, 106, 233, 7, 69, 198, 48, 178, 203, 81, 243, 12, 68, 211, 15, 106, 255, 23, 66, 91, 15, 69, 193, 7, 100, 39, 10, 24, 83, 72, 16, 176, 204, 33, 19, 0, 88, 207, 45, 68, 21, 12,
	68, 17, 10, 65, 157, 53, 68, 17, 6, 32, 254, 92, 67, 10, 65, 161, 25, 69, 182, 43, 24, 118, 91, 47, 69, 183, 18, 181, 209, 111, 253, 12, 89, 159, 8, 66, 112, 12, 69, 184, 45, 35, 0, 0, 0, 9, 24, 80, 227, 26, 73, 185, 16, 118, 195, 15, 131,
	15, 33, 1, 0, 65, 59, 15, 66, 39, 27, 160, 111, 66, 205, 12, 148, 111, 143, 110, 33, 128, 128, 156, 112, 24, 81, 199, 8, 75, 199, 23, 66, 117, 20, 155, 121, 32, 254, 68, 126, 12, 72, 213, 29, 134, 239, 149, 123, 89, 27, 16, 148, 117,
	65, 245, 8, 24, 71, 159, 14, 141, 134, 134, 28, 73, 51, 55, 109, 77, 15, 105, 131, 11, 68, 67, 11, 76, 169, 27, 107, 209, 12, 102, 174, 8, 32, 128, 72, 100, 18, 116, 163, 56, 79, 203, 11, 75, 183, 44, 85, 119, 19, 71, 119, 23, 151, 227,
	32, 1, 93, 27, 8, 65, 122, 5, 77, 102, 8, 110, 120, 20, 66, 23, 8, 66, 175, 17, 66, 63, 12, 133, 12, 79, 35, 8, 74, 235, 33, 67, 149, 16, 69, 243, 15, 78, 57, 15, 69, 235, 16, 67, 177, 7, 151, 192, 130, 23, 67, 84, 29, 141, 192, 174, 187,
	77, 67, 15, 69, 11, 12, 159, 187, 77, 59, 10, 199, 189, 24, 70, 235, 50, 96, 83, 19, 66, 53, 23, 105, 65, 19, 77, 47, 12, 163, 199, 66, 67, 37, 78, 207, 50, 67, 23, 23, 174, 205, 67, 228, 6, 71, 107, 13, 67, 22, 14, 66, 85, 11, 83, 187,
	38, 124, 47, 49, 95, 7, 19, 66, 83, 23, 67, 23, 19, 24, 96, 78, 17, 80, 101, 16, 71, 98, 40, 33, 0, 7, 88, 131, 22, 24, 89, 245, 12, 84, 45, 12, 102, 213, 5, 123, 12, 9, 32, 2, 126, 21, 14, 43, 255, 0, 128, 128, 0, 0, 20, 0, 128, 255, 128,
	3, 126, 19, 39, 32, 75, 106, 51, 7, 113, 129, 15, 24, 110, 135, 19, 126, 47, 15, 115, 117, 11, 69, 47, 11, 32, 2, 109, 76, 9, 102, 109, 9, 32, 128, 75, 2, 10, 130, 21, 32, 254, 69, 47, 6, 32, 3, 94, 217, 47, 32, 0, 65, 247, 10, 69, 15, 46,
	65, 235, 31, 65, 243, 15, 101, 139, 10, 66, 174, 14, 65, 247, 16, 72, 102, 28, 69, 17, 14, 84, 243, 9, 165, 191, 88, 47, 48, 66, 53, 12, 32, 128, 71, 108, 6, 203, 193, 32, 17, 75, 187, 42, 73, 65, 16, 65, 133, 52, 114, 123, 9, 167, 199,
	69, 21, 37, 86, 127, 44, 75, 171, 11, 180, 197, 78, 213, 12, 148, 200, 81, 97, 46, 24, 95, 243, 9, 32, 4, 66, 75, 33, 113, 103, 9, 87, 243, 36, 143, 225, 24, 84, 27, 31, 90, 145, 8, 148, 216, 67, 49, 5, 24, 84, 34, 14, 75, 155, 27, 67,
	52, 13, 140, 13, 36, 0, 20, 0, 128, 255, 24, 135, 99, 46, 88, 59, 43, 155, 249, 80, 165, 7, 136, 144, 71, 161, 23, 32, 253, 132, 33, 32, 254, 88, 87, 44, 136, 84, 35, 128, 0, 0, 21, 81, 103, 5, 94, 47, 44, 76, 51, 12, 143, 197, 151, 15,
	65, 215, 31, 24, 64, 77, 13, 65, 220, 20, 65, 214, 14, 71, 4, 40, 65, 213, 13, 32, 0, 130, 0, 35, 21, 1, 2, 0, 135, 0, 34, 36, 0, 72, 134, 10, 36, 1, 0, 26, 0, 130, 134, 11, 36, 2, 0, 14, 0, 108, 134, 11, 32, 3, 138, 23, 32, 4, 138, 11, 34,
	5, 0, 20, 134, 33, 34, 0, 0, 6, 132, 23, 32, 1, 134, 15, 32, 18, 130, 25, 133, 11, 37, 1, 0, 13, 0, 49, 0, 133, 11, 36, 2, 0, 7, 0, 38, 134, 11, 36, 3, 0, 17, 0, 45, 134, 11, 32, 4, 138, 35, 36, 5, 0, 10, 0, 62, 134, 23, 32, 6, 132, 23, 36, 3,
	0, 1, 4, 9, 130, 87, 131, 167, 133, 11, 133, 167, 133, 11, 133, 167, 133, 11, 37, 3, 0, 34, 0, 122, 0, 133, 11, 133, 167, 133, 11, 133, 167, 133, 11, 133, 167, 34, 50, 0, 48, 130, 1, 34, 52, 0, 47, 134, 5, 8, 49, 49, 0, 53, 98, 121, 32,
	84, 114, 105, 115, 116, 97, 110, 32, 71, 114, 105, 109, 109, 101, 114, 82, 101, 103, 117, 108, 97, 114, 84, 84, 88, 32, 80, 114, 111, 103, 103, 121, 67, 108, 101, 97, 110, 84, 84, 50, 48, 48, 52, 47, 130, 2, 53, 49, 53, 0, 98, 0, 121,
	0, 32, 0, 84, 0, 114, 0, 105, 0, 115, 0, 116, 0, 97, 0, 110, 130, 15, 32, 71, 132, 15, 36, 109, 0, 109, 0, 101, 130, 9, 32, 82, 130, 5, 36, 103, 0, 117, 0, 108, 130, 29, 32, 114, 130, 43, 34, 84, 0, 88, 130, 35, 32, 80, 130, 25, 34, 111,
	0, 103, 130, 1, 34, 121, 0, 67, 130, 27, 32, 101, 132, 59, 32, 84, 130, 31, 33, 0, 0, 65, 155, 9, 34, 20, 0, 0, 65, 11, 6, 130, 8, 135, 2, 33, 1, 1, 130, 9, 8, 120, 1, 1, 2, 1, 3, 1, 4, 1, 5, 1, 6, 1, 7, 1, 8, 1, 9, 1, 10, 1, 11, 1, 12, 1, 13, 1, 14,
	1, 15, 1, 16, 1, 17, 1, 18, 1, 19, 1, 20, 1, 21, 1, 22, 1, 23, 1, 24, 1, 25, 1, 26, 1, 27, 1, 28, 1, 29, 1, 30, 1, 31, 1, 32, 0, 3, 0, 4, 0, 5, 0, 6, 0, 7, 0, 8, 0, 9, 0, 10, 0, 11, 0, 12, 0, 13, 0, 14, 0, 15, 0, 16, 0, 17, 0, 18, 0, 19, 0, 20, 0, 21, 0,
	22, 0, 23, 0, 24, 0, 25, 0, 26, 0, 27, 0, 28, 0, 29, 0, 30, 0, 31, 130, 187, 8, 66, 33, 0, 34, 0, 35, 0, 36, 0, 37, 0, 38, 0, 39, 0, 40, 0, 41, 0, 42, 0, 43, 0, 44, 0, 45, 0, 46, 0, 47, 0, 48, 0, 49, 0, 50, 0, 51, 0, 52, 0, 53, 0, 54, 0, 55, 0, 56, 0,
	57, 0, 58, 0, 59, 0, 60, 0, 61, 0, 62, 0, 63, 0, 64, 0, 65, 0, 66, 130, 243, 9, 75, 68, 0, 69, 0, 70, 0, 71, 0, 72, 0, 73, 0, 74, 0, 75, 0, 76, 0, 77, 0, 78, 0, 79, 0, 80, 0, 81, 0, 82, 0, 83, 0, 84, 0, 85, 0, 86, 0, 87, 0, 88, 0, 89, 0, 90, 0, 91, 0,
	92, 0, 93, 0, 94, 0, 95, 0, 96, 0, 97, 1, 33, 1, 34, 1, 35, 1, 36, 1, 37, 1, 38, 1, 39, 1, 40, 1, 41, 1, 42, 1, 43, 1, 44, 1, 45, 1, 46, 1, 47, 1, 48, 1, 49, 1, 50, 1, 51, 1, 52, 1, 53, 1, 54, 1, 55, 1, 56, 1, 57, 1, 58, 1, 59, 1, 60, 1, 61, 1, 62, 1,
	63, 1, 64, 1, 65, 0, 172, 0, 163, 0, 132, 0, 133, 0, 189, 0, 150, 0, 232, 0, 134, 0, 142, 0, 139, 0, 157, 0, 169, 0, 164, 0, 239, 0, 138, 0, 218, 0, 131, 0, 147, 0, 242, 0, 243, 0, 141, 0, 151, 0, 136, 0, 195, 0, 222, 0, 241, 0, 158, 0, 170,
	0, 245, 0, 244, 0, 246, 0, 162, 0, 173, 0, 201, 0, 199, 0, 174, 0, 98, 0, 99, 0, 144, 0, 100, 0, 203, 0, 101, 0, 200, 0, 202, 0, 207, 0, 204, 0, 205, 0, 206, 0, 233, 0, 102, 0, 211, 0, 208, 0, 209, 0, 175, 0, 103, 0, 240, 0, 145, 0, 214, 0,
	212, 0, 213, 0, 104, 0, 235, 0, 237, 0, 137, 0, 106, 0, 105, 0, 107, 0, 109, 0, 108, 0, 110, 0, 160, 0, 111, 0, 113, 0, 112, 0, 114, 0, 115, 0, 117, 0, 116, 0, 118, 0, 119, 0, 234, 0, 120, 0, 122, 0, 121, 0, 123, 0, 125, 0, 124, 0, 184, 0,
	161, 0, 127, 0, 126, 0, 128, 0, 129, 0, 236, 0, 238, 0, 186, 14, 117, 110, 105, 99, 111, 100, 101, 35, 48, 120, 48, 48, 48, 49, 141, 14, 32, 50, 141, 14, 32, 51, 141, 14, 32, 52, 141, 14, 32, 53, 141, 14, 32, 54, 141, 14, 32, 55, 141,
	14, 32, 56, 141, 14, 32, 57, 141, 14, 32, 97, 141, 14, 32, 98, 141, 14, 32, 99, 141, 14, 32, 100, 141, 14, 32, 101, 141, 14, 32, 102, 140, 14, 33, 49, 48, 141, 14, 141, 239, 32, 49, 141, 239, 32, 49, 141, 239, 32, 49, 141, 239, 32, 49,
	141, 239, 32, 49, 141, 239, 32, 49, 141, 239, 32, 49, 141, 239, 32, 49, 141, 239, 32, 49, 141, 239, 32, 49, 141, 239, 32, 49, 141, 239, 32, 49, 141, 239, 32, 49, 141, 239, 45, 49, 102, 6, 100, 101, 108, 101, 116, 101, 4, 69, 117, 114,
	111, 140, 236, 32, 56, 141, 236, 32, 56, 141, 236, 32, 56, 141, 236, 32, 56, 141, 236, 32, 56, 141, 236, 32, 56, 141, 236, 32, 56, 141, 236, 32, 56, 141, 236, 32, 56, 141, 236, 32, 56, 141, 236, 32, 56, 141, 236, 32, 56, 141, 236,
	32, 56, 141, 236, 32, 56, 141, 236, 32, 56, 65, 220, 13, 32, 57, 65, 220, 13, 32, 57, 141, 239, 32, 57, 141, 239, 32, 57, 141, 239, 32, 57, 141, 239, 32, 57, 141, 239, 32, 57, 141, 239, 32, 57, 141, 239, 32, 57, 141, 239, 32, 57, 141,
	239, 32, 57, 141, 239, 32, 57, 141, 239, 32, 57, 141, 239, 32, 57, 141, 239, 32, 57, 141, 239, 35, 57, 102, 0, 0, 5, 250, 72, 249, 98, 247,
}

GetDefaultCompressedFontDataTTF :: proc(out_size : ^i32) -> [^]u8
{
	out_size^ = cast(i32) proggy_clean_ttf_compressed_size
	return raw_data(&proggy_clean_ttf_compressed_data)
}
} // preproc endif// #ifndef IMGUI_DISABLE_DEFAULT_FONT

//
// imgui_widgets.cpp
//
// dear imgui, v1.91.7 WIP
// (widgets code)

/*

Index of this file:

// [SECTION] Forward Declarations
// [SECTION] Widgets: Text, etc.
// [SECTION] Widgets: Main (Button, Image, Checkbox, RadioButton, ProgressBar, Bullet, etc.)
// [SECTION] Widgets: Low-level Layout helpers (Spacing, Dummy, NewLine, Separator, etc.)
// [SECTION] Widgets: ComboBox
// [SECTION] Data Type and Data Formatting Helpers
// [SECTION] Widgets: DragScalar, DragFloat, DragInt, etc.
// [SECTION] Widgets: SliderScalar, SliderFloat, SliderInt, etc.
// [SECTION] Widgets: InputScalar, InputFloat, InputInt, etc.
// [SECTION] Widgets: InputText, InputTextMultiline
// [SECTION] Widgets: ColorEdit, ColorPicker, ColorButton, etc.
// [SECTION] Widgets: TreeNode, CollapsingHeader, etc.
// [SECTION] Widgets: Selectable
// [SECTION] Widgets: Typing-Select support
// [SECTION] Widgets: Box-Select support
// [SECTION] Widgets: Multi-Select support
// [SECTION] Widgets: Multi-Select helpers
// [SECTION] Widgets: ListBox
// [SECTION] Widgets: PlotLines, PlotHistogram
// [SECTION] Widgets: Value helpers
// [SECTION] Widgets: MenuItem, BeginMenu, EndMenu, etc.
// [SECTION] Widgets: BeginTabBar, EndTabBar, etc.
// [SECTION] Widgets: BeginTabItem, EndTabItem, etc.
// [SECTION] Widgets: Columns, BeginColumns, EndColumns, etc.

*/

//-------------------------------------------------------------------------
// Data
//-------------------------------------------------------------------------

// Widgets
DRAGDROP_HOLD_TO_OPEN_TIMER : f32 = 0.70; // Time for drag-hold to activate items accepting the ImGuiButtonFlags_PressedOnDragDropHold button behavior.
DRAG_MOUSE_THRESHOLD_FACTOR : f32 = 0.50; // Multiplier for the default value of io.MouseDragThreshold to make DragFloat/DragInt react faster to mouse drags.

// Those MIN/MAX values are not define because we need to point to them
IM_S8_MIN : i8 = -128
IM_S8_MAX : i8 = 127
IM_U8_MIN : u8 = 0
IM_U8_MAX : u8 = 0xFF
IM_S16_MIN : i16 = -32768
IM_S16_MAX : i16 = 32767
IM_U16_MIN : u16 = 0
IM_U16_MAX : u16 = 0xFFFF
IM_S32_MIN : ImS32 = min(ImS32); // (-2147483647 - 1), (0x80000000);
IM_S32_MAX : ImS32 = max(ImS32); // (2147483647), (0x7FFFFFFF)
IM_U32_MIN : ImU32 = 0
IM_U32_MAX : ImU32 = max(ImU32); // (0xFFFFFFFF)
IM_S64_MIN : ImS64 = min(ImS64); // (-9223372036854775807ll - 1ll);
IM_S64_MAX : ImS64 = max(ImS64); // (9223372036854775807ll);
IM_U64_MIN : ImU64 = 0
IM_U64_MAX : ImU64 = max(ImU64); // (0xFFFFFFFFFFFFFFFFull);

//-------------------------------------------------------------------------
// [SECTION] Widgets: Text, etc.
//-------------------------------------------------------------------------
// - TextEx() [Internal]
// - TextUnformatted()
// - Text()
// - TextV()
// - TextColored()
// - TextColoredV()
// - TextDisabled()
// - TextDisabledV()
// - TextWrapped()
// - TextWrappedV()
// - LabelText()
// - LabelTextV()
// - BulletText()
// - BulletTextV()
//-------------------------------------------------------------------------

TextEx :: proc(text : string, flags : ImGuiTextFlags = {})
{
	window : ^ImGuiWindow = GetCurrentWindow()
	if window.SkipItems { return }
	g : ^ImGuiContext = GImGui

	text := text;
	text_begin : string = text

	text_pos := ImVec2 { window.DC.CursorPos.x, window.DC.CursorPos.y + window.DC.CurrLineTextBaseOffset }
	wrap_pos_x : f32 = window.DC.TextWrapPos
	wrap_enabled : bool = (wrap_pos_x >= 0.0)
	if len(text) <= 2000 || wrap_enabled {
		// Common case
		wrap_width : f32 = wrap_enabled ? CalcWrapWidthForPos(window.DC.CursorPos, wrap_pos_x) : 0.0
		text_size : ImVec2 = CalcTextSize(text_begin, false, wrap_width)

		bb : ImRect; init(&bb, text_pos, text_pos + text_size)
		ItemSize(text_size, 0.0)
		if !ItemAdd(bb, 0) { return }

		// Render (we don't hide text after ## in this end-user function)
		RenderTextWrapped(bb.Min, text_begin, wrap_width)
	}
	else {
		// Long text!
		// Perform manual coarse clipping to optimize for long multi-line text
		// - From this point we will only compute the width of lines that are visible. Optimization only available when word-wrapping is disabled.
		// - We also don't vertically center the text within the line full height, which is unlikely to matter because we are likely the biggest and only item on the line.
		// - We use memchr(), pay attention that well optimized versions of those str/mem functions are much faster than a casually written loop.
		line : [^]u8 = raw_data(text)
		text_end := &line[len(text)]
		line_height : f32 = GetTextLineHeight()
		text_size := ImVec2{ 0, 0 }

		// Lines to skip (can't skip when logging text)
		pos : ImVec2 = text_pos
		if !g.LogEnabled {
			lines_skippable : i32 = cast(i32) ((window.ClipRect.Min.y - text_pos.y) / line_height)
			if lines_skippable > 0 {
				lines_skipped : i32 = 0
				for line < text_end && lines_skipped < lines_skippable {
					line_end : ^u8 = cast(^u8) memchr(line, '\n', mem.ptr_sub(text_end, cast(^u8)line))
					if line_end == nil { line_end = text_end }
					if (flags & ImGuiTextFlags_.ImGuiTextFlags_NoWidthForLargeClippedText) == {} { text_size.x = ImMax(text_size.x, CalcTextSize(string_from_se(line, line_end)).x) }
					line = mem.ptr_offset(line_end, 1)
					post_incr(&lines_skipped)
				}

				pos.y += cast(f32)lines_skipped * line_height
			}
		}

		// Lines to render
		if line < text_end {
			line_rect : ImRect; init(&line_rect, pos, pos + ImVec2{FLT_MAX, line_height})
			for line < text_end {
				if IsClippedEx(line_rect, 0) { break }

				line_end : ^u8 = cast(^u8) memchr(line, '\n', mem.ptr_sub(text_end, cast(^u8)line))
				if line_end == nil { line_end = text_end }
				l := string_from_se(line, line_end)
				text_size.x = ImMax(text_size.x, CalcTextSize(l).x)
				RenderText(pos, l, false)
				line = cast([^]u8)mem.ptr_offset(line_end, 1)
				line_rect.Min.y += line_height
				line_rect.Max.y += line_height
				pos.y += line_height
			}

			// Count remaining lines
			lines_skipped : i32 = 0
			for line < text_end {
				line_end : ^u8 = cast(^u8) memchr(line, '\n', mem.ptr_sub(text_end, cast(^u8)line))
				if line_end == nil { line_end = text_end }
				if (flags & ImGuiTextFlags_.ImGuiTextFlags_NoWidthForLargeClippedText) == {} { text_size.x = ImMax(text_size.x, CalcTextSize(string_from_se(line, line_end)).x) }
				line = mem.ptr_offset(line_end, 1)
				post_incr(&lines_skipped)
			}

			pos.y += cast(f32)lines_skipped * line_height
		}
		text_size.y = (pos - text_pos).y

		bb : ImRect; init(&bb, text_pos, text_pos + text_size)
		ItemSize(text_size, 0.0)
		ItemAdd(bb, 0)
	}
}

TextUnformatted :: proc(text : string)
{
	TextEx(text, ImGuiTextFlags_.ImGuiTextFlags_NoWidthForLargeClippedText)
}

TextV :: proc(fmt : string, args : []any) { Text(fmt, ..args) }

Text :: proc(fmt : string, args : ..any)
{
	window : ^ImGuiWindow = GetCurrentWindow()
	if window.SkipItems { return }

	text : [^]u8; text_end : ^u8
	ImFormatStringToTempBufferV(&text, &text_end, fmt, args)
	TextEx(string_from_se(text, text_end), ImGuiTextFlags_.ImGuiTextFlags_NoWidthForLargeClippedText)
}

TextColored :: proc(col : ImVec4, fmt : string, args : ..any)
{
	TextColoredV(col, fmt, args)
}

TextColoredV :: proc(col : ImVec4, fmt : string, args : []any)
{
	PushStyleColor(ImGuiCol_.ImGuiCol_Text, col)
	TextV(fmt, args)
	PopStyleColor()
}

TextDisabled :: #force_inline proc(fmt : string, args : ..any)
{
	TextDisabledV(fmt, args)
}

TextDisabledV :: proc(fmt : string, args : []any)
{
	g : ^ImGuiContext = GImGui
	PushStyleColor(ImGuiCol_.ImGuiCol_Text, g.Style.Colors[ImGuiCol_.ImGuiCol_TextDisabled])
	TextV(fmt, args)
	PopStyleColor()
}

TextWrapped :: proc(fmt : string, args : ..any)
{
	TextWrappedV(fmt, args)
}

TextWrappedV :: proc(fmt : string, args : []any)
{
	g : ^ImGuiContext = GImGui
	need_backup : bool = (g.CurrentWindow.DC.TextWrapPos < 0.0); // Keep existing wrap position if one is already set
	if need_backup { PushTextWrapPos(0.0) }
	TextV(fmt, args)
	if need_backup { PopTextWrapPos() }
}

LabelText :: proc(label : string, fmt : string, args : ..any)
{
	LabelTextV(label, fmt, args)
}

// Add a label+text combo aligned to other label+value widgets
LabelTextV :: proc(label : string, fmt : string, args : []any)
{
	window : ^ImGuiWindow = GetCurrentWindow()
	if window.SkipItems { return }

	g : ^ImGuiContext = GImGui
	style : ^ImGuiStyle = &g.Style
	w : f32 = CalcItemWidth()

	value_text_begin : [^]u8; value_text_end : ^u8
	ImFormatStringToTempBufferV(&value_text_begin, &value_text_end, fmt, args)
	value_size : ImVec2 = CalcTextSize(string_from_se(value_text_begin, value_text_end), false)
	label_size : ImVec2 = CalcTextSize(label, true)

	pos : ImVec2 = window.DC.CursorPos
	value_bb : ImRect; init(&value_bb, pos, pos + ImVec2{w, value_size.y + style.FramePadding.y * 2})
	total_bb : ImRect; init(&total_bb, pos, pos + ImVec2{w + (label_size.x > 0.0 ? style.ItemInnerSpacing.x + label_size.x : 0.0), ImMax(value_size.y, label_size.y) + style.FramePadding.y * 2})
	ItemSize(total_bb, style.FramePadding.y)
	if !ItemAdd(total_bb, 0) { return }

	// Render
	RenderTextClipped(value_bb.Min + style.FramePadding, value_bb.Max, string_from_se(value_text_begin, value_text_end), &value_size, &ImVec2{0.0, 0.0})
	if label_size.x > 0.0 { RenderText(ImVec2{value_bb.Max.x + style.ItemInnerSpacing.x, value_bb.Min.y + style.FramePadding.y}, label) }
}

// Text with a little bullet aligned to the typical tree node.
BulletText :: proc(fmt : string, args : ..any)
{
	window : ^ImGuiWindow = GetCurrentWindow()
	if window.SkipItems { return }

	g : ^ImGuiContext = GImGui
	style : ^ImGuiStyle = &g.Style

	text_begin : [^]u8; text_end : ^u8
	ImFormatStringToTempBufferV(&text_begin, &text_end, fmt, args)
	text := string_from_se(text_begin, text_end)
	label_size : ImVec2 = CalcTextSize(text, false)
	total_size : ImVec2 = ImVec2{g.FontSize + (label_size.x > 0.0 ? (label_size.x + style.FramePadding.x * 2) : 0.0), label_size.y}; // Empty text doesn't add padding
	pos : ImVec2 = window.DC.CursorPos
	pos.y += window.DC.CurrLineTextBaseOffset
	ItemSize(total_size, 0.0)
	bb : ImRect; init(&bb, pos, pos + total_size)
	if !ItemAdd(bb, 0) { return }

	// Render
	text_col : ImU32 = GetColorU32(ImGuiCol_.ImGuiCol_Text)
	RenderBullet(window.DrawList, bb.Min + ImVec2{style.FramePadding.x + g.FontSize * 0.5, g.FontSize * 0.5}, text_col)
	RenderText(bb.Min + ImVec2{g.FontSize + style.FramePadding.x * 2, 0.0}, text, false)
}

//-------------------------------------------------------------------------
// [SECTION] Widgets: Main
//-------------------------------------------------------------------------
// - ButtonBehavior() [Internal]
// - Button()
// - SmallButton()
// - InvisibleButton()
// - ArrowButton()
// - CloseButton() [Internal]
// - CollapseButton() [Internal]
// - GetWindowScrollbarID() [Internal]
// - GetWindowScrollbarRect() [Internal]
// - Scrollbar() [Internal]
// - ScrollbarEx() [Internal]
// - Image()
// - ImageButton()
// - Checkbox()
// - CheckboxFlagsT() [Internal]
// - CheckboxFlags()
// - RadioButton()
// - ProgressBar()
// - Bullet()
// - Hyperlink()
//-------------------------------------------------------------------------

// The ButtonBehavior() function is key to many interactions and used by many/most widgets.
// Because we handle so many cases (keyboard/gamepad navigation, drag and drop) and many specific behavior (via ImGuiButtonFlags_),
// this code is a little complex.
// By far the most common path is interacting with the Mouse using the default ImGuiButtonFlags_PressedOnClickRelease button behavior.
// See the series of events below and the corresponding state reported by dear imgui:
//------------------------------------------------------------------------------------------------------------------------------------------------
// with PressedOnClickRelease:             return-value  IsItemHovered()  IsItemActive()  IsItemActivated()  IsItemDeactivated()  IsItemClicked()
//   Frame N+0 (mouse is outside bb)        -             -                -               -                  -                    -
//   Frame N+1 (mouse moves inside bb)      -             true             -               -                  -                    -
//   Frame N+2 (mouse button is down)       -             true             true            true               -                    true
//   Frame N+3 (mouse button is down)       -             true             true            -                  -                    -
//   Frame N+4 (mouse moves outside bb)     -             -                true            -                  -                    -
//   Frame N+5 (mouse moves inside bb)      -             true             true            -                  -                    -
//   Frame N+6 (mouse button is released)   true          true             -               -                  true                 -
//   Frame N+7 (mouse button is released)   -             true             -               -                  -                    -
//   Frame N+8 (mouse moves outside bb)     -             -                -               -                  -                    -
//------------------------------------------------------------------------------------------------------------------------------------------------
// with PressedOnClick:                    return-value  IsItemHovered()  IsItemActive()  IsItemActivated()  IsItemDeactivated()  IsItemClicked()
//   Frame N+2 (mouse button is down)       true          true             true            true               -                    true
//   Frame N+3 (mouse button is down)       -             true             true            -                  -                    -
//   Frame N+6 (mouse button is released)   -             true             -               -                  true                 -
//   Frame N+7 (mouse button is released)   -             true             -               -                  -                    -
//------------------------------------------------------------------------------------------------------------------------------------------------
// with PressedOnRelease:                  return-value  IsItemHovered()  IsItemActive()  IsItemActivated()  IsItemDeactivated()  IsItemClicked()
//   Frame N+2 (mouse button is down)       -             true             -               -                  -                    true
//   Frame N+3 (mouse button is down)       -             true             -               -                  -                    -
//   Frame N+6 (mouse button is released)   true          true             -               -                  -                    -
//   Frame N+7 (mouse button is released)   -             true             -               -                  -                    -
//------------------------------------------------------------------------------------------------------------------------------------------------
// with PressedOnDoubleClick:              return-value  IsItemHovered()  IsItemActive()  IsItemActivated()  IsItemDeactivated()  IsItemClicked()
//   Frame N+0 (mouse button is down)       -             true             -               -                  -                    true
//   Frame N+1 (mouse button is down)       -             true             -               -                  -                    -
//   Frame N+2 (mouse button is released)   -             true             -               -                  -                    -
//   Frame N+3 (mouse button is released)   -             true             -               -                  -                    -
//   Frame N+4 (mouse button is down)       true          true             true            true               -                    true
//   Frame N+5 (mouse button is down)       -             true             true            -                  -                    -
//   Frame N+6 (mouse button is released)   -             true             -               -                  true                 -
//   Frame N+7 (mouse button is released)   -             true             -               -                  -                    -
//------------------------------------------------------------------------------------------------------------------------------------------------
// Note that some combinations are supported,
// - PressedOnDragDropHold can generally be associated with any flag.
// - PressedOnDoubleClick can be associated by PressedOnClickRelease/PressedOnRelease, in which case the second release event won't be reported.
//------------------------------------------------------------------------------------------------------------------------------------------------
// The behavior of the return-value changes when ImGuiItemFlags_ButtonRepeat is set:
//                                         Repeat+                  Repeat+           Repeat+             Repeat+
//                                         PressedOnClickRelease    PressedOnClick    PressedOnRelease    PressedOnDoubleClick
//-------------------------------------------------------------------------------------------------------------------------------------------------
//   Frame N+0 (mouse button is down)       -                        true              -                   true
//   ...                                    -                        -                 -                   -
//   Frame N + RepeatDelay                  true                     true              -                   true
//   ...                                    -                        -                 -                   -
//   Frame N + RepeatDelay + RepeatRate*N   true                     true              -                   true
//-------------------------------------------------------------------------------------------------------------------------------------------------

// - FIXME: For refactor we could output flags, incl mouse hovered vs nav keyboard vs nav triggered etc.
//   And better standardize how widgets use 'GetColor32((held && hovered) ? ... : hovered ? ...)' vs 'GetColor32(held ? ... : hovered ? ...);'
//   For mouse feedback we typically prefer the 'held && hovered' test, but for nav feedback not always. Outputting hovered=true on Activation may be misleading.
// - Since v1.91.2 (Sept 2024) we included io.ConfigDebugHighlightIdConflicts feature.
//   One idiom which was previously valid which will now emit a warning is when using multiple overlayed ButtonBehavior()
//   with same ID and different MouseButton (see #8030). You can fix it by:
//       (1) switching to use a single ButtonBehavior() with multiple _MouseButton flags.
//    or (2) surrounding those calls with PushItemFlag(ImGuiItemFlags_AllowDuplicateId, true); ... PopItemFlag()
ButtonBehavior :: proc(bb : ImRect, id : ImGuiID, out_hovered : ^bool, out_held : ^bool, flags : ImGuiButtonFlags = {}) -> bool
{
	g : ^ImGuiContext = GImGui
	window : ^ImGuiWindow = GetCurrentWindow()
	flags := flags

	// Default behavior inherited from item flags
	// Note that _both_ ButtonFlags and ItemFlags are valid sources, so copy one into the item_flags and only check that.
	item_flags : ImGuiItemFlags = (g.LastItemData.ID == id ? g.LastItemData.ItemFlags : g.CurrentItemFlags)
	if (flags & cast(ImGuiButtonFlags) ImGuiButtonFlagsPrivate_.ImGuiButtonFlags_AllowOverlap) != {} { item_flags |= cast(ImGuiItemFlags) ImGuiItemFlagsPrivate_.ImGuiItemFlags_AllowOverlap }

	// Default only reacts to left mouse button
	if (flags & ImGuiButtonFlags_.ImGuiButtonFlags_MouseButtonMask_) == {} { flags |= ImGuiButtonFlags_.ImGuiButtonFlags_MouseButtonLeft }

	// Default behavior requires click + release inside bounding box
	if (flags & cast(ImGuiButtonFlags) ImGuiButtonFlagsPrivate_.ImGuiButtonFlags_PressedOnMask_) == {} { flags |= cast(ImGuiButtonFlags) ((item_flags & ImGuiItemFlags_.ImGuiItemFlags_ButtonRepeat) != {} ? ImGuiButtonFlagsPrivate_.ImGuiButtonFlags_PressedOnClick : ImGuiButtonFlagsPrivate_.ImGuiButtonFlags_PressedOnDefault_) }

	backup_hovered_window : ^ImGuiWindow = g.HoveredWindow
	flatten_hovered_children : bool = (flags & cast(ImGuiButtonFlags) ImGuiButtonFlagsPrivate_.ImGuiButtonFlags_FlattenChildren) != {} && g.HoveredWindow != nil && g.HoveredWindow.RootWindowDockTree == window.RootWindowDockTree
	if flatten_hovered_children { g.HoveredWindow = window }

	when IMGUI_ENABLE_TEST_ENGINE { /* @gen ifdef */
	// Alternate registration spot, for when caller didn't use ItemAdd()
	if g.LastItemData.ID != id { IMGUI_TEST_ENGINE_ITEM_ADD(id, bb, nil) }
	} // preproc endif

	pressed : bool = false
	hovered : bool = ItemHoverable(bb, id, item_flags)

	// Special mode for Drag and Drop where holding button pressed for a long time while dragging another item triggers the button
	if g.DragDropActive && (flags & cast(ImGuiButtonFlags) ImGuiButtonFlagsPrivate_.ImGuiButtonFlags_PressedOnDragDropHold) != {} && (g.DragDropSourceFlags & ImGuiDragDropFlags_.ImGuiDragDropFlags_SourceNoHoldToOpenOthers) == {} {
		if IsItemHovered(ImGuiHoveredFlags_.ImGuiHoveredFlags_AllowWhenBlockedByActiveItem) {
			hovered = true
			SetHoveredID(id)
			if g.HoveredIdTimer - g.IO.DeltaTime <= DRAGDROP_HOLD_TO_OPEN_TIMER && g.HoveredIdTimer >= DRAGDROP_HOLD_TO_OPEN_TIMER {
				pressed = true
				g.DragDropHoldJustPressedId = id
				FocusWindow(window)
			}
		}
	}

	if flatten_hovered_children { g.HoveredWindow = backup_hovered_window }

	// Mouse handling
	test_owner_id : ImGuiID = (flags & cast(ImGuiButtonFlags) ImGuiButtonFlagsPrivate_.ImGuiButtonFlags_NoTestKeyOwner) != {} ? ImGuiKeyOwner_Any : id
	if hovered {
		IM_ASSERT(id != 0); // Lazily check inside rare path.

		// Poll mouse buttons
		// - 'mouse_button_clicked' is generally carried into ActiveIdMouseButton when setting ActiveId.
		// - Technically we only need some values in one code path, but since this is gated by hovered test this is fine.
		mouse_button_clicked : i32 = -1
		mouse_button_released : i32 = -1
		for button : i32 = 0; button < 3; button += 1 { if (flags & cast(ImGuiButtonFlags) ((cast(i32) ImGuiButtonFlags_.ImGuiButtonFlags_MouseButtonLeft) << cast(u32) button)) != {} {
	// Handle ImGuiButtonFlags_MouseButtonRight and ImGuiButtonFlags_MouseButtonMiddle here.
	if IsMouseClicked(cast(ImGuiMouseButton) button, ImGuiInputFlags_.ImGuiInputFlags_None, test_owner_id) && mouse_button_clicked == -1 { mouse_button_clicked = button }
	if IsMouseReleased(cast(ImGuiMouseButton) button, test_owner_id) && mouse_button_released == -1 { mouse_button_released = button } } }

		// Process initial action
		mods_ok : bool = (flags & cast(ImGuiButtonFlags) ImGuiButtonFlagsPrivate_.ImGuiButtonFlags_NoKeyModsAllowed) == {} || (!g.IO.KeyCtrl && !g.IO.KeyShift && !g.IO.KeyAlt)
		if mods_ok {
			if mouse_button_clicked != -1 && g.ActiveId != id {
				if (flags & cast(ImGuiButtonFlags) ImGuiButtonFlagsPrivate_.ImGuiButtonFlags_NoSetKeyOwner) == {} { SetKeyOwner(MouseButtonToKey(cast(ImGuiMouseButton) mouse_button_clicked), id) }
				if (flags & cast(ImGuiButtonFlags) (ImGuiButtonFlagsPrivate_.ImGuiButtonFlags_PressedOnClickRelease | ImGuiButtonFlagsPrivate_.ImGuiButtonFlags_PressedOnClickReleaseAnywhere)) != {} {
					SetActiveID(id, window)
					g.ActiveIdMouseButton = cast(ImGuiMouseButton) mouse_button_clicked
					if (flags & cast(ImGuiButtonFlags) ImGuiButtonFlagsPrivate_.ImGuiButtonFlags_NoNavFocus) == {} {
						SetFocusID(id, window)
						FocusWindow(window)
					}
					else {
						FocusWindow(window, ImGuiFocusRequestFlags_.ImGuiFocusRequestFlags_RestoreFocusedChild); // Still need to focus and bring to front, but try to avoid losing NavId when navigating a child
					}
				}
				if (flags & cast(ImGuiButtonFlags) ImGuiButtonFlagsPrivate_.ImGuiButtonFlags_PressedOnClick) != {} || ((flags & cast(ImGuiButtonFlags) ImGuiButtonFlagsPrivate_.ImGuiButtonFlags_PressedOnDoubleClick) != {} && g.IO.MouseClickedCount[mouse_button_clicked] == 2) {
					pressed = true
					if (flags & cast(ImGuiButtonFlags) ImGuiButtonFlagsPrivate_.ImGuiButtonFlags_NoHoldingActiveId) != {} { ClearActiveID() }
					else {
						// Hold on ID
						SetActiveID(id, window)
					}
					g.ActiveIdMouseButton = cast(ImGuiMouseButton) mouse_button_clicked
					if (flags & cast(ImGuiButtonFlags) ImGuiButtonFlagsPrivate_.ImGuiButtonFlags_NoNavFocus) == {} {
						SetFocusID(id, window)
						FocusWindow(window)
					}
					else {
						FocusWindow(window, ImGuiFocusRequestFlags_.ImGuiFocusRequestFlags_RestoreFocusedChild); // Still need to focus and bring to front, but try to avoid losing NavId when navigating a child
					}
				}
			}
			if (flags & cast(ImGuiButtonFlags) ImGuiButtonFlagsPrivate_.ImGuiButtonFlags_PressedOnRelease) != {} {
				if mouse_button_released != -1 {
					has_repeated_at_least_once : bool = (item_flags & ImGuiItemFlags_.ImGuiItemFlags_ButtonRepeat) != {} && g.IO.MouseDownDurationPrev[mouse_button_released] >= g.IO.KeyRepeatDelay; // Repeat mode trumps on release behavior
					if !has_repeated_at_least_once { pressed = true }
					if (flags & cast(ImGuiButtonFlags) ImGuiButtonFlagsPrivate_.ImGuiButtonFlags_NoNavFocus) == {} {
						// FIXME: Lack of FocusWindow() call here is inconsistent with other paths. Research why.
						SetFocusID(id, window)
					}
					ClearActiveID()
				}
			}

			// 'Repeat' mode acts when held regardless of _PressedOn flags (see table above).
			// Relies on repeat logic of IsMouseClicked() but we may as well do it ourselves if we end up exposing finer RepeatDelay/RepeatRate settings.
			if g.ActiveId == id && (item_flags & ImGuiItemFlags_.ImGuiItemFlags_ButtonRepeat) != {} { if g.IO.MouseDownDuration[g.ActiveIdMouseButton] > 0.0 && IsMouseClicked(g.ActiveIdMouseButton, ImGuiInputFlags_.ImGuiInputFlags_Repeat, test_owner_id) { pressed = true } }
		}

		if pressed && g.IO.ConfigNavCursorVisibleAuto { g.NavCursorVisible = false }
	}

	// Keyboard/Gamepad navigation handling
	// We report navigated and navigation-activated items as hovered but we don't set g.HoveredId to not interfere with mouse.
	if g.NavId == id && g.NavCursorVisible && g.NavHighlightItemUnderNav { if (flags & cast(ImGuiButtonFlags) ImGuiButtonFlagsPrivate_.ImGuiButtonFlags_NoHoveredOnFocus) == {} { hovered = true } }
	if g.NavActivateDownId == id {
		nav_activated_by_code : bool = (g.NavActivateId == id)
		nav_activated_by_inputs : bool = (g.NavActivatePressedId == id)
		if !nav_activated_by_inputs && (item_flags & ImGuiItemFlags_.ImGuiItemFlags_ButtonRepeat) != {} {
			// Avoid pressing multiple keys from triggering excessive amount of repeat events
			key1 : ^ImGuiKeyData = GetKeyData(ImGuiKey.ImGuiKey_Space)
			key2 : ^ImGuiKeyData = GetKeyData(ImGuiKey.ImGuiKey_Enter)
			key3 : ^ImGuiKeyData = GetKeyData(ImGuiKey_NavGamepadActivate(g))
			t1 : f32 = ImMax(ImMax(key1.DownDuration, key2.DownDuration), key3.DownDuration)
			nav_activated_by_inputs = CalcTypematicRepeatAmount(t1 - g.IO.DeltaTime, t1, g.IO.KeyRepeatDelay, g.IO.KeyRepeatRate) > 0
		}
		if nav_activated_by_code || nav_activated_by_inputs {
			// Set active id so it can be queried by user via IsItemActive(), equivalent of holding the mouse button.
			pressed = true
			SetActiveID(id, window)
			g.ActiveIdSource = g.NavInputSource
			if (flags & cast(ImGuiButtonFlags) ImGuiButtonFlagsPrivate_.ImGuiButtonFlags_NoNavFocus) == {} && (g.NavActivateFlags & ImGuiActivateFlags_.ImGuiActivateFlags_FromShortcut) == {} { SetFocusID(id, window) }
			if (g.NavActivateFlags & ImGuiActivateFlags_.ImGuiActivateFlags_FromShortcut) != {} { g.ActiveIdFromShortcut = true }
		}
	}

	// Process while held
	held : bool = false
	if g.ActiveId == id {
		if g.ActiveIdSource == ImGuiInputSource.ImGuiInputEventType_Mouse {
			if g.ActiveIdIsJustActivated { g.ActiveIdClickOffset = g.IO.MousePos - bb.Min }

			mouse_button := g.ActiveIdMouseButton
			if mouse_button == ImGuiMouseButton(-1) {
				// Fallback for the rare situation were g.ActiveId was set programmatically or from another widget (e.g. #6304).
				ClearActiveID()
			}
			else if IsMouseDown(mouse_button, test_owner_id) {
				held = true
			}
			else {
				release_in : bool = hovered && (flags & cast(ImGuiButtonFlags) ImGuiButtonFlagsPrivate_.ImGuiButtonFlags_PressedOnClickRelease) != {}
				release_anywhere : bool = (flags & cast(ImGuiButtonFlags) ImGuiButtonFlagsPrivate_.ImGuiButtonFlags_PressedOnClickReleaseAnywhere) != {}
				if (release_in || release_anywhere) && !g.DragDropActive {
					// Report as pressed when releasing the mouse (this is the most common path)
					is_double_click_release : bool = (flags & cast(ImGuiButtonFlags) ImGuiButtonFlagsPrivate_.ImGuiButtonFlags_PressedOnDoubleClick) != {} && g.IO.MouseReleased[mouse_button] && g.IO.MouseClickedLastCount[mouse_button] == 2
					is_repeating_already : bool = (item_flags & ImGuiItemFlags_.ImGuiItemFlags_ButtonRepeat) != {} && g.IO.MouseDownDurationPrev[mouse_button] >= g.IO.KeyRepeatDelay; // Repeat mode trumps <on release>
					is_button_avail_or_owned : bool = TestKeyOwner(MouseButtonToKey(mouse_button), test_owner_id)
					if !is_double_click_release && !is_repeating_already && is_button_avail_or_owned { pressed = true }
				}
				ClearActiveID()
			}
			if (flags & cast(ImGuiButtonFlags) ImGuiButtonFlagsPrivate_.ImGuiButtonFlags_NoNavFocus) == {} && g.IO.ConfigNavCursorVisibleAuto { g.NavCursorVisible = false }
		}
		else if g.ActiveIdSource == ImGuiInputSource.ImGuiInputSource_Keyboard || g.ActiveIdSource == ImGuiInputSource.ImGuiInputSource_Gamepad {
			// When activated using Nav, we hold on the ActiveID until activation button is released
			if g.NavActivateDownId == id {
				// hovered == true not true as we are already likely hovered on direct activation.
				held = true
			}
			else { ClearActiveID() }
		}
		if pressed { g.ActiveIdHasBeenPressedBefore = true }
	}

	// Activation highlight (this may be a remote activation)
	if g.NavHighlightActivatedId == id { hovered = true }

	if out_hovered != nil { out_hovered^ = hovered }
	if out_held != nil { out_held^ = held }

	return pressed
}

ButtonEx :: proc(label : string, size_arg : ImVec2 = {}, flags : ImGuiButtonFlags = {}) -> bool
{
	window : ^ImGuiWindow = GetCurrentWindow()
	if window.SkipItems { return false }

	g : ^ImGuiContext = GImGui
	style : ^ImGuiStyle = &g.Style
	id : ImGuiID = GetID(window, label)
	label_size : ImVec2 = CalcTextSize(label, true)

	pos : ImVec2 = window.DC.CursorPos
	if (flags & cast(ImGuiButtonFlags) ImGuiButtonFlagsPrivate_.ImGuiButtonFlags_AlignTextBaseLine) != {} && style.FramePadding.y < window.DC.CurrLineTextBaseOffset {
		// Try to vertically align buttons that are smaller/have no padding so that text baseline matches (bit hacky, since it shouldn't be a flag)
		pos.y += window.DC.CurrLineTextBaseOffset - style.FramePadding.y
	}
	size : ImVec2 = CalcItemSize(size_arg, label_size.x + style.FramePadding.x * 2.0, label_size.y + style.FramePadding.y * 2.0)

	bb : ImRect; init(&bb, pos, pos + size)
	ItemSize(size, style.FramePadding.y)
	if !ItemAdd(bb, id) { return false }

	hovered : bool; held : bool
	pressed : bool = ButtonBehavior(bb, id, &hovered, &held, flags)

	// Render
	col : ImU32 = GetColorU32((held && hovered) ? ImGuiCol_.ImGuiCol_ButtonActive : hovered ? ImGuiCol_.ImGuiCol_ButtonHovered : ImGuiCol_.ImGuiCol_Button)
	RenderNavCursor(bb, id)
	RenderFrame(bb.Min, bb.Max, col, true, style.FrameRounding)

	if g.LogEnabled { LogSetNextTextDecoration("[", "]") }
	RenderTextClipped(bb.Min + style.FramePadding, bb.Max - style.FramePadding, label, &label_size, &style.ButtonTextAlign, &bb)

	// Automatically close popups
	//if (pressed && !(flags & ImGuiButtonFlags_DontClosePopups) && (window->Flags & ImGuiWindowFlags_Popup))
	//    CloseCurrentPopup();

	IMGUI_TEST_ENGINE_ITEM_INFO(g, id, label, g.LastItemData.StatusFlags)
	return pressed
}

Button :: proc(label : string, size_arg : ImVec2 = {}) -> bool
{
	return ButtonEx(label, size_arg, ImGuiButtonFlags_.ImGuiButtonFlags_None)
}

// Small buttons fits within text without additional vertical spacing.
SmallButton :: proc(label : string) -> bool
{
	g : ^ImGuiContext = GImGui
	backup_padding_y : f32 = g.Style.FramePadding.y
	g.Style.FramePadding.y = 0.0
	pressed : bool = ButtonEx(label, ImVec2{0, 0}, cast(ImGuiButtonFlags)ImGuiButtonFlagsPrivate_.ImGuiButtonFlags_AlignTextBaseLine)
	g.Style.FramePadding.y = backup_padding_y
	return pressed
}

// Tip: use ImGui::PushID()/PopID() to push indices or pointers in the ID stack.
// Then you can keep 'str_id' empty or the same for all your buttons (instead of creating a string based on a non-string id)
InvisibleButton :: proc(str_id : string, size_arg : ImVec2, flags : ImGuiButtonFlags = {}) -> bool
{
	g : ^ImGuiContext = GImGui
	window : ^ImGuiWindow = GetCurrentWindow()
	if window.SkipItems { return false }

	// Cannot use zero-size for InvisibleButton(). Unlike Button() there is not way to fallback using the label size.
	IM_ASSERT(size_arg.x != 0.0 && size_arg.y != 0.0)

	id : ImGuiID = GetID(window, str_id)
	size : ImVec2 = CalcItemSize(size_arg, 0.0, 0.0)
	bb : ImRect; init(&bb, window.DC.CursorPos, window.DC.CursorPos + size)
	ItemSize(size)
	if !ItemAdd(bb, id, nil, (flags & ImGuiButtonFlags_.ImGuiButtonFlags_EnableNav) != {} ? ImGuiItemFlags_.ImGuiItemFlags_None : ImGuiItemFlags_.ImGuiItemFlags_NoNav) { return false }

	hovered : bool; held : bool
	pressed : bool = ButtonBehavior(bb, id, &hovered, &held, flags)
	RenderNavCursor(bb, id)

	IMGUI_TEST_ENGINE_ITEM_INFO(g, id, str_id, g.LastItemData.StatusFlags)
	return pressed
}

ArrowButtonEx :: proc(str_id : string, dir : ImGuiDir, size : ImVec2, flags : ImGuiButtonFlags) -> bool
{
	g : ^ImGuiContext = GImGui
	window : ^ImGuiWindow = GetCurrentWindow()
	if window.SkipItems { return false }

	id : ImGuiID = GetID(window, str_id)
	bb : ImRect; init(&bb, window.DC.CursorPos, window.DC.CursorPos + size)
	default_size : f32 = GetFrameHeight()
	ItemSize(size, (size.y >= default_size) ? g.Style.FramePadding.y : -1.0)
	if !ItemAdd(bb, id) { return false }

	hovered : bool; held : bool
	pressed : bool = ButtonBehavior(bb, id, &hovered, &held, flags)

	// Render
	bg_col : ImU32 = GetColorU32((held && hovered) ? ImGuiCol_.ImGuiCol_ButtonActive : hovered ? ImGuiCol_.ImGuiCol_ButtonHovered : ImGuiCol_.ImGuiCol_Button)
	text_col : ImU32 = GetColorU32(ImGuiCol_.ImGuiCol_Text)
	RenderNavCursor(bb, id)
	RenderFrame(bb.Min, bb.Max, bg_col, true, g.Style.FrameRounding)
	RenderArrow(window.DrawList, bb.Min + ImVec2{ImMax(f32(0.0), (size.x - g.FontSize) * 0.5), ImMax(f32(0.0), (size.y - g.FontSize) * 0.5)}, text_col, dir)

	IMGUI_TEST_ENGINE_ITEM_INFO(g, id, str_id, g.LastItemData.StatusFlags)
	return pressed
}

ArrowButton :: proc(str_id : string, dir : ImGuiDir) -> bool
{
	sz : f32 = GetFrameHeight()
	return ArrowButtonEx(str_id, dir, ImVec2{sz, sz}, ImGuiButtonFlags_.ImGuiButtonFlags_None)
}

// Button to close a window
CloseButton :: proc(id : ImGuiID, pos : ImVec2) -> bool
{
	g : ^ImGuiContext = GImGui
	window : ^ImGuiWindow = g.CurrentWindow

	// Tweak 1: Shrink hit-testing area if button covers an abnormally large proportion of the visible region. That's in order to facilitate moving the window away. (#3825)
	// This may better be applied as a general hit-rect reduction mechanism for all widgets to ensure the area to move window is always accessible?
	bb : ImRect; init(&bb, pos, pos + ImVec2{g.FontSize, g.FontSize})
	bb_interact : ImRect = bb
	area_to_visible_ratio : f32 = GetArea(window.OuterRectClipped) / GetArea(bb)
	if area_to_visible_ratio < 1.5 { Expand(&bb_interact, ImTrunc(GetSize(bb_interact) * -0.25)) }

	// Tweak 2: We intentionally allow interaction when clipped so that a mechanical Alt,Right,Activate sequence can always close a window.
	// (this isn't the common behavior of buttons, but it doesn't affect the user because navigation tends to keep items visible in scrolling layer).
	is_clipped : bool = !ItemAdd(bb_interact, id)

	hovered : bool; held : bool
	pressed : bool = ButtonBehavior(bb_interact, id, &hovered, &held)
	if is_clipped { return pressed }

	// Render
	bg_col : ImU32 = GetColorU32(held ? ImGuiCol_.ImGuiCol_ButtonActive : ImGuiCol_.ImGuiCol_ButtonHovered)
	if hovered { AddRectFilled(window.DrawList, bb.Min, bb.Max, bg_col) }
	RenderNavCursor(bb, id, ImGuiNavRenderCursorFlags_.ImGuiNavRenderCursorFlags_Compact)
	cross_col : ImU32 = GetColorU32(ImGuiCol_.ImGuiCol_Text)
	cross_center : ImVec2 = GetCenter(bb) - ImVec2{0.5, 0.5}
	cross_extent : f32 = g.FontSize * 0.5 * 0.7071 - 1.0
	AddLine(window.DrawList, cross_center + ImVec2{+cross_extent, +cross_extent}, cross_center + ImVec2{-cross_extent, -cross_extent}, cross_col, 1.0)
	AddLine(window.DrawList, cross_center + ImVec2{+cross_extent, -cross_extent}, cross_center + ImVec2{-cross_extent, +cross_extent}, cross_col, 1.0)

	return pressed
}

// The Collapse button also functions as a Dock Menu button.
CollapseButton :: proc(id : ImGuiID, pos : ImVec2, dock_node : ^ImGuiDockNode) -> bool
{
	g : ^ImGuiContext = GImGui
	window : ^ImGuiWindow = g.CurrentWindow

	bb : ImRect; init(&bb, pos, pos + ImVec2{g.FontSize, g.FontSize})
	is_clipped : bool = !ItemAdd(bb, id)
	hovered : bool; held : bool
	pressed : bool = ButtonBehavior(bb, id, &hovered, &held, ImGuiButtonFlags_.ImGuiButtonFlags_None)
	if is_clipped { return pressed }

	// Render
	//bool is_dock_menu = (window->DockNodeAsHost && !window->Collapsed);
	bg_col : ImU32 = GetColorU32((held && hovered) ? ImGuiCol_.ImGuiCol_ButtonActive : hovered ? ImGuiCol_.ImGuiCol_ButtonHovered : ImGuiCol_.ImGuiCol_Button)
	text_col : ImU32 = GetColorU32(ImGuiCol_.ImGuiCol_Text)
	if hovered || held { AddRectFilled(window.DrawList, bb.Min, bb.Max, bg_col) }
	RenderNavCursor(bb, id, ImGuiNavRenderCursorFlags_.ImGuiNavRenderCursorFlags_Compact)

	if dock_node != nil { RenderArrowDockMenu(window.DrawList, bb.Min, g.FontSize, text_col) }
	else { RenderArrow(window.DrawList, bb.Min, text_col, window.Collapsed ? ImGuiDir.ImGuiDir_Right : ImGuiDir.ImGuiDir_Down, 1.0) }

	// Switch to moving the window after mouse is moved beyond the initial drag threshold
	if IsItemActive() && IsMouseDragging(ImGuiMouseButton(0)) {
		// Undock from window/collapse menu button
		StartMouseMovingWindowOrNode(window, dock_node, true)
	}

	return pressed
}

GetWindowScrollbarID :: proc(window : ^ImGuiWindow, axis : ImGuiAxis) -> ImGuiID
{
	return GetID(window, axis == ImGuiAxis.ImGuiAxis_X ? "#SCROLLX" : "#SCROLLY")
}

// Return scrollbar rectangle, must only be called for corresponding axis if window->ScrollbarX/Y is set.
GetWindowScrollbarRect :: proc(window : ^ImGuiWindow, axis : ImGuiAxis) -> ImRect
{
	outer_rect : ImRect = Rect(window)
	inner_rect : ImRect = window.InnerRect
	border_size : f32 = window.WindowBorderSize
	scrollbar_size : f32 = window.ScrollbarSizes[cast(i32)axis ~ 1]; // (ScrollbarSizes.x = width of Y scrollbar; ScrollbarSizes.y = height of X scrollbar)
	IM_ASSERT(scrollbar_size > 0.0)
	if axis == ImGuiAxis.ImGuiAxis_X { return ImRect{{inner_rect.Min.x, ImMax(outer_rect.Min.y, outer_rect.Max.y - border_size - scrollbar_size)}, {inner_rect.Max.x - border_size, outer_rect.Max.y - border_size} }}
	else { return ImRect{{ImMax(outer_rect.Min.x, outer_rect.Max.x - border_size - scrollbar_size), inner_rect.Min.y}, {outer_rect.Max.x - border_size, inner_rect.Max.y - border_size} }}
}

Scrollbar :: proc(axis : ImGuiAxis)
{
	g : ^ImGuiContext = GImGui
	window : ^ImGuiWindow = g.CurrentWindow
	id : ImGuiID = GetWindowScrollbarID(window, axis)

	// Calculate scrollbar bounding box
	bb : ImRect = GetWindowScrollbarRect(window, axis)
	rounding_corners : ImDrawFlags = ImDrawFlags_.ImDrawFlags_RoundCornersNone
	if axis == ImGuiAxis.ImGuiAxis_X {
		rounding_corners |= ImDrawFlags_.ImDrawFlags_RoundCornersBottomLeft
		if !window.ScrollbarY { rounding_corners |= ImDrawFlags_.ImDrawFlags_RoundCornersBottomRight }
	}
	else {
		if (window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoTitleBar) != {} && (window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_MenuBar) == {} { rounding_corners |= ImDrawFlags_.ImDrawFlags_RoundCornersTopRight }
		if !window.ScrollbarX { rounding_corners |= ImDrawFlags_.ImDrawFlags_RoundCornersBottomRight }
	}
	size_visible : f32 = window.InnerRect.Max[axis] - window.InnerRect.Min[axis]
	size_contents : f32 = window.ContentSize[axis] + window.WindowPadding[axis] * 2.0
	scroll : ImS64 = cast(ImS64) window.Scroll[axis]
	ScrollbarEx(bb, id, axis, &scroll, cast(ImS64) size_visible, cast(ImS64) size_contents, rounding_corners)
	window.Scroll[axis] = cast(f32) scroll
}

// Vertical/Horizontal scrollbar
// The entire piece of code below is rather confusing because:
// - We handle absolute seeking (when first clicking outside the grab) and relative manipulation (afterward or when clicking inside the grab)
// - We store values as normalized ratio and in a form that allows the window content to change while we are holding on a scrollbar
// - We handle both horizontal and vertical scrollbars, which makes the terminology not ideal.
// Still, the code should probably be made simpler..
ScrollbarEx :: proc(bb_frame : ImRect, id : ImGuiID, axis : ImGuiAxis, p_scroll_v : ^ImS64, size_visible_v : ImS64, size_contents_v : ImS64, draw_rounding_flags : ImDrawFlags) -> bool
{
	g : ^ImGuiContext = GImGui
	window : ^ImGuiWindow = g.CurrentWindow
	if window.SkipItems { return false }

	bb_frame_width : f32 = GetWidth(bb_frame)
	bb_frame_height : f32 = GetHeight(bb_frame)
	if bb_frame_width <= 0.0 || bb_frame_height <= 0.0 { return false }

	// When we are too small, start hiding and disabling the grab (this reduce visual noise on very small window and facilitate using the window resize grab)
	alpha : f32 = 1.0
	if (axis == ImGuiAxis.ImGuiAxis_Y) && bb_frame_height < g.FontSize + g.Style.FramePadding.y * 2.0 { alpha = ImSaturate((bb_frame_height - g.FontSize) / (g.Style.FramePadding.y * 2.0)) }
	if alpha <= 0.0 { return false }

	style : ^ImGuiStyle = &g.Style
	allow_interaction : bool = (alpha >= 1.0)

	bb : ImRect = bb_frame
	Expand(&bb, ImVec2{-ImClamp(IM_TRUNC((bb_frame_width - 2.0) * 0.5), 0.0, 3.0), -ImClamp(IM_TRUNC((bb_frame_height - 2.0) * 0.5), 0.0, 3.0)})

	// V denote the main, longer axis of the scrollbar (= height for a vertical scrollbar)
	scrollbar_size_v : f32 = (axis == ImGuiAxis.ImGuiAxis_X) ? GetWidth(bb) : GetHeight(bb)

	// Calculate the height of our grabbable box. It generally represent the amount visible (vs the total scrollable amount)
	// But we maintain a minimum size in pixel to allow for the user to still aim inside.
	IM_ASSERT(ImMax(size_contents_v, size_visible_v) > 0.0); // Adding this assert to check if the ImMax(XXX,1.0f) is still needed. PLEASE CONTACT ME if this triggers.
	win_size_v : ImS64 = ImMax(ImMax(size_contents_v, size_visible_v), cast(ImS64) 1)
	grab_h_pixels : f32 = ImClamp(scrollbar_size_v * (cast(f32) size_visible_v / cast(f32) win_size_v), style.GrabMinSize, scrollbar_size_v)
	grab_h_norm : f32 = grab_h_pixels / scrollbar_size_v

	// Handle input right away. None of the code of Begin() is relying on scrolling position before calling Scrollbar().
	held : bool = false
	hovered : bool = false
	ItemAdd(bb_frame, id, nil, ImGuiItemFlags_.ImGuiItemFlags_NoNav)
	ButtonBehavior(bb, id, &hovered, &held, cast(ImGuiButtonFlags)ImGuiButtonFlagsPrivate_.ImGuiButtonFlags_NoNavFocus)

	scroll_max : ImS64 = ImMax(cast(ImS64) 1, size_contents_v - size_visible_v)
	scroll_ratio : f32 = ImSaturate(cast(f32) p_scroll_v^ / cast(f32) scroll_max)
	grab_v_norm : f32 = scroll_ratio * (scrollbar_size_v - grab_h_pixels) / scrollbar_size_v; // Grab position in normalized space
	if held && allow_interaction && grab_h_norm < 1.0 {
		scrollbar_pos_v : f32 = bb.Min[axis]
		mouse_pos_v : f32 = g.IO.MousePos[axis]

		// Click position in scrollbar normalized space (0.0f->1.0f)
		clicked_v_norm : f32 = ImSaturate((mouse_pos_v - scrollbar_pos_v) / scrollbar_size_v)

		held_dir : i32 = (clicked_v_norm < grab_v_norm) ? -1 : (clicked_v_norm > grab_v_norm + grab_h_norm) ? +1 : 0
		if g.ActiveIdIsJustActivated {
			// On initial click when held_dir == 0 (clicked over grab): calculate the distance between mouse and the center of the grab
			scroll_to_clicked_location : bool = (g.IO.ConfigScrollbarScrollByPage == false || g.IO.KeyShift || held_dir == 0)
			g.ScrollbarSeekMode = scroll_to_clicked_location ? 0 : cast(i16) held_dir
			g.ScrollbarClickDeltaToGrabCenter = (held_dir == 0 && !g.IO.KeyShift) ? clicked_v_norm - grab_v_norm - grab_h_norm * 0.5 : 0.0
		}

		// Apply scroll (p_scroll_v will generally point on one member of window->Scroll)
		// It is ok to modify Scroll here because we are being called in Begin() after the calculation of ContentSize and before setting up our starting position
		if g.ScrollbarSeekMode == 0 {
			// Absolute seeking
			scroll_v_norm : f32 = ImSaturate((clicked_v_norm - g.ScrollbarClickDeltaToGrabCenter - grab_h_norm * 0.5) / (1.0 - grab_h_norm))
			p_scroll_v^ = cast(ImS64) (scroll_v_norm * cast(f32)scroll_max)
		}
		else {
			// Page by page
			if IsMouseClicked(ImGuiMouseButton_.ImGuiMouseButton_Left, ImGuiInputFlags_.ImGuiInputFlags_Repeat) && held_dir == cast(i32)g.ScrollbarSeekMode {
				page_dir : f32 = (g.ScrollbarSeekMode > 0.0) ? +1.0 : -1.0
				p_scroll_v^ = ImClamp(p_scroll_v^ + cast(ImS64) (page_dir * cast(f32)size_visible_v), cast(ImS64) 0, scroll_max)
			}
		}

		// Update values for rendering
		scroll_ratio = ImSaturate(cast(f32) p_scroll_v^ / cast(f32) scroll_max)
		grab_v_norm = scroll_ratio * (scrollbar_size_v - grab_h_pixels) / scrollbar_size_v

		// Update distance to grab now that we have seek'ed and saturated
		//if (seek_absolute)
		//    g.ScrollbarClickDeltaToGrabCenter = clicked_v_norm - grab_v_norm - grab_h_norm * 0.5f;
	}

	// Render
	bg_col : ImU32 = GetColorU32(ImGuiCol_.ImGuiCol_ScrollbarBg)
	grab_col : ImU32 = GetColorU32(held ? ImGuiCol_.ImGuiCol_ScrollbarGrabActive : hovered ? ImGuiCol_.ImGuiCol_ScrollbarGrabHovered : ImGuiCol_.ImGuiCol_ScrollbarGrab, alpha)
	AddRectFilled(window.DrawList, bb_frame.Min, bb_frame.Max, bg_col, window.WindowRounding, draw_rounding_flags)
	grab_rect : ImRect
	if axis == ImGuiAxis.ImGuiAxis_X { grab_rect = ImRect{{ImLerp(bb.Min.x, bb.Max.x, grab_v_norm), bb.Min.y}, {ImLerp(bb.Min.x, bb.Max.x, grab_v_norm) + grab_h_pixels, bb.Max.y} }}
	else { grab_rect = ImRect{{bb.Min.x, ImLerp(bb.Min.y, bb.Max.y, grab_v_norm)}, {bb.Max.x, ImLerp(bb.Min.y, bb.Max.y, grab_v_norm) + grab_h_pixels} }}
	AddRectFilled(window.DrawList, grab_rect.Min, grab_rect.Max, grab_col, style.ScrollbarRounding)

	return held
}

// - Read about ImTextureID here: https://github.com/ocornut/imgui/wiki/Image-Loading-and-Displaying-Examples
// - 'uv0' and 'uv1' are texture coordinates. Read about them from the same link above.
Image :: proc(user_texture_id : ImTextureID, image_size : ImVec2, uv0 : ImVec2 = 0, uv1 : ImVec2 = 1, tint_col : ImVec4 = 1, border_col : ImVec4 ={})
{
	window : ^ImGuiWindow = GetCurrentWindow()
	if window.SkipItems { return }

	border_size : f32 = (border_col.w > 0.0) ? 1.0 : 0.0
	padding := ImVec2{ border_size, border_size }
	bb : ImRect; init(&bb, window.DC.CursorPos, window.DC.CursorPos + image_size + padding * 2.0)
	ItemSize(bb)
	if !ItemAdd(bb, 0) { return }

	// Render
	if border_size > 0.0 { AddRect(window.DrawList, bb.Min, bb.Max, GetColorU32(border_col), 0.0, ImDrawFlags_.ImDrawFlags_None, border_size) }
	AddImage(window.DrawList, user_texture_id, bb.Min + padding, bb.Max - padding, uv0, uv1, GetColorU32(tint_col))
}

ImageButtonEx :: proc(id : ImGuiID, user_texture_id : ImTextureID, image_size : ImVec2, uv0 : ImVec2, uv1 : ImVec2, bg_col : ImVec4, tint_col : ImVec4, flags : ImGuiButtonFlags = {}) -> bool
{
	g : ^ImGuiContext = GImGui
	window : ^ImGuiWindow = GetCurrentWindow()
	if window.SkipItems { return false }

	padding : ImVec2 = g.Style.FramePadding
	bb : ImRect; init(&bb, window.DC.CursorPos, window.DC.CursorPos + image_size + padding * 2.0)
	ItemSize(bb)
	if !ItemAdd(bb, id) { return false }

	hovered : bool; held : bool
	pressed : bool = ButtonBehavior(bb, id, &hovered, &held, flags)

	// Render
	col : ImU32 = GetColorU32((held && hovered) ? ImGuiCol_.ImGuiCol_ButtonActive : hovered ? ImGuiCol_.ImGuiCol_ButtonHovered : ImGuiCol_.ImGuiCol_Button)
	RenderNavCursor(bb, id)
	RenderFrame(bb.Min, bb.Max, col, true, ImClamp(cast(f32) ImMin(padding.x, padding.y), 0.0, g.Style.FrameRounding))
	if bg_col.w > 0.0 { AddRectFilled(window.DrawList, bb.Min + padding, bb.Max - padding, GetColorU32(bg_col)) }
	AddImage(window.DrawList, user_texture_id, bb.Min + padding, bb.Max - padding, uv0, uv1, GetColorU32(tint_col))

	return pressed
}

// - ImageButton() adds style.FramePadding*2.0f to provided size. This is in order to facilitate fitting an image in a button.
// - ImageButton() draws a background based on regular Button() color + optionally an inner background if specified. (#8165) // FIXME: Maybe that's not the best design?
ImageButton :: proc(str_id : string, user_texture_id : ImTextureID, image_size : ImVec2, uv0 : ImVec2 = 0, uv1 : ImVec2 = 1, bg_col : ImVec4 = 0, tint_col : ImVec4 = 1) -> bool
{
	g : ^ImGuiContext = GImGui
	window : ^ImGuiWindow = g.CurrentWindow
	if window.SkipItems { return false }

	return ImageButtonEx(GetID(window, str_id), user_texture_id, image_size, uv0, uv1, bg_col, tint_col)
}

// #ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS

Checkbox :: proc(label : string, v : ^bool) -> bool
{
	window : ^ImGuiWindow = GetCurrentWindow()
	if window.SkipItems { return false }

	g : ^ImGuiContext = GImGui
	style : ^ImGuiStyle = &g.Style
	id : ImGuiID = GetID(window, label)
	label_size : ImVec2 = CalcTextSize(label, true)

	square_sz : f32 = GetFrameHeight()
	pos : ImVec2 = window.DC.CursorPos
	total_bb : ImRect; init(&total_bb, pos, pos + ImVec2{square_sz + (label_size.x > 0.0 ? style.ItemInnerSpacing.x + label_size.x : 0.0), label_size.y + style.FramePadding.y * 2.0})
	ItemSize(total_bb, style.FramePadding.y)
	is_visible : bool = ItemAdd(total_bb, id)
	is_multi_select : bool = (g.LastItemData.ItemFlags & cast(ImGuiItemFlags) ImGuiItemFlagsPrivate_.ImGuiItemFlags_IsMultiSelect) != {}
	if !is_visible { if !is_multi_select || !g.BoxSelectState.UnclipMode || !Overlaps(g.BoxSelectState.UnclipRect, total_bb) {
	// Extra layer of "no logic clip" for box-select support
	when IMGUI_ENABLE_TEST_ENGINE {
		if(g.TestEngineHookItems) {
			ImGuiTestEngineHook_ItemInfo(g, id, label, g.LastItemData.StatusFlags | ImGuiItemStatusFlags_.ImGuiItemStatusFlags_Checkable | (v^ ? ImGuiItemStatusFlags_.ImGuiItemStatusFlags_Checked : {}))
		}
	}
	return false
} }

	// Range-Selection/Multi-selection support (header)
	checked : bool = v^
	if is_multi_select { MultiSelectItemHeader(id, &checked, nil) }

	hovered : bool; held : bool
	pressed : bool = ButtonBehavior(total_bb, id, &hovered, &held)

	// Range-Selection/Multi-selection support (footer)
	if is_multi_select { MultiSelectItemFooter(id, &checked, &pressed) }
	else if pressed { checked = !checked }

	if v^ != checked {
		v^ = checked
		pressed = true; // return value
		MarkItemEdited(id)
	}

	check_bb : ImRect; init(&check_bb, pos, pos + ImVec2{square_sz, square_sz})
	mixed_value : bool = (g.LastItemData.ItemFlags & cast(ImGuiItemFlags) ImGuiItemFlagsPrivate_.ImGuiItemFlags_MixedValue) != {}
	if is_visible {
		RenderNavCursor(total_bb, id)
		RenderFrame(check_bb.Min, check_bb.Max, GetColorU32((held && hovered) ? ImGuiCol_.ImGuiCol_FrameBgActive : hovered ? ImGuiCol_.ImGuiCol_FrameBgHovered : ImGuiCol_.ImGuiCol_FrameBg), true, style.FrameRounding)
		check_col : ImU32 = GetColorU32(ImGuiCol_.ImGuiCol_CheckMark)
		if mixed_value {
			// Undocumented tristate/mixed/indeterminate checkbox (#2644)
			// This may seem awkwardly designed because the aim is to make ImGuiItemFlags_MixedValue supported by all widgets (not just checkbox)
			pad := ImVec2{ ImMax(f32(1.0), IM_TRUNC(square_sz / 3.6)), ImMax(f32(1.0), IM_TRUNC(square_sz / 3.6)) }
			AddRectFilled(window.DrawList, check_bb.Min + pad, check_bb.Max - pad, check_col, style.FrameRounding)
		}
		else if v^ {
			pad : f32 = ImMax(f32(1.0), IM_TRUNC(square_sz / 6.0))
			RenderCheckMark(window.DrawList, check_bb.Min + ImVec2{pad, pad}, check_col, square_sz - pad * 2.0)
		}
	}
	label_pos : ImVec2 = ImVec2{check_bb.Max.x + style.ItemInnerSpacing.x, check_bb.Min.y + style.FramePadding.y}
	if g.LogEnabled { LogRenderedText(&label_pos, mixed_value ? "[~]" : v^ ? "[x]" : "[ ]") }
	if is_visible && label_size.x > 0.0 { RenderText(label_pos, label) }

	when IMGUI_ENABLE_TEST_ENGINE {
		if(g.TestEngineHookItems) { ImGuiTestEngineHook_ItemInfo(g, id, label, g.LastItemData.StatusFlags | ImGuiItemStatusFlags_.ImGuiItemStatusFlags_Checkable | (v^ ? ImGuiItemStatusFlags_.ImGuiItemStatusFlags_Checked : 0)) }

	}
	return pressed
}

CheckboxFlagsT :: proc(label : string, flags : ^$T, flags_value : T) -> bool
{
	all_on : bool = (flags^ & flags_value) == flags_value
	any_on : bool = (flags^ & flags_value) != {}
	pressed : bool
	if !all_on && any_on {
		g : ^ImGuiContext = GImGui
		g.NextItemData.ItemFlags |= cast(ImGuiItemFlags_) ImGuiItemFlagsPrivate_.ImGuiItemFlags_MixedValue
		pressed = Checkbox(label, &all_on)
	}
	else {
		pressed = Checkbox(label, &all_on)

	}
	if pressed {
		if all_on { flags^ |= flags_value }
		else { flags^ &= cast(T)~cast(intrinsics.type_core_type(T))flags_value }
	}
	return pressed
}

CheckboxFlags_i :: proc(label : string, flags : ^i32, flags_value : i32) -> bool
{
	return CheckboxFlagsT(label, flags, flags_value)
}

CheckboxFlags_u :: proc(label : string, flags : ^u32, flags_value : u32) -> bool
{
	return CheckboxFlagsT(label, flags, flags_value)
}

CheckboxFlags_i64 :: proc(label : string, flags : ^ImS64, flags_value : ImS64) -> bool
{
	return CheckboxFlagsT(label, flags, flags_value)
}

CheckboxFlags_u64 :: proc(label : string, flags : ^ImU64, flags_value : ImU64) -> bool
{
	return CheckboxFlagsT(label, flags, flags_value)
}

RadioButton_0 :: proc(label : string, active : bool) -> bool
{
	window : ^ImGuiWindow = GetCurrentWindow()
	if window.SkipItems { return false }

	g : ^ImGuiContext = GImGui
	style : ^ImGuiStyle = &g.Style
	id : ImGuiID = GetID(window, label)
	label_size : ImVec2 = CalcTextSize(label, true)

	square_sz : f32 = GetFrameHeight()
	pos : ImVec2 = window.DC.CursorPos
	check_bb : ImRect; init(&check_bb, pos, pos + ImVec2{square_sz, square_sz})
	total_bb : ImRect; init(&total_bb, pos, pos + ImVec2{square_sz + (label_size.x > 0.0 ? style.ItemInnerSpacing.x + label_size.x : 0.0), label_size.y + style.FramePadding.y * 2.0})
	ItemSize(total_bb, style.FramePadding.y)
	if !ItemAdd(total_bb, id) { return false }

	center : ImVec2 = GetCenter(check_bb)
	center.x = IM_ROUND(center.x)
	center.y = IM_ROUND(center.y)
	radius : f32 = (square_sz - 1.0) * 0.5

	hovered : bool; held : bool
	pressed : bool = ButtonBehavior(total_bb, id, &hovered, &held)
	if pressed { MarkItemEdited(id) }

	RenderNavCursor(total_bb, id)
	num_segment : i32 = _CalcCircleAutoSegmentCount(window.DrawList, radius)
	AddCircleFilled(window.DrawList, center, radius, GetColorU32((held && hovered) ? ImGuiCol_.ImGuiCol_FrameBgActive : hovered ? ImGuiCol_.ImGuiCol_FrameBgHovered : ImGuiCol_.ImGuiCol_FrameBg), num_segment)
	if active {
		pad : f32 = ImMax(f32(1.0), IM_TRUNC(square_sz / 6.0))
		AddCircleFilled(window.DrawList, center, radius - pad, GetColorU32(ImGuiCol_.ImGuiCol_CheckMark))
	}

	if style.FrameBorderSize > 0.0 {
		AddCircle(window.DrawList, center + ImVec2{1, 1}, radius, GetColorU32(ImGuiCol_.ImGuiCol_BorderShadow), num_segment, style.FrameBorderSize)
		AddCircle(window.DrawList, center, radius, GetColorU32(ImGuiCol_.ImGuiCol_Border), num_segment, style.FrameBorderSize)
	}

	label_pos : ImVec2 = ImVec2{check_bb.Max.x + style.ItemInnerSpacing.x, check_bb.Min.y + style.FramePadding.y}
	if g.LogEnabled { LogRenderedText(&label_pos, active ? "(x)" : "( )") }
	if label_size.x > 0.0 { RenderText(label_pos, label) }

	IMGUI_TEST_ENGINE_ITEM_INFO(g, id, label, g.LastItemData.StatusFlags)
	return pressed
}

// FIXME: This would work nicely if it was a public template, e.g. 'template<T> RadioButton(const char* label, T* v, T v_button)', but I'm not sure how we would expose it..
RadioButton_1 :: proc(label : string, v : ^i32, v_button : i32) -> bool
{
	pressed : bool = RadioButton(label, v^ == v_button)
	if pressed { v^ = v_button }
	return pressed
}

// size_arg (for each axis) < 0.0f: align to end, 0.0f: auto, > 0.0f: specified size
ProgressBar :: proc(fraction : f32, size_arg : ImVec2, overlay : string)
{
	window : ^ImGuiWindow = GetCurrentWindow()
	if window.SkipItems { return }

	g : ^ImGuiContext = GImGui
	style : ^ImGuiStyle = &g.Style

	pos : ImVec2 = window.DC.CursorPos
	size : ImVec2 = CalcItemSize(size_arg, CalcItemWidth(), g.FontSize + style.FramePadding.y * 2.0)
	bb : ImRect; init(&bb, pos, pos + size)
	ItemSize(size, style.FramePadding.y)
	if !ItemAdd(bb, 0) { return }

	fraction := fraction
	// Fraction < 0.0f will display an indeterminate progress bar animation
	// The value must be animated along with time, so e.g. passing '-1.0f * ImGui::GetTime()' as fraction works.
	is_indeterminate : bool = (fraction < 0.0)
	if !is_indeterminate { fraction = ImSaturate(fraction) }

	// Out of courtesy we accept a NaN fraction without crashing
	fill_n0 : f32 = 0.0
	fill_n1 : f32 = (fraction == fraction) ? fraction : 0.0

	if is_indeterminate {
		fill_width_n : f32 = 0.2
		fill_n0 = ImFmod(-fraction, 1.0) * (1.0 + fill_width_n) - fill_width_n
		fill_n1 = ImSaturate(fill_n0 + fill_width_n)
		fill_n0 = ImSaturate(fill_n0)
	}

	// Render
	RenderFrame(bb.Min, bb.Max, GetColorU32(ImGuiCol_.ImGuiCol_FrameBg), true, style.FrameRounding)
	Expand(&bb, ImVec2{-style.FrameBorderSize, -style.FrameBorderSize})
	RenderRectFilledRangeH(window.DrawList, bb, GetColorU32(ImGuiCol_.ImGuiCol_PlotHistogram), fill_n0, fill_n1, style.FrameRounding)

	overlay := overlay
	// Default displaying the fraction as percentage string, but user can override it
	// Don't display text for indeterminate bars by default
	overlay_buf : [32]u8
	if !is_indeterminate || overlay != "" {
		if overlay == "" {
			ImFormatString(overlay_buf[:], "%.0f%%", fraction * 100 + 0.01)
			overlay = string_from_slice(overlay_buf[:])
		}

		overlay_size : ImVec2 = CalcTextSize(overlay)
		if overlay_size.x > 0.0 {
			text_x : f32 = is_indeterminate ? (bb.Min.x + bb.Max.x - overlay_size.x) * 0.5 : ImLerp(bb.Min.x, bb.Max.x, fill_n1) + style.ItemSpacing.x
			RenderTextClipped(ImVec2{ImClamp(text_x, bb.Min.x, bb.Max.x - overlay_size.x - style.ItemInnerSpacing.x), bb.Min.y}, bb.Max, overlay, &overlay_size, &ImVec2{0.0, 0.5}, &bb)
		}
	}
}

Bullet :: proc()
{
	window : ^ImGuiWindow = GetCurrentWindow()
	if window.SkipItems { return }

	g : ^ImGuiContext = GImGui
	style : ^ImGuiStyle = &g.Style
	line_height : f32 = ImMax(ImMin(window.DC.CurrLineSize.y, g.FontSize + style.FramePadding.y * 2), g.FontSize)
	bb : ImRect; init(&bb, window.DC.CursorPos, window.DC.CursorPos + ImVec2{g.FontSize, line_height})
	ItemSize(bb)
	if !ItemAdd(bb, 0) {
		SameLine(0, style.FramePadding.x * 2)
		return
	}

	// Render and stay on same line
	text_col : ImU32 = GetColorU32(ImGuiCol_.ImGuiCol_Text)
	RenderBullet(window.DrawList, bb.Min + ImVec2{style.FramePadding.x + g.FontSize * 0.5, line_height * 0.5}, text_col)
	SameLine(0, style.FramePadding.x * 2.0)
}

// This is provided as a convenience for being an often requested feature.
// FIXME-STYLE: we delayed adding as there is a larger plan to revamp the styling system.
// Because of this we currently don't provide many styling options for this widget
// (e.g. hovered/active colors are automatically inferred from a single color).
TextLink :: proc(label : string) -> bool
{
	window : ^ImGuiWindow = GetCurrentWindow()
	if window.SkipItems { return false }

	g : ^ImGuiContext = GImGui
	id : ImGuiID = GetID(window, label)
	label_end := FindRenderedTextEnd(label)

	pos : ImVec2 = window.DC.CursorPos
	size : ImVec2 = CalcTextSize(label[:label_end], false)
	bb : ImRect; init(&bb, pos, pos + size)
	ItemSize(size, 0.0)
	if !ItemAdd(bb, id) { return false }

	hovered : bool; held : bool
	pressed : bool = ButtonBehavior(bb, id, &hovered, &held)
	RenderNavCursor(bb, id)

	if hovered { SetMouseCursor(ImGuiMouseCursor_.ImGuiMouseCursor_Hand) }

	text_colf : ImVec4 = g.Style.Colors[ImGuiCol_.ImGuiCol_TextLink]
	line_colf : ImVec4 = text_colf
	{
	// FIXME-STYLE: Read comments above. This widget is NOT written in the same style as some earlier widgets,
	// as we are currently experimenting/planning a different styling system.
	h : f32; s : f32; v : f32
	ColorConvertRGBtoHSV(text_colf.x, text_colf.y, text_colf.z, &h, &s, &v)
	if held || hovered {
		v = ImSaturate(v + (held ? 0.4 : 0.3))
		h = ImFmod(h + 0.02, 1.0)
	}
	ColorConvertHSVtoRGB(h, s, v, &text_colf.x, &text_colf.y, &text_colf.z)
	v = ImSaturate(v - 0.20)
	ColorConvertHSVtoRGB(h, s, v, &line_colf.x, &line_colf.y, &line_colf.z)
	}

	line_y : f32 = bb.Max.y + ImFloor(g.Font.Descent * g.FontScale * 0.20)
	AddLine(window.DrawList, ImVec2{bb.Min.x, line_y}, ImVec2{bb.Max.x, line_y}, GetColorU32(line_colf)); // FIXME-TEXT: Underline mode.

	PushStyleColor(ImGuiCol_.ImGuiCol_Text, GetColorU32(text_colf))
	RenderText(bb.Min, label[:label_end], false)
	PopStyleColor()

	IMGUI_TEST_ENGINE_ITEM_INFO(g, id, label, g.LastItemData.StatusFlags)
	return pressed
}

TextLinkOpenURL :: proc(label : string, url : string)
{
	g : ^ImGuiContext = GImGui
	url := url
	if url == "" { url = label }
	if TextLink(label) { if g.PlatformIO.Platform_OpenInShellFn != nil { g.PlatformIO.Platform_OpenInShellFn(g, url) } }
	SetItemTooltip(LocalizeGetMsg(ImGuiLocKey.ImGuiLocKey_OpenLink_s), url); // It is more reassuring for user to _always_ display URL when we same as label
	if BeginPopupContextItem() {
		if MenuItem(LocalizeGetMsg(ImGuiLocKey.ImGuiLocKey_CopyLink)) { SetClipboardText(url) }
		EndPopup()
	}
}

//-------------------------------------------------------------------------
// [SECTION] Widgets: Low-level Layout helpers
//-------------------------------------------------------------------------
// - Spacing()
// - Dummy()
// - NewLine()
// - AlignTextToFramePadding()
// - SeparatorEx() [Internal]
// - Separator()
// - SplitterBehavior() [Internal]
// - ShrinkWidths() [Internal]
//-------------------------------------------------------------------------

Spacing :: proc()
{
	window : ^ImGuiWindow = GetCurrentWindow()
	if window.SkipItems { return }
	ItemSize(ImVec2{0, 0})
}

Dummy :: proc(size : ImVec2)
{
	window : ^ImGuiWindow = GetCurrentWindow()
	if window.SkipItems { return }

	bb : ImRect; init(&bb, window.DC.CursorPos, window.DC.CursorPos + size)
	ItemSize(size)
	ItemAdd(bb, 0)
}

NewLine :: proc()
{
	window : ^ImGuiWindow = GetCurrentWindow()
	if window.SkipItems { return }

	g : ^ImGuiContext = GImGui
	backup_layout_type : ImGuiLayoutType = window.DC.LayoutType
	window.DC.LayoutType = ImGuiLayoutType_.ImGuiLayoutType_Vertical
	window.DC.IsSameLine = false
	if window.DC.CurrLineSize.y > 0.0 {
		// In the event that we are on a line with items that is smaller that FontSize high, we will preserve its height.
		ItemSize(ImVec2{0, 0})
	}
	else { ItemSize(ImVec2{0.0, g.FontSize}) }
	window.DC.LayoutType = backup_layout_type
}

AlignTextToFramePadding :: proc()
{
	window : ^ImGuiWindow = GetCurrentWindow()
	if window.SkipItems { return }

	g : ^ImGuiContext = GImGui
	window.DC.CurrLineSize.y = ImMax(window.DC.CurrLineSize.y, g.FontSize + g.Style.FramePadding.y * 2)
	window.DC.CurrLineTextBaseOffset = ImMax(window.DC.CurrLineTextBaseOffset, g.Style.FramePadding.y)
}

// Horizontal/vertical separating line
// FIXME: Surprisingly, this seemingly trivial widget is a victim of many different legacy/tricky layout issues.
// Note how thickness == 1.0f is handled specifically as not moving CursorPos by 'thickness', but other values are.
SeparatorEx :: proc(flags : ImGuiSeparatorFlags, thickness : f32)
{
	window : ^ImGuiWindow = GetCurrentWindow()
	if window.SkipItems { return }

	g : ^ImGuiContext = GImGui
	IM_ASSERT(ImIsPowerOfTwo(u32(flags & (ImGuiSeparatorFlags_.ImGuiSeparatorFlags_Horizontal | ImGuiSeparatorFlags_.ImGuiSeparatorFlags_Vertical)))); // Check that only 1 option is selected
	IM_ASSERT(thickness > 0.0)

	if (flags & ImGuiSeparatorFlags_.ImGuiSeparatorFlags_Vertical) != {} {
		// Vertical separator, for menu bars (use current line height).
		y1 : f32 = window.DC.CursorPos.y
		y2 : f32 = window.DC.CursorPos.y + window.DC.CurrLineSize.y
		bb : ImRect; init(&bb, ImVec2{window.DC.CursorPos.x, y1}, ImVec2{window.DC.CursorPos.x + thickness, y2})
		ItemSize(ImVec2{thickness, 0.0})
		if !ItemAdd(bb, 0) { return }

		// Draw
		AddRectFilled(window.DrawList, bb.Min, bb.Max, GetColorU32(ImGuiCol_.ImGuiCol_Separator))
		if g.LogEnabled { LogText(" |") }
	}
	else if (flags & ImGuiSeparatorFlags_.ImGuiSeparatorFlags_Horizontal) != {} {
		// Horizontal Separator
		x1 : f32 = window.DC.CursorPos.x
		x2 : f32 = window.WorkRect.Max.x

		// Preserve legacy behavior inside Columns()
		// Before Tables API happened, we relied on Separator() to span all columns of a Columns() set.
		// We currently don't need to provide the same feature for tables because tables naturally have border features.
		columns : ^ImGuiOldColumns = (flags & ImGuiSeparatorFlags_.ImGuiSeparatorFlags_SpanAllColumns) != {} ? window.DC.CurrentColumns : nil
		if columns != nil {
			x1 = window.Pos.x + window.DC.Indent.x; // Used to be Pos.x before 2023/10/03
			x2 = window.Pos.x + window.Size.x
			PushColumnsBackground()
		}

		// We don't provide our width to the layout so that it doesn't get feed back into AutoFit
		// FIXME: This prevents ->CursorMaxPos based bounding box evaluation from working (e.g. TableEndCell)
		thickness_for_layout : f32 = (thickness == 1.0) ? 0.0 : thickness; // FIXME: See 1.70/1.71 Separator() change: makes legacy 1-px separator not affect layout yet. Should change.
		bb : ImRect; init(&bb, ImVec2{x1, window.DC.CursorPos.y}, ImVec2{x2, window.DC.CursorPos.y + thickness})
		ItemSize(ImVec2{0.0, thickness_for_layout})

		if ItemAdd(bb, 0) {
			// Draw
			AddRectFilled(window.DrawList, bb.Min, bb.Max, GetColorU32(ImGuiCol_.ImGuiCol_Separator))
			if g.LogEnabled { LogRenderedText(&bb.Min, "--------------------------------\n") }

		}
		if columns != nil {
			PopColumnsBackground()
			columns.LineMinY = window.DC.CursorPos.y
		}
	}
}

Separator :: proc()
{
	g : ^ImGuiContext = GImGui
	window : ^ImGuiWindow = g.CurrentWindow
	if window.SkipItems { return }

	// Those flags should eventually be configurable by the user
	// FIXME: We cannot g.Style.SeparatorTextBorderSize for thickness as it relates to SeparatorText() which is a decorated separator, not defaulting to 1.0f.
	flags : ImGuiSeparatorFlags = (window.DC.LayoutType == ImGuiLayoutType_.ImGuiLayoutType_Horizontal) ? ImGuiSeparatorFlags_.ImGuiSeparatorFlags_Vertical : ImGuiSeparatorFlags_.ImGuiSeparatorFlags_Horizontal

	// Only applies to legacy Columns() api as they relied on Separator() a lot.
	if window.DC.CurrentColumns != nil { flags |= ImGuiSeparatorFlags_.ImGuiSeparatorFlags_SpanAllColumns }

	SeparatorEx(flags, 1.0)
}

SeparatorTextEx :: proc(id : ImGuiID, label : string, extra_w : f32)
{
	g : ^ImGuiContext = GImGui
	window : ^ImGuiWindow = g.CurrentWindow
	style : ^ImGuiStyle = &g.Style

	label_size : ImVec2 = CalcTextSize(label, false)
	pos : ImVec2 = window.DC.CursorPos
	padding : ImVec2 = style.SeparatorTextPadding

	separator_thickness : f32 = style.SeparatorTextBorderSize
	min_size := ImVec2{ label_size.x + extra_w + padding.x * 2.0, ImMax(label_size.y + padding.y * 2.0, separator_thickness) }
	bb : ImRect; init(&bb, pos, ImVec2{window.WorkRect.Max.x, pos.y + min_size.y})
	text_baseline_y : f32 = ImTrunc((GetHeight(bb) - label_size.y) * style.SeparatorTextAlign.y + 0.99999); //ImMax(padding.y, ImTrunc((style.SeparatorTextSize - label_size.y) * 0.5f));
	ItemSize(min_size, text_baseline_y)
	if !ItemAdd(bb, id) { return }

	sep1_x1 : f32 = pos.x
	sep2_x2 : f32 = bb.Max.x
	seps_y : f32 = ImTrunc((bb.Min.y + bb.Max.y) * 0.5 + 0.99999)

	label_avail_w : f32 = ImMax(f32(0.0), sep2_x2 - sep1_x1 - padding.x * 2.0)
	label_pos : ImVec2= { pos.x + padding.x + ImMax(f32(0.0), (label_avail_w - label_size.x - extra_w) * style.SeparatorTextAlign.x), pos.y + text_baseline_y}; // FIXME-ALIGN

	// This allows using SameLine() to position something in the 'extra_w'
	window.DC.CursorPosPrevLine.x = label_pos.x + label_size.x

	separator_col : ImU32 = GetColorU32(ImGuiCol_.ImGuiCol_Separator)
	if label_size.x > 0.0 {
		sep1_x2 : f32 = label_pos.x - style.ItemSpacing.x
		sep2_x1 : f32 = label_pos.x + label_size.x + extra_w + style.ItemSpacing.x
		if sep1_x2 > sep1_x1 && separator_thickness > 0.0 { AddLine(window.DrawList, ImVec2{sep1_x1, seps_y}, ImVec2{sep1_x2, seps_y}, separator_col, separator_thickness) }
		if sep2_x2 > sep2_x1 && separator_thickness > 0.0 { AddLine(window.DrawList, ImVec2{sep2_x1, seps_y}, ImVec2{sep2_x2, seps_y}, separator_col, separator_thickness) }
		if g.LogEnabled { LogSetNextTextDecoration("---", "") }
		RenderTextEllipsis(window.DrawList, label_pos, ImVec2{bb.Max.x, bb.Max.y + style.ItemSpacing.y}, bb.Max.x, bb.Max.x, label, len(label), &label_size)
	}
	else {
		if g.LogEnabled { LogText("---") }
		if separator_thickness > 0.0 { AddLine(window.DrawList, ImVec2{sep1_x1, seps_y}, ImVec2{sep2_x2, seps_y}, separator_col, separator_thickness) }
	}
}

SeparatorText :: proc(label : string)
{
	window : ^ImGuiWindow = GetCurrentWindow()
	if window.SkipItems { return }

	// The SeparatorText() vs SeparatorTextEx() distinction is designed to be considerate that we may want:
	// - allow separator-text to be draggable items (would require a stable ID + a noticeable highlight)
	// - this high-level entry point to allow formatting? (which in turns may require ID separate from formatted string)
	// - because of this we probably can't turn 'const char* label' into 'const char* fmt, ...'
	// Otherwise, we can decide that users wanting to drag this would layout a dedicated drag-item,
	// and then we can turn this into a format function.
	SeparatorTextEx(0, label[:FindRenderedTextEnd(label)], 0.0)
}

// Using 'hover_visibility_delay' allows us to hide the highlight and mouse cursor for a short time, which can be convenient to reduce visual noise.
SplitterBehavior :: proc(bb : ImRect, id : ImGuiID, axis : ImGuiAxis, size1 : ^f32, size2 : ^f32, min_size1 : f32, min_size2 : f32, hover_extend : f32, hover_visibility_delay : f32, bg_col : ImU32) -> bool
{
	g : ^ImGuiContext = GImGui
	window : ^ImGuiWindow = g.CurrentWindow

	if !ItemAdd(bb, id, nil, ImGuiItemFlags_.ImGuiItemFlags_NoNav) { return false }

	// FIXME: AFAIK the only leftover reason for passing ImGuiButtonFlags_AllowOverlap here is
	// to allow caller of SplitterBehavior() to call SetItemAllowOverlap() after the item.
	// Nowadays we would instead want to use SetNextItemAllowOverlap() before the item.
	button_flags : ImGuiButtonFlags = cast(ImGuiButtonFlags)ImGuiButtonFlagsPrivate_.ImGuiButtonFlags_FlattenChildren


	hovered : bool; held : bool
	bb_interact : ImRect = bb
	Expand(&bb_interact, axis == ImGuiAxis.ImGuiAxis_Y ? ImVec2{0.0, hover_extend} : ImVec2{hover_extend, 0.0})
	ButtonBehavior(bb_interact, id, &hovered, &held, button_flags)
	if hovered {
		// for IsItemHovered(), because bb_interact is larger than bb
		g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_.ImGuiItemStatusFlags_HoveredRect
	}

	if held || (hovered && g.HoveredIdPreviousFrame == id && g.HoveredIdTimer >= hover_visibility_delay) { SetMouseCursor(axis == ImGuiAxis.ImGuiAxis_Y ? ImGuiMouseCursor_.ImGuiMouseCursor_ResizeNS : ImGuiMouseCursor_.ImGuiMouseCursor_ResizeEW) }

	bb_render : ImRect = bb
	if held {
		mouse_delta : f32 = (g.IO.MousePos - g.ActiveIdClickOffset - bb_interact.Min)[axis]

		// Minimum pane size
		size_1_maximum_delta : f32 = ImMax(f32(0.0), size1^ - min_size1)
		size_2_maximum_delta : f32 = ImMax(f32(0.0), size2^ - min_size2)
		if mouse_delta < -size_1_maximum_delta { mouse_delta = -size_1_maximum_delta }
		if mouse_delta > size_2_maximum_delta { mouse_delta = size_2_maximum_delta }

		// Apply resize
		if mouse_delta != 0.0 {
			size1^ = ImMax(size1^ + mouse_delta, min_size1)
			size2^ = ImMax(size2^ - mouse_delta, min_size2)
			Translate(&bb_render, (axis == ImGuiAxis.ImGuiAxis_X) ? ImVec2{mouse_delta, 0.0} : ImVec2{0.0, mouse_delta})
			MarkItemEdited(id)
		}
	}

	// Render at new position
	if (bg_col & IM_COL32_A_MASK) != 0 { AddRectFilled(window.DrawList, bb_render.Min, bb_render.Max, bg_col, 0.0) }
	col : ImU32 = GetColorU32(held ? ImGuiCol_.ImGuiCol_SeparatorActive : (hovered && g.HoveredIdTimer >= hover_visibility_delay) ? ImGuiCol_.ImGuiCol_SeparatorHovered : ImGuiCol_.ImGuiCol_Separator)
	AddRectFilled(window.DrawList, bb_render.Min, bb_render.Max, col, 0.0)

	return held
}

ShrinkWidthItemComparer :: proc (a, b : ImGuiShrinkWidthItem) -> slice.Ordering
{
	if d : i32 = cast(i32) (b.Width - a.Width); d != 0 { return slice.Ordering(d) }
	return slice.Ordering(b.Index - a.Index)
}

// Shrink excess width from a set of item, by removing width from the larger items first.
// Set items Width to -1.0f to disable shrinking this item.
ShrinkWidths :: proc(items : [^]ImGuiShrinkWidthItem, count : i32, width_excess : f32)
{
	if count == 1 {
		if items[0].Width >= 0.0 { items[0].Width = ImMax(items[0].Width - width_excess, 1.0) }
		return
	}
	ImQsort(items[:count], ShrinkWidthItemComparer)
	count_same_width : i32 = 1
	width_excess := width_excess
	for width_excess > 0.0 && count_same_width < count {
		for count_same_width < count && items[0].Width <= items[count_same_width].Width { post_incr(&count_same_width) }

		max_width_to_remove_per_item : f32 = (count_same_width < count && items[count_same_width].Width >= 0.0) ? (items[0].Width - items[count_same_width].Width) : (items[0].Width - 1.0)
		if max_width_to_remove_per_item <= 0.0 { break }
		width_to_remove_per_item : f32 = ImMin(width_excess / cast(f32)count_same_width, max_width_to_remove_per_item)
		for item_n : i32 = 0; item_n < count_same_width; item_n += 1 { items[item_n].Width -= width_to_remove_per_item }

		width_excess -= width_to_remove_per_item * cast(f32)count_same_width
	}

	// Round width and redistribute remainder
	// Ensure that e.g. the right-most tab of a shrunk tab-bar always reaches exactly at the same distance from the right-most edge of the tab bar separator.
	width_excess = 0.0
	for n : i32 = 0; n < count; n += 1 {
		width_rounded : f32 = ImTrunc(items[n].Width)
		width_excess += items[n].Width - width_rounded
		items[n].Width = width_rounded
	}

	for width_excess > 0.0 { for n : i32 = 0; n < count && width_excess > 0.0; n += 1 {
	width_to_add : f32 = ImMin(items[n].InitialWidth - items[n].Width, 1.0)
	items[n].Width += width_to_add
	width_excess -= width_to_add
} }
}

//-------------------------------------------------------------------------
// [SECTION] Widgets: ComboBox
//-------------------------------------------------------------------------
// - CalcMaxPopupHeightFromItemCount() [Internal]
// - BeginCombo()
// - BeginComboPopup() [Internal]
// - EndCombo()
// - BeginComboPreview() [Internal]
// - EndComboPreview() [Internal]
// - Combo()
//-------------------------------------------------------------------------

CalcMaxPopupHeightFromItemCount :: proc(items_count : i32) -> f32
{
	g : ^ImGuiContext = GImGui
	if items_count <= 0 { return FLT_MAX }
	return (g.FontSize + g.Style.ItemSpacing.y) * cast(f32) items_count - g.Style.ItemSpacing.y + (g.Style.WindowPadding.y * 2)
}

BeginCombo :: proc(label : string, preview_value : string, flags : ImGuiComboFlags) -> bool
{
	g : ^ImGuiContext = GImGui
	window : ^ImGuiWindow = GetCurrentWindow()

	backup_next_window_data_flags : ImGuiNextWindowDataFlags = g.NextWindowData.Flags
	ClearFlags(&g.NextWindowData); // We behave like Begin() and need to consume those values
	if window.SkipItems { return false }

	style : ^ImGuiStyle = &g.Style
	id : ImGuiID = GetID(window, label)
	IM_ASSERT((flags & (ImGuiComboFlags_.ImGuiComboFlags_NoArrowButton | ImGuiComboFlags_.ImGuiComboFlags_NoPreview)) != (ImGuiComboFlags_.ImGuiComboFlags_NoArrowButton | ImGuiComboFlags_.ImGuiComboFlags_NoPreview)); // Can't use both flags together
	if (flags & ImGuiComboFlags_.ImGuiComboFlags_WidthFitPreview) != {} { IM_ASSERT((flags & (ImGuiComboFlags_.ImGuiComboFlags_NoPreview | cast(ImGuiComboFlags) ImGuiComboFlagsPrivate_.ImGuiComboFlags_CustomPreview)) == {}) }

	arrow_size : f32 = (flags & ImGuiComboFlags_.ImGuiComboFlags_NoArrowButton) != {} ? 0.0 : GetFrameHeight()
	label_size : ImVec2 = CalcTextSize(label, true)
	preview_width : f32 = ((flags & ImGuiComboFlags_.ImGuiComboFlags_WidthFitPreview) != {} && (preview_value != "")) ? CalcTextSize(preview_value, true).x : 0.0
	w : f32 = (flags & ImGuiComboFlags_.ImGuiComboFlags_NoPreview) != {} ? arrow_size : ((flags & ImGuiComboFlags_.ImGuiComboFlags_WidthFitPreview) != {} ? (arrow_size + preview_width + style.FramePadding.x * 2.0) : CalcItemWidth())
	bb : ImRect; init(&bb, window.DC.CursorPos, window.DC.CursorPos + ImVec2{w, label_size.y + style.FramePadding.y * 2.0})
	total_bb : ImRect; init(&total_bb, bb.Min, bb.Max + ImVec2{label_size.x > 0.0 ? style.ItemInnerSpacing.x + label_size.x : 0.0, 0.0})
	ItemSize(total_bb, style.FramePadding.y)
	if !ItemAdd(total_bb, id, &bb) { return false }

	// Open on click
	hovered : bool; held : bool
	pressed : bool = ButtonBehavior(bb, id, &hovered, &held)
	popup_id : ImGuiID = ImHashStr("##ComboPopup", id)
	popup_open : bool = IsPopupOpen(popup_id, ImGuiPopupFlags_.ImGuiPopupFlags_None)
	if pressed && !popup_open {
		OpenPopupEx(popup_id, ImGuiPopupFlags_.ImGuiPopupFlags_None)
		popup_open = true
	}

	// Render shape
	frame_col : ImU32 = GetColorU32(hovered ? ImGuiCol_.ImGuiCol_FrameBgHovered : ImGuiCol_.ImGuiCol_FrameBg)
	value_x2 : f32 = ImMax(bb.Min.x, bb.Max.x - arrow_size)
	RenderNavCursor(bb, id)
	if (flags & ImGuiComboFlags_.ImGuiComboFlags_NoPreview) == {} { AddRectFilled(window.DrawList, bb.Min, ImVec2{value_x2, bb.Max.y}, frame_col, style.FrameRounding, (flags & ImGuiComboFlags_.ImGuiComboFlags_NoArrowButton) != {} ? ImDrawFlags_.ImDrawFlags_RoundCornersAll : ImDrawFlags_.ImDrawFlags_RoundCornersLeft) }
	if (flags & ImGuiComboFlags_.ImGuiComboFlags_NoArrowButton) == {} {
		bg_col : ImU32 = GetColorU32((popup_open || hovered) ? ImGuiCol_.ImGuiCol_ButtonHovered : ImGuiCol_.ImGuiCol_Button)
		text_col : ImU32 = GetColorU32(ImGuiCol_.ImGuiCol_Text)
		AddRectFilled(window.DrawList, ImVec2{value_x2, bb.Min.y}, bb.Max, bg_col, style.FrameRounding, (w <= arrow_size) ? ImDrawFlags_.ImDrawFlags_RoundCornersAll : ImDrawFlags_.ImDrawFlags_RoundCornersRight)
		if value_x2 + arrow_size - style.FramePadding.x <= bb.Max.x { RenderArrow(window.DrawList, ImVec2{value_x2 + style.FramePadding.y, bb.Min.y + style.FramePadding.y}, text_col, ImGuiDir.ImGuiDir_Down, 1.0) }
	}
	RenderFrameBorder(bb.Min, bb.Max, style.FrameRounding)

	// Custom preview
	if (flags & cast(ImGuiComboFlags) ImGuiComboFlagsPrivate_.ImGuiComboFlags_CustomPreview) != {} {
		g.ComboPreviewData.PreviewRect = ImRect{{bb.Min.x, bb.Min.y}, {value_x2, bb.Max.y}}
		IM_ASSERT(preview_value == "")
	}

	// Render preview and label
	if preview_value != "" && (flags & ImGuiComboFlags_.ImGuiComboFlags_NoPreview) == {} {
		if g.LogEnabled { LogSetNextTextDecoration("{", "}") }
		RenderTextClipped(bb.Min + style.FramePadding, ImVec2{value_x2, bb.Max.y}, preview_value, nil, nil)
	}
	if label_size.x > 0 { RenderText(ImVec2{bb.Max.x + style.ItemInnerSpacing.x, bb.Min.y + style.FramePadding.y}, label) }

	if !popup_open { return false }

	g.NextWindowData.Flags = backup_next_window_data_flags
	return BeginComboPopup(popup_id, bb, flags)
}

BeginComboPopup :: proc(popup_id : ImGuiID, bb : ImRect, flags : ImGuiComboFlags) -> bool
{
	g : ^ImGuiContext = GImGui
	if !IsPopupOpen(popup_id, ImGuiPopupFlags_.ImGuiPopupFlags_None) {
		ClearFlags(&g.NextWindowData)
		return false
	}

	flags := flags
	// Set popup size
	w : f32 = GetWidth(bb)
	if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_.ImGuiNextWindowDataFlags_HasSizeConstraint) != {} {
		g.NextWindowData.SizeConstraintRect.Min.x = ImMax(g.NextWindowData.SizeConstraintRect.Min.x, w)
	}
	else {
		if (flags & ImGuiComboFlags_.ImGuiComboFlags_HeightMask_) == {} { flags |= ImGuiComboFlags_.ImGuiComboFlags_HeightRegular }
		IM_ASSERT(ImIsPowerOfTwo(u32(flags & ImGuiComboFlags_.ImGuiComboFlags_HeightMask_))); // Only one
		popup_max_height_in_items : i32 = -1
		if (flags & ImGuiComboFlags_.ImGuiComboFlags_HeightRegular) != {} { popup_max_height_in_items = 8 }
		else if (flags & ImGuiComboFlags_.ImGuiComboFlags_HeightSmall) != {} { popup_max_height_in_items = 4 }
		else if (flags & ImGuiComboFlags_.ImGuiComboFlags_HeightLarge) != {} { popup_max_height_in_items = 20 }
		constraint_min := ImVec2{ 0.0, 0.0}; constraint_max := ImVec2{ FLT_MAX, FLT_MAX }
		if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_.ImGuiNextWindowDataFlags_HasSize) == {} || g.NextWindowData.SizeVal.x <= 0.0 {
			// Don't apply constraints if user specified a size
			constraint_min.x = w
		}
		if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_.ImGuiNextWindowDataFlags_HasSize) == {} || g.NextWindowData.SizeVal.y <= 0.0 { constraint_max.y = CalcMaxPopupHeightFromItemCount(popup_max_height_in_items) }
		SetNextWindowSizeConstraints(constraint_min, constraint_max)
	}

	// This is essentially a specialized version of BeginPopupEx()
	name : [16]u8
	ImFormatString(name[:], "##Combo_%02d", g.BeginComboDepth); // Recycle windows based on depth

	// Set position given a custom constraint (peak into expected window size so we can position it)
	// FIXME: This might be easier to express with an hypothetical SetNextWindowPosConstraints() function?
	// FIXME: This might be moved to Begin() or at least around the same spot where Tooltips and other Popups are calling FindBestWindowPosForPopupEx()?
	if popup_window : ^ImGuiWindow = FindWindowByName(string_from_slice(name[:])); popup_window != nil { if popup_window.WasActive {
	// Always override 'AutoPosLastDirection' to not leave a chance for a past value to affect us.
	size_expected : ImVec2 = CalcWindowNextAutoFitSize(popup_window)
	popup_window.AutoPosLastDirection = (flags & ImGuiComboFlags_.ImGuiComboFlags_PopupAlignLeft) != {} ? ImGuiDir.ImGuiDir_Left : ImGuiDir.ImGuiDir_Down; // Left = "Below, Toward Left", Down = "Below, Toward Right (default)"
	r_outer : ImRect = GetPopupAllowedExtentRect(popup_window)
	pos : ImVec2 = FindBestWindowPosForPopupEx(GetBL(bb), size_expected, &popup_window.AutoPosLastDirection, r_outer, bb, ImGuiPopupPositionPolicy.ImGuiPopupPositionPolicy_ComboBox)
	SetNextWindowPos(pos)
} }

	// We don't use BeginPopupEx() solely because we have a custom name string, which we could make an argument to BeginPopupEx()
	window_flags : ImGuiWindowFlags = ImGuiWindowFlags_.ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_.ImGuiWindowFlags_Popup | ImGuiWindowFlags_.ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_.ImGuiWindowFlags_NoResize | ImGuiWindowFlags_.ImGuiWindowFlags_NoSavedSettings | ImGuiWindowFlags_.ImGuiWindowFlags_NoMove
	PushStyleVarX(ImGuiStyleVar_.ImGuiStyleVar_WindowPadding, g.Style.FramePadding.x); // Horizontally align ourselves with the framed text
	ret : bool = Begin(string_from_slice(name[:]), nil, window_flags)
	PopStyleVar()
	if !ret {
		EndPopup()
		IM_ASSERT(false); // This should never happen as we tested for IsPopupOpen() above
		return false
	}
	post_incr(&g.BeginComboDepth)
	return true
}

EndCombo :: proc()
{
	g : ^ImGuiContext = GImGui
	EndPopup()
	post_decr(&g.BeginComboDepth)
}

// Call directly after the BeginCombo/EndCombo block. The preview is designed to only host non-interactive elements
// (Experimental, see GitHub issues: #1658, #4168)
BeginComboPreview :: proc() -> bool
{
	g : ^ImGuiContext = GImGui
	window : ^ImGuiWindow = g.CurrentWindow
	preview_data : ^ImGuiComboPreviewData = &g.ComboPreviewData

	if window.SkipItems || (g.LastItemData.StatusFlags & ImGuiItemStatusFlags_.ImGuiItemStatusFlags_Visible) == {} { return false }
	IM_ASSERT(g.LastItemData.Rect.Min.x == preview_data.PreviewRect.Min.x && g.LastItemData.Rect.Min.y == preview_data.PreviewRect.Min.y); // Didn't call after BeginCombo/EndCombo block or forgot to pass ImGuiComboFlags_CustomPreview flag?
	if !Overlaps(window.ClipRect, preview_data.PreviewRect) {
		// Narrower test (optional)
		return false
	}

	// FIXME: This could be contained in a PushWorkRect() api
	preview_data.BackupCursorPos = window.DC.CursorPos
	preview_data.BackupCursorMaxPos = window.DC.CursorMaxPos
	preview_data.BackupCursorPosPrevLine = window.DC.CursorPosPrevLine
	preview_data.BackupPrevLineTextBaseOffset = window.DC.PrevLineTextBaseOffset
	preview_data.BackupLayout = window.DC.LayoutType
	window.DC.CursorPos = preview_data.PreviewRect.Min + g.Style.FramePadding
	window.DC.CursorMaxPos = window.DC.CursorPos
	window.DC.LayoutType = ImGuiLayoutType_.ImGuiLayoutType_Horizontal
	window.DC.IsSameLine = false
	PushClipRect(preview_data.PreviewRect.Min, preview_data.PreviewRect.Max, true)

	return true
}

EndComboPreview :: proc()
{
	g : ^ImGuiContext = GImGui
	window : ^ImGuiWindow = g.CurrentWindow
	preview_data : ^ImGuiComboPreviewData = &g.ComboPreviewData

	// FIXME: Using CursorMaxPos approximation instead of correct AABB which we will store in ImDrawCmd in the future
	draw_list : ^ImDrawList = window.DrawList
	if window.DC.CursorMaxPos.x < preview_data.PreviewRect.Max.x && window.DC.CursorMaxPos.y < preview_data.PreviewRect.Max.y {
		if draw_list.CmdBuffer.Size > 1 {
			// Unlikely case that the PushClipRect() didn't create a command
			draw_list.CmdBuffer.Data[draw_list.CmdBuffer.Size - 1].ClipRect = draw_list.CmdBuffer.Data[draw_list.CmdBuffer.Size - 2].ClipRect; draw_list._CmdHeader.ClipRect = draw_list.CmdBuffer.Data[draw_list.CmdBuffer.Size - 1].ClipRect
			_TryMergeDrawCmds(draw_list)
		}
	}
	PopClipRect()
	window.DC.CursorPos = preview_data.BackupCursorPos
	window.DC.CursorMaxPos = ImMax(window.DC.CursorMaxPos, preview_data.BackupCursorMaxPos)
	window.DC.CursorPosPrevLine = preview_data.BackupCursorPosPrevLine
	window.DC.PrevLineTextBaseOffset = preview_data.BackupPrevLineTextBaseOffset
	window.DC.LayoutType = preview_data.BackupLayout
	window.DC.IsSameLine = false
	preview_data.PreviewRect = ImRect{}
}

// Getter for the old Combo() API: const char*[]
Items_ArrayGetter :: proc(data : rawptr, idx : i32) -> string
{
	items : [^]string = cast([^]string) data
	return items[idx]
}

// Getter for the old Combo() API: "item1\0item2\0item3\0"
Items_SingleStringGetter :: proc(data : rawptr, idx : i32) -> string
{
	items_separated_by_zeros : [^]u8 = cast([^]u8) data
	items_count : i32 = 0
	p : [^]u8 = items_separated_by_zeros
	last_p : = p
	for p[0] != 0 {
		p = mem.ptr_offset(p, strlen(p) + 1)
		if idx == items_count { break }
		post_incr(&items_count)
		last_p = p
	}

	return p[0] != 0 ? string_from_se(last_p, p) : ""
}

// Old API, prefer using BeginCombo() nowadays if you can.
Combo_0 :: proc(label : string, current_item : ^i32, getter : proc(user_data : rawptr, idx : i32) -> string, user_data : rawptr, items_count : i32, popup_max_height_in_items : i32) -> bool
{
	g : ^ImGuiContext = GImGui

	// Call the getter to obtain the preview string which is a parameter to BeginCombo()
	preview_value : string = ""
	if current_item^ >= 0 && current_item^ < items_count { preview_value = getter(user_data, current_item^) }

	// The old Combo() API exposed "popup_max_height_in_items". The new more general BeginCombo() API doesn't have/need it, but we emulate it here.
	if popup_max_height_in_items != -1 && (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_.ImGuiNextWindowDataFlags_HasSizeConstraint) == {} {
		SetNextWindowSizeConstraints(ImVec2{0, 0}, ImVec2{FLT_MAX, CalcMaxPopupHeightFromItemCount(popup_max_height_in_items)})
	}

	if !BeginCombo(label, preview_value, .ImGuiComboFlags_None) { return false }

	// Display items
	value_changed : bool = false
	clipper : ImGuiListClipper
	Begin(&clipper, items_count)
	IncludeItemByIndex(&clipper, current_item^)
	for Step(&clipper) {
		for i : i32 = clipper.DisplayStart; i < clipper.DisplayEnd; i += 1 {
			item_text_ := getter(user_data, i)
			item_text := item_text_ == "" ? "*Unknown item*" : item_text_

			PushID(i)
			item_selected : bool = (i == current_item^)
			if Selectable(item_text, item_selected) && current_item^ != i {
				value_changed = true
				current_item^ = i
			}
			if item_selected { SetItemDefaultFocus() }
			PopID()
		}
	}

	EndCombo()
	if value_changed { MarkItemEdited(g.LastItemData.ID) }

	return value_changed
}

// Combo box helper allowing to pass an array of strings.
Combo_1 :: proc(label : string, current_item : ^i32, items : []string, height_in_items : i32) -> bool
{
	value_changed : bool = Combo(label, current_item, Items_ArrayGetter, raw_data(items), cast(i32)len(items), height_in_items)
	return value_changed
}

// Combo box helper allowing to pass all items in a single string literal holding multiple zero-terminated items "item1\0item2\0"
Combo_2 :: proc(label : string, current_item : ^i32, items_separated_by_zeros : ^u8, height_in_items : i32) -> bool
{
	items_count : i32 = 0
	p : ^u8 = items_separated_by_zeros; // FIXME-OPT: Avoid computing this, or at least only when combo is open
	for p^ != 0 {
		p = mem.ptr_offset(p, strlen(p) + 1)
		post_incr(&items_count)
	}

	value_changed : bool = Combo(label, current_item, Items_SingleStringGetter, cast(rawptr) items_separated_by_zeros, items_count, height_in_items)
	return value_changed
}



//-------------------------------------------------------------------------
// [SECTION] Data Type and Data Formatting Helpers [Internal]
//-------------------------------------------------------------------------
// - DataTypeGetInfo()
// - DataTypeFormatString()
// - DataTypeApplyOp()
// - DataTypeApplyFromText()
// - DataTypeCompare()
// - DataTypeClamp()
// - GetMinimumStepAtDecimalPrecision
// - RoundScalarWithFormat<>()
//-------------------------------------------------------------------------

GDataTypeInfo := [?]ImGuiDataTypeInfo { // @cleanup
	{size_of(u8), "S8", "%d", "%d"}, // ImGuiDataType_S8
	{size_of(u8), "U8", "%u", "%u"},
	{size_of(i16), "S16", "%d", "%d"}, // ImGuiDataType_S16
	{size_of(u16), "U16", "%u", "%u"},
	{size_of(i32), "S32", "%d", "%d"}, // ImGuiDataType_S32
	{size_of(u32), "U32", "%u", "%u"},
	{size_of(ImS64), "S64", "%I64d", "%I64d"}, // ImGuiDataType_S64
	{size_of(ImU64), "U64", "%I64u", "%I64u"},
	{size_of(f32), "float", "%.3f", "%f"}, // ImGuiDataType_Float (float are promoted to double in va_arg)
	{size_of(f64), "double", "%f", "%lf"}, // ImGuiDataType_Double
	{size_of(bool), "bool", "%d", "%d"}, // ImGuiDataType_Bool
	{0, "char*", "%s", "%s"}, // ImGuiDataType_String
}
#assert(len(GDataTypeInfo) == int(ImGuiDataType_.ImGuiDataType_COUNT))

DataTypeGetInfo :: proc(data_type : ImGuiDataType) -> ^ImGuiDataTypeInfo
{
	IM_ASSERT(data_type >= ImGuiDataType(0) && data_type < ImGuiDataType_.ImGuiDataType_COUNT)
	return &GDataTypeInfo[data_type]
}

DataTypeFormatString :: proc(buf : []u8, data_type : ImGuiDataType, p_data : rawptr, format : string) -> i32
{
	// Signedness doesn't matter when pushing integer arguments
	if data_type == ImGuiDataType_.ImGuiDataType_S32 || data_type == ImGuiDataType_.ImGuiDataType_U32 { return ImFormatString(buf, format, (cast(^ImU32) p_data)^) }
	if data_type == ImGuiDataType_.ImGuiDataType_S64 || data_type == ImGuiDataType_.ImGuiDataType_U64 { return ImFormatString(buf, format, (cast(^ImU64) p_data)^) }
	if data_type == ImGuiDataType_.ImGuiDataType_Float { return ImFormatString(buf, format, (cast(^f32) p_data)^) }
	if data_type == ImGuiDataType_.ImGuiDataType_Double { return ImFormatString(buf, format, (cast(^f64) p_data)^) }
	if data_type == ImGuiDataType_.ImGuiDataType_S8 { return ImFormatString(buf, format, (cast(^ImS8) p_data)^) }
	if data_type == ImGuiDataType_.ImGuiDataType_U8 { return ImFormatString(buf, format, (cast(^ImU8) p_data)^) }
	if data_type == ImGuiDataType_.ImGuiDataType_S16 { return ImFormatString(buf, format, (cast(^ImS16) p_data)^) }
	if data_type == ImGuiDataType_.ImGuiDataType_U16 { return ImFormatString(buf, format, (cast(^ImU16) p_data)^) }
	IM_ASSERT(false)
	return 0
}

DataTypeApplyOp :: proc(data_type : ImGuiDataType, op : i32, output : rawptr, arg1 : rawptr, arg2 : rawptr)
{
	IM_ASSERT(op == '+' || op == '-')
	#partial switch data_type {
		case ImGuiDataType_.ImGuiDataType_S8:
			if op == '+' { (cast(^ImS8) output)^ = ImAddClampOverflow((cast(^ImS8) arg1)^, (cast(^ImS8) arg2)^, IM_S8_MIN, IM_S8_MAX) }
			if op == '-' { (cast(^ImS8) output)^ = ImSubClampOverflow((cast(^ImS8) arg1)^, (cast(^ImS8) arg2)^, IM_S8_MIN, IM_S8_MAX) }
			return
		case ImGuiDataType_.ImGuiDataType_U8:
			if op == '+' { (cast(^ImU8) output)^ = ImAddClampOverflow((cast(^ImU8) arg1)^, (cast(^ImU8) arg2)^, IM_U8_MIN, IM_U8_MAX) }
			if op == '-' { (cast(^ImU8) output)^ = ImSubClampOverflow((cast(^ImU8) arg1)^, (cast(^ImU8) arg2)^, IM_U8_MIN, IM_U8_MAX) }
			return
		case ImGuiDataType_.ImGuiDataType_S16:
			if op == '+' { (cast(^ImS16) output)^ = ImAddClampOverflow((cast(^ImS16) arg1)^, (cast(^ImS16) arg2)^, IM_S16_MIN, IM_S16_MAX) }
			if op == '-' { (cast(^ImS16) output)^ = ImSubClampOverflow((cast(^ImS16) arg1)^, (cast(^ImS16) arg2)^, IM_S16_MIN, IM_S16_MAX) }
			return
		case ImGuiDataType_.ImGuiDataType_U16:
			if op == '+' { (cast(^ImU16) output)^ = ImAddClampOverflow((cast(^ImU16) arg1)^, (cast(^ImU16) arg2)^, IM_U16_MIN, IM_U16_MAX) }
			if op == '-' { (cast(^ImU16) output)^ = ImSubClampOverflow((cast(^ImU16) arg1)^, (cast(^ImU16) arg2)^, IM_U16_MIN, IM_U16_MAX) }
			return
		case ImGuiDataType_.ImGuiDataType_S32:
			if op == '+' { (cast(^ImS32) output)^ = ImAddClampOverflow((cast(^ImS32) arg1)^, (cast(^ImS32) arg2)^, IM_S32_MIN, IM_S32_MAX) }
			if op == '-' { (cast(^ImS32) output)^ = ImSubClampOverflow((cast(^ImS32) arg1)^, (cast(^ImS32) arg2)^, IM_S32_MIN, IM_S32_MAX) }
			return
		case ImGuiDataType_.ImGuiDataType_U32:
			if op == '+' { (cast(^ImU32) output)^ = ImAddClampOverflow((cast(^ImU32) arg1)^, (cast(^ImU32) arg2)^, IM_U32_MIN, IM_U32_MAX) }
			if op == '-' { (cast(^ImU32) output)^ = ImSubClampOverflow((cast(^ImU32) arg1)^, (cast(^ImU32) arg2)^, IM_U32_MIN, IM_U32_MAX) }
			return
		case ImGuiDataType_.ImGuiDataType_S64:
			if op == '+' { (cast(^ImS64) output)^ = ImAddClampOverflow((cast(^ImS64) arg1)^, (cast(^ImS64) arg2)^, IM_S64_MIN, IM_S64_MAX) }
			if op == '-' { (cast(^ImS64) output)^ = ImSubClampOverflow((cast(^ImS64) arg1)^, (cast(^ImS64) arg2)^, IM_S64_MIN, IM_S64_MAX) }
			return
		case ImGuiDataType_.ImGuiDataType_U64:
			if op == '+' { (cast(^ImU64) output)^ = ImAddClampOverflow((cast(^ImU64) arg1)^, (cast(^ImU64) arg2)^, IM_U64_MIN, IM_U64_MAX) }
			if op == '-' { (cast(^ImU64) output)^ = ImSubClampOverflow((cast(^ImU64) arg1)^, (cast(^ImU64) arg2)^, IM_U64_MIN, IM_U64_MAX) }
			return
		case ImGuiDataType_.ImGuiDataType_Float:
			if op == '+' { (cast(^f32) output)^ = (cast(^f32) arg1)^ + (cast(^f32) arg2)^ }
			if op == '-' { (cast(^f32) output)^ = (cast(^f32) arg1)^ - (cast(^f32) arg2)^ }
			return
		case ImGuiDataType_.ImGuiDataType_Double:
			if op == '+' { (cast(^f64) output)^ = (cast(^f64) arg1)^ + (cast(^f64) arg2)^ }
			if op == '-' { (cast(^f64) output)^ = (cast(^f64) arg1)^ - (cast(^f64) arg2)^ }
			return
		case ImGuiDataType_.ImGuiDataType_COUNT:break
	}
	IM_ASSERT(false)
}

// User can input math operators (e.g. +100) to edit a numerical values.
// NB: This is _not_ a full expression evaluator. We should probably add one and replace this dumb mess..
DataTypeApplyFromText :: proc(buf : []u8, data_type : ImGuiDataType, p_data : rawptr, format : string, p_data_when_empty : rawptr) -> bool
{
	// Copy the value in an opaque buffer so we can compare at the end of the function if it changed at all.
	type_info : ^ImGuiDataTypeInfo = DataTypeGetInfo(data_type)
	data_backup : ImGuiDataTypeStorage
	memcpy(&data_backup, p_data, int(type_info.Size))

	buf := buf
	for ImCharIsBlankA(buf[0]) { buf = buf[1:] }

	if buf[0] == 0 {
		if p_data_when_empty != nil {
			memcpy(p_data, p_data_when_empty, cast(int)type_info.Size)
			return memcmp(&data_backup, p_data, type_info.Size) != 0
		}
		return false
	}

	format := format
	// Sanitize format
	// - For float/double we have to ignore format with precision (e.g. "%.2f") because sscanf doesn't take them in, so force them into %f and %lf
	// - In theory could treat empty format as using default, but this would only cover rare/bizarre case of using InputScalar() + integer + format string without %.
	format_sanitized : [32]u8
	if data_type == ImGuiDataType_.ImGuiDataType_Float || data_type == ImGuiDataType_.ImGuiDataType_Double { format = type_info.ScanFmt }
	else { format = ImParseFormatSanitizeForScanning(format, format_sanitized[:]) }

	// Small types need a 32-bit buffer to receive the result from scanf()
	v32 : i32 = 0
	if sscanf(buf, format, type_info.Size >= 4 ? p_data : cast(rawptr)&v32) < 1 { return false }
	if type_info.Size < 4 {
		if data_type == ImGuiDataType_.ImGuiDataType_S8 { (cast(^ImS8) p_data)^ = cast(ImS8) ImClamp(v32, cast(i32) IM_S8_MIN, cast(i32) IM_S8_MAX) }
		else if data_type == ImGuiDataType_.ImGuiDataType_U8 { (cast(^ImU8) p_data)^ = cast(ImU8) ImClamp(v32, cast(i32) IM_U8_MIN, cast(i32) IM_U8_MAX) }
		else if data_type == ImGuiDataType_.ImGuiDataType_S16 { (cast(^ImS16) p_data)^ = cast(ImS16) ImClamp(v32, cast(i32) IM_S16_MIN, cast(i32) IM_S16_MAX) }
		else if data_type == ImGuiDataType_.ImGuiDataType_U16 { (cast(^ImU16) p_data)^ = cast(ImU16) ImClamp(v32, cast(i32) IM_U16_MIN, cast(i32) IM_U16_MAX) }
		else { IM_ASSERT(false) }
	}

	return memcmp(&data_backup, p_data, type_info.Size) != 0
}

DataTypeCompareT :: proc($T : typeid, lhs : ^T, rhs : ^T) -> i32
{
	if lhs^ < rhs^ { return -1 }
	if lhs^ > rhs^ { return +1 }
	return 0
}

DataTypeCompare :: proc(data_type : ImGuiDataType, arg_1 : rawptr, arg_2 : rawptr) -> i32
{
	#partial switch data_type {
		case ImGuiDataType_.ImGuiDataType_S8:return DataTypeCompareT(ImS8, cast(^ImS8) arg_1, cast(^ImS8) arg_2)
		case ImGuiDataType_.ImGuiDataType_U8:return DataTypeCompareT(ImU8, cast(^ImU8) arg_1, cast(^ImU8) arg_2)
		case ImGuiDataType_.ImGuiDataType_S16:return DataTypeCompareT(ImS16, cast(^ImS16) arg_1, cast(^ImS16) arg_2)
		case ImGuiDataType_.ImGuiDataType_U16:return DataTypeCompareT(ImU16, cast(^ImU16) arg_1, cast(^ImU16) arg_2)
		case ImGuiDataType_.ImGuiDataType_S32:return DataTypeCompareT(ImS32, cast(^ImS32) arg_1, cast(^ImS32) arg_2)
		case ImGuiDataType_.ImGuiDataType_U32:return DataTypeCompareT(ImU32, cast(^ImU32) arg_1, cast(^ImU32) arg_2)
		case ImGuiDataType_.ImGuiDataType_S64:return DataTypeCompareT(ImS64, cast(^ImS64) arg_1, cast(^ImS64) arg_2)
		case ImGuiDataType_.ImGuiDataType_U64:return DataTypeCompareT(ImU64, cast(^ImU64) arg_1, cast(^ImU64) arg_2)
		case ImGuiDataType_.ImGuiDataType_Float:return DataTypeCompareT(f32, cast(^f32) arg_1, cast(^f32) arg_2)
		case ImGuiDataType_.ImGuiDataType_Double:return DataTypeCompareT(f64, cast(^f64) arg_1, cast(^f64) arg_2)
		case ImGuiDataType_.ImGuiDataType_COUNT:break
	}
	IM_ASSERT(false)
	return 0
}

DataTypeClampT :: proc($T : typeid, v : ^T, v_min : ^T, v_max : ^T) -> bool
{
	// Clamp, both sides are optional, return true if modified
	if v_min != nil && v^ < v_min^ { v^ = v_min^; return true }
	if v_max != nil && v^ > v_max^ { v^ = v_max^; return true }
	return false
}

DataTypeClamp :: proc(data_type : ImGuiDataType, p_data : rawptr, p_min : rawptr, p_max : rawptr) -> bool
{
	#partial switch data_type {
		case ImGuiDataType_.ImGuiDataType_S8:return DataTypeClampT(ImS8, cast(^ImS8) p_data, cast(^ImS8) p_min, cast(^ImS8) p_max)
		case ImGuiDataType_.ImGuiDataType_U8:return DataTypeClampT(ImU8, cast(^ImU8) p_data, cast(^ImU8) p_min, cast(^ImU8) p_max)
		case ImGuiDataType_.ImGuiDataType_S16:return DataTypeClampT(ImS16, cast(^ImS16) p_data, cast(^ImS16) p_min, cast(^ImS16) p_max)
		case ImGuiDataType_.ImGuiDataType_U16:return DataTypeClampT(ImU16, cast(^ImU16) p_data, cast(^ImU16) p_min, cast(^ImU16) p_max)
		case ImGuiDataType_.ImGuiDataType_S32:return DataTypeClampT(ImS32, cast(^ImS32) p_data, cast(^ImS32) p_min, cast(^ImS32) p_max)
		case ImGuiDataType_.ImGuiDataType_U32:return DataTypeClampT(ImU32, cast(^ImU32) p_data, cast(^ImU32) p_min, cast(^ImU32) p_max)
		case ImGuiDataType_.ImGuiDataType_S64:return DataTypeClampT(ImS64, cast(^ImS64) p_data, cast(^ImS64) p_min, cast(^ImS64) p_max)
		case ImGuiDataType_.ImGuiDataType_U64:return DataTypeClampT(ImU64, cast(^ImU64) p_data, cast(^ImU64) p_min, cast(^ImU64) p_max)
		case ImGuiDataType_.ImGuiDataType_Float:return DataTypeClampT(f32, cast(^f32) p_data, cast(^f32) p_min, cast(^f32) p_max)
		case ImGuiDataType_.ImGuiDataType_Double:return DataTypeClampT(f64, cast(^f64) p_data, cast(^f64) p_min, cast(^f64) p_max)
		case ImGuiDataType_.ImGuiDataType_COUNT:break
	}
	IM_ASSERT(false)
	return false
}

DataTypeIsZero :: proc(data_type : ImGuiDataType, p_data : rawptr) -> bool
{
	g : ^ImGuiContext = GImGui
	return DataTypeCompare(data_type, p_data, &g.DataTypeZeroValue) == 0
}

GetMinimumStepAtDecimalPrecision :: proc(decimal_precision : i32) -> f32
{
	min_steps : [10]f32 = {1.0, 0.1, 0.01, 0.001, 0.0001, 0.00001, 0.000001, 0.0000001, 0.00000001, 0.000000001}
	if decimal_precision < 0 { return min(f32) }
	return (decimal_precision < cast(i32)IM_ARRAYSIZE(min_steps)) ? min_steps[decimal_precision] : ImPow(10.0, cast(f32) -decimal_precision)
}

RoundScalarWithFormatT :: proc($TYPE : typeid, format : string, data_type : ImGuiDataType, v : TYPE) -> TYPE
{
	IM_UNUSED(data_type)
	IM_ASSERT(data_type == ImGuiDataType_.ImGuiDataType_Float || data_type == ImGuiDataType_.ImGuiDataType_Double)
	fmt_start := ImParseFormatFindStart(format)
	if fmt_start[0] != '%' || fmt_start[1] == '%' {
		// Don't apply if the value is not visible in the format string
		return v
	}

	// Sanitize format
	fmt_sanitized : [32]u8
	fmt_start = ImParseFormatSanitizeForPrinting(fmt_start, fmt_sanitized[:])

	// Format value with our rounding, and read back
	v_str : [64]u8
	l := ImFormatString(v_str[:], fmt_start, v)
	p := string_from_slice(v_str[:l])
	for p[0] == ' ' { p = p[1:] }

	v := cast(TYPE) ImAtof(p)

	return v
}

//-------------------------------------------------------------------------
// [SECTION] Widgets: DragScalar, DragFloat, DragInt, etc.
//-------------------------------------------------------------------------
// - DragBehaviorT<>() [Internal]
// - DragBehavior() [Internal]
// - DragScalar()
// - DragScalarN()
// - DragFloat()
// - DragFloat2()
// - DragFloat3()
// - DragFloat4()
// - DragFloatRange2()
// - DragInt()
// - DragInt2()
// - DragInt3()
// - DragInt4()
// - DragIntRange2()
//-------------------------------------------------------------------------

// This is called by DragBehavior() when the widget is active (held by mouse or being manipulated with Nav controls)
DragBehaviorT :: proc($TYPE : typeid, $SIGNEDTYPE : typeid, $FLOATTYPE : typeid, data_type : ImGuiDataType, v : ^TYPE, v_speed : f32, v_min : TYPE, v_max : TYPE, format : string, flags : ImGuiSliderFlags) -> bool
{
	g : ^ImGuiContext = GImGui
	axis : ImGuiAxis = (flags & cast(ImGuiSliderFlags) ImGuiSliderFlagsPrivate_.ImGuiSliderFlags_Vertical) != {} ? ImGuiAxis.ImGuiAxis_Y : ImGuiAxis.ImGuiAxis_X
	is_bounded : bool = (v_min < v_max) || ((v_min == v_max) && (v_min != 0.0 || (flags & ImGuiSliderFlags_.ImGuiSliderFlags_ClampZeroRange) != {}))
	is_wrapped : bool = is_bounded && (flags & ImGuiSliderFlags_.ImGuiSliderFlags_WrapAround) != {}
	is_logarithmic : bool = (flags & ImGuiSliderFlags_.ImGuiSliderFlags_Logarithmic) != {}
	is_floating_point : bool = (data_type == ImGuiDataType_.ImGuiDataType_Float) || (data_type == ImGuiDataType_.ImGuiDataType_Double)

	v_speed := v_speed
	// Default tweak speed
	if v_speed == 0.0 && is_bounded && ((v_max - v_min) < max(TYPE)) { v_speed = (cast(f32)(v_max - v_min) * g.DragSpeedDefaultRatio) }

	// Inputs accumulates into g.DragCurrentAccum, which is flushed into the current value as soon as it makes a difference with our precision settings
	adjust_delta : f32 = 0.0
	if g.ActiveIdSource == ImGuiInputSource.ImGuiInputEventType_Mouse && IsMousePosValid() && IsMouseDragPastThreshold(ImGuiMouseButton(0), g.IO.MouseDragThreshold * DRAG_MOUSE_THRESHOLD_FACTOR) {
		adjust_delta = g.IO.MouseDelta[axis]
		if g.IO.KeyAlt && (flags & ImGuiSliderFlags_.ImGuiSliderFlags_NoSpeedTweaks) == {} { adjust_delta *= 1.0 / 100.0 }
		if g.IO.KeyShift && (flags & ImGuiSliderFlags_.ImGuiSliderFlags_NoSpeedTweaks) == {} { adjust_delta *= 10.0 }
	}
	else if g.ActiveIdSource == ImGuiInputSource.ImGuiInputSource_Keyboard || g.ActiveIdSource == ImGuiInputSource.ImGuiInputSource_Gamepad {
		decimal_precision : i32 = is_floating_point ? ImParseFormatPrecision(format, 3) : 0
		tweak_slow : bool = IsKeyDown((g.NavInputSource == ImGuiInputSource.ImGuiInputSource_Gamepad) ? ImGuiKey_NavGamepadTweakSlow : ImGuiKey_NavKeyboardTweakSlow)
		tweak_fast : bool = IsKeyDown((g.NavInputSource == ImGuiInputSource.ImGuiInputSource_Gamepad) ? ImGuiKey_NavGamepadTweakFast : ImGuiKey_NavKeyboardTweakFast)
		tweak_factor : f32 = (flags & ImGuiSliderFlags_.ImGuiSliderFlags_NoSpeedTweaks) != {} ? 1.0 : tweak_slow ? 1.0 / 10.0 : tweak_fast ? 10.0 : 1.0
		adjust_delta = GetNavTweakPressedAmount(axis) * tweak_factor
		v_speed = ImMax(v_speed, GetMinimumStepAtDecimalPrecision(decimal_precision))
	}
	adjust_delta *= v_speed

	// For vertical drag we currently assume that Up=higher value (like we do with vertical sliders). This may become a parameter.
	if axis == ImGuiAxis.ImGuiAxis_Y { adjust_delta = -adjust_delta }

	// For logarithmic use our range is effectively 0..1 so scale the delta into that range
	if is_logarithmic && (v_max - v_min < max(TYPE)) && (f32(v_max - v_min) > 0.000001) {
		// Epsilon to avoid /0
		adjust_delta /= cast(f32) (v_max - v_min)
	}

	// Clear current value on activation
	// Avoid altering values and clamping when we are _already_ past the limits and heading in the same direction, so e.g. if range is 0..255, current value is 300 and we are pushing to the right side, keep the 300.
	is_just_activated : bool = g.ActiveIdIsJustActivated
	is_already_past_limits_and_pushing_outward : bool = is_bounded && !is_wrapped && ((v^ >= v_max && adjust_delta > 0.0) || (v^ <= v_min && adjust_delta < 0.0))
	if is_just_activated || is_already_past_limits_and_pushing_outward {
		g.DragCurrentAccum = 0.0
		g.DragCurrentAccumDirty = false
	}
	else if adjust_delta != 0.0 {
		g.DragCurrentAccum += adjust_delta
		g.DragCurrentAccumDirty = true
	}

	if !g.DragCurrentAccumDirty { return false }

	v_cur : TYPE = v^
	v_old_ref_for_accum_remainder : FLOATTYPE = cast(FLOATTYPE) 0.0

	logarithmic_zero_epsilon : f32 = 0.0; // Only valid when is_logarithmic is true
	zero_deadzone_halfsize : f32 = 0.0; // Drag widgets have no deadzone (as it doesn't make sense)
	if is_logarithmic {
		// When using logarithmic sliders, we need to clamp to avoid hitting zero, but our choice of clamp value greatly affects slider precision. We attempt to use the specified precision to estimate a good lower bound.
		decimal_precision : i32 = is_floating_point ? ImParseFormatPrecision(format, 3) : 1
		logarithmic_zero_epsilon = ImPow(0.1, cast(f32) decimal_precision)

		// Convert to parametric space, apply delta, convert back
		v_old_parametric : f32 = ScaleRatioFromValueT(TYPE, SIGNEDTYPE, FLOATTYPE, data_type, v_cur, v_min, v_max, is_logarithmic, logarithmic_zero_epsilon, zero_deadzone_halfsize)
		v_new_parametric : f32 = v_old_parametric + g.DragCurrentAccum
		v_cur = ScaleValueFromRatioT(TYPE, SIGNEDTYPE, FLOATTYPE, data_type, v_new_parametric, v_min, v_max, is_logarithmic, logarithmic_zero_epsilon, zero_deadzone_halfsize)
		v_old_ref_for_accum_remainder = FLOATTYPE(v_old_parametric)
	}
	else {
		v_cur += cast(TYPE) g.DragCurrentAccum
	}

	// Round to user desired precision based on format string
	if is_floating_point && (flags & ImGuiSliderFlags_.ImGuiSliderFlags_NoRoundToFormat) == {} { v_cur = RoundScalarWithFormatT(TYPE, format, data_type, v_cur) }

	// Preserve remainder after rounding has been applied. This also allow slow tweaking of values.
	g.DragCurrentAccumDirty = false
	if is_logarithmic {
		// Convert to parametric space, apply delta, convert back
		v_new_parametric := cast(FLOATTYPE) ScaleRatioFromValueT(TYPE, SIGNEDTYPE, FLOATTYPE, data_type, v_cur, v_min, v_max, is_logarithmic, logarithmic_zero_epsilon, zero_deadzone_halfsize)
		g.DragCurrentAccum -= cast(f32) (v_new_parametric - v_old_ref_for_accum_remainder)
	}
	else {
		g.DragCurrentAccum -= cast(f32) (cast(SIGNEDTYPE) v_cur - cast(SIGNEDTYPE) v^)
	}

	// Lose zero sign for float/double
	if v_cur == cast(TYPE) -0 { v_cur = cast(TYPE) 0 }

	if v^ != v_cur && is_bounded {
		if is_wrapped {
			// Wrap values
			if v_cur < v_min { v_cur += v_max - v_min + (is_floating_point ? 0 : 1) }
			if v_cur > v_max { v_cur -= v_max - v_min + (is_floating_point ? 0 : 1) }
		}
		else {
			// Clamp values + handle overflow/wrap-around for integer types.
			if v_cur < v_min || (v_cur > v^ && adjust_delta < 0.0 && !is_floating_point) { v_cur = v_min }
			if v_cur > v_max || (v_cur < v^ && adjust_delta > 0.0 && !is_floating_point) { v_cur = v_max }
		}
	}

	// Apply result
	if v^ == v_cur { return false }
	v^ = v_cur
	return true
}

DragBehavior :: proc(id : ImGuiID, data_type : ImGuiDataType, p_v : rawptr, v_speed : f32, p_min : rawptr, p_max : rawptr, format : string, flags : ImGuiSliderFlags) -> bool
{
	// Read imgui.cpp "API BREAKING CHANGES" section for 1.78 if you hit this assert.
	IM_ASSERT((flags == ImGuiSliderFlags(1) || (flags & ImGuiSliderFlags_.ImGuiSliderFlags_InvalidMask_) == {}), "Invalid ImGuiSliderFlags flags! Has the legacy 'float power' argument been mistakenly cast to flags? Call function with ImGuiSliderFlags_Logarithmic flags instead.")

	g : ^ImGuiContext = GImGui
	if g.ActiveId == id {
		// Those are the things we can do easily outside the DragBehaviorT<> template, saves code generation.
		if g.ActiveIdSource == ImGuiInputSource.ImGuiInputEventType_Mouse && !g.IO.MouseDown[0] { ClearActiveID() }
		else if (g.ActiveIdSource == ImGuiInputSource.ImGuiInputSource_Keyboard || g.ActiveIdSource == ImGuiInputSource.ImGuiInputSource_Gamepad) && g.NavActivatePressedId == id && !g.ActiveIdIsJustActivated { ClearActiveID() }
	}
	if g.ActiveId != id { return false }
	if (g.LastItemData.ItemFlags & cast(ImGuiItemFlags) ImGuiItemFlagsPrivate_.ImGuiItemFlags_ReadOnly) != {} || (flags & cast(ImGuiSliderFlags) ImGuiSliderFlagsPrivate_.ImGuiSliderFlags_ReadOnly) != {} { return false }

	#partial switch data_type {
		case ImGuiDataType_.ImGuiDataType_S8:{v32 : ImS32 = cast(ImS32) (cast(^ImS8) p_v)^; r : bool = DragBehaviorT(ImS32, ImS32, f32, ImGuiDataType_.ImGuiDataType_S32, &v32, v_speed, ImS32(p_min != nil ? (cast(^ImS8) p_min)^ : IM_S8_MIN), ImS32(p_max != nil ? (cast(^ImS8) p_max)^ : IM_S8_MAX), format, flags); if r { (cast(^ImS8) p_v)^ = cast(ImS8) v32 }; return r}
			fallthrough
		case ImGuiDataType_.ImGuiDataType_U8:{v32 : ImU32 = cast(ImU32) (cast(^ImU8) p_v)^; r : bool = DragBehaviorT(ImU32, ImS32, f32, ImGuiDataType_.ImGuiDataType_U32, &v32, v_speed, ImU32(p_min != nil ? (cast(^ImU8) p_min)^ : IM_U8_MIN), ImU32(p_max != nil ? (cast(^ImU8) p_max)^ : IM_U8_MAX), format, flags); if r { (cast(^ImU8) p_v)^ = cast(ImU8) v32 }; return r}
			fallthrough
		case ImGuiDataType_.ImGuiDataType_S16:{v32 : ImS32 = cast(ImS32) (cast(^ImS16) p_v)^; r : bool = DragBehaviorT(ImS32, ImS32, f32, ImGuiDataType_.ImGuiDataType_S32, &v32, v_speed, ImS32(p_min != nil ? (cast(^ImS16) p_min)^ : IM_S16_MIN), ImS32(p_max != nil ? (cast(^ImS16) p_max)^ : IM_S16_MAX), format, flags); if r { (cast(^ImS16) p_v)^ = cast(ImS16) v32 }; return r}
			fallthrough
		case ImGuiDataType_.ImGuiDataType_U16:{v32 : ImU32 = cast(ImU32) (cast(^ImU16) p_v)^; r : bool = DragBehaviorT(ImU32, ImS32, f32, ImGuiDataType_.ImGuiDataType_U32, &v32, v_speed, ImU32(p_min != nil ? (cast(^ImU16) p_min)^ : IM_U16_MIN), ImU32(p_max != nil ? (cast(^ImU16) p_max)^ : IM_U16_MAX), format, flags); if r { (cast(^ImU16) p_v)^ = cast(ImU16) v32 }; return r}
			fallthrough
		case ImGuiDataType_.ImGuiDataType_S32:return DragBehaviorT(ImS32, ImS32, f32, data_type, cast(^ImS32) p_v, v_speed, p_min != nil ? (cast(^ImS32) p_min)^ : IM_S32_MIN, p_max != nil ? (cast(^ImS32) p_max)^ : IM_S32_MAX, format, flags)
		case ImGuiDataType_.ImGuiDataType_U32:return DragBehaviorT(ImU32, ImS32, f32, data_type, cast(^ImU32) p_v, v_speed, p_min != nil ? (cast(^ImU32) p_min)^ : IM_U32_MIN, p_max != nil ? (cast(^ImU32) p_max)^ : IM_U32_MAX, format, flags)
		case ImGuiDataType_.ImGuiDataType_S64:return DragBehaviorT(ImS64, ImS64, f64, data_type, cast(^ImS64) p_v, v_speed, p_min != nil ? (cast(^ImS64) p_min)^ : IM_S64_MIN, p_max != nil ? (cast(^ImS64) p_max)^ : IM_S64_MAX, format, flags)
		case ImGuiDataType_.ImGuiDataType_U64:return DragBehaviorT(ImU64, ImS64, f64, data_type, cast(^ImU64) p_v, v_speed, p_min != nil ? (cast(^ImU64) p_min)^ : IM_U64_MIN, p_max != nil ? (cast(^ImU64) p_max)^ : IM_U64_MAX, format, flags)
		case ImGuiDataType_.ImGuiDataType_Float:return DragBehaviorT(f32, f32, f32, data_type, cast(^f32) p_v, v_speed, p_min != nil ? (cast(^f32) p_min)^ : -FLT_MAX, p_max != nil ? (cast(^f32) p_max)^ : FLT_MAX, format, flags)
		case ImGuiDataType_.ImGuiDataType_Double:return DragBehaviorT(f64, f64, f64, data_type, cast(^f64) p_v, v_speed, p_min != nil ? (cast(^f64) p_min)^ : -DBL_MAX, p_max != nil ? (cast(^f64) p_max)^ : DBL_MAX, format, flags)
		case ImGuiDataType_.ImGuiDataType_COUNT:break
	}
	IM_ASSERT(false)
	return false
}

// Note: p_data, p_min and p_max are _pointers_ to a memory address holding the data. For a Drag widget, p_min and p_max are optional.
// Read code of e.g. DragFloat(), DragInt() etc. or examples in 'Demo->Widgets->Data Types' to understand how to use this function directly.
DragScalar :: proc(label : string, data_type : ImGuiDataType, p_data : rawptr, v_speed : f32 = 1, p_min : rawptr = nil, p_max : rawptr = nil, format : string = "", flags : ImGuiSliderFlags = {}) -> bool
{
	window : ^ImGuiWindow = GetCurrentWindow()
	if window.SkipItems { return false }

	g : ^ImGuiContext = GImGui
	style : ^ImGuiStyle = &g.Style
	id : ImGuiID = GetID(window, label)
	w : f32 = CalcItemWidth()

	label_size : ImVec2 = CalcTextSize(label, true)
	frame_bb : ImRect; init(&frame_bb, window.DC.CursorPos, window.DC.CursorPos + ImVec2{w, label_size.y + style.FramePadding.y * 2.0})
	total_bb : ImRect; init(&total_bb, frame_bb.Min, frame_bb.Max + ImVec2{label_size.x > 0.0 ? style.ItemInnerSpacing.x + label_size.x : 0.0, 0.0})

	temp_input_allowed : bool = (flags & ImGuiSliderFlags_.ImGuiSliderFlags_NoInput) == {}
	ItemSize(total_bb, style.FramePadding.y)
	if !ItemAdd(total_bb, id, &frame_bb, temp_input_allowed ? cast(ImGuiItemFlags)ImGuiItemFlagsPrivate_.ImGuiItemFlags_Inputable : {}) { return false }

	format := format
	// Default format string when passing NULL
	if format == "" { format = DataTypeGetInfo(data_type).PrintFmt }

	hovered : bool = ItemHoverable(frame_bb, id, g.LastItemData.ItemFlags)
	temp_input_is_active : bool = temp_input_allowed && TempInputIsActive(id)
	if !temp_input_is_active {
		// Tabbing or CTRL-clicking on Drag turns it into an InputText
		clicked : bool = hovered && IsMouseClicked(ImGuiMouseButton(0), ImGuiInputFlags_.ImGuiInputFlags_None, id)
		double_clicked : bool = (hovered && g.IO.MouseClickedCount[0] == 2 && TestKeyOwner(ImGuiKey.ImGuiKey_MouseLeft, id))
		make_active : bool = (clicked || double_clicked || g.NavActivateId == id)
		if make_active && (clicked || double_clicked) { SetKeyOwner(ImGuiKey.ImGuiKey_MouseLeft, id) }
		if make_active && temp_input_allowed { if (clicked && g.IO.KeyCtrl) || double_clicked || (g.NavActivateId == id && (g.NavActivateFlags & ImGuiActivateFlags_.ImGuiActivateFlags_PreferInput) != {}) { temp_input_is_active = true } }

		// (Optional) simple click (without moving) turns Drag into an InputText
		if g.IO.ConfigDragClickToInputText && temp_input_allowed && !temp_input_is_active {
			if g.ActiveId == id && hovered && g.IO.MouseReleased[0] && !IsMouseDragPastThreshold(ImGuiMouseButton(0), g.IO.MouseDragThreshold * DRAG_MOUSE_THRESHOLD_FACTOR) {
				g.NavActivateId = id
				g.NavActivateFlags = ImGuiActivateFlags_.ImGuiActivateFlags_PreferInput
				temp_input_is_active = true
			}
		}

		// Store initial value (not used by main lib but available as a convenience but some mods e.g. to revert)
		if make_active { memcpy(&g.ActiveIdValueOnActivation, p_data, cast(int)DataTypeGetInfo(data_type).Size) }

		if make_active && !temp_input_is_active {
			SetActiveID(id, window)
			SetFocusID(id, window)
			FocusWindow(window)
			g.ActiveIdUsingNavDirMask = (1 << cast(u32)ImGuiDir.ImGuiDir_Left) | (1 << cast(u32)ImGuiDir.ImGuiDir_Right)
		}
	}

	if temp_input_is_active {
		// Only clamp CTRL+Click input when ImGuiSliderFlags_ClampOnInput is set (generally via ImGuiSliderFlags_AlwaysClamp)
		clamp_enabled : bool = false
		if (flags & ImGuiSliderFlags_.ImGuiSliderFlags_ClampOnInput) != {} && (p_min != nil || p_max != nil) {
			clamp_range_dir : i32 = (p_min != nil && p_max != nil) ? DataTypeCompare(data_type, p_min, p_max) : 0; // -1 when *p_min < *p_max, == 0 when *p_min == *p_max
			if p_min == nil || p_max == nil || clamp_range_dir < 0 { clamp_enabled = true }
			else if clamp_range_dir == 0 { clamp_enabled = DataTypeIsZero(data_type, p_min) ? ((flags & ImGuiSliderFlags_.ImGuiSliderFlags_ClampZeroRange) != {}) : true }
		}
		return TempInputScalar(frame_bb, id, label, data_type, p_data, format, clamp_enabled ? p_min : nil, clamp_enabled ? p_max : nil)
	}

	// Draw frame
	frame_col : ImU32 = GetColorU32(g.ActiveId == id ? ImGuiCol_.ImGuiCol_FrameBgActive : (hovered ? ImGuiCol_.ImGuiCol_FrameBgHovered : ImGuiCol_.ImGuiCol_FrameBg))
	RenderNavCursor(frame_bb, id)
	RenderFrame(frame_bb.Min, frame_bb.Max, frame_col, true, style.FrameRounding)

	// Drag behavior
	value_changed : bool = DragBehavior(id, data_type, p_data, v_speed, p_min, p_max, format, flags)
	if value_changed { MarkItemEdited(id) }

	// Display value using user-provided display format so user can add prefix/suffix/decorations to the value.
	value_buf : [64]u8
	value_buf_len := DataTypeFormatString(value_buf[:], data_type, p_data, format)
	if g.LogEnabled { LogSetNextTextDecoration("{", "}") }
	RenderTextClipped(frame_bb.Min, frame_bb.Max, string_from_slice(value_buf[:value_buf_len], false), nil, &ImVec2{0.5, 0.5})

	if label_size.x > 0.0 { RenderText(ImVec2{frame_bb.Max.x + style.ItemInnerSpacing.x, frame_bb.Min.y + style.FramePadding.y}, label) }

	when IMGUI_ENABLE_TEST_ENGINE {
		if(g.TestEngineHookItems) {
			ImGuiTestEngineHook_ItemInfo(g, id, label, g.LastItemData.StatusFlags | (temp_input_allowed ? ImGuiItemStatusFlags_.ImGuiItemStatusFlags_Inputable : {}))
		}
	}
	return value_changed
}

DragScalarN :: proc(label : string, data_type : ImGuiDataType, p_data : rawptr, components : i32, v_speed : f32 = 1, p_min : rawptr = nil, p_max : rawptr = nil, format : string = "", flags : ImGuiSliderFlags = {}) -> bool
{
	window : ^ImGuiWindow = GetCurrentWindow()
	if window.SkipItems { return false }

	p_data := p_data
	g : ^ImGuiContext = GImGui
	value_changed : bool = false
	BeginGroup()
	PushID(label)
	PushMultiItemsWidths(components, CalcItemWidth())
	type_size : uint = GDataTypeInfo[data_type].Size
	for i : i32 = 0; i < components; i += 1 {
		PushID(i)
		if i > 0 { SameLine(0, g.Style.ItemInnerSpacing.x) }
		value_changed |= DragScalar("", data_type, p_data, v_speed, p_min, p_max, format, flags)
		PopID()
		PopItemWidth()
		p_data = cast(rawptr) ((cast([^]u8)p_data)[type_size:])
	}

	PopID()

	label_end := FindRenderedTextEnd(label)
	if len(label) != label_end {
		SameLine(0, g.Style.ItemInnerSpacing.x)
		TextEx(label[:label_end])
	}

	EndGroup()
	return value_changed
}

DragFloat :: proc(label : string, v : ^f32, v_speed : f32 = 1, v_min : f32 = 0, v_max : f32 = 0, format : string = "%.3f", flags : ImGuiSliderFlags = {}) -> bool
{
	v_min, v_max := v_min, v_max
	return DragScalar(label, ImGuiDataType_.ImGuiDataType_Float, v, v_speed, &v_min, &v_max, format, flags)
}

DragFloat2 :: proc(label : string, v : ^[2]f32, v_speed : f32 = 1, v_min : f32 = 0, v_max : f32 = 0, format : string = "%.3f", flags : ImGuiSliderFlags = {}) -> bool
{
	v_min, v_max := v_min, v_max
	return DragScalarN(label, ImGuiDataType_.ImGuiDataType_Float, v, 2, v_speed, &v_min, &v_max, format, flags)
}

DragFloat3 :: proc(label : string, v : ^[3]f32, v_speed : f32 = 1, v_min : f32 = 0, v_max : f32 = 0, format : string = "%.3f", flags : ImGuiSliderFlags = {}) -> bool
{
	v_min, v_max := v_min, v_max
	return DragScalarN(label, ImGuiDataType_.ImGuiDataType_Float, v, 3, v_speed, &v_min, &v_max, format, flags)
}

DragFloat4 :: proc(label : string, v : ^[4]f32, v_speed : f32 = 1, v_min : f32 = 0, v_max : f32 = 0, format : string = "%.3f", flags : ImGuiSliderFlags = {}) -> bool
{
	v_min, v_max := v_min, v_max
	return DragScalarN(label, ImGuiDataType_.ImGuiDataType_Float, v, 4, v_speed, &v_min, &v_max, format, flags)
}

// NB: You likely want to specify the ImGuiSliderFlags_AlwaysClamp when using this.
DragFloatRange2 :: proc(label : string, v_current_min : ^f32, v_current_max : ^f32, v_speed : f32 = 1, v_min : f32 = 0, v_max : f32 = 0, format : = "%.3f", format_max : string = "", flags : ImGuiSliderFlags = {}) -> bool
{
	window : ^ImGuiWindow = GetCurrentWindow()
	if window.SkipItems { return false }

	g : ^ImGuiContext = GImGui
	PushID(label)
	BeginGroup()
	PushMultiItemsWidths(2, CalcItemWidth())

	min_min : f32 = (v_min >= v_max) ? -FLT_MAX : v_min
	min_max : f32 = (v_min >= v_max) ? v_current_max^ : ImMin(v_max, v_current_max^)
	min_flags : ImGuiSliderFlags = flags | ((min_min == min_max) ? cast(ImGuiSliderFlags)ImGuiSliderFlagsPrivate_.ImGuiSliderFlags_ReadOnly : {})
	value_changed : bool = DragScalar("##min", ImGuiDataType_.ImGuiDataType_Float, v_current_min, v_speed, &min_min, &min_max, format, min_flags)
	PopItemWidth()
	SameLine(0, g.Style.ItemInnerSpacing.x)

	max_min : f32 = (v_min >= v_max) ? v_current_min^ : ImMax(v_min, v_current_min^)
	max_max : f32 = (v_min >= v_max) ? FLT_MAX : v_max
	max_flags : ImGuiSliderFlags = flags | ((max_min == max_max) ? cast(ImGuiSliderFlags)ImGuiSliderFlagsPrivate_.ImGuiSliderFlags_ReadOnly : {})
	value_changed |= DragScalar("##max", ImGuiDataType_.ImGuiDataType_Float, v_current_max, v_speed, &max_min, &max_max, format_max != "" ? format_max : format, max_flags)
	PopItemWidth()
	SameLine(0, g.Style.ItemInnerSpacing.x)

	TextEx(label[:FindRenderedTextEnd(label)])
	EndGroup()
	PopID()

	return value_changed
}

// NB: v_speed is float to allow adjusting the drag speed with more precision
DragInt :: proc(label : string, v : ^i32, v_speed : f32 = 1, v_min : i32 = 0, v_max : i32 = 0, format : string = "%d", flags : ImGuiSliderFlags = {}) -> bool
{
	v_min, v_max := v_min, v_max
	return DragScalar(label, ImGuiDataType_.ImGuiDataType_S32, v, v_speed, &v_min, &v_max, format, flags)
}

DragInt2 :: proc(label : string, v : ^[2]i32, v_speed : f32 = 1, v_min : i32 = 0, v_max : i32 = 0, format : string = "%d", flags : ImGuiSliderFlags = {}) -> bool
{
	v_min, v_max := v_min, v_max
	return DragScalarN(label, ImGuiDataType_.ImGuiDataType_S32, v, 2, v_speed, &v_min, &v_max, format, flags)
}

DragInt3 :: proc(label : string, v : ^[3]i32, v_speed : f32 = 1, v_min : i32 = 0, v_max : i32 = 0, format : string = "%d", flags : ImGuiSliderFlags = {}) -> bool
{
	v_min, v_max := v_min, v_max
	return DragScalarN(label, ImGuiDataType_.ImGuiDataType_S32, v, 3, v_speed, &v_min, &v_max, format, flags)
}

DragInt4 :: proc(label : string, v : ^[4]i32, v_speed : f32 = 1, v_min : i32 = 0, v_max : i32 = 0, format : string = "%d", flags : ImGuiSliderFlags = {}) -> bool
{
	v_min, v_max := v_min, v_max
	return DragScalarN(label, ImGuiDataType_.ImGuiDataType_S32, v, 4, v_speed, &v_min, &v_max, format, flags)
}

// NB: You likely want to specify the ImGuiSliderFlags_AlwaysClamp when using this.
DragIntRange2 :: proc(label : string, v_current_min : ^i32, v_current_max : ^i32, v_speed : f32 = 1, v_min : i32 = 0, v_max : i32 = 0, format : string = "%d", format_max : string = "", flags : ImGuiSliderFlags = {}) -> bool
{
	window : ^ImGuiWindow = GetCurrentWindow()
	if window.SkipItems { return false }

	g : ^ImGuiContext = GImGui
	PushID(label)
	BeginGroup()
	PushMultiItemsWidths(2, CalcItemWidth())

	min_min : i32 = (v_min >= v_max) ? INT_MIN : v_min
	min_max : i32 = (v_min >= v_max) ? v_current_max^ : ImMin(v_max, v_current_max^)
	min_flags : ImGuiSliderFlags = flags | ((min_min == min_max) ? cast(ImGuiSliderFlags)ImGuiSliderFlagsPrivate_.ImGuiSliderFlags_ReadOnly : {})
	value_changed : bool = DragInt("##min", v_current_min, v_speed, min_min, min_max, format, min_flags)
	PopItemWidth()
	SameLine(0, g.Style.ItemInnerSpacing.x)

	max_min : i32 = (v_min >= v_max) ? v_current_min^ : ImMax(v_min, v_current_min^)
	max_max : i32 = (v_min >= v_max) ? INT_MAX : v_max
	max_flags : ImGuiSliderFlags = flags | ((max_min == max_max) ? cast(ImGuiSliderFlags)ImGuiSliderFlagsPrivate_.ImGuiSliderFlags_ReadOnly : {})
	value_changed |= DragInt("##max", v_current_max, v_speed, max_min, max_max, format_max != "" ? format_max : format, max_flags)
	PopItemWidth()
	SameLine(0, g.Style.ItemInnerSpacing.x)

	TextEx(label[:FindRenderedTextEnd(label)])
	EndGroup()
	PopID()

	return value_changed
}

//-------------------------------------------------------------------------
// [SECTION] Widgets: SliderScalar, SliderFloat, SliderInt, etc.
//-------------------------------------------------------------------------
// - ScaleRatioFromValueT<> [Internal]
// - ScaleValueFromRatioT<> [Internal]
// - SliderBehaviorT<>() [Internal]
// - SliderBehavior() [Internal]
// - SliderScalar()
// - SliderScalarN()
// - SliderFloat()
// - SliderFloat2()
// - SliderFloat3()
// - SliderFloat4()
// - SliderAngle()
// - SliderInt()
// - SliderInt2()
// - SliderInt3()
// - SliderInt4()
// - VSliderScalar()
// - VSliderFloat()
// - VSliderInt()
//-------------------------------------------------------------------------

// Convert a value v in the output space of a slider into a parametric position on the slider itself (the logical opposite of ScaleValueFromRatioT)
ScaleRatioFromValueT :: proc($TYPE : typeid, $SIGNEDTYPE : typeid, $FLOATTYPE : typeid, data_type : ImGuiDataType, v : TYPE, v_min : TYPE, v_max : TYPE, is_logarithmic : bool, logarithmic_zero_epsilon : f32, zero_deadzone_halfsize : f32) -> f32
{
	if v_min == v_max { return 0.0 }
	IM_UNUSED(data_type)

	v_min, v_max := v_min, v_max

	v_clamped : TYPE = (v_min < v_max) ? ImClamp(v, v_min, v_max) : ImClamp(v, v_max, v_min)
	if is_logarithmic {
		flipped : bool = v_max < v_min

		if flipped {
			// Handle the case where the range is backwards
			ImSwap(&v_min, &v_max)
		}

		// Fudge min/max to avoid getting close to log(0)
		v_min_fudged := (ImAbs(cast(FLOATTYPE) v_min) < cast(FLOATTYPE)logarithmic_zero_epsilon) ? FLOATTYPE((v_min < 0.0) ? -logarithmic_zero_epsilon : logarithmic_zero_epsilon) : cast(FLOATTYPE) v_min
		v_max_fudged := (ImAbs(cast(FLOATTYPE) v_max) < cast(FLOATTYPE)logarithmic_zero_epsilon) ? FLOATTYPE((v_max < 0.0) ? -logarithmic_zero_epsilon : logarithmic_zero_epsilon) : cast(FLOATTYPE) v_max

		// Awkward special cases - we need ranges of the form (-100 .. 0) to convert to (-100 .. -epsilon), not (-100 .. epsilon)
		if (v_min == 0.0) && (v_max < 0.0) { v_min_fudged = -FLOATTYPE(logarithmic_zero_epsilon) }
		else if (v_max == 0.0) && (v_min < 0.0) { v_max_fudged = -FLOATTYPE(logarithmic_zero_epsilon) }

		result : f32
		if FLOATTYPE(v_clamped) <= v_min_fudged {
			// Workaround for values that are in-range but below our fudge
			result = 0.0
		}
		else if FLOATTYPE(v_clamped) >= v_max_fudged {
			// Workaround for values that are in-range but above our fudge
			result = 1.0
		}
		else if (v_min * v_max) < 0.0 {
			// Range crosses zero, so split into two portions
			zero_point_center : f32 = (-cast(f32) v_min) / (cast(f32) v_max - cast(f32) v_min); // The zero point in parametric space.  There's an argument we should take the logarithmic nature into account when calculating this, but for now this should do (and the most common case of a symmetrical range works fine)
			zero_point_snap_L : f32 = zero_point_center - zero_deadzone_halfsize
			zero_point_snap_R : f32 = zero_point_center + zero_deadzone_halfsize
			if v == 0.0 {
				// Special case for exactly zero
				result = zero_point_center
			}
			else if v < 0.0 { result = (1.0 - cast(f32) (ImLog(-cast(FLOATTYPE) v_clamped / cast(FLOATTYPE)logarithmic_zero_epsilon) / ImLog(-v_min_fudged / cast(FLOATTYPE)logarithmic_zero_epsilon))) * zero_point_snap_L }
			else { result = zero_point_snap_R + (cast(f32) (ImLog(cast(FLOATTYPE) v_clamped / cast(FLOATTYPE)logarithmic_zero_epsilon) / ImLog(v_max_fudged / cast(FLOATTYPE)logarithmic_zero_epsilon)) * (1.0 - zero_point_snap_R)) }
		}
		else if (v_min < 0.0) || (v_max < 0.0) {
			// Entirely negative slider
			result = 1.0 - cast(f32) (ImLog(-cast(FLOATTYPE) v_clamped / -v_max_fudged) / ImLog(-v_min_fudged / -v_max_fudged))
		}
		else { result = cast(f32) (ImLog(cast(FLOATTYPE) v_clamped / v_min_fudged) / ImLog(v_max_fudged / v_min_fudged)) }

		return flipped ? (1.0 - result) : result
	}
	else {
		// Linear slider
		return cast(f32) (cast(FLOATTYPE) cast(SIGNEDTYPE) (v_clamped - v_min) / cast(FLOATTYPE) cast(SIGNEDTYPE) (v_max - v_min))
	}
}

// Convert a parametric position on a slider into a value v in the output space (the logical opposite of ScaleRatioFromValueT)
ScaleValueFromRatioT :: proc($TYPE : typeid, $SIGNEDTYPE : typeid, $FLOATTYPE : typeid, data_type : ImGuiDataType, t : f32, v_min : TYPE, v_max : TYPE, is_logarithmic : bool, logarithmic_zero_epsilon : f32, zero_deadzone_halfsize : f32) -> TYPE
{
	// We special-case the extents because otherwise our logarithmic fudging can lead to "mathematically correct"
	// but non-intuitive behaviors like a fully-left slider not actually reaching the minimum value. Also generally simpler.
	if t <= 0.0 || v_min == v_max { return v_min }
	if t >= 1.0 { return v_max }

	result : TYPE = cast(TYPE) 0
	if is_logarithmic {
		// Fudge min/max to avoid getting silly results close to zero
		v_min_fudged : FLOATTYPE = (ImAbs(cast(FLOATTYPE) v_min) < cast(FLOATTYPE)logarithmic_zero_epsilon) ? ((v_min < 0.0) ? -cast(FLOATTYPE)logarithmic_zero_epsilon : cast(FLOATTYPE)logarithmic_zero_epsilon) : cast(FLOATTYPE) v_min
		v_max_fudged : FLOATTYPE = (ImAbs(cast(FLOATTYPE) v_max) < cast(FLOATTYPE)logarithmic_zero_epsilon) ? ((v_max < 0.0) ? -cast(FLOATTYPE)logarithmic_zero_epsilon : cast(FLOATTYPE)logarithmic_zero_epsilon) : cast(FLOATTYPE) v_max

		flipped : bool = v_max < v_min; // Check if range is "backwards"
		if flipped { ImSwap(&v_min_fudged, &v_max_fudged) }

		// Awkward special case - we need ranges of the form (-100 .. 0) to convert to (-100 .. -epsilon), not (-100 .. epsilon)
		if (v_max == 0.0) && (v_min < 0.0) { v_max_fudged = -cast(FLOATTYPE)logarithmic_zero_epsilon }

		t_with_flip : f32 = flipped ? (1.0 - t) : t; // t, but flipped if necessary to account for us flipping the range

		if (v_min * v_max) < 0.0 {
			// Range crosses zero, so we have to do this in two parts
			zero_point_center : f32 = (-cast(f32) ImMin(v_min, v_max)) / ImAbs(cast(f32) v_max - cast(f32) v_min); // The zero point in parametric space
			zero_point_snap_L : f32 = zero_point_center - zero_deadzone_halfsize
			zero_point_snap_R : f32 = zero_point_center + zero_deadzone_halfsize
			if t_with_flip >= zero_point_snap_L && t_with_flip <= zero_point_snap_R {
				// Special case to make getting exactly zero possible (the epsilon prevents it otherwise)
				result = cast(TYPE) 0.0
			}
			else if t_with_flip < zero_point_center { result = cast(TYPE) -(cast(FLOATTYPE)logarithmic_zero_epsilon * ImPow(-v_min_fudged / cast(FLOATTYPE)logarithmic_zero_epsilon, cast(FLOATTYPE) (1.0 - (t_with_flip / zero_point_snap_L)))) }
			else { result = cast(TYPE) (cast(FLOATTYPE)logarithmic_zero_epsilon * ImPow(v_max_fudged / cast(FLOATTYPE)logarithmic_zero_epsilon, cast(FLOATTYPE) ((t_with_flip - zero_point_snap_R) / (1.0 - zero_point_snap_R)))) }
		}
		else if (v_min < 0.0) || (v_max < 0.0) {
			// Entirely negative slider
			result = cast(TYPE) -(-v_max_fudged * ImPow(-v_min_fudged / -v_max_fudged, cast(FLOATTYPE) (1.0 - t_with_flip)))
		}
		else { result = cast(TYPE) (v_min_fudged * ImPow(v_max_fudged / v_min_fudged, cast(FLOATTYPE) t_with_flip)) }
	}
	else {
		// Linear slider
		is_floating_point : bool = (data_type == ImGuiDataType_.ImGuiDataType_Float) || (data_type == ImGuiDataType_.ImGuiDataType_Double)
		if is_floating_point {
			result = ImLerp(v_min, v_max, t)
		}
		else if t < 1.0 {
			// - For integer values we want the clicking position to match the grab box so we round above
			//   This code is carefully tuned to work with large values (e.g. high ranges of U64) while preserving this property..
			// - Not doing a *1.0 multiply at the end of a range as it tends to be lossy. While absolute aiming at a large s64/u64
			//   range is going to be imprecise anyway, with this check we at least make the edge values matches expected limits.
			v_new_off_f : FLOATTYPE = cast(FLOATTYPE)((cast(f32) cast(SIGNEDTYPE) (v_max - v_min)) * t)
			result = cast(TYPE) (cast(SIGNEDTYPE) v_min + cast(SIGNEDTYPE) (v_new_off_f + cast(FLOATTYPE) (v_min > v_max ? -0.5 : 0.5)))
		}
	}

	return result
}

// FIXME: Try to move more of the code into shared SliderBehavior()
SliderBehaviorT :: proc($TYPE : typeid, $SIGNEDTYPE : typeid, $FLOATTYPE : typeid, bb : ImRect, id : ImGuiID, data_type : ImGuiDataType, v : ^TYPE, v_min : TYPE, v_max : TYPE, format : string, flags : ImGuiSliderFlags, out_grab_bb : ^ImRect) -> bool
{
	g : ^ImGuiContext = GImGui
	style : ^ImGuiStyle = &g.Style

	axis : ImGuiAxis = (flags & cast(ImGuiSliderFlags) ImGuiSliderFlagsPrivate_.ImGuiSliderFlags_Vertical) != {} ? ImGuiAxis.ImGuiAxis_Y : ImGuiAxis.ImGuiAxis_X
	is_logarithmic : bool = (flags & ImGuiSliderFlags_.ImGuiSliderFlags_Logarithmic) != {}
	is_floating_point : bool = (data_type == ImGuiDataType_.ImGuiDataType_Float) || (data_type == ImGuiDataType_.ImGuiDataType_Double)
	v_range_f : f32 = cast(f32) (v_min < v_max ? v_max - v_min : v_min - v_max); // We don't need high precision for what we do with it.

	// Calculate bounds
	grab_padding : f32 = 2.0; // FIXME: Should be part of style.
	slider_sz : f32 = (bb.Max[axis] - bb.Min[axis]) - grab_padding * 2.0
	grab_sz : f32 = style.GrabMinSize
	if !is_floating_point && v_range_f >= 0.0 {
		// v_range_f < 0 may happen on integer overflows
		// For integer sliders: if possible have the grab size represent 1 unit
		grab_sz = ImMax(slider_sz / (v_range_f + 1), style.GrabMinSize)
	}
	grab_sz = ImMin(grab_sz, slider_sz)
	slider_usable_sz : f32 = slider_sz - grab_sz
	slider_usable_pos_min : f32 = bb.Min[axis] + grab_padding + grab_sz * 0.5
	slider_usable_pos_max : f32 = bb.Max[axis] - grab_padding - grab_sz * 0.5

	logarithmic_zero_epsilon : f32 = 0.0; // Only valid when is_logarithmic is true
	zero_deadzone_halfsize : f32 = 0.0; // Only valid when is_logarithmic is true
	if is_logarithmic {
		// When using logarithmic sliders, we need to clamp to avoid hitting zero, but our choice of clamp value greatly affects slider precision. We attempt to use the specified precision to estimate a good lower bound.
		decimal_precision : i32 = is_floating_point ? ImParseFormatPrecision(format, 3) : 1
		logarithmic_zero_epsilon = ImPow(0.1, cast(f32) decimal_precision)
		zero_deadzone_halfsize = (style.LogSliderDeadzone * 0.5) / ImMax(slider_usable_sz, 1.0)
	}

	// Process interacting with the slider
	value_changed : bool = false
	if g.ActiveId == id {
		set_new_value : bool = false
		clicked_t : f32 = 0.0
		if g.ActiveIdSource == ImGuiInputSource.ImGuiInputEventType_Mouse {
			if !g.IO.MouseDown[0] {
				ClearActiveID()
			}
			else {
				mouse_abs_pos : f32 = g.IO.MousePos[axis]
				if g.ActiveIdIsJustActivated {
					grab_t : f32 = ScaleRatioFromValueT(TYPE, SIGNEDTYPE, FLOATTYPE, data_type, v^, v_min, v_max, is_logarithmic, logarithmic_zero_epsilon, zero_deadzone_halfsize)
					if axis == ImGuiAxis.ImGuiAxis_Y { grab_t = 1.0 - grab_t }
					grab_pos : f32 = ImLerp(slider_usable_pos_min, slider_usable_pos_max, grab_t)
					clicked_around_grab : bool = (mouse_abs_pos >= grab_pos - grab_sz * 0.5 - 1.0) && (mouse_abs_pos <= grab_pos + grab_sz * 0.5 + 1.0); // No harm being extra generous here.
					g.SliderGrabClickOffset = (clicked_around_grab && is_floating_point) ? mouse_abs_pos - grab_pos : 0.0
				}
				if slider_usable_sz > 0.0 { clicked_t = ImSaturate((mouse_abs_pos - g.SliderGrabClickOffset - slider_usable_pos_min) / slider_usable_sz) }
				if axis == ImGuiAxis.ImGuiAxis_Y { clicked_t = 1.0 - clicked_t }
				set_new_value = true
			}
		}
		else if g.ActiveIdSource == ImGuiInputSource.ImGuiInputSource_Keyboard || g.ActiveIdSource == ImGuiInputSource.ImGuiInputSource_Gamepad {
			if g.ActiveIdIsJustActivated {
				g.SliderCurrentAccum = 0.0; // Reset any stored nav delta upon activation
				g.SliderCurrentAccumDirty = false
			}

			input_delta : f32 = (axis == ImGuiAxis.ImGuiAxis_X) ? GetNavTweakPressedAmount(axis) : -GetNavTweakPressedAmount(axis)
			if input_delta != 0.0 {
				tweak_slow : bool = IsKeyDown((g.NavInputSource == ImGuiInputSource.ImGuiInputSource_Gamepad) ? ImGuiKey_NavGamepadTweakSlow : ImGuiKey_NavKeyboardTweakSlow)
				tweak_fast : bool = IsKeyDown((g.NavInputSource == ImGuiInputSource.ImGuiInputSource_Gamepad) ? ImGuiKey_NavGamepadTweakFast : ImGuiKey_NavKeyboardTweakFast)
				decimal_precision : i32 = is_floating_point ? ImParseFormatPrecision(format, 3) : 0
				if decimal_precision > 0 {
					input_delta /= 100.0; // Keyboard/Gamepad tweak speeds in % of slider bounds
					if tweak_slow { input_delta /= 10.0 }
				}
				else {
					if (v_range_f >= -100.0 && v_range_f <= 100.0 && v_range_f != 0.0) || tweak_slow {
						// Keyboard/Gamepad tweak speeds in integer steps
						input_delta = ((input_delta < 0.0) ? -1.0 : +1.0) / v_range_f
					}
					else { input_delta /= 100.0 }
				}
				if tweak_fast { input_delta *= 10.0 }

				g.SliderCurrentAccum += input_delta
				g.SliderCurrentAccumDirty = true
			}

			delta : f32 = g.SliderCurrentAccum
			if g.NavActivatePressedId == id && !g.ActiveIdIsJustActivated {
				ClearActiveID()
			}
			else if g.SliderCurrentAccumDirty {
				clicked_t = ScaleRatioFromValueT(TYPE, SIGNEDTYPE, FLOATTYPE, data_type, v^, v_min, v_max, is_logarithmic, logarithmic_zero_epsilon, zero_deadzone_halfsize)

				if (clicked_t >= 1.0 && delta > 0.0) || (clicked_t <= 0.0 && delta < 0.0) {
					// This is to avoid applying the saturation when already past the limits
					set_new_value = false
					g.SliderCurrentAccum = 0.0; // If pushing up against the limits, don't continue to accumulate
				}
				else {
					set_new_value = true
					old_clicked_t : f32 = clicked_t
					clicked_t = ImSaturate(clicked_t + delta)

					// Calculate what our "new" clicked_t will be, and thus how far we actually moved the slider, and subtract this from the accumulator
					v_new : TYPE = ScaleValueFromRatioT(TYPE, SIGNEDTYPE, FLOATTYPE, data_type, clicked_t, v_min, v_max, is_logarithmic, logarithmic_zero_epsilon, zero_deadzone_halfsize)
					if is_floating_point && (flags & ImGuiSliderFlags_.ImGuiSliderFlags_NoRoundToFormat) == {} { v_new = RoundScalarWithFormatT(TYPE, format, data_type, v_new) }
					new_clicked_t : f32 = ScaleRatioFromValueT(TYPE, SIGNEDTYPE, FLOATTYPE, data_type, v_new, v_min, v_max, is_logarithmic, logarithmic_zero_epsilon, zero_deadzone_halfsize)

					if delta > 0 { g.SliderCurrentAccum -= ImMin(new_clicked_t - old_clicked_t, delta) }
					else { g.SliderCurrentAccum -= ImMax(new_clicked_t - old_clicked_t, delta) }
				}

				g.SliderCurrentAccumDirty = false
			}
		}

		if set_new_value { if (g.LastItemData.ItemFlags & cast(ImGuiItemFlags) ImGuiItemFlagsPrivate_.ImGuiItemFlags_ReadOnly) != {} || (flags & cast(ImGuiSliderFlags) ImGuiSliderFlagsPrivate_.ImGuiSliderFlags_ReadOnly) != {} { set_new_value = false } }

		if set_new_value {
			v_new : TYPE = ScaleValueFromRatioT(TYPE, SIGNEDTYPE, FLOATTYPE, data_type, clicked_t, v_min, v_max, is_logarithmic, logarithmic_zero_epsilon, zero_deadzone_halfsize)

			// Round to user desired precision based on format string
			if is_floating_point && (flags & ImGuiSliderFlags_.ImGuiSliderFlags_NoRoundToFormat) == {} { v_new = RoundScalarWithFormatT(TYPE, format, data_type, v_new) }

			// Apply result
			if v^ != v_new {
				v^ = v_new
				value_changed = true
			}
		}
	}

	if slider_sz < 1.0 {
		out_grab_bb^ = ImRect{bb.Min, bb.Min}
	}
	else {
		// Output grab position so it can be displayed by the caller
		grab_t : f32 = ScaleRatioFromValueT(TYPE, SIGNEDTYPE, FLOATTYPE, data_type, v^, v_min, v_max, is_logarithmic, logarithmic_zero_epsilon, zero_deadzone_halfsize)
		if axis == ImGuiAxis.ImGuiAxis_Y { grab_t = 1.0 - grab_t }
		grab_pos : f32 = ImLerp(slider_usable_pos_min, slider_usable_pos_max, grab_t)
		if axis == ImGuiAxis.ImGuiAxis_X { out_grab_bb^ = ImRect{{grab_pos - grab_sz * 0.5, bb.Min.y + grab_padding}, {grab_pos + grab_sz * 0.5, bb.Max.y - grab_padding}} }
		else { out_grab_bb^ = ImRect{{bb.Min.x + grab_padding, grab_pos - grab_sz * 0.5}, {bb.Max.x - grab_padding, grab_pos + grab_sz * 0.5}} }
	}

	return value_changed
}

// For 32-bit and larger types, slider bounds are limited to half the natural type range.
// So e.g. an integer Slider between INT_MAX-10 and INT_MAX will fail, but an integer Slider between INT_MAX/2-10 and INT_MAX/2 will be ok.
// It would be possible to lift that limitation with some work but it doesn't seem to be worth it for sliders.
SliderBehavior :: proc(bb : ImRect, id : ImGuiID, data_type : ImGuiDataType, p_v : rawptr, p_min : rawptr, p_max : rawptr, format : string, flags : ImGuiSliderFlags, out_grab_bb : ^ImRect) -> bool
{
	// Read imgui.cpp "API BREAKING CHANGES" section for 1.78 if you hit this assert.
	IM_ASSERT((flags == ImGuiSliderFlags(1) || (flags & ImGuiSliderFlags_.ImGuiSliderFlags_InvalidMask_) == {}), "Invalid ImGuiSliderFlags flags! Has the legacy 'float power' argument been mistakenly cast to flags? Call function with ImGuiSliderFlags_Logarithmic flags instead.")
	IM_ASSERT((flags & ImGuiSliderFlags_.ImGuiSliderFlags_WrapAround) == {}); // Not supported by SliderXXX(), only by DragXXX()

	#partial switch data_type {
		case ImGuiDataType_.ImGuiDataType_S8:{v32 : ImS32 = cast(ImS32) (cast(^ImS8) p_v)^; r : bool = SliderBehaviorT(ImS32, ImS32, f32, bb, id, ImGuiDataType_.ImGuiDataType_S32, &v32, ImS32((cast(^ImS8) p_min)^), ImS32((cast(^ImS8) p_max)^), format, flags, out_grab_bb); if r { (cast(^ImS8) p_v)^ = cast(ImS8) v32 }; return r}
			fallthrough
		case ImGuiDataType_.ImGuiDataType_U8:{v32 : ImU32 = cast(ImU32) (cast(^ImU8) p_v)^; r : bool = SliderBehaviorT(ImU32, ImS32, f32, bb, id, ImGuiDataType_.ImGuiDataType_U32, &v32, ImU32((cast(^ImU8) p_min)^), ImU32((cast(^ImU8) p_max)^), format, flags, out_grab_bb); if r { (cast(^ImU8) p_v)^ = cast(ImU8) v32 }; return r}
			fallthrough
		case ImGuiDataType_.ImGuiDataType_S16:{v32 : ImS32 = cast(ImS32) (cast(^ImS16) p_v)^; r : bool = SliderBehaviorT(ImS32, ImS32, f32, bb, id, ImGuiDataType_.ImGuiDataType_S32, &v32, ImS32((cast(^ImS16) p_min)^), ImS32((cast(^ImS16) p_max)^), format, flags, out_grab_bb); if r { (cast(^ImS16) p_v)^ = cast(ImS16) v32 }; return r}
			fallthrough
		case ImGuiDataType_.ImGuiDataType_U16:{v32 : ImU32 = cast(ImU32) (cast(^ImU16) p_v)^; r : bool = SliderBehaviorT(ImU32, ImS32, f32, bb, id, ImGuiDataType_.ImGuiDataType_U32, &v32, ImU32((cast(^ImU16) p_min)^), ImU32((cast(^ImU16) p_max)^), format, flags, out_grab_bb); if r { (cast(^ImU16) p_v)^ = cast(ImU16) v32 }; return r}
			fallthrough
		case ImGuiDataType_.ImGuiDataType_S32:
			IM_ASSERT((cast(^ImS32) p_min)^ >= IM_S32_MIN / 2 && (cast(^ImS32) p_max)^ <= IM_S32_MAX / 2)
			return SliderBehaviorT(ImS32, ImS32, f32, bb, id, data_type, cast(^ImS32) p_v, (cast(^ImS32) p_min)^, (cast(^ImS32) p_max)^, format, flags, out_grab_bb)
		case ImGuiDataType_.ImGuiDataType_U32:
			IM_ASSERT((cast(^ImU32) p_max)^ <= IM_U32_MAX / 2)
			return SliderBehaviorT(ImU32, ImS32, f32, bb, id, data_type, cast(^ImU32) p_v, (cast(^ImU32) p_min)^, (cast(^ImU32) p_max)^, format, flags, out_grab_bb)
		case ImGuiDataType_.ImGuiDataType_S64:
			IM_ASSERT((cast(^ImS64) p_min)^ >= IM_S64_MIN / 2 && (cast(^ImS64) p_max)^ <= IM_S64_MAX / 2)
			return SliderBehaviorT(ImS64, ImS64, f64, bb, id, data_type, cast(^ImS64) p_v, (cast(^ImS64) p_min)^, (cast(^ImS64) p_max)^, format, flags, out_grab_bb)
		case ImGuiDataType_.ImGuiDataType_U64:
			IM_ASSERT((cast(^ImU64) p_max)^ <= IM_U64_MAX / 2)
			return SliderBehaviorT(ImU64, ImS64, f64, bb, id, data_type, cast(^ImU64) p_v, (cast(^ImU64) p_min)^, (cast(^ImU64) p_max)^, format, flags, out_grab_bb)
		case ImGuiDataType_.ImGuiDataType_Float:
			IM_ASSERT((cast(^f32) p_min)^ >= -FLT_MAX / 2.0 && (cast(^f32) p_max)^ <= FLT_MAX / 2.0)
			return SliderBehaviorT(f32, f32, f32, bb, id, data_type, cast(^f32) p_v, (cast(^f32) p_min)^, (cast(^f32) p_max)^, format, flags, out_grab_bb)
		case ImGuiDataType_.ImGuiDataType_Double:
			IM_ASSERT((cast(^f64) p_min)^ >= -DBL_MAX / 2.0 && (cast(^f64) p_max)^ <= DBL_MAX / 2.0)
			return SliderBehaviorT(f64, f64, f64, bb, id, data_type, cast(^f64) p_v, (cast(^f64) p_min)^, (cast(^f64) p_max)^, format, flags, out_grab_bb)
		case ImGuiDataType_.ImGuiDataType_COUNT:break
	}
	IM_ASSERT(false)
	return false
}

// Note: p_data, p_min and p_max are _pointers_ to a memory address holding the data. For a slider, they are all required.
// Read code of e.g. SliderFloat(), SliderInt() etc. or examples in 'Demo->Widgets->Data Types' to understand how to use this function directly.
SliderScalar :: proc(label : string, data_type : ImGuiDataType, p_data : rawptr, p_min : rawptr, p_max : rawptr, format : string = "", flags : ImGuiSliderFlags = {}) -> bool
{
	window : ^ImGuiWindow = GetCurrentWindow()
	if window.SkipItems { return false }

	g : ^ImGuiContext = GImGui
	style : ^ImGuiStyle = &g.Style
	id : ImGuiID = GetID(window, label)
	w : f32 = CalcItemWidth()

	label_size : ImVec2 = CalcTextSize(label, true)
	frame_bb : ImRect; init(&frame_bb, window.DC.CursorPos, window.DC.CursorPos + ImVec2{w, label_size.y + style.FramePadding.y * 2.0})
	total_bb : ImRect; init(&total_bb, frame_bb.Min, frame_bb.Max + ImVec2{label_size.x > 0.0 ? style.ItemInnerSpacing.x + label_size.x : 0.0, 0.0})

	temp_input_allowed : bool = (flags & ImGuiSliderFlags_.ImGuiSliderFlags_NoInput) == {}
	ItemSize(total_bb, style.FramePadding.y)
	if !ItemAdd(total_bb, id, &frame_bb, temp_input_allowed ? cast(ImGuiItemFlags)ImGuiItemFlagsPrivate_.ImGuiItemFlags_Inputable : {}) { return false }

	format := format
	// Default format string when passing NULL
	if format == "" { format = DataTypeGetInfo(data_type).PrintFmt }

	hovered : bool = ItemHoverable(frame_bb, id, g.LastItemData.ItemFlags)
	temp_input_is_active : bool = temp_input_allowed && TempInputIsActive(id)
	if !temp_input_is_active {
		// Tabbing or CTRL-clicking on Slider turns it into an input box
		clicked : bool = hovered && IsMouseClicked(ImGuiMouseButton(0), ImGuiInputFlags_.ImGuiInputFlags_None, id)
		make_active : bool = (clicked || g.NavActivateId == id)
		if make_active && clicked { SetKeyOwner(ImGuiKey.ImGuiKey_MouseLeft, id) }
		if make_active && temp_input_allowed { if (clicked && g.IO.KeyCtrl) || (g.NavActivateId == id && (g.NavActivateFlags & ImGuiActivateFlags_.ImGuiActivateFlags_PreferInput) != {}) { temp_input_is_active = true } }

		// Store initial value (not used by main lib but available as a convenience but some mods e.g. to revert)
		if make_active { memcpy(&g.ActiveIdValueOnActivation, p_data, cast(int)DataTypeGetInfo(data_type).Size) }

		if make_active && !temp_input_is_active {
			SetActiveID(id, window)
			SetFocusID(id, window)
			FocusWindow(window)
			g.ActiveIdUsingNavDirMask |= (1 << cast(u32)ImGuiDir.ImGuiDir_Left) | (1 << cast(u32)ImGuiDir.ImGuiDir_Right)
		}
	}

	if temp_input_is_active {
		// Only clamp CTRL+Click input when ImGuiSliderFlags_ClampOnInput is set (generally via ImGuiSliderFlags_AlwaysClamp)
		clamp_enabled : bool = (flags & ImGuiSliderFlags_.ImGuiSliderFlags_ClampOnInput) != {}
		return TempInputScalar(frame_bb, id, label, data_type, p_data, format, clamp_enabled ? p_min : nil, clamp_enabled ? p_max : nil)
	}

	// Draw frame
	frame_col : ImU32 = GetColorU32(g.ActiveId == id ? ImGuiCol_.ImGuiCol_FrameBgActive : hovered ? ImGuiCol_.ImGuiCol_FrameBgHovered : ImGuiCol_.ImGuiCol_FrameBg)
	RenderNavCursor(frame_bb, id)
	RenderFrame(frame_bb.Min, frame_bb.Max, frame_col, true, g.Style.FrameRounding)

	// Slider behavior
	grab_bb : ImRect
	value_changed : bool = SliderBehavior(frame_bb, id, data_type, p_data, p_min, p_max, format, flags, &grab_bb)
	if value_changed { MarkItemEdited(id) }

	// Render grab
	if grab_bb.Max.x > grab_bb.Min.x { AddRectFilled(window.DrawList, grab_bb.Min, grab_bb.Max, GetColorU32(g.ActiveId == id ? ImGuiCol_.ImGuiCol_SliderGrabActive : ImGuiCol_.ImGuiCol_SliderGrab), style.GrabRounding) }

	// Display value using user-provided display format so user can add prefix/suffix/decorations to the value.
	value_buf : [64]u8
	value_buf_len := DataTypeFormatString(value_buf[:], data_type, p_data, format)
	if g.LogEnabled { LogSetNextTextDecoration("{", "}") }
	RenderTextClipped(frame_bb.Min, frame_bb.Max, string_from_slice(value_buf[:value_buf_len], false), nil, &ImVec2{0.5, 0.5})

	if label_size.x > 0.0 { RenderText(ImVec2{frame_bb.Max.x + style.ItemInnerSpacing.x, frame_bb.Min.y + style.FramePadding.y}, label) }

	when IMGUI_ENABLE_TEST_ENGINE {
		if(g.TestEngineHookItems) {
			ImGuiTestEngineHook_ItemInfo(g, id, label, g.LastItemData.StatusFlags | (temp_input_allowed ? ImGuiItemStatusFlags_.ImGuiItemStatusFlags_Inputable : {}))
		}
	}
	return value_changed
}

// Add multiple sliders on 1 line for compact edition of multiple components
SliderScalarN :: proc(label : string, data_type : ImGuiDataType, v : rawptr, components : i32, v_min : rawptr, v_max : rawptr, format : string = "", flags : ImGuiSliderFlags = {}) -> bool
{
	window : ^ImGuiWindow = GetCurrentWindow()
	if window.SkipItems { return false }

	v := v
	g : ^ImGuiContext = GImGui
	value_changed : bool = false
	BeginGroup()
	PushID(label)
	PushMultiItemsWidths(components, CalcItemWidth())
	type_size : uint = GDataTypeInfo[data_type].Size
	for i : i32 = 0; i < components; i += 1 {
		PushID(i)
		if i > 0 { SameLine(0, g.Style.ItemInnerSpacing.x) }
		value_changed |= SliderScalar("", data_type, v, v_min, v_max, format, flags)
		PopID()
		PopItemWidth()
		v = cast(rawptr) ((cast([^]u8) v)[type_size:])
	}

	PopID()

	label_end := FindRenderedTextEnd(label)
	if len(label) != label_end {
		SameLine(0, g.Style.ItemInnerSpacing.x)
		TextEx(label[:label_end])
	}

	EndGroup()
	return value_changed
}

SliderFloat :: proc(label : string, v : ^f32, v_min : f32, v_max : f32, format : string = "%.3f", flags : ImGuiSliderFlags = {}) -> bool
{
	v_min, v_max := v_min, v_max
	return SliderScalar(label, ImGuiDataType_.ImGuiDataType_Float, v, &v_min, &v_max, format, flags)
}

SliderFloat2 :: proc(label : string, v : ^[2]f32, v_min : f32, v_max : f32, format : string = "%.3f", flags : ImGuiSliderFlags = {}) -> bool
{
	v_min, v_max := v_min, v_max
	return SliderScalarN(label, ImGuiDataType_.ImGuiDataType_Float, v, 2, &v_min, &v_max, format, flags)
}

SliderFloat3 :: proc(label : string, v : ^[3]f32, v_min : f32, v_max : f32, format : string = "%.3f", flags : ImGuiSliderFlags = {}) -> bool
{
	v_min, v_max := v_min, v_max
	return SliderScalarN(label, ImGuiDataType_.ImGuiDataType_Float, v, 3, &v_min, &v_max, format, flags)
}

SliderFloat4 :: proc(label : string, v : ^[4]f32, v_min : f32, v_max : f32, format : string = "%.3f", flags : ImGuiSliderFlags = {}) -> bool
{
	v_min, v_max := v_min, v_max
	return SliderScalarN(label, ImGuiDataType_.ImGuiDataType_Float, v, 4, &v_min, &v_max, format, flags)
}

SliderAngle :: proc(label : string, v_rad : ^f32, v_degrees_min : f32 = -360, v_degrees_max : f32 = +360, format : string = "%.0f deg", flags : ImGuiSliderFlags = {}) -> bool
{
	format := format
	if format == "" { format = "%.0f deg" }
	v_deg : f32 = (v_rad^) * 360.0 / (2 * IM_PI)
	value_changed : bool = SliderFloat(label, &v_deg, v_degrees_min, v_degrees_max, format, flags)
	if value_changed { v_rad^ = v_deg * (2 * IM_PI) / 360.0 }
	return value_changed
}

SliderInt :: proc(label : string, v : ^i32, v_min : i32, v_max : i32, format : string = "%d", flags : ImGuiSliderFlags = {}) -> bool
{
	v_min, v_max := v_min, v_max
	return SliderScalar(label, ImGuiDataType_.ImGuiDataType_S32, v, &v_min, &v_max, format, flags)
}

SliderInt2 :: proc(label : string, v : ^[2]i32, v_min : i32, v_max : i32, format : string = "%d", flags : ImGuiSliderFlags = {}) -> bool
{
	v_min, v_max := v_min, v_max
	return SliderScalarN(label, ImGuiDataType_.ImGuiDataType_S32, v, 2, &v_min, &v_max, format, flags)
}

SliderInt3 :: proc(label : string, v : ^[3]i32, v_min : i32, v_max : i32, format : string = "%d", flags : ImGuiSliderFlags = {}) -> bool
{
	v_min, v_max := v_min, v_max
	return SliderScalarN(label, ImGuiDataType_.ImGuiDataType_S32, v, 3, &v_min, &v_max, format, flags)
}

SliderInt4 :: proc(label : string, v : ^[4]i32, v_min : i32, v_max : i32, format : string = "%d", flags : ImGuiSliderFlags = {}) -> bool
{
	v_min, v_max := v_min, v_max
	return SliderScalarN(label, ImGuiDataType_.ImGuiDataType_S32, v, 4, &v_min, &v_max, format, flags)
}

VSliderScalar :: proc(label : string, size : ImVec2, data_type : ImGuiDataType, p_data : rawptr, p_min : rawptr, p_max : rawptr, format : string = "", flags : ImGuiSliderFlags = {}) -> bool
{
	window : ^ImGuiWindow = GetCurrentWindow()
	if window.SkipItems { return false }

	g : ^ImGuiContext = GImGui
	style : ^ImGuiStyle = &g.Style
	id : ImGuiID = GetID(window, label)

	label_size : ImVec2 = CalcTextSize(label, true)
	frame_bb : ImRect; init(&frame_bb, window.DC.CursorPos, window.DC.CursorPos + size)
	bb : ImRect; init(&bb, frame_bb.Min, frame_bb.Max + ImVec2{label_size.x > 0.0 ? style.ItemInnerSpacing.x + label_size.x : 0.0, 0.0})

	ItemSize(bb, style.FramePadding.y)
	if !ItemAdd(frame_bb, id) { return false }

	format := format
	// Default format string when passing NULL
	if format == "" { format = DataTypeGetInfo(data_type).PrintFmt }

	hovered : bool = ItemHoverable(frame_bb, id, g.LastItemData.ItemFlags)
	clicked : bool = hovered && IsMouseClicked(ImGuiMouseButton(0), ImGuiInputFlags_.ImGuiInputFlags_None, id)
	if clicked || g.NavActivateId == id {
		if clicked { SetKeyOwner(ImGuiKey.ImGuiKey_MouseLeft, id) }
		SetActiveID(id, window)
		SetFocusID(id, window)
		FocusWindow(window)
		g.ActiveIdUsingNavDirMask |= (1 << cast(u32)ImGuiDir.ImGuiDir_Up) | (1 << cast(u32)ImGuiDir.ImGuiDir_Down)
	}

	// Draw frame
	frame_col : ImU32 = GetColorU32(g.ActiveId == id ? ImGuiCol_.ImGuiCol_FrameBgActive : hovered ? ImGuiCol_.ImGuiCol_FrameBgHovered : ImGuiCol_.ImGuiCol_FrameBg)
	RenderNavCursor(frame_bb, id)
	RenderFrame(frame_bb.Min, frame_bb.Max, frame_col, true, g.Style.FrameRounding)

	// Slider behavior
	grab_bb : ImRect
	value_changed : bool = SliderBehavior(frame_bb, id, data_type, p_data, p_min, p_max, format, flags | cast(ImGuiSliderFlags)ImGuiSliderFlagsPrivate_.ImGuiSliderFlags_Vertical, &grab_bb)
	if value_changed { MarkItemEdited(id) }

	// Render grab
	if grab_bb.Max.y > grab_bb.Min.y { AddRectFilled(window.DrawList, grab_bb.Min, grab_bb.Max, GetColorU32(g.ActiveId == id ? ImGuiCol_.ImGuiCol_SliderGrabActive : ImGuiCol_.ImGuiCol_SliderGrab), style.GrabRounding) }

	// Display value using user-provided display format so user can add prefix/suffix/decorations to the value.
	// For the vertical slider we allow centered text to overlap the frame padding
	value_buf : [64]u8
	value_buf_len := DataTypeFormatString(value_buf[:], data_type, p_data, format)
	RenderTextClipped(ImVec2{frame_bb.Min.x, frame_bb.Min.y + style.FramePadding.y}, frame_bb.Max, string_from_slice(value_buf[:value_buf_len], false), nil, &ImVec2{0.5, 0.0})
	if label_size.x > 0.0 { RenderText(ImVec2{frame_bb.Max.x + style.ItemInnerSpacing.x, frame_bb.Min.y + style.FramePadding.y}, label) }

	return value_changed
}

VSliderFloat :: proc(label : string, size : ImVec2, v : ^f32, v_min : f32, v_max : f32, format : string = "%.3f", flags : ImGuiSliderFlags = {}) -> bool
{
	v_min, v_max := v_min, v_max
	return VSliderScalar(label, size, ImGuiDataType_.ImGuiDataType_Float, v, &v_min, &v_max, format, flags)
}

VSliderInt :: proc(label : string, size : ImVec2, v : ^i32, v_min : i32, v_max : i32, format : string = "%d", flags : ImGuiSliderFlags = {}) -> bool
{
	v_min, v_max := v_min, v_max
	return VSliderScalar(label, size, ImGuiDataType_.ImGuiDataType_S32, v, &v_min, &v_max, format, flags)
}

//-------------------------------------------------------------------------
// [SECTION] Widgets: InputScalar, InputFloat, InputInt, etc.
//-------------------------------------------------------------------------
// - ImParseFormatFindStart() [Internal]
// - ImParseFormatFindEnd() [Internal]
// - ImParseFormatTrimDecorations() [Internal]
// - ImParseFormatSanitizeForPrinting() [Internal]
// - ImParseFormatSanitizeForScanning() [Internal]
// - ImParseFormatPrecision() [Internal]
// - TempInputTextScalar() [Internal]
// - InputScalar()
// - InputScalarN()
// - InputFloat()
// - InputFloat2()
// - InputFloat3()
// - InputFloat4()
// - InputInt()
// - InputInt2()
// - InputInt3()
// - InputInt4()
// - InputDouble()
//-------------------------------------------------------------------------

// We don't use strchr() because our strings are usually very short and often start with '%'
ImParseFormatFindStart :: proc(fmt : string) -> string
{
	it := raw_data(fmt)
	end := raw_data(fmt)[len(fmt):]

	for it < end {
		if it[0] == '%' && it[1] != '%' { break }
		else if it[0] == '%' { it = it[1:] }
	}

	return string_from_se(it, cast(^u8)end)
}

ImParseFormatFindEnd :: proc(fmt : string) -> string
{
	it := raw_data(fmt)
	end := raw_data(fmt)[len(fmt):]
	// Printf/scanf types modifiers: I/L/h/j/l/t/w/z. Other uppercase letters qualify as types aka end of the format.
	if it[0] != '%' { return fmt }
	ignored_uppercase_mask : u32 = (1 << ('I' - 'A')) | (1 << ('L' - 'A'))
	ignored_lowercase_mask : u32 = (1 << ('h' - 'a')) | (1 << ('j' - 'a')) | (1 << ('l' - 'a')) | (1 << ('t' - 'a')) | (1 << ('w' - 'a')) | (1 << ('z' - 'a'))
	for c : u8; ; it = it[1:] {
		c = it[0]; if c == 0 { break }
		if c >= 'A' && c <= 'Z' && ((1 << (c - 'A')) & ignored_uppercase_mask) == 0 { it = it[1:]; break }
		if c >= 'a' && c <= 'z' && ((1 << (c - 'a')) & ignored_lowercase_mask) == 0 { it = it[1:]; break }
	}

	return string_from_se(raw_data(fmt), cast(^u8)it)
}

// Extract the format out of a format string with leading or trailing decorations
//  fmt = "blah blah"  -> return ""
//  fmt = "%.3f"       -> return fmt
//  fmt = "hello %.3f" -> return fmt + 6
//  fmt = "%.3f hello" -> return buf written with "%.3f"
ImParseFormatTrimDecorations :: proc(fmt : string, _ : []u8 = {}) -> string
{
	fmt_start := ImParseFormatFindStart(fmt)
	if fmt_start[0] != '%' { return "" }
	return ImParseFormatFindEnd(fmt_start)
}

// Sanitize format
// - Zero terminate so extra characters after format (e.g. "%f123") don't confuse atof/atoi
// - stb_sprintf.h supports several new modifiers which format numbers in a way that also makes them incompatible atof/atoi.
ImParseFormatSanitizeForPrinting :: proc(fmt_in : string, fmt_out : []u8) -> string
{
	fmt := ImParseFormatFindEnd(fmt_in)
	out := raw_data(fmt_out)
	IM_ASSERT(len(fmt) <= len(fmt_out)); // Format is too long, let us know if this happens to you!
	for c in transmute([]u8)fmt {
		if c != '\'' && c != '$' && c != '_' {
			// Custom flags provided by stb_sprintf.h. POSIX 2008 also supports '.
			(post_incr(&out))^ = c
		}
	}

	return string_from_se(raw_data(fmt_out), cast(^u8)out)
}

// - For scanning we need to remove all width and precision fields and flags "%+3.7f" -> "%f". BUT don't strip types like "%I64d" which includes digits. ! "%07I64d" -> "%I64d"
ImParseFormatSanitizeForScanning :: proc(fmt_in : string, fmt_out : []u8) -> string
{
	fmt := ImParseFormatFindEnd(fmt_in)
	IM_ASSERT(len(fmt) < len(fmt_out)); // Format is too long, let us know if this happens to you!
	out := raw_data(fmt_out)
	has_type : bool = false
	for c in transmute([]u8)fmt {
		if !has_type && ((c >= '0' && c <= '9') || c == '.' || c == '+' || c == '#') { continue }
		has_type |= ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')); // Stop skipping digits
		if c != '\'' && c != '$' && c != '_' {
			// Custom flags provided by stb_sprintf.h. POSIX 2008 also supports '.
			(post_incr(&out))^ = c
		}
	}

	return string_from_se(raw_data(fmt_out), cast(^u8)out)
}

ImAtoi :: proc($TYPE : typeid, src_ : string, output : ^TYPE) -> string
{
	src := raw_data(src_)
	negative : i32 = 0
	if src[0] == '-' { negative = 1; post_incr(&src) }
	if src[0] == '+' { post_incr(&src) }
	v : TYPE = 0
	for src[0] >= '0' && src[0] <= '9' { v = (v * 10) + TYPE(post_incr(&src)^ - '0') }

	output^ = negative != 0 ? -v : v
	return string_from_se(src, &raw_data(src_)[len(src_)])
}

// Parse display precision back from the display format string
// FIXME: This is still used by some navigation code path to infer a minimum tweak step, but we should aim to rework widgets so it isn't needed.
ImParseFormatPrecision :: proc(fmt : string, default_precision : i32) -> i32
{
	fmt := ImParseFormatFindStart(fmt)
	if fmt[0] != '%' { return default_precision }
	fmt = fmt[1:]
	for fmt[0] >= '0' && fmt[0] <= '9' { fmt = fmt[1:] }

	precision : i32 = INT_MAX
	if fmt[0] == '.' {
		fmt = ImAtoi(i32, fmt[1:], &precision)
		if precision < 0 || precision > 99 { precision = default_precision }
	}
	if fmt[0] == 'e' || fmt[0] == 'E' {
		// Maximum precision with scientific notation
		precision = -1
	}
	if (fmt[0] == 'g' || fmt[0] == 'G') && precision == INT_MAX { precision = -1 }
	return (precision == INT_MAX) ? default_precision : precision
}

// Create text input in place of another active widget (e.g. used when doing a CTRL+Click on drag/slider widgets)
// FIXME: Facilitate using this in variety of other situations.
// FIXME: Among other things, setting ImGuiItemFlags_AllowDuplicateId in LastItemData is currently correct but
// the expected relationship between TempInputXXX functions and LastItemData is a little fishy.
TempInputText :: proc(bb : ImRect, id : ImGuiID, label : string, buf : []u8, flags : ImGuiInputTextFlags) -> bool
{
	// On the first frame, g.TempInputTextId == 0, then on subsequent frames it becomes == id.
	// We clear ActiveID on the first frame to allow the InputText() taking it back.
	g : ^ImGuiContext = GImGui
	init : bool = (g.TempInputId != id)
	if init { ClearActiveID() }

	g.CurrentWindow.DC.CursorPos = bb.Min
	g.LastItemData.ItemFlags |= ImGuiItemFlags_.ImGuiItemFlags_AllowDuplicateId
	value_changed : bool = InputTextEx(label, "", buf, GetSize(bb), flags | cast(ImGuiInputTextFlags)ImGuiInputTextFlagsPrivate_.ImGuiInputTextFlags_MergedItem)
	if init {
		// First frame we started displaying the InputText widget, we expect it to take the active id.
		IM_ASSERT(g.ActiveId == id)
		g.TempInputId = g.ActiveId
	}
	return value_changed
}

// Note that Drag/Slider functions are only forwarding the min/max values clamping values if the ImGuiSliderFlags_AlwaysClamp flag is set!
// This is intended: this way we allow CTRL+Click manual input to set a value out of bounds, for maximum flexibility.
// However this may not be ideal for all uses, as some user code may break on out of bound values.
TempInputScalar :: proc(bb : ImRect, id : ImGuiID, label : string, data_type : ImGuiDataType, p_data : rawptr, format : string, p_clamp_min : rawptr = nil, p_clamp_max : rawptr = nil) -> bool
{
	// FIXME: May need to clarify display behavior if format doesn't contain %.
	// "%d" -> "%d" / "There are %d items" -> "%d" / "items" -> "%d" (fallback). Also see #6405
	g : ^ImGuiContext = GImGui
	type_info : ^ImGuiDataTypeInfo = DataTypeGetInfo(data_type)
	fmt_buf : [32]u8
	data_buf : [32]u8
	format := ImParseFormatTrimDecorations(format)
	if format[0] == 0 { format = type_info.PrintFmt }
	DataTypeFormatString(data_buf[:], data_type, p_data, format)
	data_len := ImStrTrimBlanks(raw_data(&data_buf))

	flags : ImGuiInputTextFlags = ImGuiInputTextFlags_.ImGuiInputTextFlags_AutoSelectAll | cast(ImGuiInputTextFlags) ImGuiInputTextFlagsPrivate_.ImGuiInputTextFlags_LocalizeDecimalPoint
	g.LastItemData.ItemFlags |= cast(ImGuiItemFlags) ImGuiItemFlagsPrivate_.ImGuiItemFlags_NoMarkEdited; // Because TempInputText() uses ImGuiInputTextFlags_MergedItem it doesn't submit a new item, so we poke LastItemData.
	value_changed : bool = false
	if TempInputText(bb, id, label, data_buf[:data_len], flags) {
		// Backup old value
		data_type_size : uint = type_info.Size
		data_backup : ImGuiDataTypeStorage
		memcpy(&data_backup, p_data, cast(int)data_type_size)

		// Apply new value (or operations) then clamp
		DataTypeApplyFromText(data_buf[:], data_type, p_data, format, nil)
		if p_clamp_min != nil || p_clamp_max != nil {
			p_clamp_min, p_clamp_max := p_clamp_min, p_clamp_max
			if p_clamp_min != nil && p_clamp_max != nil && DataTypeCompare(data_type, p_clamp_min, p_clamp_max) > 0 { ImSwap(&p_clamp_min, &p_clamp_max) }
			DataTypeClamp(data_type, p_data, p_clamp_min, p_clamp_max)
		}

		// Only mark as edited if new value is different
		g.LastItemData.ItemFlags &= cast(ImGuiItemFlags)~cast(i32)ImGuiItemFlagsPrivate_.ImGuiItemFlags_NoMarkEdited
		value_changed = memcmp(&data_backup, p_data, data_type_size) != 0
		if value_changed { MarkItemEdited(id) }
	}
	return value_changed
}

SetNextItemRefVal :: proc(data_type : ImGuiDataType, p_data : rawptr)
{
	g : ^ImGuiContext = GImGui
	g.NextItemData.HasFlags |= ImGuiNextItemDataFlags_.ImGuiNextItemDataFlags_HasRefVal
	memcpy(&g.NextItemData.RefVal, p_data, cast(int)DataTypeGetInfo(data_type).Size)
}

// Note: p_data, p_step, p_step_fast are _pointers_ to a memory address holding the data. For an Input widget, p_step and p_step_fast are optional.
// Read code of e.g. InputFloat(), InputInt() etc. or examples in 'Demo->Widgets->Data Types' to understand how to use this function directly.
InputScalar :: proc(label : string, data_type : ImGuiDataType, p_data : rawptr, p_step : rawptr, p_step_fast : rawptr, format : string, flags : ImGuiInputTextFlags) -> bool
{
	window : ^ImGuiWindow = GetCurrentWindow()
	if window.SkipItems { return false }

	g : ^ImGuiContext = GImGui
	style : ^ImGuiStyle = &g.Style
	IM_ASSERT((flags & ImGuiInputTextFlags_.ImGuiInputTextFlags_EnterReturnsTrue) == {}); // Not supported by InputScalar(). Please open an issue if you this would be useful to you. Otherwise use IsItemDeactivatedAfterEdit()!

	format := format
	if format == "" { format = DataTypeGetInfo(data_type).PrintFmt }

	p_data_default : rawptr = (g.NextItemData.HasFlags & ImGuiNextItemDataFlags_.ImGuiNextItemDataFlags_HasRefVal) != {} ? &g.NextItemData.RefVal : &g.DataTypeZeroValue

	buf : [64]u8
	if (flags & ImGuiInputTextFlags_.ImGuiInputTextFlags_DisplayEmptyRefVal) != {} && DataTypeCompare(data_type, p_data, p_data_default) == 0 { buf[0] = 0 }
	else { DataTypeFormatString(buf[:], data_type, p_data, format) }

	flags := flags
	// Disable the MarkItemEdited() call in InputText but keep ImGuiItemStatusFlags_Edited.
	// We call MarkItemEdited() ourselves by comparing the actual data rather than the string.
	g.NextItemData.ItemFlags |= cast(ImGuiItemFlags) ImGuiItemFlagsPrivate_.ImGuiItemFlags_NoMarkEdited
	flags |= ImGuiInputTextFlags_.ImGuiInputTextFlags_AutoSelectAll | cast(ImGuiInputTextFlags) ImGuiInputTextFlagsPrivate_.ImGuiInputTextFlags_LocalizeDecimalPoint

	value_changed : bool = false
	if p_step == nil {
		if InputText(label, buf[:], flags) { value_changed = DataTypeApplyFromText(buf[:], data_type, p_data, format, (flags & ImGuiInputTextFlags_.ImGuiInputTextFlags_ParseEmptyRefVal) != {} ? p_data_default : nil) }
	}
	else {
		button_size : f32 = GetFrameHeight()

		BeginGroup(); // The only purpose of the group here is to allow the caller to query item data e.g. IsItemActive()
		PushID(label)
		SetNextItemWidth(ImMax(f32(1.0), CalcItemWidth() - (button_size + style.ItemInnerSpacing.x) * 2))
		if InputText("", buf[:], flags) {
			// PushId(label) + "" gives us the expected ID from outside point of view
			value_changed = DataTypeApplyFromText(buf[:], data_type, p_data, format, (flags & ImGuiInputTextFlags_.ImGuiInputTextFlags_ParseEmptyRefVal) != {} ? p_data_default : nil)
		}
		when IMGUI_ENABLE_TEST_ENGINE {
			if(g.TestEngineHookItems) {
				ImGuiTestEngineHook_ItemInfo(g, g.LastItemData.ID, label, g.LastItemData.StatusFlags | ImGuiItemStatusFlags_.ImGuiItemStatusFlags_Inputable)
			}
		}

		// Step buttons
		backup_frame_padding : ImVec2 = style.FramePadding
		style.FramePadding.x = style.FramePadding.y
		if (flags & ImGuiInputTextFlags_.ImGuiInputTextFlags_ReadOnly) != {} { BeginDisabled() }
		PushItemFlag(ImGuiItemFlags_.ImGuiItemFlags_ButtonRepeat, true)
		SameLine(0, style.ItemInnerSpacing.x)
		if ButtonEx("-", ImVec2{button_size, button_size}) {
			DataTypeApplyOp(data_type, '-', p_data, p_data, g.IO.KeyCtrl && p_step_fast != nil ? p_step_fast : p_step)
			value_changed = true
		}
		SameLine(0, style.ItemInnerSpacing.x)
		if ButtonEx("+", ImVec2{button_size, button_size}) {
			DataTypeApplyOp(data_type, '+', p_data, p_data, g.IO.KeyCtrl && p_step_fast != nil ? p_step_fast : p_step)
			value_changed = true
		}
		PopItemFlag()
		if (flags & ImGuiInputTextFlags_.ImGuiInputTextFlags_ReadOnly) != {} { EndDisabled() }

		label_end := FindRenderedTextEnd(label)
		if len(label) != label_end {
			SameLine(0, style.ItemInnerSpacing.x)
			TextEx(label[:label_end])
		}
		style.FramePadding = backup_frame_padding

		PopID()
		EndGroup()
	}

	g.LastItemData.ItemFlags &= cast(ImGuiItemFlags)~cast(i32)ImGuiItemFlagsPrivate_.ImGuiItemFlags_NoMarkEdited
	if value_changed { MarkItemEdited(g.LastItemData.ID) }

	return value_changed
}

InputScalarN :: proc(label : string, data_type : ImGuiDataType, p_data : rawptr, components : i32, p_step : rawptr = nil, p_step_fast : rawptr = nil, format : string = "", flags : ImGuiInputTextFlags = {}) -> bool
{
	window : ^ImGuiWindow = GetCurrentWindow()
	if window.SkipItems { return false }

	p_data := p_data
	g : ^ImGuiContext = GImGui
	value_changed : bool = false
	BeginGroup()
	PushID(label)
	PushMultiItemsWidths(components, CalcItemWidth())
	type_size : uint = GDataTypeInfo[data_type].Size
	for i : i32 = 0; i < components; i += 1 {
		PushID(i)
		if i > 0 { SameLine(0, g.Style.ItemInnerSpacing.x) }
		value_changed |= InputScalar("", data_type, p_data, p_step, p_step_fast, format, flags)
		PopID()
		PopItemWidth()
		p_data = cast(rawptr) ((cast([^]u8) p_data)[type_size:])
	}

	PopID()

	label_end := FindRenderedTextEnd(label)
	if len(label) != label_end {
		SameLine(0.0, g.Style.ItemInnerSpacing.x)
		TextEx(label[:label_end])
	}

	EndGroup()
	return value_changed
}

InputFloat :: proc(label : string, v : ^f32, step : f32 = 0, step_fast : f32 = 0, format : string = "%.3f", flags : ImGuiInputTextFlags = {}) -> bool
{
	step, step_fast := step, step_fast
	return InputScalar(label, ImGuiDataType_.ImGuiDataType_Float, cast(rawptr) v, cast(rawptr) (step > 0.0 ? &step : nil), cast(rawptr) (step_fast > 0.0 ? &step_fast : nil), format, flags)
}

InputFloat2 :: proc(label : string, v : ^[2]f32, format : string = "$.3f", flags : ImGuiInputTextFlags = {}) -> bool
{
	return InputScalarN(label, ImGuiDataType_.ImGuiDataType_Float, v, 2, nil, nil, format, flags)
}

InputFloat3 :: proc(label : string, v : ^[3]f32, format : string = "$.3f", flags : ImGuiInputTextFlags = {}) -> bool
{
	return InputScalarN(label, ImGuiDataType_.ImGuiDataType_Float, v, 3, nil, nil, format, flags)
}

InputFloat4 :: proc(label : string, v : ^[4]f32, format : string = "$.3f", flags : ImGuiInputTextFlags = {}) -> bool
{
	return InputScalarN(label, ImGuiDataType_.ImGuiDataType_Float, v, 4, nil, nil, format, flags)
}

InputInt :: proc(label : string, v : ^i32, step : i32 = 1, step_fast : i32 = 100, flags : ImGuiInputTextFlags = {}) -> bool
{
	step, step_fast := step, step_fast
	// Hexadecimal input provided as a convenience but the flag name is awkward. Typically you'd use InputText() to parse your own data, if you want to handle prefixes.
	format : string = (flags & ImGuiInputTextFlags_.ImGuiInputTextFlags_CharsHexadecimal) != {} ? "%08X" : "%d"
	return InputScalar(label, ImGuiDataType_.ImGuiDataType_S32, cast(rawptr) v, cast(rawptr) (step > 0 ? &step : nil), cast(rawptr) (step_fast > 0 ? &step_fast : nil), format, flags)
}

InputInt2 :: proc(label : string, v : ^[2]i32, flags : ImGuiInputTextFlags = {}) -> bool
{
	return InputScalarN(label, ImGuiDataType_.ImGuiDataType_S32, v, 2, nil, nil, "%d", flags)
}

InputInt3 :: proc(label : string, v : ^[3]i32, flags : ImGuiInputTextFlags = {}) -> bool
{
	return InputScalarN(label, ImGuiDataType_.ImGuiDataType_S32, v, 3, nil, nil, "%d", flags)
}

InputInt4 :: proc(label : string, v : ^[4]i32, flags : ImGuiInputTextFlags = {}) -> bool
{
	return InputScalarN(label, ImGuiDataType_.ImGuiDataType_S32, v, 4, nil, nil, "%d", flags)
}

InputDouble :: proc(label : string, v : ^f64, step : f64 = 0, step_fast : f64 = 0, format : string = "%.6f", flags : ImGuiInputTextFlags = {}) -> bool
{
	step, step_fast := step, step_fast
	return InputScalar(label, ImGuiDataType_.ImGuiDataType_Double, cast(rawptr) v, cast(rawptr) (step > 0.0 ? &step : nil), cast(rawptr) (step_fast > 0.0 ? &step_fast : nil), format, flags)
}

//-------------------------------------------------------------------------
// [SECTION] Widgets: InputText, InputTextMultiline, InputTextWithHint
//-------------------------------------------------------------------------
// - InputText()
// - InputTextWithHint()
// - InputTextMultiline()
// - InputTextGetCharInfo() [Internal]
// - InputTextReindexLines() [Internal]
// - InputTextReindexLinesRange() [Internal]
// - InputTextEx() [Internal]
// - DebugNodeInputTextState() [Internal]
//-------------------------------------------------------------------------

InputText :: proc(label : string, buf : []u8, flags : ImGuiInputTextFlags = {}, callback : ImGuiInputTextCallback = nil, user_data : rawptr = nil) -> bool
{
	IM_ASSERT((flags & cast(ImGuiInputTextFlags) ImGuiInputTextFlagsPrivate_.ImGuiInputTextFlags_Multiline) == {}); // call InputTextMultiline()
	return InputTextEx(label, "", buf, ImVec2{0, 0}, flags, callback, user_data)
}

InputTextMultiline :: proc(label : string, buf : []u8, size : ImVec2, flags : ImGuiInputTextFlags = {}, callback : ImGuiInputTextCallback = nil, user_data : rawptr = nil) -> bool
{
	return InputTextEx(label, "", buf, size, flags | cast(ImGuiInputTextFlags) ImGuiInputTextFlagsPrivate_.ImGuiInputTextFlags_Multiline, callback, user_data)
}

InputTextWithHint :: proc(label : string, hint : string, buf : []u8, flags : ImGuiInputTextFlags = {}, callback : ImGuiInputTextCallback = nil, user_data : rawptr = nil) -> bool
{
	IM_ASSERT((flags & cast(ImGuiInputTextFlags) ImGuiInputTextFlagsPrivate_.ImGuiInputTextFlags_Multiline) == {}); // call InputTextMultiline() or  InputTextEx() manually if you need multi-line + hint.
	return InputTextEx(label, hint, buf, ImVec2{0, 0}, flags, callback, user_data)
}

// This is only used in the path where the multiline widget is inactivate.
InputTextCalcTextLenAndLineCount :: proc(text : string) -> i32
{
	line_count : i32 = 0
	for c in text {
		if c == '\n' { line_count += 1 }
	}
	return line_count
}

// FIXME: Ideally we'd share code with ImFont::CalcTextSizeA()
InputTextCalcTextSize :: proc(ctx : ^ImGuiContext, text_begin : [^]u8, text_end : ^u8, remaining : ^[^]u8 = nil, out_offset : ^ImVec2 = nil, stop_on_new_line : bool = false) -> ImVec2
{
	g : ^ImGuiContext = ctx
	font : ^ImFont = g.Font
	line_height : f32 = g.FontSize
	scale : f32 = line_height / font.FontSize

	text_size : ImVec2 = ImVec2{0, 0}
	line_width : f32 = 0.0

	s := text_begin
	for s < text_end {
		c : u32 = cast(u32) s[0]
		if c < 0x80 { s = s[1:] }
		else { s = s[ImTextCharFromUtf8(&c, s, text_end):] }

		if c == '\n' {
			text_size.x = ImMax(text_size.x, line_width)
			text_size.y += line_height
			line_width = 0.0
			if stop_on_new_line { break }
			continue
		}
		if c == '\r' { continue }

		char_width : f32 = (cast(i32) c < font.IndexAdvanceX.Size ? font.IndexAdvanceX.Data[c] : font.FallbackAdvanceX) * scale
		line_width += char_width
	}

	if text_size.x < line_width { text_size.x = line_width }

	if out_offset != nil {
		// offset allow for the possibility of sitting after a trailing \n
		out_offset^ = ImVec2{line_width, text_size.y + line_height}
	}

	if line_width > 0 || text_size.y == 0.0 {
		// whereas size.y will ignore the trailing \n
		text_size.y += line_height
	}

	if remaining != nil { remaining^ = s }

	return text_size
}

// Wrapper for stb_textedit.h to edit text (our wrapper is for: statically sized buffer, single-line, wchar characters. InputText converts between UTF-8 and wchar)
// With our UTF-8 use of stb_textedit:
// - STB_TEXTEDIT_GETCHAR is nothing more than a a "GETBYTE". It's only used to compare to ascii or to copy blocks of text so we are fine.
// - One exception is the STB_TEXTEDIT_IS_SPACE feature which would expect a full char in order to handle full-width space such as 0x3000 (see ImCharIsBlankW).
// - ...but we don't use that feature.
ImStb_STB_TEXTEDIT_STRINGLEN :: proc(obj : ^ImGuiInputTextState) -> i32 { return obj.TextLen }
ImStb_STB_TEXTEDIT_GETCHAR :: proc(obj : ^ImGuiInputTextState, idx : i32) -> u8
{
	IM_ASSERT(idx <= obj.TextLen); return obj.TextSrc[idx]
}
ImStb_STB_TEXTEDIT_GETWIDTH :: proc(obj : ^ImGuiInputTextState, line_start_idx : i32, char_idx : i32) -> f32
{
	c : u32; ImTextCharFromUtf8(&c, obj.TextSrc[line_start_idx + char_idx:], obj.TextSrc[obj.TextLen:]); if cast(ImWchar) c == '\n' { return IMSTB_TEXTEDIT_GETWIDTH_NEWLINE }; g : ^ImGuiContext = obj.Ctx; return GetCharAdvance(g.Font, cast(ImWchar) c) * g.FontScale
}
STB_TEXTEDIT_NEWLINE : u8 = '\n'
ImStb_STB_TEXTEDIT_LAYOUTROW :: proc(r : ^ImStb_StbTexteditRow, obj : ^ImGuiInputTextState, line_start_idx : i32)
{
	text := obj.TextSrc
	text_remaining : [^]u8 = nil
	size : ImVec2 = InputTextCalcTextSize(obj.Ctx, text[line_start_idx:], &text[obj.TextLen], &text_remaining, nil, true)
	r.x0 = 0.0
	r.x1 = size.x
	r.baseline_y_delta = size.y
	r.ymin = 0.0
	r.ymax = size.y
	r.num_chars = cast(i32) mem.ptr_sub(text_remaining, text[line_start_idx:]) 
}

IMSTB_TEXTEDIT_GETNEXTCHARINDEX :: ImStb_IMSTB_TEXTEDIT_GETNEXTCHARINDEX_IMPL
IMSTB_TEXTEDIT_GETPREVCHARINDEX :: ImStb_IMSTB_TEXTEDIT_GETPREVCHARINDEX_IMPL

ImStb_IMSTB_TEXTEDIT_GETNEXTCHARINDEX_IMPL :: proc(obj : ^ImGuiInputTextState, idx : i32) -> i32
{
	if idx >= obj.TextLen { return obj.TextLen + 1 }
	c : u32
	return idx + ImTextCharFromUtf8(&c, obj.TextSrc[idx:], &obj.TextSrc[obj.TextLen])
}

ImStb_IMSTB_TEXTEDIT_GETPREVCHARINDEX_IMPL :: proc(obj : ^ImGuiInputTextState, idx : i32) -> i32
{
	if idx <= 0 { return -1 }
	p := ImTextFindPreviousUtf8Codepoint(obj.TextSrc, obj.TextSrc[idx:])
	return cast(i32) mem.ptr_sub(p, obj.TextSrc)
}

ImStb_ImCharIsSeparatorW :: proc(c : u32) -> bool
{
	separator_list := [?]u32 {
		',', 0x3001, '.', 0x3002, ';', 0xFF1B, '(', 0xFF08, ')', 0xFF09, '{', 0xFF5B, '}', 0xFF5D,
		'[', 0x300C, ']', 0x300D, '|', 0xFF5C, '!', 0xFF01, '\\', 0xFFE5, '/', 0x30FB, 0xFF0F,
		'\n', '\r',
	}
	for separator in separator_list { if c == separator { return true } }

	return false
}

ImStb_is_word_boundary_from_right :: proc(obj : ^ImGuiInputTextState, idx : i32) -> bool
{
	// When ImGuiInputTextFlags_Password is set, we don't want actions such as CTRL+Arrow to leak the fact that underlying data are blanks or separators.
	if (obj.Flags & ImGuiInputTextFlags_.ImGuiInputTextFlags_Password) != {} || idx <= 0 { return false }

	curr_p := obj.TextSrc[idx:]
	prev_p := ImTextFindPreviousUtf8Codepoint(obj.TextSrc, curr_p)
	curr_c : u32; ImTextCharFromUtf8(&curr_c, curr_p, obj.TextSrc[obj.TextLen:])
	prev_c : u32; ImTextCharFromUtf8(&prev_c, prev_p, obj.TextSrc[obj.TextLen:])

	prev_white : bool = ImCharIsBlankW(prev_c)
	prev_separ : bool = ImStb_ImCharIsSeparatorW(prev_c)
	curr_white : bool = ImCharIsBlankW(curr_c)
	curr_separ : bool = ImStb_ImCharIsSeparatorW(curr_c)
	return ((prev_white || prev_separ) && !(curr_separ || curr_white)) || (curr_separ && !prev_separ)
}
ImStb_is_word_boundary_from_left :: proc(obj : ^ImGuiInputTextState, idx : i32) -> bool
{
	if (obj.Flags & ImGuiInputTextFlags_.ImGuiInputTextFlags_Password) != {} || idx <= 0 { return false }

	curr_p := obj.TextSrc[idx:]
	prev_p := ImTextFindPreviousUtf8Codepoint(obj.TextSrc, curr_p)
	prev_c : u32; ImTextCharFromUtf8(&prev_c, curr_p, obj.TextSrc[obj.TextLen:])
	curr_c : u32; ImTextCharFromUtf8(&curr_c, prev_p, obj.TextSrc[obj.TextLen:])

	prev_white : bool = ImCharIsBlankW(prev_c)
	prev_separ : bool = ImStb_ImCharIsSeparatorW(prev_c)
	curr_white : bool = ImCharIsBlankW(curr_c)
	curr_separ : bool = ImStb_ImCharIsSeparatorW(curr_c)
	return ((prev_white) && !(curr_separ || curr_white)) || (curr_separ && !prev_separ)
}
ImStb_STB_TEXTEDIT_MOVEWORDLEFT_IMPL :: proc(obj : ^ImGuiInputTextState, idx : i32) -> i32
{
	idx := idx
	idx = IMSTB_TEXTEDIT_GETPREVCHARINDEX(obj, idx)
	for idx >= 0 && ImStb_is_word_boundary_from_right(obj, idx) == false { idx = IMSTB_TEXTEDIT_GETPREVCHARINDEX(obj, idx) }

	return idx < 0 ? 0 : idx
}
ImStb_STB_TEXTEDIT_MOVEWORDRIGHT_MAC :: proc(obj : ^ImGuiInputTextState, idx : i32) -> i32
{
	idx := idx
	len : i32 = obj.TextLen
	idx = IMSTB_TEXTEDIT_GETNEXTCHARINDEX(obj, idx)
	for idx < len && ImStb_is_word_boundary_from_left(obj, idx) == false { idx = IMSTB_TEXTEDIT_GETNEXTCHARINDEX(obj, idx) }

	return idx > len ? len : idx
}
ImStb_STB_TEXTEDIT_MOVEWORDRIGHT_WIN :: proc(obj : ^ImGuiInputTextState, idx : i32) -> i32
{
	idx := idx
	idx = IMSTB_TEXTEDIT_GETNEXTCHARINDEX(obj, idx)
	len : i32 = obj.TextLen
	for idx < len && ImStb_is_word_boundary_from_right(obj, idx) == false { idx = IMSTB_TEXTEDIT_GETNEXTCHARINDEX(obj, idx) }

	return idx > len ? len : idx
}
ImStb_STB_TEXTEDIT_MOVEWORDRIGHT_IMPL :: proc(obj : ^ImGuiInputTextState, idx : i32) -> i32
{
	g : ^ImGuiContext = obj.Ctx; if g.IO.ConfigMacOSXBehaviors { return ImStb_STB_TEXTEDIT_MOVEWORDRIGHT_MAC(obj, idx) }
	else { return ImStb_STB_TEXTEDIT_MOVEWORDRIGHT_WIN(obj, idx) }
}
STB_TEXTEDIT_MOVEWORDLEFT :: ImStb_STB_TEXTEDIT_MOVEWORDLEFT_IMPL// They need to be #define for stb_textedit.h
STB_TEXTEDIT_MOVEWORDRIGHT :: ImStb_STB_TEXTEDIT_MOVEWORDRIGHT_IMPL

ImStb_STB_TEXTEDIT_DELETECHARS :: proc(obj : ^ImGuiInputTextState, pos : i32, n : i32)
{
	// Offset remaining text (+ copy zero terminator)
	IM_ASSERT(obj.TextSrc == obj.TextA.Data)
	dst := obj.TextA.Data[pos:]
	src := obj.TextA.Data[pos + n:]
	memmove(dst, src, cast(int)(obj.TextLen - n - pos + 1))
	obj.Edited = true
	obj.TextLen -= n
}

ImStb_STB_TEXTEDIT_INSERTCHARS :: proc(obj : ^ImGuiInputTextState, pos : i32, new_text : []u8) -> bool
{
	is_resizable : bool = (obj.Flags & ImGuiInputTextFlags_.ImGuiInputTextFlags_CallbackResize) != {}
	text_len : i32 = obj.TextLen
	IM_ASSERT(pos <= text_len)

	new_text_len := cast(i32)len(new_text)

	if !is_resizable && (new_text_len + obj.TextLen + 1 > obj.BufCapacity) { return false }

	// Grow internal buffer if needed
	IM_ASSERT(obj.TextSrc == obj.TextA.Data)
	if new_text_len + text_len + 1 > obj.TextA.Size {
		if !is_resizable { return false }
		resize(&obj.TextA, text_len + ImClamp(new_text_len, i32(32), ImMax(i32(256), new_text_len)) + 1)
		obj.TextSrc = obj.TextA.Data
	}

	text := obj.TextA.Data
	if pos != text_len { memmove(text[pos + new_text_len:], &text[pos], cast(int) (text_len - pos)) }
	memcpy(text[pos:], raw_data(new_text), cast(int) new_text_len)

	obj.Edited = true
	obj.TextLen += new_text_len
	obj.TextA.Data[obj.TextLen] = 0

	return true
}

// We don't use an enum so we can build even with conflicting symbols (if another user of stb_textedit.h leak their STB_TEXTEDIT_K_* symbols)
STB_TEXTEDIT_K_LEFT :: 0x200000// keyboard input to move cursor left
STB_TEXTEDIT_K_RIGHT :: 0x200001// keyboard input to move cursor right
STB_TEXTEDIT_K_UP :: 0x200002// keyboard input to move cursor up
STB_TEXTEDIT_K_DOWN :: 0x200003// keyboard input to move cursor down
STB_TEXTEDIT_K_LINESTART :: 0x200004// keyboard input to move cursor to start of line
STB_TEXTEDIT_K_LINEEND :: 0x200005// keyboard input to move cursor to end of line
STB_TEXTEDIT_K_TEXTSTART :: 0x200006// keyboard input to move cursor to start of text
STB_TEXTEDIT_K_TEXTEND :: 0x200007// keyboard input to move cursor to end of text
STB_TEXTEDIT_K_DELETE :: 0x200008// keyboard input to delete selection or character under cursor
STB_TEXTEDIT_K_BACKSPACE :: 0x200009// keyboard input to delete selection or character left of cursor
STB_TEXTEDIT_K_UNDO :: 0x20000A// keyboard input to perform undo
STB_TEXTEDIT_K_REDO :: 0x20000B// keyboard input to perform redo
STB_TEXTEDIT_K_WORDLEFT :: 0x20000C// keyboard input to move cursor left one word
STB_TEXTEDIT_K_WORDRIGHT :: 0x20000D// keyboard input to move cursor right one word
STB_TEXTEDIT_K_PGUP :: 0x20000E// keyboard input to move cursor up a page
STB_TEXTEDIT_K_PGDOWN :: 0x20000F// keyboard input to move cursor down a page
STB_TEXTEDIT_K_SHIFT :: 0x400000

IMSTB_TEXTEDIT_IMPLEMENTATION :: true
IMSTB_TEXTEDIT_memmove :: mem.copy
// [DEAR IMGUI]
// This is a slightly modified version of stb_textedit.h 1.14.
// Those changes would need to be pushed into nothings/stb:
// - Fix in stb_textedit_discard_redo (see https://github.com/nothings/stb/issues/321)
// - Fix in stb_textedit_find_charpos to handle last line (see https://github.com/ocornut/imgui/issues/6000 + #6783)
// - Added name to struct or it may be forward declared in our code.
// - Added UTF-8 support (see https://github.com/nothings/stb/issues/188 + https://github.com/ocornut/imgui/pull/7925)
// Grep for [DEAR IMGUI] to find the changes.
// - Also renamed macros used or defined outside of IMSTB_TEXTEDIT_IMPLEMENTATION block from STB_TEXTEDIT_* to IMSTB_TEXTEDIT_*

// stb_textedit.h - v1.14  - public domain - Sean Barrett
// Development of this library was sponsored by RAD Game Tools
//
// This C header file implements the guts of a multi-line text-editing
// widget; you implement display, word-wrapping, and low-level string
// insertion/deletion, and stb_textedit will map user inputs into
// insertions & deletions, plus updates to the cursor position,
// selection state, and undo state.
//
// It is intended for use in games and other systems that need to build
// their own custom widgets and which do not have heavy text-editing
// requirements (this library is not recommended for use for editing large
// texts, as its performance does not scale and it has limited undo).
//
// Non-trivial behaviors are modelled after Windows text controls.
//
//
// LICENSE
//
// See end of file for license information.
//
//
// DEPENDENCIES
//
// Uses the C runtime function 'memmove', which you can override
// by defining IMSTB_TEXTEDIT_memmove before the implementation.
// Uses no other functions. Performs no runtime allocations.
//
//
// VERSION HISTORY
//
//   1.14 (2021-07-11) page up/down, various fixes
//   1.13 (2019-02-07) fix bug in undo size management
//   1.12 (2018-01-29) user can change STB_TEXTEDIT_KEYTYPE, fix redo to avoid crash
//   1.11 (2017-03-03) fix HOME on last line, dragging off single-line textfield
//   1.10 (2016-10-25) suppress warnings about casting away const with -Wcast-qual
//   1.9  (2016-08-27) customizable move-by-word
//   1.8  (2016-04-02) better keyboard handling when mouse button is down
//   1.7  (2015-09-13) change y range handling in case baseline is non-0
//   1.6  (2015-04-15) allow STB_TEXTEDIT_memmove
//   1.5  (2014-09-10) add support for secondary keys for OS X
//   1.4  (2014-08-17) fix signed/unsigned warnings
//   1.3  (2014-06-19) fix mouse clicking to round to nearest char boundary
//   1.2  (2014-05-27) fix some RAD types that had crept into the new code
//   1.1  (2013-12-15) move-by-word (requires STB_TEXTEDIT_IS_SPACE )
//   1.0  (2012-07-26) improve documentation, initial public release
//   0.3  (2012-02-24) bugfixes, single-line mode; insert mode
//   0.2  (2011-11-28) fixes to undo/redo
//   0.1  (2010-07-08) initial version
//
// ADDITIONAL CONTRIBUTORS
//
//   Ulf Winklemann: move-by-word in 1.1
//   Fabian Giesen: secondary key inputs in 1.5
//   Martins Mozeiko: STB_TEXTEDIT_memmove in 1.6
//   Louis Schnellbach: page up/down in 1.14
//
//   Bugfixes:
//      Scott Graham
//      Daniel Keller
//      Omar Cornut
//      Dan Thompson
//
// USAGE
//
// This file behaves differently depending on what symbols you define
// before including it.
//
//
// Header-file mode:
//
//   If you do not define STB_TEXTEDIT_IMPLEMENTATION before including this,
//   it will operate in "header file" mode. In this mode, it declares a
//   single public symbol, STB_TexteditState, which encapsulates the current
//   state of a text widget (except for the string, which you will store
//   separately).
//
//   To compile in this mode, you must define STB_TEXTEDIT_CHARTYPE to a
//   primitive type that defines a single character (e.g. char, wchar_t, etc).
//
//   To save space or increase undo-ability, you can optionally define the
//   following things that are used by the undo system:
//
//      STB_TEXTEDIT_POSITIONTYPE         small int type encoding a valid cursor position
//      STB_TEXTEDIT_UNDOSTATECOUNT       the number of undo states to allow
//      STB_TEXTEDIT_UNDOCHARCOUNT        the number of characters to store in the undo buffer
//
//   If you don't define these, they are set to permissive types and
//   moderate sizes. The undo system does no memory allocations, so
//   it grows STB_TexteditState by the worst-case storage which is (in bytes):
//
//        [4 + 3 * sizeof(STB_TEXTEDIT_POSITIONTYPE)] * STB_TEXTEDIT_UNDOSTATECOUNT
//      +          sizeof(STB_TEXTEDIT_CHARTYPE)      * STB_TEXTEDIT_UNDOCHARCOUNT
//
//
// Implementation mode:
//
//   If you define STB_TEXTEDIT_IMPLEMENTATION before including this, it
//   will compile the implementation of the text edit widget, depending
//   on a large number of symbols which must be defined before the include.
//
//   The implementation is defined only as static functions. You will then
//   need to provide your own APIs in the same file which will access the
//   static functions.
//
//   The basic concept is that you provide a "string" object which
//   behaves like an array of characters. stb_textedit uses indices to
//   refer to positions in the string, implicitly representing positions
//   in the displayed textedit. This is true for both plain text and
//   rich text; even with rich text stb_truetype interacts with your
//   code as if there was an array of all the displayed characters.
//
// Symbols that must be the same in header-file and implementation mode:
//
//     STB_TEXTEDIT_CHARTYPE             the character type
//     STB_TEXTEDIT_POSITIONTYPE         small type that is a valid cursor position
//     STB_TEXTEDIT_UNDOSTATECOUNT       the number of undo states to allow
//     STB_TEXTEDIT_UNDOCHARCOUNT        the number of characters to store in the undo buffer
//
// Symbols you must define for implementation mode:
//
//    STB_TEXTEDIT_STRING               the type of object representing a string being edited,
//                                      typically this is a wrapper object with other data you need
//
//    STB_TEXTEDIT_STRINGLEN(obj)       the length of the string (ideally O(1))
//    STB_TEXTEDIT_LAYOUTROW(&r,obj,n)  returns the results of laying out a line of characters
//                                        starting from character #n (see discussion below)
//    STB_TEXTEDIT_GETWIDTH(obj,n,i)    returns the pixel delta from the xpos of the i'th character
//                                        to the xpos of the i+1'th char for a line of characters
//                                        starting at character #n (i.e. accounts for kerning
//                                        with previous char)
//    STB_TEXTEDIT_KEYTOTEXT(k)         maps a keyboard input to an insertable character
//                                        (return type is int, -1 means not valid to insert)
//    STB_TEXTEDIT_GETCHAR(obj,i)       returns the i'th character of obj, 0-based
//    STB_TEXTEDIT_NEWLINE              the character returned by _GETCHAR() we recognize
//                                        as manually wordwrapping for end-of-line positioning
//
//    STB_TEXTEDIT_DELETECHARS(obj,i,n)      delete n characters starting at i
//    STB_TEXTEDIT_INSERTCHARS(obj,i,c*,n)   insert n characters at i (pointed to by STB_TEXTEDIT_CHARTYPE*)
//
//    STB_TEXTEDIT_K_SHIFT       a power of two that is or'd in to a keyboard input to represent the shift key
//
//    STB_TEXTEDIT_K_LEFT        keyboard input to move cursor left
//    STB_TEXTEDIT_K_RIGHT       keyboard input to move cursor right
//    STB_TEXTEDIT_K_UP          keyboard input to move cursor up
//    STB_TEXTEDIT_K_DOWN        keyboard input to move cursor down
//    STB_TEXTEDIT_K_PGUP        keyboard input to move cursor up a page
//    STB_TEXTEDIT_K_PGDOWN      keyboard input to move cursor down a page
//    STB_TEXTEDIT_K_LINESTART   keyboard input to move cursor to start of line  // e.g. HOME
//    STB_TEXTEDIT_K_LINEEND     keyboard input to move cursor to end of line    // e.g. END
//    STB_TEXTEDIT_K_TEXTSTART   keyboard input to move cursor to start of text  // e.g. ctrl-HOME
//    STB_TEXTEDIT_K_TEXTEND     keyboard input to move cursor to end of text    // e.g. ctrl-END
//    STB_TEXTEDIT_K_DELETE      keyboard input to delete selection or character under cursor
//    STB_TEXTEDIT_K_BACKSPACE   keyboard input to delete selection or character left of cursor
//    STB_TEXTEDIT_K_UNDO        keyboard input to perform undo
//    STB_TEXTEDIT_K_REDO        keyboard input to perform redo
//
// Optional:
//    STB_TEXTEDIT_K_INSERT              keyboard input to toggle insert mode
//    STB_TEXTEDIT_IS_SPACE(ch)          true if character is whitespace (e.g. 'isspace'),
//                                          required for default WORDLEFT/WORDRIGHT handlers
//    STB_TEXTEDIT_MOVEWORDLEFT(obj,i)   custom handler for WORDLEFT, returns index to move cursor to
//    STB_TEXTEDIT_MOVEWORDRIGHT(obj,i)  custom handler for WORDRIGHT, returns index to move cursor to
//    STB_TEXTEDIT_K_WORDLEFT            keyboard input to move cursor left one word // e.g. ctrl-LEFT
//    STB_TEXTEDIT_K_WORDRIGHT           keyboard input to move cursor right one word // e.g. ctrl-RIGHT
//    STB_TEXTEDIT_K_LINESTART2          secondary keyboard input to move cursor to start of line
//    STB_TEXTEDIT_K_LINEEND2            secondary keyboard input to move cursor to end of line
//    STB_TEXTEDIT_K_TEXTSTART2          secondary keyboard input to move cursor to start of text
//    STB_TEXTEDIT_K_TEXTEND2            secondary keyboard input to move cursor to end of text
//
// Keyboard input must be encoded as a single integer value; e.g. a character code
// and some bitflags that represent shift states. to simplify the interface, SHIFT must
// be a bitflag, so we can test the shifted state of cursor movements to allow selection,
// i.e. (STB_TEXTEDIT_K_RIGHT|STB_TEXTEDIT_K_SHIFT) should be shifted right-arrow.
//
// You can encode other things, such as CONTROL or ALT, in additional bits, and
// then test for their presence in e.g. STB_TEXTEDIT_K_WORDLEFT. For example,
// my Windows implementations add an additional CONTROL bit, and an additional KEYDOWN
// bit. Then all of the STB_TEXTEDIT_K_ values bitwise-or in the KEYDOWN bit,
// and I pass both WM_KEYDOWN and WM_CHAR events to the "key" function in the
// API below. The control keys will only match WM_KEYDOWN events because of the
// keydown bit I add, and STB_TEXTEDIT_KEYTOTEXT only tests for the KEYDOWN
// bit so it only decodes WM_CHAR events.
//
// STB_TEXTEDIT_LAYOUTROW returns information about the shape of one displayed
// row of characters assuming they start on the i'th character--the width and
// the height and the number of characters consumed. This allows this library
// to traverse the entire layout incrementally. You need to compute word-wrapping
// here.
//
// Each textfield keeps its own insert mode state, which is not how normal
// applications work. To keep an app-wide insert mode, update/copy the
// "insert_mode" field of STB_TexteditState before/after calling API functions.
//
// API
//
//    void stb_textedit_initialize_state(STB_TexteditState *state, int is_single_line)
//
//    void stb_textedit_click(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, float x, float y)
//    void stb_textedit_drag(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, float x, float y)
//    int  stb_textedit_cut(STB_TEXTEDIT_STRING *str, STB_TexteditState *state)
//    int  stb_textedit_paste(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, STB_TEXTEDIT_CHARTYPE *text, int len)
//    void stb_textedit_key(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, STB_TEXEDIT_KEYTYPE key)
//    void stb_textedit_text(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, STB_TEXTEDIT_CHARTYPE *text, int text_len)
//
//    Each of these functions potentially updates the string and updates the
//    state.
//
//      initialize_state:
//          set the textedit state to a known good default state when initially
//          constructing the textedit.
//
//      click:
//          call this with the mouse x,y on a mouse down; it will update the cursor
//          and reset the selection start/end to the cursor point. the x,y must
//          be relative to the text widget, with (0,0) being the top left.
//
//      drag:
//          call this with the mouse x,y on a mouse drag/up; it will update the
//          cursor and the selection end point
//
//      cut:
//          call this to delete the current selection; returns true if there was
//          one. you should FIRST copy the current selection to the system paste buffer.
//          (To copy, just copy the current selection out of the string yourself.)
//
//      paste:
//          call this to paste text at the current cursor point or over the current
//          selection if there is one.
//
//      key:
//          call this for keyboard inputs sent to the textfield. you can use it
//          for "key down" events or for "translated" key events. if you need to
//          do both (as in Win32), or distinguish Unicode characters from control
//          inputs, set a high bit to distinguish the two; then you can define the
//          various definitions like STB_TEXTEDIT_K_LEFT have the is-key-event bit
//          set, and make STB_TEXTEDIT_KEYTOCHAR check that the is-key-event bit is
//          clear. STB_TEXTEDIT_KEYTYPE defaults to int, but you can #define it to
//          anything other type you want before including.
//          if the STB_TEXTEDIT_KEYTOTEXT function is defined, selected keys are
//          transformed into text and stb_textedit_text() is automatically called.
//
//      text: [DEAR IMGUI] added 2024-09
//          call this to text inputs sent to the textfield.
//
//
//   When rendering, you can read the cursor position and selection state from
//   the STB_TexteditState.
//
//
// Notes:
//
// This is designed to be usable in IMGUI, so it allows for the possibility of
// running in an IMGUI that has NOT cached the multi-line layout. For this
// reason, it provides an interface that is compatible with computing the
// layout incrementally--we try to make sure we make as few passes through
// as possible. (For example, to locate the mouse pointer in the text, we
// could define functions that return the X and Y positions of characters
// and binary search Y and then X, but if we're doing dynamic layout this
// will run the layout algorithm many times, so instead we manually search
// forward in one pass. Similar logic applies to e.g. up-arrow and
// down-arrow movement.)
//
// If it's run in a widget that *has* cached the layout, then this is less
// efficient, but it's not horrible on modern computers. But you wouldn't
// want to edit million-line files with it.


////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////
////   Header-file mode
////
////

////////////////////////////////////////////////////////////////////////
//
//     STB_TexteditState
//
// Definition of STB_TexteditState which you should store
// per-textfield; it includes cursor position, selection state,
// and undo state.
//

ImStb_StbUndoRecord :: struct {
	// private data
	where_ : IMSTB_TEXTEDIT_POSITIONTYPE,
	insert_length : IMSTB_TEXTEDIT_POSITIONTYPE,
	delete_length : IMSTB_TEXTEDIT_POSITIONTYPE,
	char_storage : i32,
}

ImStb_StbUndoState :: struct {
	// private data
	undo_rec : [IMSTB_TEXTEDIT_UNDOSTATECOUNT]ImStb_StbUndoRecord,
	undo_char : [IMSTB_TEXTEDIT_UNDOCHARCOUNT]IMSTB_TEXTEDIT_CHARTYPE,
	undo_point : i16, redo_point : i16,
	undo_char_point : i32, redo_char_point : i32,
}

ImStb_STB_TexteditState :: struct {
	/////////////////////
	//
	// public data
	//

	cursor : i32,
	// position of the text cursor within the string

	select_start : i32, // selection start point
	select_end : i32,
	// selection start and end point in characters; if equal, no selection.
	// note that start may be less than or greater than end (e.g. when
	// dragging the mouse, start is where the initial click was, and you
	// can drag in either direction)

	insert_mode : bool,
	// each textfield keeps its own insert mode state. to keep an app-wide
	// insert mode, copy this value in/out of the app state

	row_count_per_page : i32,
	// page size in number of row.
	// this value MUST be set to >0 for pageup or pagedown in multilines documents.

	/////////////////////
	//
	// private data
	//
	cursor_at_end_of_line : u8, // not implemented yet
	initialized : u8,
	has_preferred_x : u8,
	single_line : bool,
	padding1 : u8, padding2 : u8, padding3 : u8,
	preferred_x : f32, // this determines where the cursor up/down tries to seek to along x
	undostate : ImStb_StbUndoState,
}


////////////////////////////////////////////////////////////////////////
//
//     StbTexteditRow
//
// Result of layout query, used by stb_textedit to determine where
// the text in each row is.

// result of layout query
ImStb_StbTexteditRow :: struct {
	x0 : f32, x1 : f32, // starting x location, end x location (allows for align=right, etc)
	baseline_y_delta : f32, // position of baseline relative to previous row's baseline
	ymin : f32, ymax : f32, // height of row above and below baseline
	num_chars : i32,
}


////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////
////   Implementation mode
////
////

// traverse the layout to locate the nearest character to a display position
/////////////////////////////////////////////////////////////////////////////
//
//      Mouse input handling
//

// traverse the layout to locate the nearest character to a display position
ImStb_stb_text_locate_coord :: proc(str : ^IMSTB_TEXTEDIT_STRING, x : f32, y : f32) -> i32
{
	r : ImStb_StbTexteditRow
	n : i32 = ImStb_STB_TEXTEDIT_STRINGLEN(str)
	base_y : f32 = 0; prev_x : f32
	i : i32 = 0; k : i32

	r.x1 = 0; r.x0 = r.x1
	r.ymax = 0; r.ymin = r.ymax
	r.num_chars = 0

	// search rows to find one that straddles 'y'
	for i < n {
		ImStb_STB_TEXTEDIT_LAYOUTROW(&r, str, i)
		if r.num_chars <= 0 { return n }

		if i == 0 && y < base_y + r.ymin { return 0 }

		if y < base_y + r.ymax { break }

		i += r.num_chars
		base_y += r.baseline_y_delta
	}

	// below all text, return 'after' last character
	if i >= n { return n }

	// check if it's before the beginning of the line
	if x < r.x0 { return i }

	// check if it's before the end of the line
	if x < r.x1 {
		// search characters in row for one that straddles 'x'
		prev_x = r.x0
		for k = 0; k < r.num_chars; k = IMSTB_TEXTEDIT_GETNEXTCHARINDEX(str, i + k) - i {
			w : f32 = ImStb_STB_TEXTEDIT_GETWIDTH(str, i, k)
			if x < prev_x + w {
				if x < prev_x + w / 2 { return k + i }
				else { return IMSTB_TEXTEDIT_GETNEXTCHARINDEX(str, i + k) }
			}
			prev_x += w
		}

		// shouldn't happen, but if it does, fall through to end-of-line case
	}

	// if the last character is a newline, return that. otherwise return 'after' the last character
	if ImStb_STB_TEXTEDIT_GETCHAR(str, i + r.num_chars - 1) == STB_TEXTEDIT_NEWLINE { return i + r.num_chars - 1 }
	else { return i + r.num_chars }
}

// API click: on mouse down, move the cursor to the clicked location, and reset the selection
// API click: on mouse down, move the cursor to the clicked location, and reset the selection
ImStb_stb_textedit_click :: proc(str : ^IMSTB_TEXTEDIT_STRING, state : ^ImStb_STB_TexteditState, x : f32, y : f32)
{
	y := y
	// In single-line mode, just always make y = 0. This lets the drag keep working if the mouse
	// goes off the top or bottom of the text
	if state.single_line != false {
		r : ImStb_StbTexteditRow
		ImStb_STB_TEXTEDIT_LAYOUTROW(&r, str, 0)
		y = r.ymin
	}

	state.cursor = ImStb_stb_text_locate_coord(str, x, y)
	state.select_start = state.cursor
	state.select_end = state.cursor
	state.has_preferred_x = 0
}

// API drag: on mouse drag, move the cursor and selection endpoint to the clicked location
// API drag: on mouse drag, move the cursor and selection endpoint to the clicked location
ImStb_stb_textedit_drag :: proc(str : ^IMSTB_TEXTEDIT_STRING, state : ^ImStb_STB_TexteditState, x : f32, y : f32)
{
	p : i32 = 0
	y := y

	// In single-line mode, just always make y = 0. This lets the drag keep working if the mouse
	// goes off the top or bottom of the text
	if state.single_line != false {
		r : ImStb_StbTexteditRow
		ImStb_STB_TEXTEDIT_LAYOUTROW(&r, str, 0)
		y = r.ymin
	}

	if state.select_start == state.select_end { state.select_start = state.cursor }

	p = ImStb_stb_text_locate_coord(str, x, y)
	state.select_end = p; state.cursor = state.select_end
}

ImStb_StbFindState :: struct {
	x : f32, y : f32, // position of n'th character
	height : f32, // height of line
	first_char : i32, length : i32, // first char of row, and length
	prev_first : i32, // first char of previous row
}

// find the x/y location of a character, and remember info about the previous row in
// case we get a move-up event (for page up, we'll have to rescan)
// find the x/y location of a character, and remember info about the previous row in
// case we get a move-up event (for page up, we'll have to rescan)
ImStb_stb_textedit_find_charpos :: proc(find : ^ImStb_StbFindState, str : ^IMSTB_TEXTEDIT_STRING, n : i32, single_line : bool)
{
	r : ImStb_StbTexteditRow
	prev_start : i32 = 0
	z : i32 = ImStb_STB_TEXTEDIT_STRINGLEN(str)
	i : i32 = 0; first : i32

	if n == z && single_line {
		// special case if it's at the end (may not be needed?)
		ImStb_STB_TEXTEDIT_LAYOUTROW(&r, str, 0)
		find.y = 0
		find.first_char = 0
		find.length = z
		find.height = r.ymax - r.ymin
		find.x = r.x1
		return
	}

	// search rows to find the one that straddles character n
	find.y = 0

	for {
		ImStb_STB_TEXTEDIT_LAYOUTROW(&r, str, i)
		if n < i + r.num_chars { break }
		if i + r.num_chars == z && z > 0 && ImStb_STB_TEXTEDIT_GETCHAR(str, z - 1) != STB_TEXTEDIT_NEWLINE {
			// [DEAR IMGUI] special handling for last line
			// [DEAR IMGUI]
			break
		}
		prev_start = i
		i += r.num_chars
		find.y += r.baseline_y_delta
		if i == z {
			// [DEAR IMGUI]
			r.num_chars = 0; // [DEAR IMGUI]
			break; // [DEAR IMGUI]
		}
	}

	first = i; find.first_char = first
	find.length = r.num_chars
	find.height = r.ymax - r.ymin
	find.prev_first = prev_start

	// now scan to find xpos
	find.x = r.x0
	for i = 0; first + i < n; i = IMSTB_TEXTEDIT_GETNEXTCHARINDEX(str, first + i) - first { find.x += ImStb_STB_TEXTEDIT_GETWIDTH(str, first, i) }
}

STB_TEXT_HAS_SELECTION :: #force_inline proc "contextless" (s : $T0) -> bool
{
	return s.select_start != s.select_end
}


// make the selection/cursor state valid if client altered the string
// make the selection/cursor state valid if client altered the string
ImStb_stb_textedit_clamp :: proc(str : ^IMSTB_TEXTEDIT_STRING, state : ^ImStb_STB_TexteditState)
{
	n : i32 = ImStb_STB_TEXTEDIT_STRINGLEN(str)
	if STB_TEXT_HAS_SELECTION(state) {
		if state.select_start > n { state.select_start = n }
		if state.select_end > n { state.select_end = n }
		// if clamping forced them to be equal, move the cursor to match
		if state.select_start == state.select_end { state.cursor = state.select_start }
	}
	if state.cursor > n { state.cursor = n }
}

// delete characters while updating undo
// delete characters while updating undo
ImStb_stb_textedit_delete :: proc(str : ^IMSTB_TEXTEDIT_STRING, state : ^ImStb_STB_TexteditState, where_ : i32, len : i32)
{
	ImStb_stb_text_makeundo_delete(str, state, where_, len)
	ImStb_STB_TEXTEDIT_DELETECHARS(str, where_, len)
	state.has_preferred_x = 0
}

// delete the section
// delete the section
ImStb_stb_textedit_delete_selection :: proc(str : ^IMSTB_TEXTEDIT_STRING, state : ^ImStb_STB_TexteditState)
{
	ImStb_stb_textedit_clamp(str, state)
	if STB_TEXT_HAS_SELECTION(state) {
		if state.select_start < state.select_end {
			ImStb_stb_textedit_delete(str, state, state.select_start, state.select_end - state.select_start)
			state.cursor = state.select_start; state.select_end = state.cursor
		}
		else {
			ImStb_stb_textedit_delete(str, state, state.select_end, state.select_start - state.select_end)
			state.cursor = state.select_end; state.select_start = state.cursor
		}
		state.has_preferred_x = 0
	}
}

// canoncialize the selection so start <= end
// canoncialize the selection so start <= end
ImStb_stb_textedit_sortselection :: proc(state : ^ImStb_STB_TexteditState)
{
	if state.select_end < state.select_start {
		temp : i32 = state.select_end
		state.select_end = state.select_start
		state.select_start = temp
	}
}

// move cursor to first character of selection
// move cursor to first character of selection
ImStb_stb_textedit_move_to_first :: proc(state : ^ImStb_STB_TexteditState)
{
	if STB_TEXT_HAS_SELECTION(state) {
		ImStb_stb_textedit_sortselection(state)
		state.cursor = state.select_start
		state.select_end = state.select_start
		state.has_preferred_x = 0
	}
}

// move cursor to last character of selection
// move cursor to last character of selection
ImStb_stb_textedit_move_to_last :: proc(str : ^IMSTB_TEXTEDIT_STRING, state : ^ImStb_STB_TexteditState)
{
	if STB_TEXT_HAS_SELECTION(state) {
		ImStb_stb_textedit_sortselection(state)
		ImStb_stb_textedit_clamp(str, state)
		state.cursor = state.select_end
		state.select_start = state.select_end
		state.has_preferred_x = 0
	}
}

// [DEAR IMGUI]
// Functions must be implemented for UTF8 support
// Code in this file that uses those functions is modified for [DEAR IMGUI] and deviates from the original stb_textedit.
// There is not necessarily a '[DEAR IMGUI]' at the usage sites.

when false {

ImStb_is_word_boundary :: proc(str : ^IMSTB_TEXTEDIT_STRING, idx : i32) -> i32
{
	return idx > 0 ? (STB_TEXTEDIT_IS_SPACE(ImStb_STB_TEXTEDIT_GETCHAR(str, idx - 1)) && !STB_TEXTEDIT_IS_SPACE(ImStb_STB_TEXTEDIT_GETCHAR(str, idx))) : 1
}

}

// update selection and cursor to match each other
ImStb_stb_textedit_prep_selection_at_cursor :: proc(state : ^ImStb_STB_TexteditState)
{
	if !STB_TEXT_HAS_SELECTION(state) { state.select_end = state.cursor; state.select_start = state.select_end }
	else { state.cursor = state.select_end }
}

// API cut: delete selection
ImStb_stb_textedit_cut :: proc(str : ^IMSTB_TEXTEDIT_STRING, state : ^ImStb_STB_TexteditState) -> i32
{
	if STB_TEXT_HAS_SELECTION(state) {
		ImStb_stb_textedit_delete_selection(str, state); // implicitly clamps
		state.has_preferred_x = 0
		return 1
	}
	return 0
}

// API paste: replace existing selection with passed-in text
ImStb_stb_textedit_paste_internal :: proc(str : ^IMSTB_TEXTEDIT_STRING, state : ^ImStb_STB_TexteditState, text : []IMSTB_TEXTEDIT_CHARTYPE) -> i32
{
	// if there's a selection, the paste should delete it
	ImStb_stb_textedit_clamp(str, state)
	ImStb_stb_textedit_delete_selection(str, state)
	// try to insert the characters
	if ImStb_STB_TEXTEDIT_INSERTCHARS(str, state.cursor, text) {
		ImStb_stb_text_makeundo_insert(state, state.cursor, cast(i32)len(text))
		state.cursor += cast(i32)len(text)
		state.has_preferred_x = 0
		return 1
	}
	// note: paste failure will leave deleted selection, may be restored with an undo (see https://github.com/nothings/stb/issues/734 for details)
	return 0
}

STB_TEXTEDIT_KEYTYPE :: i32

// [DEAR IMGUI] Added stb_textedit_text(), extracted out and called by stb_textedit_key() for backward compatibility.
// [DEAR IMGUI] Added stb_textedit_text(), extracted out and called by stb_textedit_key() for backward compatibility.
ImStb_stb_textedit_text :: proc(str : ^IMSTB_TEXTEDIT_STRING, state : ^ImStb_STB_TexteditState, text : []IMSTB_TEXTEDIT_CHARTYPE)
{
	// can't add newline in single-line mode
	if text[0] == '\n' && state.single_line { return }

	if state.insert_mode && !STB_TEXT_HAS_SELECTION(state) && state.cursor < ImStb_STB_TEXTEDIT_STRINGLEN(str) {
		ImStb_stb_text_makeundo_replace(str, state, state.cursor, 1, 1)
		ImStb_STB_TEXTEDIT_DELETECHARS(str, state.cursor, 1)
		if ImStb_STB_TEXTEDIT_INSERTCHARS(str, state.cursor, text) {
			state.cursor += cast(i32)len(text)
			state.has_preferred_x = 0
		}
	}
	else {
		ImStb_stb_textedit_delete_selection(str, state); // implicitly clamps
		if ImStb_STB_TEXTEDIT_INSERTCHARS(str, state.cursor, text) {
			ImStb_stb_text_makeundo_insert(state, state.cursor, cast(i32)len(text))
			state.cursor += cast(i32)len(text)
			state.has_preferred_x = 0
		}
	}
}

// API key: process a keyboard input
// API key: process a keyboard input
ImStb_stb_textedit_key :: proc(str : ^IMSTB_TEXTEDIT_STRING, state : ^ImStb_STB_TexteditState, key : STB_TEXTEDIT_KEYTYPE)
{
	retry: for {

		switch key {
			case:{
				// when STB_TEXTEDIT_KEYTOTEXT { /* @gen ifdef */
				// c : i32 = STB_TEXTEDIT_KEYTOTEXT(key)
				// if c > 0 {
				// 	ch : IMSTB_TEXTEDIT_CHARTYPE = cast(IMSTB_TEXTEDIT_CHARTYPE) c
				// 	ImStb_stb_textedit_text(str, state, &ch, 1)
				// }
				// } // preproc endif
				break
				}

			// 	when STB_TEXTEDIT_K_INSERT { /* @gen ifdef */
			// 	fallthrough
			// case STB_TEXTEDIT_K_INSERT:
			// 	state.insert_mode = state.insert_mode == 0
			// 	break
			// 	} // preproc endif


			case STB_TEXTEDIT_K_UNDO:
				ImStb_stb_text_undo(str, state)
				state.has_preferred_x = 0
				break


			case STB_TEXTEDIT_K_REDO:
				ImStb_stb_text_redo(str, state)
				state.has_preferred_x = 0
				break


			case STB_TEXTEDIT_K_LEFT:
				// if currently there's a selection, move cursor to start of selection
				if STB_TEXT_HAS_SELECTION(state) { ImStb_stb_textedit_move_to_first(state) }
				else if state.cursor > 0 { state.cursor = IMSTB_TEXTEDIT_GETPREVCHARINDEX(str, state.cursor) }
				state.has_preferred_x = 0
				break


			case STB_TEXTEDIT_K_RIGHT:
				// if currently there's a selection, move cursor to end of selection
				if STB_TEXT_HAS_SELECTION(state) { ImStb_stb_textedit_move_to_last(str, state) }
				else { state.cursor = IMSTB_TEXTEDIT_GETNEXTCHARINDEX(str, state.cursor) }
				ImStb_stb_textedit_clamp(str, state)
				state.has_preferred_x = 0
				break


			case STB_TEXTEDIT_K_LEFT | STB_TEXTEDIT_K_SHIFT:
				ImStb_stb_textedit_clamp(str, state)
				ImStb_stb_textedit_prep_selection_at_cursor(state)
				// move selection left
				if state.select_end > 0 { state.select_end = IMSTB_TEXTEDIT_GETPREVCHARINDEX(str, state.select_end) }
				state.cursor = state.select_end
				state.has_preferred_x = 0
				break

				
			case STB_TEXTEDIT_K_WORDLEFT:
			//when STB_TEXTEDIT_MOVEWORDLEFT { /* @gen ifdef */
				if STB_TEXT_HAS_SELECTION(state) { ImStb_stb_textedit_move_to_first(state) }
				else {
					state.cursor = STB_TEXTEDIT_MOVEWORDLEFT(str, state.cursor)
					ImStb_stb_textedit_clamp(str, state)
				}
				break
			//}


			case STB_TEXTEDIT_K_WORDLEFT | STB_TEXTEDIT_K_SHIFT:
				//when STB_TEXTEDIT_MOVEWORDLEFT { /* @gen ifdef */
				if !STB_TEXT_HAS_SELECTION(state) { ImStb_stb_textedit_prep_selection_at_cursor(state) }

				state.cursor = STB_TEXTEDIT_MOVEWORDLEFT(str, state.cursor)
				state.select_end = state.cursor

				ImStb_stb_textedit_clamp(str, state)
				break
				//} // preproc endif

				// when STB_TEXTEDIT_MOVEWORDRIGHT { /* @gen ifdef */

			case STB_TEXTEDIT_K_WORDRIGHT:
				if STB_TEXT_HAS_SELECTION(state) { ImStb_stb_textedit_move_to_last(str, state) }
				else {
					state.cursor = STB_TEXTEDIT_MOVEWORDRIGHT(str, state.cursor)
					ImStb_stb_textedit_clamp(str, state)
				}
				break


			case STB_TEXTEDIT_K_WORDRIGHT | STB_TEXTEDIT_K_SHIFT:
				if !STB_TEXT_HAS_SELECTION(state) { ImStb_stb_textedit_prep_selection_at_cursor(state) }

				state.cursor = STB_TEXTEDIT_MOVEWORDRIGHT(str, state.cursor)
				state.select_end = state.cursor

				ImStb_stb_textedit_clamp(str, state)
				break
				// } // preproc endif


			case STB_TEXTEDIT_K_RIGHT | STB_TEXTEDIT_K_SHIFT:
				ImStb_stb_textedit_prep_selection_at_cursor(state)
				// move selection right
				state.select_end = IMSTB_TEXTEDIT_GETNEXTCHARINDEX(str, state.select_end)
				ImStb_stb_textedit_clamp(str, state)
				state.cursor = state.select_end
				state.has_preferred_x = 0
				break


			case STB_TEXTEDIT_K_DOWN:
				fallthrough
			case STB_TEXTEDIT_K_DOWN | STB_TEXTEDIT_K_SHIFT:
				fallthrough
			case STB_TEXTEDIT_K_PGDOWN:
				fallthrough
			case STB_TEXTEDIT_K_PGDOWN | STB_TEXTEDIT_K_SHIFT:{
				find : ImStb_StbFindState
				row : ImStb_StbTexteditRow
				i : i32; j : i32; sel : bool = (key & STB_TEXTEDIT_K_SHIFT) != {}
				is_page : bool = (key & ~cast(i32)STB_TEXTEDIT_K_SHIFT) == STB_TEXTEDIT_K_PGDOWN
				row_count : i32 = is_page != false ? state.row_count_per_page : 1

				key := key
				if is_page == false && state.single_line {
					// on windows, up&down in single-line behave like left&right
					key = STB_TEXTEDIT_K_RIGHT | (key & STB_TEXTEDIT_K_SHIFT)
					continue retry /* @gen goto: validate direction */
				}

				if sel != false { ImStb_stb_textedit_prep_selection_at_cursor(state) }
				else if STB_TEXT_HAS_SELECTION(state) { ImStb_stb_textedit_move_to_last(str, state) }

				// compute current position of cursor point
				ImStb_stb_textedit_clamp(str, state)
				ImStb_stb_textedit_find_charpos(&find, str, state.cursor, state.single_line)

				for j = 0; j < row_count; j += 1 {
					x : f32; goal_x : f32 = state.has_preferred_x != 0 ? state.preferred_x : find.x
					start : i32 = find.first_char + find.length

					if find.length == 0 { break }

					// [DEAR IMGUI]
					// going down while being on the last line shouldn't bring us to that line end
					if ImStb_STB_TEXTEDIT_GETCHAR(str, find.first_char + find.length - 1) != STB_TEXTEDIT_NEWLINE { break }

					// now find character position down a row
					state.cursor = start
					ImStb_STB_TEXTEDIT_LAYOUTROW(&row, str, state.cursor)
					x = row.x0
					for i = 0; i < row.num_chars; i += 1 {
						dx : f32 = ImStb_STB_TEXTEDIT_GETWIDTH(str, start, i)
						//when IMSTB_TEXTEDIT_GETWIDTH_NEWLINE { /* @gen ifdef */
						if dx == IMSTB_TEXTEDIT_GETWIDTH_NEWLINE { break }
						//} // preproc endif
						x += dx
						if x > goal_x { break }
						state.cursor = IMSTB_TEXTEDIT_GETNEXTCHARINDEX(str, state.cursor)
					}

					ImStb_stb_textedit_clamp(str, state)

					state.has_preferred_x = 1
					state.preferred_x = goal_x

					if sel != false { state.select_end = state.cursor }

					// go to next line
					find.first_char = find.first_char + find.length
					find.length = row.num_chars
				}

				break
				}

				fallthrough
			case STB_TEXTEDIT_K_UP:
				fallthrough
			case STB_TEXTEDIT_K_UP | STB_TEXTEDIT_K_SHIFT:
				fallthrough
			case STB_TEXTEDIT_K_PGUP:
				fallthrough
			case STB_TEXTEDIT_K_PGUP | STB_TEXTEDIT_K_SHIFT:{
				find : ImStb_StbFindState
				row : ImStb_StbTexteditRow
				i : i32; j : i32; prev_scan : i32; sel : bool = (key & STB_TEXTEDIT_K_SHIFT) != {}
				is_page : bool = (key & ~cast(i32)STB_TEXTEDIT_K_SHIFT) == STB_TEXTEDIT_K_PGUP
				row_count : i32 = is_page != false ? state.row_count_per_page : 1

				key := key
				if is_page == false && state.single_line {
					// on windows, up&down become left&right
					key = STB_TEXTEDIT_K_LEFT | (key & STB_TEXTEDIT_K_SHIFT)
					continue retry /* @gen goto: validate direction */
				}

				if sel != false { ImStb_stb_textedit_prep_selection_at_cursor(state) }
				else if STB_TEXT_HAS_SELECTION(state) { ImStb_stb_textedit_move_to_first(state) }

				// compute current position of cursor point
				ImStb_stb_textedit_clamp(str, state)
				ImStb_stb_textedit_find_charpos(&find, str, state.cursor, state.single_line)

				for j = 0; j < row_count; j += 1 {
					x : f32; goal_x : f32 = state.has_preferred_x != 0 ? state.preferred_x : find.x

					// can only go up if there's a previous row
					if find.prev_first == find.first_char { break }

					// now find character position up a row
					state.cursor = find.prev_first
					ImStb_STB_TEXTEDIT_LAYOUTROW(&row, str, state.cursor)
					x = row.x0
					for i = 0; i < row.num_chars; i += 1 {
						dx : f32 = ImStb_STB_TEXTEDIT_GETWIDTH(str, find.prev_first, i)
						//when IMSTB_TEXTEDIT_GETWIDTH_NEWLINE { /* @gen ifdef */
						if dx == IMSTB_TEXTEDIT_GETWIDTH_NEWLINE { break }
						//} // preproc endif
						x += dx
						if x > goal_x { break }
						state.cursor = IMSTB_TEXTEDIT_GETNEXTCHARINDEX(str, state.cursor)
					}

					ImStb_stb_textedit_clamp(str, state)

					state.has_preferred_x = 1
					state.preferred_x = goal_x

					if sel != false { state.select_end = state.cursor }

					// go to previous line
					// (we need to scan previous line the hard way. maybe we could expose this as a new API function?)
					prev_scan = find.prev_first > 0 ? find.prev_first - 1 : 0
					for prev_scan > 0 && ImStb_STB_TEXTEDIT_GETCHAR(str, prev_scan - 1) != STB_TEXTEDIT_NEWLINE { pre_decr(&prev_scan) }

					find.first_char = find.prev_first
					find.prev_first = prev_scan
				}

				break
				}

				fallthrough
			case STB_TEXTEDIT_K_DELETE:
				fallthrough
			case STB_TEXTEDIT_K_DELETE | STB_TEXTEDIT_K_SHIFT:
				if STB_TEXT_HAS_SELECTION(state) { ImStb_stb_textedit_delete_selection(str, state) }
				else {
					n : i32 = ImStb_STB_TEXTEDIT_STRINGLEN(str)
					if state.cursor < n { ImStb_stb_textedit_delete(str, state, state.cursor, IMSTB_TEXTEDIT_GETNEXTCHARINDEX(str, state.cursor) - state.cursor) }
				}
				state.has_preferred_x = 0
				break


			case STB_TEXTEDIT_K_BACKSPACE:
				fallthrough
			case STB_TEXTEDIT_K_BACKSPACE | STB_TEXTEDIT_K_SHIFT:
				if STB_TEXT_HAS_SELECTION(state) { ImStb_stb_textedit_delete_selection(str, state) }
				else {
					ImStb_stb_textedit_clamp(str, state)
					if state.cursor > 0 {
						prev : i32 = IMSTB_TEXTEDIT_GETPREVCHARINDEX(str, state.cursor)
						ImStb_stb_textedit_delete(str, state, prev, state.cursor - prev)
						state.cursor = prev
					}
				}
				state.has_preferred_x = 0
				break

			// 	when STB_TEXTEDIT_K_TEXTSTART2 { /* @gen ifdef */

			// case STB_TEXTEDIT_K_TEXTSTART2:
			// 	} // preproc endif
			// 	fallthrough
			case STB_TEXTEDIT_K_TEXTSTART:
				state.select_end = 0; state.select_start = state.select_end; state.cursor = state.select_start
				state.has_preferred_x = 0
				break

			// 	when STB_TEXTEDIT_K_TEXTEND2 { /* @gen ifdef */

			// case STB_TEXTEDIT_K_TEXTEND2:
			// 	} // preproc endif
			// 	fallthrough
			case STB_TEXTEDIT_K_TEXTEND:
				state.cursor = ImStb_STB_TEXTEDIT_STRINGLEN(str)
				state.select_end = 0; state.select_start = state.select_end
				state.has_preferred_x = 0
				break

			// 	when STB_TEXTEDIT_K_TEXTSTART2 { /* @gen ifdef */

			// case STB_TEXTEDIT_K_TEXTSTART2 | STB_TEXTEDIT_K_SHIFT:
			// 	} // preproc endif
			// 	fallthrough
			case STB_TEXTEDIT_K_TEXTSTART | STB_TEXTEDIT_K_SHIFT:
				ImStb_stb_textedit_prep_selection_at_cursor(state)
				state.select_end = 0; state.cursor = state.select_end
				state.has_preferred_x = 0
				break

			// 	when STB_TEXTEDIT_K_TEXTEND2 { /* @gen ifdef */

			// case STB_TEXTEDIT_K_TEXTEND2 | STB_TEXTEDIT_K_SHIFT:
			// 	} // preproc endif
			// 	fallthrough
			case STB_TEXTEDIT_K_TEXTEND | STB_TEXTEDIT_K_SHIFT:
				ImStb_stb_textedit_prep_selection_at_cursor(state)
				state.select_end = ImStb_STB_TEXTEDIT_STRINGLEN(str); state.cursor = state.select_end
				state.has_preferred_x = 0
				break


			// 	when STB_TEXTEDIT_K_LINESTART2 { /* @gen ifdef */

			// case STB_TEXTEDIT_K_LINESTART2:
			// 	} // preproc endif
			// 	fallthrough
			case STB_TEXTEDIT_K_LINESTART:
				ImStb_stb_textedit_clamp(str, state)
				ImStb_stb_textedit_move_to_first(state)
				if state.single_line != false { state.cursor = 0 }
				else { for state.cursor > 0 && ImStb_STB_TEXTEDIT_GETCHAR(str, state.cursor - 1) != STB_TEXTEDIT_NEWLINE { pre_decr(&state.cursor) } }
				state.has_preferred_x = 0
				break

			// 	when STB_TEXTEDIT_K_LINEEND2 { /* @gen ifdef */

			// case STB_TEXTEDIT_K_LINEEND2:
			// 	} // preproc endif
			// 	fallthrough
			case STB_TEXTEDIT_K_LINEEND:{
				n : i32 = ImStb_STB_TEXTEDIT_STRINGLEN(str)
				ImStb_stb_textedit_clamp(str, state)
				ImStb_stb_textedit_move_to_first(state)
				if state.single_line != false { state.cursor = n }
				else { for state.cursor < n && ImStb_STB_TEXTEDIT_GETCHAR(str, state.cursor) != STB_TEXTEDIT_NEWLINE { pre_incr(&state.cursor) } }
				state.has_preferred_x = 0
				break
				}

			// 	when STB_TEXTEDIT_K_LINESTART2 { /* @gen ifdef */
			// 	fallthrough
			// case STB_TEXTEDIT_K_LINESTART2 | STB_TEXTEDIT_K_SHIFT:
			// 	} // preproc endif
				fallthrough
			case STB_TEXTEDIT_K_LINESTART | STB_TEXTEDIT_K_SHIFT:
				ImStb_stb_textedit_clamp(str, state)
				ImStb_stb_textedit_prep_selection_at_cursor(state)
				if state.single_line != false { state.cursor = 0 }
				else { for state.cursor > 0 && ImStb_STB_TEXTEDIT_GETCHAR(str, state.cursor - 1) != STB_TEXTEDIT_NEWLINE { pre_decr(&state.cursor) } }
				state.select_end = state.cursor
				state.has_preferred_x = 0
				break

			// 	when STB_TEXTEDIT_K_LINEEND2 { /* @gen ifdef */

			// case STB_TEXTEDIT_K_LINEEND2 | STB_TEXTEDIT_K_SHIFT:
			// 	} // preproc endif
			// 	fallthrough
			case STB_TEXTEDIT_K_LINEEND | STB_TEXTEDIT_K_SHIFT:{
				n : i32 = ImStb_STB_TEXTEDIT_STRINGLEN(str)
				ImStb_stb_textedit_clamp(str, state)
				ImStb_stb_textedit_prep_selection_at_cursor(state)
				if state.single_line != false { state.cursor = n }
				else { for state.cursor < n && ImStb_STB_TEXTEDIT_GETCHAR(str, state.cursor) != STB_TEXTEDIT_NEWLINE { pre_incr(&state.cursor) } }
				state.select_end = state.cursor
				state.has_preferred_x = 0
				break
				}
		}

		break
	}
}

/////////////////////////////////////////////////////////////////////////////
//
//      Undo processing
//
// @OPTIMIZE: the undo/redo buffer should be circular

/////////////////////////////////////////////////////////////////////////////
//
//      Undo processing
//
// @OPTIMIZE: the undo/redo buffer should be circular

ImStb_stb_textedit_flush_redo :: proc(state : ^ImStb_StbUndoState)
{
	state.redo_point = IMSTB_TEXTEDIT_UNDOSTATECOUNT
	state.redo_char_point = IMSTB_TEXTEDIT_UNDOCHARCOUNT
}

// discard the oldest entry in the undo list
// discard the oldest entry in the undo list
ImStb_stb_textedit_discard_undo :: proc(state : ^ImStb_StbUndoState)
{
	if state.undo_point > 0 {
		// if the 0th undo state has characters, clean those up
		if state.undo_rec[0].char_storage >= 0 {
			n : i32 = state.undo_rec[0].insert_length; i : i16
			// delete n characters from all other records
			state.undo_char_point -= n
			IMSTB_TEXTEDIT_memmove(raw_data(&state.undo_char), raw_data(&state.undo_char)[n:], cast(int) (state.undo_char_point * size_of(IMSTB_TEXTEDIT_CHARTYPE)))
			for i = 0; i < state.undo_point; i += 1 {
				if state.undo_rec[i].char_storage >= 0 {
				// @OPTIMIZE: get rid of char_storage and infer it
				state.undo_rec[i].char_storage -= n
				}
			}
		}
		pre_decr(&state.undo_point)
		IMSTB_TEXTEDIT_memmove(raw_data(&state.undo_rec), raw_data(&state.undo_rec)[1:], cast(int) (state.undo_point * size_of(state.undo_rec[0])))
	}
}

// discard the oldest entry in the redo list--it's bad if this
// ever happens, but because undo & redo have to store the actual
// characters in different cases, the redo character buffer can
// fill up even though the undo buffer didn't
// discard the oldest entry in the redo list--it's bad if this
// ever happens, but because undo & redo have to store the actual
// characters in different cases, the redo character buffer can
// fill up even though the undo buffer didn't
ImStb_stb_textedit_discard_redo :: proc(state : ^ImStb_StbUndoState)
{
	k : i16 = IMSTB_TEXTEDIT_UNDOSTATECOUNT - 1

	if state.redo_point <= k {
		// if the k'th undo state has characters, clean those up
		if state.undo_rec[k].char_storage >= 0 {
			n : i32 = state.undo_rec[k].insert_length; i : i16
			// move the remaining redo character data to the end of the buffer
			state.redo_char_point += n
			IMSTB_TEXTEDIT_memmove(raw_data(&state.undo_char)[state.redo_char_point:], raw_data(&state.undo_char)[state.redo_char_point - n:], cast(int) ((IMSTB_TEXTEDIT_UNDOCHARCOUNT - state.redo_char_point) * size_of(IMSTB_TEXTEDIT_CHARTYPE)))
			// adjust the position of all the other records to account for above memmove
			for i = state.redo_point; i < k; i += 1 { if state.undo_rec[i].char_storage >= 0 { state.undo_rec[i].char_storage += n } }
		}
		// now move all the redo records towards the end of the buffer; the first one is at 'redo_point'
		// [DEAR IMGUI]
		move_size := cast(int) ((IMSTB_TEXTEDIT_UNDOSTATECOUNT - state.redo_point - 1) * size_of(state.undo_rec[0]))
		buf_begin : ^u8 = cast(^u8) raw_data(&state.undo_rec); _ = buf_begin
		buf_end : ^u8 = cast(^u8) raw_data(&state.undo_rec)[size_of(state.undo_rec):]; _ = buf_end
		IM_ASSERT((cast([^]u8) (raw_data(&state.undo_rec)[state.redo_point:])) >= buf_begin)
		IM_ASSERT((cast([^]u8) (raw_data(&state.undo_rec)[state.redo_point + 1:])[move_size:]) <= buf_end)
		IMSTB_TEXTEDIT_memmove(raw_data(&state.undo_rec)[state.redo_point + 1:], raw_data(&state.undo_rec)[state.redo_point:], move_size)

		// now move redo_point to point to the new one
		pre_incr(&state.redo_point)
	}
}

ImStb_stb_text_create_undo_record :: proc(state : ^ImStb_StbUndoState, numchars : i32) -> ^ImStb_StbUndoRecord
{
	// any time we create a new undo record, we discard redo
	ImStb_stb_textedit_flush_redo(state)

	// if we have no free records, we have to make room, by sliding the
	// existing records down
	if state.undo_point == IMSTB_TEXTEDIT_UNDOSTATECOUNT { ImStb_stb_textedit_discard_undo(state) }

	// if the characters to store won't possibly fit in the buffer, we can't undo
	if numchars > IMSTB_TEXTEDIT_UNDOCHARCOUNT {
		state.undo_point = 0
		state.undo_char_point = 0
		return nil
	}

	// if we don't have enough free characters in the buffer, we have to make room
	for state.undo_char_point + numchars > IMSTB_TEXTEDIT_UNDOCHARCOUNT { ImStb_stb_textedit_discard_undo(state) }

	return &state.undo_rec[post_incr(&state.undo_point)]
}

ImStb_stb_text_createundo :: proc(state : ^ImStb_StbUndoState, pos : i32, insert_len : i32, delete_len : i32) -> [^]IMSTB_TEXTEDIT_CHARTYPE
{
	r : ^ImStb_StbUndoRecord = ImStb_stb_text_create_undo_record(state, insert_len)
	if r == nil { return nil }

	r.where_ = pos
	r.insert_length = cast(IMSTB_TEXTEDIT_POSITIONTYPE) insert_len
	r.delete_length = cast(IMSTB_TEXTEDIT_POSITIONTYPE) delete_len

	if insert_len == 0 {
		r.char_storage = -1
		return nil
	}
	else {
		r.char_storage = state.undo_char_point
		state.undo_char_point += insert_len
		return raw_data(&state.undo_char)[r.char_storage:]
	}
}

/////////////////////////////////////////////////////////////////////////////
//
//      Keyboard input handling
//

// forward declarations
/////////////////////////////////////////////////////////////////////////////
//
//      Keyboard input handling
//

// forward declarations
ImStb_stb_text_undo :: proc(str : ^IMSTB_TEXTEDIT_STRING, state : ^ImStb_STB_TexteditState)
{
	s : ^ImStb_StbUndoState = &state.undostate
	u : ImStb_StbUndoRecord; r : ^ImStb_StbUndoRecord
	if s.undo_point == 0 { return }

	// we need to do two things: apply the undo record, and create a redo record
	u = s.undo_rec[s.undo_point - 1]
	r = &s.undo_rec[s.redo_point - 1]
	r.char_storage = -1

	r.insert_length = u.delete_length
	r.delete_length = u.insert_length
	r.where_ = u.where_

	if u.delete_length != {} {
		// if the undo record says to delete characters, then the redo record will
		// need to re-insert the characters that get deleted, so we need to store
		// them.

		// there are three cases:
		//    there's enough room to store the characters
		//    characters stored for *redoing* don't leave room for redo
		//    characters stored for *undoing* don't leave room for redo
		// if the last is true, we have to bail

		if s.undo_char_point + u.delete_length >= IMSTB_TEXTEDIT_UNDOCHARCOUNT {
			// the undo records take up too much character space; there's no space to store the redo characters
			r.insert_length = 0
		}
		else {
			i : i32

			// there's definitely room to store the characters eventually
			for s.undo_char_point + u.delete_length > s.redo_char_point {
				// should never happen:
				if s.redo_point == IMSTB_TEXTEDIT_UNDOSTATECOUNT { return }
				// there's currently not enough room, so discard a redo record
				ImStb_stb_textedit_discard_redo(s)
			}

			r = &s.undo_rec[s.redo_point - 1]

			r.char_storage = s.redo_char_point - u.delete_length
			s.redo_char_point = s.redo_char_point - u.delete_length

			// now save the characters
			for i = 0; i < u.delete_length; i += 1 { s.undo_char[r.char_storage + i] = ImStb_STB_TEXTEDIT_GETCHAR(str, u.where_ + i) }
		}

		// now we can carry out the deletion
		ImStb_STB_TEXTEDIT_DELETECHARS(str, u.where_, u.delete_length)
	}

	// check type of recorded action:
	if u.insert_length != {} {
		// easy case: was a deletion, so we need to insert n characters
		ImStb_STB_TEXTEDIT_INSERTCHARS(str, u.where_, raw_data(&s.undo_char)[u.char_storage:][:u.insert_length])
		s.undo_char_point -= u.insert_length
	}

	state.cursor = u.where_ + u.insert_length

	post_decr(&s.undo_point)
	post_decr(&s.redo_point)
}

ImStb_stb_text_redo :: proc(str : ^IMSTB_TEXTEDIT_STRING, state : ^ImStb_STB_TexteditState)
{
	s : ^ImStb_StbUndoState = &state.undostate
	u : ^ImStb_StbUndoRecord; r : ImStb_StbUndoRecord
	if s.redo_point == IMSTB_TEXTEDIT_UNDOSTATECOUNT { return }

	// we need to do two things: apply the redo record, and create an undo record
	u = &s.undo_rec[s.undo_point]
	r = s.undo_rec[s.redo_point]

	// we KNOW there must be room for the undo record, because the redo record
	// was derived from an undo record

	u.delete_length = r.insert_length
	u.insert_length = r.delete_length
	u.where_ = r.where_
	u.char_storage = -1

	if r.delete_length != {} {
		// the redo record requires us to delete characters, so the undo record
		// needs to store the characters

		if s.undo_char_point + u.insert_length > s.redo_char_point {
			u.insert_length = 0
			u.delete_length = 0
		}
		else {
			i : i32
			u.char_storage = s.undo_char_point
			s.undo_char_point = s.undo_char_point + u.insert_length

			// now save the characters
			for i = 0; i < u.insert_length; i += 1 { s.undo_char[u.char_storage + i] = ImStb_STB_TEXTEDIT_GETCHAR(str, u.where_ + i) }
		}

		ImStb_STB_TEXTEDIT_DELETECHARS(str, r.where_, r.delete_length)
	}

	if r.insert_length != {} {
		// easy case: need to insert n characters
		ImStb_STB_TEXTEDIT_INSERTCHARS(str, r.where_, raw_data(&s.undo_char)[r.char_storage:][:r.insert_length])
		s.redo_char_point += r.insert_length
	}

	state.cursor = r.where_ + r.insert_length

	post_incr(&s.undo_point)
	post_incr(&s.redo_point)
}

ImStb_stb_text_makeundo_insert :: proc(state : ^ImStb_STB_TexteditState, where_ : i32, length : i32)
{
	ImStb_stb_text_createundo(&state.undostate, where_, 0, length)
}

ImStb_stb_text_makeundo_delete :: proc(str : ^IMSTB_TEXTEDIT_STRING, state : ^ImStb_STB_TexteditState, where_ : i32, length : i32)
{
	i : i32
	p : [^]IMSTB_TEXTEDIT_CHARTYPE = ImStb_stb_text_createundo(&state.undostate, where_, length, 0)
	if p != nil {
		for i = 0; i < length; i += 1 { p[i] = ImStb_STB_TEXTEDIT_GETCHAR(str, where_ + i) }
	}
}

ImStb_stb_text_makeundo_replace :: proc(str : ^IMSTB_TEXTEDIT_STRING, state : ^ImStb_STB_TexteditState, where_ : i32, old_length : i32, new_length : i32)
{
	i : i32
	p : [^]IMSTB_TEXTEDIT_CHARTYPE = ImStb_stb_text_createundo(&state.undostate, where_, old_length, new_length)
	if p != nil {
		for i = 0; i < old_length; i += 1 { p[i] = ImStb_STB_TEXTEDIT_GETCHAR(str, where_ + i) }
	}
}

// reset the state to default
// reset the state to default
ImStb_stb_textedit_clear_state :: proc(state : ^ImStb_STB_TexteditState, is_single_line : bool)
{
	state.undostate.undo_point = 0
	state.undostate.undo_char_point = 0
	state.undostate.redo_point = IMSTB_TEXTEDIT_UNDOSTATECOUNT
	state.undostate.redo_char_point = IMSTB_TEXTEDIT_UNDOCHARCOUNT
	state.select_start = 0; state.select_end = state.select_start
	state.cursor = 0
	state.has_preferred_x = 0
	state.preferred_x = 0
	state.cursor_at_end_of_line = 0
	state.initialized = 1
	state.single_line = is_single_line
	state.insert_mode = false
	state.row_count_per_page = 0
}

// API initialize
ImStb_stb_textedit_initialize_state :: proc(state : ^ImStb_STB_TexteditState, is_single_line : bool)
{
	ImStb_stb_textedit_clear_state(state, is_single_line)
}

ImStb_stb_textedit_paste :: proc(str : ^IMSTB_TEXTEDIT_STRING, state : ^ImStb_STB_TexteditState, ctext : []IMSTB_TEXTEDIT_CHARTYPE) -> i32
{
	return ImStb_stb_textedit_paste_internal(str, state, ctext)
}

/*
------------------------------------------------------------------------------
This software is available under 2 licenses -- choose whichever you prefer.
------------------------------------------------------------------------------
ALTERNATIVE A - MIT License
Copyright (c) 2017 Sean Barrett
Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
------------------------------------------------------------------------------
ALTERNATIVE B - Public Domain (www.unlicense.org)
This is free and unencumbered software released into the public domain.
Anyone is free to copy, modify, publish, use, compile, sell, or distribute this
software, either in source code form or as a compiled binary, for any purpose,
commercial or non-commercial, and by any means.
In jurisdictions that recognize copyright laws, the author or authors of this
software dedicate any and all copyright interest in the software to the public
domain. We make this dedication for the benefit of the public at large and to
the detriment of our heirs and successors. We intend this dedication to be an
overt act of relinquishment in perpetuity of all present and future rights to
this software under copyright law.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
------------------------------------------------------------------------------
*/
// stb_textedit internally allows for a single undo record to do addition and deletion, but somehow, calling
// the stb_textedit_paste() function creates two separate records, so we perform it manually. (FIXME: Report to nothings/stb?)
ImStb_stb_textedit_replace :: proc(str : ^ImGuiInputTextState, state : ^ImStb_STB_TexteditState, text : []IMSTB_TEXTEDIT_CHARTYPE)
{
	ImStb_stb_text_makeundo_replace(str, state, 0, str.TextLen, cast(i32)len(text))
	ImStb_STB_TEXTEDIT_DELETECHARS(str, 0, str.TextLen)
	state.select_end = 0; state.select_start = state.select_end; state.cursor = state.select_start
	if len(text) <= 0 { return }
	if ImStb_STB_TEXTEDIT_INSERTCHARS(str, 0, text) {
		state.select_end = cast(i32)len(text); state.select_start = state.select_end; state.cursor = state.select_start
		state.has_preferred_x = 0
		return
	}
	IM_ASSERT(false); // Failed to insert character, normally shouldn't happen because of how we currently use stb_textedit_replace()
}

// namespace ImStb

// We added an extra indirection where 'Stb' is heap-allocated, in order facilitate the work of bindings generators.
ImGuiInputTextState_init :: proc(this : ^ImGuiInputTextState)
{
	this^ = {}
	this.Stb = IM_NEW(ImStbTexteditState)
	memset(this.Stb, 0, size_of(this.Stb^))
}

ImGuiInputTextState_deinit :: proc(this : ^ImGuiInputTextState)
{
	IM_DELETE(this.Stb)
	deinit(&this.TextA)
	deinit(&this.TextToRevertTo)
	deinit(&this.CallbackTextBackup)
}

// Cannot be inline because we call in code in stb_textedit.h implementation
ImGuiInputTextState_OnKeyPressed :: proc(this : ^ImGuiInputTextState, key : i32)
{
	ImStb_stb_textedit_key(this, this.Stb, key)
	this.CursorFollow = true
	ImGuiInputTextState_CursorAnimReset(this)
}

ImGuiInputTextState_OnCharPressed :: proc(this : ^ImGuiInputTextState, c : u32)
{
	// Convert the key to a UTF8 byte sequence.
	// The changes we had to make to stb_textedit_key made it very much UTF-8 specific which is not too great.
	utf8 : [5]u8
	ImTextCharToUtf8(&utf8, c)
	ImStb_stb_textedit_text(this, this.Stb, raw_data(&utf8)[:strlen(raw_data(&utf8))])
	this.CursorFollow = true
	ImGuiInputTextState_CursorAnimReset(this)
}

// Cursor & Selection
// Those functions are not inlined in imgui_internal.h, allowing us to hide ImStbTexteditState from that header.
// After a user-input the cursor stays on for a while without blinking
ImGuiInputTextState_CursorAnimReset :: proc(this : ^ImGuiInputTextState) { this.CursorAnim = -0.30 }
ImGuiInputTextState_CursorClamp :: proc(this : ^ImGuiInputTextState)
{
	this.Stb.cursor = ImMin(this.Stb.cursor, this.TextLen); this.Stb.select_start = ImMin(this.Stb.select_start, this.TextLen); this.Stb.select_end = ImMin(this.Stb.select_end, this.TextLen)
}
ImGuiInputTextState_HasSelection :: proc(this : ^ImGuiInputTextState) -> bool { return this.Stb.select_start != this.Stb.select_end }
ImGuiInputTextState_ClearSelection :: proc(this : ^ImGuiInputTextState) { this.Stb.select_end = this.Stb.cursor; this.Stb.select_start = this.Stb.select_end }
ImGuiInputTextState_GetCursorPos :: proc(this : ^ImGuiInputTextState) -> i32 { return this.Stb.cursor }
ImGuiInputTextState_GetSelectionStart :: proc(this : ^ImGuiInputTextState) -> i32 { return this.Stb.select_start }
ImGuiInputTextState_GetSelectionEnd :: proc(this : ^ImGuiInputTextState) -> i32 { return this.Stb.select_end }
ImGuiInputTextState_SelectAll :: proc(this : ^ImGuiInputTextState)
{
	this.Stb.select_start = 0; this.Stb.select_end = this.TextLen; this.Stb.cursor = this.Stb.select_end; this.Stb.has_preferred_x = 0
}
// Reload user buf (WIP #2890)
// If you modify underlying user-passed const char* while active you need to call this (InputText V2 may lift this)
//   strcpy(my_buf, "hello");
//   if (ImGuiInputTextState* state = ImGui::GetInputTextState(id)) // id may be ImGui::GetItemID() is last item
//       state->ReloadUserBufAndSelectAll();
ImGuiInputTextState_ReloadUserBufAndSelectAll :: proc(this : ^ImGuiInputTextState)
{
	this.WantReloadUserBuf = true; this.ReloadSelectionStart = 0; this.ReloadSelectionEnd = INT_MAX
}
ImGuiInputTextState_ReloadUserBufAndKeepSelection :: proc(this : ^ImGuiInputTextState)
{
	this.WantReloadUserBuf = true; this.ReloadSelectionStart = this.Stb.select_start; this.ReloadSelectionEnd = this.Stb.select_end
}
ImGuiInputTextState_ReloadUserBufAndMoveToEnd :: proc(this : ^ImGuiInputTextState)
{
	this.WantReloadUserBuf = true; this.ReloadSelectionEnd = INT_MAX; this.ReloadSelectionStart = this.ReloadSelectionEnd
}

ImGuiInputTextCallbackData_init :: proc(this : ^ImGuiInputTextCallbackData)
{
	this^ = {}
}

// Public API to manipulate UTF-8 text from within a callback.
// FIXME: The existence of this rarely exercised code path is a bit of a nuisance.
// Historically they existed because STB_TEXTEDIT_INSERTCHARS() etc. worked on our ImWchar
// buffer, but nowadays they both work on UTF-8 data. Should aim to merge both.
ImGuiInputTextCallbackData_DeleteChars :: proc(this : ^ImGuiInputTextCallbackData, pos : i32, bytes_count : i32)
{
	IM_ASSERT(pos + bytes_count <= this.BufTextLen)
	dst := this.Buf[pos:]
	src := this.Buf[pos + bytes_count:]
	memmove(dst, src, int(this.BufTextLen - bytes_count - pos + 1))

	if this.CursorPos >= pos + bytes_count { this.CursorPos -= bytes_count }
	else if this.CursorPos >= pos { this.CursorPos = pos }
	this.SelectionEnd = this.CursorPos; this.SelectionStart = this.SelectionEnd
	this.BufDirty = true
	this.BufTextLen -= bytes_count
}

ImGuiInputTextCallbackData_InsertChars :: proc(this : ^ImGuiInputTextCallbackData, pos : i32, new_text : string)
{
	// Accept null ranges
	if new_text == "" { return }

	// Grow internal buffer if needed
	is_resizable : bool = (this.Flags & ImGuiInputTextFlags_.ImGuiInputTextFlags_CallbackResize) != {}
	new_text_len := cast(i32) len(new_text)
	if new_text_len + this.BufTextLen >= this.BufSize {
		if !is_resizable { return }

		g : ^ImGuiContext = this.Ctx
		edit_state : ^ImGuiInputTextState = &g.InputTextState
		IM_ASSERT(edit_state.ID != 0 && g.ActiveId == edit_state.ID)
		IM_ASSERT(this.Buf == edit_state.TextA.Data)
		new_buf_size : i32 = this.BufTextLen + ImClamp(new_text_len * 4, 32, ImMax(i32(256), new_text_len)) + 1
		resize(&edit_state.TextA, new_buf_size + 1)
		edit_state.TextSrc = edit_state.TextA.Data
		this.Buf = edit_state.TextA.Data
		edit_state.BufCapacity = new_buf_size; this.BufSize = edit_state.BufCapacity
	}

	if this.BufTextLen != pos { memmove(this.Buf[pos + new_text_len:], this.Buf[pos:], int(this.BufTextLen - pos)) }
	memcpy(this.Buf[pos:], raw_data(new_text), cast(int) new_text_len * size_of(u8))
	this.Buf[this.BufTextLen + new_text_len] = 0

	if this.CursorPos >= pos { this.CursorPos += new_text_len }
	this.SelectionEnd = this.CursorPos; this.SelectionStart = this.SelectionEnd
	this.BufDirty = true
	this.BufTextLen += new_text_len
}

//-------------------------------------------------------------------------
// [SECTION] Forward Declarations
//-------------------------------------------------------------------------

// For InputTextEx()
// Return false to discard a character.
InputTextFilterCharacter :: proc(ctx : ^ImGuiContext, p_char : ^u32, flags : ImGuiInputTextFlags, callback : ImGuiInputTextCallback, user_data : rawptr, input_source_is_clipboard : bool = false) -> bool
{
	c : u32 = p_char^

	// Filter non-printable (NB: isprint is unreliable! see #2467)
	apply_named_filters : bool = true
	if c < 0x20 {
		pass : bool = false
		pass |= (c == '\n') && (flags & cast(ImGuiInputTextFlags) ImGuiInputTextFlagsPrivate_.ImGuiInputTextFlags_Multiline) != {}; // Note that an Enter KEY will emit \r and be ignored (we poll for KEY in InputText() code)
		pass |= (c == '\t') && (flags & ImGuiInputTextFlags_.ImGuiInputTextFlags_AllowTabInput) != {}
		if !pass { return false }
		apply_named_filters = false; // Override named filters below so newline and tabs can still be inserted.
	}

	if input_source_is_clipboard == false {
		// We ignore Ascii representation of delete (emitted from Backspace on OSX, see #2578, #2817)
		if c == 127 { return false }

		// Filter private Unicode range. GLFW on OSX seems to send private characters for special keys like arrow keys (FIXME)
		if c >= 0xE000 && c <= 0xF8FF { return false }
	}

	// Filter Unicode ranges we are not handling in this build
	if c > IM_UNICODE_CODEPOINT_MAX { return false }

	// Generic named filters
	if apply_named_filters && (flags & (ImGuiInputTextFlags_.ImGuiInputTextFlags_CharsDecimal | ImGuiInputTextFlags_.ImGuiInputTextFlags_CharsHexadecimal | ImGuiInputTextFlags_.ImGuiInputTextFlags_CharsUppercase | ImGuiInputTextFlags_.ImGuiInputTextFlags_CharsNoBlank | ImGuiInputTextFlags_.ImGuiInputTextFlags_CharsScientific | cast(ImGuiInputTextFlags) ImGuiInputTextFlagsPrivate_.ImGuiInputTextFlags_LocalizeDecimalPoint) != {}) {
		// The libc allows overriding locale, with e.g. 'setlocale(LC_NUMERIC, "de_DE.UTF-8");' which affect the output/input of printf/scanf to use e.g. ',' instead of '.'.
		// The standard mandate that programs starts in the "C" locale where the decimal point is '.'.
		// We don't really intend to provide widespread support for it, but out of empathy for people stuck with using odd API, we support the bare minimum aka overriding the decimal point.
		// Change the default decimal_point with:
		//   ImGui::GetPlatformIO()->Platform_LocaleDecimalPoint = *localeconv()->decimal_point;
		// Users of non-default decimal point (in particular ',') may be affected by word-selection logic (is_word_boundary_from_right/is_word_boundary_from_left) functions.
		g : ^ImGuiContext = ctx
		c_decimal_point : u32 = cast(u32) g.PlatformIO.Platform_LocaleDecimalPoint
		if (flags & (ImGuiInputTextFlags_.ImGuiInputTextFlags_CharsDecimal | ImGuiInputTextFlags_.ImGuiInputTextFlags_CharsScientific | cast(ImGuiInputTextFlags) ImGuiInputTextFlagsPrivate_.ImGuiInputTextFlags_LocalizeDecimalPoint)) != {} { if c == '.' || c == ',' { c = c_decimal_point } }

		// Full-width -> half-width conversion for numeric fields (https://en.wikipedia.org/wiki/Halfwidth_and_Fullwidth_Forms_(Unicode_block)
		// While this is mostly convenient, this has the side-effect for uninformed users accidentally inputting full-width characters that they may
		// scratch their head as to why it works in numerical fields vs in generic text fields it would require support in the font.
		if (flags & (ImGuiInputTextFlags_.ImGuiInputTextFlags_CharsDecimal | ImGuiInputTextFlags_.ImGuiInputTextFlags_CharsScientific | ImGuiInputTextFlags_.ImGuiInputTextFlags_CharsHexadecimal)) != {} { if c >= 0xFF01 && c <= 0xFF5E { c = c - 0xFF01 + 0x21 } }

		// Allow 0-9 . - + * /
		if (flags & ImGuiInputTextFlags_.ImGuiInputTextFlags_CharsDecimal) != {} { if !(c >= '0' && c <= '9') && (c != c_decimal_point) && (c != '-') && (c != '+') && (c != '*') && (c != '/') { return false } }

		// Allow 0-9 . - + * / e E
		if (flags & ImGuiInputTextFlags_.ImGuiInputTextFlags_CharsScientific) != {} { if !(c >= '0' && c <= '9') && (c != c_decimal_point) && (c != '-') && (c != '+') && (c != '*') && (c != '/') && (c != 'e') && (c != 'E') { return false } }

		// Allow 0-9 a-F A-F
		if (flags & ImGuiInputTextFlags_.ImGuiInputTextFlags_CharsHexadecimal) != {} { if !(c >= '0' && c <= '9') && !(c >= 'a' && c <= 'f') && !(c >= 'A' && c <= 'F') { return false } }

		// Turn a-z into A-Z
		if (flags & ImGuiInputTextFlags_.ImGuiInputTextFlags_CharsUppercase) != {} { if c >= 'a' && c <= 'z' { c += transmute(u32)cast(i32) ('A' - 'a') } }

		if (flags & ImGuiInputTextFlags_.ImGuiInputTextFlags_CharsNoBlank) != {} { if ImCharIsBlankW(c) { return false } }

		p_char^ = c
	}

	// Custom callback filter
	if (flags & ImGuiInputTextFlags_.ImGuiInputTextFlags_CallbackCharFilter) != {} {
		g : ^ImGuiContext = GImGui
		callback_data : ImGuiInputTextCallbackData
		callback_data.Ctx = g
		callback_data.EventFlag = ImGuiInputTextFlags_.ImGuiInputTextFlags_CallbackCharFilter
		callback_data.EventChar = cast(ImWchar) c
		callback_data.Flags = flags
		callback_data.UserData = user_data
		if callback(&callback_data) != {} { return false }
		p_char^ = cast(u32)callback_data.EventChar
		if callback_data.EventChar == {} { return false }
	}

	return true
}

// Find the shortest single replacement we can make to get from old_buf to new_buf
// Note that this doesn't directly alter state->TextA, state->TextLen. They are expected to be made valid separately.
// FIXME: Ideally we should transition toward (1) making InsertChars()/DeleteChars() update undo-stack (2) discourage (and keep reconcile) or obsolete (and remove reconcile) accessing buffer directly.
InputTextReconcileUndoState :: proc(state : ^ImGuiInputTextState, old_buf : []u8, new_buf : []u8)
{
	shorter_length := cast(i32)ImMin(len(old_buf), len(new_buf))
	first_diff : i32
	for first_diff = 0; first_diff < shorter_length; first_diff += 1 { if old_buf[first_diff] != new_buf[first_diff] { break } }

	if first_diff == cast(i32)len(old_buf) && first_diff == cast(i32)len(new_buf) { return }

	old_last_diff : i32 = cast(i32)len(old_buf) - 1
	new_last_diff : i32 = cast(i32)len(new_buf) - 1
	for ; old_last_diff >= first_diff && new_last_diff >= first_diff; old_last_diff, new_last_diff = old_last_diff - 1, new_last_diff - 1 { if old_buf[old_last_diff] != new_buf[new_last_diff] { break } }

	insert_len : i32 = new_last_diff - first_diff + 1
	delete_len : i32 = old_last_diff - first_diff + 1
	if insert_len > 0 || delete_len > 0 { if p := ImStb_stb_text_createundo(&state.Stb.undostate, first_diff, delete_len, insert_len); p != nil { for i : i32 = 0; i < delete_len; i += 1 { p[i] = old_buf[first_diff + i] } } }
}

// As InputText() retain textual data and we currently provide a path for user to not retain it (via local variables)
// we need some form of hook to reapply data back to user buffer on deactivation frame. (#4714)
// It would be more desirable that we discourage users from taking advantage of the "user not retaining data" trick,
// but that more likely be attractive when we do have _NoLiveEdit flag available.
InputTextDeactivateHook :: proc(id : ImGuiID)
{
	g : ^ImGuiContext = GImGui
	state : ^ImGuiInputTextState = &g.InputTextState
	if id == 0 || state.ID != id { return }
	g.InputTextDeactivatedState.ID = state.ID
	if (state.Flags & ImGuiInputTextFlags_.ImGuiInputTextFlags_ReadOnly) != {} {
		resize(&g.InputTextDeactivatedState.TextA, 0); // In theory this data won't be used, but clear to be neat.
	}
	else {
		IM_ASSERT(state.TextA.Data != nil)
		IM_ASSERT(state.TextA.Data[state.TextLen] == 0)
		resize(&g.InputTextDeactivatedState.TextA, state.TextLen + 1)
		memcpy(g.InputTextDeactivatedState.TextA.Data, state.TextA.Data, cast(int)state.TextLen + 1)
	}
}

// Edit a string of text
// - buf_size account for the zero-terminator, so a buf_size of 6 can hold "Hello" but not "Hello!".
//   This is so we can easily call InputText() on static arrays using ARRAYSIZE() and to match
//   Note that in std::string world, capacity() would omit 1 byte used by the zero-terminator.
// - When active, hold on a privately held copy of the text (and apply back to 'buf'). So changing 'buf' while the InputText is active has no effect.
// - If you want to use ImGui::InputText() with std::string, see misc/cpp/imgui_stdlib.h
// (FIXME: Rather confusing and messy function, among the worse part of our codebase, expecting to rewrite a V2 at some point.. Partly because we are
//  doing UTF8 > U16 > UTF8 conversions on the go to easily interface with stb_textedit. Ideally should stay in UTF-8 all the time. See https://github.com/nothings/stb/issues/188)
InputTextEx :: proc(label : string, hint : string, buf : []u8, size_arg : ImVec2, flags : ImGuiInputTextFlags, callback : ImGuiInputTextCallback = nil, callback_user_data : rawptr = nil) -> bool
{
	window : ^ImGuiWindow = GetCurrentWindow()
	if window.SkipItems { return false }

	IM_ASSERT(!((flags & ImGuiInputTextFlags_.ImGuiInputTextFlags_CallbackHistory) != {} && (flags & cast(ImGuiInputTextFlags) ImGuiInputTextFlagsPrivate_.ImGuiInputTextFlags_Multiline) != {})); // Can't use both together (they both use up/down keys)
	IM_ASSERT(!((flags & ImGuiInputTextFlags_.ImGuiInputTextFlags_CallbackCompletion) != {} && (flags & ImGuiInputTextFlags_.ImGuiInputTextFlags_AllowTabInput) != {})); // Can't use both together (they both use tab key)
	IM_ASSERT(!((flags & ImGuiInputTextFlags_.ImGuiInputTextFlags_ElideLeft) != {} && (flags & cast(ImGuiInputTextFlags) ImGuiInputTextFlagsPrivate_.ImGuiInputTextFlags_Multiline) != {})); // Multiline will not work with left-trimming

	g : ^ImGuiContext = GImGui
	io : ^ImGuiIO = &g.IO
	style : ^ImGuiStyle = &g.Style
	flags := flags

	RENDER_SELECTION_WHEN_INACTIVE : bool = false
	is_multiline : bool = (flags & cast(ImGuiInputTextFlags) ImGuiInputTextFlagsPrivate_.ImGuiInputTextFlags_Multiline) != {}

	if is_multiline {
		// Open group before calling GetID() because groups tracks id created within their scope (including the scrollbar)
		BeginGroup()
	}
	id : ImGuiID = GetID(window, label)
	label_size : ImVec2 = CalcTextSize(label, true)
	frame_size : ImVec2 = CalcItemSize(size_arg, CalcItemWidth(), (is_multiline ? g.FontSize * 8.0 : label_size.y) + style.FramePadding.y * 2.0); // Arbitrary default of 8 lines high for multi-line
	total_size : ImVec2 = ImVec2{frame_size.x + (label_size.x > 0.0 ? style.ItemInnerSpacing.x + label_size.x : 0.0), frame_size.y}

	frame_bb : ImRect; init(&frame_bb, window.DC.CursorPos, window.DC.CursorPos + frame_size)
	total_bb : ImRect; init(&total_bb, frame_bb.Min, frame_bb.Min + total_size)

	draw_window : ^ImGuiWindow = window
	inner_size : ImVec2 = frame_size
	item_data_backup : ImGuiLastItemData
	if is_multiline {
		backup_pos : ImVec2 = window.DC.CursorPos
		ItemSize(total_bb, style.FramePadding.y)
		if !ItemAdd(total_bb, id, &frame_bb, cast(ImGuiItemFlags)ImGuiItemFlagsPrivate_.ImGuiItemFlags_Inputable) {
			EndGroup()
			return false
		}
		item_data_backup = g.LastItemData
		window.DC.CursorPos = backup_pos

		// Prevent NavActivation from Tabbing when our widget accepts Tab inputs: this allows cycling through widgets without stopping.
		if g.NavActivateId == id && (g.NavActivateFlags & ImGuiActivateFlags_.ImGuiActivateFlags_FromTabbing) != {} && (flags & ImGuiInputTextFlags_.ImGuiInputTextFlags_AllowTabInput) != {} { g.NavActivateId = 0 }

		// Prevent NavActivate reactivating in BeginChild() when we are already active.
		backup_activate_id : ImGuiID = g.NavActivateId
		if g.ActiveId == id {
			// Prevent reactivation
			g.NavActivateId = 0
		}

		// We reproduce the contents of BeginChildFrame() in order to provide 'label' so our window internal data are easier to read/debug.
		PushStyleColor(ImGuiCol_.ImGuiCol_ChildBg, style.Colors[ImGuiCol_.ImGuiCol_FrameBg])
		PushStyleVar(ImGuiStyleVar_.ImGuiStyleVar_ChildRounding, style.FrameRounding)
		PushStyleVar(ImGuiStyleVar_.ImGuiStyleVar_ChildBorderSize, style.FrameBorderSize)
		PushStyleVar(ImGuiStyleVar_.ImGuiStyleVar_WindowPadding, ImVec2{0, 0}); // Ensure no clip rect so mouse hover can reach FramePadding edges
		child_visible : bool = BeginChildEx(label, id, GetSize(frame_bb), ImGuiChildFlags_.ImGuiChildFlags_Borders, ImGuiWindowFlags_.ImGuiWindowFlags_NoMove)
		g.NavActivateId = backup_activate_id
		PopStyleVar(3)
		PopStyleColor()
		if !child_visible {
			EndChild()
			EndGroup()
			return false
		}
		draw_window = g.CurrentWindow; // Child window
		draw_window.DC.NavLayersActiveMaskNext |= (1 << cast(u32)draw_window.DC.NavLayerCurrent); // This is to ensure that EndChild() will display a navigation highlight so we can "enter" into it.
		draw_window.DC.CursorPos += style.FramePadding
		inner_size.x -= draw_window.ScrollbarSizes.x
	}
	else {
		// Support for internal ImGuiInputTextFlags_MergedItem flag, which could be redesigned as an ItemFlags if needed (with test performed in ItemAdd)
		ItemSize(total_bb, style.FramePadding.y)
		if (flags & cast(ImGuiInputTextFlags) ImGuiInputTextFlagsPrivate_.ImGuiInputTextFlags_MergedItem) == {} { if !ItemAdd(total_bb, id, &frame_bb, cast(ImGuiItemFlags)ImGuiItemFlagsPrivate_.ImGuiItemFlags_Inputable) { return false } }
	}

	// Ensure mouse cursor is set even after switching to keyboard/gamepad mode. May generalize further? (#6417)
	hovered : bool = ItemHoverable(frame_bb, id, g.LastItemData.ItemFlags | cast(ImGuiItemFlags)ImGuiItemFlagsPrivate_.ImGuiItemFlags_NoNavDisableMouseHover)
	if hovered { SetMouseCursor(ImGuiMouseCursor_.ImGuiMouseCursor_TextInput) }
	if hovered && g.NavHighlightItemUnderNav { hovered = false }

	// We are only allowed to access the state if we are already the active widget.
	state : ^ImGuiInputTextState = GetInputTextState(id)

	if (g.LastItemData.ItemFlags & cast(ImGuiItemFlags) ImGuiItemFlagsPrivate_.ImGuiItemFlags_ReadOnly) != {} { flags |= ImGuiInputTextFlags_.ImGuiInputTextFlags_ReadOnly }
	is_readonly : bool = (flags & ImGuiInputTextFlags_.ImGuiInputTextFlags_ReadOnly) != {}
	is_password : bool = (flags & ImGuiInputTextFlags_.ImGuiInputTextFlags_Password) != {}
	is_undoable : bool = (flags & ImGuiInputTextFlags_.ImGuiInputTextFlags_NoUndoRedo) == {}
	is_resizable : bool = (flags & ImGuiInputTextFlags_.ImGuiInputTextFlags_CallbackResize) != {}
	if is_resizable {
		// Must provide a callback if you set the ImGuiInputTextFlags_CallbackResize flag!
		IM_ASSERT(callback != nil)
	}

	input_requested_by_nav : bool = (g.ActiveId != id) && ((g.NavActivateId == id) && ((g.NavActivateFlags & ImGuiActivateFlags_.ImGuiActivateFlags_PreferInput) != {} || (g.NavInputSource == ImGuiInputSource.ImGuiInputSource_Keyboard)))

	user_clicked : bool = hovered && io.MouseClicked[0]
	user_scroll_finish : bool = is_multiline && state != nil && g.ActiveId == 0 && g.ActiveIdPreviousFrame == GetWindowScrollbarID(draw_window, ImGuiAxis.ImGuiAxis_Y)
	user_scroll_active : bool = is_multiline && state != nil && g.ActiveId == GetWindowScrollbarID(draw_window, ImGuiAxis.ImGuiAxis_Y)
	clear_active_id : bool = false
	select_all : bool = false

	scroll_y : f32 = is_multiline ? draw_window.Scroll.y : FLT_MAX

	init_reload_from_user_buf : bool = (state != nil && state.WantReloadUserBuf)
	init_changed_specs : bool = (state != nil && (state.Stb.single_line != false) != !is_multiline); // state != NULL means its our state.
	init_make_active : bool = (user_clicked || user_scroll_finish || input_requested_by_nav)
	init_state : bool = (init_make_active || user_scroll_active)
	if init_reload_from_user_buf {
		new_len : i32 = cast(i32) strlen(raw_data(buf))
		IM_ASSERT(cast(int)new_len + 1 <= len(buf), "Is your input buffer properly zero-terminated?")
		state.WantReloadUserBuf = false
		InputTextReconcileUndoState(state, state.TextA.Data[:state.TextLen], buf[:new_len])
		resize(&state.TextA, cast(i32)len(buf) + 1); // we use +1 to make sure that .Data is always pointing to at least an empty string.
		state.TextLen = new_len
		memcpy(state.TextA.Data, raw_data(buf), cast(int)state.TextLen + 1)
		state.Stb.select_start = state.ReloadSelectionStart
		state.Stb.select_end = state.ReloadSelectionEnd; state.Stb.cursor = state.Stb.select_end
		CursorClamp(state)
	}
	else if (init_state && g.ActiveId != id) || init_changed_specs {
		// Access state even if we don't own it yet.
		state = &g.InputTextState
		CursorAnimReset(state)

		// Backup state of deactivating item so they'll have a chance to do a write to output buffer on the same frame they report IsItemDeactivatedAfterEdit (#4714)
		InputTextDeactivateHook(state.ID)

		// Take a copy of the initial buffer value.
		// From the moment we focused we are normally ignoring the content of 'buf' (unless we are in read-only mode)
		buf_len : i32 = cast(i32) strlen(raw_data(buf))
		IM_ASSERT(cast(int)buf_len + 1 <= len(buf), "Is your input buffer properly zero-terminated?")
		resize(&state.TextToRevertTo, buf_len + 1); // UTF-8. we use +1 to make sure that .Data is always pointing to at least an empty string.
		memcpy(state.TextToRevertTo.Data, raw_data(buf), cast(int) buf_len + 1)

		// Preserve cursor position and undo/redo stack if we come back to same widget
		// FIXME: Since we reworked this on 2022/06, may want to differentiate recycle_cursor vs recycle_undostate?
		recycle_state : bool = (state.ID == id && !init_changed_specs)
		if recycle_state && (state.TextLen != buf_len || (state.TextA.Data == nil ||  string_from_slice(state.TextA.Data[:buf_len]) != string_from_slice(buf[:buf_len], false))) { recycle_state = false }

		// Start edition
		state.ID = id
		state.TextLen = buf_len
		if !is_readonly {
			resize(&state.TextA, cast(i32)len(buf) + 1); // we use +1 to make sure that .Data is always pointing to at least an empty string.
			memcpy(state.TextA.Data, raw_data(buf), cast(int)state.TextLen + 1)
		}

		// Find initial scroll position for right alignment
		state.Scroll = ImVec2{0.0, 0.0}
		if (flags & ImGuiInputTextFlags_.ImGuiInputTextFlags_ElideLeft) != {} { state.Scroll.x += ImMax(f32(0.0), CalcTextSize(string_from_slice(buf)).x - frame_size.x + style.FramePadding.x * 2.0) }

		// Recycle existing cursor/selection/undo stack but clamp position
		// Note a single mouse click will override the cursor/position immediately by calling stb_textedit_click handler.
		if recycle_state { CursorClamp(state) }
		else { stb_textedit_initialize_state(state.Stb, !is_multiline) }

		if !is_multiline {
			if (flags & ImGuiInputTextFlags_.ImGuiInputTextFlags_AutoSelectAll) != {} { select_all = true }
			if input_requested_by_nav && (!recycle_state || (g.NavActivateFlags & ImGuiActivateFlags_.ImGuiActivateFlags_TryToPreserveState) == {}) { select_all = true }
			if user_clicked && io.KeyCtrl { select_all = true }
		}

		if (flags & ImGuiInputTextFlags_.ImGuiInputTextFlags_AlwaysOverwrite) != {} {
			// stb field name is indeed incorrect (see #2863)
			state.Stb.insert_mode = true
		}
	}

	is_osx : bool = io.ConfigMacOSXBehaviors
	if g.ActiveId != id && init_make_active {
		IM_ASSERT(state != nil && state.ID == id)
		SetActiveID(id, window)
		SetFocusID(id, window)
		FocusWindow(window)
	}
	if g.ActiveId == id {
		// Declare some inputs, the other are registered and polled via Shortcut() routing system.
		// FIXME: The reason we don't use Shortcut() is we would need a routing flag to specify multiple mods, or to all mods combinaison into individual shortcuts.
		always_owned_keys := [?]ImGuiKey {ImGuiKey.ImGuiKey_LeftArrow, ImGuiKey.ImGuiKey_RightArrow, ImGuiKey.ImGuiKey_Enter, ImGuiKey.ImGuiKey_KeypadEnter, ImGuiKey.ImGuiKey_Delete, ImGuiKey.ImGuiKey_Backspace, ImGuiKey.ImGuiKey_Home, ImGuiKey.ImGuiKey_End}
		for key in always_owned_keys { SetKeyOwner(key, id) }

		if user_clicked { SetKeyOwner(ImGuiKey.ImGuiKey_MouseLeft, id) }
		g.ActiveIdUsingNavDirMask |= (1 << cast(u32)ImGuiDir.ImGuiDir_Left) | (1 << cast(u32)ImGuiDir.ImGuiDir_Right)
		if is_multiline || (flags & ImGuiInputTextFlags_.ImGuiInputTextFlags_CallbackHistory) != {} {
			g.ActiveIdUsingNavDirMask |= (1 << cast(u32)ImGuiDir.ImGuiDir_Up) | (1 << cast(u32)ImGuiDir.ImGuiDir_Down)
			SetKeyOwner(ImGuiKey.ImGuiKey_UpArrow, id)
			SetKeyOwner(ImGuiKey.ImGuiKey_DownArrow, id)
		}
		if is_multiline {
			SetKeyOwner(ImGuiKey.ImGuiKey_PageUp, id)
			SetKeyOwner(ImGuiKey.ImGuiKey_PageDown, id)
		}
		// FIXME: May be a problem to always steal Alt on OSX, would ideally still allow an uninterrupted Alt down-up to toggle menu
		if is_osx { SetKeyOwner(ImGuiKey.ImGuiMod_Alt, id) }

		// Expose scroll in a manner that is agnostic to us using a child window
		if is_multiline && state != nil { state.Scroll.y = draw_window.Scroll.y }

		// Read-only mode always ever read from source buffer. Refresh TextLen when active.
		if is_readonly && state != nil { state.TextLen = cast(i32) strlen(raw_data(buf)) }
		//if (is_readonly && state != NULL)
		//    state->TextA.clear(); // Uncomment to facilitate debugging, but we otherwise prefer to keep/amortize th allocation.
	}
	if state != nil { state.TextSrc = is_readonly ? raw_data(buf) : state.TextA.Data }

	// We have an edge case if ActiveId was set through another widget (e.g. widget being swapped), clear id immediately (don't wait until the end of the function)
	if g.ActiveId == id && state == nil { ClearActiveID() }

	// Release focus when we click outside
	if g.ActiveId == id && io.MouseClicked[0] && !init_state && !init_make_active {
		//-V560
		clear_active_id = true
	}

	// Lock the decision of whether we are going to take the path displaying the cursor or selection
	render_cursor : bool = (g.ActiveId == id) || (state != nil && user_scroll_active)
	render_selection : bool = state != nil && (HasSelection(state) || select_all) && (RENDER_SELECTION_WHEN_INACTIVE || render_cursor)
	value_changed : bool = false
	validated : bool = false

	// Select the buffer to render.
	buf_display_from_state : bool = (render_cursor || render_selection || g.ActiveId == id) && !is_readonly && state != nil
	is_displaying_hint : bool = (hint != "" && (buf_display_from_state ? state.TextA.Data : raw_data(buf))[0] == 0)

	// Password pushes a temporary font with only a fallback glyph
	if is_password && !is_displaying_hint {
		glyph : ^ImFontGlyph = FindGlyph(g.Font, '*')
		password_font : ^ImFont = &g.InputTextPasswordFont
		password_font.FontSize = g.Font.FontSize
		password_font.Scale = g.Font.Scale
		password_font.Ascent = g.Font.Ascent
		password_font.Descent = g.Font.Descent
		password_font.ContainerAtlas = g.Font.ContainerAtlas
		password_font.FallbackGlyph = glyph
		password_font.FallbackAdvanceX = glyph.AdvanceX
		IM_ASSERT(empty(&password_font.Glyphs) && empty(&password_font.IndexAdvanceX) && empty(&password_font.IndexLookup))
		PushFont(password_font)
	}

	// Process mouse inputs and character inputs
	if g.ActiveId == id {
		IM_ASSERT(state != nil)
		state.Edited = false
		state.BufCapacity = cast(i32) len(buf)
		state.Flags = flags

		// Although we are active we don't prevent mouse from hovering other elements unless we are interacting right now with the widget.
		// Down the line we should have a cleaner library-wide concept of Selected vs Active.
		g.ActiveIdAllowOverlap = !io.MouseDown[0]

		// Edit in progress
		mouse_x : f32 = (io.MousePos.x - frame_bb.Min.x - style.FramePadding.x) + state.Scroll.x
		mouse_y : f32 = (is_multiline ? (io.MousePos.y - draw_window.DC.CursorPos.y) : (g.FontSize * 0.5))

		if select_all {
			SelectAll(state)
			state.SelectedAllMouseLock = true
		}
		else if hovered && io.MouseClickedCount[0] >= 2 && !io.KeyShift {
			stb_textedit_click(state, state.Stb, mouse_x, mouse_y)
			multiclick_count := i32(io.MouseClickedCount[0] - 2)
			if (multiclick_count % 2) == 0 {
				// Double-click: Select word
				// We always use the "Mac" word advance for double-click select vs CTRL+Right which use the platform dependent variant:
				// FIXME: There are likely many ways to improve this behavior, but there's no "right" behavior (depends on use-case, software, OS)
				is_bol : bool = (state.Stb.cursor == 0) || ImStb_STB_TEXTEDIT_GETCHAR(state, state.Stb.cursor - 1) == '\n'
				if STB_TEXT_HAS_SELECTION(state.Stb) || !is_bol { OnKeyPressed(state, STB_TEXTEDIT_K_WORDLEFT) }
				//state->OnKeyPressed(STB_TEXTEDIT_K_WORDRIGHT | STB_TEXTEDIT_K_SHIFT);
				if !STB_TEXT_HAS_SELECTION(state.Stb) { ImStb_stb_textedit_prep_selection_at_cursor(state.Stb) }
				state.Stb.cursor = ImStb_STB_TEXTEDIT_MOVEWORDRIGHT_MAC(state, state.Stb.cursor)
				state.Stb.select_end = state.Stb.cursor
				ImStb_stb_textedit_clamp(state, state.Stb)
			}
			else {
				// Triple-click: Select line
				is_eol : bool = ImStb_STB_TEXTEDIT_GETCHAR(state, state.Stb.cursor) == '\n'
				OnKeyPressed(state, STB_TEXTEDIT_K_LINESTART)
				OnKeyPressed(state, STB_TEXTEDIT_K_LINEEND | STB_TEXTEDIT_K_SHIFT)
				OnKeyPressed(state, STB_TEXTEDIT_K_RIGHT | STB_TEXTEDIT_K_SHIFT)
				if !is_eol && is_multiline {
					ImSwap(&state.Stb.select_start, &state.Stb.select_end)
					state.Stb.cursor = state.Stb.select_end
				}
				state.CursorFollow = false
			}
			CursorAnimReset(state)
		}
		else if io.MouseClicked[0] && !state.SelectedAllMouseLock {
			if hovered {
				if io.KeyShift { stb_textedit_drag(state, state.Stb, mouse_x, mouse_y) }
				else { stb_textedit_click(state, state.Stb, mouse_x, mouse_y) }
				CursorAnimReset(state)
			}
		}
		else if io.MouseDown[0] && !state.SelectedAllMouseLock && (io.MouseDelta.x != 0.0 || io.MouseDelta.y != 0.0) {
			stb_textedit_drag(state, state.Stb, mouse_x, mouse_y)
			CursorAnimReset(state)
			state.CursorFollow = true
		}
		if state.SelectedAllMouseLock && !io.MouseDown[0] { state.SelectedAllMouseLock = false }

		// We expect backends to emit a Tab key but some also emit a Tab character which we ignore (#2467, #1336)
		// (For Tab and Enter: Win32/SFML/Allegro are sending both keys and chars, GLFW and SDL are only sending keys. For Space they all send all threes)
		if (flags & ImGuiInputTextFlags_.ImGuiInputTextFlags_AllowTabInput) != {} && !is_readonly {
			if Shortcut(ImGuiKey.ImGuiKey_Tab, ImGuiInputFlags_.ImGuiInputFlags_Repeat, id) {
				c : u32 = '\t'; // Insert TAB
				if InputTextFilterCharacter(g, &c, flags, callback, callback_user_data) { OnCharPressed(state, c) }
			}
			// FIXME: Implement Shift+Tab
			/*
            if (Shortcut(ImGuiKey_Tab | ImGuiMod_Shift, ImGuiInputFlags_Repeat, id))
            {
            }
            */
		}

		// Process regular text input (before we check for Return because using some IME will effectively send a Return?)
		// We ignore CTRL inputs, but need to allow ALT+CTRL as some keyboards (e.g. German) use AltGR (which _is_ Alt+Ctrl) to input certain characters.
		ignore_char_inputs : bool = (io.KeyCtrl && !io.KeyAlt) || (is_osx && io.KeyCtrl)
		if io.InputQueueCharacters.Size > 0 {
			if !ignore_char_inputs && !is_readonly && !input_requested_by_nav { for n : i32 = 0; n < io.InputQueueCharacters.Size; n += 1 {
				// Insert character if they pass filtering
				c : u32 = cast(u32) io.InputQueueCharacters.Data[n]
				if c == '\t' {
					// Skip Tab, see above.
					continue
				}
				if InputTextFilterCharacter(g, &c, flags, callback, callback_user_data) { OnCharPressed(state, c) }
			} }

			// Consume characters
			resize(&io.InputQueueCharacters, 0)
		}
	}

	// Process other shortcuts/key-presses
	revert_edit : bool = false
	if g.ActiveId == id && !g.ActiveIdIsJustActivated && !clear_active_id {
		IM_ASSERT(state != nil)

		row_count_per_page : i32 = ImMax(cast(i32) ((inner_size.y - style.FramePadding.y) / g.FontSize), 1)
		state.Stb.row_count_per_page = row_count_per_page

		k_mask : i32 = (io.KeyShift ? STB_TEXTEDIT_K_SHIFT : 0)
		is_wordmove_key_down : bool = is_osx ? io.KeyAlt : io.KeyCtrl; // OS X style: Text editing cursor movement using Alt instead of Ctrl
		is_startend_key_down : bool = is_osx && io.KeyCtrl && !io.KeySuper && !io.KeyAlt; // OS X style: Line/Text Start and End using Cmd+Arrows instead of Home/End

		// Using Shortcut() with ImGuiInputFlags_RouteFocused (default policy) to allow routing operations for other code (e.g. calling window trying to use CTRL+A and CTRL+B: formet would be handled by InputText)
		// Otherwise we could simply assume that we own the keys as we are active.
		f_repeat : ImGuiInputFlags = ImGuiInputFlags_.ImGuiInputFlags_Repeat
		is_cut : bool = (Shortcut(ImGuiKey.ImGuiMod_Ctrl | ImGuiKey.ImGuiKey_X, f_repeat, id) || Shortcut(ImGuiKey.ImGuiMod_Shift | ImGuiKey.ImGuiKey_Delete, f_repeat, id)) && !is_readonly && !is_password && (!is_multiline || HasSelection(state))
		is_copy : bool = (Shortcut(ImGuiKey.ImGuiMod_Ctrl | ImGuiKey.ImGuiKey_C, {}, id) || Shortcut(ImGuiKey.ImGuiMod_Ctrl | ImGuiKey.ImGuiKey_Insert, {}, id)) && !is_password && (!is_multiline || HasSelection(state))
		is_paste : bool = (Shortcut(ImGuiKey.ImGuiMod_Ctrl | ImGuiKey.ImGuiKey_V, f_repeat, id) || Shortcut(ImGuiKey.ImGuiMod_Shift | ImGuiKey.ImGuiKey_Insert, f_repeat, id)) && !is_readonly
		is_undo : bool = (Shortcut(ImGuiKey.ImGuiMod_Ctrl | ImGuiKey.ImGuiKey_Z, f_repeat, id)) && !is_readonly && is_undoable
		is_redo : bool = (Shortcut(ImGuiKey.ImGuiMod_Ctrl | ImGuiKey.ImGuiKey_Y, f_repeat, id) || (is_osx && Shortcut(ImGuiKey.ImGuiMod_Ctrl | ImGuiKey.ImGuiMod_Shift | ImGuiKey.ImGuiKey_Z, f_repeat, id))) && !is_readonly && is_undoable
		is_select_all : bool = Shortcut(ImGuiKey.ImGuiMod_Ctrl | ImGuiKey.ImGuiKey_A, {}, id)

		// We allow validate/cancel with Nav source (gamepad) to makes it easier to undo an accidental NavInput press with no keyboard wired, but otherwise it isn't very useful.
		nav_gamepad_active : bool = (io.ConfigFlags & ImGuiConfigFlags_.ImGuiConfigFlags_NavEnableGamepad) != {} && (io.BackendFlags & ImGuiBackendFlags_.ImGuiBackendFlags_HasGamepad) != {}
		is_enter_pressed : bool = IsKeyPressed(ImGuiKey.ImGuiKey_Enter, true) || IsKeyPressed(ImGuiKey.ImGuiKey_KeypadEnter, true)
		is_gamepad_validate : bool = nav_gamepad_active && (IsKeyPressed(ImGuiKey_NavGamepadActivate(g), false) || IsKeyPressed(ImGuiKey_NavGamepadInput, false))
		is_cancel : bool = Shortcut(ImGuiKey.ImGuiKey_Escape, f_repeat, id) || (nav_gamepad_active && Shortcut(ImGuiKey_NavGamepadCancel(g), f_repeat, id))

		// FIXME: Should use more Shortcut() and reduce IsKeyPressed()+SetKeyOwner(), but requires modifiers combination to be taken account of.
		// FIXME-OSX: Missing support for Alt(option)+Right/Left = go to end of line, or next line if already in end of line.
		if IsKeyPressed(ImGuiKey.ImGuiKey_LeftArrow) { OnKeyPressed(state, (is_startend_key_down ? STB_TEXTEDIT_K_LINESTART : is_wordmove_key_down ? STB_TEXTEDIT_K_WORDLEFT : STB_TEXTEDIT_K_LEFT) | k_mask) }
		else if IsKeyPressed(ImGuiKey.ImGuiKey_RightArrow) { OnKeyPressed(state, (is_startend_key_down ? STB_TEXTEDIT_K_LINEEND : is_wordmove_key_down ? STB_TEXTEDIT_K_WORDRIGHT : STB_TEXTEDIT_K_RIGHT) | k_mask) }
		else if IsKeyPressed(ImGuiKey.ImGuiKey_UpArrow) && is_multiline { if io.KeyCtrl { SetScrollY(draw_window, ImMax(draw_window.Scroll.y - g.FontSize, 0.0)) }
else { OnKeyPressed(state, (is_startend_key_down ? STB_TEXTEDIT_K_TEXTSTART : STB_TEXTEDIT_K_UP) | k_mask) } }
		else if IsKeyPressed(ImGuiKey.ImGuiKey_DownArrow) && is_multiline { if io.KeyCtrl { SetScrollY(draw_window, ImMin(draw_window.Scroll.y + g.FontSize, GetScrollMaxY())) }
else { OnKeyPressed(state, (is_startend_key_down ? STB_TEXTEDIT_K_TEXTEND : STB_TEXTEDIT_K_DOWN) | k_mask) } }
		else if IsKeyPressed(ImGuiKey.ImGuiKey_PageUp) && is_multiline {OnKeyPressed(state, STB_TEXTEDIT_K_PGUP | k_mask); scroll_y -= cast(f32) row_count_per_page * g.FontSize
		}
		else if IsKeyPressed(ImGuiKey.ImGuiKey_PageDown) && is_multiline {OnKeyPressed(state, STB_TEXTEDIT_K_PGDOWN | k_mask); scroll_y += cast(f32) row_count_per_page * g.FontSize
		}
		else if IsKeyPressed(ImGuiKey.ImGuiKey_Home) { OnKeyPressed(state, io.KeyCtrl ? STB_TEXTEDIT_K_TEXTSTART | k_mask : STB_TEXTEDIT_K_LINESTART | k_mask) }
		else if IsKeyPressed(ImGuiKey.ImGuiKey_End) { OnKeyPressed(state, io.KeyCtrl ? STB_TEXTEDIT_K_TEXTEND | k_mask : STB_TEXTEDIT_K_LINEEND | k_mask) }
		else if IsKeyPressed(ImGuiKey.ImGuiKey_Delete) && !is_readonly && !is_cut {
			if !HasSelection(state) {
				// OSX doesn't seem to have Super+Delete to delete until end-of-line, so we don't emulate that (as opposed to Super+Backspace)
				if is_wordmove_key_down { OnKeyPressed(state, STB_TEXTEDIT_K_WORDRIGHT | STB_TEXTEDIT_K_SHIFT) }
			}
			OnKeyPressed(state, STB_TEXTEDIT_K_DELETE | k_mask)
		}
		else if IsKeyPressed(ImGuiKey.ImGuiKey_Backspace) && !is_readonly {
			if !HasSelection(state) {
				if is_wordmove_key_down { OnKeyPressed(state, STB_TEXTEDIT_K_WORDLEFT | STB_TEXTEDIT_K_SHIFT) }
				else if is_osx && io.KeyCtrl && !io.KeyAlt && !io.KeySuper { OnKeyPressed(state, STB_TEXTEDIT_K_LINESTART | STB_TEXTEDIT_K_SHIFT) }
			}
			OnKeyPressed(state, STB_TEXTEDIT_K_BACKSPACE | k_mask)
		}
		else if is_enter_pressed || is_gamepad_validate {
			// Determine if we turn Enter into a \n character
			ctrl_enter_for_new_line : bool = (flags & ImGuiInputTextFlags_.ImGuiInputTextFlags_CtrlEnterForNewLine) != {}
			if !is_multiline || is_gamepad_validate || (ctrl_enter_for_new_line && !io.KeyCtrl) || (!ctrl_enter_for_new_line && io.KeyCtrl) {
				validated = true
				if io.ConfigInputTextEnterKeepActive && !is_multiline {
					// No need to scroll
					SelectAll(state)
				}
				else { clear_active_id = true }
			}
			else if !is_readonly {
				c : u32 = '\n'; // Insert new line
				if InputTextFilterCharacter(g, &c, flags, callback, callback_user_data) { OnCharPressed(state, c) }
			}
		}
		else if is_cancel {
			if (flags & ImGuiInputTextFlags_.ImGuiInputTextFlags_EscapeClearsAll) != {} {
				if buf[0] != 0 {
					revert_edit = true
				}
				else {
					render_selection = false; render_cursor = render_selection
					clear_active_id = true
				}
			}
			else {
				revert_edit = true; clear_active_id = revert_edit
				render_selection = false; render_cursor = render_selection
			}
		}
		else if is_undo || is_redo {
			OnKeyPressed(state, is_undo ? STB_TEXTEDIT_K_UNDO : STB_TEXTEDIT_K_REDO)
			ClearSelection(state)
		}
		else if is_select_all {
			SelectAll(state)
			state.CursorFollow = true
		}
		else if is_cut || is_copy {
			// Cut, Copy
			if g.PlatformIO.Platform_SetClipboardTextFn != nil {
				// SetClipboardText() only takes null terminated strings + state->TextSrc may point to read-only user buffer, so we need to make a copy.
				ib : i32 = HasSelection(state) ? ImMin(state.Stb.select_start, state.Stb.select_end) : 0
				ie : i32 = HasSelection(state) ? ImMax(state.Stb.select_start, state.Stb.select_end) : state.TextLen
				reserve(&g.TempBuffer, ie - ib + 1)
				memcpy(g.TempBuffer.Data, mem.ptr_offset(state.TextSrc, cast(int)ib), int(ie - ib))
				g.TempBuffer.Data[ie - ib] = 0
				SetClipboardText(string_from_cstr(cast(cstring)g.TempBuffer.Data, ie - ib))
			}
			if is_cut {
				if !HasSelection(state) { SelectAll(state) }
				state.CursorFollow = true
				stb_textedit_cut(state, state.Stb)
			}
		}
		else if is_paste {
			if clipboard := GetClipboardText(); clipboard != "" {
				// Filter pasted buffer
				clipboard_filtered : ImVector(u8)
				reserve(&clipboard_filtered, cast(i32) len(clipboard) + 1)
				for s, e := raw_data(clipboard), raw_data(clipboard)[len(clipboard):]; s != e;  {
					c : u32
					in_len := ImTextCharFromUtf8(&c, s, nil)
					s = s[in_len:]
					if !InputTextFilterCharacter(g, &c, flags, callback, callback_user_data, true) { continue }
					c_utf8 : [5]u8
					ImTextCharToUtf8(&c_utf8, c)
					out_len := cast(i32) strlen(raw_data(&c_utf8))
					resize(&clipboard_filtered, clipboard_filtered.Size + out_len)
					memcpy(clipboard_filtered.Data[clipboard_filtered.Size - out_len:], raw_data(&c_utf8), cast(int)out_len)
				}

				if clipboard_filtered.Size > 0 {
					// If everything was filtered, ignore the pasting operation
					push_back(&clipboard_filtered, 0)
					stb_textedit_paste(state, state.Stb, clipboard_filtered.Data[:clipboard_filtered.Size - 1])
					state.CursorFollow = true
				}
			}
		}

		// Update render selection flag after events have been handled, so selection highlight can be displayed during the same frame.
		render_selection |= HasSelection(state) && (RENDER_SELECTION_WHEN_INACTIVE || render_cursor)
	}

	// Process callbacks and apply result back to user's buffer.
	apply_new_text : ^u8 = nil
	apply_new_text_length : i32 = 0
	if g.ActiveId == id {
		IM_ASSERT(state != nil)
		if revert_edit && !is_readonly {
			if (flags & ImGuiInputTextFlags_.ImGuiInputTextFlags_EscapeClearsAll) != {} {
				// Clear input
				IM_ASSERT(buf[0] != 0)
				apply_new_text = &{}
				apply_new_text_length = 0
				value_changed = true
				empty_string : [0]IMSTB_TEXTEDIT_CHARTYPE
				stb_textedit_replace(state, state.Stb, empty_string[:])
			}
			else if strcmp(cast(cstring) raw_data(buf), cast(cstring) state.TextToRevertTo.Data) != 0 {
				apply_new_text = state.TextToRevertTo.Data
				apply_new_text_length = state.TextToRevertTo.Size - 1

				// Restore initial value. Only return true if restoring to the initial value changes the current buffer contents.
				// Push records into the undo stack so we can CTRL+Z the revert operation itself
				value_changed = true
				stb_textedit_replace(state, state.Stb, state.TextToRevertTo.Data[:state.TextToRevertTo.Size - 1])
			}
		}

		// When using 'ImGuiInputTextFlags_EnterReturnsTrue' as a special case we reapply the live buffer back to the input buffer
		// before clearing ActiveId, even though strictly speaking it wasn't modified on this frame.
		// If we didn't do that, code like InputInt() with ImGuiInputTextFlags_EnterReturnsTrue would fail.
		// This also allows the user to use InputText() with ImGuiInputTextFlags_EnterReturnsTrue without maintaining any user-side storage
		// (please note that if you use this property along ImGuiInputTextFlags_CallbackResize you can end up with your temporary string object
		// unnecessarily allocating once a frame, either store your string data, either if you don't then don't use ImGuiInputTextFlags_CallbackResize).
		apply_edit_back_to_user_buffer : bool = !revert_edit || (validated && (flags & ImGuiInputTextFlags_.ImGuiInputTextFlags_EnterReturnsTrue) != {})
		if apply_edit_back_to_user_buffer {
			// Apply new value immediately - copy modified buffer back
			// Note that as soon as the input box is active, the in-widget value gets priority over any underlying modification of the input buffer
			// FIXME: We actually always render 'buf' when calling DrawList->AddText, making the comment above incorrect.
			// FIXME-OPT: CPU waste to do this every time the widget is active, should mark dirty state from the stb_textedit callbacks.

			// User callback
			if (flags & (ImGuiInputTextFlags_.ImGuiInputTextFlags_CallbackCompletion | ImGuiInputTextFlags_.ImGuiInputTextFlags_CallbackHistory | ImGuiInputTextFlags_.ImGuiInputTextFlags_CallbackEdit | ImGuiInputTextFlags_.ImGuiInputTextFlags_CallbackAlways)) != {} {
				IM_ASSERT(callback != nil)

				// The reason we specify the usage semantic (Completion/History) is that Completion needs to disable keyboard TABBING at the moment.
				event_flag : ImGuiInputTextFlags = {}
				event_key : ImGuiKey = ImGuiKey.ImGuiKey_None
				if (flags & ImGuiInputTextFlags_.ImGuiInputTextFlags_CallbackCompletion) != {} && Shortcut(ImGuiKey.ImGuiKey_Tab, {}, id) {
					event_flag = ImGuiInputTextFlags_.ImGuiInputTextFlags_CallbackCompletion
					event_key = ImGuiKey.ImGuiKey_Tab
				}
				else if (flags & ImGuiInputTextFlags_.ImGuiInputTextFlags_CallbackHistory) != {} && IsKeyPressed(ImGuiKey.ImGuiKey_UpArrow) {
					event_flag = ImGuiInputTextFlags_.ImGuiInputTextFlags_CallbackHistory
					event_key = ImGuiKey.ImGuiKey_UpArrow
				}
				else if (flags & ImGuiInputTextFlags_.ImGuiInputTextFlags_CallbackHistory) != {} && IsKeyPressed(ImGuiKey.ImGuiKey_DownArrow) {
					event_flag = ImGuiInputTextFlags_.ImGuiInputTextFlags_CallbackHistory
					event_key = ImGuiKey.ImGuiKey_DownArrow
				}
				else if (flags & ImGuiInputTextFlags_.ImGuiInputTextFlags_CallbackEdit) != {} && state.Edited {
					event_flag = ImGuiInputTextFlags_.ImGuiInputTextFlags_CallbackEdit
				}
				else if (flags & ImGuiInputTextFlags_.ImGuiInputTextFlags_CallbackAlways) != {} {
					event_flag = ImGuiInputTextFlags_.ImGuiInputTextFlags_CallbackAlways
				}

				if event_flag != {} {
					callback_data : ImGuiInputTextCallbackData
					callback_data.Ctx = g
					callback_data.EventFlag = event_flag
					callback_data.Flags = flags
					callback_data.UserData = callback_user_data

					// FIXME-OPT: Undo stack reconcile needs a backup of the data until we rework API, see #7925
					callback_buf : [^]u8 = is_readonly ? raw_data(buf) : state.TextA.Data
					IM_ASSERT(callback_buf == state.TextSrc)
					resize(&state.CallbackTextBackup, state.TextLen + 1)
					memcpy(state.CallbackTextBackup.Data, callback_buf, int(state.TextLen + 1))

					callback_data.EventKey = event_key
					callback_data.Buf = callback_buf
					callback_data.BufTextLen = state.TextLen
					callback_data.BufSize = state.BufCapacity
					callback_data.BufDirty = false

					callback_data.CursorPos = state.Stb.cursor
					utf8_cursor_pos : i32 = callback_data.CursorPos
					callback_data.SelectionStart = state.Stb.select_start
					utf8_selection_start : i32 = callback_data.SelectionStart
					callback_data.SelectionEnd = state.Stb.select_end
					utf8_selection_end : i32 = callback_data.SelectionEnd

					// Call user code
					callback(&callback_data)

					// Read back what user may have modified
					callback_buf = is_readonly ? raw_data(buf) : state.TextA.Data; // Pointer may have been invalidated by a resize callback
					IM_ASSERT(callback_data.Buf == callback_buf); // Invalid to modify those fields
					IM_ASSERT(callback_data.BufSize == state.BufCapacity)
					IM_ASSERT(callback_data.Flags == flags)
					buf_dirty : bool = callback_data.BufDirty
					if callback_data.CursorPos != utf8_cursor_pos || buf_dirty {state.Stb.cursor = callback_data.CursorPos; state.CursorFollow = true
					}
					if callback_data.SelectionStart != utf8_selection_start || buf_dirty { state.Stb.select_start = (callback_data.SelectionStart == callback_data.CursorPos) ? state.Stb.cursor : callback_data.SelectionStart }
					if callback_data.SelectionEnd != utf8_selection_end || buf_dirty { state.Stb.select_end = (callback_data.SelectionEnd == callback_data.SelectionStart) ? state.Stb.select_start : callback_data.SelectionEnd }
					if buf_dirty {
						// Callback may update buffer and thus set buf_dirty even in read-only mode.
						IM_ASSERT(callback_data.BufTextLen == cast(i32) strlen(callback_data.Buf)); // You need to maintain BufTextLen if you change the text!
						InputTextReconcileUndoState(state, state.CallbackTextBackup.Data[:state.CallbackTextBackup.Size - 1], callback_data.Buf[:callback_data.BufTextLen])
						state.TextLen = callback_data.BufTextLen; // Assume correct length and valid UTF-8 from user, saves us an extra strlen()
						CursorAnimReset(state)
					}
				}
			}

			// Will copy result string if modified
			if !is_readonly && strcmp(cast(cstring)state.TextSrc, cast(cstring)raw_data(buf)) != 0 {
				apply_new_text = state.TextSrc
				apply_new_text_length = state.TextLen
				value_changed = true
			}
		}
	}

	// Handle reapplying final data on deactivation (see InputTextDeactivateHook() for details)
	if g.InputTextDeactivatedState.ID == id {
		if g.ActiveId != id && IsItemDeactivatedAfterEdit() && !is_readonly && strcmp(cast(cstring)g.InputTextDeactivatedState.TextA.Data, cast(cstring)raw_data(buf)) != 0 {
			apply_new_text = g.InputTextDeactivatedState.TextA.Data
			apply_new_text_length = g.InputTextDeactivatedState.TextA.Size - 1
			value_changed = true
			//IMGUI_DEBUG_LOG("InputText(): apply Deactivated data for 0x%08X: \"%.*s\".\n", id, apply_new_text_length, apply_new_text);
		}
		g.InputTextDeactivatedState.ID = 0
	}

	buf := buf

	// Copy result to user buffer. This can currently only happen when (g.ActiveId == id)
	if apply_new_text != nil {
		//// We cannot test for 'backup_current_text_length != apply_new_text_length' here because we have no guarantee that the size
		//// of our owned buffer matches the size of the string object held by the user, and by design we allow InputText() to be used
		//// without any storage on user's side.
		IM_ASSERT(apply_new_text_length >= 0)
		if is_resizable {
			callback_data : ImGuiInputTextCallbackData
			callback_data.Ctx = g
			callback_data.EventFlag = ImGuiInputTextFlags_.ImGuiInputTextFlags_CallbackResize
			callback_data.Flags = flags
			callback_data.Buf = raw_data(buf)
			callback_data.BufTextLen = apply_new_text_length
			callback_data.BufSize = ImMax(cast(i32)len(buf), apply_new_text_length + 1)
			callback_data.UserData = callback_user_data
			callback(&callback_data)
			buf = callback_data.Buf[:callback_data.BufSize]
			apply_new_text_length = ImMin(callback_data.BufTextLen, callback_data.BufSize - 1)
			IM_ASSERT(apply_new_text_length <= callback_data.BufSize)
		}
		//IMGUI_DEBUG_PRINT("InputText(\"%s\"): apply_new_text length %d\n", label, apply_new_text_length);

		// If the underlying buffer resize was denied or not carried to the next frame, apply_new_text_length+1 may be >= buf_size.
		ImStrncpy(raw_data(buf), apply_new_text, ImMin(apply_new_text_length + 1, cast(i32)len(buf)))
	}

	// Release active ID at the end of the function (so e.g. pressing Return still does a final application of the value)
	// Otherwise request text input ahead for next frame.
	if g.ActiveId == id && clear_active_id { ClearActiveID() }
	else if g.ActiveId == id { g.WantTextInputNextFrame = 1 }

	// Render frame
	if !is_multiline {
		RenderNavCursor(frame_bb, id)
		RenderFrame(frame_bb.Min, frame_bb.Max, GetColorU32(ImGuiCol_.ImGuiCol_FrameBg), true, style.FrameRounding)
	}

	clip_rect : ImRect = {frame_bb.Min, frame_bb.Min + inner_size}; // Not using frame_bb.Max because we have adjusted size
	draw_pos : ImVec2 = is_multiline ? draw_window.DC.CursorPos : frame_bb.Min + style.FramePadding
	text_size := ImVec2{ 0.0, 0.0 }

	// Set upper limit of single-line InputTextEx() at 2 million characters strings. The current pathological worst case is a long line
	// without any carriage return, which would makes ImFont::RenderText() reserve too many vertices and probably crash. Avoid it altogether.
	// Note that we only use this limit on single-line InputText(), so a pathologically large line on a InputTextMultiline() would still crash.
	buf_display_max_length : i32 = 2 * 1024 * 1024
	buf_display := buf_display_from_state ? state.TextA.Data : raw_data(buf); //-V595
	buf_display_end : [^]u8; // We have specialized paths below for setting the length
	if is_displaying_hint {
		buf_display = raw_data(hint)
		buf_display_end = raw_data(hint)[len(hint):]
	}

	// Render text. We currently only render selection when the widget is active or while scrolling.
	// FIXME: We could remove the '&& render_cursor' to keep rendering selection when inactive.
	if render_cursor || render_selection {
		IM_ASSERT(state != nil)
		if !is_displaying_hint { buf_display_end = buf_display[state.TextLen:] }

		// Render text (with cursor and selection)
		// This is going to be messy. We need to:
		// - Display the text (this alone can be more easily clipped)
		// - Handle scrolling, highlight selection, display cursor (those all requires some form of 1d->2d cursor position calculation)
		// - Measure text height (for scrollbar)
		// We are attempting to do most of that in **one main pass** to minimize the computation cost (non-negligible for large amount of text) + 2nd pass for selection rendering (we could merge them by an extra refactoring effort)
		// FIXME: This should occur on buf_display but we'd need to maintain cursor/select_start/select_end for UTF-8.
		text_begin := buf_display
		text_end := text_begin[state.TextLen:]
		cursor_offset : ImVec2; select_start_offset : ImVec2

		{
		// Find lines numbers straddling cursor and selection min position
		cursor_line_no : i32 = render_cursor ? -1 : -1000
		selmin_line_no : i32 = render_selection ? -1 : -1000
		cursor_ptr := render_cursor ? text_begin[state.Stb.cursor:] : nil
		selmin_ptr := render_selection ? text_begin[ImMin(state.Stb.select_start, state.Stb.select_end):] : nil

		// Count lines and find line number for cursor and selection ends
		line_count : i32 = 1
		if is_multiline {
			for s := text_begin; ; s = s[1:] {
				s = cast([^]u8) memchr(s, '\n', cast(int) mem.ptr_sub(text_end, s))
				if s == nil { break }
				if cursor_line_no == -1 && s >= cursor_ptr { cursor_line_no = line_count }
				if selmin_line_no == -1 && s >= selmin_ptr { selmin_line_no = line_count }
				post_incr(&line_count)
			}
		}
		if cursor_line_no == -1 { cursor_line_no = line_count }
		if selmin_line_no == -1 { selmin_line_no = line_count }

		// Calculate 2d position by finding the beginning of the line and measuring distance
		cursor_offset.x = InputTextCalcTextSize(g, ImStrbol(cursor_ptr, text_begin), cursor_ptr).x
		cursor_offset.y = f32(cursor_line_no) * g.FontSize
		if selmin_line_no >= 0 {
			select_start_offset.x = InputTextCalcTextSize(g, ImStrbol(selmin_ptr, text_begin), selmin_ptr).x
			select_start_offset.y = f32(selmin_line_no) * g.FontSize
		}

		// Store text height (note that we haven't calculated text width at all, see GitHub issues #383, #1224)
		if is_multiline { text_size = ImVec2{inner_size.x, f32(line_count) * g.FontSize} }
		}

		// Scroll
		if render_cursor && state.CursorFollow {
			// Horizontal scroll in chunks of quarter width
			if (flags & ImGuiInputTextFlags_.ImGuiInputTextFlags_NoHorizontalScroll) == {} {
				scroll_increment_x : f32 = inner_size.x * 0.25
				visible_width : f32 = inner_size.x - style.FramePadding.x
				if cursor_offset.x < state.Scroll.x { state.Scroll.x = IM_TRUNC(ImMax(f32(0.0), cursor_offset.x - scroll_increment_x)) }
				else if cursor_offset.x - visible_width >= state.Scroll.x { state.Scroll.x = IM_TRUNC(cursor_offset.x - visible_width + scroll_increment_x) }
			}
			else {
				state.Scroll.y = 0.0
			}

			// Vertical scroll
			if is_multiline {
				// Test if cursor is vertically visible
				if cursor_offset.y - g.FontSize < scroll_y { scroll_y = ImMax(f32(0.0), cursor_offset.y - g.FontSize) }
				else if cursor_offset.y - (inner_size.y - style.FramePadding.y * 2.0) >= scroll_y { scroll_y = cursor_offset.y - inner_size.y + style.FramePadding.y * 2.0 }
				scroll_max_y : f32 = ImMax((text_size.y + style.FramePadding.y * 2.0) - inner_size.y, 0.0)
				scroll_y = ImClamp(scroll_y, 0.0, scroll_max_y)
				draw_pos.y += (draw_window.Scroll.y - scroll_y); // Manipulate cursor pos immediately avoid a frame of lag
				draw_window.Scroll.y = scroll_y
			}

			state.CursorFollow = false
		}

		// Draw selection
		draw_scroll : ImVec2 = ImVec2{state.Scroll.x, 0.0}
		if render_selection {
			text_selected_begin := text_begin[ImMin(state.Stb.select_start, state.Stb.select_end):]
			text_selected_end := text_begin[ImMax(state.Stb.select_start, state.Stb.select_end):]

			bg_color : ImU32 = GetColorU32(ImGuiCol_.ImGuiCol_TextSelectedBg, render_cursor ? 1.0 : 0.6); // FIXME: current code flow mandate that render_cursor is always true here, we are leaving the transparent one for tests.
			bg_offy_up : f32 = is_multiline ? 0.0 : -1.0; // FIXME: those offsets should be part of the style? they don't play so well with multi-line selection.
			bg_offy_dn : f32 = is_multiline ? 0.0 : 2.0
			rect_pos : ImVec2 = draw_pos + select_start_offset - draw_scroll
			for p := text_selected_begin; p < text_selected_end;  {
				if rect_pos.y > (transmute(ImVec4)clip_rect).w + g.FontSize { break }
				if rect_pos.y < (transmute(ImVec4)clip_rect).y {
					p = cast([^]u8) memchr(p, '\n', mem.ptr_sub(text_selected_end, p))
					p = p != nil ? p[1:] : text_selected_end
				}
				else {
					rect_size : ImVec2 = InputTextCalcTextSize(g, p, text_selected_end, &p, nil, true)
					if rect_size.x <= 0.0 {
						// So we can see selected empty lines
						rect_size.x = IM_TRUNC(GetCharAdvance(g.Font, cast(ImWchar) ' ') * 0.50)
					}
					rect : ImRect; init(&rect, rect_pos + ImVec2{0.0, bg_offy_up - g.FontSize}, rect_pos + ImVec2{rect_size.x, bg_offy_dn})
					ClipWith(&rect, clip_rect)
					if Overlaps(rect, clip_rect) { AddRectFilled(draw_window.DrawList, rect.Min, rect.Max, bg_color) }
					rect_pos.x = draw_pos.x - draw_scroll.x
				}
				rect_pos.y += g.FontSize
			}
		}

		// We test for 'buf_display_max_length' as a way to avoid some pathological cases (e.g. single-line 1 MB string) which would make ImDrawList crash.
		// FIXME-OPT: Multiline could submit a smaller amount of contents to AddText() since we already iterated through it.
		if is_multiline || cast(i32)mem.ptr_sub(buf_display_end, buf_display) < buf_display_max_length {
			col : ImU32 = GetColorU32(is_displaying_hint ? ImGuiCol_.ImGuiCol_TextDisabled : ImGuiCol_.ImGuiCol_Text)
			AddText(draw_window.DrawList, g.Font, g.FontSize, draw_pos - draw_scroll, col, string_from_se(buf_display, buf_display_end), 0.0, is_multiline ? nil : cast(^ImVec4)&clip_rect)
		}

		// Draw blinking cursor
		if render_cursor {
			state.CursorAnim += io.DeltaTime
			cursor_is_visible : bool = (!g.IO.ConfigInputTextCursorBlink) || (state.CursorAnim <= 0.0) || ImFmod(state.CursorAnim, 1.20) <= 0.80
			cursor_screen_pos : ImVec2 = ImTrunc(draw_pos + cursor_offset - draw_scroll)
			cursor_screen_rect : ImRect; init(&cursor_screen_rect, cursor_screen_pos.x, cursor_screen_pos.y - g.FontSize + 0.5, cursor_screen_pos.x + 1.0, cursor_screen_pos.y - 1.5)
			if cursor_is_visible && Overlaps(cursor_screen_rect, clip_rect) { AddLine(draw_window.DrawList, cursor_screen_rect.Min, GetBL(cursor_screen_rect), GetColorU32(ImGuiCol_.ImGuiCol_Text)) }

			// Notify OS of text input position for advanced IME (-1 x offset so that Windows IME can cover our cursor. Bit of an extra nicety.)
			if !is_readonly {
				g.PlatformImeData.WantVisible = true
				g.PlatformImeData.InputPos = ImVec2{cursor_screen_pos.x - 1.0, cursor_screen_pos.y - g.FontSize}
				g.PlatformImeData.InputLineHeight = g.FontSize
				g.PlatformImeViewport = window.Viewport.ID
			}
		}
	}
	else {
		// Render text only (no selection, no cursor)
		if is_multiline {
			// We don't need width
			text_size = ImVec2{inner_size.x, cast(f32)InputTextCalcTextLenAndLineCount(string_from_se(buf_display, cast(^u8)buf_display_end)) * g.FontSize}
		}
		else if !is_displaying_hint && g.ActiveId == id { buf_display_end = buf_display[state.TextLen:] }
		else if !is_displaying_hint { buf_display_end = buf_display[strlen(buf_display):] }

		if is_multiline || cast(i32)mem.ptr_sub(buf_display_end, buf_display) < buf_display_max_length {
			// Find render position for right alignment
			if (flags & ImGuiInputTextFlags_.ImGuiInputTextFlags_ElideLeft) != {} {
				draw_pos.x = ImMin(draw_pos.x, frame_bb.Max.x - CalcTextSize(string_from_slice(buf_display[:strlen(buf_display)], false)).x - style.FramePadding.x)
			}

			draw_scroll : ImVec2 = ImVec2{0.0, 0.0}; // Preserve scroll when inactive?
			col : ImU32 = GetColorU32(is_displaying_hint ? ImGuiCol_.ImGuiCol_TextDisabled : ImGuiCol_.ImGuiCol_Text)
			AddText(draw_window.DrawList, g.Font, g.FontSize, draw_pos - draw_scroll, col, string_from_se(buf_display, buf_display_end), 0.0, is_multiline ? nil : cast(^ImVec4)&clip_rect)
		}
	}

	if is_password && !is_displaying_hint { PopFont() }

	if is_multiline {
		// For focus requests to work on our multiline we need to ensure our child ItemAdd() call specifies the ImGuiItemFlags_Inputable (see #4761, #7870)...
		Dummy(ImVec2{text_size.x, text_size.y + style.FramePadding.y})
		g.NextItemData.ItemFlags |= cast(ImGuiItemFlags) ImGuiItemFlagsPrivate_.ImGuiItemFlags_Inputable | ImGuiItemFlags_.ImGuiItemFlags_NoTabStop
		EndChild()
		item_data_backup.StatusFlags |= (g.LastItemData.StatusFlags & ImGuiItemStatusFlags_.ImGuiItemStatusFlags_HoveredWindow)

		// ...and then we need to undo the group overriding last item data, which gets a bit messy as EndGroup() tries to forward scrollbar being active...
		// FIXME: This quite messy/tricky, should attempt to get rid of the child window.
		EndGroup()
		if g.LastItemData.ID == 0 || g.LastItemData.ID != GetWindowScrollbarID(draw_window, ImGuiAxis.ImGuiAxis_Y) {
			g.LastItemData.ID = id
			g.LastItemData.ItemFlags = item_data_backup.ItemFlags
			g.LastItemData.StatusFlags = item_data_backup.StatusFlags
		}
	}
	if state != nil { state.TextSrc = nil }

	// Log as text
	if g.LogEnabled && (!is_password || is_displaying_hint) {
		LogSetNextTextDecoration("{", "}")
		LogRenderedText(&draw_pos, string_from_se(buf_display, buf_display_end))
	}

	if label_size.x > 0 { RenderText(ImVec2{frame_bb.Max.x + style.ItemInnerSpacing.x, frame_bb.Min.y + style.FramePadding.y}, label) }

	if value_changed { MarkItemEdited(id) }

	when IMGUI_ENABLE_TEST_ENGINE {
		if(g.TestEngineHookItems) {
			ImGuiTestEngineHook_ItemInfo(g, id, label, g.LastItemData.StatusFlags | ImGuiItemStatusFlags_.ImGuiItemStatusFlags_Inputable)
		}
	}
	if (flags & ImGuiInputTextFlags_.ImGuiInputTextFlags_EnterReturnsTrue) != {} { return validated }
	else { return value_changed }
}

DebugNodeInputTextState :: proc(state : ^ImGuiInputTextState)
{
	when ! IMGUI_DISABLE_DEBUG_TOOLS { /* @gen ifndef */
	g : ^ImGuiContext = GImGui
	stb_state : ^ImStb_STB_TexteditState = state.Stb
	undo_state : ^ImStb_StbUndoState = &stb_state.undostate
	Text("ID: 0x%08X, ActiveID: 0x%08X", state.ID, g.ActiveId)
	DebugLocateItemOnHover(state.ID)
	Text("CurLenA: %d, Cursor: %d, Selection: %d..%d", state.TextLen, stb_state.cursor, stb_state.select_start, stb_state.select_end)
	Text("BufCapacityA: %d", state.BufCapacity)
	Text("(Internal Buffer: TextA Size: %d, Capacity: %d)", state.TextA.Size, state.TextA.Capacity)
	Text("has_preferred_x: %d (%.2f)", stb_state.has_preferred_x, stb_state.preferred_x)
	Text("undo_point: %d, redo_point: %d, undo_char_point: %d, redo_char_point: %d", undo_state.undo_point, undo_state.redo_point, undo_state.undo_char_point, undo_state.redo_char_point)
	if BeginChild("undopoints", ImVec2{0.0, GetTextLineHeight() * 10}, ImGuiChildFlags_.ImGuiChildFlags_Borders | ImGuiChildFlags_.ImGuiChildFlags_ResizeY) {
		// Visualize undo state
		PushStyleVar(ImGuiStyleVar_.ImGuiStyleVar_ItemSpacing, ImVec2{0, 0})
		for n : i16 = 0; n < IMSTB_TEXTEDIT_UNDOSTATECOUNT; n += 1 {
			undo_rec := &undo_state.undo_rec[n]
			undo_rec_type : u8 = (n < undo_state.undo_point) ? 'u' : (n >= undo_state.redo_point) ? 'r' : ' '
			if undo_rec_type == ' ' { BeginDisabled() }
			buf_preview_len : i32 = (undo_rec_type != ' ' && undo_rec.char_storage != -1) ? undo_rec.insert_length : 0
			buf_preview_str := raw_data(&undo_state.undo_char)[undo_rec.char_storage:]
			Text("%c [%02d] where %03d, insert %03d, delete %03d, char_storage %03d \"%.*s\"", undo_rec_type, n, undo_rec.where_, undo_rec.insert_length, undo_rec.delete_length, undo_rec.char_storage, buf_preview_len, buf_preview_str)
			if undo_rec_type == ' ' { EndDisabled() }
		}

		PopStyleVar()
	}
	EndChild()
	} else { // preproc else
	IM_UNUSED(state)
	} // preproc endif
}

//-------------------------------------------------------------------------
// [SECTION] Widgets: ColorEdit, ColorPicker, ColorButton, etc.
//-------------------------------------------------------------------------
// - ColorEdit3()
// - ColorEdit4()
// - ColorPicker3()
// - RenderColorRectWithAlphaCheckerboard() [Internal]
// - ColorPicker4()
// - ColorButton()
// - SetColorEditOptions()
// - ColorTooltip() [Internal]
// - ColorEditOptionsPopup() [Internal]
// - ColorPickerOptionsPopup() [Internal]
//-------------------------------------------------------------------------

ColorEdit3 :: proc(label : string, col : ^[3]f32, flags : ImGuiColorEditFlags = {}) -> bool
{
	return ColorEdit4(label, cast(^[4]f32) col, flags | ImGuiColorEditFlags_.ImGuiColorEditFlags_NoAlpha)
}

ColorEditRestoreH :: proc(col : ^[3]f32, H : ^f32)
{
	g : ^ImGuiContext = GImGui
	IM_ASSERT(g.ColorEditCurrentID != 0)
	if g.ColorEditSavedID != g.ColorEditCurrentID || g.ColorEditSavedColor != ColorConvertFloat4ToU32(ImVec4{col[0], col[1], col[2], 0}) { return }
	H^ = g.ColorEditSavedHue
}

// ColorEdit supports RGB and HSV inputs. In case of RGB input resulting color may have undefined hue and/or saturation.
// Since widget displays both RGB and HSV values we must preserve hue and saturation to prevent these values resetting.
ColorEditRestoreHS :: proc(col : ^[3]f32, H : ^f32, S : ^f32, V : ^f32)
{
	g : ^ImGuiContext = GImGui
	IM_ASSERT(g.ColorEditCurrentID != 0)
	if g.ColorEditSavedID != g.ColorEditCurrentID || g.ColorEditSavedColor != ColorConvertFloat4ToU32(ImVec4{col[0], col[1], col[2], 0}) { return }

	// When S == 0, H is undefined.
	// When H == 1 it wraps around to 0.
	if S^ == 0.0 || (H^ == 0.0 && g.ColorEditSavedHue == 1) { H^ = g.ColorEditSavedHue }

	// When V == 0, S is undefined.
	if V^ == 0.0 { S^ = g.ColorEditSavedSat }
}

// Edit colors components (each component in 0.0f..1.0f range).
// See enum ImGuiColorEditFlags_ for available options. e.g. Only access 3 floats if ImGuiColorEditFlags_NoAlpha flag is set.
// With typical options: Left-click on color square to open color picker. Right-click to open option menu. CTRL-Click over input fields to edit them and TAB to go to next item.
ColorEdit4 :: proc(label : string, col : ^[4]f32, flags : ImGuiColorEditFlags) -> bool
{
	window : ^ImGuiWindow = GetCurrentWindow()
	if window.SkipItems { return false }

	g : ^ImGuiContext = GImGui
	style : ^ImGuiStyle = &g.Style
	square_sz : f32 = GetFrameHeight()
	label_display_end := FindRenderedTextEnd(label)
	w_full : f32 = CalcItemWidth()
	ClearFlags(&g.NextItemData)

	BeginGroup()
	PushID(label)
	set_current_color_edit_id : bool = (g.ColorEditCurrentID == 0)
	if set_current_color_edit_id { g.ColorEditCurrentID = back(&window.IDStack)^ }

	flags := flags
	// If we're not showing any slider there's no point in doing any HSV conversions
	flags_untouched : ImGuiColorEditFlags = flags
	if (flags & ImGuiColorEditFlags_.ImGuiColorEditFlags_NoInputs) != {} { flags = (flags & ImGuiColorEditFlags(~cast(i32)ImGuiColorEditFlags_.ImGuiColorEditFlags_DisplayMask_)) | ImGuiColorEditFlags_.ImGuiColorEditFlags_DisplayRGB | ImGuiColorEditFlags_.ImGuiColorEditFlags_NoOptions }

	// Context menu: display and modify options (before defaults are applied)
	if (flags & ImGuiColorEditFlags_.ImGuiColorEditFlags_NoOptions) == {} { ColorEditOptionsPopup(col, flags) }

	// Read stored options
	if (flags & ImGuiColorEditFlags_.ImGuiColorEditFlags_DisplayMask_) == {} { flags |= (g.ColorEditOptions & ImGuiColorEditFlags_.ImGuiColorEditFlags_DisplayMask_) }
	if (flags & ImGuiColorEditFlags_.ImGuiColorEditFlags_DataTypeMask_) == {} { flags |= (g.ColorEditOptions & ImGuiColorEditFlags_.ImGuiColorEditFlags_DataTypeMask_) }
	if (flags & ImGuiColorEditFlags_.ImGuiColorEditFlags_PickerMask_) == {} { flags |= (g.ColorEditOptions & ImGuiColorEditFlags_.ImGuiColorEditFlags_PickerMask_) }
	if (flags & ImGuiColorEditFlags_.ImGuiColorEditFlags_InputMask_) == {} { flags |= (g.ColorEditOptions & ImGuiColorEditFlags_.ImGuiColorEditFlags_InputMask_) }
	flags |= (g.ColorEditOptions & cast(ImGuiColorEditFlags)~i32(ImGuiColorEditFlags_.ImGuiColorEditFlags_DisplayMask_ | ImGuiColorEditFlags_.ImGuiColorEditFlags_DataTypeMask_ | ImGuiColorEditFlags_.ImGuiColorEditFlags_PickerMask_ | ImGuiColorEditFlags_.ImGuiColorEditFlags_InputMask_))
	IM_ASSERT(ImIsPowerOfTwo(u32(flags & ImGuiColorEditFlags_.ImGuiColorEditFlags_DisplayMask_))); // Check that only 1 is selected
	IM_ASSERT(ImIsPowerOfTwo(u32(flags & ImGuiColorEditFlags_.ImGuiColorEditFlags_InputMask_))); // Check that only 1 is selected

	alpha : bool = (flags & ImGuiColorEditFlags_.ImGuiColorEditFlags_NoAlpha) == {}
	hdr : bool = (flags & ImGuiColorEditFlags_.ImGuiColorEditFlags_HDR) != {}
	components : i32 = alpha ? 4 : 3
	w_button : f32 = (flags & ImGuiColorEditFlags_.ImGuiColorEditFlags_NoSmallPreview) != {} ? 0.0 : (square_sz + style.ItemInnerSpacing.x)
	w_inputs : f32 = ImMax(w_full - w_button, 1.0)
	w_full = w_inputs + w_button

	// Convert to the formats we need
	f : [4]f32 = {col[0], col[1], col[2], alpha ? col[3] : 1.0}
	if (flags & ImGuiColorEditFlags_.ImGuiColorEditFlags_InputHSV) != {} && (flags & ImGuiColorEditFlags_.ImGuiColorEditFlags_DisplayRGB) != {} { ColorConvertHSVtoRGB(f[0], f[1], f[2], &f[0], &f[1], &f[2]) }
	else if (flags & ImGuiColorEditFlags_.ImGuiColorEditFlags_InputRGB) != {} && (flags & ImGuiColorEditFlags_.ImGuiColorEditFlags_DisplayHSV) != {} {
		// Hue is lost when converting from grayscale rgb (saturation=0). Restore it.
		ColorConvertRGBtoHSV(f[0], f[1], f[2], &f[0], &f[1], &f[2])
		ColorEditRestoreHS(cast(^[3]f32)col, &f[0], &f[1], &f[2])
	}
	i : [4]i32 = {IM_F32_TO_INT8_UNBOUND(f[0]), IM_F32_TO_INT8_UNBOUND(f[1]), IM_F32_TO_INT8_UNBOUND(f[2]), IM_F32_TO_INT8_UNBOUND(f[3])}

	value_changed : bool = false
	value_changed_as_float : bool = false

	pos : ImVec2 = window.DC.CursorPos
	inputs_offset_x : f32 = (style.ColorButtonPosition == ImGuiDir.ImGuiDir_Left) ? w_button : 0.0
	window.DC.CursorPos.x = pos.x + inputs_offset_x

	if (flags & (ImGuiColorEditFlags_.ImGuiColorEditFlags_DisplayRGB | ImGuiColorEditFlags_.ImGuiColorEditFlags_DisplayHSV)) != {} && (flags & ImGuiColorEditFlags_.ImGuiColorEditFlags_NoInputs) == {} {
		// RGB/HSV 0..255 Sliders
		w_items : f32 = w_inputs - style.ItemInnerSpacing.x * f32(components - 1)

		hide_prefix : bool = (IM_TRUNC(w_items / f32(components)) <= CalcTextSize((flags & ImGuiColorEditFlags_.ImGuiColorEditFlags_Float) != {} ? "M:0.000" : "M:000").x)
		ids := [?]string {"##X", "##Y", "##Z", "##W"}
		fmt_table_int := [3][4]string {
			{"%3d", "%3d", "%3d", "%3d"}, // Short display
			{"R:%3d", "G:%3d", "B:%3d", "A:%3d"}, // Long display for RGBA
			{"H:%3d", "S:%3d", "V:%3d", "A:%3d"}, // Long display for HSVA
		}
		fmt_table_float := [3][4]string {
			{"%0.3f", "%0.3f", "%0.3f", "%0.3f"}, // Short display
			{"R:%0.3f", "G:%0.3f", "B:%0.3f", "A:%0.3f"}, // Long display for RGBA
			{"H:%0.3f", "S:%0.3f", "V:%0.3f", "A:%0.3f"}, // Long display for HSVA
		}
		fmt_idx : i32 = hide_prefix ? 0 : (flags & ImGuiColorEditFlags_.ImGuiColorEditFlags_DisplayHSV) != {} ? 2 : 1

		prev_split : f32 = 0.0
		for n : i32 = 0; n < components; n += 1 {
			if n > 0 { SameLine(0, style.ItemInnerSpacing.x) }
			next_split : f32 = IM_TRUNC(w_items * f32(n + 1) / f32(components))
			SetNextItemWidth(ImMax(next_split - prev_split, 1.0))
			prev_split = next_split

			// FIXME: When ImGuiColorEditFlags_HDR flag is passed HS values snap in weird ways when SV values go below 0.
			if (flags & ImGuiColorEditFlags_.ImGuiColorEditFlags_Float) != {} {
				value_changed |= DragFloat(ids[n], &f[n], 1.0 / 255.0, 0.0, hdr ? 0.0 : 1.0, fmt_table_float[fmt_idx][n])
				value_changed_as_float |= value_changed
			}
			else {
				value_changed |= DragInt(ids[n], &i[n], 1.0, 0, hdr ? 0 : 255, fmt_table_int[fmt_idx][n])
			}
			if (flags & ImGuiColorEditFlags_.ImGuiColorEditFlags_NoOptions) == {} { OpenPopupOnItemClick("context", ImGuiPopupFlags_.ImGuiPopupFlags_MouseButtonRight) }
		}
	}
	else if (flags & ImGuiColorEditFlags_.ImGuiColorEditFlags_DisplayHex) != {} && (flags & ImGuiColorEditFlags_.ImGuiColorEditFlags_NoInputs) == {} {
		// RGB Hexadecimal Input
		buf : [64]u8
		if alpha { ImFormatString(buf[:], "#%02X%02X%02X%02X", ImClamp(i[0], 0, 255), ImClamp(i[1], 0, 255), ImClamp(i[2], 0, 255), ImClamp(i[3], 0, 255)) }
		else { ImFormatString(buf[:], "#%02X%02X%02X", ImClamp(i[0], 0, 255), ImClamp(i[1], 0, 255), ImClamp(i[2], 0, 255)) }
		SetNextItemWidth(w_inputs)
		if InputText("##Text", buf[:], ImGuiInputTextFlags_.ImGuiInputTextFlags_CharsUppercase) {
			value_changed = true
			p := raw_data(&buf)
			for p[0] == '#' || ImCharIsBlankA(p[0]) { post_incr(&p) }

			i[2] = 0; i[1] = i[2]; i[0] = i[1]
			i[3] = 0xFF; // alpha default to 255 is not parsed by scanf (e.g. inputting #FFFFFF omitting alpha)
			if alpha {
				// Treat at unsigned (%X is unsigned)
				i[0] = i32((HEX_LUT_INVERSE[p[0]] << 4) | HEX_LUT_INVERSE[p[1]]); p = p[2:]
				i[1] = i32((HEX_LUT_INVERSE[p[0]] << 4) | HEX_LUT_INVERSE[p[1]]); p = p[2:]
				i[2] = i32((HEX_LUT_INVERSE[p[0]] << 4) | HEX_LUT_INVERSE[p[1]]); p = p[2:]
				i[3] = i32((HEX_LUT_INVERSE[p[0]] << 4) | HEX_LUT_INVERSE[p[1]]); p = p[2:]
			}
			else {
				i[0] = i32((HEX_LUT_INVERSE[p[0]] << 4) | HEX_LUT_INVERSE[p[1]]); p = p[2:]
				i[1] = i32((HEX_LUT_INVERSE[p[0]] << 4) | HEX_LUT_INVERSE[p[1]]); p = p[2:]
				i[2] = i32((HEX_LUT_INVERSE[p[0]] << 4) | HEX_LUT_INVERSE[p[1]]); p = p[2:]
			}
		}
		if (flags & ImGuiColorEditFlags_.ImGuiColorEditFlags_NoOptions) == {} { OpenPopupOnItemClick("context", ImGuiPopupFlags_.ImGuiPopupFlags_MouseButtonRight) }
	}

	picker_active_window : ^ImGuiWindow = nil
	if (flags & ImGuiColorEditFlags_.ImGuiColorEditFlags_NoSmallPreview) == {} {
		button_offset_x : f32 = ((flags & ImGuiColorEditFlags_.ImGuiColorEditFlags_NoInputs) != {} || (style.ColorButtonPosition == ImGuiDir.ImGuiDir_Left)) ? 0.0 : w_inputs + style.ItemInnerSpacing.x
		window.DC.CursorPos = ImVec2{pos.x + button_offset_x, pos.y}

		col_v4 : ImVec4 = {col[0], col[1], col[2], alpha ? col[3] : 1.0}
		if ColorButton("##ColorButton", col_v4, flags) {
			if (flags & ImGuiColorEditFlags_.ImGuiColorEditFlags_NoPicker) == {} {
				// Store current color and open a picker
				g.ColorPickerRef = col_v4
				OpenPopup("picker")
				SetNextWindowPos(GetBL(g.LastItemData.Rect) + ImVec2{0.0, style.ItemSpacing.y})
			}
		}
		if (flags & ImGuiColorEditFlags_.ImGuiColorEditFlags_NoOptions) == {} { OpenPopupOnItemClick("context", ImGuiPopupFlags_.ImGuiPopupFlags_MouseButtonRight) }

		if BeginPopup("picker") {
			if g.CurrentWindow.BeginCount == 1 {
				picker_active_window = g.CurrentWindow
				if len(label) != label_display_end {
					TextEx(label[:label_display_end])
					Spacing()
				}
				picker_flags_to_forward : ImGuiColorEditFlags = ImGuiColorEditFlags_.ImGuiColorEditFlags_DataTypeMask_ | ImGuiColorEditFlags_.ImGuiColorEditFlags_PickerMask_ | ImGuiColorEditFlags_.ImGuiColorEditFlags_InputMask_ | ImGuiColorEditFlags_.ImGuiColorEditFlags_HDR | ImGuiColorEditFlags_.ImGuiColorEditFlags_NoAlpha | ImGuiColorEditFlags_.ImGuiColorEditFlags_AlphaBar
				picker_flags : ImGuiColorEditFlags = (flags_untouched & picker_flags_to_forward) | ImGuiColorEditFlags_.ImGuiColorEditFlags_DisplayMask_ | ImGuiColorEditFlags_.ImGuiColorEditFlags_NoLabel | ImGuiColorEditFlags_.ImGuiColorEditFlags_AlphaPreviewHalf
				SetNextItemWidth(square_sz * 12.0); // Use 256 + bar sizes?
				value_changed |= ColorPicker4("##picker", col, picker_flags, &g.ColorPickerRef)
			}
			EndPopup()
		}
	}

	if len(label) != label_display_end && (flags & ImGuiColorEditFlags_.ImGuiColorEditFlags_NoLabel) == {} {
		// Position not necessarily next to last submitted button (e.g. if style.ColorButtonPosition == ImGuiDir_Left),
		// but we need to use SameLine() to setup baseline correctly. Might want to refactor SameLine() to simplify this.
		SameLine(0.0, style.ItemInnerSpacing.x)
		window.DC.CursorPos.x = pos.x + ((flags & ImGuiColorEditFlags_.ImGuiColorEditFlags_NoInputs) != {} ? w_button : w_full + style.ItemInnerSpacing.x)
		TextEx(label[:label_display_end])
	}

	// Convert back
	if value_changed && picker_active_window == nil {
		if !value_changed_as_float { for n : i32 = 0; n < 4; n += 1 { f[n] = f32(i[n]) / 255.0 } }
		if (flags & ImGuiColorEditFlags_.ImGuiColorEditFlags_DisplayHSV) != {} && (flags & ImGuiColorEditFlags_.ImGuiColorEditFlags_InputRGB) != {} {
			g.ColorEditSavedHue = f[0]
			g.ColorEditSavedSat = f[1]
			ColorConvertHSVtoRGB(f[0], f[1], f[2], &f[0], &f[1], &f[2])
			g.ColorEditSavedID = g.ColorEditCurrentID
			g.ColorEditSavedColor = ColorConvertFloat4ToU32(ImVec4{f[0], f[1], f[2], 0})
		}
		if (flags & ImGuiColorEditFlags_.ImGuiColorEditFlags_DisplayRGB) != {} && (flags & ImGuiColorEditFlags_.ImGuiColorEditFlags_InputHSV) != {} { ColorConvertRGBtoHSV(f[0], f[1], f[2], &f[0], &f[1], &f[2]) }

		col[0] = f[0]
		col[1] = f[1]
		col[2] = f[2]
		if alpha { col[3] = f[3] }
	}

	if set_current_color_edit_id { g.ColorEditCurrentID = 0 }
	PopID()
	EndGroup()

	// Drag and Drop Target
	// NB: The flag test is merely an optional micro-optimization, BeginDragDropTarget() does the same test.
	if (g.LastItemData.StatusFlags & ImGuiItemStatusFlags_.ImGuiItemStatusFlags_HoveredRect) != {} && (g.LastItemData.ItemFlags & cast(ImGuiItemFlags) ImGuiItemFlagsPrivate_.ImGuiItemFlags_ReadOnly) == {} && (flags & ImGuiColorEditFlags_.ImGuiColorEditFlags_NoDragDrop) == {} && BeginDragDropTarget() {
		accepted_drag_drop : bool = false
		if payload : ^ImGuiPayload = AcceptDragDropPayload(IMGUI_PAYLOAD_TYPE_COLOR_3F); payload != nil {
			memcpy(cast(^f32) col, payload.Data, size_of(f32) * 3); // Preserve alpha if any //-V512 //-V1086
			accepted_drag_drop = true; value_changed = accepted_drag_drop
		}
		if payload : ^ImGuiPayload = AcceptDragDropPayload(IMGUI_PAYLOAD_TYPE_COLOR_4F); payload != nil {
			memcpy(cast(^f32) col, payload.Data, size_of(f32) * cast(int)components)
			accepted_drag_drop = true; value_changed = accepted_drag_drop
		}

		// Drag-drop payloads are always RGB
		if accepted_drag_drop && (flags & ImGuiColorEditFlags_.ImGuiColorEditFlags_InputHSV) != {} { ColorConvertRGBtoHSV(col[0], col[1], col[2], &col[0], &col[1], &col[2]) }
		EndDragDropTarget()
	}

	// When picker is being actively used, use its active id so IsItemActive() will function on ColorEdit4().
	if picker_active_window != nil && g.ActiveId != 0 && g.ActiveIdWindow == picker_active_window { g.LastItemData.ID = g.ActiveId }

	if value_changed && g.LastItemData.ID != 0 {
		// In case of ID collision, the second EndGroup() won't catch g.ActiveId
		MarkItemEdited(g.LastItemData.ID)
	}

	return value_changed
}

ColorPicker3 :: proc(label : string, col : ^[3]f32, flags : ImGuiColorEditFlags) -> bool
{
	col4 : [4]f32 = {col[0], col[1], col[2], 1.0}
	if !ColorPicker4(label, &col4, flags | ImGuiColorEditFlags_.ImGuiColorEditFlags_NoAlpha) { return false }
	col[0] = col4[0]; col[1] = col4[1]; col[2] = col4[2]
	return true
}

// Helper for ColorPicker4()
RenderArrowsForVerticalBar :: proc(draw_list : ^ImDrawList, pos : ImVec2, half_sz : ImVec2, bar_w : f32, alpha : f32)
{
	alpha8 : ImU32 = cast(u32)IM_F32_TO_INT8_SAT(alpha)
	RenderArrowPointingAt(draw_list, ImVec2{pos.x + half_sz.x + 1, pos.y}, ImVec2{half_sz.x + 2, half_sz.y + 1}, ImGuiDir.ImGuiDir_Right, IM_COL32(0, 0, 0, alpha8))
	RenderArrowPointingAt(draw_list, ImVec2{pos.x + half_sz.x, pos.y}, half_sz, ImGuiDir.ImGuiDir_Right, IM_COL32(255, 255, 255, alpha8))
	RenderArrowPointingAt(draw_list, ImVec2{pos.x + bar_w - half_sz.x - 1, pos.y}, ImVec2{half_sz.x + 2, half_sz.y + 1}, ImGuiDir.ImGuiDir_Left, IM_COL32(0, 0, 0, alpha8))
	RenderArrowPointingAt(draw_list, ImVec2{pos.x + bar_w - half_sz.x, pos.y}, half_sz, ImGuiDir.ImGuiDir_Left, IM_COL32(255, 255, 255, alpha8))
}

// Note: ColorPicker4() only accesses 3 floats if ImGuiColorEditFlags_NoAlpha flag is set.
// (In C++ the 'float col[4]' notation for a function argument is equivalent to 'float* col', we only specify a size to facilitate understanding of the code.)
// FIXME: we adjust the big color square height based on item width, which may cause a flickering feedback loop (if automatic height makes a vertical scrollbar appears, affecting automatic width..)
// FIXME: this is trying to be aware of style.Alpha but not fully correct. Also, the color wheel will have overlapping glitches with (style.Alpha < 1.0)
ColorPicker4 :: proc(label : string, col : ^[4]f32, flags : ImGuiColorEditFlags = {}, ref_col : ^[4]f32 = nil) -> bool
{
	g : ^ImGuiContext = GImGui
	window : ^ImGuiWindow = GetCurrentWindow()
	if window.SkipItems { return false }

	draw_list : ^ImDrawList = window.DrawList
	style : ^ImGuiStyle = &g.Style
	io : ^ImGuiIO = &g.IO

	width : f32 = CalcItemWidth()
	is_readonly : bool = ((g.NextItemData.ItemFlags | g.CurrentItemFlags) & cast(ImGuiItemFlags)ImGuiItemFlagsPrivate_.ImGuiItemFlags_ReadOnly) != {}
	ClearFlags(&g.NextItemData)

	PushID(label)
	set_current_color_edit_id : bool = (g.ColorEditCurrentID == 0)
	if set_current_color_edit_id { g.ColorEditCurrentID = back(&window.IDStack)^ }
	BeginGroup()

	flags := flags
	if (flags & ImGuiColorEditFlags_.ImGuiColorEditFlags_NoSidePreview) == {} { flags |= ImGuiColorEditFlags_.ImGuiColorEditFlags_NoSmallPreview }

	// Context menu: display and store options.
	if (flags & ImGuiColorEditFlags_.ImGuiColorEditFlags_NoOptions) == {} { ColorPickerOptionsPopup(col, flags) }

	// Read stored options
	if (flags & ImGuiColorEditFlags_.ImGuiColorEditFlags_PickerMask_) == {} { flags |= ((g.ColorEditOptions & ImGuiColorEditFlags_.ImGuiColorEditFlags_PickerMask_) != {} ? g.ColorEditOptions : ImGuiColorEditFlags_.ImGuiColorEditFlags_DefaultOptions_) & ImGuiColorEditFlags_.ImGuiColorEditFlags_PickerMask_ }
	if (flags & ImGuiColorEditFlags_.ImGuiColorEditFlags_InputMask_) == {} { flags |= ((g.ColorEditOptions & ImGuiColorEditFlags_.ImGuiColorEditFlags_InputMask_) != {} ? g.ColorEditOptions : ImGuiColorEditFlags_.ImGuiColorEditFlags_DefaultOptions_) & ImGuiColorEditFlags_.ImGuiColorEditFlags_InputMask_ }
	IM_ASSERT(ImIsPowerOfTwo(u32(flags & ImGuiColorEditFlags_.ImGuiColorEditFlags_PickerMask_))); // Check that only 1 is selected
	IM_ASSERT(ImIsPowerOfTwo(u32(flags & ImGuiColorEditFlags_.ImGuiColorEditFlags_InputMask_))); // Check that only 1 is selected
	if (flags & ImGuiColorEditFlags_.ImGuiColorEditFlags_NoOptions) == {} { flags |= (g.ColorEditOptions & ImGuiColorEditFlags_.ImGuiColorEditFlags_AlphaBar) }

	// Setup
	components : i32 = (flags & ImGuiColorEditFlags_.ImGuiColorEditFlags_NoAlpha) != {} ? 3 : 4
	alpha_bar : bool = (flags & ImGuiColorEditFlags_.ImGuiColorEditFlags_AlphaBar) != {} && (flags & ImGuiColorEditFlags_.ImGuiColorEditFlags_NoAlpha) == {}
	picker_pos : ImVec2 = window.DC.CursorPos
	square_sz : f32 = GetFrameHeight()
	bars_width : f32 = square_sz; // Arbitrary smallish width of Hue/Alpha picking bars
	sv_picker_size : f32 = ImMax(bars_width * 1, width - (alpha_bar ? 2 : 1) * (bars_width + style.ItemInnerSpacing.x)); // Saturation/Value picking box
	bar0_pos_x : f32 = picker_pos.x + sv_picker_size + style.ItemInnerSpacing.x
	bar1_pos_x : f32 = bar0_pos_x + bars_width + style.ItemInnerSpacing.x
	bars_triangles_half_sz : f32 = IM_TRUNC(bars_width * 0.20)

	backup_initial_col : [4]f32
	memcpy(&backup_initial_col, col, int(components) * size_of(f32))

	wheel_thickness : f32 = sv_picker_size * 0.08
	wheel_r_outer : f32 = sv_picker_size * 0.50
	wheel_r_inner : f32 = wheel_r_outer - wheel_thickness
	wheel_center := ImVec2{ picker_pos.x + (sv_picker_size + bars_width) * 0.5, picker_pos.y + sv_picker_size * 0.5 }

	// Note: the triangle is displayed rotated with triangle_pa pointing to Hue, but most coordinates stays unrotated for logic.
	triangle_r : f32 = wheel_r_inner - cast(f32) cast(i32) (sv_picker_size * 0.027)
	triangle_pa : ImVec2 = ImVec2{triangle_r, 0.0}; // Hue point.
	triangle_pb : ImVec2 = ImVec2{triangle_r * -0.5, triangle_r * -0.866025}; // Black point.
	triangle_pc : ImVec2 = ImVec2{triangle_r * -0.5, triangle_r * +0.866025}; // White point.

	H : f32 = col[0]; S : f32 = col[1]; V : f32 = col[2]
	R : f32 = col[0]; G : f32 = col[1]; B : f32 = col[2]
	if (flags & ImGuiColorEditFlags_.ImGuiColorEditFlags_InputRGB) != {} {
		// Hue is lost when converting from grayscale rgb (saturation=0). Restore it.
		ColorConvertRGBtoHSV(R, G, B, &H, &S, &V)
		ColorEditRestoreHS(cast(^[3]f32) col, &H, &S, &V)
	}
	else if (flags & ImGuiColorEditFlags_.ImGuiColorEditFlags_InputHSV) != {} {
		ColorConvertHSVtoRGB(H, S, V, &R, &G, &B)
	}

	value_changed : bool = false; value_changed_h : bool = false; value_changed_sv : bool = false

	PushItemFlag(ImGuiItemFlags_.ImGuiItemFlags_NoNav, true)
	if (flags & ImGuiColorEditFlags_.ImGuiColorEditFlags_PickerHueWheel) != {} {
		// Hue wheel + SV triangle logic
		InvisibleButton("hsv", ImVec2{sv_picker_size + style.ItemInnerSpacing.x + bars_width, sv_picker_size})
		if IsItemActive() && !is_readonly {
			initial_off : ImVec2 = g.IO.MouseClickedPos[0] - wheel_center
			current_off : ImVec2 = g.IO.MousePos - wheel_center
			initial_dist2 : f32 = ImLengthSqr(initial_off)
			if initial_dist2 >= (wheel_r_inner - 1) * (wheel_r_inner - 1) && initial_dist2 <= (wheel_r_outer + 1) * (wheel_r_outer + 1) {
				// Interactive with Hue wheel
				H = ImAtan2(current_off.y, current_off.x) / IM_PI * 0.5
				if H < 0.0 { H += 1.0 }
				value_changed_h = true; value_changed = value_changed_h
			}
			cos_hue_angle : f32 = ImCos(-H * 2.0 * IM_PI)
			sin_hue_angle : f32 = ImSin(-H * 2.0 * IM_PI)
			if ImTriangleContainsPoint(triangle_pa, triangle_pb, triangle_pc, ImRotate(initial_off, cos_hue_angle, sin_hue_angle)) {
				// Interacting with SV triangle
				current_off_unrotated : ImVec2 = ImRotate(current_off, cos_hue_angle, sin_hue_angle)
				if !ImTriangleContainsPoint(triangle_pa, triangle_pb, triangle_pc, current_off_unrotated) { current_off_unrotated = ImTriangleClosestPoint(triangle_pa, triangle_pb, triangle_pc, current_off_unrotated) }
				uu : f32; vv : f32; ww : f32
				ImTriangleBarycentricCoords(triangle_pa, triangle_pb, triangle_pc, current_off_unrotated, &uu, &vv, &ww)
				V = ImClamp(1.0 - vv, 0.0001, 1.0)
				S = ImClamp(uu / V, 0.0001, 1.0)
				value_changed_sv = true; value_changed = value_changed_sv
			}
		}
		if (flags & ImGuiColorEditFlags_.ImGuiColorEditFlags_NoOptions) == {} { OpenPopupOnItemClick("context", ImGuiPopupFlags_.ImGuiPopupFlags_MouseButtonRight) }
	}
	else if (flags & ImGuiColorEditFlags_.ImGuiColorEditFlags_PickerHueBar) != {} {
		// SV rectangle logic
		InvisibleButton("sv", ImVec2{sv_picker_size, sv_picker_size})
		if IsItemActive() && !is_readonly {
			S = ImSaturate((io.MousePos.x - picker_pos.x) / (sv_picker_size - 1))
			V = 1.0 - ImSaturate((io.MousePos.y - picker_pos.y) / (sv_picker_size - 1))
			ColorEditRestoreH(cast(^[3]f32) col, &H); // Greatly reduces hue jitter and reset to 0 when hue == 255 and color is rapidly modified using SV square.
			value_changed_sv = true; value_changed = value_changed_sv
		}
		if (flags & ImGuiColorEditFlags_.ImGuiColorEditFlags_NoOptions) == {} { OpenPopupOnItemClick("context", ImGuiPopupFlags_.ImGuiPopupFlags_MouseButtonRight) }

		// Hue bar logic
		SetCursorScreenPos(ImVec2{bar0_pos_x, picker_pos.y})
		InvisibleButton("hue", ImVec2{bars_width, sv_picker_size})
		if IsItemActive() && !is_readonly {
			H = ImSaturate((io.MousePos.y - picker_pos.y) / (sv_picker_size - 1))
			value_changed_h = true; value_changed = value_changed_h
		}
	}

	// Alpha bar logic
	if alpha_bar {
		SetCursorScreenPos(ImVec2{bar1_pos_x, picker_pos.y})
		InvisibleButton("alpha", ImVec2{bars_width, sv_picker_size})
		if IsItemActive() {
			col[3] = 1.0 - ImSaturate((io.MousePos.y - picker_pos.y) / (sv_picker_size - 1))
			value_changed = true
		}
	}
	PopItemFlag(); // ImGuiItemFlags_NoNav

	if (flags & ImGuiColorEditFlags_.ImGuiColorEditFlags_NoSidePreview) == {} {
		SameLine(0, style.ItemInnerSpacing.x)
		BeginGroup()
	}

	if (flags & ImGuiColorEditFlags_.ImGuiColorEditFlags_NoLabel) == {} {
		label_display_end := FindRenderedTextEnd(label)
		if len(label) != label_display_end {
			if (flags & ImGuiColorEditFlags_.ImGuiColorEditFlags_NoSidePreview) != {} { SameLine(0, style.ItemInnerSpacing.x) }
			TextEx(label[:label_display_end])
		}
	}

	if (flags & ImGuiColorEditFlags_.ImGuiColorEditFlags_NoSidePreview) == {} {
		PushItemFlag(ImGuiItemFlags_.ImGuiItemFlags_NoNavDefaultFocus, true)
		col_v4 : ImVec4 = {col[0], col[1], col[2], (flags & ImGuiColorEditFlags_.ImGuiColorEditFlags_NoAlpha) != {} ? 1.0 : col[3] }
		if (flags & ImGuiColorEditFlags_.ImGuiColorEditFlags_NoLabel) != {} { Text("Current") }

		sub_flags_to_forward : ImGuiColorEditFlags = ImGuiColorEditFlags_.ImGuiColorEditFlags_InputMask_ | ImGuiColorEditFlags_.ImGuiColorEditFlags_HDR | ImGuiColorEditFlags_.ImGuiColorEditFlags_AlphaPreview | ImGuiColorEditFlags_.ImGuiColorEditFlags_AlphaPreviewHalf | ImGuiColorEditFlags_.ImGuiColorEditFlags_NoTooltip
		ColorButton("##current", col_v4, (flags & sub_flags_to_forward), ImVec2{square_sz * 3, square_sz * 2})
		if ref_col != nil {
			Text("Original")
			ref_col_v4 : ImVec4 = {ref_col[0], ref_col[1], ref_col[2], (flags & ImGuiColorEditFlags_.ImGuiColorEditFlags_NoAlpha) != {} ? 1.0 : ref_col[3]}
			if ColorButton("##original", ref_col_v4, (flags & sub_flags_to_forward), ImVec2{square_sz * 3, square_sz * 2}) {
				memcpy(col, ref_col, int(components) * size_of(f32))
				value_changed = true
			}
		}
		PopItemFlag()
		EndGroup()
	}

	// Convert back color to RGB
	if value_changed_h || value_changed_sv {
		if (flags & ImGuiColorEditFlags_.ImGuiColorEditFlags_InputRGB) != {} {
			ColorConvertHSVtoRGB(H, S, V, &col[0], &col[1], &col[2])
			g.ColorEditSavedHue = H
			g.ColorEditSavedSat = S
			g.ColorEditSavedID = g.ColorEditCurrentID
			g.ColorEditSavedColor = ColorConvertFloat4ToU32(ImVec4{col[0], col[1], col[2], 0})
		}
		else if (flags & ImGuiColorEditFlags_.ImGuiColorEditFlags_InputHSV) != {} {
			col[0] = H
			col[1] = S
			col[2] = V
		}
	}

	// R,G,B and H,S,V slider color editor
	value_changed_fix_hue_wrap : bool = false
	if (flags & ImGuiColorEditFlags_.ImGuiColorEditFlags_NoInputs) == {} {
		PushItemWidth((alpha_bar ? bar1_pos_x : bar0_pos_x) + bars_width - picker_pos.x)
		sub_flags_to_forward : ImGuiColorEditFlags = ImGuiColorEditFlags_.ImGuiColorEditFlags_DataTypeMask_ | ImGuiColorEditFlags_.ImGuiColorEditFlags_InputMask_ | ImGuiColorEditFlags_.ImGuiColorEditFlags_HDR | ImGuiColorEditFlags_.ImGuiColorEditFlags_NoAlpha | ImGuiColorEditFlags_.ImGuiColorEditFlags_NoOptions | ImGuiColorEditFlags_.ImGuiColorEditFlags_NoTooltip | ImGuiColorEditFlags_.ImGuiColorEditFlags_NoSmallPreview | ImGuiColorEditFlags_.ImGuiColorEditFlags_AlphaPreview | ImGuiColorEditFlags_.ImGuiColorEditFlags_AlphaPreviewHalf
		sub_flags : ImGuiColorEditFlags = (flags & sub_flags_to_forward) | ImGuiColorEditFlags_.ImGuiColorEditFlags_NoPicker
		if flags & ImGuiColorEditFlags_.ImGuiColorEditFlags_DisplayRGB != {} || (flags & ImGuiColorEditFlags_.ImGuiColorEditFlags_DisplayMask_) == {} { if ColorEdit4("##rgb", col, sub_flags | ImGuiColorEditFlags_.ImGuiColorEditFlags_DisplayRGB) {
	// FIXME: Hackily differentiating using the DragInt (ActiveId != 0 && !ActiveIdAllowOverlap) vs. using the InputText or DropTarget.
	// For the later we don't want to run the hue-wrap canceling code. If you are well versed in HSV picker please provide your input! (See #2050)
	value_changed_fix_hue_wrap = (g.ActiveId != 0 && !g.ActiveIdAllowOverlap)
	value_changed = true
} }
		if flags & ImGuiColorEditFlags_.ImGuiColorEditFlags_DisplayHSV != {} || (flags & ImGuiColorEditFlags_.ImGuiColorEditFlags_DisplayMask_) == {} { value_changed |= ColorEdit4("##hsv", col, sub_flags | ImGuiColorEditFlags_.ImGuiColorEditFlags_DisplayHSV) }
		if flags & ImGuiColorEditFlags_.ImGuiColorEditFlags_DisplayHex != {} || (flags & ImGuiColorEditFlags_.ImGuiColorEditFlags_DisplayMask_) == {} { value_changed |= ColorEdit4("##hex", col, sub_flags | ImGuiColorEditFlags_.ImGuiColorEditFlags_DisplayHex) }
		PopItemWidth()
	}

	// Try to cancel hue wrap (after ColorEdit4 call), if any
	if value_changed_fix_hue_wrap && (flags & ImGuiColorEditFlags_.ImGuiColorEditFlags_InputRGB) != {} {
		new_H : f32; new_S : f32; new_V : f32
		ColorConvertRGBtoHSV(col[0], col[1], col[2], &new_H, &new_S, &new_V)
		if new_H <= 0 && H > 0 {
			if new_V <= 0 && V != new_V { ColorConvertHSVtoRGB(H, S, new_V <= 0 ? V * 0.5 : new_V, &col[0], &col[1], &col[2]) }
			else if new_S <= 0 { ColorConvertHSVtoRGB(H, new_S <= 0 ? S * 0.5 : new_S, new_V, &col[0], &col[1], &col[2]) }
		}
	}

	if value_changed {
		if (flags & ImGuiColorEditFlags_.ImGuiColorEditFlags_InputRGB) != {} {
			R = col[0]
			G = col[1]
			B = col[2]
			ColorConvertRGBtoHSV(R, G, B, &H, &S, &V)
			ColorEditRestoreHS(cast(^[3]f32) col, &H, &S, &V); // Fix local Hue as display below will use it immediately.
		}
		else if (flags & ImGuiColorEditFlags_.ImGuiColorEditFlags_InputHSV) != {} {
			H = col[0]
			S = col[1]
			V = col[2]
			ColorConvertHSVtoRGB(H, S, V, &R, &G, &B)
		}
	}

	style_alpha8 : i32 = IM_F32_TO_INT8_SAT(style.Alpha)
	col_black : ImU32 = IM_COL32(0, 0, 0, style_alpha8)
	col_white : ImU32 = IM_COL32(255, 255, 255, style_alpha8)
	col_midgrey : ImU32 = IM_COL32(128, 128, 128, style_alpha8)
	col_hues : [6 + 1]ImU32 = {IM_COL32(255, 0, 0, style_alpha8), IM_COL32(255, 255, 0, style_alpha8), IM_COL32(0, 255, 0, style_alpha8), IM_COL32(0, 255, 255, style_alpha8), IM_COL32(0, 0, 255, style_alpha8), IM_COL32(255, 0, 255, style_alpha8), IM_COL32(255, 0, 0, style_alpha8)}

	hue_color_f : ImVec4 = {1, 1, 1, style.Alpha}; ColorConvertHSVtoRGB(H, 1, 1, &hue_color_f.x, &hue_color_f.y, &hue_color_f.z)
	hue_color32 : ImU32 = ColorConvertFloat4ToU32(hue_color_f)
	user_col32_striped_of_alpha : ImU32 = ColorConvertFloat4ToU32(ImVec4{R, G, B, style.Alpha}); // Important: this is still including the main rendering/style alpha!!

	sv_cursor_pos : ImVec2

	if (flags & ImGuiColorEditFlags_.ImGuiColorEditFlags_PickerHueWheel) != {} {
		// Render Hue Wheel
		aeps : f32 = 0.5 / wheel_r_outer; // Half a pixel arc length in radians (2pi cancels out).
		segment_per_arc : i32 = ImMax(i32(4), cast(i32) wheel_r_outer / 12)
		for n : i32 = 0; n < 6; n += 1 {
			a0 : f32 = f32(n) / 6.0 * 2.0 * IM_PI - aeps
			a1 : f32 = f32(n + 1.0) / 6.0 * 2.0 * IM_PI + aeps
			vert_start_idx : i32 = draw_list.VtxBuffer.Size
			PathArcTo(draw_list, wheel_center, (wheel_r_inner + wheel_r_outer) * 0.5, a0, a1, segment_per_arc)
			PathStroke(draw_list, col_white, {}, wheel_thickness)
			vert_end_idx : i32 = draw_list.VtxBuffer.Size

			// Paint colors over existing vertices
			gradient_p0 := ImVec2{ wheel_center.x + ImCos(a0) * wheel_r_inner, wheel_center.y + ImSin(a0) * wheel_r_inner }
			gradient_p1 := ImVec2{ wheel_center.x + ImCos(a1) * wheel_r_inner, wheel_center.y + ImSin(a1) * wheel_r_inner }
			ShadeVertsLinearColorGradientKeepAlpha(draw_list, vert_start_idx, vert_end_idx, gradient_p0, gradient_p1, col_hues[n], col_hues[n + 1])
		}

		// Render Cursor + preview on Hue Wheel
		cos_hue_angle : f32 = ImCos(H * 2.0 * IM_PI)
		sin_hue_angle : f32 = ImSin(H * 2.0 * IM_PI)
		hue_cursor_pos := ImVec2{ wheel_center.x + cos_hue_angle * (wheel_r_inner + wheel_r_outer) * 0.5, wheel_center.y + sin_hue_angle * (wheel_r_inner + wheel_r_outer) * 0.5 }
		hue_cursor_rad : f32 = value_changed_h ? wheel_thickness * 0.65 : wheel_thickness * 0.55
		hue_cursor_segments : i32 = _CalcCircleAutoSegmentCount(draw_list, hue_cursor_rad); // Lock segment count so the +1 one matches others.
		AddCircleFilled(draw_list, hue_cursor_pos, hue_cursor_rad, hue_color32, hue_cursor_segments)
		AddCircle(draw_list, hue_cursor_pos, hue_cursor_rad + 1, col_midgrey, hue_cursor_segments)
		AddCircle(draw_list, hue_cursor_pos, hue_cursor_rad, col_white, hue_cursor_segments)

		// Render SV triangle (rotated according to hue)
		tra : ImVec2 = wheel_center + ImRotate(triangle_pa, cos_hue_angle, sin_hue_angle)
		trb : ImVec2 = wheel_center + ImRotate(triangle_pb, cos_hue_angle, sin_hue_angle)
		trc : ImVec2 = wheel_center + ImRotate(triangle_pc, cos_hue_angle, sin_hue_angle)
		uv_white : ImVec2 = GetFontTexUvWhitePixel()
		PrimReserve(draw_list, 3, 3)
		PrimVtx(draw_list, tra, uv_white, hue_color32)
		PrimVtx(draw_list, trb, uv_white, col_black)
		PrimVtx(draw_list, trc, uv_white, col_white)
		AddTriangle(draw_list, tra, trb, trc, col_midgrey, 1.5)
		sv_cursor_pos = ImLerp(ImLerp(trc, tra, ImSaturate(S)), trb, ImSaturate(1 - V))
	}
	else if (flags & ImGuiColorEditFlags_.ImGuiColorEditFlags_PickerHueBar) != {} {
		// Render SV Square
		AddRectFilledMultiColor(draw_list, picker_pos, picker_pos + ImVec2{sv_picker_size, sv_picker_size}, col_white, hue_color32, hue_color32, col_white)
		AddRectFilledMultiColor(draw_list, picker_pos, picker_pos + ImVec2{sv_picker_size, sv_picker_size}, 0, 0, col_black, col_black)
		RenderFrameBorder(picker_pos, picker_pos + ImVec2{sv_picker_size, sv_picker_size}, 0.0)
		sv_cursor_pos.x = ImClamp(IM_ROUND(picker_pos.x + ImSaturate(S) * sv_picker_size), picker_pos.x + 2, picker_pos.x + sv_picker_size - 2); // Sneakily prevent the circle to stick out too much
		sv_cursor_pos.y = ImClamp(IM_ROUND(picker_pos.y + ImSaturate(1 - V) * sv_picker_size), picker_pos.y + 2, picker_pos.y + sv_picker_size - 2)

		// Render Hue Bar
		for i : i32 = 0; i < 6; i += 1 { AddRectFilledMultiColor(draw_list, ImVec2{bar0_pos_x, picker_pos.y + f32(i) * (sv_picker_size / 6)}, ImVec2{bar0_pos_x + bars_width, picker_pos.y + f32(i + 1) * (sv_picker_size / 6)}, col_hues[i], col_hues[i], col_hues[i + 1], col_hues[i + 1]) }

		bar0_line_y : f32 = IM_ROUND(picker_pos.y + H * sv_picker_size)
		RenderFrameBorder(ImVec2{bar0_pos_x, picker_pos.y}, ImVec2{bar0_pos_x + bars_width, picker_pos.y + sv_picker_size}, 0.0)
		RenderArrowsForVerticalBar(draw_list, ImVec2{bar0_pos_x - 1, bar0_line_y}, ImVec2{bars_triangles_half_sz + 1, bars_triangles_half_sz}, bars_width + 2.0, style.Alpha)
	}

	// Render cursor/preview circle (clamp S/V within 0..1 range because floating points colors may lead HSV values to be out of range)
	sv_cursor_rad : f32 = value_changed_sv ? wheel_thickness * 0.55 : wheel_thickness * 0.40
	sv_cursor_segments : i32 = _CalcCircleAutoSegmentCount(draw_list, sv_cursor_rad); // Lock segment count so the +1 one matches others.
	AddCircleFilled(draw_list, sv_cursor_pos, sv_cursor_rad, user_col32_striped_of_alpha, sv_cursor_segments)
	AddCircle(draw_list, sv_cursor_pos, sv_cursor_rad + 1, col_midgrey, sv_cursor_segments)
	AddCircle(draw_list, sv_cursor_pos, sv_cursor_rad, col_white, sv_cursor_segments)

	// Render alpha bar
	if alpha_bar {
		alpha : f32 = ImSaturate(col[3])
		bar1_bb : ImRect; init(&bar1_bb, bar1_pos_x, picker_pos.y, bar1_pos_x + bars_width, picker_pos.y + sv_picker_size)
		RenderColorRectWithAlphaCheckerboard(draw_list, bar1_bb.Min, bar1_bb.Max, 0, GetWidth(bar1_bb) / 2.0, ImVec2{0.0, 0.0})
		AddRectFilledMultiColor(draw_list, bar1_bb.Min, bar1_bb.Max, user_col32_striped_of_alpha, user_col32_striped_of_alpha, user_col32_striped_of_alpha & ~ImU32(IM_COL32_A_MASK), user_col32_striped_of_alpha & ~ImU32(IM_COL32_A_MASK))
		bar1_line_y : f32 = IM_ROUND(picker_pos.y + (1.0 - alpha) * sv_picker_size)
		RenderFrameBorder(bar1_bb.Min, bar1_bb.Max, 0.0)
		RenderArrowsForVerticalBar(draw_list, ImVec2{bar1_pos_x - 1, bar1_line_y}, ImVec2{bars_triangles_half_sz + 1, bars_triangles_half_sz}, bars_width + 2.0, style.Alpha)
	}

	EndGroup()

	if value_changed && memcmp(&backup_initial_col, col, components * size_of(f32)) == 0 { value_changed = false }
	if value_changed && g.LastItemData.ID != 0 {
		// In case of ID collision, the second EndGroup() won't catch g.ActiveId
		MarkItemEdited(g.LastItemData.ID)
	}

	if set_current_color_edit_id { g.ColorEditCurrentID = 0 }
	PopID()

	return value_changed
}

// A little color square. Return true when clicked.
// FIXME: May want to display/ignore the alpha component in the color display? Yet show it in the tooltip.
// 'desc_id' is not called 'label' because we don't display it next to the button, but only in the tooltip.
// Note that 'col' may be encoded in HSV if ImGuiColorEditFlags_InputHSV is set.
ColorButton :: proc(desc_id : string, col : ImVec4, flags : ImGuiColorEditFlags = {}, size_arg : ImVec2 = {}) -> bool
{
	window : ^ImGuiWindow = GetCurrentWindow()
	if window.SkipItems { return false }

	g : ^ImGuiContext = GImGui
	id : ImGuiID = GetID(window, desc_id)
	default_size : f32 = GetFrameHeight()
	size := ImVec2{ size_arg.x == 0.0 ? default_size : size_arg.x, size_arg.y == 0.0 ? default_size : size_arg.y }
	bb : ImRect; init(&bb, window.DC.CursorPos, window.DC.CursorPos + size)
	ItemSize(bb, (size.y >= default_size) ? g.Style.FramePadding.y : 0.0)
	if !ItemAdd(bb, id) { return false }

	hovered : bool; held : bool
	pressed : bool = ButtonBehavior(bb, id, &hovered, &held)

	flags := flags
	if (flags & ImGuiColorEditFlags_.ImGuiColorEditFlags_NoAlpha) != {} { flags &= cast(ImGuiColorEditFlags) ~i32(ImGuiColorEditFlags_.ImGuiColorEditFlags_AlphaPreview | ImGuiColorEditFlags_.ImGuiColorEditFlags_AlphaPreviewHalf) }

	col_rgb : ImVec4 = col
	if (flags & ImGuiColorEditFlags_.ImGuiColorEditFlags_InputHSV) != {} { ColorConvertHSVtoRGB(col_rgb.x, col_rgb.y, col_rgb.z, &col_rgb.x, &col_rgb.y, &col_rgb.z) }

	col_rgb_without_alpha : ImVec4 = {col_rgb.x, col_rgb.y, col_rgb.z, 1.0}
	grid_step : f32 = ImMin(size.x, size.y) / 2.99
	rounding : f32 = ImMin(g.Style.FrameRounding, grid_step * 0.5)
	bb_inner : ImRect = bb
	off : f32 = 0.0
	if (flags & ImGuiColorEditFlags_.ImGuiColorEditFlags_NoBorder) == {} {
		off = -0.75; // The border (using Col_FrameBg) tends to look off when color is near-opaque and rounding is enabled. This offset seemed like a good middle ground to reduce those artifacts.
		Expand(&bb_inner, off)
	}
	if (flags & ImGuiColorEditFlags_.ImGuiColorEditFlags_AlphaPreviewHalf) != {} && col_rgb.w < 1.0 {
		mid_x : f32 = IM_ROUND((bb_inner.Min.x + bb_inner.Max.x) * 0.5)
		RenderColorRectWithAlphaCheckerboard(window.DrawList, ImVec2{bb_inner.Min.x + grid_step, bb_inner.Min.y}, bb_inner.Max, GetColorU32(col_rgb), grid_step, ImVec2{-grid_step + off, off}, rounding, ImDrawFlags_.ImDrawFlags_RoundCornersRight)
		AddRectFilled(window.DrawList, bb_inner.Min, ImVec2{mid_x, bb_inner.Max.y}, GetColorU32(col_rgb_without_alpha), rounding, ImDrawFlags_.ImDrawFlags_RoundCornersLeft)
	}
	else {
		// Because GetColorU32() multiplies by the global style Alpha and we don't want to display a checkerboard if the source code had no alpha
		col_source : ImVec4 = (flags & ImGuiColorEditFlags_.ImGuiColorEditFlags_AlphaPreview) != {} ? col_rgb : col_rgb_without_alpha
		if col_source.w < 1.0 { RenderColorRectWithAlphaCheckerboard(window.DrawList, bb_inner.Min, bb_inner.Max, GetColorU32(col_source), grid_step, ImVec2{off, off}, rounding) }
		else { AddRectFilled(window.DrawList, bb_inner.Min, bb_inner.Max, GetColorU32(col_source), rounding) }
	}
	RenderNavCursor(bb, id)
	if (flags & ImGuiColorEditFlags_.ImGuiColorEditFlags_NoBorder) == {} {
		if g.Style.FrameBorderSize > 0.0 { RenderFrameBorder(bb.Min, bb.Max, rounding) }
		else {
			// Color button are often in need of some sort of border
			AddRect(window.DrawList, bb.Min, bb.Max, GetColorU32(ImGuiCol_.ImGuiCol_FrameBg), rounding)
		}
	}

	// Drag and Drop Source
	// NB: The ActiveId test is merely an optional micro-optimization, BeginDragDropSource() does the same test.
	if g.ActiveId == id && (flags & ImGuiColorEditFlags_.ImGuiColorEditFlags_NoDragDrop) == {} && BeginDragDropSource() {
		if (flags & ImGuiColorEditFlags_.ImGuiColorEditFlags_NoAlpha) != {} { SetDragDropPayload(IMGUI_PAYLOAD_TYPE_COLOR_3F, &col_rgb, size_of(f32) * 3, ImGuiCond_.ImGuiCond_Once) }
		else { SetDragDropPayload(IMGUI_PAYLOAD_TYPE_COLOR_4F, &col_rgb, size_of(f32) * 4, ImGuiCond_.ImGuiCond_Once) }
		ColorButton(desc_id, col, flags)
		SameLine()
		TextEx("Color")
		EndDragDropSource()
	}

	// Tooltip
	if (flags & ImGuiColorEditFlags_.ImGuiColorEditFlags_NoTooltip) == {} && hovered && IsItemHovered(ImGuiHoveredFlags_.ImGuiHoveredFlags_ForTooltip) { ColorTooltip(desc_id, col, flags & (ImGuiColorEditFlags_.ImGuiColorEditFlags_InputMask_ | ImGuiColorEditFlags_.ImGuiColorEditFlags_NoAlpha | ImGuiColorEditFlags_.ImGuiColorEditFlags_AlphaPreview | ImGuiColorEditFlags_.ImGuiColorEditFlags_AlphaPreviewHalf)) }

	return pressed
}

// Initialize/override default color options
SetColorEditOptions :: proc(flags : ImGuiColorEditFlags)
{
	flags := flags
	g : ^ImGuiContext = GImGui
	if (flags & ImGuiColorEditFlags_.ImGuiColorEditFlags_DisplayMask_) == {} { flags |= ImGuiColorEditFlags_.ImGuiColorEditFlags_DefaultOptions_ & ImGuiColorEditFlags_.ImGuiColorEditFlags_DisplayMask_ }
	if (flags & ImGuiColorEditFlags_.ImGuiColorEditFlags_DataTypeMask_) == {} { flags |= ImGuiColorEditFlags_.ImGuiColorEditFlags_DefaultOptions_ & ImGuiColorEditFlags_.ImGuiColorEditFlags_DataTypeMask_ }
	if (flags & ImGuiColorEditFlags_.ImGuiColorEditFlags_PickerMask_) == {} { flags |= ImGuiColorEditFlags_.ImGuiColorEditFlags_DefaultOptions_ & ImGuiColorEditFlags_.ImGuiColorEditFlags_PickerMask_ }
	if (flags & ImGuiColorEditFlags_.ImGuiColorEditFlags_InputMask_) == {} { flags |= ImGuiColorEditFlags_.ImGuiColorEditFlags_DefaultOptions_ & ImGuiColorEditFlags_.ImGuiColorEditFlags_InputMask_ }
	IM_ASSERT(ImIsPowerOfTwo(u32(flags & ImGuiColorEditFlags_.ImGuiColorEditFlags_DisplayMask_))); // Check only 1 option is selected
	IM_ASSERT(ImIsPowerOfTwo(u32(flags & ImGuiColorEditFlags_.ImGuiColorEditFlags_DataTypeMask_))); // Check only 1 option is selected
	IM_ASSERT(ImIsPowerOfTwo(u32(flags & ImGuiColorEditFlags_.ImGuiColorEditFlags_PickerMask_))); // Check only 1 option is selected
	IM_ASSERT(ImIsPowerOfTwo(u32(flags & ImGuiColorEditFlags_.ImGuiColorEditFlags_InputMask_))); // Check only 1 option is selected
	g.ColorEditOptions = flags
}

// Note: only access 3 floats if ImGuiColorEditFlags_NoAlpha flag is set.
ColorTooltip :: proc(text : string, col : [4]f32, flags : ImGuiColorEditFlags)
{
	g : ^ImGuiContext = GImGui

	if !BeginTooltipEx(ImGuiTooltipFlags_.ImGuiTooltipFlags_OverridePrevious, ImGuiWindowFlags_.ImGuiWindowFlags_None) { return }
	text_end := text != "" ? FindRenderedTextEnd(text) : len(text)
	if text_end > 0 {
		TextEx(text[:text_end])
		Separator()
	}

	sz := ImVec2{ g.FontSize * 3 + g.Style.FramePadding.y * 2, g.FontSize * 3 + g.Style.FramePadding.y * 2 }
	cf : ImVec4 = { col[0], col[1], col[2], (flags & ImGuiColorEditFlags_.ImGuiColorEditFlags_NoAlpha) != {} ? 1.0 : col[3] }
	cr : i32 = IM_F32_TO_INT8_SAT(col[0]); cg : i32 = IM_F32_TO_INT8_SAT(col[1]); cb : i32 = IM_F32_TO_INT8_SAT(col[2]); ca : i32 = (flags & ImGuiColorEditFlags_.ImGuiColorEditFlags_NoAlpha) != {} ? 255 : IM_F32_TO_INT8_SAT(col[3])
	ColorButton("##preview", cf, (flags & (ImGuiColorEditFlags_.ImGuiColorEditFlags_InputMask_ | ImGuiColorEditFlags_.ImGuiColorEditFlags_NoAlpha | ImGuiColorEditFlags_.ImGuiColorEditFlags_AlphaPreview | ImGuiColorEditFlags_.ImGuiColorEditFlags_AlphaPreviewHalf)) | ImGuiColorEditFlags_.ImGuiColorEditFlags_NoTooltip, sz)
	SameLine()
	if (flags & ImGuiColorEditFlags_.ImGuiColorEditFlags_InputRGB) != {} || (flags & ImGuiColorEditFlags_.ImGuiColorEditFlags_InputMask_) == {} {
		if (flags & ImGuiColorEditFlags_.ImGuiColorEditFlags_NoAlpha) != {} { Text("#%02X%02X%02X\nR: %d, G: %d, B: %d\n(%.3f, %.3f, %.3f)", cr, cg, cb, cr, cg, cb, col[0], col[1], col[2]) }
		else { Text("#%02X%02X%02X%02X\nR:%d, G:%d, B:%d, A:%d\n(%.3f, %.3f, %.3f, %.3f)", cr, cg, cb, ca, cr, cg, cb, ca, col[0], col[1], col[2], col[3]) }
	}
	else if (flags & ImGuiColorEditFlags_.ImGuiColorEditFlags_InputHSV) != {} {
		if (flags & ImGuiColorEditFlags_.ImGuiColorEditFlags_NoAlpha) != {} { Text("H: %.3f, S: %.3f, V: %.3f", col[0], col[1], col[2]) }
		else { Text("H: %.3f, S: %.3f, V: %.3f, A: %.3f", col[0], col[1], col[2], col[3]) }
	}
	EndTooltip()
}

ColorEditOptionsPopup :: proc(col : ^[4]f32, flags : ImGuiColorEditFlags)
{
	allow_opt_inputs : bool = (flags & ImGuiColorEditFlags_.ImGuiColorEditFlags_DisplayMask_) == {}
	allow_opt_datatype : bool = (flags & ImGuiColorEditFlags_.ImGuiColorEditFlags_DataTypeMask_) == {}
	if (!allow_opt_inputs && !allow_opt_datatype) || !BeginPopup("context") { return }

	g : ^ImGuiContext = GImGui
	PushItemFlag(cast(ImGuiItemFlags)ImGuiItemFlagsPrivate_.ImGuiItemFlags_NoMarkEdited, true)
	opts : ImGuiColorEditFlags = g.ColorEditOptions
	if allow_opt_inputs {
		if RadioButton("RGB", (opts & ImGuiColorEditFlags_.ImGuiColorEditFlags_DisplayRGB) != {}) { opts = (opts & cast(ImGuiColorEditFlags)~cast(i32)ImGuiColorEditFlags_.ImGuiColorEditFlags_DisplayMask_) | ImGuiColorEditFlags_.ImGuiColorEditFlags_DisplayRGB }
		if RadioButton("HSV", (opts & ImGuiColorEditFlags_.ImGuiColorEditFlags_DisplayHSV) != {}) { opts = (opts & cast(ImGuiColorEditFlags)~cast(i32)ImGuiColorEditFlags_.ImGuiColorEditFlags_DisplayMask_) | ImGuiColorEditFlags_.ImGuiColorEditFlags_DisplayHSV }
		if RadioButton("Hex", (opts & ImGuiColorEditFlags_.ImGuiColorEditFlags_DisplayHex) != {}) { opts = (opts & cast(ImGuiColorEditFlags)~cast(i32)ImGuiColorEditFlags_.ImGuiColorEditFlags_DisplayMask_) | ImGuiColorEditFlags_.ImGuiColorEditFlags_DisplayHex }
	}
	if allow_opt_datatype {
		if allow_opt_inputs { Separator() }
		if RadioButton("0..255", (opts & ImGuiColorEditFlags_.ImGuiColorEditFlags_Uint8) != {}) { opts = (opts & cast(ImGuiColorEditFlags)~cast(i32)ImGuiColorEditFlags_.ImGuiColorEditFlags_DataTypeMask_) | ImGuiColorEditFlags_.ImGuiColorEditFlags_Uint8 }
		if RadioButton("0.00..1.00", (opts & ImGuiColorEditFlags_.ImGuiColorEditFlags_Float) != {}) { opts = (opts & cast(ImGuiColorEditFlags)~cast(i32)ImGuiColorEditFlags_.ImGuiColorEditFlags_DataTypeMask_) | ImGuiColorEditFlags_.ImGuiColorEditFlags_Float }
	}

	if allow_opt_inputs || allow_opt_datatype { Separator() }
	if Button("Copy as..", ImVec2{-1, 0}) { OpenPopup("Copy") }
	if BeginPopup("Copy") {
		cr : i32 = IM_F32_TO_INT8_SAT(col[0]); cg : i32 = IM_F32_TO_INT8_SAT(col[1]); cb : i32 = IM_F32_TO_INT8_SAT(col[2]); ca : i32 = (flags & ImGuiColorEditFlags_.ImGuiColorEditFlags_NoAlpha) != {} ? 255 : IM_F32_TO_INT8_SAT(col[3])
		buf : [64]u8; buf_str : string; l : i32
		l = ImFormatString(buf[:], "(%.3ff, %.3ff, %.3ff, %.3ff)", col[0], col[1], col[2], (flags & ImGuiColorEditFlags_.ImGuiColorEditFlags_NoAlpha) != {} ? 1.0 : col[3]); buf_str = string_from_slice(buf[:l], false)
		if Selectable(buf_str) { SetClipboardText(buf_str) }
		l = ImFormatString(buf[:], "(%d,%d,%d,%d)", cr, cg, cb, ca); buf_str = string_from_slice(buf[:l], false)
		if Selectable(buf_str) { SetClipboardText(buf_str) }
		l = ImFormatString(buf[:], "#%02X%02X%02X", cr, cg, cb); buf_str = string_from_slice(buf[:l], false)
		if Selectable(buf_str) { SetClipboardText(buf_str) }
		if (flags & ImGuiColorEditFlags_.ImGuiColorEditFlags_NoAlpha) == {} {
			l = ImFormatString(buf[:], "#%02X%02X%02X%02X", cr, cg, cb, ca); buf_str = string_from_slice(buf[:l], false)
			if Selectable(buf_str) { SetClipboardText(buf_str) }
		}
		EndPopup()
	}

	g.ColorEditOptions = opts
	PopItemFlag()
	EndPopup()
}

ColorPickerOptionsPopup :: proc(ref_col : ^[4]f32, flags : ImGuiColorEditFlags)
{
	allow_opt_picker : bool = (flags & ImGuiColorEditFlags_.ImGuiColorEditFlags_PickerMask_) == {}
	allow_opt_alpha_bar : bool = (flags & ImGuiColorEditFlags_.ImGuiColorEditFlags_NoAlpha) == {} && (flags & ImGuiColorEditFlags_.ImGuiColorEditFlags_AlphaBar) == {}
	if (!allow_opt_picker && !allow_opt_alpha_bar) || !BeginPopup("context") { return }

	g : ^ImGuiContext = GImGui
	PushItemFlag(cast(ImGuiItemFlags)ImGuiItemFlagsPrivate_.ImGuiItemFlags_NoMarkEdited, true)
	if allow_opt_picker {
		picker_size : ImVec2 = { g.FontSize * 8, ImMax(g.FontSize * 8 - (GetFrameHeight() + g.Style.ItemInnerSpacing.x), 1.0) }; // FIXME: Picker size copied from main picker function
		PushItemWidth(picker_size.x)
		for picker_type : i32 = 0; picker_type < 2; picker_type += 1 {
			// Draw small/thumbnail version of each picker type (over an invisible button for selection)
			if picker_type > 0 { Separator() }
			PushID(picker_type)
			picker_flags : ImGuiColorEditFlags = ImGuiColorEditFlags_.ImGuiColorEditFlags_NoInputs | ImGuiColorEditFlags_.ImGuiColorEditFlags_NoOptions | ImGuiColorEditFlags_.ImGuiColorEditFlags_NoLabel | ImGuiColorEditFlags_.ImGuiColorEditFlags_NoSidePreview | (flags & ImGuiColorEditFlags_.ImGuiColorEditFlags_NoAlpha)
			if picker_type == 0 { picker_flags |= ImGuiColorEditFlags_.ImGuiColorEditFlags_PickerHueBar }
			if picker_type == 1 { picker_flags |= ImGuiColorEditFlags_.ImGuiColorEditFlags_PickerHueWheel }
			backup_pos : ImVec2 = GetCursorScreenPos()
			if Selectable("##selectable", false, {}, picker_size) {
				// By default, Selectable() is closing popup
				g.ColorEditOptions = (g.ColorEditOptions & cast(ImGuiColorEditFlags)~cast(i32)ImGuiColorEditFlags_.ImGuiColorEditFlags_PickerMask_) | (picker_flags & ImGuiColorEditFlags_.ImGuiColorEditFlags_PickerMask_)
			}
			SetCursorScreenPos(backup_pos)
			previewing_ref_col : ImVec4
			memcpy(&previewing_ref_col, ref_col, size_of(f32) * ((picker_flags & ImGuiColorEditFlags_.ImGuiColorEditFlags_NoAlpha) != {} ? 3 : 4))
			ColorPicker4("##previewing_picker", &previewing_ref_col, picker_flags)
			PopID()
		}

		PopItemWidth()
	}
	if allow_opt_alpha_bar {
		if allow_opt_picker { Separator() }
		CheckboxFlags("Alpha Bar", &g.ColorEditOptions, ImGuiColorEditFlags_.ImGuiColorEditFlags_AlphaBar)
	}
	PopItemFlag()
	EndPopup()
}

//-------------------------------------------------------------------------
// [SECTION] Widgets: TreeNode, CollapsingHeader, etc.
//-------------------------------------------------------------------------
// - TreeNode()
// - TreeNodeV()
// - TreeNodeEx()
// - TreeNodeExV()
// - TreeNodeBehavior() [Internal]
// - TreePush()
// - TreePop()
// - GetTreeNodeToLabelSpacing()
// - SetNextItemOpen()
// - CollapsingHeader()
//-------------------------------------------------------------------------

TreeNode_s :: proc(str_id : string, fmt : string, args : ..any) -> bool
{
	return TreeNodeEx(str_id, {}, fmt, args)
}

TreeNode_p :: proc(ptr_id : rawptr, fmt : string, args : ..any) -> bool
{
	return TreeNodeEx(ptr_id, {}, fmt, args)
}

TreeNode_b :: proc(label : string) -> bool
{
	window : ^ImGuiWindow = GetCurrentWindow()
	if window.SkipItems { return false }
	id : ImGuiID = GetID(window, label)
	return TreeNodeBehavior(id, ImGuiTreeNodeFlags_.ImGuiTreeNodeFlags_None, label)
}

TreeNodeEx_b :: proc(label : string, flags : ImGuiTreeNodeFlags) -> bool
{
	window : ^ImGuiWindow = GetCurrentWindow()
	if window.SkipItems { return false }
	id : ImGuiID = GetID(window, label)
	return TreeNodeBehavior(id, flags, label)
}

TreeNodeEx_s :: proc(str_id : string, flags : ImGuiTreeNodeFlags, fmt : string, args : ..any) -> bool
{
	window : ^ImGuiWindow = GetCurrentWindow()
	if window.SkipItems { return false }

	id : ImGuiID = GetID(window, raw_data(str_id))
	label : [^]u8; label_end : ^u8
	ImFormatStringToTempBufferV(&label, &label_end, fmt, args)
	return TreeNodeBehavior(id, flags, string_from_se(label, label_end), false)
}

TreeNodeEx_p :: proc(ptr_id : rawptr, flags : ImGuiTreeNodeFlags, fmt : string, args : ..any) -> bool
{
	window : ^ImGuiWindow = GetCurrentWindow()
	if window.SkipItems { return false }

	id : ImGuiID = GetID(window, ptr_id)
	label : [^]u8; label_end : ^u8
	ImFormatStringToTempBufferV(&label, &label_end, fmt, args)
	return TreeNodeBehavior(id, flags, string_from_se(label, label_end), false)
}

TreeNodeGetOpen :: proc(storage_id : ImGuiID) -> bool
{
	g : ^ImGuiContext = GImGui
	storage : ^ImGuiStorage = g.CurrentWindow.DC.StateStorage
	return GetInt(storage, storage_id, 0) != 0
}

TreeNodeSetOpen :: proc(storage_id : ImGuiID, open : bool)
{
	g : ^ImGuiContext = GImGui
	storage : ^ImGuiStorage = g.CurrentWindow.DC.StateStorage
	SetInt(storage, storage_id, open ? 1 : 0)
}

TreeNodeUpdateNextOpen :: proc(storage_id : ImGuiID, flags : ImGuiTreeNodeFlags) -> bool
{
	if (flags & ImGuiTreeNodeFlags_.ImGuiTreeNodeFlags_Leaf) != {} { return true }

	// We only write to the tree storage if the user clicks, or explicitly use the SetNextItemOpen function
	g : ^ImGuiContext = GImGui
	window : ^ImGuiWindow = g.CurrentWindow
	storage : ^ImGuiStorage = window.DC.StateStorage

	is_open : bool
	if (g.NextItemData.HasFlags & ImGuiNextItemDataFlags_.ImGuiNextItemDataFlags_HasOpen) != {} {
		if (cast(ImGuiCond)g.NextItemData.OpenCond & ImGuiCond_.ImGuiCond_Always) != {} {
			is_open = g.NextItemData.OpenVal
			TreeNodeSetOpen(storage_id, is_open)
		}
		else {
			// We treat ImGuiCond_Once and ImGuiCond_FirstUseEver the same because tree node state are not saved persistently.
			stored_value : i32 = GetInt(storage, storage_id, -1)
			if stored_value == -1 {
				is_open = g.NextItemData.OpenVal
				TreeNodeSetOpen(storage_id, is_open)
			}
			else {
				is_open = stored_value != 0
			}
		}
	}
	else {
		is_open = GetInt(storage, storage_id, (flags & ImGuiTreeNodeFlags_.ImGuiTreeNodeFlags_DefaultOpen) != {} ? 1 : 0) != 0
	}

	// When logging is enabled, we automatically expand tree nodes (but *NOT* collapsing headers.. seems like sensible behavior).
	// NB- If we are above max depth we still allow manually opened nodes to be logged.
	if g.LogEnabled && (flags & ImGuiTreeNodeFlags_.ImGuiTreeNodeFlags_NoAutoOpenOnLog) == {} && (window.DC.TreeDepth - g.LogDepthRef) < g.LogDepthToExpand { is_open = true }

	return is_open
}

// Store ImGuiTreeNodeStackData for just submitted node.
// Currently only supports 32 level deep and we are fine with (1 << Depth) overflowing into a zero, easy to increase.
TreeNodeStoreStackData :: proc(flags : ImGuiTreeNodeFlags)
{
	g : ^ImGuiContext = GImGui
	window : ^ImGuiWindow = g.CurrentWindow

	resize(&g.TreeNodeStack, g.TreeNodeStack.Size + 1)
	tree_node_data : ^ImGuiTreeNodeStackData = back(&g.TreeNodeStack)
	tree_node_data.ID = g.LastItemData.ID
	tree_node_data.TreeFlags = flags
	tree_node_data.ItemFlags = g.LastItemData.ItemFlags
	tree_node_data.NavRect = g.LastItemData.NavRect
	window.DC.TreeHasStackDataDepthMask |= (1 << cast(u32)window.DC.TreeDepth)
}

// When using public API, currently 'id == storage_id' is always true, but we separate the values to facilitate advanced user code doing storage queries outside of UI loop.

TreeNodeBehavior :: proc(id : ImGuiID, flags : ImGuiTreeNodeFlags, label : string, hide_label_after_double_hash: bool = true) -> bool
{
	window : ^ImGuiWindow = GetCurrentWindow()
	if window.SkipItems { return false }

	g : ^ImGuiContext = GImGui
	style : ^ImGuiStyle = &g.Style
	display_frame : bool = (flags & ImGuiTreeNodeFlags_.ImGuiTreeNodeFlags_Framed) != {}
	padding : ImVec2 = (display_frame || (flags & ImGuiTreeNodeFlags_.ImGuiTreeNodeFlags_FramePadding) != {}) ? style.FramePadding : ImVec2{style.FramePadding.x, ImMin(window.DC.CurrLineTextBaseOffset, style.FramePadding.y)}

	label_vis := hide_label_after_double_hash ? label[:FindRenderedTextEnd(label)] : label
	label_size : ImVec2 = CalcTextSize(label_vis, false)

	text_offset_x : f32 = g.FontSize + (display_frame ? padding.x * 3 : padding.x * 2); // Collapsing arrow width + Spacing
	text_offset_y : f32 = ImMax(padding.y, window.DC.CurrLineTextBaseOffset); // Latch before ItemSize changes it
	text_width : f32 = g.FontSize + label_size.x + padding.x * 2; // Include collapsing arrow

	// We vertically grow up to current line height up the typical widget height.
	frame_height : f32 = ImMax(ImMin(window.DC.CurrLineSize.y, g.FontSize + style.FramePadding.y * 2), label_size.y + padding.y * 2)
	span_all_columns : bool = (flags & ImGuiTreeNodeFlags_.ImGuiTreeNodeFlags_SpanAllColumns) != {} && (g.CurrentTable != nil)
	frame_bb : ImRect
	frame_bb.Min.x = span_all_columns ? window.ParentWorkRect.Min.x : (flags & ImGuiTreeNodeFlags_.ImGuiTreeNodeFlags_SpanFullWidth) != {} ? window.WorkRect.Min.x : window.DC.CursorPos.x
	frame_bb.Min.y = window.DC.CursorPos.y
	frame_bb.Max.x = span_all_columns ? window.ParentWorkRect.Max.x : (flags & ImGuiTreeNodeFlags_.ImGuiTreeNodeFlags_SpanTextWidth) != {} ? window.DC.CursorPos.x + text_width + padding.x : window.WorkRect.Max.x
	frame_bb.Max.y = window.DC.CursorPos.y + frame_height
	if display_frame {
		outer_extend : f32 = IM_TRUNC(window.WindowPadding.x * 0.5); // Framed header expand a little outside of current limits
		frame_bb.Min.x -= outer_extend
		frame_bb.Max.x += outer_extend
	}

	text_pos := ImVec2{window.DC.CursorPos.x + text_offset_x, window.DC.CursorPos.y + text_offset_y}
	ItemSize(ImVec2{text_width, frame_height}, padding.y)

	// For regular tree nodes, we arbitrary allow to click past 2 worth of ItemSpacing
	interact_bb : ImRect = frame_bb
	if (flags & (ImGuiTreeNodeFlags_.ImGuiTreeNodeFlags_Framed | ImGuiTreeNodeFlags_.ImGuiTreeNodeFlags_SpanAvailWidth | ImGuiTreeNodeFlags_.ImGuiTreeNodeFlags_SpanFullWidth | ImGuiTreeNodeFlags_.ImGuiTreeNodeFlags_SpanTextWidth | ImGuiTreeNodeFlags_.ImGuiTreeNodeFlags_SpanAllColumns)) == {} { interact_bb.Max.x = frame_bb.Min.x + text_width + (label_size.x > 0.0 ? style.ItemSpacing.x * 2.0 : 0.0) }

	// Compute open and multi-select states before ItemAdd() as it clear NextItem data.
	storage_id : ImGuiID = (g.NextItemData.HasFlags & ImGuiNextItemDataFlags_.ImGuiNextItemDataFlags_HasStorageID) != {} ? g.NextItemData.StorageId : id
	is_open : bool = TreeNodeUpdateNextOpen(storage_id, flags)

	is_visible : bool
	if span_all_columns {
		// Modify ClipRect for the ItemAdd(), faster than doing a PushColumnsBackground/PushTableBackgroundChannel for every Selectable..
		backup_clip_rect_min_x : f32 = window.ClipRect.Min.x
		backup_clip_rect_max_x : f32 = window.ClipRect.Max.x
		window.ClipRect.Min.x = window.ParentWorkRect.Min.x
		window.ClipRect.Max.x = window.ParentWorkRect.Max.x
		is_visible = ItemAdd(interact_bb, id)
		window.ClipRect.Min.x = backup_clip_rect_min_x
		window.ClipRect.Max.x = backup_clip_rect_max_x
	}
	else {
		is_visible = ItemAdd(interact_bb, id)
	}
	g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_.ImGuiItemStatusFlags_HasDisplayRect
	g.LastItemData.DisplayRect = frame_bb

	// If a NavLeft request is happening and ImGuiTreeNodeFlags_NavLeftJumpsBackHere enabled:
	// Store data for the current depth to allow returning to this node from any child item.
	// For this purpose we essentially compare if g.NavIdIsAlive went from 0 to 1 between TreeNode() and TreePop().
	// It will become tempting to enable ImGuiTreeNodeFlags_NavLeftJumpsBackHere by default or move it to ImGuiStyle.
	store_tree_node_stack_data : bool = false
	if (flags & ImGuiTreeNodeFlags_.ImGuiTreeNodeFlags_NoTreePushOnOpen) == {} {
		if (flags & ImGuiTreeNodeFlags_.ImGuiTreeNodeFlags_NavLeftJumpsBackHere) != {} && is_open && !g.NavIdIsAlive { if g.NavMoveDir == ImGuiDir.ImGuiDir_Left && g.NavWindow == window && NavMoveRequestButNoResultYet() { store_tree_node_stack_data = true } }
	}

	is_leaf : bool = (flags & ImGuiTreeNodeFlags_.ImGuiTreeNodeFlags_Leaf) != {}
	if !is_visible {
		if store_tree_node_stack_data && is_open {
			// Call before TreePushOverrideID()
			TreeNodeStoreStackData(flags)
		}
		if is_open && (flags & ImGuiTreeNodeFlags_.ImGuiTreeNodeFlags_NoTreePushOnOpen) == {} { TreePushOverrideID(id) }
		when IMGUI_ENABLE_TEST_ENGINE {
			if(g.TestEngineHookItems) {
				ImGuiTestEngineHook_ItemInfo(g, g.LastItemData.ID, label, g.LastItemData.StatusFlags | (is_leaf ? 0 : ImGuiItemStatusFlags_.ImGuiItemStatusFlags_Openable) | (is_open ? ImGuiItemStatusFlags_.ImGuiItemStatusFlags_Opened : {}))
			}
		}
		return is_open
	}

	if span_all_columns {
		TablePushBackgroundChannel()
		g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_.ImGuiItemStatusFlags_HasClipRect
		g.LastItemData.ClipRect = window.ClipRect
	}

	button_flags : ImGuiButtonFlags = ImGuiButtonFlags.ImGuiButtonFlags_None
	if (flags & ImGuiTreeNodeFlags_.ImGuiTreeNodeFlags_AllowOverlap) != {} || (g.LastItemData.ItemFlags & cast(ImGuiItemFlags) ImGuiItemFlagsPrivate_.ImGuiItemFlags_AllowOverlap) != {} { button_flags |= cast(ImGuiButtonFlags) ImGuiButtonFlagsPrivate_.ImGuiButtonFlags_AllowOverlap }
	if !is_leaf { button_flags |= cast(ImGuiButtonFlags) ImGuiButtonFlagsPrivate_.ImGuiButtonFlags_PressedOnDragDropHold }

	// We allow clicking on the arrow section with keyboard modifiers held, in order to easily
	// allow browsing a tree while preserving selection with code implementing multi-selection patterns.
	// When clicking on the rest of the tree node we always disallow keyboard modifiers.
	arrow_hit_x1 : f32 = (text_pos.x - text_offset_x) - style.TouchExtraPadding.x
	arrow_hit_x2 : f32 = (text_pos.x - text_offset_x) + (g.FontSize + padding.x * 2.0) + style.TouchExtraPadding.x
	is_mouse_x_over_arrow : bool = (g.IO.MousePos.x >= arrow_hit_x1 && g.IO.MousePos.x < arrow_hit_x2)

	is_multi_select : bool = (g.LastItemData.ItemFlags & cast(ImGuiItemFlags) ImGuiItemFlagsPrivate_.ImGuiItemFlags_IsMultiSelect) != {}
	flags := flags
	if is_multi_select {
		// We absolutely need to distinguish open vs select so _OpenOnArrow comes by default
		flags |= (flags & cast(ImGuiTreeNodeFlags) ImGuiTreeNodeFlagsPrivate_.ImGuiTreeNodeFlags_OpenOnMask_) == {} ? ImGuiTreeNodeFlags_.ImGuiTreeNodeFlags_OpenOnArrow | ImGuiTreeNodeFlags_.ImGuiTreeNodeFlags_OpenOnDoubleClick : ImGuiTreeNodeFlags_.ImGuiTreeNodeFlags_OpenOnArrow
	}

	// Open behaviors can be altered with the _OpenOnArrow and _OnOnDoubleClick flags.
	// Some alteration have subtle effects (e.g. toggle on MouseUp vs MouseDown events) due to requirements for multi-selection and drag and drop support.
	// - Single-click on label = Toggle on MouseUp (default, when _OpenOnArrow=0)
	// - Single-click on arrow = Toggle on MouseDown (when _OpenOnArrow=0)
	// - Single-click on arrow = Toggle on MouseDown (when _OpenOnArrow=1)
	// - Double-click on label = Toggle on MouseDoubleClick (when _OpenOnDoubleClick=1)
	// - Double-click on arrow = Toggle on MouseDoubleClick (when _OpenOnDoubleClick=1 and _OpenOnArrow=0)
	// It is rather standard that arrow click react on Down rather than Up.
	// We set ImGuiButtonFlags_PressedOnClickRelease on OpenOnDoubleClick because we want the item to be active on the initial MouseDown in order for drag and drop to work.
	if is_mouse_x_over_arrow { button_flags |= cast(ImGuiButtonFlags) ImGuiButtonFlagsPrivate_.ImGuiButtonFlags_PressedOnClick }
	else if (flags & ImGuiTreeNodeFlags_.ImGuiTreeNodeFlags_OpenOnDoubleClick) != {} { button_flags |= cast(ImGuiButtonFlags) ImGuiButtonFlagsPrivate_.ImGuiButtonFlags_PressedOnClickRelease | cast(ImGuiButtonFlags) ImGuiButtonFlagsPrivate_.ImGuiButtonFlags_PressedOnDoubleClick }
	else { button_flags |= cast(ImGuiButtonFlags) ImGuiButtonFlagsPrivate_.ImGuiButtonFlags_PressedOnClickRelease }

	selected : bool = (flags & ImGuiTreeNodeFlags_.ImGuiTreeNodeFlags_Selected) != {}
	was_selected : bool = selected

	// Multi-selection support (header)
	if is_multi_select {
		// Handle multi-select + alter button flags for it
		MultiSelectItemHeader(id, &selected, &button_flags)
		if is_mouse_x_over_arrow { button_flags = (button_flags | cast(ImGuiButtonFlags) ImGuiButtonFlagsPrivate_.ImGuiButtonFlags_PressedOnClick) & cast(ImGuiButtonFlags) ~cast(i32)ImGuiButtonFlagsPrivate_.ImGuiButtonFlags_PressedOnClickRelease }
	}
	else {
		if window != g.HoveredWindow || !is_mouse_x_over_arrow { button_flags |= cast(ImGuiButtonFlags) ImGuiButtonFlagsPrivate_.ImGuiButtonFlags_NoKeyModsAllowed }
	}

	hovered : bool; held : bool
	pressed : bool = ButtonBehavior(interact_bb, id, &hovered, &held, button_flags)
	toggled : bool = false
	if !is_leaf {
		if pressed && g.DragDropHoldJustPressedId != id {
			if (flags & cast(ImGuiTreeNodeFlags) ImGuiTreeNodeFlagsPrivate_.ImGuiTreeNodeFlags_OpenOnMask_) == {} || (g.NavActivateId == id && !is_multi_select) {
				// Single click
				toggled = true
			}
			if (flags & ImGuiTreeNodeFlags_.ImGuiTreeNodeFlags_OpenOnArrow) != {} {
				// Lightweight equivalent of IsMouseHoveringRect() since ButtonBehavior() already did the job
				toggled |= is_mouse_x_over_arrow && !g.NavHighlightItemUnderNav
			}
			if (flags & ImGuiTreeNodeFlags_.ImGuiTreeNodeFlags_OpenOnDoubleClick) != {} && g.IO.MouseClickedCount[0] == 2 {
				// Double click
				toggled = true
			}
		}
		else if pressed && g.DragDropHoldJustPressedId == id {
			IM_ASSERT((button_flags & cast(ImGuiButtonFlags) ImGuiButtonFlagsPrivate_.ImGuiButtonFlags_PressedOnDragDropHold) != {})
			if !is_open {
				// When using Drag and Drop "hold to open" we keep the node highlighted after opening, but never close it again.
				toggled = true
			}
			else {
				// Cancel press so it doesn't trigger selection.
				pressed = false
			}
		}

		if g.NavId == id && g.NavMoveDir == ImGuiDir.ImGuiDir_Left && is_open {
			toggled = true
			NavClearPreferredPosForAxis(ImGuiAxis.ImGuiAxis_X)
			NavMoveRequestCancel()
		}
		if g.NavId == id && g.NavMoveDir == ImGuiDir.ImGuiDir_Right && !is_open {
			// If there's something upcoming on the line we may want to give it the priority?
			toggled = true
			NavClearPreferredPosForAxis(ImGuiAxis.ImGuiAxis_X)
			NavMoveRequestCancel()
		}

		if toggled {
			is_open = !is_open
			SetInt(window.DC.StateStorage, storage_id, is_open ? 1 : 0)
			g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_.ImGuiItemStatusFlags_ToggledOpen
		}
	}

	// Multi-selection support (footer)
	if is_multi_select {
		pressed_copy : bool = pressed && !toggled
		MultiSelectItemFooter(id, &selected, &pressed_copy)
		if pressed { SetNavID(id, window.DC.NavLayerCurrent, g.CurrentFocusScopeId, interact_bb) }
	}

	if selected != was_selected { g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_.ImGuiItemStatusFlags_ToggledSelection }

	// Render
	{
	text_col : ImU32 = GetColorU32(ImGuiCol_.ImGuiCol_Text)
	nav_render_cursor_flags : ImGuiNavRenderCursorFlags = ImGuiNavRenderCursorFlags_.ImGuiNavRenderCursorFlags_Compact
	if is_multi_select {
		// Always show the nav rectangle
		nav_render_cursor_flags |= ImGuiNavRenderCursorFlags_.ImGuiNavRenderCursorFlags_AlwaysDraw
	}
	if display_frame {
		// Framed type
		bg_col : ImU32 = GetColorU32((held && hovered) ? ImGuiCol_.ImGuiCol_HeaderActive : hovered ? ImGuiCol_.ImGuiCol_HeaderHovered : ImGuiCol_.ImGuiCol_Header)
		RenderFrame(frame_bb.Min, frame_bb.Max, bg_col, true, style.FrameRounding)
		RenderNavCursor(frame_bb, id, nav_render_cursor_flags)
		if (flags & ImGuiTreeNodeFlags_.ImGuiTreeNodeFlags_Bullet) != {} { RenderBullet(window.DrawList, ImVec2{text_pos.x - text_offset_x * 0.60, text_pos.y + g.FontSize * 0.5}, text_col) }
		else if !is_leaf { RenderArrow(window.DrawList, ImVec2{text_pos.x - text_offset_x + padding.x, text_pos.y}, text_col, is_open ? ((flags & cast(ImGuiTreeNodeFlags) ImGuiTreeNodeFlagsPrivate_.ImGuiTreeNodeFlags_UpsideDownArrow) != {} ? ImGuiDir.ImGuiDir_Up : ImGuiDir.ImGuiDir_Down) : ImGuiDir.ImGuiDir_Right, 1.0) }
		else { text_pos.x -= text_offset_x - padding.x }
		if (flags & cast(ImGuiTreeNodeFlags) ImGuiTreeNodeFlagsPrivate_.ImGuiTreeNodeFlags_ClipLabelForTrailingButton) != {} { frame_bb.Max.x -= g.FontSize + style.FramePadding.x }
		if g.LogEnabled { LogSetNextTextDecoration("###", "###") }
	}
	else {
		// Unframed typed for tree nodes
		if hovered || selected {
			bg_col : ImU32 = GetColorU32((held && hovered) ? ImGuiCol_.ImGuiCol_HeaderActive : hovered ? ImGuiCol_.ImGuiCol_HeaderHovered : ImGuiCol_.ImGuiCol_Header)
			RenderFrame(frame_bb.Min, frame_bb.Max, bg_col, false)
		}
		RenderNavCursor(frame_bb, id, nav_render_cursor_flags)
		if (flags & ImGuiTreeNodeFlags_.ImGuiTreeNodeFlags_Bullet) != {} { RenderBullet(window.DrawList, ImVec2{text_pos.x - text_offset_x * 0.5, text_pos.y + g.FontSize * 0.5}, text_col) }
		else if !is_leaf { RenderArrow(window.DrawList, ImVec2{text_pos.x - text_offset_x + padding.x, text_pos.y + g.FontSize * 0.15}, text_col, is_open ? ((flags & cast(ImGuiTreeNodeFlags) ImGuiTreeNodeFlagsPrivate_.ImGuiTreeNodeFlags_UpsideDownArrow) != {} ? ImGuiDir.ImGuiDir_Up : ImGuiDir.ImGuiDir_Down) : ImGuiDir.ImGuiDir_Right, 0.70) }
		if g.LogEnabled { LogSetNextTextDecoration(">", "") }
	}

	if span_all_columns { TablePopBackgroundChannel() }

	// Label
	if display_frame { RenderTextClipped(text_pos, frame_bb.Max, label, &label_size) }
	else { RenderText(text_pos, label, false) }
	}

	if store_tree_node_stack_data && is_open {
		// Call before TreePushOverrideID()
		TreeNodeStoreStackData(flags)
	}
	if is_open && (flags & ImGuiTreeNodeFlags_.ImGuiTreeNodeFlags_NoTreePushOnOpen) == {} {
		// Could use TreePush(label) but this avoid computing twice
		TreePushOverrideID(id)
	}

	when IMGUI_ENABLE_TEST_ENGINE {
		if(g.TestEngineHookItems) {
			ImGuiTestEngineHook_ItemInfo(g, label, g.LastItemData.StatusFlags | (is_leaf ? 0 : ImGuiItemStatusFlags_.ImGuiItemStatusFlags_Openable) | (is_open ? ImGuiItemStatusFlags_.ImGuiItemStatusFlags_Opened : {}))
		}
	}
	return is_open
}

TreePush_s :: proc(str_id : string)
{
	window : ^ImGuiWindow = GetCurrentWindow()
	Indent()
	post_incr(&window.DC.TreeDepth)
	PushID(str_id)
}

TreePush_p :: proc(ptr_id : rawptr)
{
	window : ^ImGuiWindow = GetCurrentWindow()
	Indent()
	post_incr(&window.DC.TreeDepth)
	PushID(ptr_id)
}

TreePushOverrideID :: proc(id : ImGuiID)
{
	g : ^ImGuiContext = GImGui
	window : ^ImGuiWindow = g.CurrentWindow
	Indent()
	post_incr(&window.DC.TreeDepth)
	PushOverrideID(id)
}

TreePop :: proc()
{
	g : ^ImGuiContext = GImGui
	window : ^ImGuiWindow = g.CurrentWindow
	Unindent()

	post_decr(&window.DC.TreeDepth)
	tree_depth_mask : ImU32 = (1 << cast(u32) window.DC.TreeDepth)

	if (window.DC.TreeHasStackDataDepthMask & tree_depth_mask) != 0 {
		// Only set during request
		data : ^ImGuiTreeNodeStackData = back(&g.TreeNodeStack)
		IM_ASSERT(data.ID == back(&window.IDStack)^)
		if (data.TreeFlags & ImGuiTreeNodeFlags_.ImGuiTreeNodeFlags_NavLeftJumpsBackHere) != {} {
			// Handle Left arrow to move to parent tree node (when ImGuiTreeNodeFlags_NavLeftJumpsBackHere is enabled)
			if g.NavIdIsAlive && g.NavMoveDir == ImGuiDir.ImGuiDir_Left && g.NavWindow == window && NavMoveRequestButNoResultYet() { NavMoveRequestResolveWithPastTreeNode(&g.NavMoveResultLocal, data) }
		}
		pop_back(&g.TreeNodeStack)
		window.DC.TreeHasStackDataDepthMask &= ~tree_depth_mask
	}

	IM_ASSERT(window.IDStack.Size > 1); // There should always be 1 element in the IDStack (pushed during window creation). If this triggers you called TreePop/PopID too much.
	PopID()
}

// Horizontal distance preceding label when using TreeNode() or Bullet()
GetTreeNodeToLabelSpacing :: proc() -> f32
{
	g : ^ImGuiContext = GImGui
	return g.FontSize + (g.Style.FramePadding.x * 2.0)
}

// Set next TreeNode/CollapsingHeader open state.
SetNextItemOpen :: proc(is_open : bool, cond : ImGuiCond)
{
	g : ^ImGuiContext = GImGui
	if g.CurrentWindow.SkipItems { return }
	g.NextItemData.HasFlags |= ImGuiNextItemDataFlags_.ImGuiNextItemDataFlags_HasOpen
	g.NextItemData.OpenVal = is_open
	g.NextItemData.OpenCond = cast(ImU8) (cond != {} ? cond : ImGuiCond_.ImGuiCond_Always)
}

// Set next TreeNode/CollapsingHeader storage id.
SetNextItemStorageID :: proc(storage_id : ImGuiID)
{
	g : ^ImGuiContext = GImGui
	if g.CurrentWindow.SkipItems { return }
	g.NextItemData.HasFlags |= ImGuiNextItemDataFlags_.ImGuiNextItemDataFlags_HasStorageID
	g.NextItemData.StorageId = storage_id
}

// CollapsingHeader returns true when opened but do not indent nor push into the ID stack (because of the ImGuiTreeNodeFlags_NoTreePushOnOpen flag).
// This is basically the same as calling TreeNodeEx(label, ImGuiTreeNodeFlags_CollapsingHeader). You can remove the _NoTreePushOnOpen flag if you want behavior closer to normal TreeNode().
CollapsingHeader_b :: proc(label : string, flags : ImGuiTreeNodeFlags) -> bool
{
	window : ^ImGuiWindow = GetCurrentWindow()
	if window.SkipItems { return false }
	id : ImGuiID = GetID(window, label)
	return TreeNodeBehavior(id, flags | ImGuiTreeNodeFlags_.ImGuiTreeNodeFlags_CollapsingHeader, label)
}

// p_visible == NULL                        : regular collapsing header
// p_visible != NULL && *p_visible == true  : show a small close button on the corner of the header, clicking the button will set *p_visible = false
// p_visible != NULL && *p_visible == false : do not show the header at all
// Do not mistake this with the Open state of the header itself, which you can adjust with SetNextItemOpen() or ImGuiTreeNodeFlags_DefaultOpen.
CollapsingHeader_v :: proc(label : string, p_visible : ^bool, flags : ImGuiTreeNodeFlags) -> bool
{
	window : ^ImGuiWindow = GetCurrentWindow()
	if window.SkipItems { return false }

	if p_visible != nil && !p_visible^ { return false }

	id : ImGuiID = GetID(window, label)
	flags := flags | ImGuiTreeNodeFlags_.ImGuiTreeNodeFlags_CollapsingHeader
	if p_visible != nil { flags |= ImGuiTreeNodeFlags_.ImGuiTreeNodeFlags_AllowOverlap | cast(ImGuiTreeNodeFlags) ImGuiTreeNodeFlagsPrivate_.ImGuiTreeNodeFlags_ClipLabelForTrailingButton }
	is_open : bool = TreeNodeBehavior(id, flags, label)
	if p_visible != nil {
		// Create a small overlapping close button
		// FIXME: We can evolve this into user accessible helpers to add extra buttons on title bars, headers, etc.
		// FIXME: CloseButton can overlap into text, need find a way to clip the text somehow.
		g : ^ImGuiContext = GImGui
		last_item_backup : ImGuiLastItemData = g.LastItemData
		button_size : f32 = g.FontSize
		button_x : f32 = ImMax(g.LastItemData.Rect.Min.x, g.LastItemData.Rect.Max.x - g.Style.FramePadding.x - button_size)
		button_y : f32 = g.LastItemData.Rect.Min.y + g.Style.FramePadding.y
		close_button_id : ImGuiID = GetIDWithSeed("#CLOSE", id)
		if CloseButton(close_button_id, ImVec2{button_x, button_y}) { p_visible^ = false }
		g.LastItemData = last_item_backup
	}

	return is_open
}

//-------------------------------------------------------------------------
// [SECTION] Widgets: Selectable
//-------------------------------------------------------------------------
// - Selectable()
//-------------------------------------------------------------------------

// Tip: pass a non-visible label (e.g. "##hello") then you can use the space to draw other text or image.
// But you need to make sure the ID is unique, e.g. enclose calls in PushID/PopID or use ##unique_id.
// With this scheme, ImGuiSelectableFlags_SpanAllColumns and ImGuiSelectableFlags_AllowOverlap are also frequently used flags.
// FIXME: Selectable() with (size.x == 0.0f) and (SelectableTextAlign.x > 0.0f) followed by SameLine() is currently not supported.
Selectable_0 :: proc(label : string, selected : bool = false, flags : ImGuiSelectableFlags = {}, size_arg : ImVec2 = {}) -> bool
{
	window : ^ImGuiWindow = GetCurrentWindow()
	if window.SkipItems { return false }

	g : ^ImGuiContext = GImGui
	style : ^ImGuiStyle = &g.Style

	// Submit label or explicit size to ItemSize(), whereas ItemAdd() will submit a larger/spanning rectangle.
	id : ImGuiID = GetID(window, label)
	label_size : ImVec2 = CalcTextSize(label, true)
	size : ImVec2 = { size_arg.x != 0.0 ? size_arg.x : label_size.x, size_arg.y != 0.0 ? size_arg.y : label_size.y }
	pos : ImVec2 = window.DC.CursorPos
	pos.y += window.DC.CurrLineTextBaseOffset
	ItemSize(size, 0.0)

	// Fill horizontal space
	// We don't support (size < 0.0f) in Selectable() because the ItemSpacing extension would make explicitly right-aligned sizes not visibly match other widgets.
	span_all_columns : bool = (flags & ImGuiSelectableFlags_.ImGuiSelectableFlags_SpanAllColumns) != {}
	min_x : f32 = span_all_columns ? window.ParentWorkRect.Min.x : pos.x
	max_x : f32 = span_all_columns ? window.ParentWorkRect.Max.x : window.WorkRect.Max.x
	if size_arg.x == 0.0 || (flags & cast(ImGuiSelectableFlags) ImGuiSelectableFlagsPrivate_.ImGuiSelectableFlags_SpanAvailWidth) != {} { size.x = ImMax(label_size.x, max_x - min_x) }

	// Text stays at the submission position, but bounding box may be extended on both sides
	text_min : ImVec2 = pos
	text_max := ImVec2 {min_x + size.x, pos.y + size.y}

	// Selectables are meant to be tightly packed together with no click-gap, so we extend their box to cover spacing between selectable.
	// FIXME: Not part of layout so not included in clipper calculation, but ItemSize currently doesn't allow offsetting CursorPos.
	bb : ImRect; init(&bb, min_x, pos.y, text_max.x, text_max.y)
	if (flags & cast(ImGuiSelectableFlags) ImGuiSelectableFlagsPrivate_.ImGuiSelectableFlags_NoPadWithHalfSpacing) == {} {
		spacing_x : f32 = span_all_columns ? 0.0 : style.ItemSpacing.x
		spacing_y : f32 = style.ItemSpacing.y
		spacing_L : f32 = IM_TRUNC(spacing_x * 0.50)
		spacing_U : f32 = IM_TRUNC(spacing_y * 0.50)
		bb.Min.x -= spacing_L
		bb.Min.y -= spacing_U
		bb.Max.x += (spacing_x - spacing_L)
		bb.Max.y += (spacing_y - spacing_U)
	}
	//if (g.IO.KeyCtrl) { GetForegroundDrawList()->AddRect(bb.Min, bb.Max, IM_COL32(0, 255, 0, 255)); }

	disabled_item : bool = (flags & ImGuiSelectableFlags_.ImGuiSelectableFlags_Disabled) != {}
	extra_item_flags : ImGuiItemFlags = disabled_item ? cast(ImGuiItemFlags) ImGuiItemFlagsPrivate_.ImGuiItemFlags_Disabled : ImGuiItemFlags_.ImGuiItemFlags_None
	is_visible : bool
	if span_all_columns {
		// Modify ClipRect for the ItemAdd(), faster than doing a PushColumnsBackground/PushTableBackgroundChannel for every Selectable..
		backup_clip_rect_min_x : f32 = window.ClipRect.Min.x
		backup_clip_rect_max_x : f32 = window.ClipRect.Max.x
		window.ClipRect.Min.x = window.ParentWorkRect.Min.x
		window.ClipRect.Max.x = window.ParentWorkRect.Max.x
		is_visible = ItemAdd(bb, id, nil, extra_item_flags)
		window.ClipRect.Min.x = backup_clip_rect_min_x
		window.ClipRect.Max.x = backup_clip_rect_max_x
	}
	else {
		is_visible = ItemAdd(bb, id, nil, extra_item_flags)
	}

	is_multi_select : bool = (g.LastItemData.ItemFlags & cast(ImGuiItemFlags) ImGuiItemFlagsPrivate_.ImGuiItemFlags_IsMultiSelect) != {}
	if !is_visible { if !is_multi_select || !g.BoxSelectState.UnclipMode || !Overlaps(g.BoxSelectState.UnclipRect, bb) {
	// Extra layer of "no logic clip" for box-select support (would be more overhead to add to ItemAdd)
	return false
} }

	disabled_global : bool = (g.CurrentItemFlags & cast(ImGuiItemFlags) ImGuiItemFlagsPrivate_.ImGuiItemFlags_Disabled) != {}
	if disabled_item && !disabled_global {
		// Only testing this as an optimization
		BeginDisabled()
	}

	// FIXME: We can standardize the behavior of those two, we could also keep the fast path of override ClipRect + full push on render only,
	// which would be advantageous since most selectable are not selected.
	if span_all_columns {
		if g.CurrentTable != nil { TablePushBackgroundChannel() }
		else if window.DC.CurrentColumns != nil { PushColumnsBackground() }
		g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_.ImGuiItemStatusFlags_HasClipRect
		g.LastItemData.ClipRect = window.ClipRect
	}

	// We use NoHoldingActiveID on menus so user can click and _hold_ on a menu then drag to browse child entries
	button_flags : ImGuiButtonFlags = {}
	if (flags & cast(ImGuiSelectableFlags) ImGuiSelectableFlagsPrivate_.ImGuiSelectableFlags_NoHoldingActiveID) != {} { button_flags |= cast(ImGuiButtonFlags) ImGuiButtonFlagsPrivate_.ImGuiButtonFlags_NoHoldingActiveId }
	if (flags & cast(ImGuiSelectableFlags) ImGuiSelectableFlagsPrivate_.ImGuiSelectableFlags_NoSetKeyOwner) != {} { button_flags |= cast(ImGuiButtonFlags) ImGuiButtonFlagsPrivate_.ImGuiButtonFlags_NoSetKeyOwner }
	if (flags & cast(ImGuiSelectableFlags) ImGuiSelectableFlagsPrivate_.ImGuiSelectableFlags_SelectOnClick) != {} { button_flags |= cast(ImGuiButtonFlags) ImGuiButtonFlagsPrivate_.ImGuiButtonFlags_PressedOnClick }
	if (flags & cast(ImGuiSelectableFlags) ImGuiSelectableFlagsPrivate_.ImGuiSelectableFlags_SelectOnRelease) != {} { button_flags |= cast(ImGuiButtonFlags) ImGuiButtonFlagsPrivate_.ImGuiButtonFlags_PressedOnRelease }
	if (flags & ImGuiSelectableFlags_.ImGuiSelectableFlags_AllowDoubleClick) != {} { button_flags |= cast(ImGuiButtonFlags) (ImGuiButtonFlagsPrivate_.ImGuiButtonFlags_PressedOnClickRelease | ImGuiButtonFlagsPrivate_.ImGuiButtonFlags_PressedOnDoubleClick) }
	if (flags & ImGuiSelectableFlags_.ImGuiSelectableFlags_AllowOverlap) != {} || (g.LastItemData.ItemFlags & cast(ImGuiItemFlags) ImGuiItemFlagsPrivate_.ImGuiItemFlags_AllowOverlap) != {} { button_flags |= cast(ImGuiButtonFlags) ImGuiButtonFlagsPrivate_.ImGuiButtonFlags_AllowOverlap }

	selected := selected

	// Multi-selection support (header)
	was_selected : bool = selected
	if is_multi_select {
		// Handle multi-select + alter button flags for it
		MultiSelectItemHeader(id, &selected, &button_flags)
	}

	hovered : bool; held : bool
	pressed : bool = ButtonBehavior(bb, id, &hovered, &held, button_flags)

	// Multi-selection support (footer)
	if is_multi_select {
		MultiSelectItemFooter(id, &selected, &pressed)
	}
	else {
		// Auto-select when moved into
		// - This will be more fully fleshed in the range-select branch
		// - This is not exposed as it won't nicely work with some user side handling of shift/control
		// - We cannot do 'if (g.NavJustMovedToId != id) { selected = false; pressed = was_selected; }' for two reasons
		//   - (1) it would require focus scope to be set, need exposing PushFocusScope() or equivalent (e.g. BeginSelection() calling PushFocusScope())
		//   - (2) usage will fail with clipped items
		//   The multi-select API aim to fix those issues, e.g. may be replaced with a BeginSelection() API.
		if (flags & cast(ImGuiSelectableFlags) ImGuiSelectableFlagsPrivate_.ImGuiSelectableFlags_SelectOnNav) != {} && g.NavJustMovedToId != 0 && g.NavJustMovedToFocusScopeId == g.CurrentFocusScopeId { if g.NavJustMovedToId == id { pressed = true; selected = pressed } }
	}

	// Update NavId when clicking or when Hovering (this doesn't happen on most widgets), so navigation can be resumed with keyboard/gamepad
	if pressed || (hovered && (flags & cast(ImGuiSelectableFlags) ImGuiSelectableFlagsPrivate_.ImGuiSelectableFlags_SetNavIdOnHover) != {}) {
		if !g.NavHighlightItemUnderNav && g.NavWindow == window && g.NavLayer == window.DC.NavLayerCurrent {
			SetNavID(id, window.DC.NavLayerCurrent, g.CurrentFocusScopeId, WindowRectAbsToRel(window, bb)); // (bb == NavRect)
			if g.IO.ConfigNavCursorVisibleAuto { g.NavCursorVisible = false }
		}
	}
	if pressed { MarkItemEdited(id) }

	if selected != was_selected { g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_.ImGuiItemStatusFlags_ToggledSelection }

	// Render
	if is_visible {
		highlighted : bool = hovered || (flags & ImGuiSelectableFlags_.ImGuiSelectableFlags_Highlight) != {}
		if highlighted || selected {
			// Between 1.91.0 and 1.91.4 we made selected Selectable use an arbitrary lerp between _Header and _HeaderHovered. Removed that now. (#8106)
			col : ImU32 = GetColorU32((held && highlighted) ? ImGuiCol_.ImGuiCol_HeaderActive : highlighted ? ImGuiCol_.ImGuiCol_HeaderHovered : ImGuiCol_.ImGuiCol_Header)
			RenderFrame(bb.Min, bb.Max, col, false, 0.0)
		}
		if g.NavId == id {
			nav_render_cursor_flags : ImGuiNavRenderCursorFlags = ImGuiNavRenderCursorFlags_.ImGuiNavRenderCursorFlags_Compact | ImGuiNavRenderCursorFlags_.ImGuiNavRenderCursorFlags_NoRounding
			if is_multi_select {
				// Always show the nav rectangle
				nav_render_cursor_flags |= ImGuiNavRenderCursorFlags_.ImGuiNavRenderCursorFlags_AlwaysDraw
			}
			RenderNavCursor(bb, id, nav_render_cursor_flags)
		}
	}

	if span_all_columns {
		if g.CurrentTable != nil { TablePopBackgroundChannel() }
		else if window.DC.CurrentColumns != nil { PopColumnsBackground() }
	}

	if is_visible { RenderTextClipped(text_min, text_max, label, &label_size, &style.SelectableTextAlign, &bb) }

	// Automatically close popups
	if pressed && (window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_Popup) != {} && (flags & ImGuiSelectableFlags_.ImGuiSelectableFlags_NoAutoClosePopups) == {} && (g.LastItemData.ItemFlags & ImGuiItemFlags_.ImGuiItemFlags_AutoClosePopups) != {} { CloseCurrentPopup() }

	if disabled_item && !disabled_global { EndDisabled() }

	// Selectable() always returns a pressed state!
	// Users of BeginMultiSelect()/EndMultiSelect() scope: you may call ImGui::IsItemToggledSelection() to retrieve
	// selection toggle, only useful if you need that state updated (e.g. for rendering purpose) before reaching EndMultiSelect().
	IMGUI_TEST_ENGINE_ITEM_INFO(g, id, label, g.LastItemData.StatusFlags)
	return pressed//-V1020
}

Selectable_1 :: proc(label : string, p_selected : ^bool, flags : ImGuiSelectableFlags = {}, size_arg : ImVec2 = {}) -> bool
{
	if Selectable(label, p_selected^, flags, size_arg) {
		p_selected^ = !p_selected^
		return true
	}
	return false
}


//-------------------------------------------------------------------------
// [SECTION] Widgets: Typing-Select support
//-------------------------------------------------------------------------

// [Experimental] Currently not exposed in public API.
// Consume character inputs and return search request, if any.
// This would typically only be called on the focused window or location you want to grab inputs for, e.g.
//   if (ImGui::IsWindowFocused(...))
//       if (ImGuiTypingSelectRequest* req = ImGui::GetTypingSelectRequest())
//           focus_idx = ImGui::TypingSelectFindMatch(req, my_items.size(), [](void*, int n) { return my_items[n]->Name; }, &my_items, -1);
// However the code is written in a way where calling it from multiple locations is safe (e.g. to obtain buffer).
GetTypingSelectRequest :: proc(flags : ImGuiTypingSelectFlags) -> ^ImGuiTypingSelectRequest
{
	g : ^ImGuiContext = GImGui
	data : ^ImGuiTypingSelectState = &g.TypingSelectState
	out_request : ^ImGuiTypingSelectRequest = &data.Request

	// Clear buffer
	TYPING_SELECT_RESET_TIMER : f32 = 1.80; // FIXME: Potentially move to IO config.
	TYPING_SELECT_SINGLE_CHAR_COUNT_FOR_LOCK : i32 = 4; // Lock single char matching when repeating same char 4 times
	if data.SearchBuffer[0] != 0 {
		clear_buffer : bool = false
		clear_buffer |= (g.NavFocusScopeId != data.FocusScope)
		clear_buffer |= (f64(data.LastRequestTime + TYPING_SELECT_RESET_TIMER) < g.Time)
		clear_buffer |= g.NavAnyRequest
		clear_buffer |= g.ActiveId != 0 && g.NavActivateId == 0; // Allow temporary SPACE activation to not interfere
		clear_buffer |= IsKeyPressed(ImGuiKey.ImGuiKey_Escape) || IsKeyPressed(ImGuiKey.ImGuiKey_Enter)
		clear_buffer |= IsKeyPressed(ImGuiKey.ImGuiKey_Backspace) && (flags & ImGuiTypingSelectFlags_.ImGuiTypingSelectFlags_AllowBackspace) == {}
		//if (clear_buffer) { IMGUI_DEBUG_LOG("GetTypingSelectRequest(): Clear SearchBuffer.\n"); }
		if clear_buffer { Clear(data) }
	}

	// Append to buffer
	buffer_max_len : i32 = cast(i32)IM_ARRAYSIZE(data.SearchBuffer) - 1
	buffer_len : i32 = cast(i32) strlen(raw_data(&data.SearchBuffer))
	select_request : bool = false
	for &w in g.IO.InputQueueCharacters.Data[:g.IO.InputQueueCharacters.Size] {
		w_len : i32 = ImTextCountUtf8BytesFromStr((cast([^]ImWchar)&w)[:1])
		if w < 32 || (buffer_len == 0 && ImCharIsBlankW(u32(w))) || (buffer_len + w_len > buffer_max_len) {
			// Ignore leading blanks
			continue
		}
		w_buf : [5]u8
		ImTextCharToUtf8(&w_buf, cast(u32) w)
		if data.SingleCharModeLock && w_len == i32(out_request.SingleCharSize) && memcmp(&w_buf, &data.SearchBuffer, w_len) == 0 {
			select_request = true; // Same character: don't need to append to buffer.
			continue
		}
		if data.SingleCharModeLock {
			Clear(data); // Different character: clear
			buffer_len = 0
		}
		memcpy(&data.SearchBuffer[buffer_len], &w_buf, int(w_len) + 1); // Append
		buffer_len += w_len
		select_request = true
	}

	resize(&g.IO.InputQueueCharacters, 0)

	// Handle backspace
	if (flags & ImGuiTypingSelectFlags_.ImGuiTypingSelectFlags_AllowBackspace) != {} && IsKeyPressed(ImGuiKey.ImGuiKey_Backspace, ImGuiInputFlags_.ImGuiInputFlags_Repeat) {
		p := ImTextFindPreviousUtf8Codepoint(raw_data(&data.SearchBuffer), raw_data(&data.SearchBuffer)[buffer_len:])
		p[0] = 0
		buffer_len = cast(i32) mem.ptr_sub(p, raw_data(&data.SearchBuffer))
	}

	// Return request if any
	if buffer_len == 0 { return nil }
	if select_request {
		data.FocusScope = g.NavFocusScopeId
		data.LastRequestFrame = g.FrameCount
		data.LastRequestTime = cast(f32) g.Time
	}
	out_request.Flags = flags
	out_request.SearchBufferLen = buffer_len
	out_request.SearchBuffer = raw_data(&data.SearchBuffer)
	out_request.SelectRequest = (data.LastRequestFrame == g.FrameCount)
	out_request.SingleCharMode = false
	out_request.SingleCharSize = 0

	// Calculate if buffer contains the same character repeated.
	// - This can be used to implement a special search mode on first character.
	// - Performed on UTF-8 codepoint for correctness.
	// - SingleCharMode is always set for first input character, because it usually leads to a "next".
	if (flags & ImGuiTypingSelectFlags_.ImGuiTypingSelectFlags_AllowSingleCharMode) != {} {
		buf_begin := out_request.SearchBuffer
		buf_end := out_request.SearchBuffer[out_request.SearchBufferLen:]
		c0_len : i32 = ImTextCountUtf8BytesFromChar(buf_begin, buf_end)
		p := buf_begin[c0_len:]
		for ; p < buf_end; p = p[c0_len:] { if memcmp(buf_begin, p, cast(uint) c0_len) != 0 { break } }

		single_char_count : i32 = (p == buf_end) ? (out_request.SearchBufferLen / c0_len) : 0
		out_request.SingleCharMode = (single_char_count > 0 || data.SingleCharModeLock)
		out_request.SingleCharSize = cast(ImS8) c0_len
		data.SingleCharModeLock |= (single_char_count >= TYPING_SELECT_SINGLE_CHAR_COUNT_FOR_LOCK); // From now on we stop search matching to lock to single char mode.
	}

	return out_request
}

ImStrimatchlen :: proc(s1 : [^]u8, s1_end : ^u8, s2 : [^]u8) -> i32
{
	s1, s2 := s1, s2
	match_len : i32 = 0
	for s1 < s1_end && ImToUpper(post_incr(&s1)^) == ImToUpper(post_incr(&s2)^) { post_incr(&match_len) }

	return match_len
}

// Default handler for finding a result for typing-select. You may implement your own.
// You might want to display a tooltip to visualize the current request SearchBuffer
// When SingleCharMode is set:
// - it is better to NOT display a tooltip of other on-screen display indicator.
// - the index of the currently focused item is required.
//   if your SetNextItemSelectionUserData() values are indices, you can obtain it from ImGuiMultiSelectIO::NavIdItem, otherwise from g.NavLastValidSelectionUserData.
TypingSelectFindMatch :: proc(req : ^ImGuiTypingSelectRequest, items_count : i32, get_item_name_func : proc(_ : rawptr, _ : i32) -> string, user_data : rawptr, nav_item_idx : i32) -> i32
{
	if req == nil || req.SelectRequest == false {
		// Support NULL parameter so both calls can be done from same spot.
		return -1
	}
	idx : i32 = -1
	if req.SingleCharMode && (req.Flags & ImGuiTypingSelectFlags_.ImGuiTypingSelectFlags_AllowSingleCharMode) != {} { idx = TypingSelectFindNextSingleCharMatch(req, items_count, get_item_name_func, user_data, nav_item_idx) }
	else { idx = TypingSelectFindBestLeadingMatch(req, items_count, get_item_name_func, user_data) }
	if idx != -1 { SetNavCursorVisibleAfterMove() }
	return idx
}

// Special handling when a single character is repeated: perform search on a single letter and goes to next.
TypingSelectFindNextSingleCharMatch :: proc(req : ^ImGuiTypingSelectRequest, items_count : i32, get_item_name_func : proc(_ : rawptr, _ : i32) -> string, user_data : rawptr, nav_item_idx : i32) -> i32
{
	// FIXME: Assume selection user data is index. Would be extremely practical.
	//if (nav_item_idx == -1)
	//    nav_item_idx = (int)g.NavLastValidSelectionUserData;

	first_match_idx : i32 = -1
	return_next_match : bool = false
	for idx : i32 = 0; idx < items_count; idx += 1 {
		item_name := get_item_name_func(user_data, idx)
		if ImStrimatchlen(req.SearchBuffer, &req.SearchBuffer[req.SingleCharSize], raw_data(item_name)) < i32(req.SingleCharSize) { continue }
		if return_next_match {
			// Return next matching item after current item.
			return idx
		}
		if first_match_idx == -1 && nav_item_idx == -1 {
			// Return first match immediately if we don't have a nav_item_idx value.
			return idx
		}
		if first_match_idx == -1 {
			// Record first match for wrapping.
			first_match_idx = idx
		}
		if nav_item_idx == idx {
			// Record that we encountering nav_item so we can return next match.
			return_next_match = true
		}
	}

	return first_match_idx// First result
}

TypingSelectFindBestLeadingMatch :: proc(req : ^ImGuiTypingSelectRequest, items_count : i32, get_item_name_func : proc(_ : rawptr, _ : i32) -> string, user_data : rawptr) -> i32
{
	longest_match_idx : i32 = -1
	longest_match_len : i32 = 0
	for idx : i32 = 0; idx < items_count; idx += 1 {
		item_name := get_item_name_func(user_data, idx)
		match_len : i32 = ImStrimatchlen(req.SearchBuffer, &req.SearchBuffer[req.SearchBufferLen], raw_data(item_name))
		if match_len <= longest_match_len { continue }
		longest_match_idx = idx
		longest_match_len = match_len
		if match_len == req.SearchBufferLen { break }
	}

	return longest_match_idx
}

DebugNodeTypingSelectState :: proc(data : ^ImGuiTypingSelectState)
{
	when ! IMGUI_DISABLE_DEBUG_TOOLS { /* @gen ifndef */
	Text("SearchBuffer = \"%s\"", data.SearchBuffer)
	Text("SingleCharMode = %d, Size = %d, Lock = %d", data.Request.SingleCharMode, data.Request.SingleCharSize, data.SingleCharModeLock)
	Text("LastRequest = time: %.2f, frame: %d", data.LastRequestTime, data.LastRequestFrame)
	} else { // preproc else
	IM_UNUSED(data)
	} // preproc endif
}

//-------------------------------------------------------------------------
// [SECTION] Widgets: Box-Select support
// This has been extracted away from Multi-Select logic in the hope that it could eventually be used elsewhere, but hasn't been yet.
//-------------------------------------------------------------------------
// Extra logic in MultiSelectItemFooter() and ImGuiListClipper::Step()
//-------------------------------------------------------------------------
// - BoxSelectPreStartDrag() [Internal]
// - BoxSelectActivateDrag() [Internal]
// - BoxSelectDeactivateDrag() [Internal]
// - BoxSelectScrollWithMouseDrag() [Internal]
// - BeginBoxSelect() [Internal]
// - EndBoxSelect() [Internal]
//-------------------------------------------------------------------------

// Call on the initial click.
BoxSelectPreStartDrag :: proc(id : ImGuiID, clicked_item : ImGuiSelectionUserData)
{
	g : ^ImGuiContext = GImGui
	bs : ^ImGuiBoxSelectState = &g.BoxSelectState
	bs.ID = id
	bs.IsStarting = true; // Consider starting box-select.
	bs.IsStartedFromVoid = (clicked_item == ImGuiSelectionUserData_Invalid)
	bs.IsStartedSetNavIdOnce = bs.IsStartedFromVoid
	bs.KeyMods = g.IO.KeyMods
	bs.EndPosRel = WindowPosAbsToRel(g.CurrentWindow, g.IO.MousePos); bs.StartPosRel = bs.EndPosRel
	bs.ScrollAccum = ImVec2{0.0, 0.0}
}

BoxSelectActivateDrag :: proc(bs : ^ImGuiBoxSelectState, window : ^ImGuiWindow)
{
	g : ^ImGuiContext = GImGui
	IMGUI_DEBUG_LOG_SELECTION(g, "[selection] BeginBoxSelect() 0X%08X: Activate\n", bs.ID)
	bs.IsActive = true
	bs.Window = window
	bs.IsStarting = false
	SetActiveID(bs.ID, window)
	SetActiveIdUsingAllKeyboardKeys()
	if bs.IsStartedFromVoid && (bs.KeyMods & (ImGuiKey.ImGuiMod_Ctrl | ImGuiKey.ImGuiMod_Shift)) == {} { bs.RequestClear = true }
}

BoxSelectDeactivateDrag :: proc(bs : ^ImGuiBoxSelectState)
{
	g : ^ImGuiContext = GImGui
	bs.IsStarting = false; bs.IsActive = bs.IsStarting
	if g.ActiveId == bs.ID {
		IMGUI_DEBUG_LOG_SELECTION(g, "[selection] BeginBoxSelect() 0X%08X: Deactivate\n", bs.ID)
		ClearActiveID()
	}
	bs.ID = 0
}

BoxSelectScrollWithMouseDrag :: proc(bs : ^ImGuiBoxSelectState, window : ^ImGuiWindow, inner_r : ImRect)
{
	g : ^ImGuiContext = GImGui
	IM_ASSERT(bs.Window == window)
	for n : i32 = 0; n < 2; n += 1 {
		mouse_pos : f32 = g.IO.MousePos[n]
		dist : f32 = (mouse_pos > inner_r.Max[n]) ? mouse_pos - inner_r.Max[n] : (mouse_pos < inner_r.Min[n]) ? mouse_pos - inner_r.Min[n] : 0.0
		scroll_curr : f32 = window.Scroll[n]
		if dist == 0.0 || (dist < 0.0 && scroll_curr < 0.0) || (dist > 0.0 && scroll_curr >= window.ScrollMax[n]) { continue }

		speed_multiplier : f32 = ImLinearRemapClamp(g.FontSize, g.FontSize * 5.0, 1.0, 4.0, ImAbs(dist)); // x1 to x4 depending on distance
		scroll_step : f32 = g.FontSize * 35.0 * speed_multiplier * ImSign(dist) * g.IO.DeltaTime
		bs.ScrollAccum[n] += scroll_step

		// Accumulate into a stored value so we can handle high-framerate
		scroll_step_i : f32 = ImFloor(bs.ScrollAccum[n])
		if scroll_step_i == 0.0 { continue }
		if n == 0 { SetScrollX(window, scroll_curr + scroll_step_i) }
		else { SetScrollY(window, scroll_curr + scroll_step_i) }
		bs.ScrollAccum[n] -= scroll_step_i
	}
}

BeginBoxSelect :: proc(scope_rect : ImRect, window : ^ImGuiWindow, box_select_id : ImGuiID, ms_flags : ImGuiMultiSelectFlags) -> bool
{
	g : ^ImGuiContext = GImGui
	bs : ^ImGuiBoxSelectState = &g.BoxSelectState
	KeepAliveID(box_select_id)
	if bs.ID != box_select_id { return false }

	// IsStarting is set by MultiSelectItemFooter() when considering a possible box-select. We validate it here and lock geometry.
	bs.UnclipMode = false
	bs.RequestClear = false
	if bs.IsStarting && IsMouseDragPastThreshold(ImGuiMouseButton(0)) { BoxSelectActivateDrag(bs, window) }
	else if (bs.IsStarting || bs.IsActive) && g.IO.MouseDown[0] == false { BoxSelectDeactivateDrag(bs) }
	if !bs.IsActive { return false }

	// Current frame absolute prev/current rectangles are used to toggle selection.
	// They are derived from positions relative to scrolling space.
	start_pos_abs : ImVec2 = WindowPosRelToAbs(window, bs.StartPosRel)
	prev_end_pos_abs : ImVec2 = WindowPosRelToAbs(window, bs.EndPosRel); // Clamped already
	curr_end_pos_abs : ImVec2 = g.IO.MousePos
	if (ms_flags & ImGuiMultiSelectFlags_.ImGuiMultiSelectFlags_ScopeWindow) != {} {
		// Box-select scrolling only happens with ScopeWindow
		curr_end_pos_abs = ImClamp(curr_end_pos_abs, scope_rect.Min, scope_rect.Max)
	}
	bs.BoxSelectRectPrev.Min = ImMin(start_pos_abs, prev_end_pos_abs)
	bs.BoxSelectRectPrev.Max = ImMax(start_pos_abs, prev_end_pos_abs)
	bs.BoxSelectRectCurr.Min = ImMin(start_pos_abs, curr_end_pos_abs)
	bs.BoxSelectRectCurr.Max = ImMax(start_pos_abs, curr_end_pos_abs)

	// Box-select 2D mode detects horizontal changes (vertical ones are already picked by Clipper)
	// Storing an extra rect used by widgets supporting box-select.
	if (ms_flags & ImGuiMultiSelectFlags_.ImGuiMultiSelectFlags_BoxSelect2d) != {} { if bs.BoxSelectRectPrev.Min.x != bs.BoxSelectRectCurr.Min.x || bs.BoxSelectRectPrev.Max.x != bs.BoxSelectRectCurr.Max.x {
	bs.UnclipMode = true
	bs.UnclipRect = bs.BoxSelectRectPrev; // FIXME-OPT: UnclipRect x coordinates could be intersection of Prev and Curr rect on X axis.
	Add(&bs.UnclipRect, bs.BoxSelectRectCurr)
} }

	//GetForegroundDrawList()->AddRect(bs->UnclipRect.Min, bs->UnclipRect.Max, IM_COL32(255,0,0,200), 0.0f, 0, 3.0f);
	//GetForegroundDrawList()->AddRect(bs->BoxSelectRectPrev.Min, bs->BoxSelectRectPrev.Max, IM_COL32(255,0,0,200), 0.0f, 0, 3.0f);
	//GetForegroundDrawList()->AddRect(bs->BoxSelectRectCurr.Min, bs->BoxSelectRectCurr.Max, IM_COL32(0,255,0,200), 0.0f, 0, 1.0f);
	return true
}

EndBoxSelect :: proc(scope_rect : ImRect, ms_flags : ImGuiMultiSelectFlags)
{
	g : ^ImGuiContext = GImGui
	window : ^ImGuiWindow = g.CurrentWindow
	bs : ^ImGuiBoxSelectState = &g.BoxSelectState
	IM_ASSERT(bs.IsActive)
	bs.UnclipMode = false

	// Render selection rectangle
	bs.EndPosRel = WindowPosAbsToRel(window, ImClamp(g.IO.MousePos, scope_rect.Min, scope_rect.Max)); // Clamp stored position according to current scrolling view
	box_select_r : ImRect = bs.BoxSelectRectCurr
	ClipWith(&box_select_r, scope_rect)
	AddRectFilled(window.DrawList, box_select_r.Min, box_select_r.Max, GetColorU32(ImGuiCol_.ImGuiCol_SeparatorHovered, 0.30)); // FIXME-MULTISELECT: Styling
	AddRect(window.DrawList, box_select_r.Min, box_select_r.Max, GetColorU32(ImGuiCol_.ImGuiCol_NavCursor)); // FIXME-MULTISELECT: Styling

	// Scroll
	enable_scroll : bool = (ms_flags & ImGuiMultiSelectFlags_.ImGuiMultiSelectFlags_ScopeWindow) != {} && (ms_flags & ImGuiMultiSelectFlags_.ImGuiMultiSelectFlags_BoxSelectNoScroll) == {}
	if enable_scroll {
		scroll_r : ImRect = scope_rect
		Expand(&scroll_r, -g.FontSize)
		//GetForegroundDrawList()->AddRect(scroll_r.Min, scroll_r.Max, IM_COL32(0, 255, 0, 255));
		if !Contains(scroll_r, g.IO.MousePos) { BoxSelectScrollWithMouseDrag(bs, window, scroll_r) }
	}
}

//-------------------------------------------------------------------------
// [SECTION] Widgets: Multi-Select support
//-------------------------------------------------------------------------
// - DebugLogMultiSelectRequests() [Internal]
// - CalcScopeRect() [Internal]
// - BeginMultiSelect()
// - EndMultiSelect()
// - SetNextItemSelectionUserData()
// - MultiSelectItemHeader() [Internal]
// - MultiSelectItemFooter() [Internal]
// - DebugNodeMultiSelectState() [Internal]
//-------------------------------------------------------------------------

DebugLogMultiSelectRequests :: proc(function : string, io : ^ImGuiMultiSelectIO)
{
	g : ^ImGuiContext = GImGui
	IM_UNUSED(function)
	for req in io.Requests.Data[:io.Requests.Size] {
		if req.Type == ImGuiSelectionRequestType.ImGuiSelectionRequestType_SetAll { IMGUI_DEBUG_LOG_SELECTION(g, "[selection] %s: Request: SetAll %d (= %s)\n", function, req.Selected, req.Selected ? "SelectAll" : "Clear") }
		if req.Type == ImGuiSelectionRequestType.ImGuiSelectionRequestType_SetRange { IMGUI_DEBUG_LOG_SELECTION(g, ") = %d (dir %d)\n", function, req.RangeFirstItem, req.RangeLastItem, req.RangeFirstItem, req.RangeLastItem, req.Selected, req.RangeDirection) }
	}
}

CalcScopeRect :: proc(ms : ^ImGuiMultiSelectTempData, window : ^ImGuiWindow) -> ImRect
{
	g : ^ImGuiContext = GImGui
	if (ms.Flags & ImGuiMultiSelectFlags_.ImGuiMultiSelectFlags_ScopeRect) != {} {
		// Warning: this depends on CursorMaxPos so it means to be called by EndMultiSelect() only
		return ImRect{ms.ScopeRectMin, ImMax(window.DC.CursorMaxPos, ms.ScopeRectMin)}
	}
	else {
		// When a table, pull HostClipRect, which allows us to predict ClipRect before first row/layout is performed. (#7970)
		scope_rect : ImRect = window.InnerClipRect
		if g.CurrentTable != nil { scope_rect = g.CurrentTable.HostClipRect }

		// Add inner table decoration (#7821) // FIXME: Why not baking in InnerClipRect?
		scope_rect.Min = ImMin(scope_rect.Min + ImVec2{window.DecoInnerSizeX1, window.DecoInnerSizeY1}, scope_rect.Max)
		return scope_rect
	}
}

// Return ImGuiMultiSelectIO structure.
// Lifetime: don't hold on ImGuiMultiSelectIO* pointers over multiple frames or past any subsequent call to BeginMultiSelect() or EndMultiSelect().
// Passing 'selection_size' and 'items_count' parameters is currently optional.
// - 'selection_size' is useful to disable some shortcut routing: e.g. ImGuiMultiSelectFlags_ClearOnEscape won't claim Escape key when selection_size 0,
//    allowing a first press to clear selection THEN the second press to leave child window and return to parent.
// - 'items_count' is stored in ImGuiMultiSelectIO which makes it a convenient way to pass the information to your ApplyRequest() handler (but you may pass it differently).
// - If they are costly for you to compute (e.g. external intrusive selection without maintaining size), you may avoid them and pass -1.
//   - If you can easily tell if your selection is empty or not, you may pass 0/1, or you may enable ImGuiMultiSelectFlags_ClearOnEscape flag dynamically.
BeginMultiSelect :: proc(flags : ImGuiMultiSelectFlags, selection_size : i32, items_count : i32) -> ^ImGuiMultiSelectIO
{
	g : ^ImGuiContext = GImGui
	window : ^ImGuiWindow = g.CurrentWindow

	if pre_incr(&g.MultiSelectTempDataStacked) > g.MultiSelectTempData.Size { v : ImGuiMultiSelectTempData; init(&v); resize(&g.MultiSelectTempData, g.MultiSelectTempDataStacked, v) }
	ms : ^ImGuiMultiSelectTempData = &g.MultiSelectTempData.Data[g.MultiSelectTempDataStacked - 1]
	#assert(offset_of(ImGuiMultiSelectTempData, IO) == 0); // Clear() relies on that.
	g.CurrentMultiSelect = ms
	flags := flags
	if (flags & (ImGuiMultiSelectFlags_.ImGuiMultiSelectFlags_ScopeWindow | ImGuiMultiSelectFlags_.ImGuiMultiSelectFlags_ScopeRect)) == {} { flags |= ImGuiMultiSelectFlags_.ImGuiMultiSelectFlags_ScopeWindow }
	if (flags & ImGuiMultiSelectFlags_.ImGuiMultiSelectFlags_SingleSelect) != {} { flags &= cast(ImGuiMultiSelectFlags)~i32(ImGuiMultiSelectFlags_.ImGuiMultiSelectFlags_BoxSelect2d | ImGuiMultiSelectFlags_.ImGuiMultiSelectFlags_BoxSelect1d) }
	if (flags & ImGuiMultiSelectFlags_.ImGuiMultiSelectFlags_BoxSelect2d) != {} { flags &= cast(ImGuiMultiSelectFlags)~cast(i32)ImGuiMultiSelectFlags_.ImGuiMultiSelectFlags_BoxSelect1d }

	// FIXME: Workaround to the fact we override CursorMaxPos, meaning size measurement are lost. (#8250)
	// They should perhaps be stacked properly?
	if table : ^ImGuiTable = g.CurrentTable; table != nil {
		if table.CurrentColumn != -1 {
			// This is currently safe to call multiple time. If that properly is lost we can extract the "save measurement" part of it.
			TableEndCell(table)
		}
	}

	// FIXME: BeginFocusScope()
	id : ImGuiID = back(&window.IDStack)^
	Clear(ms)
	ms.FocusScopeId = id
	ms.Flags = flags
	ms.IsFocused = (ms.FocusScopeId == g.NavFocusScopeId)
	ms.BackupCursorMaxPos = window.DC.CursorMaxPos
	window.DC.CursorMaxPos = window.DC.CursorPos; ms.ScopeRectMin = window.DC.CursorMaxPos
	PushFocusScope(ms.FocusScopeId)
	if (flags & ImGuiMultiSelectFlags_.ImGuiMultiSelectFlags_ScopeWindow) != {} {
		// Mark parent child window as navigable into, with highlight. Assume user will always submit interactive items.
		window.DC.NavLayersActiveMask |= 1 << u32(ImGuiNavLayer.ImGuiNavLayer_Main)
	}

	// Use copy of keyboard mods at the time of the request, otherwise we would requires mods to be held for an extra frame.
	ms.KeyMods = g.NavJustMovedToId != 0 ? (g.NavJustMovedToIsTabbing ? {} : g.NavJustMovedToKeyMods) : g.IO.KeyMods
	if (flags & ImGuiMultiSelectFlags_.ImGuiMultiSelectFlags_NoRangeSelect) != {} { ms.KeyMods &= cast(ImGuiKey)~cast(i32)ImGuiKey.ImGuiMod_Shift }

	// Bind storage
	storage : ^ImGuiMultiSelectState = GetOrAddByKey(&g.MultiSelectStorage, id)
	storage.ID = id
	storage.LastFrameActive = g.FrameCount
	storage.LastSelectionSize = selection_size
	storage.Window = window
	ms.Storage = storage

	// Output to user
	resize(&ms.IO.Requests, 0)
	ms.IO.RangeSrcItem = storage.RangeSrcItem
	ms.IO.NavIdItem = storage.NavIdItem
	ms.IO.NavIdSelected = (storage.NavIdSelected == 1) ? true : false
	ms.IO.ItemsCount = items_count

	// Clear when using Navigation to move within the scope
	// (we compare FocusScopeId so it possible to use multiple selections inside a same window)
	request_clear : bool = false
	request_select_all : bool = false
	if g.NavJustMovedToId != 0 && g.NavJustMovedToFocusScopeId == ms.FocusScopeId && g.NavJustMovedToHasSelectionData {
		if (ms.KeyMods & ImGuiKey.ImGuiMod_Shift) != {} { ms.IsKeyboardSetRange = true }
		if ms.IsKeyboardSetRange {
			// Not ready -> could clear?
			IM_ASSERT(storage.RangeSrcItem != ImGuiSelectionUserData_Invalid)
		}
		if (ms.KeyMods & (ImGuiKey.ImGuiMod_Ctrl | ImGuiKey.ImGuiMod_Shift)) == {} && (flags & (ImGuiMultiSelectFlags_.ImGuiMultiSelectFlags_NoAutoClear | ImGuiMultiSelectFlags_.ImGuiMultiSelectFlags_NoAutoSelect)) ==  {} { request_clear = true }
	}
	else if g.NavJustMovedFromFocusScopeId == ms.FocusScopeId {
		// Also clear on leaving scope (may be optional?)
		if (ms.KeyMods & (ImGuiKey.ImGuiMod_Ctrl | ImGuiKey.ImGuiMod_Shift)) ==  {} && (flags & (ImGuiMultiSelectFlags_.ImGuiMultiSelectFlags_NoAutoClear | ImGuiMultiSelectFlags_.ImGuiMultiSelectFlags_NoAutoSelect)) ==  {} { request_clear = true }
	}

	// Box-select handling: update active state.
	bs : ^ImGuiBoxSelectState = &g.BoxSelectState
	if (flags & (ImGuiMultiSelectFlags_.ImGuiMultiSelectFlags_BoxSelect1d | ImGuiMultiSelectFlags_.ImGuiMultiSelectFlags_BoxSelect2d)) != {} {
		ms.BoxSelectId = GetID("##BoxSelect")
		if BeginBoxSelect(CalcScopeRect(ms, window), window, ms.BoxSelectId, flags) { request_clear |= bs.RequestClear }
	}

	if ms.IsFocused {
		// Shortcut: Clear selection (Escape)
		// - Only claim shortcut if selection is not empty, allowing further presses on Escape to e.g. leave current child window.
		// - Box select also handle Escape and needs to pass an id to bypass ActiveIdUsingAllKeyboardKeys lock.
		if (flags & ImGuiMultiSelectFlags_.ImGuiMultiSelectFlags_ClearOnEscape) != {} {
			if selection_size != 0 || bs.IsActive {
				if Shortcut(ImGuiKey.ImGuiKey_Escape, ImGuiInputFlags_.ImGuiInputFlags_None, bs.IsActive ? bs.ID : 0) {
					request_clear = true
					if bs.IsActive { BoxSelectDeactivateDrag(bs) }
				}
			}
		}

		// Shortcut: Select all (CTRL+A)
		if (flags & ImGuiMultiSelectFlags_.ImGuiMultiSelectFlags_SingleSelect) == {} && (flags & ImGuiMultiSelectFlags_.ImGuiMultiSelectFlags_NoSelectAll) == {} { if Shortcut(ImGuiKey.ImGuiMod_Ctrl | ImGuiKey.ImGuiKey_A) { request_select_all = true } }
	}

	if request_clear || request_select_all {
		MultiSelectAddSetAll(ms, request_select_all)
		if !request_select_all { storage.LastSelectionSize = 0 }
	}
	ms.LoopRequestSetAll = request_select_all ? 1 : request_clear ? 0 : -1
	ms.LastSubmittedItem = ImGuiSelectionUserData_Invalid

	if (g.DebugLogFlags & ImGuiDebugLogFlags_.ImGuiDebugLogFlags_EventSelection) != {} { DebugLogMultiSelectRequests("BeginMultiSelect", &ms.IO) }

	return &ms.IO
}

// Return updated ImGuiMultiSelectIO structure.
// Lifetime: don't hold on ImGuiMultiSelectIO* pointers over multiple frames or past any subsequent call to BeginMultiSelect() or EndMultiSelect().
EndMultiSelect :: proc() -> ^ImGuiMultiSelectIO
{
	g : ^ImGuiContext = GImGui
	ms : ^ImGuiMultiSelectTempData = g.CurrentMultiSelect
	storage : ^ImGuiMultiSelectState = ms.Storage
	window : ^ImGuiWindow = g.CurrentWindow
	IM_ASSERT_USER_ERROR(ms.FocusScopeId == g.CurrentFocusScopeId, "EndMultiSelect() FocusScope mismatch!")
	IM_ASSERT(g.CurrentMultiSelect != nil && storage.Window == g.CurrentWindow)
	IM_ASSERT(g.MultiSelectTempDataStacked > 0 && &g.MultiSelectTempData.Data[g.MultiSelectTempDataStacked - 1] == g.CurrentMultiSelect)

	scope_rect : ImRect = CalcScopeRect(ms, window)
	if ms.IsFocused {
		// We currently don't allow user code to modify RangeSrcItem by writing to BeginIO's version, but that would be an easy change here.
		if ms.IO.RangeSrcReset || (ms.RangeSrcPassedBy == false && ms.IO.RangeSrcItem != ImGuiSelectionUserData_Invalid) {
			// Can't read storage->RangeSrcItem here -> we want the state at begining of the scope (see tests for easy failure)
			IMGUI_DEBUG_LOG_SELECTION(g, "[selection] EndMultiSelect: Reset RangeSrcItem.\n"); // Will set be to NavId.
			storage.RangeSrcItem = ImGuiSelectionUserData_Invalid
		}
		if ms.NavIdPassedBy == false && storage.NavIdItem != ImGuiSelectionUserData_Invalid {
			IMGUI_DEBUG_LOG_SELECTION(g, "[selection] EndMultiSelect: Reset NavIdItem.\n")
			storage.NavIdItem = ImGuiSelectionUserData_Invalid
			storage.NavIdSelected = -1
		}

		if (ms.Flags & (ImGuiMultiSelectFlags_.ImGuiMultiSelectFlags_BoxSelect1d | ImGuiMultiSelectFlags_.ImGuiMultiSelectFlags_BoxSelect2d)) != {} && GetBoxSelectState(ms.BoxSelectId) != nil { EndBoxSelect(scope_rect, ms.Flags) }
	}

	if ms.IsEndIO == false { resize(&ms.IO.Requests, 0) }

	// Clear selection when clicking void?
	// We specifically test for IsMouseDragPastThreshold(0) == false to allow box-selection!
	// The InnerRect test is necessary for non-child/decorated windows.
	scope_hovered : bool = IsWindowHovered() && Contains(window.InnerRect, g.IO.MousePos)
	if scope_hovered && (ms.Flags & ImGuiMultiSelectFlags_.ImGuiMultiSelectFlags_ScopeRect) != {} { scope_hovered &= Contains(scope_rect, g.IO.MousePos) }
	if scope_hovered && g.HoveredId == 0 && g.ActiveId == 0 {
		if (ms.Flags & (ImGuiMultiSelectFlags_.ImGuiMultiSelectFlags_BoxSelect1d | ImGuiMultiSelectFlags_.ImGuiMultiSelectFlags_BoxSelect2d)) != {} {
			if !g.BoxSelectState.IsActive && !g.BoxSelectState.IsStarting && g.IO.MouseClickedCount[0] == 1 {
				BoxSelectPreStartDrag(ms.BoxSelectId, ImGuiSelectionUserData_Invalid)
				FocusWindow(window, ImGuiFocusRequestFlags_.ImGuiFocusRequestFlags_UnlessBelowModal)
				SetHoveredID(ms.BoxSelectId)
				if (ms.Flags & ImGuiMultiSelectFlags_.ImGuiMultiSelectFlags_ScopeRect) != {} {
					// Automatically switch FocusScope for initial click from void to box-select.
					SetNavID(0, ImGuiNavLayer.ImGuiNavLayer_Main, ms.FocusScopeId, ImRect{g.IO.MousePos, g.IO.MousePos})
				}
			}
		}

		if (ms.Flags & ImGuiMultiSelectFlags_.ImGuiMultiSelectFlags_ClearOnClickVoid) != {} {
			if IsMouseReleased(cast(ImGuiMouseButton) 0) && IsMouseDragPastThreshold(cast(ImGuiMouseButton) 0) == false && g.IO.KeyMods == ImGuiKey.ImGuiMod_None { MultiSelectAddSetAll(ms, false) }
		}
	}

	// Courtesy nav wrapping helper flag
	if (ms.Flags & ImGuiMultiSelectFlags_.ImGuiMultiSelectFlags_NavWrapX) != {} {
		IM_ASSERT((ms.Flags & ImGuiMultiSelectFlags_.ImGuiMultiSelectFlags_ScopeWindow) != {}); // Only supported at window scope
		NavMoveRequestTryWrapping(GetCurrentWindow(), ImGuiNavMoveFlags_.ImGuiNavMoveFlags_WrapX)
	}

	// Unwind
	window.DC.CursorMaxPos = ImMax(ms.BackupCursorMaxPos, window.DC.CursorMaxPos)
	PopFocusScope()

	if (g.DebugLogFlags & ImGuiDebugLogFlags_.ImGuiDebugLogFlags_EventSelection) != {} { DebugLogMultiSelectRequests("EndMultiSelect", &ms.IO) }

	ms.FocusScopeId = 0
	ms.Flags = ImGuiMultiSelectFlags_.ImGuiMultiSelectFlags_None
	g.CurrentMultiSelect = (pre_decr(&g.MultiSelectTempDataStacked) > 0) ? &g.MultiSelectTempData.Data[g.MultiSelectTempDataStacked - 1] : nil

	return &ms.IO
}

SetNextItemSelectionUserData :: proc(selection_user_data : ImGuiSelectionUserData)
{
	// Note that flags will be cleared by ItemAdd(), so it's only useful for Navigation code!
	// This designed so widgets can also cheaply set this before calling ItemAdd(), so we are not tied to MultiSelect api.
	g : ^ImGuiContext = GImGui
	g.NextItemData.SelectionUserData = selection_user_data
	g.NextItemData.FocusScopeId = g.CurrentFocusScopeId

	if ms : ^ImGuiMultiSelectTempData = g.CurrentMultiSelect; ms != nil {
		// Auto updating RangeSrcPassedBy for cases were clipper is not used (done before ItemAdd() clipping)
		g.NextItemData.ItemFlags |= cast(ImGuiItemFlags) (ImGuiItemFlagsPrivate_.ImGuiItemFlags_HasSelectionUserData | ImGuiItemFlagsPrivate_.ImGuiItemFlags_IsMultiSelect)
		if ms.IO.RangeSrcItem == selection_user_data { ms.RangeSrcPassedBy = true }
	}
	else {
		g.NextItemData.ItemFlags |= cast(ImGuiItemFlags) ImGuiItemFlagsPrivate_.ImGuiItemFlags_HasSelectionUserData
	}
}

// In charge of:
// - Applying SetAll for submitted items.
// - Applying SetRange for submitted items and record end points.
// - Altering button behavior flags to facilitate use with drag and drop.
MultiSelectItemHeader :: proc(id : ImGuiID, p_selected : ^bool, p_button_flags : ^ImGuiButtonFlags)
{
	g : ^ImGuiContext = GImGui
	ms : ^ImGuiMultiSelectTempData = g.CurrentMultiSelect

	selected : bool = p_selected^
	if ms.IsFocused {
		storage : ^ImGuiMultiSelectState = ms.Storage
		item_data : ImGuiSelectionUserData = g.NextItemData.SelectionUserData
		IM_ASSERT(g.NextItemData.FocusScopeId == g.CurrentFocusScopeId, "Forgot to call SetNextItemSelectionUserData() prior to item, required in BeginMultiSelect()/EndMultiSelect() scope")

		// Apply SetAll (Clear/SelectAll) requests requested by BeginMultiSelect().
		// This is only useful if the user hasn't processed them already, and this only works if the user isn't using the clipper.
		// If you are using a clipper you need to process the SetAll request after calling BeginMultiSelect()
		if ms.LoopRequestSetAll != -1 { selected = (ms.LoopRequestSetAll == 1) }

		// When using SHIFT+Nav: because it can incur scrolling we cannot afford a frame of lag with the selection highlight (otherwise scrolling would happen before selection)
		// For this to work, we need someone to set 'RangeSrcPassedBy = true' at some point (either clipper either SetNextItemSelectionUserData() function)
		if ms.IsKeyboardSetRange {
			IM_ASSERT(id != 0 && (ms.KeyMods & ImGuiKey.ImGuiMod_Shift) != {})
			is_range_dst : bool = (ms.RangeDstPassedBy == false) && g.NavJustMovedToId == id; // Assume that g.NavJustMovedToId is not clipped.
			if is_range_dst { ms.RangeDstPassedBy = true }
			if is_range_dst && storage.RangeSrcItem == ImGuiSelectionUserData_Invalid {
				// If we don't have RangeSrc, assign RangeSrc = RangeDst
				storage.RangeSrcItem = item_data
				storage.RangeSelected = selected ? 1 : 0
			}
			is_range_src : bool = storage.RangeSrcItem == item_data
			if is_range_src || is_range_dst || ms.RangeSrcPassedBy != ms.RangeDstPassedBy {
				// Apply range-select value to visible items
				IM_ASSERT(storage.RangeSrcItem != ImGuiSelectionUserData_Invalid && storage.RangeSelected != -1)
				selected = (storage.RangeSelected != 0)
			}
			else if (ms.KeyMods & ImGuiKey.ImGuiMod_Ctrl) == {} && (ms.Flags & ImGuiMultiSelectFlags_.ImGuiMultiSelectFlags_NoAutoClear) == {} {
				// Clear other items
				selected = false
			}
		}
		p_selected^ = selected
	}

	// Alter button behavior flags
	// To handle drag and drop of multiple items we need to avoid clearing selection on click.
	// Enabling this test makes actions using CTRL+SHIFT delay their effect on MouseUp which is annoying, but it allows drag and drop of multiple items.
	if p_button_flags != nil {
		button_flags : ImGuiButtonFlags = p_button_flags^
		button_flags |= cast(ImGuiButtonFlags) ImGuiButtonFlagsPrivate_.ImGuiButtonFlags_NoHoveredOnFocus
		if (!selected || (g.ActiveId == id && g.ActiveIdHasBeenPressedBefore)) && (ms.Flags & ImGuiMultiSelectFlags_.ImGuiMultiSelectFlags_SelectOnClickRelease) == {} { button_flags = (button_flags | cast(ImGuiButtonFlags) ImGuiButtonFlagsPrivate_.ImGuiButtonFlags_PressedOnClick) & cast(ImGuiButtonFlags) ~cast(i32)ImGuiButtonFlagsPrivate_.ImGuiButtonFlags_PressedOnClickRelease }
		else { button_flags |= cast(ImGuiButtonFlags) ImGuiButtonFlagsPrivate_.ImGuiButtonFlags_PressedOnClickRelease }
		p_button_flags^ = button_flags
	}
}

// In charge of:
// - Auto-select on navigation.
// - Box-select toggle handling.
// - Right-click handling.
// - Altering selection based on Ctrl/Shift modifiers, both for keyboard and mouse.
// - Record current selection state for RangeSrc
// This is all rather complex, best to run and refer to "widgets_multiselect_xxx" tests in imgui_test_suite.
MultiSelectItemFooter :: proc(id : ImGuiID, p_selected : ^bool, p_pressed : ^bool)
{
	g : ^ImGuiContext = GImGui
	window : ^ImGuiWindow = g.CurrentWindow

	selected : bool = p_selected^
	pressed : bool = p_pressed^
	ms : ^ImGuiMultiSelectTempData = g.CurrentMultiSelect
	storage : ^ImGuiMultiSelectState = ms.Storage
	if pressed { ms.IsFocused = true }

	hovered : bool = false
	if (g.LastItemData.StatusFlags & ImGuiItemStatusFlags_.ImGuiItemStatusFlags_HoveredRect) != {} { hovered = IsItemHovered(ImGuiHoveredFlags_.ImGuiHoveredFlags_AllowWhenBlockedByPopup) }
	if !ms.IsFocused && !hovered { return }

	item_data : ImGuiSelectionUserData = g.NextItemData.SelectionUserData

	flags : ImGuiMultiSelectFlags = ms.Flags
	is_singleselect : bool = (flags & ImGuiMultiSelectFlags_.ImGuiMultiSelectFlags_SingleSelect) != {}
	is_ctrl : bool = (ms.KeyMods & ImGuiKey.ImGuiMod_Ctrl) != {}
	is_shift : bool = (ms.KeyMods & ImGuiKey.ImGuiMod_Shift) != {}

	apply_to_range_src : bool = false

	if g.NavId == id && storage.RangeSrcItem == ImGuiSelectionUserData_Invalid { apply_to_range_src = true }
	if ms.IsEndIO == false {
		resize(&ms.IO.Requests, 0)
		ms.IsEndIO = true
	}

	// Auto-select as you navigate a list
	if g.NavJustMovedToId == id {
		if (flags & ImGuiMultiSelectFlags_.ImGuiMultiSelectFlags_NoAutoSelect) == {} {
			if is_ctrl && is_shift { pressed = true }
			else if !is_ctrl { pressed = true; selected = pressed }
		}
		else {
			// With NoAutoSelect, using Shift+keyboard performs a write/copy
			if is_shift { pressed = true }
			else if !is_ctrl {
				// Since if (pressed) {} main block is not running we update this
				apply_to_range_src = true
			}
		}
	}

	if apply_to_range_src {
		storage.RangeSrcItem = item_data
		storage.RangeSelected = selected ? 1 : 0; // Will be updated at the end of this function anyway.
	}

	// Box-select toggle handling
	if ms.BoxSelectId != 0 { if bs : ^ImGuiBoxSelectState = GetBoxSelectState(ms.BoxSelectId); bs != nil {
	rect_overlap_curr : bool = Overlaps(bs.BoxSelectRectCurr, g.LastItemData.Rect)
	rect_overlap_prev : bool = Overlaps(bs.BoxSelectRectPrev, g.LastItemData.Rect)
	if (rect_overlap_curr && !rect_overlap_prev && !selected) || (rect_overlap_prev && !rect_overlap_curr) {
		if storage.LastSelectionSize <= 0 && bs.IsStartedSetNavIdOnce {
			pressed = true; // First item act as a pressed: code below will emit selection request and set NavId (whatever we emit here will be overridden anyway)
			bs.IsStartedSetNavIdOnce = false
		}
		else {
			selected = !selected
			MultiSelectAddSetRange(ms, selected, +1, item_data, item_data)
		}
		storage.LastSelectionSize = ImMax(storage.LastSelectionSize + 1, 1)
	}
} }

	// Right-click handling.
	// FIXME-MULTISELECT: Currently filtered out by ImGuiMultiSelectFlags_NoAutoSelect but maybe should be moved to Selectable(). See https://github.com/ocornut/imgui/pull/5816
	if hovered && IsMouseClicked(cast(ImGuiMouseButton) 1) && (flags & ImGuiMultiSelectFlags_.ImGuiMultiSelectFlags_NoAutoSelect) == {} {
		if g.ActiveId != 0 && g.ActiveId != id { ClearActiveID() }
		SetFocusID(id, window)
		if !pressed && !selected {
			pressed = true
			is_shift = false; is_ctrl = is_shift
		}
	}

	// Unlike Space, Enter doesn't alter selection (but can still return a press) unless current item is not selected.
	// The later, "unless current item is not select", may become optional? It seems like a better default if Enter doesn't necessarily open something
	// (unlike e.g. Windows explorer). For use case where Enter always open something, we might decide to make this optional?
	enter_pressed : bool = pressed && (g.NavActivateId == id) && (g.NavActivateFlags & ImGuiActivateFlags_.ImGuiActivateFlags_PreferInput) != {}

	// Alter selection
	if pressed && (!enter_pressed || !selected) {
		// Box-select
		input_source : ImGuiInputSource = (g.NavJustMovedToId == id || g.NavActivateId == id) ? g.NavInputSource : ImGuiInputSource.ImGuiInputEventType_Mouse
		if (flags & (ImGuiMultiSelectFlags_.ImGuiMultiSelectFlags_BoxSelect1d | ImGuiMultiSelectFlags_.ImGuiMultiSelectFlags_BoxSelect2d)) != {} { if selected == false && !g.BoxSelectState.IsActive && !g.BoxSelectState.IsStarting && input_source == ImGuiInputSource.ImGuiInputEventType_Mouse && g.IO.MouseClickedCount[0] == 1 { BoxSelectPreStartDrag(ms.BoxSelectId, item_data) } }

		//----------------------------------------------------------------------------------------
		// ACTION                      | Begin  | Pressed/Activated  | End
		//----------------------------------------------------------------------------------------
		// Keys Navigated:             | Clear  | Src=item, Sel=1               SetRange 1
		// Keys Navigated: Ctrl        | n/a    | n/a
		// Keys Navigated:      Shift  | n/a    | Dst=item, Sel=1,   => Clear + SetRange 1
		// Keys Navigated: Ctrl+Shift  | n/a    | Dst=item, Sel=Src  => Clear + SetRange Src-Dst
		// Keys Activated:             | n/a    | Src=item, Sel=1    => Clear + SetRange 1
		// Keys Activated: Ctrl        | n/a    | Src=item, Sel=!Sel =>         SetSange 1
		// Keys Activated:      Shift  | n/a    | Dst=item, Sel=1    => Clear + SetSange 1
		//----------------------------------------------------------------------------------------
		// Mouse Pressed:              | n/a    | Src=item, Sel=1,   => Clear + SetRange 1
		// Mouse Pressed:  Ctrl        | n/a    | Src=item, Sel=!Sel =>         SetRange 1
		// Mouse Pressed:       Shift  | n/a    | Dst=item, Sel=1,   => Clear + SetRange 1
		// Mouse Pressed:  Ctrl+Shift  | n/a    | Dst=item, Sel=!Sel =>         SetRange Src-Dst
		//----------------------------------------------------------------------------------------

		if (flags & ImGuiMultiSelectFlags_.ImGuiMultiSelectFlags_NoAutoClear) == {} {
			request_clear : bool = false
			if is_singleselect { request_clear = true }
			else if (input_source == ImGuiInputSource.ImGuiInputEventType_Mouse || g.NavActivateId == id) && !is_ctrl { request_clear = (flags & ImGuiMultiSelectFlags_.ImGuiMultiSelectFlags_NoAutoClearOnReselect) != {} ? !selected : true }
			else if (input_source == ImGuiInputSource.ImGuiInputSource_Keyboard || input_source == ImGuiInputSource.ImGuiInputSource_Gamepad) && is_shift && !is_ctrl {
				// With is_shift==false the RequestClear was done in BeginIO, not necessary to do again.
				request_clear = true
			}
			if request_clear { MultiSelectAddSetAll(ms, false) }
		}

		range_direction : i32
		range_selected : bool
		if is_shift && !is_singleselect {
			//IM_ASSERT(storage->HasRangeSrc && storage->HasRangeValue);
			if storage.RangeSrcItem == ImGuiSelectionUserData_Invalid { storage.RangeSrcItem = item_data }
			if (flags & ImGuiMultiSelectFlags_.ImGuiMultiSelectFlags_NoAutoSelect) == {} {
				// Shift+Arrow always select
				// Ctrl+Shift+Arrow copy source selection state (already stored by BeginMultiSelect() in storage->RangeSelected)
				range_selected = (is_ctrl && storage.RangeSelected != -1) ? (storage.RangeSelected != 0) : true
			}
			else {
				// Shift+Arrow copy source selection state
				// Shift+Click always copy from target selection state
				if ms.IsKeyboardSetRange { range_selected = (storage.RangeSelected != -1) ? (storage.RangeSelected != 0) : true }
				else { range_selected = !selected }
			}
			range_direction = ms.RangeSrcPassedBy ? +1 : -1
		}
		else {
			// Ctrl inverts selection, otherwise always select
			if (flags & ImGuiMultiSelectFlags_.ImGuiMultiSelectFlags_NoAutoSelect) == {} { selected = is_ctrl ? !selected : true }
			else { selected = !selected }
			storage.RangeSrcItem = item_data
			range_selected = selected
			range_direction = +1
		}
		MultiSelectAddSetRange(ms, range_selected, range_direction, storage.RangeSrcItem, item_data)
	}

	// Update/store the selection state of the Source item (used by CTRL+SHIFT, when Source is unselected we perform a range unselect)
	if storage.RangeSrcItem == item_data { storage.RangeSelected = selected ? 1 : 0 }

	// Update/store the selection state of focused item
	if g.NavId == id {
		storage.NavIdItem = item_data
		storage.NavIdSelected = selected ? 1 : 0
	}
	if storage.NavIdItem == item_data { ms.NavIdPassedBy = true }
	ms.LastSubmittedItem = item_data

	p_selected^ = selected
	p_pressed^ = pressed
}

MultiSelectAddSetAll :: proc(ms : ^ImGuiMultiSelectTempData, selected : bool)
{
	req : ImGuiSelectionRequest = {ImGuiSelectionRequestType.ImGuiSelectionRequestType_SetAll, selected, 0, ImGuiSelectionUserData_Invalid, ImGuiSelectionUserData_Invalid}
	resize(&ms.IO.Requests, 0); // Can always clear previous requests
	push_back(&ms.IO.Requests, req); // Add new request
}

MultiSelectAddSetRange :: proc(ms : ^ImGuiMultiSelectTempData, selected : bool, range_dir : i32, first_item : ImGuiSelectionUserData, last_item : ImGuiSelectionUserData)
{
	// Merge contiguous spans into same request (unless NoRangeSelect is set which guarantees single-item ranges)
	if ms.IO.Requests.Size > 0 && first_item == last_item && (ms.Flags & ImGuiMultiSelectFlags_.ImGuiMultiSelectFlags_NoRangeSelect) == {} {
		prev : ^ImGuiSelectionRequest = &ms.IO.Requests.Data[ms.IO.Requests.Size - 1]
		if prev.Type == ImGuiSelectionRequestType.ImGuiSelectionRequestType_SetRange && prev.RangeLastItem == ms.LastSubmittedItem && prev.Selected == selected {
			prev.RangeLastItem = last_item
			return
		}
	}

	req : ImGuiSelectionRequest = {ImGuiSelectionRequestType.ImGuiSelectionRequestType_SetRange, selected, cast(ImS8) range_dir, (range_dir > 0) ? first_item : last_item, (range_dir > 0) ? last_item : first_item}
	push_back(&ms.IO.Requests, req); // Add new request
}

DebugNodeMultiSelectState :: proc(storage : ^ImGuiMultiSelectState)
{
	when ! IMGUI_DISABLE_DEBUG_TOOLS { /* @gen ifndef */
	is_active : bool = (storage.LastFrameActive >= GetFrameCount() - 2); // Note that fully clipped early out scrolling tables will appear as inactive here.
	if !is_active { PushStyleColor(ImGuiCol_.ImGuiCol_Text, GetStyleColorVec4(ImGuiCol_.ImGuiCol_TextDisabled)) }
	open : bool = TreeNode(cast(rawptr) cast(uintptr) storage.ID, "MultiSelect 0x%08X in '%s'%s", storage.ID, storage.Window != nil ? storage.Window.Name : "N/A", is_active ? "" : " *Inactive*")
	if !is_active { PopStyleColor() }
	if !open { return }
	Text("), RangeSelected = %d", storage.RangeSrcItem, storage.RangeSrcItem, storage.RangeSelected)
	Text("), NavIdSelected = %d", storage.NavIdItem, storage.NavIdItem, storage.NavIdSelected)
	Text("LastSelectionSize = %d", storage.LastSelectionSize); // Provided by user
	TreePop()
	} else { // preproc else
	IM_UNUSED(storage)
	} // preproc endif
}

//-------------------------------------------------------------------------
// [SECTION] Widgets: Multi-Select helpers
//-------------------------------------------------------------------------
// - ImGuiSelectionBasicStorage
// - ImGuiSelectionExternalStorage
//-------------------------------------------------------------------------

ImGuiSelectionBasicStorage_init :: proc(this : ^ImGuiSelectionBasicStorage)
{
	init(&this._Storage)
	this.Size = 0
	this.PreserveOrder = false
	this.UserData = nil
	this.AdapterIndexToStorageId = proc(_ : ^ImGuiSelectionBasicStorage, idx : i32) -> ImGuiID { return cast(ImGuiID) idx }
	this._SelectionOrder = 1; // Always >0
}

// Clear selection
ImGuiSelectionBasicStorage_Clear :: proc(this : ^ImGuiSelectionBasicStorage)
{
	this.Size = 0
	this._SelectionOrder = 1; // Always >0
	resize(&this._Storage.Data, 0)
}

// Swap two selections
ImGuiSelectionBasicStorage_Swap :: proc(this : ^ImGuiSelectionBasicStorage, r : ^ImGuiSelectionBasicStorage)
{
	ImSwap(&this.Size, &r.Size)
	ImSwap(&this._SelectionOrder, &r._SelectionOrder)
	swap(&this._Storage.Data, &r._Storage.Data)
}

// Query if an item id is in selection.
ImGuiSelectionBasicStorage_Contains :: proc(this : ^ImGuiSelectionBasicStorage, id : ImGuiID) -> bool
{
	return GetInt(&this._Storage, id, 0) != 0
}

PairComparerByValueInt :: proc(lhs, rhs : ImGuiStoragePair) -> slice.Ordering
{
	lhs_v : i32 = lhs.val_i
	rhs_v : i32 = rhs.val_i
	return lhs_v > rhs_v ? .Greater : lhs_v < rhs_v ? .Less : .Equal
}

// Iterate selection with 'void* it = NULL; ImGuiID id; while (selection.GetNextSelectedItem(&it, &id)) { ... }'
// GetNextSelectedItem() is an abstraction allowing us to change our underlying actual storage system without impacting user.
// (e.g. store unselected vs compact down, compact down on demand, use raw ImVector<ImGuiID> instead of ImGuiStorage...)
ImGuiSelectionBasicStorage_GetNextSelectedItem :: proc(this : ^ImGuiSelectionBasicStorage, opaque_it : ^rawptr, out_id : ^ImGuiID) -> bool
{
	it : [^]ImGuiStoragePair = cast([^]ImGuiStoragePair) opaque_it^
	it_end : ^ImGuiStoragePair = &this._Storage.Data.Data[this._Storage.Data.Size]
	if this.PreserveOrder && it == nil && it_end != nil {
		// ~ImGuiStorage::BuildSortByValueInt()
		ImQsort(this._Storage.Data.Data[:this._Storage.Data.Size], PairComparerByValueInt)
	}
	if it == nil { it = this._Storage.Data.Data }
	IM_ASSERT(it >= this._Storage.Data.Data && it <= it_end)
	if it != it_end { for it[0].val_i == 0 && it < it_end { post_incr(&it) } }
	has_more : bool = (it != it_end)
	opaque_it^ = has_more ? cast(^rawptr) (&it[1]) : cast(^rawptr) (it)
	out_id^ = has_more ? it[0].key : 0
	if this.PreserveOrder && !has_more { BuildSortByKey(&this._Storage) }
	return has_more
}

// Add/remove an item from selection (generally done by ApplyRequests() function)
ImGuiSelectionBasicStorage_SetItemSelected :: proc(this : ^ImGuiSelectionBasicStorage, id : ImGuiID, selected : bool)
{
	p_int : ^i32 = GetIntRef(&this._Storage, id, 0)
	if selected && p_int^ == 0 {p_int^ = post_incr(&this._SelectionOrder); post_incr(&this.Size)
	}
	else if !selected && p_int^ != 0 {p_int^ = 0; post_decr(&this.Size)
	}
}

// Optimized for batch edits (with same value of 'selected')
ImGuiSelectionBasicStorage_BatchSetItemSelected :: proc(selection : ^ImGuiSelectionBasicStorage, id : ImGuiID, selected : bool, size_before_amends : i32, selection_order : i32)
{
	storage : ^ImGuiStorage = &selection._Storage
	it : ^ImGuiStoragePair = ImLowerBound(storage.Data.Data, &storage.Data.Data[size_before_amends], id)
	is_contained : bool = (it != &storage.Data.Data[size_before_amends]) && (it.key == id)
	if selected == (is_contained && it.val_i != 0) { return }
	if selected && !is_contained {
		// Push unsorted at end of vector, will be sorted in SelectionMultiAmendsFinish()
		v : ImGuiStoragePair
		init(&v, id, selection_order)
		push_back(&storage.Data, v)
	}
	else if is_contained {
		// Modify in-place.
		it.val_i = selected ? selection_order : 0
	}
	selection.Size += selected ? +1 : -1
}

ImGuiSelectionBasicStorage_BatchFinish :: proc(selection : ^ImGuiSelectionBasicStorage, selected : bool, size_before_amends : i32)
{
	storage : ^ImGuiStorage = &selection._Storage
	if selected && selection.Size != size_before_amends {
		// When done selecting: sort everything
		BuildSortByKey(storage)
	}
}

// Apply selection requests coming from BeginMultiSelect() and EndMultiSelect() functions. It uses 'items_count' passed to BeginMultiSelect()
// Apply requests coming from BeginMultiSelect() and EndMultiSelect().
// - Enable 'Demo->Tools->Debug Log->Selection' to see selection requests as they happen.
// - Honoring SetRange requests requires that you can iterate/interpolate between RangeFirstItem and RangeLastItem.
//   - In this demo we often submit indices to SetNextItemSelectionUserData() + store the same indices in persistent selection.
//   - Your code may do differently. If you store pointers or objects ID in ImGuiSelectionUserData you may need to perform
//     a lookup in order to have some way to iterate/interpolate between two items.
// - A full-featured application is likely to allow search/filtering which is likely to lead to using indices
//   and constructing a view index <> object id/ptr data structure anyway.
// WHEN YOUR APPLICATION SETTLES ON A CHOICE, YOU WILL PROBABLY PREFER TO GET RID OF THIS UNNECESSARY 'ImGuiSelectionBasicStorage' INDIRECTION LOGIC.
// Notice that with the simplest adapter (using indices everywhere), all functions return their parameters.
// The most simple implementation (using indices everywhere) would look like:
//   for (ImGuiSelectionRequest& req : ms_io->Requests)
//   {
//      if (req.Type == ImGuiSelectionRequestType_SetAll)    { Clear(); if (req.Selected) { for (int n = 0; n < items_count; n++) { SetItemSelected(n, true); } }
//      if (req.Type == ImGuiSelectionRequestType_SetRange)  { for (int n = (int)ms_io->RangeFirstItem; n <= (int)ms_io->RangeLastItem; n++) { SetItemSelected(n, ms_io->Selected); } }
//   }
ImGuiSelectionBasicStorage_ApplyRequests :: proc(this : ^ImGuiSelectionBasicStorage, ms_io : ^ImGuiMultiSelectIO)
{
	// For convenience we obtain ItemsCount as passed to BeginMultiSelect(), which is optional.
	// It makes sense when using ImGuiSelectionBasicStorage to simply pass your items count to BeginMultiSelect().
	// Other scheme may handle SetAll differently.
	IM_ASSERT(ms_io.ItemsCount != -1, "Missing value for items_count in BeginMultiSelect() call!")
	IM_ASSERT(this.AdapterIndexToStorageId != nil)

	// This is optimized/specialized to cope with very large selections (e.g. 100k+ items)
	// - A simpler version could call SetItemSelected() directly instead of ImGuiSelectionBasicStorage_BatchSetItemSelected() + ImGuiSelectionBasicStorage_BatchFinish().
	// - Optimized select can append unsorted, then sort in a second pass. Optimized unselect can clear in-place then compact in a second pass.
	// - A more optimal version wouldn't even use ImGuiStorage but directly a ImVector<ImGuiID> to reduce bandwidth, but this is a reasonable trade off to reuse code.
	// - There are many ways this could be better optimized. The worse case scenario being: using BoxSelect2d in a grid, box-select scrolling down while wiggling
	//   left and right: it affects coarse clipping + can emit multiple SetRange with 1 item each.)
	// FIXME-OPT: For each block of consecutive SetRange request:
	// - add all requests to a sorted list, store ID, selected, offset in ImGuiStorage.
	// - rewrite sorted storage a single time.
	for req in ms_io.Requests.Data[:ms_io.Requests.Size] {
		if req.Type == ImGuiSelectionRequestType.ImGuiSelectionRequestType_SetAll {
			ImGuiSelectionBasicStorage_Clear(this)
			if req.Selected {
				reserve(&this._Storage.Data, ms_io.ItemsCount)
				size_before_amends : i32 = this._Storage.Data.Size
				for idx : i32 = 0; idx < ms_io.ItemsCount; idx, this._SelectionOrder = idx + 1, this._SelectionOrder + 1 { ImGuiSelectionBasicStorage_BatchSetItemSelected(this, ImGuiSelectionBasicStorage_GetStorageIdFromIndex(this, idx), req.Selected, size_before_amends, this._SelectionOrder) }

				ImGuiSelectionBasicStorage_BatchFinish(this, req.Selected, size_before_amends)
			}
		}
		else if req.Type == ImGuiSelectionRequestType.ImGuiSelectionRequestType_SetRange {
			selection_changes : i32 = cast(i32) req.RangeLastItem - cast(i32) req.RangeFirstItem + 1
			//ImGuiContext& g = *GImGui; IMGUI_DEBUG_LOG_SELECTION(g, "Req %d/%d: set %d to %d\n", ms_io->Requests.index_from_ptr(&req), ms_io->Requests.Size, selection_changes, req.Selected);
			if selection_changes == 1 || (selection_changes < this.Size / 100) {
				// Multiple sorted insertion + copy likely to be faster.
				// Technically we could do a single copy with a little more work (sort sequential SetRange requests)
				for idx : i32 = cast(i32) req.RangeFirstItem; idx <= cast(i32) req.RangeLastItem; idx += 1 { ImGuiSelectionBasicStorage_SetItemSelected(this, ImGuiSelectionBasicStorage_GetStorageIdFromIndex(this, idx), req.Selected) }
			}
			else {
				// Append insertion + single sort likely be faster.
				// Use req.RangeDirection to set order field so that shift+clicking from 1 to 5 is different than shift+clicking from 5 to 1
				size_before_amends : i32 = this._Storage.Data.Size
				selection_order : i32 = this._SelectionOrder + ((req.RangeDirection < 0) ? selection_changes - 1 : 0)
				for idx : i32 = cast(i32) req.RangeFirstItem; idx <= cast(i32) req.RangeLastItem; idx, selection_order = idx + 1, selection_order + i32(req.RangeDirection) { ImGuiSelectionBasicStorage_BatchSetItemSelected(this, ImGuiSelectionBasicStorage_GetStorageIdFromIndex(this, idx), req.Selected, size_before_amends, selection_order) }

				if req.Selected { this._SelectionOrder += selection_changes }
				ImGuiSelectionBasicStorage_BatchFinish(this, req.Selected, size_before_amends)
			}
		}
	}
}

//-------------------------------------------------------------------------

ImGuiSelectionExternalStorage_init :: proc(this : ^ImGuiSelectionExternalStorage)
{
	this.UserData = nil
	this.AdapterSetItemSelected = nil
}

// Apply selection requests by using AdapterSetItemSelected() calls
// Apply requests coming from BeginMultiSelect() and EndMultiSelect().
// We also pull 'ms_io->ItemsCount' as passed for BeginMultiSelect() for consistency with ImGuiSelectionBasicStorage
// This makes no assumption about underlying storage.
ImGuiSelectionExternalStorage_ApplyRequests :: proc(this : ^ImGuiSelectionExternalStorage, ms_io : ^ImGuiMultiSelectIO)
{
	IM_ASSERT(this.AdapterSetItemSelected != nil)
	for req in ms_io.Requests.Data[:ms_io.Requests.Size] {
		if req.Type == ImGuiSelectionRequestType.ImGuiSelectionRequestType_SetAll { for idx : i32 = 0; idx < ms_io.ItemsCount; idx += 1 { this.AdapterSetItemSelected(this, idx, req.Selected) } }
		if req.Type == ImGuiSelectionRequestType.ImGuiSelectionRequestType_SetRange { for idx : i32 = cast(i32) req.RangeFirstItem; idx <= cast(i32) req.RangeLastItem; idx += 1 { this.AdapterSetItemSelected(this, idx, req.Selected) } }
	}
}

//-------------------------------------------------------------------------
// [SECTION] Widgets: ListBox
//-------------------------------------------------------------------------
// - BeginListBox()
// - EndListBox()
// - ListBox()
//-------------------------------------------------------------------------

// This is essentially a thin wrapper to using BeginChild/EndChild with the ImGuiChildFlags_FrameStyle flag for stylistic changes + displaying a label.
// This handle some subtleties with capturing info from the label.
// If you don't need a label you can pretty much directly use ImGui::BeginChild() with ImGuiChildFlags_FrameStyle.
// Tip: To have a list filling the entire window width, use size.x = -FLT_MIN and pass an non-visible label e.g. "##empty"
// Tip: If your vertical size is calculated from an item count (e.g. 10 * item_height) consider adding a fractional part to facilitate seeing scrolling boundaries (e.g. 10.5f * item_height).
BeginListBox :: proc(label : string, size_arg : ImVec2) -> bool
{
	g : ^ImGuiContext = GImGui
	window : ^ImGuiWindow = GetCurrentWindow()
	if window.SkipItems { return false }

	style : ^ImGuiStyle = &g.Style
	id : ImGuiID = GetID(label)
	label_size : ImVec2 = CalcTextSize(label, true)

	// Size default to hold ~7.25 items.
	// Fractional number of items helps seeing that we can scroll down/up without looking at scrollbar.
	size : ImVec2 = ImTrunc(CalcItemSize(size_arg, CalcItemWidth(), GetTextLineHeightWithSpacing() * 7.25 + style.FramePadding.y * 2.0))
	frame_size : ImVec2 = ImVec2{size.x, ImMax(size.y, label_size.y)}
	frame_bb : ImRect; init(&frame_bb, window.DC.CursorPos, window.DC.CursorPos + frame_size)
	bb : ImRect; init(&bb, frame_bb.Min, frame_bb.Max + ImVec2{label_size.x > 0.0 ? style.ItemInnerSpacing.x + label_size.x : 0.0, 0.0})
	ClearFlags(&g.NextItemData)

	if !IsRectVisible(bb.Min, bb.Max) {
		ItemSize(GetSize(bb), style.FramePadding.y)
		ItemAdd(bb, 0, &frame_bb)
		ClearFlags(&g.NextWindowData); // We behave like Begin() and need to consume those values
		return false
	}

	// FIXME-OPT: We could omit the BeginGroup() if label_size.x == 0.0f but would need to omit the EndGroup() as well.
	BeginGroup()
	if label_size.x > 0.0 {
		label_pos : ImVec2 = ImVec2{frame_bb.Max.x + style.ItemInnerSpacing.x, frame_bb.Min.y + style.FramePadding.y}
		RenderText(label_pos, label)
		window.DC.CursorMaxPos = ImMax(window.DC.CursorMaxPos, label_pos + label_size)
		AlignTextToFramePadding()
	}

	BeginChild(id, GetSize(frame_bb), ImGuiChildFlags_.ImGuiChildFlags_FrameStyle)
	return true
}

EndListBox :: proc()
{
	g : ^ImGuiContext = GImGui
	window : ^ImGuiWindow = g.CurrentWindow
	IM_ASSERT((window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_ChildWindow) != {}, "Mismatched BeginListBox/EndListBox calls. Did you test the return value of BeginListBox?")
	IM_UNUSED(window)

	EndChild()
	EndGroup(); // This is only required to be able to do IsItemXXX query on the whole ListBox including label
}

ListBox_0 :: proc(label : string, current_item : ^i32, items : [^]^u8, items_count : i32, height_items : i32) -> bool
{
	value_changed : bool = ListBox(label, current_item, Items_ArrayGetter, cast(rawptr) items, items_count, height_items)
	return value_changed
}

// This is merely a helper around BeginListBox(), EndListBox().
// Considering using those directly to submit custom data or store selection differently.
ListBox_1 :: proc(label : string, current_item : ^i32, getter : proc(user_data : rawptr, idx : i32) -> string, user_data : rawptr, items_count : i32, height_in_items : i32) -> bool
{
	g : ^ImGuiContext = GImGui

	height_in_items := height_in_items
	// Calculate size from "height_in_items"
	if height_in_items < 0 { height_in_items = ImMin(items_count, 7) }
	height_in_items_f : f32 = f32(height_in_items) + 0.25
	size := ImVec2{ 0.0, ImTrunc(GetTextLineHeightWithSpacing() * height_in_items_f + g.Style.FramePadding.y * 2.0) }

	if !BeginListBox(label, size) { return false }

	// Assume all items have even height (= 1 line of text). If you need items of different height,
	// you can create a custom version of ListBox() in your code without using the clipper.
	value_changed : bool = false
	clipper : ImGuiListClipper
	Begin(&clipper, items_count, GetTextLineHeightWithSpacing()); // We know exactly our line height here so we pass it as a minor optimization, but generally you don't need to.
	IncludeItemByIndex(&clipper, current_item^)
	for Step(&clipper) { for i : i32 = clipper.DisplayStart; i < clipper.DisplayEnd; i += 1 {
	item_text := getter(user_data, i)
	if item_text == "" { item_text = "*Unknown item*" }

	PushID(i)
	item_selected : bool = (i == current_item^)
	if Selectable(item_text, item_selected) {
		current_item^ = i
		value_changed = true
	}
	if item_selected { SetItemDefaultFocus() }
	PopID()
} }

	EndListBox()

	if value_changed { MarkItemEdited(g.LastItemData.ID) }

	return value_changed
}

//-------------------------------------------------------------------------
// [SECTION] Widgets: PlotLines, PlotHistogram
//-------------------------------------------------------------------------
// - PlotEx() [Internal]
// - PlotLines()
// - PlotHistogram()
//-------------------------------------------------------------------------
// Plot/Graph widgets are not very good.
// Consider writing your own, or using a third-party one, see:
// - ImPlot https://github.com/epezent/implot
// - others https://github.com/ocornut/imgui/wiki/Useful-Extensions
//-------------------------------------------------------------------------

PlotEx :: proc(plot_type : ImGuiPlotType, label : string, values_getter : proc(data : rawptr, idx : i32) -> f32, data : rawptr, values_count : i32, values_offset : i32, overlay_text : string, scale_min : f32, scale_max : f32, size_arg : ImVec2) -> i32
{
	g : ^ImGuiContext = GImGui
	window : ^ImGuiWindow = GetCurrentWindow()
	if window.SkipItems { return -1 }

	style : ^ImGuiStyle = &g.Style
	id : ImGuiID = GetID(window, label)

	label_size : ImVec2 = CalcTextSize(label, true)
	frame_size : ImVec2 = CalcItemSize(size_arg, CalcItemWidth(), label_size.y + style.FramePadding.y * 2.0)

	frame_bb : ImRect; init(&frame_bb, window.DC.CursorPos, window.DC.CursorPos + frame_size)
	inner_bb : ImRect; init(&inner_bb, frame_bb.Min + style.FramePadding, frame_bb.Max - style.FramePadding)
	total_bb : ImRect; init(&total_bb, frame_bb.Min, frame_bb.Max + ImVec2{label_size.x > 0.0 ? style.ItemInnerSpacing.x + label_size.x : 0.0, 0})
	ItemSize(total_bb, style.FramePadding.y)
	if !ItemAdd(total_bb, id, &frame_bb, ImGuiItemFlags_.ImGuiItemFlags_NoNav) { return -1 }
	hovered : bool
	ButtonBehavior(frame_bb, id, &hovered, nil)

	scale_min, scale_max := scale_min, scale_max
	// Determine scale from values if not specified
	if scale_min == FLT_MAX || scale_max == FLT_MAX {
		v_min : f32 = FLT_MAX
		v_max : f32 = -FLT_MAX
		for i : i32 = 0; i < values_count; i += 1 {
			v : f32 = values_getter(data, i)
			if v != v {
				// Ignore NaN values
				continue
			}
			v_min = ImMin(v_min, v)
			v_max = ImMax(v_max, v)
		}

		if scale_min == FLT_MAX { scale_min = v_min }
		if scale_max == FLT_MAX { scale_max = v_max }
	}

	RenderFrame(frame_bb.Min, frame_bb.Max, GetColorU32(ImGuiCol_.ImGuiCol_FrameBg), true, style.FrameRounding)

	values_count_min : i32 = (plot_type == ImGuiPlotType.ImGuiPlotType_Lines) ? 2 : 1
	idx_hovered : i32 = -1
	if values_count >= values_count_min {
		res_w : i32 = ImMin(cast(i32) frame_size.x, values_count) + ((plot_type == ImGuiPlotType.ImGuiPlotType_Lines) ? -1 : 0)
		item_count : i32 = values_count + ((plot_type == ImGuiPlotType.ImGuiPlotType_Lines) ? -1 : 0)

		// Tooltip on hover
		if hovered && Contains(inner_bb, g.IO.MousePos) {
			t : f32 = ImClamp((g.IO.MousePos.x - inner_bb.Min.x) / (inner_bb.Max.x - inner_bb.Min.x), 0.0, 0.9999)
			v_idx : i32 = cast(i32) (t * f32(item_count))
			IM_ASSERT(v_idx >= 0 && v_idx < values_count)

			v0 : f32 = values_getter(data, (v_idx + values_offset) % values_count)
			v1 : f32 = values_getter(data, (v_idx + 1 + values_offset) % values_count)
			if plot_type == ImGuiPlotType.ImGuiPlotType_Lines { SetTooltip("%d: %8.4g\n%d: %8.4g", v_idx, v0, v_idx + 1, v1) }
			else if plot_type == ImGuiPlotType.ImGuiPlotType_Histogram { SetTooltip("%d: %8.4g", v_idx, v0) }
			idx_hovered = v_idx
		}

		t_step : f32 = 1.0 / cast(f32) res_w
		inv_scale : f32 = (scale_min == scale_max) ? 0.0 : (1.0 / (scale_max - scale_min))

		v0 : f32 = values_getter(data, (0 + values_offset) % values_count)
		t0 : f32 = 0.0
		tp0 : ImVec2 = ImVec2{t0, 1.0 - ImSaturate((v0 - scale_min) * inv_scale)}; // Point in the normalized space of our target rectangle
		histogram_zero_line_t : f32 = (scale_min * scale_max < 0.0) ? (1 + scale_min * inv_scale) : (scale_min < 0.0 ? 0.0 : 1.0); // Where does the zero line stands

		col_base : ImU32 = GetColorU32((plot_type == ImGuiPlotType.ImGuiPlotType_Lines) ? ImGuiCol_.ImGuiCol_PlotLines : ImGuiCol_.ImGuiCol_PlotHistogram)
		col_hovered : ImU32 = GetColorU32((plot_type == ImGuiPlotType.ImGuiPlotType_Lines) ? ImGuiCol_.ImGuiCol_PlotLinesHovered : ImGuiCol_.ImGuiCol_PlotHistogramHovered)

		for n : i32 = 0; n < res_w; n += 1 {
			t1 : f32 = t0 + t_step
			v1_idx : i32 = cast(i32) (t0 * f32(item_count) + 0.5)
			IM_ASSERT(v1_idx >= 0 && v1_idx < values_count)
			v1 : f32 = values_getter(data, (v1_idx + values_offset + 1) % values_count)
			tp1 : ImVec2 = ImVec2{t1, 1.0 - ImSaturate((v1 - scale_min) * inv_scale)}

			// NB: Draw calls are merged together by the DrawList system. Still, we should render our batch are lower level to save a bit of CPU.
			pos0 : ImVec2 = ImLerp(inner_bb.Min, inner_bb.Max, tp0)
			pos1 : ImVec2 = ImLerp(inner_bb.Min, inner_bb.Max, (plot_type == ImGuiPlotType.ImGuiPlotType_Lines) ? tp1 : ImVec2{tp1.x, histogram_zero_line_t})
			if plot_type == ImGuiPlotType.ImGuiPlotType_Lines {
				AddLine(window.DrawList, pos0, pos1, idx_hovered == v1_idx ? col_hovered : col_base)
			}
			else if plot_type == ImGuiPlotType.ImGuiPlotType_Histogram {
				if pos1.x >= pos0.x + 2.0 { pos1.x -= 1.0 }
				AddRectFilled(window.DrawList, pos0, pos1, idx_hovered == v1_idx ? col_hovered : col_base)
			}

			t0 = t1
			tp0 = tp1
		}
	}

	// Text overlay
	if overlay_text != "" { RenderTextClipped(ImVec2{frame_bb.Min.x, frame_bb.Min.y + style.FramePadding.y}, frame_bb.Max, overlay_text, nil, &ImVec2{0.5, 0.0}) }

	if label_size.x > 0.0 { RenderText(ImVec2{frame_bb.Max.x + style.ItemInnerSpacing.x, inner_bb.Min.y}, label) }

	// Return hovered index or -1 if none are hovered.
	// This is currently not exposed in the public API because we need a larger redesign of the whole thing, but in the short-term we are making it available in PlotEx().
	return idx_hovered
}

ImGuiPlotArrayGetterData :: struct {
	Values : ^f32,
	Stride : i32,
}

ImGuiPlotArrayGetterData_init :: proc(this : ^ImGuiPlotArrayGetterData, values : ^f32, stride : i32)
{
	this.Values = values; this.Stride = stride
}

Plot_ArrayGetter :: proc(data : rawptr, idx : i32) -> f32
{
	plot_data : ^ImGuiPlotArrayGetterData = cast(^ImGuiPlotArrayGetterData) data
	v : f32 = (cast(^f32) &((cast([^]u8)plot_data.Values)[cast(uint) (idx * plot_data.Stride)]))^
	return v
}

PlotLines_0 :: proc(label : string, values : ^f32, values_count : i32, values_offset : i32, overlay_text : string, scale_min : f32, scale_max : f32, graph_size : ImVec2, stride : i32)
{
	data : ImGuiPlotArrayGetterData; init(&data, values, stride)
	PlotEx(ImGuiPlotType.ImGuiPlotType_Lines, label, Plot_ArrayGetter, cast(rawptr) &data, values_count, values_offset, overlay_text, scale_min, scale_max, graph_size)
}

PlotLines_1 :: proc(label : string, values_getter : proc(data : rawptr, idx : i32) -> f32, data : rawptr, values_count : i32, values_offset : i32, overlay_text : string, scale_min : f32, scale_max : f32, graph_size : ImVec2)
{
	PlotEx(ImGuiPlotType.ImGuiPlotType_Lines, label, values_getter, data, values_count, values_offset, overlay_text, scale_min, scale_max, graph_size)
}

PlotHistogram_0 :: proc(label : string, values : ^f32, values_count : i32, values_offset : i32, overlay_text : string, scale_min : f32, scale_max : f32, graph_size : ImVec2, stride : i32)
{
	data : ImGuiPlotArrayGetterData; init(&data, values, stride)
	PlotEx(ImGuiPlotType.ImGuiPlotType_Histogram, label, Plot_ArrayGetter, cast(rawptr) &data, values_count, values_offset, overlay_text, scale_min, scale_max, graph_size)
}

PlotHistogram_1 :: proc(label : string, values_getter : proc(data : rawptr, idx : i32) -> f32, data : rawptr, values_count : i32, values_offset : i32, overlay_text : string, scale_min : f32, scale_max : f32, graph_size : ImVec2)
{
	PlotEx(ImGuiPlotType.ImGuiPlotType_Histogram, label, values_getter, data, values_count, values_offset, overlay_text, scale_min, scale_max, graph_size)
}

//-------------------------------------------------------------------------
// [SECTION] Widgets: Value helpers
// Those is not very useful, legacy API.
//-------------------------------------------------------------------------
// - Value()
//-------------------------------------------------------------------------

Value_0 :: proc(prefix : ^u8, b : bool)
{
	Text("%s: %s", prefix, (b ? "true" : "false"))
}

Value_1 :: proc(prefix : ^u8, v : i32)
{
	Text("%s: %d", prefix, v)
}

Value_2 :: proc(prefix : ^u8, v : u32)
{
	Text("%s: %d", prefix, v)
}

Value_3 :: proc(prefix : ^u8, v : f32, float_format : ^u8)
{
	if float_format != nil {
		fmt : [64]u8
		l := ImFormatString(fmt[:], "%%s: %s", float_format)
		Text(string_from_slice(fmt[:l], false), prefix, v)
	}
	else {
		Text("%s: %.3f", prefix, v)
	}
}

//-------------------------------------------------------------------------
// [SECTION] MenuItem, BeginMenu, EndMenu, etc.
//-------------------------------------------------------------------------
// - ImGuiMenuColumns [Internal]
// - BeginMenuBar()
// - EndMenuBar()
// - BeginMainMenuBar()
// - EndMainMenuBar()
// - BeginMenu()
// - EndMenu()
// - MenuItemEx() [Internal]
// - MenuItem()
//-------------------------------------------------------------------------

// Helpers for internal use
ImGuiMenuColumns_Update :: proc(this : ^ImGuiMenuColumns, spacing : f32, window_reappearing : bool)
{
	if window_reappearing { this.Widths = 0 }
	this.Spacing = cast(ImU16) spacing
	ImGuiMenuColumns_CalcNextTotalWidth(this, true)
	this.Widths = 0
	this.TotalWidth = this.NextTotalWidth
	this.NextTotalWidth = 0
}

ImGuiMenuColumns_CalcNextTotalWidth :: proc(this : ^ImGuiMenuColumns, update_offsets : bool)
{
	offset : ImU16 = 0
	want_spacing : bool = false
	for i : i32 = 0; i < cast(i32)IM_ARRAYSIZE(this.Widths); i += 1 {
		width : ImU16 = this.Widths[i]
		if want_spacing && width > 0 { offset += this.Spacing }
		want_spacing |= (width > 0)
		if update_offsets {
			if i == 1 { this.OffsetLabel = offset }
			if i == 2 { this.OffsetShortcut = offset }
			if i == 3 { this.OffsetMark = offset }
		}
		offset += width
	}

	this.NextTotalWidth = u32(offset)
}

ImGuiMenuColumns_DeclColumns :: proc(this : ^ImGuiMenuColumns, w_icon : f32, w_label : f32, w_shortcut : f32, w_mark : f32) -> f32
{
	this.Widths[0] = ImMax(this.Widths[0], cast(ImU16) w_icon)
	this.Widths[1] = ImMax(this.Widths[1], cast(ImU16) w_label)
	this.Widths[2] = ImMax(this.Widths[2], cast(ImU16) w_shortcut)
	this.Widths[3] = ImMax(this.Widths[3], cast(ImU16) w_mark)
	ImGuiMenuColumns_CalcNextTotalWidth(this, false)
	return cast(f32) ImMax(this.TotalWidth, this.NextTotalWidth)
}

// FIXME: Provided a rectangle perhaps e.g. a BeginMenuBarEx() could be used anywhere..
// Currently the main responsibility of this function being to setup clip-rect + horizontal layout + menu navigation layer.
// Ideally we also want this to be responsible for claiming space out of the main window scrolling rectangle, in which case ImGuiWindowFlags_MenuBar will become unnecessary.
// Then later the same system could be used for multiple menu-bars, scrollbars, side-bars.
BeginMenuBar :: proc() -> bool
{
	window : ^ImGuiWindow = GetCurrentWindow()
	if window.SkipItems { return false }
	if (window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_MenuBar) == {} { return false }

	IM_ASSERT(!window.DC.MenuBarAppending)
	BeginGroup(); // Backup position on layer 0 // FIXME: Misleading to use a group for that backup/restore
	PushID("##menubar")

	// We don't clip with current window clipping rectangle as it is already set to the area below. However we clip with window full rect.
	// We remove 1 worth of rounding to Max.x to that text in long menus and small windows don't tend to display over the lower-right rounded area, which looks particularly glitchy.
	bar_rect : ImRect = MenuBarRect(window)
	clip_rect : ImRect; init(&clip_rect, ImFloor(bar_rect.Min.x + window.WindowBorderSize), ImFloor(bar_rect.Min.y + window.WindowBorderSize), ImFloor(ImMax(bar_rect.Min.x, bar_rect.Max.x - ImMax(window.WindowRounding, window.WindowBorderSize))), ImFloor(bar_rect.Max.y))
	ClipWith(&clip_rect, window.OuterRectClipped)
	PushClipRect(clip_rect.Min, clip_rect.Max, false)

	// We overwrite CursorMaxPos because BeginGroup sets it to CursorPos (essentially the .EmitItem hack in EndMenuBar() would need something analogous here, maybe a BeginGroupEx() with flags).
	window.DC.CursorMaxPos = ImVec2{bar_rect.Min.x + window.DC.MenuBarOffset.x, bar_rect.Min.y + window.DC.MenuBarOffset.y}; window.DC.CursorPos = window.DC.CursorMaxPos
	window.DC.LayoutType = ImGuiLayoutType_.ImGuiLayoutType_Horizontal
	window.DC.IsSameLine = false
	window.DC.NavLayerCurrent = ImGuiNavLayer.ImGuiNavLayer_Menu
	window.DC.MenuBarAppending = true
	AlignTextToFramePadding()
	return true
}

EndMenuBar :: proc()
{
	window : ^ImGuiWindow = GetCurrentWindow()
	if window.SkipItems { return }
	g : ^ImGuiContext = GImGui

	// Nav: When a move request within one of our child menu failed, capture the request to navigate among our siblings.
	if NavMoveRequestButNoResultYet() && (g.NavMoveDir == ImGuiDir.ImGuiDir_Left || g.NavMoveDir == ImGuiDir.ImGuiDir_Right) && (g.NavWindow.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_ChildMenu) != {} {
		// Try to find out if the request is for one of our child menu
		nav_earliest_child : ^ImGuiWindow = g.NavWindow
		for nav_earliest_child.ParentWindow != nil && (nav_earliest_child.ParentWindow.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_ChildMenu) != {} { nav_earliest_child = nav_earliest_child.ParentWindow }

		if nav_earliest_child.ParentWindow == window && nav_earliest_child.DC.ParentLayoutType == ImGuiLayoutType_.ImGuiLayoutType_Horizontal && (g.NavMoveFlags & ImGuiNavMoveFlags_.ImGuiNavMoveFlags_Forwarded) == {} {
			// To do so we claim focus back, restore NavId and then process the movement request for yet another frame.
			// This involve a one-frame delay which isn't very problematic in this situation. We could remove it by scoring in advance for multiple window (probably not worth bothering)
			layer : ImGuiNavLayer = ImGuiNavLayer.ImGuiNavLayer_Menu
			IM_ASSERT((window.DC.NavLayersActiveMaskNext & (1 << u32(layer))) != 0); // Sanity check (FIXME: Seems unnecessary)
			FocusWindow(window)
			SetNavID(window.NavLastIds[layer], layer, 0, window.NavRectRel[layer])
			// FIXME-NAV: How to deal with this when not using g.IO.ConfigNavCursorVisibleAuto?
			if g.NavCursorVisible {
				g.NavCursorVisible = false; // Hide nav cursor for the current frame so we don't see the intermediary selection. Will be set again
				g.NavCursorHideFrames = 2
			}
			g.NavMousePosDirty = true; g.NavHighlightItemUnderNav = g.NavMousePosDirty
			NavMoveRequestForward(g.NavMoveDir, g.NavMoveClipDir, g.NavMoveFlags, g.NavMoveScrollFlags); // Repeat
		}
	}

	IM_ASSERT((window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_MenuBar) != {})
	IM_ASSERT(window.DC.MenuBarAppending)
	PopClipRect()
	PopID()
	window.DC.MenuBarOffset.x = window.DC.CursorPos.x - window.Pos.x; // Save horizontal position so next append can reuse it. This is kinda equivalent to a per-layer CursorPos.

	// FIXME: Extremely confusing, cleanup by (a) working on WorkRect stack system (b) not using a Group confusingly here.
	group_data : ^ImGuiGroupData = back(&g.GroupStack)
	group_data.EmitItem = false
	restore_cursor_max_pos : ImVec2 = group_data.BackupCursorMaxPos
	window.DC.IdealMaxPos.x = ImMax(window.DC.IdealMaxPos.x, window.DC.CursorMaxPos.x - window.Scroll.x); // Convert ideal extents for scrolling layer equivalent.
	EndGroup(); // Restore position on layer 0 // FIXME: Misleading to use a group for that backup/restore
	window.DC.LayoutType = ImGuiLayoutType_.ImGuiLayoutType_Vertical
	window.DC.IsSameLine = false
	window.DC.NavLayerCurrent = ImGuiNavLayer.ImGuiNavLayer_Main
	window.DC.MenuBarAppending = false
	window.DC.CursorMaxPos = restore_cursor_max_pos
}

// Important: calling order matters!
// FIXME: Somehow overlapping with docking tech.
// FIXME: The "rect-cut" aspect of this could be formalized into a lower-level helper (rect-cut: https://halt.software/dead-simple-layouts)
BeginViewportSideBar :: proc(name : string, viewport_p : ^ImGuiViewport, dir : ImGuiDir, axis_size : f32, window_flags : ImGuiWindowFlags) -> bool
{
	IM_ASSERT(dir != ImGuiDir.ImGuiDir_None)

	bar_window : ^ImGuiWindow = FindWindowByName(name)
	viewport : ^ImGuiViewportP = cast(^ImGuiViewportP) cast(rawptr) (viewport_p != nil ? viewport_p : GetMainViewport())
	if bar_window == nil || bar_window.BeginCount == 0 {
		// Calculate and set window size/position
		avail_rect : ImRect = GetBuildWorkRect(viewport)
		axis : ImGuiAxis = (dir == ImGuiDir.ImGuiDir_Up || dir == ImGuiDir.ImGuiDir_Down) ? ImGuiAxis.ImGuiAxis_Y : ImGuiAxis.ImGuiAxis_X
		pos : ImVec2 = avail_rect.Min
		if dir == ImGuiDir.ImGuiDir_Right || dir == ImGuiDir.ImGuiDir_Down { pos[axis] = avail_rect.Max[axis] - axis_size }
		size : ImVec2 = GetSize(avail_rect)
		size[axis] = axis_size
		SetNextWindowPos(pos)
		SetNextWindowSize(size)

		// Report our size into work area (for next frame) using actual window size
		if dir == ImGuiDir.ImGuiDir_Up || dir == ImGuiDir.ImGuiDir_Left { viewport.BuildWorkInsetMin[axis] += axis_size }
		else if dir == ImGuiDir.ImGuiDir_Down || dir == ImGuiDir.ImGuiDir_Right { viewport.BuildWorkInsetMax[axis] += axis_size }
	}

	window_flags := window_flags | ImGuiWindowFlags_.ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_.ImGuiWindowFlags_NoResize | ImGuiWindowFlags_.ImGuiWindowFlags_NoMove | ImGuiWindowFlags_.ImGuiWindowFlags_NoDocking
	SetNextWindowViewport(viewport.ID); // Enforce viewport so we don't create our own viewport when ImGuiConfigFlags_ViewportsNoMerge is set.
	PushStyleVar(ImGuiStyleVar_.ImGuiStyleVar_WindowRounding, 0.0)
	PushStyleVar(ImGuiStyleVar_.ImGuiStyleVar_WindowMinSize, ImVec2{0, 0}); // Lift normal size constraint
	is_open : bool = Begin(name, nil, window_flags)
	PopStyleVar(2)

	return is_open
}

BeginMainMenuBar :: proc() -> bool
{
	g : ^ImGuiContext = GImGui
	viewport : ^ImGuiViewportP = cast(^ImGuiViewportP) cast(rawptr) GetMainViewport()

	// Notify of viewport change so GetFrameHeight() can be accurate in case of DPI change
	SetCurrentViewport(nil, viewport)

	// For the main menu bar, which cannot be moved, we honor g.Style.DisplaySafeAreaPadding to ensure text can be visible on a TV set.
	// FIXME: This could be generalized as an opt-in way to clamp window->DC.CursorStartPos to avoid SafeArea?
	// FIXME: Consider removing support for safe area down the line... it's messy. Nowadays consoles have support for TV calibration in OS settings.
	g.NextWindowData.MenuBarOffsetMinVal = ImVec2{g.Style.DisplaySafeAreaPadding.x, ImMax(g.Style.DisplaySafeAreaPadding.y - g.Style.FramePadding.y, 0.0)}
	window_flags : ImGuiWindowFlags = ImGuiWindowFlags_.ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_.ImGuiWindowFlags_NoSavedSettings | ImGuiWindowFlags_.ImGuiWindowFlags_MenuBar
	height : f32 = GetFrameHeight()
	is_open : bool = BeginViewportSideBar("##MainMenuBar", viewport, ImGuiDir.ImGuiDir_Up, height, window_flags)
	g.NextWindowData.MenuBarOffsetMinVal = ImVec2{0.0, 0.0}

	if is_open { BeginMenuBar() }
	else { End() }
	return is_open
}

EndMainMenuBar :: proc()
{
	EndMenuBar()

	// When the user has left the menu layer (typically: closed menus through activation of an item), we restore focus to the previous window
	// FIXME: With this strategy we won't be able to restore a NULL focus.
	g : ^ImGuiContext = GImGui
	if g.CurrentWindow == g.NavWindow && g.NavLayer == ImGuiNavLayer.ImGuiNavLayer_Main && !g.NavAnyRequest { FocusTopMostWindowUnderOne(g.NavWindow, nil, nil, ImGuiFocusRequestFlags_.ImGuiFocusRequestFlags_UnlessBelowModal | ImGuiFocusRequestFlags_.ImGuiFocusRequestFlags_RestoreFocusedChild) }

	End()
}

IsRootOfOpenMenuSet :: proc() -> bool
{
	g : ^ImGuiContext = GImGui
	window : ^ImGuiWindow = g.CurrentWindow
	if (g.OpenPopupStack.Size <= g.BeginPopupStack.Size) || (window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_ChildMenu) != {} { return false }

	// Initially we used 'upper_popup->OpenParentId == window->IDStack.back()' to differentiate multiple menu sets from each others
	// (e.g. inside menu bar vs loose menu items) based on parent ID.
	// This would however prevent the use of e.g. PushID() user code submitting menus.
	// Previously this worked between popup and a first child menu because the first child menu always had the _ChildWindow flag,
	// making hovering on parent popup possible while first child menu was focused - but this was generally a bug with other side effects.
	// Instead we don't treat Popup specifically (in order to consistently support menu features in them), maybe the first child menu of a Popup
	// doesn't have the _ChildWindow flag, and we rely on this IsRootOfOpenMenuSet() check to allow hovering between root window/popup and first child menu.
	// In the end, lack of ID check made it so we could no longer differentiate between separate menu sets. To compensate for that, we at least check parent window nav layer.
	// This fixes the most common case of menu opening on hover when moving between window content and menu bar. Multiple different menu sets in same nav layer would still
	// open on hover, but that should be a lesser problem, because if such menus are close in proximity in window content then it won't feel weird and if they are far apart
	// it likely won't be a problem anyone runs into.
	upper_popup : ^ImGuiPopupData = &g.OpenPopupStack.Data[g.BeginPopupStack.Size]
	if window.DC.NavLayerCurrent != upper_popup.ParentNavLayer { return false }
	return upper_popup.Window != nil && (upper_popup.Window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_ChildMenu) != {} && IsWindowChildOf(upper_popup.Window, window, true, false)
}

BeginMenuEx :: proc(label : string, icon : string, enabled : bool) -> bool
{
	window : ^ImGuiWindow = GetCurrentWindow()
	if window.SkipItems { return false }

	g : ^ImGuiContext = GImGui
	style : ^ImGuiStyle = &g.Style
	id : ImGuiID = GetID(window, label)
	menu_is_open : bool = IsPopupOpen(id, ImGuiPopupFlags_.ImGuiPopupFlags_None)

	// Sub-menus are ChildWindow so that mouse can be hovering across them (otherwise top-most popup menu would steal focus and not allow hovering on parent menu)
	// The first menu in a hierarchy isn't so hovering doesn't get across (otherwise e.g. resizing borders with ImGuiButtonFlags_FlattenChildren would react), but top-most BeginMenu() will bypass that limitation.
	window_flags : ImGuiWindowFlags = ImGuiWindowFlags_.ImGuiWindowFlags_ChildMenu | ImGuiWindowFlags_.ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_.ImGuiWindowFlags_NoMove | ImGuiWindowFlags_.ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_.ImGuiWindowFlags_NoSavedSettings | ImGuiWindowFlags_.ImGuiWindowFlags_NoNavFocus
	if (window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_ChildMenu) != {} { window_flags |= ImGuiWindowFlags_.ImGuiWindowFlags_ChildWindow }

	// If a menu with same the ID was already submitted, we will append to it, matching the behavior of Begin().
	// We are relying on a O(N) search - so O(N log N) over the frame - which seems like the most efficient for the expected small amount of BeginMenu() calls per frame.
	// If somehow this is ever becoming a problem we can switch to use e.g. ImGuiStorage mapping key to last frame used.
	if contains(g.MenusIdSubmittedThisFrame, id) {
		if menu_is_open {
			// menu_is_open can be 'false' when the popup is completely clipped (e.g. zero size display)
			menu_is_open = BeginPopupEx(id, window_flags)
		}
		else {
			// we behave like Begin() and need to consume those values
			ClearFlags(&g.NextWindowData)
		}
		return menu_is_open
	}

	// Tag menu as used. Next time BeginMenu() with same ID is called it will append to existing menu
	push_back(&g.MenusIdSubmittedThisFrame, id)

	label_size : ImVec2 = CalcTextSize(label, true)

	// Odd hack to allow hovering across menus of a same menu-set (otherwise we wouldn't be able to hover parent without always being a Child window)
	// This is only done for items for the menu set and not the full parent window.
	menuset_is_open : bool = IsRootOfOpenMenuSet()
	if menuset_is_open { PushItemFlag(cast(ImGuiItemFlags)ImGuiItemFlagsPrivate_.ImGuiItemFlags_NoWindowHoverableCheck, true) }

	// The reference position stored in popup_pos will be used by Begin() to find a suitable position for the child menu,
	// However the final position is going to be different! It is chosen by FindBestWindowPosForPopup().
	// e.g. Menus tend to overlap each other horizontally to amplify relative Z-ordering.
	popup_pos : ImVec2; pos : ImVec2 = window.DC.CursorPos
	PushID(label)
	if !enabled { BeginDisabled() }
	offsets : ^ImGuiMenuColumns = &window.DC.MenuColumns
	pressed : bool

	// We use ImGuiSelectableFlags_NoSetKeyOwner to allow down on one menu item, move, up on another.
	selectable_flags : ImGuiSelectableFlags = ImGuiSelectableFlags(ImGuiSelectableFlagsPrivate_.ImGuiSelectableFlags_NoHoldingActiveID | ImGuiSelectableFlagsPrivate_.ImGuiSelectableFlags_NoSetKeyOwner | ImGuiSelectableFlagsPrivate_.ImGuiSelectableFlags_SelectOnClick) | ImGuiSelectableFlags_.ImGuiSelectableFlags_NoAutoClosePopups
	if window.DC.LayoutType == ImGuiLayoutType_.ImGuiLayoutType_Horizontal {
		// Menu inside an horizontal menu bar
		// Selectable extend their highlight by half ItemSpacing in each direction.
		// For ChildMenu, the popup position will be overwritten by the call to FindBestWindowPosForPopup() in Begin()
		popup_pos = ImVec2{pos.x - 1.0 - IM_TRUNC(style.ItemSpacing.x * 0.5), pos.y - style.FramePadding.y + window.MenuBarHeight}
		window.DC.CursorPos.x += IM_TRUNC(style.ItemSpacing.x * 0.5)
		PushStyleVarX(ImGuiStyleVar_.ImGuiStyleVar_ItemSpacing, style.ItemSpacing.x * 2.0)
		w : f32 = label_size.x
		text_pos := ImVec2{ window.DC.CursorPos.x + f32(offsets.OffsetLabel), window.DC.CursorPos.y + window.DC.CurrLineTextBaseOffset }
		pressed = Selectable("", menu_is_open, selectable_flags, ImVec2{w, label_size.y})
		LogSetNextTextDecoration("[", "]")
		RenderText(text_pos, label)
		PopStyleVar()
		window.DC.CursorPos.x += IM_TRUNC(style.ItemSpacing.x * (-1.0 + 0.5)); // -1 spacing to compensate the spacing added when Selectable() did a SameLine(). It would also work to call SameLine() ourselves after the PopStyleVar().
	}
	else {
		// Menu inside a regular/vertical menu
		// (In a typical menu window where all items are BeginMenu() or MenuItem() calls, extra_w will always be 0.0f.
		//  Only when they are other items sticking out we're going to add spacing, yet only register minimum width into the layout system.
		popup_pos = ImVec2{pos.x, pos.y - style.WindowPadding.y}
		icon_w : f32 = (icon != "") ? CalcTextSize(icon).x : 0.0
		checkmark_w : f32 = IM_TRUNC(g.FontSize * 1.20)
		min_w : f32 = DeclColumns(&window.DC.MenuColumns, icon_w, label_size.x, 0.0, checkmark_w); // Feedback to next frame
		extra_w : f32 = ImMax(f32(0.0), GetContentRegionAvail().x - min_w)
		text_pos := ImVec2{ window.DC.CursorPos.x + f32(offsets.OffsetLabel), window.DC.CursorPos.y + window.DC.CurrLineTextBaseOffset }
		pressed = Selectable("", menu_is_open, selectable_flags | cast(ImGuiSelectableFlags)ImGuiSelectableFlagsPrivate_.ImGuiSelectableFlags_SpanAvailWidth, ImVec2{min_w, label_size.y})
		LogSetNextTextDecoration("", ">")
		RenderText(text_pos, label)
		if icon_w > 0.0 { RenderText(pos + ImVec2{f32(offsets.OffsetIcon), 0.0}, icon) }
		RenderArrow(window.DrawList, pos + ImVec2{f32(offsets.OffsetMark) + extra_w + g.FontSize * 0.30, 0.0}, GetColorU32(ImGuiCol_.ImGuiCol_Text), ImGuiDir.ImGuiDir_Right)
	}
	if !enabled { EndDisabled() }

	hovered : bool = (g.HoveredId == id) && enabled && !g.NavHighlightItemUnderNav
	if menuset_is_open { PopItemFlag() }

	want_open : bool = false
	want_open_nav_init : bool = false
	want_close : bool = false
	if window.DC.LayoutType == ImGuiLayoutType_.ImGuiLayoutType_Vertical {
		// (window->Flags & (ImGuiWindowFlags_Popup|ImGuiWindowFlags_ChildMenu))
		// Close menu when not hovering it anymore unless we are moving roughly in the direction of the menu
		// Implement http://bjk5.com/post/44698559168/breaking-down-amazons-mega-dropdown to avoid using timers, so menus feels more reactive.
		moving_toward_child_menu : bool = false
		child_popup : ^ImGuiPopupData = (g.BeginPopupStack.Size < g.OpenPopupStack.Size) ? &g.OpenPopupStack.Data[g.BeginPopupStack.Size] : nil; // Popup candidate (testing below)
		child_menu_window : ^ImGuiWindow = (child_popup != nil && child_popup.Window != nil && child_popup.Window.ParentWindow == window) ? child_popup.Window : nil
		if g.HoveredWindow == window && child_menu_window != nil {
			ref_unit : f32 = g.FontSize; // FIXME-DPI
			child_dir : f32 = (window.Pos.x < child_menu_window.Pos.x) ? 1.0 : -1.0
			next_window_rect : ImRect = Rect(child_menu_window)
			ta : ImVec2 = (g.IO.MousePos - g.IO.MouseDelta)
			tb : ImVec2 = (child_dir > 0.0) ? GetTL(next_window_rect) : GetTR(next_window_rect)
			tc : ImVec2 = (child_dir > 0.0) ? GetBL(next_window_rect) : GetBR(next_window_rect)
			pad_farmost_h : f32 = ImClamp(ImFabs(ta.x - tb.x) * 0.30, ref_unit * 0.5, ref_unit * 2.5); // Add a bit of extra slack.
			ta.x += child_dir * -0.5
			tb.x += child_dir * ref_unit
			tc.x += child_dir * ref_unit
			tb.y = ta.y + ImMax((tb.y - pad_farmost_h) - ta.y, -ref_unit * 8.0); // Triangle has maximum height to limit the slope and the bias toward large sub-menus
			tc.y = ta.y + ImMin((tc.y + pad_farmost_h) - ta.y, +ref_unit * 8.0)
			moving_toward_child_menu = ImTriangleContainsPoint(ta, tb, tc, g.IO.MousePos)
			//GetForegroundDrawList()->AddTriangleFilled(ta, tb, tc, moving_toward_child_menu ? IM_COL32(0,128,0,128) : IM_COL32(128,0,0,128)); // [DEBUG]
		}

		// The 'HovereWindow == window' check creates an inconsistency (e.g. moving away from menu slowly tends to hit same window, whereas moving away fast does not)
		// But we also need to not close the top-menu menu when moving over void. Perhaps we should extend the triangle check to a larger polygon.
		// (Remember to test this on BeginPopup("A")->BeginMenu("B") sequence which behaves slightly differently as B isn't a Child of A and hovering isn't shared.)
		if menu_is_open && !hovered && g.HoveredWindow == window && !moving_toward_child_menu && !g.NavHighlightItemUnderNav && g.ActiveId == 0 { want_close = true }

		// Open
		// (note: at this point 'hovered' actually includes the NavDisableMouseHover == false test)
		if !menu_is_open && pressed {
			// Click/activate to open
			want_open = true
		}
		else if !menu_is_open && hovered && !moving_toward_child_menu {
			// Hover to open
			want_open = true
		}
		else if !menu_is_open && hovered && g.HoveredIdTimer >= 0.30 && g.MouseStationaryTimer >= 0.30 {
			// Hover to open (timer fallback)
			want_open = true
		}
		if g.NavId == id && g.NavMoveDir == ImGuiDir.ImGuiDir_Right {
			// Nav-Right to open
			want_open_nav_init = true; want_open = want_open_nav_init
			NavMoveRequestCancel()
			SetNavCursorVisibleAfterMove()
		}
	}
	else {
		// Menu bar
		if menu_is_open && pressed && menuset_is_open {
			// Click an open menu again to close it
			want_close = true
			menu_is_open = false; want_open = menu_is_open
		}
		else if pressed || (hovered && menuset_is_open && !menu_is_open) {
			// First click to open, then hover to open others
			want_open = true
		}
		else if g.NavId == id && g.NavMoveDir == ImGuiDir.ImGuiDir_Down {
			// Nav-Down to open
			want_open = true
			NavMoveRequestCancel()
		}
	}

	if !enabled {
		// explicitly close if an open menu becomes disabled, facilitate users code a lot in pattern such as 'if (BeginMenu("options", has_object)) { ..use object.. }'
		want_close = true
	}
	if want_close && IsPopupOpen(id, ImGuiPopupFlags_.ImGuiPopupFlags_None) { ClosePopupToLevel(g.BeginPopupStack.Size, true) }

	when IMGUI_ENABLE_TEST_ENGINE {
		if(g.TestEngineHookItems) {
			ImGuiTestEngineHook_ItemInfo(g, id, label, g.LastItemData.StatusFlags | ImGuiItemStatusFlags_.ImGuiItemStatusFlags_Openable | (menu_is_open ? ImGuiItemStatusFlags_.ImGuiItemStatusFlags_Opened : {}))
		}
	}
	PopID()

	if want_open && !menu_is_open && g.OpenPopupStack.Size > g.BeginPopupStack.Size {
		// Don't reopen/recycle same menu level in the same frame if it is a different menu ID, first close the other menu and yield for a frame.
		OpenPopup(label)
	}
	else if want_open {
		menu_is_open = true
		OpenPopup(label, ImGuiPopupFlags_.ImGuiPopupFlags_NoReopen); // | (want_open_nav_init ? ImGuiPopupFlags_NoReopenAlwaysNavInit : 0));
	}

	if menu_is_open {
		last_item_in_parent : ImGuiLastItemData = g.LastItemData
		SetNextWindowPos(popup_pos, ImGuiCond_.ImGuiCond_Always); // Note: misleading: the value will serve as reference for FindBestWindowPosForPopup(), not actual pos.
		PushStyleVar(ImGuiStyleVar_.ImGuiStyleVar_ChildRounding, style.PopupRounding); // First level will use _PopupRounding, subsequent will use _ChildRounding
		menu_is_open = BeginPopupEx(id, window_flags); // menu_is_open can be 'false' when the popup is completely clipped (e.g. zero size display)
		PopStyleVar()
		if menu_is_open {
			// Implement what ImGuiPopupFlags_NoReopenAlwaysNavInit would do:
			// Perform an init request in the case the popup was already open (via a previous mouse hover)
			if want_open && want_open_nav_init && !g.NavInitRequest {
				FocusWindow(g.CurrentWindow, ImGuiFocusRequestFlags_.ImGuiFocusRequestFlags_UnlessBelowModal)
				NavInitWindow(g.CurrentWindow, false)
			}

			// Restore LastItemData so IsItemXXXX functions can work after BeginMenu()/EndMenu()
			// (This fixes using IsItemClicked() and IsItemHovered(), but IsItemHovered() also relies on its support for ImGuiItemFlags_NoWindowHoverableCheck)
			g.LastItemData = last_item_in_parent
			if g.HoveredWindow == window { g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_.ImGuiItemStatusFlags_HoveredWindow }
		}
	}
	else {
		ClearFlags(&g.NextWindowData); // We behave like Begin() and need to consume those values
	}

	return menu_is_open
}

BeginMenu :: proc(label : string, enabled : bool) -> bool
{
	return BeginMenuEx(label, "", enabled)
}

EndMenu :: proc()
{
	// Nav: When a left move request our menu failed, close ourselves.
	g : ^ImGuiContext = GImGui
	window : ^ImGuiWindow = g.CurrentWindow
	IM_ASSERT((window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_Popup) != {}); // Mismatched BeginMenu()/EndMenu() calls
	parent_window : ^ImGuiWindow = window.ParentWindow; // Should always be != NULL is we passed assert.
	if window.BeginCount == window.BeginCountPreviousFrame { if g.NavMoveDir == ImGuiDir.ImGuiDir_Left && NavMoveRequestButNoResultYet() { if g.NavWindow != nil && (g.NavWindow.RootWindowForNav == window) && parent_window.DC.LayoutType == ImGuiLayoutType_.ImGuiLayoutType_Vertical {
	ClosePopupToLevel(g.BeginPopupStack.Size - 1, true)
	NavMoveRequestCancel()
} } }

	EndPopup()
}

MenuItemEx :: proc(label : string, icon : string, shortcut : string, selected : bool, enabled : bool) -> bool
{
	window : ^ImGuiWindow = GetCurrentWindow()
	if window.SkipItems { return false }

	g : ^ImGuiContext = GImGui
	style : ^ImGuiStyle = &g.Style
	pos : ImVec2 = window.DC.CursorPos
	label_size : ImVec2 = CalcTextSize(label, true)

	// See BeginMenuEx() for comments about this.
	menuset_is_open : bool = IsRootOfOpenMenuSet()
	if menuset_is_open { PushItemFlag(cast(ImGuiItemFlags)ImGuiItemFlagsPrivate_.ImGuiItemFlags_NoWindowHoverableCheck, true) }

	// We've been using the equivalent of ImGuiSelectableFlags_SetNavIdOnHover on all Selectable() since early Nav system days (commit 43ee5d73),
	// but I am unsure whether this should be kept at all. For now moved it to be an opt-in feature used by menus only.
	pressed : bool
	PushID(label)
	if !enabled { BeginDisabled() }

	// We use ImGuiSelectableFlags_NoSetKeyOwner to allow down on one menu item, move, up on another.
	selectable_flags : ImGuiSelectableFlags = ImGuiSelectableFlags(ImGuiSelectableFlagsPrivate_.ImGuiSelectableFlags_SelectOnRelease | ImGuiSelectableFlagsPrivate_.ImGuiSelectableFlags_NoSetKeyOwner | ImGuiSelectableFlagsPrivate_.ImGuiSelectableFlags_SetNavIdOnHover)
	offsets : ^ImGuiMenuColumns = &window.DC.MenuColumns
	if window.DC.LayoutType == ImGuiLayoutType_.ImGuiLayoutType_Horizontal {
		// Mimic the exact layout spacing of BeginMenu() to allow MenuItem() inside a menu bar, which is a little misleading but may be useful
		// Note that in this situation: we don't render the shortcut, we render a highlight instead of the selected tick mark.
		w : f32 = label_size.x
		window.DC.CursorPos.x += IM_TRUNC(style.ItemSpacing.x * 0.5)
		text_pos := ImVec2{ window.DC.CursorPos.x + f32(offsets.OffsetLabel), window.DC.CursorPos.y + window.DC.CurrLineTextBaseOffset }
		PushStyleVarX(ImGuiStyleVar_.ImGuiStyleVar_ItemSpacing, style.ItemSpacing.x * 2.0)
		pressed = Selectable("", selected, selectable_flags, ImVec2{w, 0.0})
		PopStyleVar()
		if (g.LastItemData.StatusFlags & ImGuiItemStatusFlags_.ImGuiItemStatusFlags_Visible) != {} { RenderText(text_pos, label) }
		window.DC.CursorPos.x += IM_TRUNC(style.ItemSpacing.x * (-1.0 + 0.5)); // -1 spacing to compensate the spacing added when Selectable() did a SameLine(). It would also work to call SameLine() ourselves after the PopStyleVar().
	}
	else {
		// Menu item inside a vertical menu
		// (In a typical menu window where all items are BeginMenu() or MenuItem() calls, extra_w will always be 0.0f.
		//  Only when they are other items sticking out we're going to add spacing, yet only register minimum width into the layout system.
		icon_w : f32 = icon != "" ? CalcTextSize(icon).x : 0.0
		shortcut_w : f32 = shortcut != "" ? CalcTextSize(shortcut).x : 0.0
		checkmark_w : f32 = IM_TRUNC(g.FontSize * 1.20)
		min_w : f32 = DeclColumns(&window.DC.MenuColumns, icon_w, label_size.x, shortcut_w, checkmark_w); // Feedback for next frame
		stretch_w : f32 = ImMax(f32(0.0), GetContentRegionAvail().x - min_w)
		pressed = Selectable("", false, selectable_flags | cast(ImGuiSelectableFlags)ImGuiSelectableFlagsPrivate_.ImGuiSelectableFlags_SpanAvailWidth, ImVec2{min_w, label_size.y})
		if (g.LastItemData.StatusFlags & ImGuiItemStatusFlags_.ImGuiItemStatusFlags_Visible) != {} {
			RenderText(pos + ImVec2{f32(offsets.OffsetLabel), 0.0}, label)
			if icon_w > 0.0 { RenderText(pos + ImVec2{f32(offsets.OffsetIcon), 0.0}, icon) }
			if shortcut_w > 0.0 {
				PushStyleColor(ImGuiCol_.ImGuiCol_Text, style.Colors[ImGuiCol_.ImGuiCol_TextDisabled])
				LogSetNextTextDecoration("(", ")")
				RenderText(pos + ImVec2{f32(offsets.OffsetShortcut) + stretch_w, 0.0}, shortcut, false)
				PopStyleColor()
			}
			if selected { RenderCheckMark(window.DrawList, pos + ImVec2{f32(offsets.OffsetMark) + stretch_w + g.FontSize * 0.40, g.FontSize * 0.134 * 0.5}, GetColorU32(ImGuiCol_.ImGuiCol_Text), g.FontSize * 0.866) }
		}
	}
	when IMGUI_ENABLE_TEST_ENGINE {
		if(g.TestEngineHookItems) {
			ImGuiTestEngineHook_ItemInfo(g, g.LastItemData.ID, label, g.LastItemData.StatusFlags | ImGuiItemStatusFlags_.ImGuiItemStatusFlags_Checkable | (selected ? ImGuiItemStatusFlags_.ImGuiItemStatusFlags_Checked : {}))
		}
	}
	if !enabled { EndDisabled() }
	PopID()
	if menuset_is_open { PopItemFlag() }

	return pressed
}

MenuItem_0 :: proc(label : string, shortcut : string = "", selected : bool = false, enabled : bool = true) -> bool
{
	return MenuItemEx(label, "", shortcut, selected, enabled)
}

MenuItem_1 :: proc(label : string, shortcut : string, p_selected : ^bool, enabled : bool = true) -> bool
{
	if MenuItemEx(label, "", shortcut, p_selected != nil ? p_selected^ : false, enabled) {
		if p_selected != nil { p_selected^ = !p_selected^ }
		return true
	}
	return false
}

//-------------------------------------------------------------------------
// [SECTION] Widgets: BeginTabBar, EndTabBar, etc.
//-------------------------------------------------------------------------
// - BeginTabBar()
// - BeginTabBarEx() [Internal]
// - EndTabBar()
// - TabBarLayout() [Internal]
// - TabBarCalcTabID() [Internal]
// - TabBarCalcMaxTabWidth() [Internal]
// - TabBarFindTabById() [Internal]
// - TabBarFindTabByOrder() [Internal]
// - TabBarFindMostRecentlySelectedTabForActiveWindow() [Internal]
// - TabBarGetCurrentTab() [Internal]
// - TabBarGetTabName() [Internal]
// - TabBarAddTab() [Internal]
// - TabBarRemoveTab() [Internal]
// - TabBarCloseTab() [Internal]
// - TabBarScrollClamp() [Internal]
// - TabBarScrollToTab() [Internal]
// - TabBarQueueFocus() [Internal]
// - TabBarQueueReorder() [Internal]
// - TabBarProcessReorderFromMousePos() [Internal]
// - TabBarProcessReorder() [Internal]
// - TabBarScrollingButtons() [Internal]
// - TabBarTabListPopupButton() [Internal]
//-------------------------------------------------------------------------

ImGuiTabBarSection :: struct {
	TabCount : i32, // Number of tabs in this section.
	Width : f32, // Sum of width of tabs in this section (after shrinking down)
	Spacing : f32, // Horizontal spacing at the end of the section.
}

ImGuiTabBarSection_init :: proc(this : ^ImGuiTabBarSection) { this^ = {} }

ImGuiTabBar_init :: proc(this : ^ImGuiTabBar)
{
	this^ = {}
	this.PrevFrameVisible = -1; this.CurrFrameVisible = this.PrevFrameVisible
	this.LastTabItemIdx = -1
}

TabItemGetSectionIdx :: #force_inline proc(tab : ImGuiTabItem) -> i32
{
	return (tab.Flags & ImGuiTabItemFlags_.ImGuiTabItemFlags_Leading) != {} ? 0 : (tab.Flags & ImGuiTabItemFlags_.ImGuiTabItemFlags_Trailing) != {} ? 2 : 1
}

TabItemComparerBySection :: proc(a, b : ImGuiTabItem) -> slice.Ordering
{
	a_section : i32 = TabItemGetSectionIdx(a)
	b_section : i32 = TabItemGetSectionIdx(b)
	if a_section != b_section { return cast(slice.Ordering)(a_section - b_section) }
	return cast(slice.Ordering) (a.IndexDuringLayout - b.IndexDuringLayout)
}

TabItemComparerByBeginOrder :: proc(a, b : ImGuiTabItem) -> slice.Ordering
{
	return cast(slice.Ordering) (a.BeginOrder - b.BeginOrder)
}

GetTabBarFromTabBarRef :: proc(ref : ^ImGuiPtrOrIndex) -> ^ImGuiTabBar
{
	g : ^ImGuiContext = GImGui
	return ref.Ptr != nil ? cast(^ImGuiTabBar) ref.Ptr : GetByIndex(&g.TabBars, ref.Index)
}

GetTabBarRefFromTabBar :: proc(tab_bar : ^ImGuiTabBar) -> ImGuiPtrOrIndex
{
	g : ^ImGuiContext = GImGui
	v : ImGuiPtrOrIndex
	if Contains(g.TabBars, tab_bar) { init(&v, GetIndex(&g.TabBars, tab_bar)); return v; }
	init(&v, tab_bar)
	return v
}

BeginTabBar :: proc(str_id : string, flags : ImGuiTabBarFlags) -> bool
{
	g : ^ImGuiContext = GImGui
	window : ^ImGuiWindow = g.CurrentWindow
	if window.SkipItems { return false }

	id : ImGuiID = GetID(window, str_id)
	tab_bar : ^ImGuiTabBar = GetOrAddByKey(&g.TabBars, id)
	tab_bar_bb : ImRect = ImRect{{window.DC.CursorPos.x, window.DC.CursorPos.y}, {window.WorkRect.Max.x, window.DC.CursorPos.y + g.FontSize + g.Style.FramePadding.y * 2}}
	tab_bar.ID = id
	tab_bar.SeparatorMinX = tab_bar.BarRect.Min.x - IM_TRUNC(window.WindowPadding.x * 0.5)
	tab_bar.SeparatorMaxX = tab_bar.BarRect.Max.x + IM_TRUNC(window.WindowPadding.x * 0.5)
	//if (g.NavWindow && IsWindowChildOf(g.NavWindow, window, false, false))
	flags := flags | cast(ImGuiTabBarFlags) ImGuiTabBarFlagsPrivate_.ImGuiTabBarFlags_IsFocused
	return BeginTabBarEx(tab_bar, tab_bar_bb, flags)
}

BeginTabBarEx :: proc(tab_bar : ^ImGuiTabBar, tab_bar_bb : ImRect, flags : ImGuiTabBarFlags) -> bool
{
	g : ^ImGuiContext = GImGui
	window : ^ImGuiWindow = g.CurrentWindow
	if window.SkipItems { return false }

	IM_ASSERT(tab_bar.ID != 0)
	if (flags & cast(ImGuiTabBarFlags) ImGuiTabBarFlagsPrivate_.ImGuiTabBarFlags_DockNode) == {} { PushOverrideID(tab_bar.ID) }

	// Add to stack
	push_back(&g.CurrentTabBarStack, GetTabBarRefFromTabBar(tab_bar))
	g.CurrentTabBar = tab_bar
	tab_bar.Window = window

	// Append with multiple BeginTabBar()/EndTabBar() pairs.
	tab_bar.BackupCursorPos = window.DC.CursorPos
	if tab_bar.CurrFrameVisible == g.FrameCount {
		window.DC.CursorPos = ImVec2{tab_bar.BarRect.Min.x, tab_bar.BarRect.Max.y + tab_bar.ItemSpacingY}
		post_incr(&tab_bar.BeginCount)
		return true
	}

	// Ensure correct ordering when toggling ImGuiTabBarFlags_Reorderable flag, or when a new tab was added while being not reorderable
	if (flags & ImGuiTabBarFlags_.ImGuiTabBarFlags_Reorderable) != (tab_bar.Flags & ImGuiTabBarFlags_.ImGuiTabBarFlags_Reorderable) || (tab_bar.TabsAddedNew && (flags & ImGuiTabBarFlags_.ImGuiTabBarFlags_Reorderable) == {}) {
		if (flags & cast(ImGuiTabBarFlags) ImGuiTabBarFlagsPrivate_.ImGuiTabBarFlags_DockNode) == {} {
			// FIXME: TabBar with DockNode can now be hybrid
			ImQsort(tab_bar.Tabs.Data[:tab_bar.Tabs.Size], TabItemComparerByBeginOrder)
		}
	}
	tab_bar.TabsAddedNew = false

	flags := flags
	// Flags
	if (flags & ImGuiTabBarFlags_.ImGuiTabBarFlags_FittingPolicyMask_) == {} { flags |= ImGuiTabBarFlags_.ImGuiTabBarFlags_FittingPolicyDefault_ }

	tab_bar.Flags = flags
	tab_bar.BarRect = tab_bar_bb
	tab_bar.WantLayout = true; // Layout will be done on the first call to ItemTab()
	tab_bar.PrevFrameVisible = tab_bar.CurrFrameVisible
	tab_bar.CurrFrameVisible = g.FrameCount
	tab_bar.PrevTabsContentsHeight = tab_bar.CurrTabsContentsHeight
	tab_bar.CurrTabsContentsHeight = 0.0
	tab_bar.ItemSpacingY = g.Style.ItemSpacing.y
	tab_bar.FramePadding = g.Style.FramePadding
	tab_bar.TabsActiveCount = 0
	tab_bar.LastTabItemIdx = -1
	tab_bar.BeginCount = 1

	// Set cursor pos in a way which only be used in the off-chance the user erroneously submits item before BeginTabItem(): items will overlap
	window.DC.CursorPos = ImVec2{tab_bar.BarRect.Min.x, tab_bar.BarRect.Max.y + tab_bar.ItemSpacingY}

	// Draw separator
	// (it would be misleading to draw this in EndTabBar() suggesting that it may be drawn over tabs, as tab bar are appendable)
	col : ImU32 = GetColorU32((flags & cast(ImGuiTabBarFlags) ImGuiTabBarFlagsPrivate_.ImGuiTabBarFlags_IsFocused) != {} ? ImGuiCol_.ImGuiCol_TabSelected : ImGuiCol_.ImGuiCol_TabDimmedSelected)
	if g.Style.TabBarBorderSize > 0.0 {
		y : f32 = tab_bar.BarRect.Max.y
		AddRectFilled(window.DrawList, ImVec2{tab_bar.SeparatorMinX, y - g.Style.TabBarBorderSize}, ImVec2{tab_bar.SeparatorMaxX, y}, col)
	}
	return true
}

EndTabBar :: proc()
{
	g : ^ImGuiContext = GImGui
	window : ^ImGuiWindow = g.CurrentWindow
	if window.SkipItems { return }

	tab_bar : ^ImGuiTabBar = g.CurrentTabBar
	if tab_bar == nil {
		IM_ASSERT_USER_ERROR(tab_bar != nil, "Mismatched BeginTabBar()/EndTabBar()!")
		return
	}

	// Fallback in case no TabItem have been submitted
	if tab_bar.WantLayout { TabBarLayout(tab_bar) }

	// Restore the last visible height if no tab is visible, this reduce vertical flicker/movement when a tabs gets removed without calling SetTabItemClosed().
	tab_bar_appearing : bool = (tab_bar.PrevFrameVisible + 1 < g.FrameCount)
	if tab_bar.VisibleTabWasSubmitted || tab_bar.VisibleTabId == 0 || tab_bar_appearing {
		tab_bar.CurrTabsContentsHeight = ImMax(window.DC.CursorPos.y - tab_bar.BarRect.Max.y, tab_bar.CurrTabsContentsHeight)
		window.DC.CursorPos.y = tab_bar.BarRect.Max.y + tab_bar.CurrTabsContentsHeight
	}
	else {
		window.DC.CursorPos.y = tab_bar.BarRect.Max.y + tab_bar.PrevTabsContentsHeight
	}
	if tab_bar.BeginCount > 1 { window.DC.CursorPos = tab_bar.BackupCursorPos }

	tab_bar.LastTabItemIdx = -1
	if (tab_bar.Flags & cast(ImGuiTabBarFlags) ImGuiTabBarFlagsPrivate_.ImGuiTabBarFlags_DockNode) == {} { PopID() }

	pop_back(&g.CurrentTabBarStack)
	g.CurrentTabBar = empty(&g.CurrentTabBarStack) ? nil : GetTabBarFromTabBarRef(back(&g.CurrentTabBarStack))
}

// Scrolling happens only in the central section (leading/trailing sections are not scrolling)
TabBarCalcScrollableWidth :: proc(tab_bar : ^ImGuiTabBar, sections : [^]ImGuiTabBarSection) -> f32
{
	return GetWidth(tab_bar.BarRect) - sections[0].Width - sections[2].Width - sections[1].Spacing
}

// This is called only once a frame before by the first call to ItemTab()
// The reason we're not calling it in BeginTabBar() is to leave a chance to the user to call the SetTabItemClosed() functions.
TabBarLayout :: proc(tab_bar : ^ImGuiTabBar)
{
	g : ^ImGuiContext = GImGui
	tab_bar.WantLayout = false

	// Garbage collect by compacting list
	// Detect if we need to sort out tab list (e.g. in rare case where a tab changed section)
	tab_dst_n : i32 = 0
	need_sort_by_section : bool = false
	sections : [3]ImGuiTabBarSection; // Layout sections: Leading, Central, Trailing
	for tab_src_n : i32 = 0; tab_src_n < tab_bar.Tabs.Size; tab_src_n += 1 {
		tab : ^ImGuiTabItem = &tab_bar.Tabs.Data[tab_src_n]
		if tab.LastFrameVisible < tab_bar.PrevFrameVisible || tab.WantClose {
			// Remove tab
			if tab_bar.VisibleTabId == tab.ID { tab_bar.VisibleTabId = 0 }
			if tab_bar.SelectedTabId == tab.ID { tab_bar.SelectedTabId = 0 }
			if tab_bar.NextSelectedTabId == tab.ID { tab_bar.NextSelectedTabId = 0 }
			continue
		}
		if tab_dst_n != tab_src_n { tab_bar.Tabs.Data[tab_dst_n] = tab_bar.Tabs.Data[tab_src_n] }

		tab = &tab_bar.Tabs.Data[tab_dst_n]
		tab.IndexDuringLayout = cast(ImS16) tab_dst_n

		// We will need sorting if tabs have changed section (e.g. moved from one of Leading/Central/Trailing to another)
		curr_tab_section_n : i32 = TabItemGetSectionIdx(tab^)
		if tab_dst_n > 0 {
			prev_tab := &tab_bar.Tabs.Data[tab_dst_n - 1]
			prev_tab_section_n : i32 = TabItemGetSectionIdx(prev_tab^)
			if curr_tab_section_n == 0 && prev_tab_section_n != 0 { need_sort_by_section = true }
			if prev_tab_section_n == 2 && curr_tab_section_n != 2 { need_sort_by_section = true }
		}

		post_incr(&sections[curr_tab_section_n].TabCount)
		post_incr(&tab_dst_n)
	}

	if tab_bar.Tabs.Size != tab_dst_n { resize(&tab_bar.Tabs, tab_dst_n) }

	if need_sort_by_section { ImQsort(tab_bar.Tabs.Data[:tab_bar.Tabs.Size], TabItemComparerBySection) }

	// Calculate spacing between sections
	sections[0].Spacing = sections[0].TabCount > 0 && (sections[1].TabCount + sections[2].TabCount) > 0 ? g.Style.ItemInnerSpacing.x : 0.0
	sections[1].Spacing = sections[1].TabCount > 0 && sections[2].TabCount > 0 ? g.Style.ItemInnerSpacing.x : 0.0

	// Setup next selected tab
	scroll_to_tab_id : ImGuiID = 0
	if tab_bar.NextSelectedTabId != 0 {
		tab_bar.SelectedTabId = tab_bar.NextSelectedTabId
		tab_bar.NextSelectedTabId = 0
		scroll_to_tab_id = tab_bar.SelectedTabId
	}

	// Process order change request (we could probably process it when requested but it's just saner to do it in a single spot).
	if tab_bar.ReorderRequestTabId != 0 {
		if TabBarProcessReorder(tab_bar) { if tab_bar.ReorderRequestTabId == tab_bar.SelectedTabId { scroll_to_tab_id = tab_bar.ReorderRequestTabId } }
		tab_bar.ReorderRequestTabId = 0
	}

	// Tab List Popup (will alter tab_bar->BarRect and therefore the available width!)
	tab_list_popup_button : bool = (tab_bar.Flags & ImGuiTabBarFlags_.ImGuiTabBarFlags_TabListPopupButton) != {}
	if tab_list_popup_button { if tab_to_select : ^ImGuiTabItem = TabBarTabListPopupButton(tab_bar); tab_to_select != nil {
		// NB: Will alter BarRect.Min.x!
		tab_bar.SelectedTabId = tab_to_select.ID; scroll_to_tab_id = tab_bar.SelectedTabId
	} }

	// Leading/Trailing tabs will be shrink only if central one aren't visible anymore, so layout the shrink data as: leading, trailing, central
	// (whereas our tabs are stored as: leading, central, trailing)
	shrink_buffer_indexes : [3]i32 = {0, sections[0].TabCount + sections[2].TabCount, sections[0].TabCount}
	resize(&g.ShrinkWidthBuffer, tab_bar.Tabs.Size)

	// Compute ideal tabs widths + store them into shrink buffer
	most_recently_selected_tab : ^ImGuiTabItem = nil
	curr_section_n : i32 = -1
	found_selected_tab_id : bool = false
	for tab_n : i32 = 0; tab_n < tab_bar.Tabs.Size; tab_n += 1 {
		tab : ^ImGuiTabItem = &tab_bar.Tabs.Data[tab_n]
		IM_ASSERT(tab.LastFrameVisible >= tab_bar.PrevFrameVisible)

		if (most_recently_selected_tab == nil || most_recently_selected_tab.LastFrameSelected < tab.LastFrameSelected) && (tab.Flags & cast(ImGuiTabItemFlags) ImGuiTabItemFlagsPrivate_.ImGuiTabItemFlags_Button) == {} { most_recently_selected_tab = tab }
		if tab.ID == tab_bar.SelectedTabId { found_selected_tab_id = true }
		if scroll_to_tab_id == 0 && g.NavJustMovedToId == tab.ID { scroll_to_tab_id = tab.ID }

		// Refresh tab width immediately, otherwise changes of style e.g. style.FramePadding.x would noticeably lag in the tab bar.
		// Additionally, when using TabBarAddTab() to manipulate tab bar order we occasionally insert new tabs that don't have a width yet,
		// and we cannot wait for the next BeginTabItem() call. We cannot compute this width within TabBarAddTab() because font size depends on the active window.
		tab_name := TabBarGetTabName(tab_bar, tab)
		has_close_button_or_unsaved_marker : bool = (tab.Flags & cast(ImGuiTabItemFlags) ImGuiTabItemFlagsPrivate_.ImGuiTabItemFlags_NoCloseButton) == {} || (tab.Flags & ImGuiTabItemFlags_.ImGuiTabItemFlags_UnsavedDocument) != {}
		tab.ContentWidth = (tab.RequestedWidth >= 0.0) ? tab.RequestedWidth : TabItemCalcSize(tab_name, has_close_button_or_unsaved_marker).x

		section_n : i32 = TabItemGetSectionIdx(tab^)
		section : ^ImGuiTabBarSection = &sections[section_n]
		section.Width += tab.ContentWidth + (section_n == curr_section_n ? g.Style.ItemInnerSpacing.x : 0.0)
		curr_section_n = section_n

		// Store data so we can build an array sorted by width if we need to shrink tabs down
		shrink_width_item : ^ImGuiShrinkWidthItem = &g.ShrinkWidthBuffer.Data[post_incr(&shrink_buffer_indexes[section_n])]
		shrink_width_item.Index = tab_n
		shrink_width_item.InitialWidth = tab.ContentWidth; shrink_width_item.Width = shrink_width_item.InitialWidth
		tab.Width = ImMax(tab.ContentWidth, 1.0)
	}

	// Compute total ideal width (used for e.g. auto-resizing a window)
	tab_bar.WidthAllTabsIdeal = 0.0
	for section_n : i32 = 0; section_n < 3; section_n += 1 { tab_bar.WidthAllTabsIdeal += sections[section_n].Width + sections[section_n].Spacing }

	// Horizontal scrolling buttons
	// (note that TabBarScrollButtons() will alter BarRect.Max.x)
	if (tab_bar.WidthAllTabsIdeal > GetWidth(tab_bar.BarRect) && tab_bar.Tabs.Size > 1) && (tab_bar.Flags & ImGuiTabBarFlags_.ImGuiTabBarFlags_NoTabListScrollingButtons) == {} && (tab_bar.Flags & ImGuiTabBarFlags_.ImGuiTabBarFlags_FittingPolicyScroll) != {} { if scroll_and_select_tab : ^ImGuiTabItem = TabBarScrollingButtons(tab_bar); scroll_and_select_tab != nil {
	scroll_to_tab_id = scroll_and_select_tab.ID
	if (scroll_and_select_tab.Flags & cast(ImGuiTabItemFlags) ImGuiTabItemFlagsPrivate_.ImGuiTabItemFlags_Button) == {} { tab_bar.SelectedTabId = scroll_to_tab_id }
} }

	// Shrink widths if full tabs don't fit in their allocated space
	section_0_w : f32 = sections[0].Width + sections[0].Spacing
	section_1_w : f32 = sections[1].Width + sections[1].Spacing
	section_2_w : f32 = sections[2].Width + sections[2].Spacing
	central_section_is_visible : bool = (section_0_w + section_2_w) < GetWidth(tab_bar.BarRect)
	width_excess : f32
	if central_section_is_visible {
		// Excess used to shrink central section
		width_excess = ImMax(section_1_w - (GetWidth(tab_bar.BarRect) - section_0_w - section_2_w), 0.0)
	}
	else {
		// Excess used to shrink leading/trailing section
		width_excess = (section_0_w + section_2_w) - GetWidth(tab_bar.BarRect)
	}

	// With ImGuiTabBarFlags_FittingPolicyScroll policy, we will only shrink leading/trailing if the central section is not visible anymore
	if width_excess >= 1.0 && ((tab_bar.Flags & ImGuiTabBarFlags_.ImGuiTabBarFlags_FittingPolicyResizeDown) != {} || !central_section_is_visible) {
		shrink_data_count : i32 = (central_section_is_visible ? sections[1].TabCount : sections[0].TabCount + sections[2].TabCount)
		shrink_data_offset : i32 = (central_section_is_visible ? sections[0].TabCount + sections[2].TabCount : 0)
		ShrinkWidths(g.ShrinkWidthBuffer.Data[shrink_data_offset:], shrink_data_count, width_excess)

		// Apply shrunk values into tabs and sections
		for tab_n : i32 = shrink_data_offset; tab_n < shrink_data_offset + shrink_data_count; tab_n += 1 {
			tab : ^ImGuiTabItem = &tab_bar.Tabs.Data[g.ShrinkWidthBuffer.Data[tab_n].Index]
			shrinked_width : f32 = IM_TRUNC(g.ShrinkWidthBuffer.Data[tab_n].Width)
			if shrinked_width < 0.0 { continue }

			shrinked_width = ImMax(f32(1.0), shrinked_width)
			section_n : i32 = TabItemGetSectionIdx(tab^)
			sections[section_n].Width -= (tab.Width - shrinked_width)
			tab.Width = shrinked_width
		}
	}

	// Layout all active tabs
	section_tab_index : i32 = 0
	tab_offset : f32 = 0.0
	tab_bar.WidthAllTabs = 0.0
	for section_n : i32 = 0; section_n < 3; section_n += 1 {
		section : ^ImGuiTabBarSection = &sections[section_n]
		if section_n == 2 { tab_offset = ImMin(ImMax(f32(0.0), GetWidth(tab_bar.BarRect) - section.Width), tab_offset) }

		for tab_n : i32 = 0; tab_n < section.TabCount; tab_n += 1 {
			tab : ^ImGuiTabItem = &tab_bar.Tabs.Data[section_tab_index + tab_n]
			tab.Offset = tab_offset
			tab.NameOffset = -1
			tab_offset += tab.Width + (tab_n < section.TabCount - 1 ? g.Style.ItemInnerSpacing.x : 0.0)
		}

		tab_bar.WidthAllTabs += ImMax(section.Width + section.Spacing, 0.0)
		tab_offset += section.Spacing
		section_tab_index += section.TabCount
	}

	// Clear name buffers
	resize(&tab_bar.TabsNames.Buf, 0)

	// If we have lost the selected tab, select the next most recently active one
	if found_selected_tab_id == false { tab_bar.SelectedTabId = 0 }
	if tab_bar.SelectedTabId == 0 && tab_bar.NextSelectedTabId == 0 && most_recently_selected_tab != nil { tab_bar.SelectedTabId = most_recently_selected_tab.ID; scroll_to_tab_id = tab_bar.SelectedTabId }

	// Lock in visible tab
	tab_bar.VisibleTabId = tab_bar.SelectedTabId
	tab_bar.VisibleTabWasSubmitted = false

	// CTRL+TAB can override visible tab temporarily
	if g.NavWindowingTarget != nil && g.NavWindowingTarget.DockNode != nil && g.NavWindowingTarget.DockNode.TabBar == tab_bar { scroll_to_tab_id = g.NavWindowingTarget.TabId; tab_bar.VisibleTabId = scroll_to_tab_id }

	// Apply request requests
	if scroll_to_tab_id != {} { TabBarScrollToTab(tab_bar, scroll_to_tab_id, raw_data(&sections)) }
	else if (tab_bar.Flags & ImGuiTabBarFlags_.ImGuiTabBarFlags_FittingPolicyScroll) != {} && IsMouseHoveringRect(tab_bar.BarRect.Min, tab_bar.BarRect.Max, true) && IsWindowContentHoverable(g.CurrentWindow) {
		wheel : f32 = g.IO.MouseWheelRequestAxisSwap ? g.IO.MouseWheel : g.IO.MouseWheelH
		wheel_key : ImGuiKey = g.IO.MouseWheelRequestAxisSwap ? ImGuiKey.ImGuiKey_MouseWheelY : ImGuiKey.ImGuiKey_MouseWheelX
		if TestKeyOwner(wheel_key, tab_bar.ID) && wheel != 0.0 {
			scroll_step : f32 = wheel * TabBarCalcScrollableWidth(tab_bar, raw_data(&sections)) / 3.0
			tab_bar.ScrollingTargetDistToVisibility = 0.0
			tab_bar.ScrollingTarget = TabBarScrollClamp(tab_bar, tab_bar.ScrollingTarget - scroll_step)
		}
		SetKeyOwner(wheel_key, tab_bar.ID)
	}

	// Update scrolling
	tab_bar.ScrollingAnim = TabBarScrollClamp(tab_bar, tab_bar.ScrollingAnim)
	tab_bar.ScrollingTarget = TabBarScrollClamp(tab_bar, tab_bar.ScrollingTarget)
	if tab_bar.ScrollingAnim != tab_bar.ScrollingTarget {
		// Scrolling speed adjust itself so we can always reach our target in 1/3 seconds.
		// Teleport if we are aiming far off the visible line
		tab_bar.ScrollingSpeed = ImMax(tab_bar.ScrollingSpeed, 70.0 * g.FontSize)
		tab_bar.ScrollingSpeed = ImMax(tab_bar.ScrollingSpeed, ImFabs(tab_bar.ScrollingTarget - tab_bar.ScrollingAnim) / 0.3)
		teleport : bool = (tab_bar.PrevFrameVisible + 1 < g.FrameCount) || (tab_bar.ScrollingTargetDistToVisibility > 10.0 * g.FontSize)
		tab_bar.ScrollingAnim = teleport ? tab_bar.ScrollingTarget : ImLinearSweep(tab_bar.ScrollingAnim, tab_bar.ScrollingTarget, g.IO.DeltaTime * tab_bar.ScrollingSpeed)
	}
	else {
		tab_bar.ScrollingSpeed = 0.0
	}
	tab_bar.ScrollingRectMinX = tab_bar.BarRect.Min.x + sections[0].Width + sections[0].Spacing
	tab_bar.ScrollingRectMaxX = tab_bar.BarRect.Max.x - sections[2].Width - sections[1].Spacing

	// Actual layout in host window (we don't do it in BeginTabBar() so as not to waste an extra frame)
	window : ^ImGuiWindow = g.CurrentWindow
	window.DC.CursorPos = tab_bar.BarRect.Min
	ItemSize(ImVec2{tab_bar.WidthAllTabs, GetHeight(tab_bar.BarRect)}, tab_bar.FramePadding.y)
	window.DC.IdealMaxPos.x = ImMax(window.DC.IdealMaxPos.x, tab_bar.BarRect.Min.x + tab_bar.WidthAllTabsIdeal)
}

// Dockable windows uses Name/ID in the global namespace. Non-dockable items use the ID stack.
TabBarCalcTabID :: proc(tab_bar : ^ImGuiTabBar, label : string, docked_window : ^ImGuiWindow) -> ImU32
{
	if docked_window != nil {
		IM_UNUSED(tab_bar)
		IM_ASSERT((tab_bar.Flags & cast(ImGuiTabBarFlags) ImGuiTabBarFlagsPrivate_.ImGuiTabBarFlags_DockNode) != {})
		id : ImGuiID = docked_window.TabId
		KeepAliveID(id)
		return id
	}
	else {
		window : ^ImGuiWindow = GImGui.CurrentWindow
		return GetID(window, label)
	}
}

TabBarCalcMaxTabWidth :: proc() -> f32
{
	g : ^ImGuiContext = GImGui
	return g.FontSize * 20.0
}

TabBarFindTabByID :: proc(tab_bar : ^ImGuiTabBar, tab_id : ImGuiID) -> ^ImGuiTabItem
{
	if tab_id != 0 { for n : i32 = 0; n < tab_bar.Tabs.Size; n += 1 { if tab_bar.Tabs.Data[n].ID == tab_id { return &tab_bar.Tabs.Data[n] } } }
	return nil
}

// Order = visible order, not submission order! (which is tab->BeginOrder)
TabBarFindTabByOrder :: proc(tab_bar : ^ImGuiTabBar, order : i32) -> ^ImGuiTabItem
{
	if order < 0 || order >= tab_bar.Tabs.Size { return nil }
	return &tab_bar.Tabs.Data[order]
}

// FIXME: See references to #2304 in TODO.txt
TabBarFindMostRecentlySelectedTabForActiveWindow :: proc(tab_bar : ^ImGuiTabBar) -> ^ImGuiTabItem
{
	most_recently_selected_tab : ^ImGuiTabItem = nil
	for tab_n : i32 = 0; tab_n < tab_bar.Tabs.Size; tab_n += 1 {
		tab : ^ImGuiTabItem = &tab_bar.Tabs.Data[tab_n]
		if most_recently_selected_tab == nil || most_recently_selected_tab.LastFrameSelected < tab.LastFrameSelected {
			if tab.Window != nil && tab.Window.WasActive { most_recently_selected_tab = tab }
		}
	}

	return most_recently_selected_tab
}

TabBarGetCurrentTab :: proc(tab_bar : ^ImGuiTabBar) -> ^ImGuiTabItem
{
	if tab_bar.LastTabItemIdx < 0 || i32(tab_bar.LastTabItemIdx) >= tab_bar.Tabs.Size { return nil }
	return &tab_bar.Tabs.Data[tab_bar.LastTabItemIdx]
}

TabBarGetTabName :: proc(tab_bar : ^ImGuiTabBar, tab : ^ImGuiTabItem) -> string
{
	if tab.Window != nil { return tab.Window.Name }
	if tab.NameOffset == -1 { return "N/A" }
	IM_ASSERT(tab.NameOffset < tab_bar.TabsNames.Buf.Size)
	return string_from_slice(tab_bar.TabsNames.Buf.Data[tab.NameOffset:tab_bar.TabsNames.Buf.Size])
}

// The purpose of this call is to register tab in advance so we can control their order at the time they appear.
// Otherwise calling this is unnecessary as tabs are appending as needed by the BeginTabItem() function.
TabBarAddTab :: proc(tab_bar : ^ImGuiTabBar, tab_flags : ImGuiTabItemFlags, window : ^ImGuiWindow)
{
	g : ^ImGuiContext = GImGui
	IM_ASSERT(TabBarFindTabByID(tab_bar, window.TabId) == nil)
	IM_ASSERT(g.CurrentTabBar != tab_bar); // Can't work while the tab bar is active as our tab doesn't have an X offset yet, in theory we could/should test something like (tab_bar->CurrFrameVisible < g.FrameCount) but we'd need to solve why triggers the commented early-out assert in BeginTabBarEx() (probably dock node going from implicit to explicit in same frame)

	tab_flags := tab_flags
	if !window.HasCloseButton {
		// Set _NoCloseButton immediately because it will be used for first-frame width calculation.
		tab_flags |= cast(ImGuiTabItemFlags) ImGuiTabItemFlagsPrivate_.ImGuiTabItemFlags_NoCloseButton
	}

	new_tab : ImGuiTabItem
	new_tab.ID = window.TabId
	new_tab.Flags = tab_flags
	new_tab.LastFrameVisible = tab_bar.CurrFrameVisible; // Required so BeginTabBar() doesn't ditch the tab
	if new_tab.LastFrameVisible == -1 { new_tab.LastFrameVisible = g.FrameCount - 1 }
	new_tab.Window = window; // Required so tab bar layout can compute the tab width before tab submission
	push_back(&tab_bar.Tabs, new_tab)
}

// The *TabId fields are already set by the docking system _before_ the actual TabItem was created, so we clear them regardless.
TabBarRemoveTab :: proc(tab_bar : ^ImGuiTabBar, tab_id : ImGuiID)
{
	if tab : ^ImGuiTabItem = TabBarFindTabByID(tab_bar, tab_id); tab != nil { erase(&tab_bar.Tabs, tab) }
	if tab_bar.VisibleTabId == tab_id { tab_bar.VisibleTabId = 0 }
	if tab_bar.SelectedTabId == tab_id { tab_bar.SelectedTabId = 0 }
	if tab_bar.NextSelectedTabId == tab_id { tab_bar.NextSelectedTabId = 0 }
}

// Called on manual closure attempt
TabBarCloseTab :: proc(tab_bar : ^ImGuiTabBar, tab : ^ImGuiTabItem)
{
	if (tab.Flags & cast(ImGuiTabItemFlags) ImGuiTabItemFlagsPrivate_.ImGuiTabItemFlags_Button) != {} {
		// A button appended with TabItemButton().
		return
	}

	if (tab.Flags & (ImGuiTabItemFlags_.ImGuiTabItemFlags_UnsavedDocument | ImGuiTabItemFlags_.ImGuiTabItemFlags_NoAssumedClosure)) == {} {
		// This will remove a frame of lag for selecting another tab on closure.
		// However we don't run it in the case where the 'Unsaved' flag is set, so user gets a chance to fully undo the closure
		tab.WantClose = true
		if tab_bar.VisibleTabId == tab.ID {
			tab.LastFrameVisible = -1
			tab_bar.NextSelectedTabId = 0; tab_bar.SelectedTabId = tab_bar.NextSelectedTabId
		}
	}
	else {
		// Actually select before expecting closure attempt (on an UnsavedDocument tab user is expect to e.g. show a popup)
		if tab_bar.VisibleTabId != tab.ID { TabBarQueueFocus(tab_bar, tab) }
	}
}

TabBarScrollClamp :: proc(tab_bar : ^ImGuiTabBar, scrolling : f32) -> f32
{
	scrolling := ImMin(scrolling, tab_bar.WidthAllTabs - GetWidth(tab_bar.BarRect))
	return ImMax(scrolling, 0.0)
}

// Note: we may scroll to tab that are not selected! e.g. using keyboard arrow keys
TabBarScrollToTab :: proc(tab_bar : ^ImGuiTabBar, tab_id : ImGuiID, sections : [^]ImGuiTabBarSection)
{
	tab : ^ImGuiTabItem = TabBarFindTabByID(tab_bar, tab_id)
	if tab == nil { return }
	if (tab.Flags & cast(ImGuiTabItemFlags) ImGuiTabItemFlagsPrivate_.ImGuiTabItemFlags_SectionMask_) != {} { return }

	g : ^ImGuiContext = GImGui
	margin : f32 = g.FontSize * 1.0; // When to scroll to make Tab N+1 visible always make a bit of N visible to suggest more scrolling area (since we don't have a scrollbar)
	order : i32 = TabBarGetTabOrder(tab_bar, tab)

	// Scrolling happens only in the central section (leading/trailing sections are not scrolling)
	scrollable_width : f32 = TabBarCalcScrollableWidth(tab_bar, sections)

	// We make all tabs positions all relative Sections[0].Width to make code simpler
	tab_x1 : f32 = tab.Offset - sections[0].Width + (order > sections[0].TabCount - 1 ? -margin : 0.0)
	tab_x2 : f32 = tab.Offset - sections[0].Width + tab.Width + (order + 1 < tab_bar.Tabs.Size - sections[2].TabCount ? margin : 1.0)
	tab_bar.ScrollingTargetDistToVisibility = 0.0
	if tab_bar.ScrollingTarget > tab_x1 || (tab_x2 - tab_x1 >= scrollable_width) {
		// Scroll to the left
		tab_bar.ScrollingTargetDistToVisibility = ImMax(tab_bar.ScrollingAnim - tab_x2, 0.0)
		tab_bar.ScrollingTarget = tab_x1
	}
	else if tab_bar.ScrollingTarget < tab_x2 - scrollable_width {
		// Scroll to the right
		tab_bar.ScrollingTargetDistToVisibility = ImMax((tab_x1 - scrollable_width) - tab_bar.ScrollingAnim, 0.0)
		tab_bar.ScrollingTarget = tab_x2 - scrollable_width
	}
}

TabBarQueueFocus_0 :: proc(tab_bar : ^ImGuiTabBar, tab : ^ImGuiTabItem)
{
	tab_bar.NextSelectedTabId = tab.ID
}

TabBarQueueFocus_1 :: proc(tab_bar : ^ImGuiTabBar, tab_name : string)
{
	IM_ASSERT((tab_bar.Flags & cast(ImGuiTabBarFlags) ImGuiTabBarFlagsPrivate_.ImGuiTabBarFlags_DockNode) == {}); // Only supported for manual/explicit tab bars
	tab_id : ImGuiID = TabBarCalcTabID(tab_bar, tab_name, nil)
	tab_bar.NextSelectedTabId = tab_id
}

TabBarQueueReorder :: proc(tab_bar : ^ImGuiTabBar, tab : ^ImGuiTabItem, offset : i32)
{
	IM_ASSERT(offset != 0)
	IM_ASSERT(tab_bar.ReorderRequestTabId == 0)
	tab_bar.ReorderRequestTabId = tab.ID
	tab_bar.ReorderRequestOffset = cast(ImS16) offset
}

TabBarQueueReorderFromMousePos :: proc(tab_bar : ^ImGuiTabBar, src_tab : ^ImGuiTabItem, mouse_pos : ImVec2)
{
	g : ^ImGuiContext = GImGui
	IM_ASSERT(tab_bar.ReorderRequestTabId == 0)
	if (tab_bar.Flags & ImGuiTabBarFlags_.ImGuiTabBarFlags_Reorderable) == {} { return }

	is_central_section : bool = (src_tab.Flags & cast(ImGuiTabItemFlags) ImGuiTabItemFlagsPrivate_.ImGuiTabItemFlags_SectionMask_) == {}
	bar_offset : f32 = tab_bar.BarRect.Min.x - (is_central_section ? tab_bar.ScrollingTarget : 0)

	// Count number of contiguous tabs we are crossing over
	dir : i32 = (bar_offset + src_tab.Offset) > mouse_pos.x ? -1 : +1
	src_idx : i32 = index_from_ptr(&tab_bar.Tabs, src_tab)
	dst_idx : i32 = src_idx
	for i : i32 = src_idx; i >= 0 && i < tab_bar.Tabs.Size; i += dir {
		// Reordered tabs must share the same section
		dst_tab : ^ImGuiTabItem = &tab_bar.Tabs.Data[i]
		if (dst_tab.Flags & ImGuiTabItemFlags_.ImGuiTabItemFlags_NoReorder) != {} { break }
		if (dst_tab.Flags & cast(ImGuiTabItemFlags) ImGuiTabItemFlagsPrivate_.ImGuiTabItemFlags_SectionMask_) != (src_tab.Flags & cast(ImGuiTabItemFlags) ImGuiTabItemFlagsPrivate_.ImGuiTabItemFlags_SectionMask_) { break }
		dst_idx = i

		// Include spacing after tab, so when mouse cursor is between tabs we would not continue checking further tabs that are not hovered.
		x1 : f32 = bar_offset + dst_tab.Offset - g.Style.ItemInnerSpacing.x
		x2 : f32 = bar_offset + dst_tab.Offset + dst_tab.Width + g.Style.ItemInnerSpacing.x
		//GetForegroundDrawList()->AddRect(ImVec2{x1, tab_bar->BarRect.Min.y}, ImVec2{x2, tab_bar->BarRect.Max.y}, IM_COL32(255, 0, 0, 255));
		if (dir < 0 && mouse_pos.x > x1) || (dir > 0 && mouse_pos.x < x2) { break }
	}

	if dst_idx != src_idx { TabBarQueueReorder(tab_bar, src_tab, dst_idx - src_idx) }
}

TabBarProcessReorder :: proc(tab_bar : ^ImGuiTabBar) -> bool
{
	tab1 : ^ImGuiTabItem = TabBarFindTabByID(tab_bar, tab_bar.ReorderRequestTabId)
	if tab1 == nil || (tab1.Flags & ImGuiTabItemFlags_.ImGuiTabItemFlags_NoReorder) != {} { return false }

	//IM_ASSERT(tab_bar->Flags & ImGuiTabBarFlags_Reorderable); // <- this may happen when using debug tools
	tab2_order : i32 = TabBarGetTabOrder(tab_bar, tab1) + i32(tab_bar.ReorderRequestOffset)
	if tab2_order < 0 || tab2_order >= tab_bar.Tabs.Size { return false }

	// Reordered tabs must share the same section
	// (Note: TabBarQueueReorderFromMousePos() also has a similar test but since we allow direct calls to TabBarQueueReorder() we do it here too)
	tab2 : ^ImGuiTabItem = &tab_bar.Tabs.Data[tab2_order]
	if (tab2.Flags & ImGuiTabItemFlags_.ImGuiTabItemFlags_NoReorder) != {} { return false }
	if (tab1.Flags & cast(ImGuiTabItemFlags) ImGuiTabItemFlagsPrivate_.ImGuiTabItemFlags_SectionMask_) != (tab2.Flags & cast(ImGuiTabItemFlags) ImGuiTabItemFlagsPrivate_.ImGuiTabItemFlags_SectionMask_) { return false }

	item_tmp : ImGuiTabItem = tab1^
	src_tab : ^ImGuiTabItem = (tab_bar.ReorderRequestOffset > 0) ? mem.ptr_offset(tab1, 1) : tab2
	dst_tab : ^ImGuiTabItem = (tab_bar.ReorderRequestOffset > 0) ? tab1 : mem.ptr_offset(tab2, 1)
	move_count : i32 = i32((tab_bar.ReorderRequestOffset > 0) ? tab_bar.ReorderRequestOffset : -tab_bar.ReorderRequestOffset)
	memmove(dst_tab, src_tab, int(move_count * size_of(ImGuiTabItem)))
	tab2^ = item_tmp

	if (tab_bar.Flags & cast(ImGuiTabBarFlags) ImGuiTabBarFlagsPrivate_.ImGuiTabBarFlags_SaveSettings) != {} { MarkIniSettingsDirty() }
	return true
}

TabBarScrollingButtons :: proc(tab_bar : ^ImGuiTabBar) -> ^ImGuiTabItem
{
	g : ^ImGuiContext = GImGui
	window : ^ImGuiWindow = g.CurrentWindow

	arrow_button_size := ImVec2{ g.FontSize - 2.0, g.FontSize + g.Style.FramePadding.y * 2.0 }
	scrolling_buttons_width : f32 = arrow_button_size.x * 2.0

	backup_cursor_pos : ImVec2 = window.DC.CursorPos
	//window->DrawList->AddRect(ImVec2{tab_bar->BarRect.Max.x - scrolling_buttons_width, tab_bar->BarRect.Min.y}, ImVec2{tab_bar->BarRect.Max.x, tab_bar->BarRect.Max.y}, IM_COL32(255,0,0,255));

	select_dir : i32 = 0
	arrow_col : ImVec4 = g.Style.Colors[ImGuiCol_.ImGuiCol_Text]
	arrow_col.w *= 0.5

	PushStyleColor(ImGuiCol_.ImGuiCol_Text, arrow_col)
	PushStyleColor(ImGuiCol_.ImGuiCol_Button, ImVec4{0, 0, 0, 0})
	PushItemFlag(ImGuiItemFlags_.ImGuiItemFlags_ButtonRepeat, true)
	backup_repeat_delay : f32 = g.IO.KeyRepeatDelay
	backup_repeat_rate : f32 = g.IO.KeyRepeatRate
	g.IO.KeyRepeatDelay = 0.250
	g.IO.KeyRepeatRate = 0.200
	x : f32 = ImMax(tab_bar.BarRect.Min.x, tab_bar.BarRect.Max.x - scrolling_buttons_width)
	window.DC.CursorPos = ImVec2{x, tab_bar.BarRect.Min.y}
	if ArrowButtonEx("##<", ImGuiDir.ImGuiDir_Left, arrow_button_size, cast(ImGuiButtonFlags)ImGuiButtonFlagsPrivate_.ImGuiButtonFlags_PressedOnClick) { select_dir = -1 }
	window.DC.CursorPos = ImVec2{x + arrow_button_size.x, tab_bar.BarRect.Min.y}
	if ArrowButtonEx("##>", ImGuiDir.ImGuiDir_Right, arrow_button_size, cast(ImGuiButtonFlags)ImGuiButtonFlagsPrivate_.ImGuiButtonFlags_PressedOnClick) { select_dir = +1 }
	PopItemFlag()
	PopStyleColor(2)
	g.IO.KeyRepeatRate = backup_repeat_rate
	g.IO.KeyRepeatDelay = backup_repeat_delay

	tab_to_scroll_to : ^ImGuiTabItem = nil
	if select_dir != 0 { if tab_item : ^ImGuiTabItem = TabBarFindTabByID(tab_bar, tab_bar.SelectedTabId); tab_item != nil {
	selected_order : i32 = TabBarGetTabOrder(tab_bar, tab_item)
	target_order : i32 = selected_order + select_dir

	// Skip tab item buttons until another tab item is found or end is reached
	for tab_to_scroll_to == nil {
		// If we are at the end of the list, still scroll to make our tab visible
		tab_to_scroll_to = &tab_bar.Tabs.Data[(target_order >= 0 && target_order < tab_bar.Tabs.Size) ? target_order : selected_order]

		// Cross through buttons
		// (even if first/last item is a button, return it so we can update the scroll)
		if (tab_to_scroll_to.Flags & cast(ImGuiTabItemFlags) ImGuiTabItemFlagsPrivate_.ImGuiTabItemFlags_Button) != {} {
			target_order += select_dir
			selected_order += select_dir
			tab_to_scroll_to = (target_order < 0 || target_order >= tab_bar.Tabs.Size) ? tab_to_scroll_to : nil
		}
	}
} }
	window.DC.CursorPos = backup_cursor_pos
	tab_bar.BarRect.Max.x -= scrolling_buttons_width + 1.0

	return tab_to_scroll_to
}

TabBarTabListPopupButton :: proc(tab_bar : ^ImGuiTabBar) -> ^ImGuiTabItem
{
	g : ^ImGuiContext = GImGui
	window : ^ImGuiWindow = g.CurrentWindow

	// We use g.Style.FramePadding.y to match the square ArrowButton size
	tab_list_popup_button_width : f32 = g.FontSize + g.Style.FramePadding.y
	backup_cursor_pos : ImVec2 = window.DC.CursorPos
	window.DC.CursorPos = ImVec2{tab_bar.BarRect.Min.x - g.Style.FramePadding.y, tab_bar.BarRect.Min.y}
	tab_bar.BarRect.Min.x += tab_list_popup_button_width

	arrow_col : ImVec4 = g.Style.Colors[ImGuiCol_.ImGuiCol_Text]
	arrow_col.w *= 0.5
	PushStyleColor(ImGuiCol_.ImGuiCol_Text, arrow_col)
	PushStyleColor(ImGuiCol_.ImGuiCol_Button, ImVec4{0, 0, 0, 0})
	open : bool = BeginCombo("##v", "", ImGuiComboFlags_.ImGuiComboFlags_NoPreview | ImGuiComboFlags_.ImGuiComboFlags_HeightLargest)
	PopStyleColor(2)

	tab_to_select : ^ImGuiTabItem = nil
	if open {
		for tab_n : i32 = 0; tab_n < tab_bar.Tabs.Size; tab_n += 1 {
			tab : ^ImGuiTabItem = &tab_bar.Tabs.Data[tab_n]
			if (tab.Flags & cast(ImGuiTabItemFlags) ImGuiTabItemFlagsPrivate_.ImGuiTabItemFlags_Button) != {} { continue }

			tab_name := TabBarGetTabName(tab_bar, tab)
			if Selectable(tab_name, tab_bar.SelectedTabId == tab.ID) { tab_to_select = tab }
		}

		EndCombo()
	}

	window.DC.CursorPos = backup_cursor_pos
	return tab_to_select
}

//-------------------------------------------------------------------------
// [SECTION] Widgets: BeginTabItem, EndTabItem, etc.
//-------------------------------------------------------------------------
// - BeginTabItem()
// - EndTabItem()
// - TabItemButton()
// - TabItemEx() [Internal]
// - SetTabItemClosed()
// - TabItemCalcSize() [Internal]
// - TabItemBackground() [Internal]
// - TabItemLabelAndCloseButton() [Internal]
//-------------------------------------------------------------------------

BeginTabItem :: proc(label : string, p_open : ^bool, flags : ImGuiTabItemFlags) -> bool
{
	g : ^ImGuiContext = GImGui
	window : ^ImGuiWindow = g.CurrentWindow
	if window.SkipItems { return false }

	tab_bar : ^ImGuiTabBar = g.CurrentTabBar
	if tab_bar == nil {
		IM_ASSERT_USER_ERROR(tab_bar != nil, "Needs to be called between BeginTabBar() and EndTabBar()!")
		return false
	}
	IM_ASSERT((flags & cast(ImGuiTabItemFlags) ImGuiTabItemFlagsPrivate_.ImGuiTabItemFlags_Button) == {}); // BeginTabItem() Can't be used with button flags, use TabItemButton() instead!

	ret : bool = TabItemEx(tab_bar, label, p_open, flags, nil)
	if ret && (flags & ImGuiTabItemFlags_.ImGuiTabItemFlags_NoPushId) == {} {
		tab : ^ImGuiTabItem = &tab_bar.Tabs.Data[tab_bar.LastTabItemIdx]
		PushOverrideID(tab.ID); // We already hashed 'label' so push into the ID stack directly instead of doing another hash through PushID(label)
	}
	return ret
}

EndTabItem :: proc()
{
	g : ^ImGuiContext = GImGui
	window : ^ImGuiWindow = g.CurrentWindow
	if window.SkipItems { return }

	tab_bar : ^ImGuiTabBar = g.CurrentTabBar
	if tab_bar == nil {
		IM_ASSERT_USER_ERROR(tab_bar != nil, "Needs to be called between BeginTabBar() and EndTabBar()!")
		return
	}
	IM_ASSERT(tab_bar.LastTabItemIdx >= 0)
	tab : ^ImGuiTabItem = &tab_bar.Tabs.Data[tab_bar.LastTabItemIdx]
	if (tab.Flags & ImGuiTabItemFlags_.ImGuiTabItemFlags_NoPushId) == {} { PopID() }
}

TabItemButton :: proc(label : string, flags : ImGuiTabItemFlags) -> bool
{
	g : ^ImGuiContext = GImGui
	window : ^ImGuiWindow = g.CurrentWindow
	if window.SkipItems { return false }

	tab_bar : ^ImGuiTabBar = g.CurrentTabBar
	if tab_bar == nil {
		IM_ASSERT_USER_ERROR(tab_bar != nil, "Needs to be called between BeginTabBar() and EndTabBar()!")
		return false
	}
	return TabItemEx(tab_bar, label, nil, flags | ImGuiTabItemFlags(ImGuiTabItemFlagsPrivate_.ImGuiTabItemFlags_Button) | ImGuiTabItemFlags_.ImGuiTabItemFlags_NoReorder, nil)
}

TabItemEx :: proc(tab_bar : ^ImGuiTabBar, label : string, p_open : ^bool, flags : ImGuiTabItemFlags, docked_window : ^ImGuiWindow) -> bool
{
	// Layout whole tab bar if not already done
	g : ^ImGuiContext = GImGui
	if tab_bar.WantLayout {
		backup_next_item_data : ImGuiNextItemData = g.NextItemData
		TabBarLayout(tab_bar)
		g.NextItemData = backup_next_item_data
	}
	window : ^ImGuiWindow = g.CurrentWindow
	if window.SkipItems { return false }

	style : ^ImGuiStyle = &g.Style
	id : ImGuiID = TabBarCalcTabID(tab_bar, label, docked_window)

	// If the user called us with *p_open == false, we early out and don't render.
	// We make a call to ItemAdd() so that attempts to use a contextual popup menu with an implicit ID won't use an older ID.
	IMGUI_TEST_ENGINE_ITEM_INFO(g, id, label, g.LastItemData.StatusFlags)
	if p_open != nil && !p_open^ {
		ItemAdd(ImRect{}, id, nil, ImGuiItemFlags_.ImGuiItemFlags_NoNav)
		return false
	}

	IM_ASSERT(p_open == nil || (flags & cast(ImGuiTabItemFlags) ImGuiTabItemFlagsPrivate_.ImGuiTabItemFlags_Button) == {})
	IM_ASSERT((flags & (ImGuiTabItemFlags_.ImGuiTabItemFlags_Leading | ImGuiTabItemFlags_.ImGuiTabItemFlags_Trailing)) != (ImGuiTabItemFlags_.ImGuiTabItemFlags_Leading | ImGuiTabItemFlags_.ImGuiTabItemFlags_Trailing)); // Can't use both Leading and Trailing

	flags, p_open := flags, p_open
	// Store into ImGuiTabItemFlags_NoCloseButton, also honor ImGuiTabItemFlags_NoCloseButton passed by user (although not documented)
	if (flags & cast(ImGuiTabItemFlags) ImGuiTabItemFlagsPrivate_.ImGuiTabItemFlags_NoCloseButton) != {} { p_open = nil }
	else if p_open == nil { flags |= cast(ImGuiTabItemFlags) ImGuiTabItemFlagsPrivate_.ImGuiTabItemFlags_NoCloseButton }

	// Acquire tab data
	tab : ^ImGuiTabItem = TabBarFindTabByID(tab_bar, id)
	tab_is_new : bool = false
	if tab == nil {
		v : ImGuiTabItem
		init(&v)
		push_back(&tab_bar.Tabs, v)
		tab = back(&tab_bar.Tabs)
		tab.ID = id
		tab_is_new = true; tab_bar.TabsAddedNew = tab_is_new
	}
	tab_bar.LastTabItemIdx = cast(ImS16) index_from_ptr(&tab_bar.Tabs, tab)

	// Calculate tab contents size
	size : ImVec2 = TabItemCalcSize(label, (p_open != nil) || (flags & ImGuiTabItemFlags_.ImGuiTabItemFlags_UnsavedDocument) != {})
	tab.RequestedWidth = -1.0
	if (g.NextItemData.HasFlags & ImGuiNextItemDataFlags_.ImGuiNextItemDataFlags_HasWidth) != {} { tab.RequestedWidth = g.NextItemData.Width; size.x = tab.RequestedWidth }
	if tab_is_new { tab.Width = ImMax(f32(1.0), size.x) }
	tab.ContentWidth = size.x
	tab.BeginOrder = post_incr(&tab_bar.TabsActiveCount)

	tab_bar_appearing : bool = (tab_bar.PrevFrameVisible + 1 < g.FrameCount)
	tab_bar_focused : bool = (tab_bar.Flags & cast(ImGuiTabBarFlags) ImGuiTabBarFlagsPrivate_.ImGuiTabBarFlags_IsFocused) != {}
	tab_appearing : bool = (tab.LastFrameVisible + 1 < g.FrameCount)
	tab_just_unsaved : bool = (flags & ImGuiTabItemFlags_.ImGuiTabItemFlags_UnsavedDocument) != {} && (tab.Flags & ImGuiTabItemFlags_.ImGuiTabItemFlags_UnsavedDocument) == {}
	is_tab_button : bool = (flags & cast(ImGuiTabItemFlags) ImGuiTabItemFlagsPrivate_.ImGuiTabItemFlags_Button) != {}
	tab.LastFrameVisible = g.FrameCount
	tab.Flags = flags
	tab.Window = docked_window

	// Append name _WITH_ the zero-terminator
	// (regular tabs are permitted in a DockNode tab bar, but window tabs not permitted in a non-DockNode tab bar)
	if docked_window != nil {
		IM_ASSERT((tab_bar.Flags & cast(ImGuiTabBarFlags) ImGuiTabBarFlagsPrivate_.ImGuiTabBarFlags_DockNode) != {})
		tab.NameOffset = -1
	}
	else {
		tab.NameOffset = cast(ImS32) ImGuiTextBuffer_size(&tab_bar.TabsNames)
		append(&tab_bar.TabsNames, label)
		n : [1]u8; append(&tab_bar.TabsNames, raw_data(&n), &raw_data(&n)[1])
	}

	// Update selected tab
	if !is_tab_button {
		if tab_appearing && (tab_bar.Flags & ImGuiTabBarFlags_.ImGuiTabBarFlags_AutoSelectNewTabs) != {} && tab_bar.NextSelectedTabId == 0 {
			if !tab_bar_appearing || tab_bar.SelectedTabId == 0 {
				// New tabs gets activated
				TabBarQueueFocus(tab_bar, tab)
			}
		}
		if (flags & ImGuiTabItemFlags_.ImGuiTabItemFlags_SetSelected) != {} && (tab_bar.SelectedTabId != id) {
			// _SetSelected can only be passed on explicit tab bar
			TabBarQueueFocus(tab_bar, tab)
		}
	}

	// Lock visibility
	// (Note: tab_contents_visible != tab_selected... because CTRL+TAB operations may preview some tabs without selecting them!)
	tab_contents_visible : bool = (tab_bar.VisibleTabId == id)
	if tab_contents_visible { tab_bar.VisibleTabWasSubmitted = true }

	// On the very first frame of a tab bar we let first tab contents be visible to minimize appearing glitches
	if !tab_contents_visible && tab_bar.SelectedTabId == 0 && tab_bar_appearing && docked_window == nil { if tab_bar.Tabs.Size == 1 && (tab_bar.Flags & ImGuiTabBarFlags_.ImGuiTabBarFlags_AutoSelectNewTabs) == {} { tab_contents_visible = true } }

	// Note that tab_is_new is not necessarily the same as tab_appearing! When a tab bar stops being submitted
	// and then gets submitted again, the tabs will have 'tab_appearing=true' but 'tab_is_new=false'.
	if tab_appearing && (!tab_bar_appearing || tab_is_new) {
		ItemAdd(ImRect{}, id, nil, ImGuiItemFlags_.ImGuiItemFlags_NoNav)
		if is_tab_button { return false }
		return tab_contents_visible
	}

	if tab_bar.SelectedTabId == id { tab.LastFrameSelected = g.FrameCount }

	// Backup current layout position
	backup_main_cursor_pos : ImVec2 = window.DC.CursorPos

	// Layout
	is_central_section : bool = (tab.Flags & cast(ImGuiTabItemFlags) ImGuiTabItemFlagsPrivate_.ImGuiTabItemFlags_SectionMask_) == {}
	size.x = tab.Width
	if is_central_section { window.DC.CursorPos = tab_bar.BarRect.Min + ImVec2{IM_TRUNC(tab.Offset - tab_bar.ScrollingAnim), 0.0} }
	else { window.DC.CursorPos = tab_bar.BarRect.Min + ImVec2{tab.Offset, 0.0} }
	pos : ImVec2 = window.DC.CursorPos
	bb : ImRect; init(&bb, pos, pos + size)

	// We don't have CPU clipping primitives to clip the CloseButton (until it becomes a texture), so need to add an extra draw call (temporary in the case of vertical animation)
	want_clip_rect : bool = is_central_section && (bb.Min.x < tab_bar.ScrollingRectMinX || bb.Max.x > tab_bar.ScrollingRectMaxX)
	if want_clip_rect { PushClipRect(ImVec2{ImMax(bb.Min.x, tab_bar.ScrollingRectMinX), bb.Min.y - 1}, ImVec2{tab_bar.ScrollingRectMaxX, bb.Max.y}, true) }

	backup_cursor_max_pos : ImVec2 = window.DC.CursorMaxPos
	ItemSize(GetSize(bb), style.FramePadding.y)
	window.DC.CursorMaxPos = backup_cursor_max_pos

	if !ItemAdd(bb, id) {
		if want_clip_rect { PopClipRect() }
		window.DC.CursorPos = backup_main_cursor_pos
		return tab_contents_visible
	}

	// Click to Select a tab
	button_flags : ImGuiButtonFlags = ImGuiButtonFlags((is_tab_button ? ImGuiButtonFlagsPrivate_.ImGuiButtonFlags_PressedOnClickRelease : ImGuiButtonFlagsPrivate_.ImGuiButtonFlags_PressedOnClick) | ImGuiButtonFlagsPrivate_.ImGuiButtonFlags_AllowOverlap)
	if g.DragDropActive && !IsDataType(&g.DragDropPayload, IMGUI_PAYLOAD_TYPE_WINDOW) {
		// FIXME: May be an opt-in property of the payload to disable this
		button_flags |= cast(ImGuiButtonFlags) ImGuiButtonFlagsPrivate_.ImGuiButtonFlags_PressedOnDragDropHold
	}
	hovered : bool; held : bool
	pressed : bool = ButtonBehavior(bb, id, &hovered, &held, button_flags)
	if pressed && !is_tab_button { TabBarQueueFocus(tab_bar, tab) }

	// Transfer active id window so the active id is not owned by the dock host (as StartMouseMovingWindow()
	// will only do it on the drag). This allows FocusWindow() to be more conservative in how it clears active id.
	if held && docked_window != nil && g.ActiveId == id && g.ActiveIdIsJustActivated { g.ActiveIdWindow = docked_window }

	// Drag and drop a single floating window node moves it
	node : ^ImGuiDockNode = docked_window != nil ? docked_window.DockNode : nil
	single_floating_window_node : bool = node != nil && IsFloatingNode(node) && (node.Windows.Size == 1)
	if held && single_floating_window_node && IsMouseDragging(ImGuiMouseButton(0), 0.0) {
		// Move
		StartMouseMovingWindow(docked_window)
	}
	else if held && !tab_appearing && IsMouseDragging(ImGuiMouseButton(0)) {
		// Drag and drop: re-order tabs
		drag_dir : i32 = 0
		drag_distance_from_edge_x : f32 = 0.0
		if !g.DragDropActive && ((tab_bar.Flags & ImGuiTabBarFlags_.ImGuiTabBarFlags_Reorderable) != {} || (docked_window != nil)) {
			// While moving a tab it will jump on the other side of the mouse, so we also test for MouseDelta.x
			if g.IO.MouseDelta.x < 0.0 && g.IO.MousePos.x < bb.Min.x {
				drag_dir = -1
				drag_distance_from_edge_x = bb.Min.x - g.IO.MousePos.x
				TabBarQueueReorderFromMousePos(tab_bar, tab, g.IO.MousePos)
			}
			else if g.IO.MouseDelta.x > 0.0 && g.IO.MousePos.x > bb.Max.x {
				drag_dir = +1
				drag_distance_from_edge_x = g.IO.MousePos.x - bb.Max.x
				TabBarQueueReorderFromMousePos(tab_bar, tab, g.IO.MousePos)
			}
		}

		// Extract a Dockable window out of it's tab bar
		can_undock : bool = docked_window != nil && (docked_window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoMove) == {} && (node.MergedFlags & ImGuiDockNodeFlags_.ImGuiDockNodeFlags_NoUndocking) == {}
		if can_undock {
			// We use a variable threshold to distinguish dragging tabs within a tab bar and extracting them out of the tab bar
			undocking_tab : bool = (g.DragDropActive && g.DragDropPayload.SourceId == id)
			if !undocking_tab {
				//&& (!g.IO.ConfigDockingWithShift || g.IO.KeyShift)
				threshold_base : f32 = g.FontSize
				threshold_x : f32 = (threshold_base * 2.2)
				threshold_y : f32 = (threshold_base * 1.5) + ImClamp((ImFabs(g.IO.MouseDragMaxDistanceAbs[0].x) - threshold_base * 2.0) * 0.20, 0.0, threshold_base * 4.0)
				//GetForegroundDrawList()->AddRect(ImVec2{bb.Min.x - threshold_x, bb.Min.y - threshold_y}, ImVec2{bb.Max.x + threshold_x, bb.Max.y + threshold_y}, IM_COL32_WHITE); // [DEBUG]

				distance_from_edge_y : f32 = ImMax(bb.Min.y - g.IO.MousePos.y, g.IO.MousePos.y - bb.Max.y)
				if distance_from_edge_y >= threshold_y { undocking_tab = true }
				if drag_distance_from_edge_x > threshold_x { if (drag_dir < 0 && TabBarGetTabOrder(tab_bar, tab) == 0) || (drag_dir > 0 && TabBarGetTabOrder(tab_bar, tab) == tab_bar.Tabs.Size - 1) { undocking_tab = true } }
			}

			if undocking_tab {
				// Undock
				// FIXME: refactor to share more code with e.g. StartMouseMovingWindow
				DockContextQueueUndockWindow(g, docked_window)
				g.MovingWindow = docked_window
				SetActiveID(g.MovingWindow.MoveId, g.MovingWindow)
				g.ActiveIdClickOffset -= g.MovingWindow.Pos - bb.Min
				g.ActiveIdNoClearOnFocusLoss = true
				SetActiveIdUsingAllKeyboardKeys()
			}
		}
	}



	// Render tab shape
	display_draw_list : ^ImDrawList = window.DrawList
	tab_col : ImU32 = GetColorU32((held || hovered) ? ImGuiCol_.ImGuiCol_TabHovered : tab_contents_visible ? (tab_bar_focused ? ImGuiCol_.ImGuiCol_TabSelected : ImGuiCol_.ImGuiCol_TabDimmedSelected) : (tab_bar_focused ? ImGuiCol_.ImGuiCol_Tab : ImGuiCol_.ImGuiCol_TabDimmed))
	TabItemBackground(display_draw_list, bb, flags, tab_col)
	if tab_contents_visible && (tab_bar.Flags & ImGuiTabBarFlags_.ImGuiTabBarFlags_DrawSelectedOverline) != {} && style.TabBarOverlineSize > 0.0 {
		x_offset : f32 = IM_TRUNC(0.4 * style.TabRounding)
		if x_offset < 2.0 * g.CurrentDpiScale { x_offset = 0.0 }
		y_offset : f32 = 1.0 * g.CurrentDpiScale
		AddLine(display_draw_list, GetTL(bb) + ImVec2{x_offset, y_offset}, GetTR(bb) + ImVec2{-x_offset, y_offset}, GetColorU32(tab_bar_focused ? ImGuiCol_.ImGuiCol_TabSelectedOverline : ImGuiCol_.ImGuiCol_TabDimmedSelectedOverline), style.TabBarOverlineSize)
	}
	RenderNavCursor(bb, id)

	// Select with right mouse button. This is so the common idiom for context menu automatically highlight the current widget.
	hovered_unblocked : bool = IsItemHovered(ImGuiHoveredFlags_.ImGuiHoveredFlags_AllowWhenBlockedByPopup)
	if tab_bar.SelectedTabId != tab.ID && hovered_unblocked && (IsMouseClicked(cast(ImGuiMouseButton) 1) || IsMouseReleased(cast(ImGuiMouseButton) 1)) && !is_tab_button { TabBarQueueFocus(tab_bar, tab) }

	if (tab_bar.Flags & ImGuiTabBarFlags_.ImGuiTabBarFlags_NoCloseWithMiddleMouseButton) != {} { flags |= ImGuiTabItemFlags_.ImGuiTabItemFlags_NoCloseWithMiddleMouseButton }

	// Render tab label, process close button
	close_button_id : ImGuiID = p_open != nil ? GetIDWithSeed("#CLOSE", docked_window != nil ? docked_window.ID : id) : 0
	just_closed : bool
	text_clipped : bool
	TabItemLabelAndCloseButton(display_draw_list, bb, tab_just_unsaved ? (flags & cast(ImGuiTabItemFlags)~cast(i32)ImGuiTabItemFlags_.ImGuiTabItemFlags_UnsavedDocument) : flags, tab_bar.FramePadding, label, id, close_button_id, tab_contents_visible, &just_closed, &text_clipped)
	if just_closed && p_open != nil {
		p_open^ = false
		TabBarCloseTab(tab_bar, tab)
	}

	// Forward Hovered state so IsItemHovered() after Begin() can work (even though we are technically hovering our parent)
	// That state is copied to window->DockTabItemStatusFlags by our caller.
	if docked_window != nil && (hovered || g.HoveredId == close_button_id) { g.LastItemData.StatusFlags |= ImGuiItemStatusFlags_.ImGuiItemStatusFlags_HoveredWindow }

	// Restore main window position so user can draw there
	if want_clip_rect { PopClipRect() }
	window.DC.CursorPos = backup_main_cursor_pos

	// Tooltip
	// (Won't work over the close button because ItemOverlap systems messes up with HoveredIdTimer-> seems ok)
	// (We test IsItemHovered() to discard e.g. when another item is active or drag and drop over the tab bar, which g.HoveredId ignores)
	// FIXME: This is a mess.
	// FIXME: We may want disabled tab to still display the tooltip?
	if text_clipped && g.HoveredId == id && !held { if (tab_bar.Flags & ImGuiTabBarFlags_.ImGuiTabBarFlags_NoTooltip) == {} && (tab.Flags & ImGuiTabItemFlags_.ImGuiTabItemFlags_NoTooltip) == {} { SetItemTooltip("%s", label[:FindRenderedTextEnd(label)]) } }

	IM_ASSERT(!is_tab_button || !(tab_bar.SelectedTabId == tab.ID && is_tab_button)); // TabItemButton should not be selected
	if is_tab_button { return pressed }
	return tab_contents_visible
}

// [Public] This is call is 100% optional but it allows to remove some one-frame glitches when a tab has been unexpectedly removed.
// To use it to need to call the function SetTabItemClosed() between BeginTabBar() and EndTabBar().
// Tabs closed by the close button will automatically be flagged to avoid this issue.
SetTabItemClosed :: proc(label : string)
{
	g : ^ImGuiContext = GImGui
	is_within_manual_tab_bar : bool = g.CurrentTabBar != nil && (g.CurrentTabBar.Flags & cast(ImGuiTabBarFlags) ImGuiTabBarFlagsPrivate_.ImGuiTabBarFlags_DockNode) == {}
	if is_within_manual_tab_bar {
		tab_bar : ^ImGuiTabBar = g.CurrentTabBar
		tab_id : ImGuiID = TabBarCalcTabID(tab_bar, label, nil)
		if tab : ^ImGuiTabItem = TabBarFindTabByID(tab_bar, tab_id); tab != nil {
			// Will be processed by next call to TabBarLayout()
			tab.WantClose = true
		}
	}
	else if window : ^ImGuiWindow = FindWindowByName(label); window != nil {
		if window.DockIsActive { if node : ^ImGuiDockNode = window.DockNode; node != nil {
	tab_id : ImGuiID = TabBarCalcTabID(node.TabBar, label, window)
	TabBarRemoveTab(node.TabBar, tab_id)
	window.DockTabWantClose = true
} }
	}
}

TabItemCalcSize_0 :: proc(label : string, has_close_button_or_unsaved_marker : bool) -> ImVec2
{
	g : ^ImGuiContext = GImGui
	label_size : ImVec2 = CalcTextSize(label, true)
	size : ImVec2 = ImVec2{label_size.x + g.Style.FramePadding.x, label_size.y + g.Style.FramePadding.y * 2.0}
	if has_close_button_or_unsaved_marker {
		// We use Y intentionally to fit the close button circle.
		size.x += g.Style.FramePadding.x + (g.Style.ItemInnerSpacing.x + g.FontSize)
	}
	else { size.x += g.Style.FramePadding.x + 1.0 }
	return ImVec2{ImMin(size.x, TabBarCalcMaxTabWidth()), size.y}
}

TabItemCalcSize_1 :: proc(window : ^ImGuiWindow) -> ImVec2
{
	return TabItemCalcSize(window.Name, window.HasCloseButton || (window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_UnsavedDocument) != {})
}

TabItemBackground :: proc(draw_list : ^ImDrawList, bb : ImRect, flags : ImGuiTabItemFlags, col : ImU32)
{
	// While rendering tabs, we trim 1 pixel off the top of our bounding box so they can fit within a regular frame height while looking "detached" from it.
	g : ^ImGuiContext = GImGui
	width : f32 = GetWidth(bb)
	IM_UNUSED(flags)
	IM_ASSERT(width > 0.0)
	rounding : f32 = ImMax(f32(0.0), ImMin((flags & cast(ImGuiTabItemFlags) ImGuiTabItemFlagsPrivate_.ImGuiTabItemFlags_Button) != {} ? g.Style.FrameRounding : g.Style.TabRounding, width * 0.5 - 1.0))
	y1 : f32 = bb.Min.y + 1.0
	y2 : f32 = bb.Max.y - g.Style.TabBarBorderSize
	PathLineTo(draw_list, ImVec2{bb.Min.x, y2})
	PathArcToFast(draw_list, ImVec2{bb.Min.x + rounding, y1 + rounding}, rounding, 6, 9)
	PathArcToFast(draw_list, ImVec2{bb.Max.x - rounding, y1 + rounding}, rounding, 9, 12)
	PathLineTo(draw_list, ImVec2{bb.Max.x, y2})
	PathFillConvex(draw_list, col)
	if g.Style.TabBorderSize > 0.0 {
		PathLineTo(draw_list, ImVec2{bb.Min.x + 0.5, y2})
		PathArcToFast(draw_list, ImVec2{bb.Min.x + rounding + 0.5, y1 + rounding + 0.5}, rounding, 6, 9)
		PathArcToFast(draw_list, ImVec2{bb.Max.x - rounding - 0.5, y1 + rounding + 0.5}, rounding, 9, 12)
		PathLineTo(draw_list, ImVec2{bb.Max.x - 0.5, y2})
		PathStroke(draw_list, GetColorU32(ImGuiCol_.ImGuiCol_Border), {}, g.Style.TabBorderSize)
	}
}

// Render text label (with custom clipping) + Unsaved Document marker + Close Button logic
// We tend to lock style.FramePadding for a given tab-bar, hence the 'frame_padding' parameter.
TabItemLabelAndCloseButton :: proc(draw_list : ^ImDrawList, bb : ImRect, flags : ImGuiTabItemFlags, frame_padding : ImVec2, label : string, tab_id : ImGuiID, close_button_id : ImGuiID, is_contents_visible : bool, out_just_closed : ^bool, out_text_clipped : ^bool)
{
	g : ^ImGuiContext = GImGui
	label_size : ImVec2 = CalcTextSize(label, true)

	if out_just_closed != nil { out_just_closed^ = false }
	if out_text_clipped != nil { out_text_clipped^ = false }

	if GetWidth(bb) <= 1.0 { return }

	// In Style V2 we'll have full override of all colors per state (e.g. focused, selected)
	// But right now if you want to alter text color of tabs this is what you need to do.


	// Render text label (with clipping + alpha gradient) + unsaved marker
	text_pixel_clip_bb : ImRect; init(&text_pixel_clip_bb, bb.Min.x + frame_padding.x, bb.Min.y + frame_padding.y, bb.Max.x - frame_padding.x, bb.Max.y)
	text_ellipsis_clip_bb : ImRect = text_pixel_clip_bb

	// Return clipped state ignoring the close button
	if out_text_clipped != nil {
		out_text_clipped^ = (text_ellipsis_clip_bb.Min.x + label_size.x) > text_pixel_clip_bb.Max.x
		//draw_list->AddCircle(text_ellipsis_clip_bb.Min, 3.0f, *out_text_clipped ? IM_COL32(255, 0, 0, 255) : IM_COL32(0, 255, 0, 255));
	}

	button_sz : f32 = g.FontSize
	button_pos := ImVec2{ ImMax(bb.Min.x, bb.Max.x - frame_padding.x - button_sz), bb.Min.y + frame_padding.y }

	// Close Button & Unsaved Marker
	// We are relying on a subtle and confusing distinction between 'hovered' and 'g.HoveredId' which happens because we are using ImGuiButtonFlags_AllowOverlapMode + SetItemAllowOverlap()
	//  'hovered' will be true when hovering the Tab but NOT when hovering the close button
	//  'g.HoveredId==id' will be true when hovering the Tab including when hovering the close button
	//  'g.ActiveId==close_button_id' will be true when we are holding on the close button, in which case both hovered booleans are false
	close_button_pressed : bool = false
	close_button_visible : bool = false
	if close_button_id != 0 { if is_contents_visible || GetWidth(bb) >= ImMax(button_sz, g.Style.TabMinWidthForCloseButton) { if g.HoveredId == tab_id || g.HoveredId == close_button_id || g.ActiveId == tab_id || g.ActiveId == close_button_id { close_button_visible = true } } }
	unsaved_marker_visible : bool = (flags & ImGuiTabItemFlags_.ImGuiTabItemFlags_UnsavedDocument) != {} && (button_pos.x + button_sz <= bb.Max.x)

	if close_button_visible {
		last_item_backup : ImGuiLastItemData = g.LastItemData
		if CloseButton(close_button_id, button_pos) { close_button_pressed = true }
		g.LastItemData = last_item_backup

		// Close with middle mouse button
		if (flags & ImGuiTabItemFlags_.ImGuiTabItemFlags_NoCloseWithMiddleMouseButton) == {} && IsMouseClicked(cast(ImGuiMouseButton) 2) { close_button_pressed = true }
	}
	else if unsaved_marker_visible {
		bullet_bb : ImRect; init(&bullet_bb, button_pos, button_pos + ImVec2{button_sz, button_sz})
		RenderBullet(draw_list, GetCenter(bullet_bb), GetColorU32(ImGuiCol_.ImGuiCol_Text))
	}

	// This is all rather complicated
	// (the main idea is that because the close button only appears on hover, we don't want it to alter the ellipsis position)
	// FIXME: if FramePadding is noticeably large, ellipsis_max_x will be wrong here (e.g. #3497), maybe for consistency that parameter of RenderTextEllipsis() shouldn't exist..
	ellipsis_max_x : f32 = close_button_visible ? text_pixel_clip_bb.Max.x : bb.Max.x - 1.0
	if close_button_visible || unsaved_marker_visible {
		text_pixel_clip_bb.Max.x -= close_button_visible ? (button_sz) : (button_sz * 0.80)
		text_ellipsis_clip_bb.Max.x -= unsaved_marker_visible ? (button_sz * 0.80) : 0.0
		ellipsis_max_x = text_pixel_clip_bb.Max.x
	}
	LogSetNextTextDecoration("/", "\\")
	RenderTextEllipsis(draw_list, text_ellipsis_clip_bb.Min, text_ellipsis_clip_bb.Max, text_pixel_clip_bb.Max.x, ellipsis_max_x, label, 0, &label_size)



	if out_just_closed != nil { out_just_closed^ = close_button_pressed }
}


//
// imgui_tables.cpp
//
// dear imgui, v1.91.7 WIP
// (tables and columns code)

/*

Index of this file:

// [SECTION] Commentary
// [SECTION] Header mess
// [SECTION] Tables: Main code
// [SECTION] Tables: Simple accessors
// [SECTION] Tables: Row changes
// [SECTION] Tables: Columns changes
// [SECTION] Tables: Columns width management
// [SECTION] Tables: Drawing
// [SECTION] Tables: Sorting
// [SECTION] Tables: Headers
// [SECTION] Tables: Context Menu
// [SECTION] Tables: Settings (.ini data)
// [SECTION] Tables: Garbage Collection
// [SECTION] Tables: Debugging
// [SECTION] Columns, BeginColumns, EndColumns, etc.

*/

// Navigating this file:
// - In Visual Studio: CTRL+comma ("Edit.GoToAll") can follow symbols inside comments, whereas CTRL+F12 ("Edit.GoToImplementation") cannot.
// - In Visual Studio w/ Visual Assist installed: ALT+G ("VAssistX.GoToImplementation") can also follow symbols inside comments.
// - In VS Code, CLion, etc.: CTRL+click can follow symbols inside comments.

//-----------------------------------------------------------------------------
// [SECTION] Commentary
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// Typical tables call flow: (root level is generally public API):
//-----------------------------------------------------------------------------
// - BeginTable()                               user begin into a table
//    | BeginChild()                            - (if ScrollX/ScrollY is set)
//    | TableBeginInitMemory()                  - first time table is used
//    | TableResetSettings()                    - on settings reset
//    | TableLoadSettings()                     - on settings load
//    | TableBeginApplyRequests()               - apply queued resizing/reordering/hiding requests
//    | - TableSetColumnWidth()                 - apply resizing width (for mouse resize, often requested by previous frame)
//    |    - TableUpdateColumnsWeightFromWidth()- recompute columns weights (of stretch columns) from their respective width
// - TableSetupColumn()                         user submit columns details (optional)
// - TableSetupScrollFreeze()                   user submit scroll freeze information (optional)
//-----------------------------------------------------------------------------
// - TableUpdateLayout() [Internal]             followup to BeginTable(): setup everything: widths, columns positions, clipping rectangles. Automatically called by the FIRST call to TableNextRow() or TableHeadersRow().
//    | TableSetupDrawChannels()                - setup ImDrawList channels
//    | TableUpdateBorders()                    - detect hovering columns for resize, ahead of contents submission
//    | TableBeginContextMenuPopup()
//    | - TableDrawDefaultContextMenu()         - draw right-click context menu contents
//-----------------------------------------------------------------------------
// - TableHeadersRow() or TableHeader()         user submit a headers row (optional)
//    | TableSortSpecsClickColumn()             - when left-clicked: alter sort order and sort direction
//    | TableOpenContextMenu()                  - when right-clicked: trigger opening of the default context menu
// - TableGetSortSpecs()                        user queries updated sort specs (optional, generally after submitting headers)
// - TableNextRow()                             user begin into a new row (also automatically called by TableHeadersRow())
//    | TableEndRow()                           - finish existing row
//    | TableBeginRow()                         - add a new row
// - TableSetColumnIndex() / TableNextColumn()  user begin into a cell
//    | TableEndCell()                          - close existing column/cell
//    | TableBeginCell()                        - enter into current column/cell
// - [...]                                      user emit contents
//-----------------------------------------------------------------------------
// - EndTable()                                 user ends the table
//    | TableDrawBorders()                      - draw outer borders, inner vertical borders
//    | TableMergeDrawChannels()                - merge draw channels if clipping isn't required
//    | EndChild()                              - (if ScrollX/ScrollY is set)
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// TABLE SIZING
//-----------------------------------------------------------------------------
// (Read carefully because this is subtle but it does make sense!)
//-----------------------------------------------------------------------------
// About 'outer_size':
// Its meaning needs to differ slightly depending on if we are using ScrollX/ScrollY flags.
// Default value is ImVec2{0.0f, 0.0f}.
//   X
//   - outer_size.x <= 0.0f  ->  Right-align from window/work-rect right-most edge. With -FLT_MIN or 0.0f will align exactly on right-most edge.
//   - outer_size.x  > 0.0f  ->  Set Fixed width.
//   Y with ScrollX/ScrollY disabled: we output table directly in current window
//   - outer_size.y  < 0.0f  ->  Bottom-align (but will auto extend, unless _NoHostExtendY is set). Not meaningful if parent window can vertically scroll.
//   - outer_size.y  = 0.0f  ->  No minimum height (but will auto extend, unless _NoHostExtendY is set)
//   - outer_size.y  > 0.0f  ->  Set Minimum height (but will auto extend, unless _NoHostExtendY is set)
//   Y with ScrollX/ScrollY enabled: using a child window for scrolling
//   - outer_size.y  < 0.0f  ->  Bottom-align. Not meaningful if parent window can vertically scroll.
//   - outer_size.y  = 0.0f  ->  Bottom-align, consistent with BeginChild(). Not recommended unless table is last item in parent window.
//   - outer_size.y  > 0.0f  ->  Set Exact height. Recommended when using Scrolling on any axis.
//-----------------------------------------------------------------------------
// Outer size is also affected by the NoHostExtendX/NoHostExtendY flags.
// Important to note how the two flags have slightly different behaviors!
//   - ImGuiTableFlags_NoHostExtendX -> Make outer width auto-fit to columns (overriding outer_size.x value). Only available when ScrollX/ScrollY are disabled and Stretch columns are not used.
//   - ImGuiTableFlags_NoHostExtendY -> Make outer height stop exactly at outer_size.y (prevent auto-extending table past the limit). Only available when ScrollX/ScrollY is disabled. Data below the limit will be clipped and not visible.
// In theory ImGuiTableFlags_NoHostExtendY could be the default and any non-scrolling tables with outer_size.y != 0.0f would use exact height.
// This would be consistent but perhaps less useful and more confusing (as vertically clipped items are not useful and not easily noticeable).
//-----------------------------------------------------------------------------
// About 'inner_width':
//   With ScrollX disabled:
//   - inner_width          ->  *ignored*
//   With ScrollX enabled:
//   - inner_width  < 0.0f  ->  *illegal* fit in known width (right align from outer_size.x) <-- weird
//   - inner_width  = 0.0f  ->  fit in outer_width: Fixed size columns will take space they need (if avail, otherwise shrink down), Stretch columns becomes Fixed columns.
//   - inner_width  > 0.0f  ->  override scrolling width, generally to be larger than outer_size.x. Fixed column take space they need (if avail, otherwise shrink down), Stretch columns share remaining space!
//-----------------------------------------------------------------------------
// Details:
// - If you want to use Stretch columns with ScrollX, you generally need to specify 'inner_width' otherwise the concept
//   of "available space" doesn't make sense.
// - Even if not really useful, we allow 'inner_width < outer_size.x' for consistency and to facilitate understanding
//   of what the value does.
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// COLUMNS SIZING POLICIES
// (Reference: ImGuiTableFlags_SizingXXX flags and ImGuiTableColumnFlags_WidthXXX flags)
//-----------------------------------------------------------------------------
// About overriding column sizing policy and width/weight with TableSetupColumn():
// We use a default parameter of -1 for 'init_width'/'init_weight'.
//   - with ImGuiTableColumnFlags_WidthFixed,    init_width  <= 0 (default)  --> width is automatic
//   - with ImGuiTableColumnFlags_WidthFixed,    init_width  >  0 (explicit) --> width is custom
//   - with ImGuiTableColumnFlags_WidthStretch,  init_weight <= 0 (default)  --> weight is 1.0f
//   - with ImGuiTableColumnFlags_WidthStretch,  init_weight >  0 (explicit) --> weight is custom
// Widths are specified _without_ CellPadding. If you specify a width of 100.0f, the column will be cover (100.0f + Padding * 2.0f)
// and you can fit a 100.0f wide item in it without clipping and with padding honored.
//-----------------------------------------------------------------------------
// About default sizing policy (if you don't specify a ImGuiTableColumnFlags_WidthXXXX flag)
//   - with Table policy ImGuiTableFlags_SizingFixedFit      --> default Column policy is ImGuiTableColumnFlags_WidthFixed, default Width is equal to contents width
//   - with Table policy ImGuiTableFlags_SizingFixedSame     --> default Column policy is ImGuiTableColumnFlags_WidthFixed, default Width is max of all contents width
//   - with Table policy ImGuiTableFlags_SizingStretchSame   --> default Column policy is ImGuiTableColumnFlags_WidthStretch, default Weight is 1.0f
//   - with Table policy ImGuiTableFlags_SizingStretchWeight --> default Column policy is ImGuiTableColumnFlags_WidthStretch, default Weight is proportional to contents
// Default Width and default Weight can be overridden when calling TableSetupColumn().
//-----------------------------------------------------------------------------
// About mixing Fixed/Auto and Stretch columns together:
//   - the typical use of mixing sizing policies is: any number of LEADING Fixed columns, followed by one or two TRAILING Stretch columns.
//   - using mixed policies with ScrollX does not make much sense, as using Stretch columns with ScrollX does not make much sense in the first place!
//     that is, unless 'inner_width' is passed to BeginTable() to explicitly provide a total width to layout columns in.
//   - when using ImGuiTableFlags_SizingFixedSame with mixed columns, only the Fixed/Auto columns will match their widths to the width of the maximum contents.
//   - when using ImGuiTableFlags_SizingStretchSame with mixed columns, only the Stretch columns will match their weights/widths.
//-----------------------------------------------------------------------------
// About using column width:
// If a column is manually resizable or has a width specified with TableSetupColumn():
//   - you may use GetContentRegionAvail().x to query the width available in a given column.
//   - right-side alignment features such as SetNextItemWidth(-x) or PushItemWidth(-x) will rely on this width.
// If the column is not resizable and has no width specified with TableSetupColumn():
//   - its width will be automatic and be set to the max of items submitted.
//   - therefore you generally cannot have ALL items of the columns use e.g. SetNextItemWidth(-FLT_MIN).
//   - but if the column has one or more items of known/fixed size, this will become the reference width used by SetNextItemWidth(-FLT_MIN).
//-----------------------------------------------------------------------------


//-----------------------------------------------------------------------------
// TABLES CLIPPING/CULLING
//-----------------------------------------------------------------------------
// About clipping/culling of Rows in Tables:
// - For large numbers of rows, it is recommended you use ImGuiListClipper to submit only visible rows.
//   ImGuiListClipper is reliant on the fact that rows are of equal height.
//   See 'Demo->Tables->Vertical Scrolling' or 'Demo->Tables->Advanced' for a demo of using the clipper.
// - Note that auto-resizing columns don't play well with using the clipper.
//   By default a table with _ScrollX but without _Resizable will have column auto-resize.
//   So, if you want to use the clipper, make sure to either enable _Resizable, either setup columns width explicitly with _WidthFixed.
//-----------------------------------------------------------------------------
// About clipping/culling of Columns in Tables:
// - Both TableSetColumnIndex() and TableNextColumn() return true when the column is visible or performing
//   width measurements. Otherwise, you may skip submitting the contents of a cell/column, BUT ONLY if you know
//   it is not going to contribute to row height.
//   In many situations, you may skip submitting contents for every column but one (e.g. the first one).
// - Case A: column is not hidden by user, and at least partially in sight (most common case).
// - Case B: column is clipped / out of sight (because of scrolling or parent ClipRect): TableNextColumn() return false as a hint but we still allow layout output.
// - Case C: column is hidden explicitly by the user (e.g. via the context menu, or _DefaultHide column flag, etc.).
//
//                        [A]         [B]          [C]
//  TableNextColumn():    true        false        false       -> [userland] when TableNextColumn() / TableSetColumnIndex() returns false, user can skip submitting items but only if the column doesn't contribute to row height.
//          SkipItems:    false       false        true        -> [internal] when SkipItems is true, most widgets will early out if submitted, resulting is no layout output.
//           ClipRect:    normal      zero-width   zero-width  -> [internal] when ClipRect is zero, ItemAdd() will return false and most widgets will early out mid-way.
//  ImDrawList output:    normal      dummy        dummy       -> [internal] when using the dummy channel, ImDrawList submissions (if any) will be wasted (because cliprect is zero-width anyway).
//
// - We need to distinguish those cases because non-hidden columns that are clipped outside of scrolling bounds should still contribute their height to the row.
//   However, in the majority of cases, the contribution to row height is the same for all columns, or the tallest cells are known by the programmer.
//-----------------------------------------------------------------------------
// About clipping/culling of whole Tables:
// - Scrolling tables with a known outer size can be clipped earlier as BeginTable() will return false.
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// [SECTION] Tables: Main code
//-----------------------------------------------------------------------------
// - TableFixFlags() [Internal]
// - TableFindByID() [Internal]
// - BeginTable()
// - BeginTableEx() [Internal]
// - TableBeginInitMemory() [Internal]
// - TableBeginApplyRequests() [Internal]
// - TableSetupColumnFlags() [Internal]
// - TableUpdateLayout() [Internal]
// - TableUpdateBorders() [Internal]
// - EndTable()
// - TableSetupColumn()
// - TableSetupScrollFreeze()
//-----------------------------------------------------------------------------

// Configuration
TABLE_DRAW_CHANNEL_BG0 : i32 = 0
TABLE_DRAW_CHANNEL_BG2_FROZEN : i32 = 1
TABLE_DRAW_CHANNEL_NOCLIP : i32 = 2; // When using ImGuiTableFlags_NoClip (this becomes the last visible channel)
TABLE_BORDER_SIZE : f32 = 1.0; // FIXME-TABLE: Currently hard-coded because of clipping assumptions with outer borders rendering.
TABLE_RESIZE_SEPARATOR_HALF_THICKNESS : f32 = 4.0; // Extend outside inner borders.
TABLE_RESIZE_SEPARATOR_FEEDBACK_TIMER : f32 = 0.06; // Delay/timer before making the hover feedback (color+cursor) visible because tables/columns tends to be more cramped.

// Helper
TableFixFlags :: #force_inline proc(flags : ImGuiTableFlags, outer_window : ^ImGuiWindow) -> ImGuiTableFlags
{
	flags := flags
	// Adjust flags: set default sizing policy
	if (flags & ImGuiTableFlags_.ImGuiTableFlags_SizingMask_) == {} { flags |= ((flags & ImGuiTableFlags_.ImGuiTableFlags_ScrollX) != {} || (outer_window.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_AlwaysAutoResize) != {}) ? ImGuiTableFlags_.ImGuiTableFlags_SizingFixedFit : ImGuiTableFlags_.ImGuiTableFlags_SizingStretchSame }

	// Adjust flags: enable NoKeepColumnsVisible when using ImGuiTableFlags_SizingFixedSame
	if (flags & ImGuiTableFlags_.ImGuiTableFlags_SizingMask_) == ImGuiTableFlags_.ImGuiTableFlags_SizingFixedSame { flags |= ImGuiTableFlags_.ImGuiTableFlags_NoKeepColumnsVisible }

	// Adjust flags: enforce borders when resizable
	if (flags & ImGuiTableFlags_.ImGuiTableFlags_Resizable) != {} { flags |= ImGuiTableFlags_.ImGuiTableFlags_BordersInnerV }

	// Adjust flags: disable NoHostExtendX/NoHostExtendY if we have any scrolling going on
	if (flags & (ImGuiTableFlags_.ImGuiTableFlags_ScrollX | ImGuiTableFlags_.ImGuiTableFlags_ScrollY)) != {} { flags &= cast(ImGuiTableFlags)~i32(ImGuiTableFlags_.ImGuiTableFlags_NoHostExtendX | ImGuiTableFlags_.ImGuiTableFlags_NoHostExtendY) }

	// Adjust flags: NoBordersInBodyUntilResize takes priority over NoBordersInBody
	if (flags & ImGuiTableFlags_.ImGuiTableFlags_NoBordersInBodyUntilResize) != {} { flags &= cast(ImGuiTableFlags)~cast(i32)ImGuiTableFlags_.ImGuiTableFlags_NoBordersInBody }

	// Adjust flags: disable saved settings if there's nothing to save
	if (flags & (ImGuiTableFlags_.ImGuiTableFlags_Resizable | ImGuiTableFlags_.ImGuiTableFlags_Hideable | ImGuiTableFlags_.ImGuiTableFlags_Reorderable | ImGuiTableFlags_.ImGuiTableFlags_Sortable)) == {} { flags |= ImGuiTableFlags_.ImGuiTableFlags_NoSavedSettings }

	// Inherit _NoSavedSettings from top-level window (child windows always have _NoSavedSettings set)
	if (outer_window.RootWindow.Flags & ImGuiWindowFlags_.ImGuiWindowFlags_NoSavedSettings) != {} { flags |= ImGuiTableFlags_.ImGuiTableFlags_NoSavedSettings }

	return flags
}

TableFindByID :: proc(id : ImGuiID) -> ^ImGuiTable
{
	g : ^ImGuiContext = GImGui
	return GetByKey(&g.Tables, id)
}

// Read about "TABLE SIZING" at the top of this file.
BeginTable :: proc(str_id : string, columns_count : i32, flags : ImGuiTableFlags = {}, outer_size : ImVec2 = {}, inner_width : f32 = 0) -> bool
{
	id : ImGuiID = GetID(str_id)
	return BeginTableEx(str_id, id, columns_count, flags, outer_size, inner_width)
}

BeginTableEx :: proc(name : string, id : ImGuiID, columns_count : i32, flags : ImGuiTableFlags, outer_size : ImVec2, inner_width : f32) -> bool
{
	g : ^ImGuiContext = GImGui
	outer_window : ^ImGuiWindow = GetCurrentWindow()
	if outer_window.SkipItems {
		// Consistent with other tables + beneficial side effect that assert on miscalling EndTable() will be more visible.
		return false
	}

	// Sanity checks
	IM_ASSERT(columns_count > 0 && columns_count < IMGUI_TABLE_MAX_COLUMNS)
	if (flags & ImGuiTableFlags_.ImGuiTableFlags_ScrollX) != {} { IM_ASSERT(inner_width >= 0.0) }

	// If an outer size is specified ahead we will be able to early out when not visible. Exact clipping criteria may evolve.
	// FIXME: coarse clipping because access to table data causes two issues:
	// - instance numbers varying/unstable. may not be a direct problem for users, but could make outside access broken or confusing, e.g. TestEngine.
	// - can't implement support for ImGuiChildFlags_ResizeY as we need to somehow pull the height data from somewhere. this also needs stable instance numbers.
	// The side-effects of accessing table data on coarse clip would be:
	// - always reserving the pooled ImGuiTable data ahead for a fully clipped table (minor IMHO). Also the 'outer_window_is_measuring_size' criteria may already be defeating this in some situations.
	// - always performing the GetOrAddByKey() O(log N) query in g.Tables.Map[].
	use_child_window : bool = (flags & (ImGuiTableFlags_.ImGuiTableFlags_ScrollX | ImGuiTableFlags_.ImGuiTableFlags_ScrollY)) != {}
	avail_size : ImVec2 = GetContentRegionAvail()
	actual_outer_size : ImVec2 = ImTrunc(CalcItemSize(outer_size, ImMax(avail_size.x, 1.0), use_child_window ? ImMax(avail_size.y, 1.0) : 0.0))
	outer_rect : ImRect; init(&outer_rect, outer_window.DC.CursorPos, outer_window.DC.CursorPos + actual_outer_size)
	outer_window_is_measuring_size : bool = (outer_window.AutoFitFramesX > 0) || (outer_window.AutoFitFramesY > 0); // Doesn't apply to AlwaysAutoResize windows!
	if use_child_window && IsClippedEx(outer_rect, 0) && !outer_window_is_measuring_size {
		ItemSize(outer_rect)
		ItemAdd(outer_rect, id)
		return false
	}

	// [DEBUG] Debug break requested by user
	if g.DebugBreakInTable == id { IM_DEBUG_BREAK() }

	// Acquire storage for the table
	table : ^ImGuiTable = GetOrAddByKey(&g.Tables, id)

	// Acquire temporary buffers
	table_idx : i32 = GetIndex(&g.Tables, table)
	if pre_incr(&g.TablesTempDataStacked) > g.TablesTempData.Size { v : ImGuiTableTempData; init(&v); resize(&g.TablesTempData, g.TablesTempDataStacked, v) }
	table.TempData = &g.TablesTempData.Data[g.TablesTempDataStacked - 1]
	temp_data : ^ImGuiTableTempData = table.TempData
	temp_data.TableIndex = table_idx
	table.DrawSplitter = &table.TempData.DrawSplitter
	Clear(table.DrawSplitter)

	// Fix flags
	table.IsDefaultSizingPolicy = (flags & ImGuiTableFlags_.ImGuiTableFlags_SizingMask_) == {}
	flags := TableFixFlags(flags, outer_window)

	// Initialize
	previous_frame_active : i32 = table.LastFrameActive
	instance_no : i32 = (previous_frame_active != g.FrameCount) ? 0 : i32(table.InstanceCurrent) + 1
	previous_flags : ImGuiTableFlags = table.Flags
	table.ID = id
	table.Flags = flags
	table.LastFrameActive = g.FrameCount
	table.InnerWindow = outer_window; table.OuterWindow = table.InnerWindow
	table.ColumnsCount = columns_count
	table.IsLayoutLocked = false
	table.InnerWidth = inner_width
	temp_data.UserOuterSize = outer_size

	// Instance data (for instance 0, TableID == TableInstanceID)
	instance_id : ImGuiID
	table.InstanceCurrent = cast(ImS16) instance_no
	if instance_no > 0 {
		IM_ASSERT(table.ColumnsCount == columns_count, "BeginTable(): Cannot change columns count mid-frame while preserving same ID")
		if table.InstanceDataExtra.Size < instance_no { v : ImGuiTableInstanceData; init(&v); push_back(&table.InstanceDataExtra, v) }
		instance_id = GetIDWithSeed(instance_no, GetIDWithSeed("##Instances", id)); // Push "##Instances" followed by (int)instance_no in ID stack.
	}
	else {
		instance_id = id
	}
	table_instance : ^ImGuiTableInstanceData = TableGetInstanceData(table, i32(table.InstanceCurrent))
	table_instance.TableInstanceID = instance_id

	// When not using a child window, WorkRect.Max will grow as we append contents.
	if use_child_window {
		// Ensure no vertical scrollbar appears if we only want horizontal one, to make flag consistent
		// (we have no other way to disable vertical scrollbar of a window while keeping the horizontal one showing)
		override_content_size := ImVec2{ FLT_MAX, FLT_MAX }
		if (flags & ImGuiTableFlags_.ImGuiTableFlags_ScrollX) != {} && (flags & ImGuiTableFlags_.ImGuiTableFlags_ScrollY) == {} { override_content_size.y = FLT_MIN }

		// Ensure specified width (when not specified, Stretched columns will act as if the width == OuterWidth and
		// never lead to any scrolling). We don't handle inner_width < 0.0f, we could potentially use it to right-align
		// based on the right side of the child window work rect, which would require knowing ahead if we are going to
		// have decoration taking horizontal spaces (typically a vertical scrollbar).
		if (flags & ImGuiTableFlags_.ImGuiTableFlags_ScrollX) != {} && inner_width > 0.0 { override_content_size.x = inner_width }

		if override_content_size.x != FLT_MAX || override_content_size.y != FLT_MAX { SetNextWindowContentSize(ImVec2{override_content_size.x != FLT_MAX ? override_content_size.x : 0.0, override_content_size.y != FLT_MAX ? override_content_size.y : 0.0}) }

		// Reset scroll if we are reactivating it
		if (previous_flags & (ImGuiTableFlags_.ImGuiTableFlags_ScrollX | ImGuiTableFlags_.ImGuiTableFlags_ScrollY)) == {} { if (g.NextWindowData.Flags & ImGuiNextWindowDataFlags_.ImGuiNextWindowDataFlags_HasScroll) == {} { SetNextWindowScroll(ImVec2{0.0, 0.0}) } }

		// Create scrolling region (without border and zero window padding)
		child_window_flags : ImGuiWindowFlags = (flags & ImGuiTableFlags_.ImGuiTableFlags_ScrollX) != {} ? ImGuiWindowFlags_.ImGuiWindowFlags_HorizontalScrollbar : ImGuiWindowFlags_.ImGuiWindowFlags_None
		BeginChildEx(name, instance_id, GetSize(outer_rect), ImGuiChildFlags_.ImGuiChildFlags_None, child_window_flags)
		table.InnerWindow = g.CurrentWindow
		table.WorkRect = table.InnerWindow.WorkRect
		table.OuterRect = Rect(table.InnerWindow)
		table.InnerRect = table.InnerWindow.InnerRect
		IM_ASSERT(table.InnerWindow.WindowPadding.x == 0.0 && table.InnerWindow.WindowPadding.y == 0.0 && table.InnerWindow.WindowBorderSize == 0.0)

		// Allow submitting when host is measuring
		if table.InnerWindow.SkipItems && outer_window_is_measuring_size { table.InnerWindow.SkipItems = false }

		// When using multiple instances, ensure they have the same amount of horizontal decorations (aka vertical scrollbar) so stretched columns can be aligned)
		if instance_no == 0 {
			table.HasScrollbarYPrev = table.HasScrollbarYCurr
			table.HasScrollbarYCurr = false
		}
		table.HasScrollbarYCurr |= table.InnerWindow.ScrollbarY
	}
	else {
		// For non-scrolling tables, WorkRect == OuterRect == InnerRect.
		// But at this point we do NOT have a correct value for .Max.y (unless a height has been explicitly passed in). It will only be updated in EndTable().
		table.InnerRect = outer_rect; table.OuterRect = table.InnerRect; table.WorkRect = table.OuterRect
		table.HasScrollbarYCurr = false; table.HasScrollbarYPrev = table.HasScrollbarYCurr
	}

	// Push a standardized ID for both child-using and not-child-using tables
	PushOverrideID(id)
	if instance_no > 0 {
		// FIXME: Somehow this is not resolved by stack-tool, even tho GetIDWithSeed() submitted the symbol.
		PushOverrideID(instance_id)
	}

	// Backup a copy of host window members we will modify
	inner_window : ^ImGuiWindow = table.InnerWindow
	table.HostIndentX = inner_window.DC.Indent.x
	table.HostClipRect = inner_window.ClipRect
	table.HostSkipItems = inner_window.SkipItems
	temp_data.HostBackupWorkRect = inner_window.WorkRect
	temp_data.HostBackupParentWorkRect = inner_window.ParentWorkRect
	temp_data.HostBackupColumnsOffset = outer_window.DC.ColumnsOffset
	temp_data.HostBackupPrevLineSize = inner_window.DC.PrevLineSize
	temp_data.HostBackupCurrLineSize = inner_window.DC.CurrLineSize
	temp_data.HostBackupCursorMaxPos = inner_window.DC.CursorMaxPos
	temp_data.HostBackupItemWidth = outer_window.DC.ItemWidth
	temp_data.HostBackupItemWidthStackSize = outer_window.DC.ItemWidthStack.Size
	inner_window.DC.CurrLineSize = ImVec2{0.0, 0.0}; inner_window.DC.PrevLineSize = inner_window.DC.CurrLineSize

	// Make borders not overlap our contents by offsetting HostClipRect (#6765, #7428, #3752)
	// (we normally shouldn't alter HostClipRect as we rely on TableMergeDrawChannels() expanding non-clipped column toward the
	// limits of that rectangle, in order for ImDrawListSplitter::Merge() to merge the draw commands. However since the overlap
	// problem only affect scrolling tables in this case we can get away with doing it without extra cost).
	if inner_window != outer_window {
		// FIXME: Because inner_window's Scrollbar doesn't know about border size, since it's not encoded in window->WindowBorderSize,
		// it already overlaps it and doesn't need an extra offset. Ideally we should be able to pass custom border size with
		// different x/y values to BeginChild().
		if (flags & ImGuiTableFlags_.ImGuiTableFlags_BordersOuterV) != {} {
			table.HostClipRect.Min.x = ImMin(table.HostClipRect.Min.x + TABLE_BORDER_SIZE, table.HostClipRect.Max.x)
			if inner_window.DecoOuterSizeX2 == 0.0 { table.HostClipRect.Max.x = ImMax(table.HostClipRect.Max.x - TABLE_BORDER_SIZE, table.HostClipRect.Min.x) }
		}
		if (flags & ImGuiTableFlags_.ImGuiTableFlags_BordersOuterH) != {} {
			table.HostClipRect.Min.y = ImMin(table.HostClipRect.Min.y + TABLE_BORDER_SIZE, table.HostClipRect.Max.y)
			if inner_window.DecoOuterSizeY2 == 0.0 { table.HostClipRect.Max.y = ImMax(table.HostClipRect.Max.y - TABLE_BORDER_SIZE, table.HostClipRect.Min.y) }
		}
	}

	// Padding and Spacing
	// - None               ........Content..... Pad .....Content........
	// - PadOuter           | Pad ..Content..... Pad .....Content.. Pad |
	// - PadInner           ........Content.. Pad | Pad ..Content........
	// - PadOuter+PadInner  | Pad ..Content.. Pad | Pad ..Content.. Pad |
	pad_outer_x : bool = (flags & ImGuiTableFlags_.ImGuiTableFlags_NoPadOuterX) != {} ? false : (flags & ImGuiTableFlags_.ImGuiTableFlags_PadOuterX) != {} ? true : (flags & ImGuiTableFlags_.ImGuiTableFlags_BordersOuterV) != {}
	pad_inner_x : bool = (flags & ImGuiTableFlags_.ImGuiTableFlags_NoPadInnerX) != {} ? false : true
	inner_spacing_for_border : f32 = (flags & ImGuiTableFlags_.ImGuiTableFlags_BordersInnerV) != {} ? TABLE_BORDER_SIZE : 0.0
	inner_spacing_explicit : f32 = (pad_inner_x && (flags & ImGuiTableFlags_.ImGuiTableFlags_BordersInnerV) == {}) ? g.Style.CellPadding.x : 0.0
	inner_padding_explicit : f32 = (pad_inner_x && (flags & ImGuiTableFlags_.ImGuiTableFlags_BordersInnerV) != {}) ? g.Style.CellPadding.x : 0.0
	table.CellSpacingX1 = inner_spacing_explicit + inner_spacing_for_border
	table.CellSpacingX2 = inner_spacing_explicit
	table.CellPaddingX = inner_padding_explicit

	outer_padding_for_border : f32 = (flags & ImGuiTableFlags_.ImGuiTableFlags_BordersOuterV) != {} ? TABLE_BORDER_SIZE : 0.0
	outer_padding_explicit : f32 = pad_outer_x ? g.Style.CellPadding.x : 0.0
	table.OuterPaddingX = (outer_padding_for_border + outer_padding_explicit) - table.CellPaddingX

	table.CurrentColumn = -1
	table.CurrentRow = -1
	table.RowBgColorCounter = 0
	table.LastRowFlags = ImGuiTableRowFlags_.ImGuiTableRowFlags_None
	table.InnerClipRect = (inner_window == outer_window) ? table.WorkRect : inner_window.ClipRect
	ClipWith(&table.InnerClipRect, table.WorkRect); // We need this to honor inner_width
	ClipWithFull(&table.InnerClipRect, table.HostClipRect)
	table.InnerClipRect.Max.y = (flags & ImGuiTableFlags_.ImGuiTableFlags_NoHostExtendY) != {} ? ImMin(table.InnerClipRect.Max.y, inner_window.WorkRect.Max.y) : table.HostClipRect.Max.y

	table.RowPosY2 = table.WorkRect.Min.y; table.RowPosY1 = table.RowPosY2; // This is needed somehow
	table.RowTextBaseline = 0.0; // This will be cleared again by TableBeginRow()
	table.RowCellPaddingY = 0.0
	table.FreezeRowsCount = 0; table.FreezeRowsRequest = table.FreezeRowsCount; // This will be setup by TableSetupScrollFreeze(), if any
	table.FreezeColumnsCount = 0; table.FreezeColumnsRequest = table.FreezeColumnsCount
	table.IsUnfrozenRows = true
	table.AngledHeadersCount = 0; table.DeclColumnsCount = table.AngledHeadersCount
	if previous_frame_active + 1 < g.FrameCount { table.IsActiveIdInTable = false }
	table.AngledHeadersHeight = 0.0
	temp_data.AngledHeadersExtraWidth = 0.0

	// Using opaque colors facilitate overlapping lines of the grid, otherwise we'd need to improve TableDrawBorders()
	table.BorderColorStrong = GetColorU32(ImGuiCol_.ImGuiCol_TableBorderStrong)
	table.BorderColorLight = GetColorU32(ImGuiCol_.ImGuiCol_TableBorderLight)

	// Make table current
	g.CurrentTable = table
	outer_window.DC.NavIsScrollPushableX = false; // Shortcut for NavUpdateCurrentWindowIsScrollPushableX();
	outer_window.DC.CurrentTableIdx = table_idx
	if inner_window != outer_window {
		// So EndChild() within the inner window can restore the table properly.
		inner_window.DC.CurrentTableIdx = table_idx
	}

	if (previous_flags & ImGuiTableFlags_.ImGuiTableFlags_Reorderable) != {} && (flags & ImGuiTableFlags_.ImGuiTableFlags_Reorderable) == {} { table.IsResetDisplayOrderRequest = true }

	// Mark as used to avoid GC
	if table_idx >= g.TablesLastTimeActive.Size { resize(&g.TablesLastTimeActive, table_idx + 1, -1.0) }
	g.TablesLastTimeActive.Data[table_idx] = cast(f32) g.Time
	temp_data.LastTimeActive = cast(f32) g.Time
	table.MemoryCompacted = false

	// Setup memory buffer (clear data if columns count changed)
	old_columns_to_preserve : [^]ImGuiTableColumn = nil
	old_columns_raw_data : rawptr = nil
	old_columns_count : i32 = size(&table.Columns)
	if old_columns_count != 0 && old_columns_count != columns_count {
		// Attempt to preserve width on column count change (#4046)
		old_columns_to_preserve = table.Columns.Data
		old_columns_raw_data = table.RawData
		table.RawData = nil
	}
	if table.RawData == nil {
		TableBeginInitMemory(table, columns_count)
		table.IsSettingsRequestLoad = true; table.IsInitializing = table.IsSettingsRequestLoad
	}
	if table.IsResetAllRequest { TableResetSettings(table) }
	if table.IsInitializing {
		// Initialize
		table.SettingsOffset = -1
		table.IsSortSpecsDirty = true
		table.InstanceInteracted = -1
		table.ContextPopupColumn = -1
		table.LastResizedColumn = -1; table.ResizedColumn = table.LastResizedColumn; table.ReorderColumn = table.ResizedColumn
		table.AutoFitSingleColumn = -1
		table.HoveredColumnBorder = -1; table.HoveredColumnBody = table.HoveredColumnBorder
		for n : i32 = 0; n < columns_count; n += 1 {
			column : ^ImGuiTableColumn = &table.Columns.Data[n]
			if old_columns_to_preserve != nil && n < old_columns_count {
				// FIXME: We don't attempt to preserve column order in this path.
				column^ = old_columns_to_preserve[n]
			}
			else {
				width_auto : f32 = column.WidthAuto
				init(column)
				column.WidthAuto = width_auto
				column.IsPreserveWidthAuto = true; // Preserve WidthAuto when reinitializing a live table: not technically necessary but remove a visible flicker
				column.IsUserEnabledNextFrame = true; column.IsUserEnabled = column.IsUserEnabledNextFrame; column.IsEnabled = column.IsUserEnabled
			}
			table.DisplayOrderToIndex.Data[n] = cast(ImGuiTableColumnIdx) n; column.DisplayOrder = table.DisplayOrderToIndex.Data[n]
		}
	}
	if old_columns_raw_data != nil { IM_FREE(old_columns_raw_data) }

	// Load settings
	if table.IsSettingsRequestLoad { TableLoadSettings(table) }

	// Handle DPI/font resize
	// This is designed to facilitate DPI changes with the assumption that e.g. style.CellPadding has been scaled as well.
	// It will also react to changing fonts with mixed results. It doesn't need to be perfect but merely provide a decent transition.
	// FIXME-DPI: Provide consistent standards for reference size. Perhaps using g.CurrentDpiScale would be more self explanatory.
	// This is will lead us to non-rounded WidthRequest in columns, which should work but is a poorly tested path.
	new_ref_scale_unit : f32 = g.FontSize; // g.Font->GetCharAdvance('A') ?
	if table.RefScale != 0.0 && table.RefScale != new_ref_scale_unit {
		scale_factor : f32 = new_ref_scale_unit / table.RefScale
		//IMGUI_DEBUG_PRINT("[table] %08X RefScaleUnit %.3f -> %.3f, scaling width by %.3f\n", table->ID, table->RefScaleUnit, new_ref_scale_unit, scale_factor);
		for n : i32 = 0; n < columns_count; n += 1 { table.Columns.Data[n].WidthRequest = table.Columns.Data[n].WidthRequest * scale_factor }
	}
	table.RefScale = new_ref_scale_unit

	// Disable output until user calls TableNextRow() or TableNextColumn() leading to the TableUpdateLayout() call..
	// This is not strictly necessary but will reduce cases were "out of table" output will be misleading to the user.
	// Because we cannot safely assert in EndTable() when no rows have been created, this seems like our best option.
	inner_window.SkipItems = true

	// Clear names
	// At this point the ->NameOffset field of each column will be invalid until TableUpdateLayout() or the first call to TableSetupColumn()
	if table.ColumnsNames.Buf.Size > 0 { resize(&table.ColumnsNames.Buf, 0) }

	// Apply queued resizing/reordering/hiding requests
	TableBeginApplyRequests(table)

	return true
}

// For reference, the average total _allocation count_ for a table is:
// + 0 (for ImGuiTable instance, we are pooling allocations in g.Tables[])
// + 1 (for table->RawData allocated below)
// + 1 (for table->ColumnsNames, if names are used)
// Shared allocations for the maximum number of simultaneously nested tables (generally a very small number)
// + 1 (for table->Splitter._Channels)
// + 2 * active_channels_count (for ImDrawCmd and ImDrawIdx buffers inside channels)
// Where active_channels_count is variable but often == columns_count or == columns_count + 1, see TableSetupDrawChannels() for details.
// Unused channels don't perform their +2 allocations.
TableBeginInitMemory :: proc(table : ^ImGuiTable, columns_count : i32)
{
	// Allocate single buffer for our arrays
	columns_bit_array_size : i32 = cast(i32) ImBitArrayGetStorageSizeInBytes(columns_count)
	span_allocator : ImSpanAllocator(6)
	Reserve(&span_allocator, 0, columns_count * size_of(ImGuiTableColumn))
	Reserve(&span_allocator, 1, columns_count * size_of(ImGuiTableColumnIdx))
	Reserve(&span_allocator, 2, columns_count * size_of(ImGuiTableCellData), 4)
	for n : i32 = 3; n < 6; n += 1 { Reserve(&span_allocator, n, columns_bit_array_size) }

	table.RawData = IM_ALLOC(GetArenaSizeInBytes(&span_allocator))
	memset(table.RawData, 0, cast(int)GetArenaSizeInBytes(&span_allocator))
	SetArenaBasePtr(&span_allocator, table.RawData)
	GetSpan(&span_allocator, 0, &table.Columns)
	GetSpan(&span_allocator, 1, &table.DisplayOrderToIndex)
	GetSpan(&span_allocator, 2, &table.RowCellData)
	table.EnabledMaskByDisplayOrder = cast(^ImU32) GetSpanPtrBegin(&span_allocator, 3)
	table.EnabledMaskByIndex = cast(^ImU32) GetSpanPtrBegin(&span_allocator, 4)
	table.VisibleMaskByIndex = cast(^ImU32) GetSpanPtrBegin(&span_allocator, 5)
}

// Apply queued resizing/reordering/hiding requests
TableBeginApplyRequests :: proc(table : ^ImGuiTable)
{
	// Handle resizing request
	// (We process this in the TableBegin() of the first instance of each table)
	// FIXME-TABLE: Contains columns if our work area doesn't allow for scrolling?
	if table.InstanceCurrent == 0 {
		if table.ResizedColumn != -1 && table.ResizedColumnNextWidth != FLT_MAX { TableSetColumnWidth(i32(table.ResizedColumn), table.ResizedColumnNextWidth) }
		table.LastResizedColumn = table.ResizedColumn
		table.ResizedColumnNextWidth = FLT_MAX
		table.ResizedColumn = -1

		// Process auto-fit for single column, which is a special case for stretch columns and fixed columns with FixedSame policy.
		// FIXME-TABLE: Would be nice to redistribute available stretch space accordingly to other weights, instead of giving it all to siblings.
		if table.AutoFitSingleColumn != -1 {
			TableSetColumnWidth(i32(table.AutoFitSingleColumn), table.Columns.Data[table.AutoFitSingleColumn].WidthAuto)
			table.AutoFitSingleColumn = -1
		}
	}

	// Handle reordering request
	// Note: we don't clear ReorderColumn after handling the request.
	if table.InstanceCurrent == 0 {
		if table.HeldHeaderColumn == -1 && table.ReorderColumn != -1 { table.ReorderColumn = -1 }
		table.HeldHeaderColumn = -1
		if table.ReorderColumn != -1 && table.ReorderColumnDir != {} {
			// We need to handle reordering across hidden columns.
			// In the configuration below, moving C to the right of E will lead to:
			//    ... C [D] E  --->  ... [D] E  C   (Column name/index)
			//    ... 2  3  4        ...  2  3  4   (Display order)
			reorder_dir := i32(table.ReorderColumnDir)
			IM_ASSERT(reorder_dir == -1 || reorder_dir == +1)
			IM_ASSERT((table.Flags & ImGuiTableFlags_.ImGuiTableFlags_Reorderable) != {})
			src_column : ^ImGuiTableColumn = &table.Columns.Data[table.ReorderColumn]
			dst_column : ^ImGuiTableColumn = &table.Columns.Data[(reorder_dir == -1) ? src_column.PrevEnabledColumn : src_column.NextEnabledColumn]
			IM_UNUSED(dst_column)
			src_order := i32(src_column.DisplayOrder)
			dst_order := i32(dst_column.DisplayOrder)
			src_column.DisplayOrder = cast(ImGuiTableColumnIdx) dst_order
			for order_n : i32 = src_order + reorder_dir; order_n != dst_order + reorder_dir; order_n += reorder_dir { table.Columns.Data[table.DisplayOrderToIndex.Data[order_n]].DisplayOrder -= cast(ImGuiTableColumnIdx) reorder_dir }

			IM_ASSERT(i32(dst_column.DisplayOrder) == dst_order - reorder_dir)

			// Display order is stored in both columns->IndexDisplayOrder and table->DisplayOrder[]. Rebuild later from the former.
			for column_n : i32 = 0; column_n < table.ColumnsCount; column_n += 1 { table.DisplayOrderToIndex.Data[table.Columns.Data[column_n].DisplayOrder] = cast(ImGuiTableColumnIdx) column_n }

			table.ReorderColumnDir = 0
			table.IsSettingsDirty = true
		}
	}

	// Handle display order reset request
	if table.IsResetDisplayOrderRequest {
		for n : i32 = 0; n < table.ColumnsCount; n += 1 { table.Columns.Data[n].DisplayOrder = cast(ImGuiTableColumnIdx) n; table.DisplayOrderToIndex.Data[n] = table.Columns.Data[n].DisplayOrder }

		table.IsResetDisplayOrderRequest = false
		table.IsSettingsDirty = true
	}
}

// Adjust flags: default width mode + stretch columns are not allowed when auto extending
TableSetupColumnFlags :: proc(table : ^ImGuiTable, column : ^ImGuiTableColumn, flags_in : ImGuiTableColumnFlags)
{
	flags : ImGuiTableColumnFlags = flags_in

	// Sizing Policy
	if (flags & ImGuiTableColumnFlags_.ImGuiTableColumnFlags_WidthMask_) == {} {
		table_sizing_policy : ImGuiTableFlags = (table.Flags & ImGuiTableFlags_.ImGuiTableFlags_SizingMask_)
		if table_sizing_policy == ImGuiTableFlags_.ImGuiTableFlags_SizingFixedFit || table_sizing_policy == ImGuiTableFlags_.ImGuiTableFlags_SizingFixedSame { flags |= ImGuiTableColumnFlags_.ImGuiTableColumnFlags_WidthFixed }
		else { flags |= ImGuiTableColumnFlags_.ImGuiTableColumnFlags_WidthStretch }
	}
	else {
		IM_ASSERT(ImIsPowerOfTwo(u32(flags & ImGuiTableColumnFlags_.ImGuiTableColumnFlags_WidthMask_))); // Check that only 1 of each set is used.
	}

	// Resize
	if (table.Flags & ImGuiTableFlags_.ImGuiTableFlags_Resizable) == {} { flags |= ImGuiTableColumnFlags_.ImGuiTableColumnFlags_NoResize }

	// Sorting
	if (flags & ImGuiTableColumnFlags_.ImGuiTableColumnFlags_NoSortAscending) != nil && (flags & ImGuiTableColumnFlags_.ImGuiTableColumnFlags_NoSortDescending) != nil { flags |= ImGuiTableColumnFlags_.ImGuiTableColumnFlags_NoSort }

	// Indentation
	if (flags & ImGuiTableColumnFlags_.ImGuiTableColumnFlags_IndentMask_) == {} { flags |= (index_from_ptr(&table.Columns, column) == 0) ? ImGuiTableColumnFlags_.ImGuiTableColumnFlags_IndentEnable : ImGuiTableColumnFlags_.ImGuiTableColumnFlags_IndentDisable }

	// Alignment
	//if ((flags & ImGuiTableColumnFlags_AlignMask_) == 0)
	//    flags |= ImGuiTableColumnFlags_AlignCenter;
	//IM_ASSERT(ImIsPowerOfTwo(flags & ImGuiTableColumnFlags_AlignMask_)); // Check that only 1 of each set is used.

	// Preserve status flags
	column.Flags = flags | (column.Flags & ImGuiTableColumnFlags_.ImGuiTableColumnFlags_StatusMask_)

	// Build an ordered list of available sort directions
	column.SortDirectionsAvailList = 0; column.SortDirectionsAvailMask = column.SortDirectionsAvailList; column.SortDirectionsAvailCount = column.SortDirectionsAvailMask
	if (table.Flags & ImGuiTableFlags_.ImGuiTableFlags_Sortable) != {} {
		count : u32 = 0; mask : i32 = 0; list : i32 = 0
		if (flags & ImGuiTableColumnFlags_.ImGuiTableColumnFlags_PreferSortAscending) != {} && (flags & ImGuiTableColumnFlags_.ImGuiTableColumnFlags_NoSortAscending) == {} {
			mask |= 1 << ImGuiSortDirection.ImGuiSortDirection_Ascending
			list |= cast(i32)ImGuiSortDirection.ImGuiSortDirection_Ascending << (count << 1)
			post_incr(&count)
		}
		if (flags & ImGuiTableColumnFlags_.ImGuiTableColumnFlags_PreferSortDescending) != {} && (flags & ImGuiTableColumnFlags_.ImGuiTableColumnFlags_NoSortDescending) == {} {
			mask |= 1 << ImGuiSortDirection.ImGuiSortDirection_Descending
			list |= cast(i32)ImGuiSortDirection.ImGuiSortDirection_Descending << (count << 1)
			post_incr(&count)
		}
		if (flags & ImGuiTableColumnFlags_.ImGuiTableColumnFlags_PreferSortAscending) == {} && (flags & ImGuiTableColumnFlags_.ImGuiTableColumnFlags_NoSortAscending) == {} {
			mask |= 1 << ImGuiSortDirection.ImGuiSortDirection_Ascending
			list |= cast(i32)ImGuiSortDirection.ImGuiSortDirection_Ascending << (count << 1)
			post_incr(&count)
		}
		if (flags & ImGuiTableColumnFlags_.ImGuiTableColumnFlags_PreferSortDescending) == {} && (flags & ImGuiTableColumnFlags_.ImGuiTableColumnFlags_NoSortDescending) == {} {
			mask |= 1 << ImGuiSortDirection.ImGuiSortDirection_Descending
			list |= cast(i32)ImGuiSortDirection.ImGuiSortDirection_Descending << (count << 1)
			post_incr(&count)
		}
		if (table.Flags & ImGuiTableFlags_.ImGuiTableFlags_SortTristate) != {} || count == 0 {mask |= 1 << ImGuiSortDirection.ImGuiSortDirection_None; post_incr(&count)
		}
		column.SortDirectionsAvailList = cast(ImU8) list
		column.SortDirectionsAvailMask = cast(ImU8) mask
		column.SortDirectionsAvailCount = cast(ImU8) count
		TableFixColumnSortDirection(table, column)
	}
}

// Layout columns for the frame. This is in essence the followup to BeginTable() and this is our largest function.
// Runs on the first call to TableNextRow(), to give a chance for TableSetupColumn() and other TableSetupXXXXX() functions to be called first.
// FIXME-TABLE: Our width (and therefore our WorkRect) will be minimal in the first frame for _WidthAuto columns.
// Increase feedback side-effect with widgets relying on WorkRect.Max.x... Maybe provide a default distribution for _WidthAuto columns?
TableUpdateLayout :: proc(table : ^ImGuiTable)
{
	g : ^ImGuiContext = GImGui
	IM_ASSERT(table.IsLayoutLocked == false)

	table_sizing_policy : ImGuiTableFlags = (table.Flags & ImGuiTableFlags_.ImGuiTableFlags_SizingMask_)
	table.IsDefaultDisplayOrder = true
	table.ColumnsEnabledCount = 0
	ImBitArrayClearAllBits(table.EnabledMaskByIndex, table.ColumnsCount)
	ImBitArrayClearAllBits(table.EnabledMaskByDisplayOrder, table.ColumnsCount)
	table.LeftMostEnabledColumn = -1
	table.MinColumnWidth = ImMax(f32(1.0), g.Style.FramePadding.x * 1.0); // g.Style.ColumnsMinSpacing; // FIXME-TABLE

	// [Part 1] Apply/lock Enabled and Order states. Calculate auto/ideal width for columns. Count fixed/stretch columns.
	// Process columns in their visible orders as we are building the Prev/Next indices.
	count_fixed : i32 = 0; // Number of columns that have fixed sizing policies
	count_stretch : i32 = 0; // Number of columns that have stretch sizing policies
	prev_visible_column_idx : i32 = -1
	has_auto_fit_request : bool = false
	has_resizable : bool = false
	stretch_sum_width_auto : f32 = 0.0
	fixed_max_width_auto : f32 = 0.0
	for order_n : i32 = 0; order_n < table.ColumnsCount; order_n += 1 {
		column_n := table.DisplayOrderToIndex.Data[order_n]
		if cast(i32)column_n != order_n { table.IsDefaultDisplayOrder = false }
		column : ^ImGuiTableColumn = &table.Columns.Data[column_n]

		// Clear column setup if not submitted by user. Currently we make it mandatory to call TableSetupColumn() every frame.
		// It would easily work without but we're not ready to guarantee it since e.g. names need resubmission anyway.
		// We take a slight shortcut but in theory we could be calling TableSetupColumn() here with dummy values, it should yield the same effect.
		if table.DeclColumnsCount <= column_n {
			TableSetupColumnFlags(table, column, ImGuiTableColumnFlags_.ImGuiTableColumnFlags_None)
			column.NameOffset = -1
			column.UserID = 0
			column.InitStretchWeightOrWidth = -1.0
		}

		// Update Enabled state, mark settings and sort specs dirty
		if (table.Flags & ImGuiTableFlags_.ImGuiTableFlags_Hideable) == {} || (column.Flags & ImGuiTableColumnFlags_.ImGuiTableColumnFlags_NoHide) != {} { column.IsUserEnabledNextFrame = true }
		if column.IsUserEnabled != column.IsUserEnabledNextFrame {
			column.IsUserEnabled = column.IsUserEnabledNextFrame
			table.IsSettingsDirty = true
		}
		column.IsEnabled = column.IsUserEnabled && (column.Flags & ImGuiTableColumnFlags_.ImGuiTableColumnFlags_Disabled) == {}

		if column.SortOrder != -1 && !column.IsEnabled { table.IsSortSpecsDirty = true }
		if column.SortOrder > 0 && (table.Flags & ImGuiTableFlags_.ImGuiTableFlags_SortMulti) == {} { table.IsSortSpecsDirty = true }

		// Auto-fit unsized columns
		start_auto_fit : bool = (column.Flags & ImGuiTableColumnFlags_.ImGuiTableColumnFlags_WidthFixed) != {} ? (column.WidthRequest < 0.0) : (column.StretchWeight < 0.0)
		if start_auto_fit {
			// Fit for three frames
			column.CannotSkipItemsQueue = (1 << 3) - 1; column.AutoFitQueue = column.CannotSkipItemsQueue
		}

		if !column.IsEnabled {
			column.IndexWithinEnabledSet = -1
			continue
		}

		// Mark as enabled and link to previous/next enabled column
		column.PrevEnabledColumn = cast(ImGuiTableColumnIdx) prev_visible_column_idx
		column.NextEnabledColumn = -1
		if prev_visible_column_idx != -1 { table.Columns.Data[prev_visible_column_idx].NextEnabledColumn = cast(ImGuiTableColumnIdx) column_n }
		else { table.LeftMostEnabledColumn = cast(ImGuiTableColumnIdx) column_n }
		column.IndexWithinEnabledSet = post_incr(&table.ColumnsEnabledCount)
		ImBitArraySetBit(table.EnabledMaskByIndex, cast(u32)column_n)
		ImBitArraySetBit(table.EnabledMaskByDisplayOrder, cast(u32)column.DisplayOrder)
		prev_visible_column_idx = i32(column_n)
		IM_ASSERT(column.IndexWithinEnabledSet <= column.DisplayOrder)

		// Calculate ideal/auto column width (that's the width required for all contents to be visible without clipping)
		// Combine width from regular rows + width from headers unless requested not to.
		if !column.IsPreserveWidthAuto && table.InstanceCurrent == 0 { column.WidthAuto = TableGetColumnWidthAuto(table, column) }

		// Non-resizable columns keep their requested width (apply user value regardless of IsPreserveWidthAuto)
		column_is_resizable : bool = (column.Flags & ImGuiTableColumnFlags_.ImGuiTableColumnFlags_NoResize) == {}
		if column_is_resizable { has_resizable = true }
		if (column.Flags & ImGuiTableColumnFlags_.ImGuiTableColumnFlags_WidthFixed) != {} && column.InitStretchWeightOrWidth > 0.0 && !column_is_resizable { column.WidthAuto = column.InitStretchWeightOrWidth }

		if column.AutoFitQueue != 0x00 { has_auto_fit_request = true }
		if (column.Flags & ImGuiTableColumnFlags_.ImGuiTableColumnFlags_WidthStretch) != {} {
			stretch_sum_width_auto += column.WidthAuto
			post_incr(&count_stretch)
		}
		else {
			fixed_max_width_auto = ImMax(fixed_max_width_auto, column.WidthAuto)
			post_incr(&count_fixed)
		}
	}

	if (table.Flags & ImGuiTableFlags_.ImGuiTableFlags_Sortable) != {} && table.SortSpecsCount == 0 && (table.Flags & ImGuiTableFlags_.ImGuiTableFlags_SortTristate) == {} { table.IsSortSpecsDirty = true }
	table.RightMostEnabledColumn = cast(ImGuiTableColumnIdx) prev_visible_column_idx
	IM_ASSERT(table.LeftMostEnabledColumn >= 0 && table.RightMostEnabledColumn >= 0)

	// [Part 2] Disable child window clipping while fitting columns. This is not strictly necessary but makes it possible to avoid
	// the column fitting having to wait until the first visible frame of the child container (may or not be a good thing). Also see #6510.
	// FIXME-TABLE: for always auto-resizing columns may not want to do that all the time.
	if has_auto_fit_request && table.OuterWindow != table.InnerWindow { table.InnerWindow.SkipItems = false }
	if has_auto_fit_request { table.IsSettingsDirty = true }

	// [Part 3] Fix column flags and record a few extra information.
	sum_width_requests : f32 = 0.0; // Sum of all width for fixed and auto-resize columns, excluding width contributed by Stretch columns but including spacing/padding.
	stretch_sum_weights : f32 = 0.0; // Sum of all weights for stretch columns.
	table.RightMostStretchedColumn = -1; table.LeftMostStretchedColumn = table.RightMostStretchedColumn
	for column_n : i32 = 0; column_n < table.ColumnsCount; column_n += 1 {
		if !IM_BITARRAY_TESTBIT(table.EnabledMaskByIndex, column_n) { continue }
		column : ^ImGuiTableColumn = &table.Columns.Data[column_n]

		column_is_resizable : bool = (column.Flags & ImGuiTableColumnFlags_.ImGuiTableColumnFlags_NoResize) == {}
		if (column.Flags & ImGuiTableColumnFlags_.ImGuiTableColumnFlags_WidthFixed) != {} {
			// Apply same widths policy
			width_auto : f32 = column.WidthAuto
			if table_sizing_policy == ImGuiTableFlags_.ImGuiTableFlags_SizingFixedSame && (column.AutoFitQueue != 0x00 || !column_is_resizable) { width_auto = fixed_max_width_auto }

			// Apply automatic width
			// Latch initial size for fixed columns and update it constantly for auto-resizing column (unless clipped!)
			if column.AutoFitQueue != 0x00 { column.WidthRequest = width_auto }
			else if (column.Flags & ImGuiTableColumnFlags_.ImGuiTableColumnFlags_WidthFixed) != {} && !column_is_resizable && column.IsRequestOutput { column.WidthRequest = width_auto }

			// FIXME-TABLE: Increase minimum size during init frame to avoid biasing auto-fitting widgets
			// (e.g. TextWrapped) too much. Otherwise what tends to happen is that TextWrapped would output a very
			// large height (= first frame scrollbar display very off + clipper would skip lots of items).
			// This is merely making the side-effect less extreme, but doesn't properly fixes it.
			// FIXME: Move this to ->WidthGiven to avoid temporary lossyless?
			// FIXME: This break IsPreserveWidthAuto from not flickering if the stored WidthAuto was smaller.
			if column.AutoFitQueue > 0x01 && table.IsInitializing && !column.IsPreserveWidthAuto {
				// FIXME-TABLE: Another constant/scale?
				column.WidthRequest = ImMax(column.WidthRequest, table.MinColumnWidth * 4.0)
			}
			sum_width_requests += column.WidthRequest
		}
		else {
			// Initialize stretch weight
			if column.AutoFitQueue != 0x00 || column.StretchWeight < 0.0 || !column_is_resizable {
				if column.InitStretchWeightOrWidth > 0.0 { column.StretchWeight = column.InitStretchWeightOrWidth }
				else if table_sizing_policy == ImGuiTableFlags_.ImGuiTableFlags_SizingStretchProp { column.StretchWeight = (column.WidthAuto / stretch_sum_width_auto) * f32(count_stretch) }
				else { column.StretchWeight = 1.0 }
			}

			stretch_sum_weights += column.StretchWeight
			if table.LeftMostStretchedColumn == -1 || table.Columns.Data[table.LeftMostStretchedColumn].DisplayOrder > column.DisplayOrder { table.LeftMostStretchedColumn = cast(ImGuiTableColumnIdx) column_n }
			if table.RightMostStretchedColumn == -1 || table.Columns.Data[table.RightMostStretchedColumn].DisplayOrder < column.DisplayOrder { table.RightMostStretchedColumn = cast(ImGuiTableColumnIdx) column_n }
		}
		column.IsPreserveWidthAuto = false
		sum_width_requests += table.CellPaddingX * 2.0
	}

	table.ColumnsEnabledFixedCount = cast(ImGuiTableColumnIdx) count_fixed
	table.ColumnsStretchSumWeights = stretch_sum_weights

	// [Part 4] Apply final widths based on requested widths
	work_rect : ImRect = table.WorkRect
	width_spacings : f32 = (table.OuterPaddingX * 2.0) + (table.CellSpacingX1 + table.CellSpacingX2) * (f32(table.ColumnsEnabledCount) - 1)
	width_removed : f32 = (table.HasScrollbarYPrev && !table.InnerWindow.ScrollbarY) ? g.Style.ScrollbarSize : 0.0; // To synchronize decoration width of synched tables with mismatching scrollbar state (#5920)
	width_avail : f32 = ImMax(f32(1.0), (((table.Flags & ImGuiTableFlags_.ImGuiTableFlags_ScrollX) != {} && table.InnerWidth == 0.0) ? GetWidth(table.InnerClipRect) : GetWidth(work_rect)) - width_removed)
	width_avail_for_stretched_columns : f32 = width_avail - width_spacings - sum_width_requests
	width_remaining_for_stretched_columns : f32 = width_avail_for_stretched_columns
	table.ColumnsGivenWidth = width_spacings + (table.CellPaddingX * 2.0) * f32(table.ColumnsEnabledCount)
	for column_n : i32 = 0; column_n < table.ColumnsCount; column_n += 1 {
		if !IM_BITARRAY_TESTBIT(table.EnabledMaskByIndex, column_n) { continue }
		column : ^ImGuiTableColumn = &table.Columns.Data[column_n]

		// Allocate width for stretched/weighted columns (StretchWeight gets converted into WidthRequest)
		if (column.Flags & ImGuiTableColumnFlags_.ImGuiTableColumnFlags_WidthStretch) != {} {
			weight_ratio : f32 = column.StretchWeight / stretch_sum_weights
			column.WidthRequest = IM_TRUNC(ImMax(width_avail_for_stretched_columns * weight_ratio, table.MinColumnWidth) + 0.01)
			width_remaining_for_stretched_columns -= column.WidthRequest
		}

		// [Resize Rule 1] The right-most Visible column is not resizable if there is at least one Stretch column
		// See additional comments in TableSetColumnWidth().
		if column.NextEnabledColumn == -1 && table.LeftMostStretchedColumn != -1 { column.Flags |= ImGuiTableColumnFlags_.ImGuiTableColumnFlags_NoDirectResize_ }

		// Assign final width, record width in case we will need to shrink
		column.WidthGiven = ImTrunc(ImMax(column.WidthRequest, table.MinColumnWidth))
		table.ColumnsGivenWidth += column.WidthGiven
	}

	// [Part 5] Redistribute stretch remainder width due to rounding (remainder width is < 1.0f * number of Stretch column).
	// Using right-to-left distribution (more likely to match resizing cursor).
	if width_remaining_for_stretched_columns >= 1.0 && (table.Flags & ImGuiTableFlags_.ImGuiTableFlags_PreciseWidths) == {} { for order_n : i32 = table.ColumnsCount - 1; stretch_sum_weights > 0.0 && width_remaining_for_stretched_columns >= 1.0 && order_n >= 0; order_n -= 1 {
	if !IM_BITARRAY_TESTBIT(table.EnabledMaskByDisplayOrder, order_n) { continue }
	column : ^ImGuiTableColumn = &table.Columns.Data[table.DisplayOrderToIndex.Data[order_n]]
	if (column.Flags & ImGuiTableColumnFlags_.ImGuiTableColumnFlags_WidthStretch) == {} { continue }
	column.WidthRequest += 1.0
	column.WidthGiven += 1.0
	width_remaining_for_stretched_columns -= 1.0
} }

	// Determine if table is hovered which will be used to flag columns as hovered.
	// - In principle we'd like to use the equivalent of IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByActiveItem),
	//   but because our item is partially submitted at this point we use ItemHoverable() and a workaround (temporarily
	//   clear ActiveId, which is equivalent to the change provided by _AllowWhenBLockedByActiveItem).
	// - This allows columns to be marked as hovered when e.g. clicking a button inside the column, or using drag and drop.
	table_instance : ^ImGuiTableInstanceData = TableGetInstanceData(table, i32(table.InstanceCurrent))
	table_instance.HoveredRowLast = table_instance.HoveredRowNext
	table_instance.HoveredRowNext = -1
	table.HoveredColumnBorder = -1; table.HoveredColumnBody = table.HoveredColumnBorder
	mouse_hit_rect : ImRect; init(&mouse_hit_rect, table.OuterRect.Min.x, table.OuterRect.Min.y, table.OuterRect.Max.x, ImMax(table.OuterRect.Max.y, table.OuterRect.Min.y + table_instance.LastOuterHeight))
	backup_active_id : ImGuiID = g.ActiveId
	g.ActiveId = 0
	is_hovering_table : bool = ItemHoverable(mouse_hit_rect, 0, ImGuiItemFlags_.ImGuiItemFlags_None)
	g.ActiveId = backup_active_id

	// Determine skewed MousePos.x to support angled headers.
	mouse_skewed_x : f32 = g.IO.MousePos.x
	if table.AngledHeadersHeight > 0.0 { if g.IO.MousePos.y >= table.OuterRect.Min.y && g.IO.MousePos.y <= table.OuterRect.Min.y + table.AngledHeadersHeight { mouse_skewed_x += ImTrunc((table.OuterRect.Min.y + table.AngledHeadersHeight - g.IO.MousePos.y) * table.AngledHeadersSlope) } }

	// [Part 6] Setup final position, offset, skip/clip states and clipping rectangles, detect hovered column
	// Process columns in their visible orders as we are comparing the visible order and adjusting host_clip_rect while looping.
	visible_n : i16 = 0
	has_at_least_one_column_requesting_output : bool = false
	offset_x_frozen : bool = (table.FreezeColumnsCount > 0)
	offset_x : f32 = ((table.FreezeColumnsCount > 0) ? table.OuterRect.Min.x : work_rect.Min.x) + table.OuterPaddingX - table.CellSpacingX1
	host_clip_rect : ImRect = table.InnerClipRect
	//host_clip_rect.Max.x += table->CellPaddingX + table->CellSpacingX2;
	ImBitArrayClearAllBits(table.VisibleMaskByIndex, table.ColumnsCount)
	for order_n : i32 = 0; order_n < table.ColumnsCount; order_n += 1 {
		column_n := table.DisplayOrderToIndex.Data[order_n]
		column : ^ImGuiTableColumn = &table.Columns.Data[column_n]

		column.NavLayerCurrent = cast(ImS8) (table.FreezeRowsCount > 0 ? ImGuiNavLayer.ImGuiNavLayer_Menu : ImGuiNavLayer.ImGuiNavLayer_Main); // Use Count NOT request so Header line changes layer when frozen

		if offset_x_frozen && table.FreezeColumnsCount == visible_n {
			offset_x += work_rect.Min.x - table.OuterRect.Min.x
			offset_x_frozen = false
		}

		// Clear status flags
		column.Flags &= cast(ImGuiTableColumnFlags)~cast(i32)ImGuiTableColumnFlags_.ImGuiTableColumnFlags_StatusMask_

		if !IM_BITARRAY_TESTBIT(table.EnabledMaskByDisplayOrder, order_n) {
			// Hidden column: clear a few fields and we are done with it for the remainder of the function.
			// We set a zero-width clip rect but set Min.y/Max.y properly to not interfere with the clipper.
			column.ClipRect.Max.x = offset_x; column.ClipRect.Min.x = column.ClipRect.Max.x; column.WorkMinX = column.ClipRect.Min.x; column.MaxX = column.WorkMinX; column.MinX = column.MaxX
			column.WidthGiven = 0.0
			column.ClipRect.Min.y = work_rect.Min.y
			column.ClipRect.Max.y = FLT_MAX
			ClipWithFull(&column.ClipRect, host_clip_rect)
			column.IsRequestOutput = false; column.IsVisibleY = column.IsRequestOutput; column.IsVisibleX = column.IsVisibleY
			column.IsSkipItems = true
			column.ItemWidth = 1.0
			continue
		}

		// Lock start position
		column.MinX = offset_x

		// Lock width based on start position and minimum/maximum width for this position
		column.WidthMax = TableCalcMaxColumnWidth(table, i32(column_n))
		column.WidthGiven = ImMin(column.WidthGiven, column.WidthMax)
		column.WidthGiven = ImMax(column.WidthGiven, ImMin(column.WidthRequest, table.MinColumnWidth))
		column.MaxX = offset_x + column.WidthGiven + table.CellSpacingX1 + table.CellSpacingX2 + table.CellPaddingX * 2.0

		// Lock other positions
		// - ClipRect.Min.x: Because merging draw commands doesn't compare min boundaries, we make ClipRect.Min.x match left bounds to be consistent regardless of merging.
		// - ClipRect.Max.x: using WorkMaxX instead of MaxX (aka including padding) makes things more consistent when resizing down, tho slightly detrimental to visibility in very-small column.
		// - ClipRect.Max.x: using MaxX makes it easier for header to receive hover highlight with no discontinuity and display sorting arrow.
		// - FIXME-TABLE: We want equal width columns to have equal (ClipRect.Max.x - WorkMinX) width, which means ClipRect.max.x cannot stray off host_clip_rect.Max.x else right-most column may appear shorter.
		previous_instance_work_min_x : f32 = column.WorkMinX
		column.WorkMinX = column.MinX + table.CellPaddingX + table.CellSpacingX1
		column.WorkMaxX = column.MaxX - table.CellPaddingX - table.CellSpacingX2; // Expected max
		column.ItemWidth = ImTrunc(column.WidthGiven * 0.65)
		column.ClipRect.Min.x = column.MinX
		column.ClipRect.Min.y = work_rect.Min.y
		column.ClipRect.Max.x = column.MaxX; //column->WorkMaxX;
		column.ClipRect.Max.y = FLT_MAX
		ClipWithFull(&column.ClipRect, host_clip_rect)

		// Mark column as Clipped (not in sight)
		// Note that scrolling tables (where inner_window != outer_window) handle Y clipped earlier in BeginTable() so IsVisibleY really only applies to non-scrolling tables.
		// FIXME-TABLE: Because InnerClipRect.Max.y is conservatively ==outer_window->ClipRect.Max.y, we never can mark columns _Above_ the scroll line as not IsVisibleY.
		// Taking advantage of LastOuterHeight would yield good results there...
		// FIXME-TABLE: Y clipping is disabled because it effectively means not submitting will reduce contents width which is fed to outer_window->DC.CursorMaxPos.x,
		// and this may be used (e.g. typically by outer_window using AlwaysAutoResize or outer_window's horizontal scrollbar, but could be something else).
		// Possible solution to preserve last known content width for clipped column. Test 'table_reported_size' fails when enabling Y clipping and window is resized small.
		column.IsVisibleX = (column.ClipRect.Max.x > column.ClipRect.Min.x)
		column.IsVisibleY = true; // (column->ClipRect.Max.y > column->ClipRect.Min.y);
		is_visible : bool = column.IsVisibleX; //&& column->IsVisibleY;
		if is_visible { ImBitArraySetBit(table.VisibleMaskByIndex, u32(column_n)) }

		// Mark column as requesting output from user. Note that fixed + non-resizable sets are auto-fitting at all times and therefore always request output.
		column.IsRequestOutput = is_visible || column.AutoFitQueue != 0 || column.CannotSkipItemsQueue != 0

		// Mark column as SkipItems (ignoring all items/layout)
		// (table->HostSkipItems is a copy of inner_window->SkipItems before we cleared it above in Part 2)
		column.IsSkipItems = !column.IsEnabled || table.HostSkipItems
		if column.IsSkipItems { IM_ASSERT(!is_visible) }
		if column.IsRequestOutput && !column.IsSkipItems { has_at_least_one_column_requesting_output = true }

		// Update status flags
		column.Flags |= ImGuiTableColumnFlags_.ImGuiTableColumnFlags_IsEnabled
		if is_visible { column.Flags |= ImGuiTableColumnFlags_.ImGuiTableColumnFlags_IsVisible }
		if column.SortOrder != -1 { column.Flags |= ImGuiTableColumnFlags_.ImGuiTableColumnFlags_IsSorted }

		// Detect hovered column
		if is_hovering_table && mouse_skewed_x >= column.ClipRect.Min.x && mouse_skewed_x < column.ClipRect.Max.x {
			column.Flags |= ImGuiTableColumnFlags_.ImGuiTableColumnFlags_IsHovered
			table.HoveredColumnBody = cast(ImGuiTableColumnIdx) column_n
		}

		// Alignment
		// FIXME-TABLE: This align based on the whole column width, not per-cell, and therefore isn't useful in
		// many cases (to be able to honor this we might be able to store a log of cells width, per row, for
		// visible rows, but nav/programmatic scroll would have visible artifacts.)
		//if (column->Flags & ImGuiTableColumnFlags_AlignRight)
		//    column->WorkMinX = ImMax(column->WorkMinX, column->MaxX - column->ContentWidthRowsUnfrozen);
		//else if (column->Flags & ImGuiTableColumnFlags_AlignCenter)
		//    column->WorkMinX = ImLerp(column->WorkMinX, ImMax(column->StartX, column->MaxX - column->ContentWidthRowsUnfrozen), 0.5f);

		// Reset content width variables
		if table.InstanceCurrent == 0 {
			column.ContentMaxXFrozen = column.WorkMinX
			column.ContentMaxXUnfrozen = column.WorkMinX
			column.ContentMaxXHeadersUsed = column.WorkMinX
			column.ContentMaxXHeadersIdeal = column.WorkMinX
		}
		else {
			// As we store an absolute value to make per-cell updates faster, we need to offset values used for width computation.
			offset_from_previous_instance : f32 = column.WorkMinX - previous_instance_work_min_x
			column.ContentMaxXFrozen += offset_from_previous_instance
			column.ContentMaxXUnfrozen += offset_from_previous_instance
			column.ContentMaxXHeadersUsed += offset_from_previous_instance
			column.ContentMaxXHeadersIdeal += offset_from_previous_instance
		}

		// Don't decrement auto-fit counters until container window got a chance to submit its items
		if table.HostSkipItems == false && table.InstanceCurrent == 0 {
			column.AutoFitQueue >>= 1
			column.CannotSkipItemsQueue >>= 1
		}

		if visible_n < table.FreezeColumnsCount { host_clip_rect.Min.x = ImClamp(column.MaxX + TABLE_BORDER_SIZE, host_clip_rect.Min.x, host_clip_rect.Max.x) }

		offset_x += column.WidthGiven + table.CellSpacingX1 + table.CellSpacingX2 + table.CellPaddingX * 2.0
		post_incr(&visible_n)
	}

	// In case the table is visible (e.g. decorations) but all columns clipped, we keep a column visible.
	// Else if give no chance to a clipper-savy user to submit rows and therefore total contents height used by scrollbar.
	if has_at_least_one_column_requesting_output == false {
		table.Columns.Data[table.LeftMostEnabledColumn].IsRequestOutput = true
		table.Columns.Data[table.LeftMostEnabledColumn].IsSkipItems = false
	}

	// [Part 7] Detect/store when we are hovering the unused space after the right-most column (so e.g. context menus can react on it)
	// Clear Resizable flag if none of our column are actually resizable (either via an explicit _NoResize flag, either
	// because of using _WidthAuto/_WidthStretch). This will hide the resizing option from the context menu.
	unused_x1 : f32 = ImMax(table.WorkRect.Min.x, table.Columns.Data[table.RightMostEnabledColumn].ClipRect.Max.x)
	if is_hovering_table && table.HoveredColumnBody == -1 { if mouse_skewed_x >= unused_x1 { table.HoveredColumnBody = cast(ImGuiTableColumnIdx) table.ColumnsCount } }
	if has_resizable == false && (table.Flags & ImGuiTableFlags_.ImGuiTableFlags_Resizable) != {} { table.Flags &= cast(ImGuiTableFlags)~cast(i32)ImGuiTableFlags_.ImGuiTableFlags_Resizable }

	table.IsActiveIdAliveBeforeTable = (g.ActiveIdIsAlive != 0)

	// [Part 8] Lock actual OuterRect/WorkRect right-most position.
	// This is done late to handle the case of fixed-columns tables not claiming more widths that they need.
	// Because of this we are careful with uses of WorkRect and InnerClipRect before this point.
	if table.RightMostStretchedColumn != -1 { table.Flags &= cast(ImGuiTableFlags)~cast(i32)ImGuiTableFlags_.ImGuiTableFlags_NoHostExtendX }
	if (table.Flags & ImGuiTableFlags_.ImGuiTableFlags_NoHostExtendX) != {} {
		table.WorkRect.Max.x = unused_x1; table.OuterRect.Max.x = table.WorkRect.Max.x
		table.InnerClipRect.Max.x = ImMin(table.InnerClipRect.Max.x, unused_x1)
	}
	table.InnerWindow.ParentWorkRect = table.WorkRect
	table.BorderX1 = table.InnerClipRect.Min.x
	table.BorderX2 = table.InnerClipRect.Max.x

	// Setup window's WorkRect.Max.y for GetContentRegionAvail(). Other values will be updated in each TableBeginCell() call.
	window_content_max_y : f32
	if (table.Flags & ImGuiTableFlags_.ImGuiTableFlags_NoHostExtendY) != {} { window_content_max_y = table.OuterRect.Max.y }
	else { window_content_max_y = ImMax(table.InnerWindow.ContentRegionRect.Max.y, (table.Flags & ImGuiTableFlags_.ImGuiTableFlags_ScrollY) != {} ? 0.0 : table.OuterRect.Max.y) }
	table.InnerWindow.WorkRect.Max.y = ImClamp(window_content_max_y - g.Style.CellPadding.y, table.InnerWindow.WorkRect.Min.y, table.InnerWindow.WorkRect.Max.y)

	// [Part 9] Allocate draw channels and setup background cliprect
	TableSetupDrawChannels(table)

	// [Part 10] Hit testing on borders
	if (table.Flags & ImGuiTableFlags_.ImGuiTableFlags_Resizable) != {} { TableUpdateBorders(table) }
	table_instance.LastTopHeadersRowHeight = 0.0
	table.IsLayoutLocked = true
	table.IsUsingHeaders = false

	// Highlight header
	table.HighlightColumnHeader = -1
	if table.IsContextPopupOpen && table.ContextPopupColumn != -1 && table.InstanceInteracted == table.InstanceCurrent { table.HighlightColumnHeader = table.ContextPopupColumn }
	else if (table.Flags & ImGuiTableFlags_.ImGuiTableFlags_HighlightHoveredColumn) != {} && table.HoveredColumnBody != -1 && i32(table.HoveredColumnBody) != table.ColumnsCount && table.HoveredColumnBorder == -1 { if g.ActiveId == 0 || (table.IsActiveIdInTable || g.DragDropActive) { table.HighlightColumnHeader = table.HoveredColumnBody } }

	// [Part 11] Default context menu
	// - To append to this menu: you can call TableBeginContextMenuPopup()/.../EndPopup().
	// - To modify or replace this: set table->IsContextPopupNoDefaultContents = true, then call TableBeginContextMenuPopup()/.../EndPopup().
	// - You may call TableDrawDefaultContextMenu() with selected flags to display specific sections of the default menu,
	//   e.g. TableDrawDefaultContextMenu(table, table->Flags & ~ImGuiTableFlags_Hideable) will display everything EXCEPT columns visibility options.
	if table.DisableDefaultContextMenu == false && TableBeginContextMenuPopup(table) {
		TableDrawDefaultContextMenu(table, table.Flags)
		EndPopup()
	}

	// [Part 12] Sanitize and build sort specs before we have a chance to use them for display.
	// This path will only be exercised when sort specs are modified before header rows (e.g. init or visibility change)
	if table.IsSortSpecsDirty && (table.Flags & ImGuiTableFlags_.ImGuiTableFlags_Sortable) != {} { TableSortSpecsBuild(table) }

	// [Part 13] Setup inner window decoration size (for scrolling / nav tracking to properly take account of frozen rows/columns)
	if table.FreezeColumnsRequest > 0 { table.InnerWindow.DecoInnerSizeX1 = table.Columns.Data[table.DisplayOrderToIndex.Data[table.FreezeColumnsRequest - 1]].MaxX - table.OuterRect.Min.x }
	if table.FreezeRowsRequest > 0 { table.InnerWindow.DecoInnerSizeY1 = table_instance.LastFrozenHeight }
	table_instance.LastFrozenHeight = 0.0

	// Initial state
	inner_window : ^ImGuiWindow = table.InnerWindow
	if (table.Flags & ImGuiTableFlags_.ImGuiTableFlags_NoClip) != {} { SetCurrentChannel(table.DrawSplitter, inner_window.DrawList, TABLE_DRAW_CHANNEL_NOCLIP) }
	else {
		// FIXME: use table->InnerClipRect?
		PushClipRect(inner_window.DrawList, inner_window.InnerClipRect.Min, inner_window.InnerClipRect.Max, false)
	}
}

// Process hit-testing on resizing borders. Actual size change will be applied in EndTable()
// - Set table->HoveredColumnBorder with a short delay/timer to reduce visual feedback noise.
TableUpdateBorders :: proc(table : ^ImGuiTable)
{
	g : ^ImGuiContext = GImGui
	IM_ASSERT((table.Flags & ImGuiTableFlags_.ImGuiTableFlags_Resizable) != {})

	// At this point OuterRect height may be zero or under actual final height, so we rely on temporal coherency and
	// use the final height from last frame. Because this is only affecting _interaction_ with columns, it is not
	// really problematic (whereas the actual visual will be displayed in EndTable() and using the current frame height).
	// Actual columns highlight/render will be performed in EndTable() and not be affected.
	table_instance : ^ImGuiTableInstanceData = TableGetInstanceData(table, i32(table.InstanceCurrent))
	hit_half_width : f32 = ImTrunc(TABLE_RESIZE_SEPARATOR_HALF_THICKNESS * g.CurrentDpiScale)
	hit_y1 : f32 = (table.FreezeRowsCount >= 1 ? table.OuterRect.Min.y : table.WorkRect.Min.y) + table.AngledHeadersHeight
	hit_y2_body : f32 = ImMax(table.OuterRect.Max.y, hit_y1 + table_instance.LastOuterHeight - table.AngledHeadersHeight)
	hit_y2_head : f32 = hit_y1 + table_instance.LastTopHeadersRowHeight

	for order_n : i32 = 0; order_n < table.ColumnsCount; order_n += 1 {
		if !IM_BITARRAY_TESTBIT(table.EnabledMaskByDisplayOrder, order_n) { continue }

		column_n := table.DisplayOrderToIndex.Data[order_n]
		column : ^ImGuiTableColumn = &table.Columns.Data[column_n]
		if (column.Flags & (ImGuiTableColumnFlags_.ImGuiTableColumnFlags_NoResize | ImGuiTableColumnFlags_.ImGuiTableColumnFlags_NoDirectResize_)) != {} { continue }

		// ImGuiTableFlags_NoBordersInBodyUntilResize will be honored in TableDrawBorders()
		border_y2_hit : f32 = (table.Flags & ImGuiTableFlags_.ImGuiTableFlags_NoBordersInBody) != {} ? hit_y2_head : hit_y2_body
		if (table.Flags & ImGuiTableFlags_.ImGuiTableFlags_NoBordersInBody) != {} && table.IsUsingHeaders == false { continue }

		if !column.IsVisibleX && table.LastResizedColumn != column_n { continue }

		column_id : ImGuiID = TableGetColumnResizeID(table, i32(column_n), i32(table.InstanceCurrent))
		hit_rect : ImRect; init(&hit_rect, column.MaxX - hit_half_width, hit_y1, column.MaxX + hit_half_width, border_y2_hit)
		ItemAdd(hit_rect, column_id, nil, ImGuiItemFlags_.ImGuiItemFlags_NoNav)
		//GetForegroundDrawList()->AddRect(hit_rect.Min, hit_rect.Max, IM_COL32(255, 0, 0, 100));

		hovered : bool = false; held : bool = false
		pressed : bool = ButtonBehavior(hit_rect, column_id, &hovered, &held, ImGuiButtonFlags(ImGuiButtonFlagsPrivate_.ImGuiButtonFlags_FlattenChildren | ImGuiButtonFlagsPrivate_.ImGuiButtonFlags_PressedOnClick | ImGuiButtonFlagsPrivate_.ImGuiButtonFlags_PressedOnDoubleClick | ImGuiButtonFlagsPrivate_.ImGuiButtonFlags_NoNavFocus))
		if pressed && IsMouseDoubleClicked(ImGuiMouseButton(0)) {
			TableSetColumnWidthAutoSingle(table, i32(column_n))
			ClearActiveID()
			held = false
		}
		if held {
			if table.LastResizedColumn == -1 { table.ResizeLockMinContentsX2 = table.RightMostEnabledColumn != -1 ? table.Columns.Data[table.RightMostEnabledColumn].MaxX : -FLT_MAX }
			table.ResizedColumn = cast(ImGuiTableColumnIdx) column_n
			table.InstanceInteracted = table.InstanceCurrent
		}
		if (hovered && g.HoveredIdTimer > TABLE_RESIZE_SEPARATOR_FEEDBACK_TIMER) || held {
			table.HoveredColumnBorder = cast(ImGuiTableColumnIdx) column_n
			SetMouseCursor(ImGuiMouseCursor_.ImGuiMouseCursor_ResizeEW)
		}
	}
}

EndTable :: proc()
{
	g : ^ImGuiContext = GImGui
	table : ^ImGuiTable = g.CurrentTable
	IM_ASSERT(table != nil, "Only call EndTable() if BeginTable() returns true!")

	// This assert would be very useful to catch a common error... unfortunately it would probably trigger in some
	// cases, and for consistency user may sometimes output empty tables (and still benefit from e.g. outer border)
	//IM_ASSERT(table->IsLayoutLocked, "Table unused: never called TableNextRow(), is that the intent?");

	// If the user never got to call TableNextRow() or TableNextColumn(), we call layout ourselves to ensure all our
	// code paths are consistent (instead of just hoping that TableBegin/TableEnd will work), get borders drawn, etc.
	if !table.IsLayoutLocked { TableUpdateLayout(table) }

	flags : ImGuiTableFlags = table.Flags
	inner_window : ^ImGuiWindow = table.InnerWindow
	outer_window : ^ImGuiWindow = table.OuterWindow
	temp_data : ^ImGuiTableTempData = table.TempData
	IM_ASSERT(inner_window == g.CurrentWindow)
	IM_ASSERT(outer_window == inner_window || outer_window == inner_window.ParentWindow)

	if table.IsInsideRow { TableEndRow(table) }

	// Context menu in columns body
	if (flags & ImGuiTableFlags_.ImGuiTableFlags_ContextMenuInBody) != {} { if table.HoveredColumnBody != -1 && !IsAnyItemHovered() && IsMouseReleased(ImGuiMouseButton_.ImGuiMouseButton_Right) { TableOpenContextMenu(cast(i32) table.HoveredColumnBody) } }

	// Finalize table height
	table_instance : ^ImGuiTableInstanceData = TableGetInstanceData(table, i32(table.InstanceCurrent))
	inner_window.DC.PrevLineSize = temp_data.HostBackupPrevLineSize
	inner_window.DC.CurrLineSize = temp_data.HostBackupCurrLineSize
	inner_window.DC.CursorMaxPos = temp_data.HostBackupCursorMaxPos
	inner_content_max_y : f32 = table.RowPosY2
	IM_ASSERT(table.RowPosY2 == inner_window.DC.CursorPos.y)
	if inner_window != outer_window { inner_window.DC.CursorMaxPos.y = inner_content_max_y }
	else if (flags & ImGuiTableFlags_.ImGuiTableFlags_NoHostExtendY) == {} {
		// Patch OuterRect/InnerRect height
		table.InnerRect.Max.y = ImMax(table.OuterRect.Max.y, inner_content_max_y); table.OuterRect.Max.y = table.InnerRect.Max.y
	}
	table.WorkRect.Max.y = ImMax(table.WorkRect.Max.y, table.OuterRect.Max.y)
	table_instance.LastOuterHeight = GetHeight(table.OuterRect)

	// Setup inner scrolling range
	// FIXME: This ideally should be done earlier, in BeginTable() SetNextWindowContentSize call, just like writing to inner_window->DC.CursorMaxPos.y,
	// but since the later is likely to be impossible to do we'd rather update both axises together.
	if (table.Flags & ImGuiTableFlags_.ImGuiTableFlags_ScrollX) != {} {
		outer_padding_for_border : f32 = (table.Flags & ImGuiTableFlags_.ImGuiTableFlags_BordersOuterV) != {} ? TABLE_BORDER_SIZE : 0.0
		max_pos_x : f32 = table.InnerWindow.DC.CursorMaxPos.x
		if table.RightMostEnabledColumn != -1 { max_pos_x = ImMax(max_pos_x, table.Columns.Data[table.RightMostEnabledColumn].WorkMaxX + table.CellPaddingX + table.OuterPaddingX - outer_padding_for_border) }
		if table.ResizedColumn != -1 { max_pos_x = ImMax(max_pos_x, table.ResizeLockMinContentsX2) }
		table.InnerWindow.DC.CursorMaxPos.x = max_pos_x + table.TempData.AngledHeadersExtraWidth
	}

	// Pop clipping rect
	if (flags & ImGuiTableFlags_.ImGuiTableFlags_NoClip) == {} { PopClipRect(inner_window.DrawList) }
	inner_window.ClipRect = transmute(ImRect) back(&inner_window.DrawList._ClipRectStack)^

	// Draw borders
	if (flags & ImGuiTableFlags_.ImGuiTableFlags_Borders) != {} { TableDrawBorders(table) }



	// Flatten channels and merge draw calls
	splitter : ^ImDrawListSplitter = table.DrawSplitter
	SetCurrentChannel(splitter, inner_window.DrawList, 0)
	if (table.Flags & ImGuiTableFlags_.ImGuiTableFlags_NoClip) == {} { TableMergeDrawChannels(table) }
	Merge(splitter, inner_window.DrawList)

	// Update ColumnsAutoFitWidth to get us ahead for host using our size to auto-resize without waiting for next BeginTable()
	auto_fit_width_for_fixed : f32 = 0.0
	auto_fit_width_for_stretched : f32 = 0.0
	auto_fit_width_for_stretched_min : f32 = 0.0
	for column_n : i32 = 0; column_n < table.ColumnsCount; column_n += 1 { if IM_BITARRAY_TESTBIT(table.EnabledMaskByIndex, column_n) {
	column : ^ImGuiTableColumn = &table.Columns.Data[column_n]
	column_width_request : f32 = ((column.Flags & ImGuiTableColumnFlags_.ImGuiTableColumnFlags_WidthFixed) != {} && (column.Flags & ImGuiTableColumnFlags_.ImGuiTableColumnFlags_NoResize) == {}) ? column.WidthRequest : TableGetColumnWidthAuto(table, column)
	if (column.Flags & ImGuiTableColumnFlags_.ImGuiTableColumnFlags_WidthFixed) != {} { auto_fit_width_for_fixed += column_width_request }
	else { auto_fit_width_for_stretched += column_width_request }
	if (column.Flags & ImGuiTableColumnFlags_.ImGuiTableColumnFlags_WidthStretch) != {} && (column.Flags & ImGuiTableColumnFlags_.ImGuiTableColumnFlags_NoResize) != {} { auto_fit_width_for_stretched_min = ImMax(auto_fit_width_for_stretched_min, column_width_request / (column.StretchWeight / table.ColumnsStretchSumWeights)) }
} }

	width_spacings : f32 = (table.OuterPaddingX * 2.0) + (table.CellSpacingX1 + table.CellSpacingX2) * (f32(table.ColumnsEnabledCount) - 1)
	table.ColumnsAutoFitWidth = width_spacings + (table.CellPaddingX * 2.0) * f32(table.ColumnsEnabledCount) + auto_fit_width_for_fixed + ImMax(auto_fit_width_for_stretched, auto_fit_width_for_stretched_min)

	// Update scroll
	if (table.Flags & ImGuiTableFlags_.ImGuiTableFlags_ScrollX) == {} && inner_window != outer_window {
		inner_window.Scroll.x = 0.0
	}
	else if table.LastResizedColumn != -1 && table.ResizedColumn == -1 && inner_window.ScrollbarX && table.InstanceInteracted == table.InstanceCurrent {
		// When releasing a column being resized, scroll to keep the resulting column in sight
		neighbor_width_to_keep_visible : f32 = table.MinColumnWidth + table.CellPaddingX * 2.0
		column : ^ImGuiTableColumn = &table.Columns.Data[table.LastResizedColumn]
		if column.MaxX < table.InnerClipRect.Min.x { SetScrollFromPosX(inner_window, column.MaxX - inner_window.Pos.x - neighbor_width_to_keep_visible, 1.0) }
		else if column.MaxX > table.InnerClipRect.Max.x { SetScrollFromPosX(inner_window, column.MaxX - inner_window.Pos.x + neighbor_width_to_keep_visible, 1.0) }
	}

	// Apply resizing/dragging at the end of the frame
	if table.ResizedColumn != -1 && table.InstanceCurrent == table.InstanceInteracted {
		column : ^ImGuiTableColumn = &table.Columns.Data[table.ResizedColumn]
		new_x2 : f32 = (g.IO.MousePos.x - g.ActiveIdClickOffset.x + ImTrunc(TABLE_RESIZE_SEPARATOR_HALF_THICKNESS * g.CurrentDpiScale))
		new_width : f32 = ImTrunc(new_x2 - column.MinX - table.CellSpacingX1 - table.CellPaddingX * 2.0)
		table.ResizedColumnNextWidth = new_width
	}

	table.IsActiveIdInTable = (g.ActiveIdIsAlive != 0 && table.IsActiveIdAliveBeforeTable == false)

	// Pop from id stack
	IM_ASSERT_USER_ERROR(back(&inner_window.IDStack)^ == table_instance.TableInstanceID, "Mismatching PushID/PopID!")
	IM_ASSERT_USER_ERROR(outer_window.DC.ItemWidthStack.Size >= temp_data.HostBackupItemWidthStackSize, "Too many PopItemWidth!")
	if table.InstanceCurrent > 0 { PopID() }
	PopID()

	// Restore window data that we modified
	backup_outer_max_pos : ImVec2 = outer_window.DC.CursorMaxPos
	inner_window.WorkRect = temp_data.HostBackupWorkRect
	inner_window.ParentWorkRect = temp_data.HostBackupParentWorkRect
	inner_window.SkipItems = table.HostSkipItems
	outer_window.DC.CursorPos = table.OuterRect.Min
	outer_window.DC.ItemWidth = temp_data.HostBackupItemWidth
	outer_window.DC.ItemWidthStack.Size = temp_data.HostBackupItemWidthStackSize
	outer_window.DC.ColumnsOffset = temp_data.HostBackupColumnsOffset

	// Layout in outer window
	// (FIXME: To allow auto-fit and allow desirable effect of SameLine() we dissociate 'used' vs 'ideal' size by overriding
	// CursorPosPrevLine and CursorMaxPos manually. That should be a more general layout feature, see same problem e.g. #3414)
	if inner_window != outer_window {
		backup_nav_layers_active_mask : i16 = inner_window.DC.NavLayersActiveMask
		inner_window.DC.NavLayersActiveMask |= 1 << cast(u32)ImGuiNavLayer.ImGuiNavLayer_Main; // So empty table don't appear to navigate differently.
		g.CurrentTable = nil; // To avoid error recovery recursing
		EndChild()
		g.CurrentTable = table
		inner_window.DC.NavLayersActiveMask = backup_nav_layers_active_mask
	}
	else {
		ItemSize(GetSize(table.OuterRect))
		ItemAdd(table.OuterRect, 0)
	}

	// Override declared contents width/height to enable auto-resize while not needlessly adding a scrollbar
	if (table.Flags & ImGuiTableFlags_.ImGuiTableFlags_NoHostExtendX) != {} {
		// FIXME-TABLE: Could we remove this section?
		// ColumnsAutoFitWidth may be one frame ahead here since for Fixed+NoResize is calculated from latest contents
		IM_ASSERT((table.Flags & ImGuiTableFlags_.ImGuiTableFlags_ScrollX) == {})
		outer_window.DC.CursorMaxPos.x = ImMax(backup_outer_max_pos.x, table.OuterRect.Min.x + table.ColumnsAutoFitWidth)
	}
	else if temp_data.UserOuterSize.x <= 0.0 {
		// Some references for this: #7651 + tests "table_reported_size", "table_reported_size_outer" equivalent Y block
		// - Checking for ImGuiTableFlags_ScrollX/ScrollY flag makes us a frame ahead when disabling those flags.
		// - FIXME-TABLE: Would make sense to pre-compute expected scrollbar visibility/sizes to generally save a frame of feedback.
		inner_content_max_x : f32 = table.OuterRect.Min.x + table.ColumnsAutoFitWidth; // Slightly misleading name but used for code symmetry with inner_content_max_y
		decoration_size : f32 = table.TempData.AngledHeadersExtraWidth + ((table.Flags & ImGuiTableFlags_.ImGuiTableFlags_ScrollY) != {} ? inner_window.ScrollbarSizes.x : 0.0)
		outer_window.DC.IdealMaxPos.x = ImMax(outer_window.DC.IdealMaxPos.x, inner_content_max_x + decoration_size - temp_data.UserOuterSize.x)
		outer_window.DC.CursorMaxPos.x = ImMax(backup_outer_max_pos.x, ImMin(table.OuterRect.Max.x, inner_content_max_x + decoration_size))
	}
	else {
		outer_window.DC.CursorMaxPos.x = ImMax(backup_outer_max_pos.x, table.OuterRect.Max.x)
	}
	if temp_data.UserOuterSize.y <= 0.0 {
		decoration_size : f32 = (table.Flags & ImGuiTableFlags_.ImGuiTableFlags_ScrollX) != {} ? inner_window.ScrollbarSizes.y : 0.0
		outer_window.DC.IdealMaxPos.y = ImMax(outer_window.DC.IdealMaxPos.y, inner_content_max_y + decoration_size - temp_data.UserOuterSize.y)
		outer_window.DC.CursorMaxPos.y = ImMax(backup_outer_max_pos.y, ImMin(table.OuterRect.Max.y, inner_content_max_y + decoration_size))
	}
	else {
		// OuterRect.Max.y may already have been pushed downward from the initial value (unless ImGuiTableFlags_NoHostExtendY is set)
		outer_window.DC.CursorMaxPos.y = ImMax(backup_outer_max_pos.y, table.OuterRect.Max.y)
	}

	// Save settings
	if table.IsSettingsDirty { TableSaveSettings(table) }
	table.IsInitializing = false

	// Clear or restore current table, if any
	IM_ASSERT(g.CurrentWindow == outer_window && g.CurrentTable == table)
	IM_ASSERT(g.TablesTempDataStacked > 0)
	temp_data = (pre_decr(&g.TablesTempDataStacked) > 0) ? &g.TablesTempData.Data[g.TablesTempDataStacked - 1] : nil
	g.CurrentTable = temp_data != nil ? GetByIndex(&g.Tables, temp_data.TableIndex) : nil
	if g.CurrentTable != nil {
		g.CurrentTable.TempData = temp_data
		g.CurrentTable.DrawSplitter = &temp_data.DrawSplitter
	}
	outer_window.DC.CurrentTableIdx = g.CurrentTable != nil ? GetIndex(&g.Tables, g.CurrentTable) : -1
	NavUpdateCurrentWindowIsScrollPushableX()
}

// See "COLUMNS SIZING POLICIES" comments at the top of this file
// If (init_width_or_weight <= 0.0f) it is ignored
TableSetupColumn :: proc(label : string, flags : ImGuiTableColumnFlags = {}, init_width_or_weight : f32 = 0, user_id : ImGuiID = 0)
{
	flags := flags
	g : ^ImGuiContext = GImGui
	table : ^ImGuiTable = g.CurrentTable
	IM_ASSERT(table != nil, "Need to call TableSetupColumn() after BeginTable()!")
	IM_ASSERT(table.IsLayoutLocked == false, "Need to call call TableSetupColumn() before first row!")
	IM_ASSERT((flags & ImGuiTableColumnFlags_.ImGuiTableColumnFlags_StatusMask_) == {}, "Illegal to pass StatusMask values to TableSetupColumn()")
	if i32(table.DeclColumnsCount) >= table.ColumnsCount {
		IM_ASSERT_USER_ERROR(i32(table.DeclColumnsCount) < table.ColumnsCount, "Called TableSetupColumn() too many times!")
		return
	}

	column : ^ImGuiTableColumn = &table.Columns.Data[table.DeclColumnsCount]
	post_incr(&table.DeclColumnsCount)

	// Assert when passing a width or weight if policy is entirely left to default, to avoid storing width into weight and vice-versa.
	// Give a grace to users of ImGuiTableFlags_ScrollX.
	if table.IsDefaultSizingPolicy && (flags & ImGuiTableColumnFlags_.ImGuiTableColumnFlags_WidthMask_) == {} && (flags & cast(ImGuiTableColumnFlags)ImGuiTableFlags_.ImGuiTableFlags_ScrollX) == {} { IM_ASSERT(init_width_or_weight <= 0.0, "Can only specify width/weight if sizing policy is set explicitly in either Table or Column.") }

	// When passing a width automatically enforce WidthFixed policy
	// (whereas TableSetupColumnFlags would default to WidthAuto if table is not Resizable)
	if (flags & ImGuiTableColumnFlags_.ImGuiTableColumnFlags_WidthMask_) == {} && init_width_or_weight > 0.0 { if (table.Flags & ImGuiTableFlags_.ImGuiTableFlags_SizingMask_) == ImGuiTableFlags_.ImGuiTableFlags_SizingFixedFit || (table.Flags & ImGuiTableFlags_.ImGuiTableFlags_SizingMask_) == ImGuiTableFlags_.ImGuiTableFlags_SizingFixedSame { flags |= ImGuiTableColumnFlags_.ImGuiTableColumnFlags_WidthFixed } }
	if (flags & ImGuiTableColumnFlags_.ImGuiTableColumnFlags_AngledHeader) != {} {
		flags |= ImGuiTableColumnFlags_.ImGuiTableColumnFlags_NoHeaderLabel
		post_incr(&table.AngledHeadersCount)
	}

	TableSetupColumnFlags(table, column, flags)
	column.UserID = user_id
	flags = column.Flags

	// Initialize defaults
	column.InitStretchWeightOrWidth = init_width_or_weight
	if table.IsInitializing {
		// Init width or weight
		if column.WidthRequest < 0.0 && column.StretchWeight < 0.0 {
			if (flags & ImGuiTableColumnFlags_.ImGuiTableColumnFlags_WidthFixed) != {} && init_width_or_weight > 0.0 { column.WidthRequest = init_width_or_weight }
			if (flags & ImGuiTableColumnFlags_.ImGuiTableColumnFlags_WidthStretch) != {} { column.StretchWeight = (init_width_or_weight > 0.0) ? init_width_or_weight : -1.0 }

			// Disable auto-fit if an explicit width/weight has been specified
			if init_width_or_weight > 0.0 { column.AutoFitQueue = 0x00 }
		}

		// Init default visibility/sort state
		if (flags & ImGuiTableColumnFlags_.ImGuiTableColumnFlags_DefaultHide) != {} && (table.SettingsLoadedFlags & ImGuiTableFlags_.ImGuiTableFlags_Hideable) == {} { column.IsUserEnabledNextFrame = false; column.IsUserEnabled = column.IsUserEnabledNextFrame }
		if (flags & ImGuiTableColumnFlags_.ImGuiTableColumnFlags_DefaultSort) != {} && (table.SettingsLoadedFlags & ImGuiTableFlags_.ImGuiTableFlags_Sortable) == {} {
			column.SortOrder = 0; // Multiple columns using _DefaultSort will be reassigned unique SortOrder values when building the sort specs.
			column.SortDirection = (column.Flags & ImGuiTableColumnFlags_.ImGuiTableColumnFlags_PreferSortDescending) != {} ? ImGuiSortDirection.ImGuiSortDirection_Descending : ImGuiSortDirection.ImGuiSortDirection_Ascending
		}
	}

	// Store name (append with zero-terminator in contiguous buffer)
	// FIXME: If we recorded the number of \n in names we could compute header row height
	column.NameOffset = -1
	if label != "" {
		column.NameOffset = cast(ImS16) size(&table.ColumnsNames)
		append(&table.ColumnsNames, label)
		n : [1]u8; append(&table.ColumnsNames, raw_data(&n), &raw_data(&n)[1])
	}
}

// [Public]
TableSetupScrollFreeze :: proc(columns : i32, rows : i32)
{
	g : ^ImGuiContext = GImGui
	table : ^ImGuiTable = g.CurrentTable
	IM_ASSERT(table != nil, "Need to call TableSetupColumn() after BeginTable()!")
	IM_ASSERT(table.IsLayoutLocked == false, "Need to call TableSetupColumn() before first row!")
	IM_ASSERT(columns >= 0 && columns < IMGUI_TABLE_MAX_COLUMNS)
	IM_ASSERT(rows >= 0 && rows < 128); // Arbitrary limit

	table.FreezeColumnsRequest = (table.Flags & ImGuiTableFlags_.ImGuiTableFlags_ScrollX) != {} ? cast(ImGuiTableColumnIdx) ImMin(columns, table.ColumnsCount) : 0
	table.FreezeColumnsCount = (table.InnerWindow.Scroll.x != 0.0) ? table.FreezeColumnsRequest : 0
	table.FreezeRowsRequest = (table.Flags & ImGuiTableFlags_.ImGuiTableFlags_ScrollY) != {} ? cast(ImGuiTableColumnIdx) rows : 0
	table.FreezeRowsCount = (table.InnerWindow.Scroll.y != 0.0) ? table.FreezeRowsRequest : 0
	table.IsUnfrozenRows = (table.FreezeRowsCount == {}); // Make sure this is set before TableUpdateLayout() so ImGuiListClipper can benefit from it.b

	// Ensure frozen columns are ordered in their section. We still allow multiple frozen columns to be reordered.
	// FIXME-TABLE: This work for preserving 2143 into 21|43. How about 4321 turning into 21|43? (preserve relative order in each section)
	for column_n : i16 = 0; column_n < table.FreezeColumnsRequest; column_n += 1 {
		order_n : i16 = table.DisplayOrderToIndex.Data[column_n]
		if order_n != column_n && order_n >= table.FreezeColumnsRequest {
			ImSwap(&table.Columns.Data[table.DisplayOrderToIndex.Data[order_n]].DisplayOrder, &table.Columns.Data[table.DisplayOrderToIndex.Data[column_n]].DisplayOrder)
			ImSwap(&table.DisplayOrderToIndex.Data[order_n], &table.DisplayOrderToIndex.Data[column_n])
		}
	}
}

//-----------------------------------------------------------------------------
// [SECTION] Tables: Simple accessors
//-----------------------------------------------------------------------------
// - TableGetColumnCount()
// - TableGetColumnName()
// - TableGetColumnName() [Internal]
// - TableSetColumnEnabled()
// - TableGetColumnFlags()
// - TableGetCellBgRect() [Internal]
// - TableGetColumnResizeID() [Internal]
// - TableGetHoveredColumn() [Internal]
// - TableGetHoveredRow() [Internal]
// - TableSetBgColor()
//-----------------------------------------------------------------------------

TableGetColumnCount :: proc() -> i32
{
	g : ^ImGuiContext = GImGui
	table : ^ImGuiTable = g.CurrentTable
	return table != nil ? table.ColumnsCount : 0
}

TableGetColumnName_n :: proc(column_n : i32) -> string
{
	g : ^ImGuiContext = GImGui
	table : ^ImGuiTable = g.CurrentTable
	if table == nil { return "" }
	column_n := column_n; if column_n < 0 { column_n = table.CurrentColumn }
	return TableGetColumnName(table, column_n)
}

TableGetColumnName_tn :: proc(table : ^ImGuiTable, column_n : i32) -> string
{
	if table.IsLayoutLocked == false && column_n >= cast(i32) table.DeclColumnsCount {
		// NameOffset is invalid at this point
		return ""
	}
	column : ^ImGuiTableColumn = &table.Columns.Data[column_n]
	if column.NameOffset == -1 { return "" }
	return str.string_from_null_terminated_ptr(table.ColumnsNames.Buf.Data[column.NameOffset:], int(table.ColumnsNames.Buf.Size - cast(i32) column.NameOffset))
}

// Change user accessible enabled/disabled state of a column (often perceived as "showing/hiding" from users point of view)
// Note that end-user can use the context menu to change this themselves (right-click in headers, or right-click in columns body with ImGuiTableFlags_ContextMenuInBody)
// - Require table to have the ImGuiTableFlags_Hideable flag because we are manipulating user accessible state.
// - Request will be applied during next layout, which happens on the first call to TableNextRow() after BeginTable().
// - For the getter you can test (TableGetColumnFlags() & ImGuiTableColumnFlags_IsEnabled) != 0.
// - Alternative: the ImGuiTableColumnFlags_Disabled is an overriding/master disable flag which will also hide the column from context menu.
TableSetColumnEnabled :: proc(column_n : i32, enabled : bool)
{
	g : ^ImGuiContext = GImGui
	table : ^ImGuiTable = g.CurrentTable
	IM_ASSERT(table != nil)
	if table == nil { return }
	IM_ASSERT((table.Flags & ImGuiTableFlags_.ImGuiTableFlags_Hideable) != {}); // See comments above
	column_n := column_n
	if column_n < 0 { column_n = table.CurrentColumn }
	IM_ASSERT(column_n >= 0 && column_n < table.ColumnsCount)
	column : ^ImGuiTableColumn = &table.Columns.Data[column_n]
	column.IsUserEnabledNextFrame = enabled
}

// We allow querying for an extra column in order to poll the IsHovered state of the right-most section
TableGetColumnFlags :: proc(column_n : i32) -> ImGuiTableColumnFlags
{
	g : ^ImGuiContext = GImGui
	table : ^ImGuiTable = g.CurrentTable
	if table == nil { return ImGuiTableColumnFlags_.ImGuiTableColumnFlags_None }
	column_n := column_n
	if column_n < 0 { column_n = table.CurrentColumn }
	if column_n == table.ColumnsCount { return (i32(table.HoveredColumnBody) == column_n) ? ImGuiTableColumnFlags_.ImGuiTableColumnFlags_IsHovered : ImGuiTableColumnFlags_.ImGuiTableColumnFlags_None }
	return table.Columns.Data[column_n].Flags
}

// Return the cell rectangle based on currently known height.
// - Important: we generally don't know our row height until the end of the row, so Max.y will be incorrect in many situations.
//   The only case where this is correct is if we provided a min_row_height to TableNextRow() and don't go below it, or in TableEndRow() when we locked that height.
// - Important: if ImGuiTableFlags_PadOuterX is set but ImGuiTableFlags_PadInnerX is not set, the outer-most left and right
//   columns report a small offset so their CellBgRect can extend up to the outer border.
//   FIXME: But the rendering code in TableEndRow() nullifies that with clamping required for scrolling.
TableGetCellBgRect :: proc(table : ^ImGuiTable, column_n : i32) -> ImRect
{
	column : ^ImGuiTableColumn = &table.Columns.Data[column_n]
	x1 : f32 = column.MinX
	x2 : f32 = column.MaxX
	//if (column->PrevEnabledColumn == -1)
	//    x1 -= table->OuterPaddingX;
	//if (column->NextEnabledColumn == -1)
	//    x2 += table->OuterPaddingX;
	x1 = ImMax(x1, table.WorkRect.Min.x)
	x2 = ImMin(x2, table.WorkRect.Max.x)
	return ImRect{{x1, table.RowPosY1}, {x2, table.RowPosY2}}
}

// Return the resizing ID for the right-side of the given column.
TableGetColumnResizeID :: proc(table : ^ImGuiTable, column_n : i32, instance_no : i32) -> ImGuiID
{
	IM_ASSERT(column_n >= 0 && column_n < table.ColumnsCount)
	instance_id : ImGuiID = TableGetInstanceID(table, instance_no)
	return instance_id + ImGuiID(1 + column_n)// FIXME: #6140: still not ideal
}

// Return -1 when table is not hovered. return columns_count if hovering the unused space at the right of the right-most visible column.
TableGetHoveredColumn :: proc() -> i32
{
	g : ^ImGuiContext = GImGui
	table : ^ImGuiTable = g.CurrentTable
	if table == nil { return -1 }
	return cast(i32) table.HoveredColumnBody
}

// Return -1 when table is not hovered. Return maxrow+1 if in table but below last submitted row.
// *IMPORTANT* Unlike TableGetHoveredColumn(), this has a one frame latency in updating the value.
// This difference with is the reason why this is not public yet.
TableGetHoveredRow :: proc() -> i32
{
	g : ^ImGuiContext = GImGui
	table : ^ImGuiTable = g.CurrentTable
	if table == nil { return -1 }
	table_instance : ^ImGuiTableInstanceData = TableGetInstanceData(table, i32(table.InstanceCurrent))
	return cast(i32) table_instance.HoveredRowLast
}

TableSetBgColor :: proc(target : ImGuiTableBgTarget, color : ImU32, column_n : i32 = -1)
{
	g : ^ImGuiContext = GImGui
	table : ^ImGuiTable = g.CurrentTable
	IM_ASSERT(target != ImGuiTableBgTarget_.ImGuiTableBgTarget_None)

	color, column_n := color, column_n
	if color == IM_COL32_DISABLE { color = 0 }

	// We cannot draw neither the cell or row background immediately as we don't know the row height at this point in time.
	#partial switch target {
		case ImGuiTableBgTarget_.ImGuiTableBgTarget_CellBg:
			{
			if table.RowPosY1 > table.InnerClipRect.Max.y {
				// Discard
				return
			}
			if column_n == -1 { column_n = table.CurrentColumn }
			if !IM_BITARRAY_TESTBIT(table.VisibleMaskByIndex, cast(u32)column_n) { return }
			if table.RowCellDataCurrent < 0 || i32(table.RowCellData.Data[table.RowCellDataCurrent].Column) != column_n { post_incr(&table.RowCellDataCurrent) }
			cell_data : ^ImGuiTableCellData = &table.RowCellData.Data[table.RowCellDataCurrent]
			cell_data.BgColor = color
			cell_data.Column = cast(ImGuiTableColumnIdx) column_n
			break
			}
			fallthrough
		case ImGuiTableBgTarget_.ImGuiTableBgTarget_RowBg0:
			fallthrough
		case ImGuiTableBgTarget_.ImGuiTableBgTarget_RowBg1:
			{
			if table.RowPosY1 > table.InnerClipRect.Max.y {
				// Discard
				return
			}
			IM_ASSERT(column_n == -1)
			bg_idx : i32 = (target == ImGuiTableBgTarget_.ImGuiTableBgTarget_RowBg1) ? 1 : 0
			table.RowBgColor[bg_idx] = color
			break
			}
			fallthrough
		case:
			IM_ASSERT(false)
	}
}

//-------------------------------------------------------------------------
// [SECTION] Tables: Row changes
//-------------------------------------------------------------------------
// - TableGetRowIndex()
// - TableNextRow()
// - TableBeginRow() [Internal]
// - TableEndRow() [Internal]
//-------------------------------------------------------------------------

// [Public] Note: for row coloring we use ->RowBgColorCounter which is the same value without counting header rows
TableGetRowIndex :: proc() -> i32
{
	g : ^ImGuiContext = GImGui
	table : ^ImGuiTable = g.CurrentTable
	if table == nil { return 0 }
	return table.CurrentRow
}

// [Public] Starts into the first cell of a new row
TableNextRow :: proc(row_flags : ImGuiTableRowFlags = {}, row_min_height : f32 = 0)
{
	g : ^ImGuiContext = GImGui
	table : ^ImGuiTable = g.CurrentTable

	if !table.IsLayoutLocked { TableUpdateLayout(table) }
	if table.IsInsideRow { TableEndRow(table) }

	table.LastRowFlags = table.RowFlags
	table.RowFlags = row_flags
	table.RowCellPaddingY = g.Style.CellPadding.y
	table.RowMinHeight = row_min_height
	TableBeginRow(table)

	// We honor min_row_height requested by user, but cannot guarantee per-row maximum height,
	// because that would essentially require a unique clipping rectangle per-cell.
	table.RowPosY2 += table.RowCellPaddingY * 2.0
	table.RowPosY2 = ImMax(table.RowPosY2, table.RowPosY1 + row_min_height)

	// Disable output until user calls TableNextColumn()
	table.InnerWindow.SkipItems = true
}

// [Internal] Only called by TableNextRow()
TableBeginRow :: proc(table : ^ImGuiTable)
{
	window : ^ImGuiWindow = table.InnerWindow
	IM_ASSERT(!table.IsInsideRow)

	// New row
	post_incr(&table.CurrentRow)
	table.CurrentColumn = -1
	table.RowBgColor[1] = IM_COL32_DISABLE; table.RowBgColor[0] = table.RowBgColor[1]
	table.RowCellDataCurrent = -1
	table.IsInsideRow = true

	// Begin frozen rows
	next_y1 : f32 = table.RowPosY2
	if table.CurrentRow == 0 && table.FreezeRowsCount > 0 { window.DC.CursorPos.y = table.OuterRect.Min.y; next_y1 = window.DC.CursorPos.y }

	table.RowPosY2 = next_y1; table.RowPosY1 = table.RowPosY2
	table.RowTextBaseline = 0.0
	table.RowIndentOffsetX = window.DC.Indent.x - table.HostIndentX; // Lock indent

	window.DC.PrevLineTextBaseOffset = 0.0
	window.DC.CursorPosPrevLine = ImVec2{window.DC.CursorPos.x, window.DC.CursorPos.y + table.RowCellPaddingY}; // This allows users to call SameLine() to share LineSize between columns.
	window.DC.CurrLineSize = ImVec2{0.0, 0.0}; window.DC.PrevLineSize = window.DC.CurrLineSize; // This allows users to call SameLine() to share LineSize between columns, and to call it from first column too.
	window.DC.IsSetPos = false; window.DC.IsSameLine = window.DC.IsSetPos
	window.DC.CursorMaxPos.y = next_y1

	// Making the header BG color non-transparent will allow us to overlay it multiple times when handling smooth dragging.
	if (table.RowFlags & ImGuiTableRowFlags_.ImGuiTableRowFlags_Headers) != {} {
		TableSetBgColor(ImGuiTableBgTarget_.ImGuiTableBgTarget_RowBg0, GetColorU32(ImGuiCol_.ImGuiCol_TableHeaderBg))
		if table.CurrentRow == 0 { table.IsUsingHeaders = true }
	}
}

// [Internal] Called by TableNextRow()
TableEndRow :: proc(table : ^ImGuiTable)
{
	g : ^ImGuiContext = GImGui
	window : ^ImGuiWindow = g.CurrentWindow
	IM_ASSERT(window == table.InnerWindow)
	IM_ASSERT(table.IsInsideRow)

	if table.CurrentColumn != -1 { TableEndCell(table) }

	// Logging
	if g.LogEnabled { LogRenderedText(nil, "|") }

	// Position cursor at the bottom of our row so it can be used for e.g. clipping calculation. However it is
	// likely that the next call to TableBeginCell() will reposition the cursor to take account of vertical padding.
	window.DC.CursorPos.y = table.RowPosY2

	// Row background fill
	bg_y1 : f32 = table.RowPosY1
	bg_y2 : f32 = table.RowPosY2
	unfreeze_rows_actual : bool = (table.CurrentRow + 1 == cast(i32) table.FreezeRowsCount)
	unfreeze_rows_request : bool = (table.CurrentRow + 1 == cast(i32) table.FreezeRowsRequest)
	table_instance : ^ImGuiTableInstanceData = TableGetInstanceData(table, i32(table.InstanceCurrent))
	if (table.RowFlags & ImGuiTableRowFlags_.ImGuiTableRowFlags_Headers) != {} && (table.CurrentRow == 0 || (table.LastRowFlags & ImGuiTableRowFlags_.ImGuiTableRowFlags_Headers) != {}) { table_instance.LastTopHeadersRowHeight += bg_y2 - bg_y1 }

	is_visible : bool = (bg_y2 >= table.InnerClipRect.Min.y && bg_y1 <= table.InnerClipRect.Max.y)
	if is_visible {
		// Update data for TableGetHoveredRow()
		if table.HoveredColumnBody != -1 && g.IO.MousePos.y >= bg_y1 && g.IO.MousePos.y < bg_y2 && table_instance.HoveredRowNext < 0 { table_instance.HoveredRowNext = table.CurrentRow }

		// Decide of background color for the row
		bg_col0 : ImU32 = 0
		bg_col1 : ImU32 = 0
		if table.RowBgColor[0] != IM_COL32_DISABLE { bg_col0 = table.RowBgColor[0] }
		else if (table.Flags & ImGuiTableFlags_.ImGuiTableFlags_RowBg) != {} { bg_col0 = GetColorU32((table.RowBgColorCounter & 1) != 0 ? ImGuiCol_.ImGuiCol_TableRowBgAlt : ImGuiCol_.ImGuiCol_TableRowBg) }
		if table.RowBgColor[1] != IM_COL32_DISABLE { bg_col1 = table.RowBgColor[1] }

		// Decide of top border color
		top_border_col : ImU32 = 0
		border_size : f32 = TABLE_BORDER_SIZE
		if table.CurrentRow > 0 && (table.Flags & ImGuiTableFlags_.ImGuiTableFlags_BordersInnerH) != {} { top_border_col = (table.LastRowFlags & ImGuiTableRowFlags_.ImGuiTableRowFlags_Headers) != {} ? table.BorderColorStrong : table.BorderColorLight }

		draw_cell_bg_color : bool = table.RowCellDataCurrent >= 0
		draw_strong_bottom_border : bool = unfreeze_rows_actual
		if (bg_col0 | bg_col1 | top_border_col) != 0 || draw_strong_bottom_border || draw_cell_bg_color {
			// In theory we could call SetWindowClipRectBeforeSetChannel() but since we know TableEndRow() is
			// always followed by a change of clipping rectangle we perform the smallest overwrite possible here.
			if (table.Flags & ImGuiTableFlags_.ImGuiTableFlags_NoClip) == {} { window.DrawList._CmdHeader.ClipRect = ToVec4(table.Bg0ClipRectForDrawCmd) }
			SetCurrentChannel(table.DrawSplitter, window.DrawList, TABLE_DRAW_CHANNEL_BG0)
		}

		// Draw row background
		// We soft/cpu clip this so all backgrounds and borders can share the same clipping rectangle
		if bg_col0 != 0 || bg_col1 != 0 {
			row_rect : ImRect; init(&row_rect, table.WorkRect.Min.x, bg_y1, table.WorkRect.Max.x, bg_y2)
			ClipWith(&row_rect, table.BgClipRect)
			if bg_col0 != 0 && row_rect.Min.y < row_rect.Max.y { AddRectFilled(window.DrawList, row_rect.Min, row_rect.Max, bg_col0) }
			if bg_col1 != 0 && row_rect.Min.y < row_rect.Max.y { AddRectFilled(window.DrawList, row_rect.Min, row_rect.Max, bg_col1) }
		}

		// Draw cell background color
		if draw_cell_bg_color {
			cell_data_end := table.RowCellData.Data[table.RowCellDataCurrent:]
			for cell_data := table.RowCellData.Data; cell_data <= cell_data_end; cell_data = cell_data[1:] {
				// As we render the BG here we need to clip things (for layout we would not)
				// FIXME: This cancels the OuterPadding addition done by TableGetCellBgRect(), need to keep it while rendering correctly while scrolling.
				column : ^ImGuiTableColumn = &table.Columns.Data[cell_data[0].Column]
				cell_bg_rect : ImRect = TableGetCellBgRect(table, i32(cell_data[0].Column))
				ClipWith(&cell_bg_rect, table.BgClipRect)
				cell_bg_rect.Min.x = ImMax(cell_bg_rect.Min.x, column.ClipRect.Min.x); // So that first column after frozen one gets clipped when scrolling
				cell_bg_rect.Max.x = ImMin(cell_bg_rect.Max.x, column.MaxX)
				if cell_bg_rect.Min.y < cell_bg_rect.Max.y { AddRectFilled(window.DrawList, cell_bg_rect.Min, cell_bg_rect.Max, cell_data[0].BgColor) }
			}
		}

		// Draw top border
		if top_border_col != 0 && bg_y1 >= table.BgClipRect.Min.y && bg_y1 < table.BgClipRect.Max.y {
			AddLine(window.DrawList, ImVec2{table.BorderX1, bg_y1}, ImVec2{table.BorderX2, bg_y1}, top_border_col, border_size)
		}

		// Draw bottom border at the row unfreezing mark (always strong)
		if draw_strong_bottom_border && bg_y2 >= table.BgClipRect.Min.y && bg_y2 < table.BgClipRect.Max.y { AddLine(window.DrawList, ImVec2{table.BorderX1, bg_y2}, ImVec2{table.BorderX2, bg_y2}, table.BorderColorStrong, border_size) }
	}

	// End frozen rows (when we are past the last frozen row line, teleport cursor and alter clipping rectangle)
	// We need to do that in TableEndRow() instead of TableBeginRow() so the list clipper can mark end of row and
	// get the new cursor position.
	if unfreeze_rows_request {
		for column_n : i32 = 0; column_n < table.ColumnsCount; column_n += 1 { table.Columns.Data[column_n].NavLayerCurrent = cast(i8)ImGuiNavLayer.ImGuiNavLayer_Main }

		y0 : f32 = ImMax(table.RowPosY2 + 1, table.InnerClipRect.Min.y)
		table_instance.LastFrozenHeight = y0 - table.OuterRect.Min.y

		if unfreeze_rows_actual {
			IM_ASSERT(table.IsUnfrozenRows == false)
			table.IsUnfrozenRows = true

			// BgClipRect starts as table->InnerClipRect, reduce it now and make BgClipRectForDrawCmd == BgClipRect
			table.Bg2ClipRectForDrawCmd.Min.y = ImMin(y0, table.InnerClipRect.Max.y); table.BgClipRect.Min.y = table.Bg2ClipRectForDrawCmd.Min.y
			table.Bg2ClipRectForDrawCmd.Max.y = table.InnerClipRect.Max.y; table.BgClipRect.Max.y = table.Bg2ClipRectForDrawCmd.Max.y
			table.Bg2DrawChannelCurrent = table.Bg2DrawChannelUnfrozen
			IM_ASSERT(table.Bg2ClipRectForDrawCmd.Min.y <= table.Bg2ClipRectForDrawCmd.Max.y)

			row_height : f32 = table.RowPosY2 - table.RowPosY1
			window.DC.CursorPos.y = table.WorkRect.Min.y + table.RowPosY2 - table.OuterRect.Min.y; table.RowPosY2 = window.DC.CursorPos.y
			table.RowPosY1 = table.RowPosY2 - row_height
			for column_n : i32 = 0; column_n < table.ColumnsCount; column_n += 1 {
				column : ^ImGuiTableColumn = &table.Columns.Data[column_n]
				column.DrawChannelCurrent = column.DrawChannelUnfrozen
				column.ClipRect.Min.y = table.Bg2ClipRectForDrawCmd.Min.y
			}

			// Update cliprect ahead of TableBeginCell() so clipper can access to new ClipRect->Min.y
			SetWindowClipRectBeforeSetChannel(window, table.Columns.Data[0].ClipRect)
			SetCurrentChannel(table.DrawSplitter, window.DrawList, i32(table.Columns.Data[0].DrawChannelCurrent))
		}
	}

	if (table.RowFlags & ImGuiTableRowFlags_.ImGuiTableRowFlags_Headers) == {} { post_incr(&table.RowBgColorCounter) }
	table.IsInsideRow = false
}

//-------------------------------------------------------------------------
// [SECTION] Tables: Columns changes
//-------------------------------------------------------------------------
// - TableGetColumnIndex()
// - TableSetColumnIndex()
// - TableNextColumn()
// - TableBeginCell() [Internal]
// - TableEndCell() [Internal]
//-------------------------------------------------------------------------

TableGetColumnIndex :: proc() -> i32
{
	g : ^ImGuiContext = GImGui
	table : ^ImGuiTable = g.CurrentTable
	if table == nil { return 0 }
	return table.CurrentColumn
}

// [Public] Append into a specific column
TableSetColumnIndex :: proc(column_n : i32) -> bool
{
	g : ^ImGuiContext = GImGui
	table : ^ImGuiTable = g.CurrentTable
	if table == nil { return false }

	if table.CurrentColumn != column_n {
		if table.CurrentColumn != -1 { TableEndCell(table) }
		IM_ASSERT(column_n >= 0 && table.ColumnsCount != 0)
		TableBeginCell(table, column_n)
	}

	// Return whether the column is visible. User may choose to skip submitting items based on this return value,
	// however they shouldn't skip submitting for columns that may have the tallest contribution to row height.
	return table.Columns.Data[column_n].IsRequestOutput
}

// [Public] Append into the next column, wrap and create a new row when already on last column
TableNextColumn :: proc() -> bool
{
	g : ^ImGuiContext = GImGui
	table : ^ImGuiTable = g.CurrentTable
	if table == nil { return false }

	if table.IsInsideRow && table.CurrentColumn + 1 < table.ColumnsCount {
		if table.CurrentColumn != -1 { TableEndCell(table) }
		TableBeginCell(table, table.CurrentColumn + 1)
	}
	else {
		TableNextRow()
		TableBeginCell(table, 0)
	}

	// Return whether the column is visible. User may choose to skip submitting items based on this return value,
	// however they shouldn't skip submitting for columns that may have the tallest contribution to row height.
	return table.Columns.Data[table.CurrentColumn].IsRequestOutput
}


// [Internal] Called by TableSetColumnIndex()/TableNextColumn()
// This is called very frequently, so we need to be mindful of unnecessary overhead.
// FIXME-TABLE FIXME-OPT: Could probably shortcut some things for non-active or clipped columns.
TableBeginCell :: proc(table : ^ImGuiTable, column_n : i32)
{
	g : ^ImGuiContext = GImGui
	column : ^ImGuiTableColumn = &table.Columns.Data[column_n]
	window : ^ImGuiWindow = table.InnerWindow
	table.CurrentColumn = column_n

	// Start position is roughly ~~ CellRect.Min + CellPadding + Indent
	start_x : f32 = column.WorkMinX
	if (column.Flags & ImGuiTableColumnFlags_.ImGuiTableColumnFlags_IndentEnable) != {} {
		// ~~ += window.DC.Indent.x - table->HostIndentX, except we locked it for the row.
		start_x += table.RowIndentOffsetX
	}

	window.DC.CursorPos.x = start_x
	window.DC.CursorPos.y = table.RowPosY1 + table.RowCellPaddingY
	window.DC.CursorMaxPos.x = window.DC.CursorPos.x
	window.DC.ColumnsOffset.x = start_x - window.Pos.x - window.DC.Indent.x; // FIXME-WORKRECT
	window.DC.CursorPosPrevLine.x = window.DC.CursorPos.x; // PrevLine.y is preserved. This allows users to call SameLine() to share LineSize between columns.
	window.DC.CurrLineTextBaseOffset = table.RowTextBaseline
	window.DC.NavLayerCurrent = cast(ImGuiNavLayer) column.NavLayerCurrent

	// Note how WorkRect.Max.y is only set once during layout
	window.WorkRect.Min.y = window.DC.CursorPos.y
	window.WorkRect.Min.x = column.WorkMinX
	window.WorkRect.Max.x = column.WorkMaxX
	window.DC.ItemWidth = column.ItemWidth

	window.SkipItems = column.IsSkipItems
	if column.IsSkipItems {
		g.LastItemData.ID = 0
		g.LastItemData.StatusFlags = {}
	}

	if (table.Flags & ImGuiTableFlags_.ImGuiTableFlags_NoClip) != {} {
		// FIXME: if we end up drawing all borders/bg in EndTable, could remove this and just assert that channel hasn't changed.
		SetCurrentChannel(table.DrawSplitter, window.DrawList, TABLE_DRAW_CHANNEL_NOCLIP)
		//IM_ASSERT(table->DrawSplitter._Current == TABLE_DRAW_CHANNEL_NOCLIP);
	}
	else {
		// FIXME-TABLE: Could avoid this if draw channel is dummy channel?
		SetWindowClipRectBeforeSetChannel(window, column.ClipRect)
		SetCurrentChannel(table.DrawSplitter, window.DrawList, i32(column.DrawChannelCurrent))
	}

	// Logging
	if g.LogEnabled && !column.IsSkipItems {
		LogRenderedText(&window.DC.CursorPos, "|")
		g.LogLinePosY = FLT_MAX
	}
}

// [Internal] Called by TableNextRow()/TableSetColumnIndex()/TableNextColumn()
TableEndCell :: proc(table : ^ImGuiTable)
{
	column : ^ImGuiTableColumn = &table.Columns.Data[table.CurrentColumn]
	window : ^ImGuiWindow = table.InnerWindow

	if window.DC.IsSetPos { ErrorCheckUsingSetCursorPosToExtendParentBoundaries() }

	// Report maximum position so we can infer content size per column.
	p_max_pos_x : ^f32
	if (table.RowFlags & ImGuiTableRowFlags_.ImGuiTableRowFlags_Headers) != {} {
		// Useful in case user submit contents in header row that is not a TableHeader() call
		p_max_pos_x = &column.ContentMaxXHeadersUsed
	}
	else { p_max_pos_x = table.IsUnfrozenRows ? &column.ContentMaxXUnfrozen : &column.ContentMaxXFrozen }
	p_max_pos_x^ = ImMax(p_max_pos_x^, window.DC.CursorMaxPos.x)
	if column.IsEnabled { table.RowPosY2 = ImMax(table.RowPosY2, window.DC.CursorMaxPos.y + table.RowCellPaddingY) }
	column.ItemWidth = window.DC.ItemWidth

	// Propagate text baseline for the entire row
	// FIXME-TABLE: Here we propagate text baseline from the last line of the cell.. instead of the first one.
	table.RowTextBaseline = ImMax(table.RowTextBaseline, window.DC.PrevLineTextBaseOffset)
}

//-------------------------------------------------------------------------
// [SECTION] Tables: Columns width management
//-------------------------------------------------------------------------
// - TableGetMaxColumnWidth() [Internal]
// - TableGetColumnWidthAuto() [Internal]
// - TableSetColumnWidth()
// - TableSetColumnWidthAutoSingle() [Internal]
// - TableSetColumnWidthAutoAll() [Internal]
// - TableUpdateColumnsWeightFromWidth() [Internal]
//-------------------------------------------------------------------------
// Note that actual columns widths are computed in TableUpdateLayout().
//-------------------------------------------------------------------------

// Maximum column content width given current layout. Use column->MinX so this value differs on a per-column basis.
TableCalcMaxColumnWidth :: proc(table : ^ImGuiTable, column_n : i32) -> f32
{
	column : ^ImGuiTableColumn = &table.Columns.Data[column_n]
	max_width : f32 = FLT_MAX
	min_column_distance : f32 = table.MinColumnWidth + table.CellPaddingX * 2.0 + table.CellSpacingX1 + table.CellSpacingX2
	if (table.Flags & ImGuiTableFlags_.ImGuiTableFlags_ScrollX) != {} {
		// Frozen columns can't reach beyond visible width else scrolling will naturally break.
		// (we use DisplayOrder as within a set of multiple frozen column reordering is possible)
		if column.DisplayOrder < table.FreezeColumnsRequest {
			max_width = (table.InnerClipRect.Max.x - (f32(table.FreezeColumnsRequest - column.DisplayOrder)) * min_column_distance) - column.MinX
			max_width = max_width - table.OuterPaddingX - table.CellPaddingX - table.CellSpacingX2
		}
	}
	else if (table.Flags & ImGuiTableFlags_.ImGuiTableFlags_NoKeepColumnsVisible) == {} {
		// If horizontal scrolling if disabled, we apply a final lossless shrinking of columns in order to make
		// sure they are all visible. Because of this we also know that all of the columns will always fit in
		// table->WorkRect and therefore in table->InnerRect (because ScrollX is off)
		// FIXME-TABLE: This is solved incorrectly but also quite a difficult problem to fix as we also want ClipRect width to match.
		// See "table_width_distrib" and "table_width_keep_visible" tests
		max_width = table.WorkRect.Max.x - (f32(table.ColumnsEnabledCount - column.IndexWithinEnabledSet) - 1) * min_column_distance - column.MinX
		//max_width -= table->CellSpacingX1;
		max_width -= table.CellSpacingX2
		max_width -= table.CellPaddingX * 2.0
		max_width -= table.OuterPaddingX
	}
	return max_width
}

// Note this is meant to be stored in column->WidthAuto, please generally use the WidthAuto field
TableGetColumnWidthAuto :: proc(table : ^ImGuiTable, column : ^ImGuiTableColumn) -> f32
{
	content_width_body : f32 = ImMax(column.ContentMaxXFrozen, column.ContentMaxXUnfrozen) - column.WorkMinX
	content_width_headers : f32 = column.ContentMaxXHeadersIdeal - column.WorkMinX
	width_auto : f32 = content_width_body
	if (column.Flags & ImGuiTableColumnFlags_.ImGuiTableColumnFlags_NoHeaderWidth) == {} { width_auto = ImMax(width_auto, content_width_headers) }

	// Non-resizable fixed columns preserve their requested width
	if (column.Flags & ImGuiTableColumnFlags_.ImGuiTableColumnFlags_WidthFixed) != {} && column.InitStretchWeightOrWidth > 0.0 { if (table.Flags & ImGuiTableFlags_.ImGuiTableFlags_Resizable) == {} || (column.Flags & ImGuiTableColumnFlags_.ImGuiTableColumnFlags_NoResize) != {} { width_auto = column.InitStretchWeightOrWidth } }

	return ImMax(width_auto, table.MinColumnWidth)
}

// 'width' = inner column width, without padding
TableSetColumnWidth :: proc(column_n : i32, width : f32)
{
	g : ^ImGuiContext = GImGui
	table : ^ImGuiTable = g.CurrentTable
	IM_ASSERT(table != nil && table.IsLayoutLocked == false)
	IM_ASSERT(column_n >= 0 && column_n < table.ColumnsCount)
	column_0 : ^ImGuiTableColumn = &table.Columns.Data[column_n]
	column_0_width : f32 = width

	// Apply constraints early
	// Compare both requested and actual given width to avoid overwriting requested width when column is stuck (minimum size, bounded)
	IM_ASSERT(table.MinColumnWidth > 0.0)
	min_width : f32 = table.MinColumnWidth
	max_width : f32 = ImMax(min_width, column_0.WidthMax); // Don't use TableCalcMaxColumnWidth() here as it would rely on MinX from last instance (#7933)
	column_0_width = ImClamp(column_0_width, min_width, max_width)
	if column_0.WidthGiven == column_0_width || column_0.WidthRequest == column_0_width { return }

	//IMGUI_DEBUG_PRINT("TableSetColumnWidth(%d, %.1f->%.1f)\n", column_0_idx, column_0->WidthGiven, column_0_width);
	column_1 : ^ImGuiTableColumn = (column_0.NextEnabledColumn != -1) ? &table.Columns.Data[column_0.NextEnabledColumn] : nil

	// In this surprisingly not simple because of how we support mixing Fixed and multiple Stretch columns.
	// - All fixed: easy.
	// - All stretch: easy.
	// - One or more fixed + one stretch: easy.
	// - One or more fixed + more than one stretch: tricky.
	// Qt when manual resize is enabled only supports a single _trailing_ stretch column, we support more cases here.

	// When forwarding resize from Wn| to Fn+1| we need to be considerate of the _NoResize flag on Fn+1.
	// FIXME-TABLE: Find a way to rewrite all of this so interactions feel more consistent for the user.
	// Scenarios:
	// - F1 F2 F3  resize from F1| or F2|   --> ok: alter ->WidthRequested of Fixed column. Subsequent columns will be offset.
	// - F1 F2 F3  resize from F3|          --> ok: alter ->WidthRequested of Fixed column. If active, ScrollX extent can be altered.
	// - F1 F2 W3  resize from F1| or F2|   --> ok: alter ->WidthRequested of Fixed column. If active, ScrollX extent can be altered, but it doesn't make much sense as the Stretch column will always be minimal size.
	// - F1 F2 W3  resize from W3|          --> ok: no-op (disabled by Resize Rule 1)
	// - W1 W2 W3  resize from W1| or W2|   --> ok
	// - W1 W2 W3  resize from W3|          --> ok: no-op (disabled by Resize Rule 1)
	// - W1 F2 F3  resize from F3|          --> ok: no-op (disabled by Resize Rule 1)
	// - W1 F2     resize from F2|          --> ok: no-op (disabled by Resize Rule 1)
	// - W1 W2 F3  resize from W1| or W2|   --> ok
	// - W1 F2 W3  resize from W1| or F2|   --> ok
	// - F1 W2 F3  resize from W2|          --> ok
	// - F1 W3 F2  resize from W3|          --> ok
	// - W1 F2 F3  resize from W1|          --> ok: equivalent to resizing |F2. F3 will not move.
	// - W1 F2 F3  resize from F2|          --> ok
	// All resizes from a Wx columns are locking other columns.

	// Possible improvements:
	// - W1 W2 W3  resize W1|               --> to not be stuck, both W2 and W3 would stretch down. Seems possible to fix. Would be most beneficial to simplify resize of all-weighted columns.
	// - W3 F1 F2  resize W3|               --> to not be stuck past F1|, both F1 and F2 would need to stretch down, which would be lossy or ambiguous. Seems hard to fix.

	// [Resize Rule 1] Can't resize from right of right-most visible column if there is any Stretch column. Implemented in TableUpdateLayout().

	// If we have all Fixed columns OR resizing a Fixed column that doesn't come after a Stretch one, we can do an offsetting resize.
	// This is the preferred resize path
	if (column_0.Flags & ImGuiTableColumnFlags_.ImGuiTableColumnFlags_WidthFixed) != {} { if column_1 == nil || table.LeftMostStretchedColumn == -1 || table.Columns.Data[table.LeftMostStretchedColumn].DisplayOrder >= column_0.DisplayOrder {
	column_0.WidthRequest = column_0_width
	table.IsSettingsDirty = true
	return
} }

	// We can also use previous column if there's no next one (this is used when doing an auto-fit on the right-most stretch column)
	if column_1 == nil { column_1 = (column_0.PrevEnabledColumn != -1) ? &table.Columns.Data[column_0.PrevEnabledColumn] : nil }
	if column_1 == nil { return }

	// Resizing from right-side of a Stretch column before a Fixed column forward sizing to left-side of fixed column.
	// (old_a + old_b == new_a + new_b) --> (new_a == old_a + old_b - new_b)
	column_1_width : f32 = ImMax(column_1.WidthRequest - (column_0_width - column_0.WidthRequest), min_width)
	column_0_width = column_0.WidthRequest + column_1.WidthRequest - column_1_width
	IM_ASSERT(column_0_width > 0.0 && column_1_width > 0.0)
	column_0.WidthRequest = column_0_width
	column_1.WidthRequest = column_1_width
	if ((column_0.Flags | column_1.Flags) & ImGuiTableColumnFlags_.ImGuiTableColumnFlags_WidthStretch) != {} { TableUpdateColumnsWeightFromWidth(table) }
	table.IsSettingsDirty = true
}

// Disable clipping then auto-fit, will take 2 frames
// (we don't take a shortcut for unclipped columns to reduce inconsistencies when e.g. resizing multiple columns)
TableSetColumnWidthAutoSingle :: proc(table : ^ImGuiTable, column_n : i32)
{
	// Single auto width uses auto-fit
	column : ^ImGuiTableColumn = &table.Columns.Data[column_n]
	if !column.IsEnabled { return }
	column.CannotSkipItemsQueue = (1 << 0)
	table.AutoFitSingleColumn = cast(ImGuiTableColumnIdx) column_n
}

TableSetColumnWidthAutoAll :: proc(table : ^ImGuiTable)
{
	for column_n : i32 = 0; column_n < table.ColumnsCount; column_n += 1 {
		column : ^ImGuiTableColumn = &table.Columns.Data[column_n]
		if !column.IsEnabled && (column.Flags & ImGuiTableColumnFlags_.ImGuiTableColumnFlags_WidthStretch) == {} {
			// Cannot reset weight of hidden stretch column
			continue
		}
		column.CannotSkipItemsQueue = (1 << 0)
		column.AutoFitQueue = (1 << 1)
	}
}

TableUpdateColumnsWeightFromWidth :: proc(table : ^ImGuiTable)
{
	IM_ASSERT(table.LeftMostStretchedColumn != -1 && table.RightMostStretchedColumn != -1)

	// Measure existing quantities
	visible_weight : f32 = 0.0
	visible_width : f32 = 0.0
	for column_n : i32 = 0; column_n < table.ColumnsCount; column_n += 1 {
		column : ^ImGuiTableColumn = &table.Columns.Data[column_n]
		if !column.IsEnabled || (column.Flags & ImGuiTableColumnFlags_.ImGuiTableColumnFlags_WidthStretch) == {} { continue }
		IM_ASSERT(column.StretchWeight > 0.0)
		visible_weight += column.StretchWeight
		visible_width += column.WidthRequest
	}

	IM_ASSERT(visible_weight > 0.0 && visible_width > 0.0)

	// Apply new weights
	for column_n : i32 = 0; column_n < table.ColumnsCount; column_n += 1 {
		column : ^ImGuiTableColumn = &table.Columns.Data[column_n]
		if !column.IsEnabled || (column.Flags & ImGuiTableColumnFlags_.ImGuiTableColumnFlags_WidthStretch) == {} { continue }
		column.StretchWeight = (column.WidthRequest / visible_width) * visible_weight
		IM_ASSERT(column.StretchWeight > 0.0)
	}
}

//-------------------------------------------------------------------------
// [SECTION] Tables: Drawing
//-------------------------------------------------------------------------
// - TablePushBackgroundChannel() [Internal]
// - TablePopBackgroundChannel() [Internal]
// - TableSetupDrawChannels() [Internal]
// - TableMergeDrawChannels() [Internal]
// - TableGetColumnBorderCol() [Internal]
// - TableDrawBorders() [Internal]
//-------------------------------------------------------------------------

// Bg2 is used by Selectable (and possibly other widgets) to render to the background.
// Unlike our Bg0/1 channel which we uses for RowBg/CellBg/Borders and where we guarantee all shapes to be CPU-clipped, the Bg2 channel being widgets-facing will rely on regular ClipRect.
TablePushBackgroundChannel :: proc()
{
	g : ^ImGuiContext = GImGui
	window : ^ImGuiWindow = g.CurrentWindow
	table : ^ImGuiTable = g.CurrentTable

	// Optimization: avoid SetCurrentChannel() + PushClipRect()
	table.HostBackupInnerClipRect = window.ClipRect
	SetWindowClipRectBeforeSetChannel(window, table.Bg2ClipRectForDrawCmd)
	SetCurrentChannel(table.DrawSplitter, window.DrawList, i32(table.Bg2DrawChannelCurrent))
}

TablePopBackgroundChannel :: proc()
{
	g : ^ImGuiContext = GImGui
	window : ^ImGuiWindow = g.CurrentWindow
	table : ^ImGuiTable = g.CurrentTable
	column : ^ImGuiTableColumn = &table.Columns.Data[table.CurrentColumn]

	// Optimization: avoid PopClipRect() + SetCurrentChannel()
	SetWindowClipRectBeforeSetChannel(window, table.HostBackupInnerClipRect)
	SetCurrentChannel(table.DrawSplitter, window.DrawList, i32(column.DrawChannelCurrent))
}

// Allocate draw channels. Called by TableUpdateLayout()
// - We allocate them following storage order instead of display order so reordering columns won't needlessly
//   increase overall dormant memory cost.
// - We isolate headers draw commands in their own channels instead of just altering clip rects.
//   This is in order to facilitate merging of draw commands.
// - After crossing FreezeRowsCount, all columns see their current draw channel changed to a second set of channels.
// - We only use the dummy draw channel so we can push a null clipping rectangle into it without affecting other
//   channels, while simplifying per-row/per-cell overhead. It will be empty and discarded when merged.
// - We allocate 1 or 2 background draw channels. This is because we know TablePushBackgroundChannel() is only used for
//   horizontal spanning. If we allowed vertical spanning we'd need one background draw channel per merge group (1-4).
// Draw channel allocation (before merging):
// - NoClip                       --> 2+D+1 channels: bg0/1 + bg2 + foreground (same clip rect == always 1 draw call)
// - Clip                         --> 2+D+N channels
// - FreezeRows                   --> 2+D+N*2 (unless scrolling value is zero)
// - FreezeRows || FreezeColunns  --> 3+D+N*2 (unless scrolling value is zero)
// Where D is 1 if any column is clipped or hidden (dummy channel) otherwise 0.
TableSetupDrawChannels :: proc(table : ^ImGuiTable)
{
	freeze_row_multiplier : i32 = (table.FreezeRowsCount > 0) ? 2 : 1
	channels_for_row : i32 = (table.Flags & ImGuiTableFlags_.ImGuiTableFlags_NoClip) != {} ? 1 : i32(table.ColumnsEnabledCount)
	channels_for_bg : i32 = 1 + 1 * freeze_row_multiplier
	channels_for_dummy : i32 = (i32(table.ColumnsEnabledCount) < table.ColumnsCount || (memcmp(table.VisibleMaskByIndex, table.EnabledMaskByIndex, ImBitArrayGetStorageSizeInBytes(table.ColumnsCount)) != 0)) ? +1 : 0
	channels_total : i32 = channels_for_bg + (channels_for_row * freeze_row_multiplier) + channels_for_dummy
	Split(table.DrawSplitter, table.InnerWindow.DrawList, channels_total)
	table.DummyDrawChannel = cast(ImGuiTableDrawChannelIdx) ((channels_for_dummy > 0) ? channels_total - 1 : -1)
	table.Bg2DrawChannelCurrent = u16(TABLE_DRAW_CHANNEL_BG2_FROZEN)
	table.Bg2DrawChannelUnfrozen = cast(ImGuiTableDrawChannelIdx) ((table.FreezeRowsCount > 0) ? 2 + channels_for_row : TABLE_DRAW_CHANNEL_BG2_FROZEN)

	draw_channel_current : i32 = 2
	for column_n : i32 = 0; column_n < table.ColumnsCount; column_n += 1 {
		column : ^ImGuiTableColumn = &table.Columns.Data[column_n]
		if column.IsVisibleX && column.IsVisibleY {
			column.DrawChannelFrozen = cast(ImGuiTableDrawChannelIdx) (draw_channel_current)
			column.DrawChannelUnfrozen = cast(ImGuiTableDrawChannelIdx) (draw_channel_current + (table.FreezeRowsCount > 0 ? channels_for_row + 1 : 0))
			if (table.Flags & ImGuiTableFlags_.ImGuiTableFlags_NoClip) == {} { post_incr(&draw_channel_current) }
		}
		else {
			column.DrawChannelUnfrozen = table.DummyDrawChannel; column.DrawChannelFrozen = column.DrawChannelUnfrozen
		}
		column.DrawChannelCurrent = column.DrawChannelFrozen
	}

	// Initial draw cmd starts with a BgClipRect that matches the one of its host, to facilitate merge draw commands by default.
	// All our cell highlight are manually clipped with BgClipRect. When unfreezing it will be made smaller to fit scrolling rect.
	// (This technically isn't part of setting up draw channels, but is reasonably related to be done here)
	table.BgClipRect = table.InnerClipRect
	table.Bg0ClipRectForDrawCmd = table.OuterWindow.ClipRect
	table.Bg2ClipRectForDrawCmd = table.HostClipRect
	IM_ASSERT(table.BgClipRect.Min.y <= table.BgClipRect.Max.y)
}

// This function reorder draw channels based on matching clip rectangle, to facilitate merging them. Called by EndTable().
// For simplicity we call it TableMergeDrawChannels() but in fact it only reorder channels + overwrite ClipRect,
// actual merging is done by table->DrawSplitter.Merge() which is called right after TableMergeDrawChannels().
//
// Columns where the contents didn't stray off their local clip rectangle can be merged. To achieve
// this we merge their clip rect and make them contiguous in the channel list, so they can be merged
// by the call to DrawSplitter.Merge() following to the call to this function.
// We reorder draw commands by arranging them into a maximum of 4 distinct groups:
//
//   1 group:               2 groups:              2 groups:              4 groups:
//   [ 0. ] no freeze       [ 0. ] row freeze      [ 01 ] col freeze      [ 01 ] row+col freeze
//   [ .. ]  or no scroll   [ 2. ]  and v-scroll   [ .. ]  and h-scroll   [ 23 ]  and v+h-scroll
//
// Each column itself can use 1 channel (row freeze disabled) or 2 channels (row freeze enabled).
// When the contents of a column didn't stray off its limit, we move its channels into the corresponding group
// based on its position (within frozen rows/columns groups or not).
// At the end of the operation our 1-4 groups will each have a ImDrawCmd using the same ClipRect.
// This function assume that each column are pointing to a distinct draw channel,
// otherwise merge_group->ChannelsCount will not match set bit count of merge_group->ChannelsMask.
//
// Column channels will not be merged into one of the 1-4 groups in the following cases:
// - The contents stray off its clipping rectangle (we only compare the MaxX value, not the MinX value).
//   Direct ImDrawList calls won't be taken into account by default, if you use them make sure the ImGui:: bounds
//   matches, by e.g. calling SetCursorScreenPos().
// - The channel uses more than one draw command itself. We drop all our attempt at merging stuff here..
//   we could do better but it's going to be rare and probably not worth the hassle.
// Columns for which the draw channel(s) haven't been merged with other will use their own ImDrawCmd.
//
// This function is particularly tricky to understand.. take a breath.
TableMergeDrawChannels :: proc(table : ^ImGuiTable)
{
	g : ^ImGuiContext = GImGui
	splitter : ^ImDrawListSplitter = table.DrawSplitter
	has_freeze_v : bool = (table.FreezeRowsCount > 0)
	has_freeze_h : bool = (table.FreezeColumnsCount > 0)
	IM_ASSERT(splitter._Current == 0)

	// Track which groups we are going to attempt to merge, and which channels goes into each group.
	MergeGroup :: struct {
		ClipRect : ImRect,
		ChannelsCount : i32,
		ChannelsMask : ImBitArrayPtr,
	}

	merge_group_mask : i32 = 0x00
	merge_groups : [4]MergeGroup

	// Use a reusable temp buffer for the merge masks as they are dynamically sized.
	max_draw_channels : i32 = (4 + table.ColumnsCount * 2)
	size_for_masks_bitarrays_one : i32 = cast(i32) ImBitArrayGetStorageSizeInBytes(max_draw_channels)
	reserve(&g.TempBuffer, size_for_masks_bitarrays_one * 5)
	memset(g.TempBuffer.Data, 0, int(size_for_masks_bitarrays_one * 5))
	for n : i32 = 0; n < cast(i32)IM_ARRAYSIZE(merge_groups); n += 1 { merge_groups[n].ChannelsMask = cast(ImBitArrayPtr) g.TempBuffer.Data[size_for_masks_bitarrays_one * n:] }

	remaining_mask : ImBitArrayPtr = cast(ImBitArrayPtr) g.TempBuffer.Data[size_for_masks_bitarrays_one * 4:]

	// 1. Scan channels and take note of those which can be merged
	for column_n : i32 = 0; column_n < table.ColumnsCount; column_n += 1 {
		if !IM_BITARRAY_TESTBIT(table.VisibleMaskByIndex, column_n) { continue }
		column : ^ImGuiTableColumn = &table.Columns.Data[column_n]

		merge_group_sub_count : i32 = has_freeze_v ? 2 : 1
		for merge_group_sub_n : i32 = 0; merge_group_sub_n < merge_group_sub_count; merge_group_sub_n += 1 {
			channel_no : i32 = i32((merge_group_sub_n == 0) ? column.DrawChannelFrozen : column.DrawChannelUnfrozen)

			// Don't attempt to merge if there are multiple draw calls within the column
			src_channel : ^ImDrawChannel = &splitter._Channels.Data[channel_no]
			if src_channel._CmdBuffer.Size > 0 && back(&src_channel._CmdBuffer).ElemCount == 0 && back(&src_channel._CmdBuffer).UserCallback == nil {
				// Equivalent of PopUnusedDrawCmd()
				pop_back(&src_channel._CmdBuffer)
			}
			if src_channel._CmdBuffer.Size != 1 { continue }

			// Find out the width of this merge group and check if it will fit in our column
			// (note that we assume that rendering didn't stray on the left direction. we should need a CursorMinPos to detect it)
			if (column.Flags & ImGuiTableColumnFlags_.ImGuiTableColumnFlags_NoClip) == {} {
				content_max_x : f32
				if !has_freeze_v {
					// No row freeze
					content_max_x = ImMax(column.ContentMaxXUnfrozen, column.ContentMaxXHeadersUsed)
				}
				else if merge_group_sub_n == 0 {
					// Row freeze: use width before freeze
					content_max_x = ImMax(column.ContentMaxXFrozen, column.ContentMaxXHeadersUsed)
				}
				else {
					// Row freeze: use width after freeze
					content_max_x = column.ContentMaxXUnfrozen
				}
				if content_max_x > column.ClipRect.Max.x { continue }
			}

			merge_group_n : i32 = (has_freeze_h && column_n < i32(table.FreezeColumnsCount) ? 0 : 1) + (has_freeze_v && merge_group_sub_n == 0 ? 0 : 2)
			IM_ASSERT(channel_no < max_draw_channels)
			merge_group : ^MergeGroup = &merge_groups[merge_group_n]
			if merge_group.ChannelsCount == 0 { merge_group.ClipRect = ImRect{{+FLT_MAX, +FLT_MAX}, {-FLT_MAX, -FLT_MAX}} }
			ImBitArraySetBit(merge_group.ChannelsMask, u32(channel_no))
			post_incr(&merge_group.ChannelsCount)
			Add(&merge_group.ClipRect, transmute(ImRect) src_channel._CmdBuffer.Data[0].ClipRect)
			merge_group_mask |= (1 << u32(merge_group_n))
		}

		// Invalidate current draw channel
		// (we don't clear DrawChannelFrozen/DrawChannelUnfrozen solely to facilitate debugging/later inspection of data)
		column.DrawChannelCurrent = ~ImGuiTableDrawChannelIdx(0)
	}

	// [DEBUG] Display merge groups


	// 2. Rewrite channel list in our preferred order
	if merge_group_mask != 0 {
		// We skip channel 0 (Bg0/Bg1) and 1 (Bg2 frozen) from the shuffling since they won't move - see channels allocation in TableSetupDrawChannels().
		LEADING_DRAW_CHANNELS : i32 = 2
		resize(&g.DrawChannelsTempMergeBuffer, splitter._Count - LEADING_DRAW_CHANNELS); // Use shared temporary storage so the allocation gets amortized
		dst_tmp := g.DrawChannelsTempMergeBuffer.Data
		ImBitArraySetBitRange(remaining_mask, u32(LEADING_DRAW_CHANNELS), u32(splitter._Count))
		ImBitArrayClearBit(remaining_mask, u32(table.Bg2DrawChannelUnfrozen))
		IM_ASSERT(has_freeze_v == false || i32(table.Bg2DrawChannelUnfrozen) != TABLE_DRAW_CHANNEL_BG2_FROZEN)
		remaining_count : i32 = splitter._Count - (has_freeze_v ? LEADING_DRAW_CHANNELS + 1 : LEADING_DRAW_CHANNELS)
		//ImRect host_rect = (table->InnerWindow == table->OuterWindow) ? table->InnerClipRect : table->HostClipRect;
		host_rect : ImRect = table.HostClipRect
		for merge_group_n : i32 = 0; merge_group_n < cast(i32)IM_ARRAYSIZE(merge_groups); merge_group_n += 1 {
			if merge_channels_count : i32 = merge_groups[merge_group_n].ChannelsCount; merge_channels_count != 0 {
				merge_group : ^MergeGroup = &merge_groups[merge_group_n]
				merge_clip_rect : ImRect = merge_group.ClipRect

				// Extend outer-most clip limits to match those of host, so draw calls can be merged even if
				// outer-most columns have some outer padding offsetting them from their parent ClipRect.
				// The principal cases this is dealing with are:
				// - On a same-window table (not scrolling = single group), all fitting columns ClipRect -> will extend and match host ClipRect -> will merge
				// - Columns can use padding and have left-most ClipRect.Min.x and right-most ClipRect.Max.x != from host ClipRect -> will extend and match host ClipRect -> will merge
				// FIXME-TABLE FIXME-WORKRECT: We are wasting a merge opportunity on tables without scrolling if column doesn't fit
				// within host clip rect, solely because of the half-padding difference between window->WorkRect and window->InnerClipRect.
				if (merge_group_n & 1) == 0 || !has_freeze_h { merge_clip_rect.Min.x = ImMin(merge_clip_rect.Min.x, host_rect.Min.x) }
				if (merge_group_n & 2) == 0 || !has_freeze_v { merge_clip_rect.Min.y = ImMin(merge_clip_rect.Min.y, host_rect.Min.y) }
				if (merge_group_n & 1) != 0 { merge_clip_rect.Max.x = ImMax(merge_clip_rect.Max.x, host_rect.Max.x) }
				if (merge_group_n & 2) != 0 && (table.Flags & ImGuiTableFlags_.ImGuiTableFlags_NoHostExtendY) == {} { merge_clip_rect.Max.y = ImMax(merge_clip_rect.Max.y, host_rect.Max.y) }
				//GetForegroundDrawList()->AddRect(merge_group->ClipRect.Min, merge_group->ClipRect.Max, IM_COL32(255, 0, 0, 200), 0.0f, 0, 1.0f); // [DEBUG]
				//GetForegroundDrawList()->AddLine(merge_group->ClipRect.Min, merge_clip_rect.Min, IM_COL32(255, 100, 0, 200));
				//GetForegroundDrawList()->AddLine(merge_group->ClipRect.Max, merge_clip_rect.Max, IM_COL32(255, 100, 0, 200));
				remaining_count -= merge_group.ChannelsCount
				for n : i32 = 0; n < (size_for_masks_bitarrays_one >> 2); n += 1 { remaining_mask[n] &= ~merge_group.ChannelsMask[n] }

				for n : i32 = 0; n < splitter._Count && merge_channels_count != 0; n += 1 {
					// Copy + overwrite new clip rect
					if !IM_BITARRAY_TESTBIT(merge_group.ChannelsMask, n) { continue }
					IM_BITARRAY_CLEARBIT(merge_group.ChannelsMask, n)
					post_decr(&merge_channels_count)

					channel : ^ImDrawChannel = &splitter._Channels.Data[n]
					IM_ASSERT(channel._CmdBuffer.Size == 1 && Contains(merge_clip_rect, transmute(ImRect) channel._CmdBuffer.Data[0].ClipRect ))
					channel._CmdBuffer.Data[0].ClipRect = ToVec4(merge_clip_rect)
					memcpy(post_incr(&dst_tmp), channel, size_of(ImDrawChannel))
				}
			}

			// Make sure Bg2DrawChannelUnfrozen appears in the middle of our groups (whereas Bg0/Bg1 and Bg2 frozen are fixed to 0 and 1)
			if merge_group_n == 1 && has_freeze_v { memcpy(post_incr(&dst_tmp), &splitter._Channels.Data[table.Bg2DrawChannelUnfrozen], size_of(ImDrawChannel)) }
		}

		// Append unmergeable channels that we didn't reorder at the end of the list
		for n : i32 = 0; n < splitter._Count && remaining_count != 0; n += 1 {
			if !IM_BITARRAY_TESTBIT(remaining_mask, n) { continue }
			channel : ^ImDrawChannel = &splitter._Channels.Data[n]
			memcpy(post_incr(&dst_tmp), channel, size_of(ImDrawChannel))
			post_decr(&remaining_count)
		}

		IM_ASSERT(dst_tmp == g.DrawChannelsTempMergeBuffer.Data[g.DrawChannelsTempMergeBuffer.Size:])
		memcpy(splitter._Channels.Data[LEADING_DRAW_CHANNELS:], g.DrawChannelsTempMergeBuffer.Data, int(splitter._Count - LEADING_DRAW_CHANNELS) * size_of(ImDrawChannel))
	}
}

TableGetColumnBorderCol :: proc(table : ^ImGuiTable, order_n : i32, column_n : i32) -> ImU32
{
	is_hovered : bool = (i32(table.HoveredColumnBorder) == column_n)
	is_resized : bool = (i32(table.ResizedColumn) == column_n) && (table.InstanceInteracted == table.InstanceCurrent)
	is_frozen_separator : bool = (i32(table.FreezeColumnsCount) == order_n + 1)
	if is_resized || is_hovered { return GetColorU32(is_resized ? ImGuiCol_.ImGuiCol_SeparatorActive : ImGuiCol_.ImGuiCol_SeparatorHovered) }
	if is_frozen_separator || (table.Flags & (ImGuiTableFlags_.ImGuiTableFlags_NoBordersInBody | ImGuiTableFlags_.ImGuiTableFlags_NoBordersInBodyUntilResize)) != {} { return table.BorderColorStrong }
	return table.BorderColorLight
}

// FIXME-TABLE: This is a mess, need to redesign how we render borders (as some are also done in TableEndRow)
TableDrawBorders :: proc(table : ^ImGuiTable)
{
	inner_window : ^ImGuiWindow = table.InnerWindow
	if !Overlaps(table.OuterWindow.ClipRect, table.OuterRect) { return }

	inner_drawlist : ^ImDrawList = inner_window.DrawList
	SetCurrentChannel(table.DrawSplitter, inner_drawlist, TABLE_DRAW_CHANNEL_BG0)
	PushClipRect(inner_drawlist, table.Bg0ClipRectForDrawCmd.Min, table.Bg0ClipRectForDrawCmd.Max, false)

	// Draw inner border and resizing feedback
	table_instance : ^ImGuiTableInstanceData = TableGetInstanceData(table, i32(table.InstanceCurrent))
	border_size : f32 = TABLE_BORDER_SIZE
	draw_y1 : f32 = ImMax(table.InnerRect.Min.y, (table.FreezeRowsCount >= 1 ? table.InnerRect.Min.y : table.WorkRect.Min.y) + table.AngledHeadersHeight) + ((table.Flags & ImGuiTableFlags_.ImGuiTableFlags_BordersOuterH) != {} ? 1.0 : 0.0)
	draw_y2_body : f32 = table.InnerRect.Max.y
	draw_y2_head : f32 = table.IsUsingHeaders ? ImMin(table.InnerRect.Max.y, (table.FreezeRowsCount >= 1 ? table.InnerRect.Min.y : table.WorkRect.Min.y) + table_instance.LastTopHeadersRowHeight) : draw_y1
	if (table.Flags & ImGuiTableFlags_.ImGuiTableFlags_BordersInnerV) != {} {
		for order_n : i32 = 0; order_n < table.ColumnsCount; order_n += 1 {
			if !IM_BITARRAY_TESTBIT(table.EnabledMaskByDisplayOrder, order_n) { continue }

			column_n := table.DisplayOrderToIndex.Data[order_n]
			column : ^ImGuiTableColumn = &table.Columns.Data[column_n]
			is_hovered : bool = (table.HoveredColumnBorder == column_n)
			is_resized : bool = (table.ResizedColumn == column_n) && (table.InstanceInteracted == table.InstanceCurrent)
			is_resizable : bool = (column.Flags & (ImGuiTableColumnFlags_.ImGuiTableColumnFlags_NoResize | ImGuiTableColumnFlags_.ImGuiTableColumnFlags_NoDirectResize_)) == {}
			is_frozen_separator : bool = (i32(table.FreezeColumnsCount) == order_n + 1)
			if column.MaxX > table.InnerClipRect.Max.x && !is_resized { continue }

			// Decide whether right-most column is visible
			if column.NextEnabledColumn == -1 && !is_resizable { if (table.Flags & ImGuiTableFlags_.ImGuiTableFlags_SizingMask_) != ImGuiTableFlags_.ImGuiTableFlags_SizingFixedSame || (table.Flags & ImGuiTableFlags_.ImGuiTableFlags_NoHostExtendX) != {} { continue } }
			if column.MaxX <= column.ClipRect.Min.x {
				// FIXME-TABLE FIXME-STYLE: Assume BorderSize==1, this is problematic if we want to increase the border size..
				continue
			}

			// Draw in outer window so right-most column won't be clipped
			// Always draw full height border when being resized/hovered, or on the delimitation of frozen column scrolling.
			draw_y2 : f32 = (is_hovered || is_resized || is_frozen_separator || (table.Flags & (ImGuiTableFlags_.ImGuiTableFlags_NoBordersInBody | ImGuiTableFlags_.ImGuiTableFlags_NoBordersInBodyUntilResize)) == {}) ? draw_y2_body : draw_y2_head
			if draw_y2 > draw_y1 { AddLine(inner_drawlist, ImVec2{column.MaxX, draw_y1}, ImVec2{column.MaxX, draw_y2}, TableGetColumnBorderCol(table, order_n, i32(column_n)), border_size) }
		}
	}

	// Draw outer border
	// FIXME: could use AddRect or explicit VLine/HLine helper?
	if (table.Flags & ImGuiTableFlags_.ImGuiTableFlags_BordersOuter) != {} {
		// Display outer border offset by 1 which is a simple way to display it without adding an extra draw call
		// (Without the offset, in outer_window it would be rendered behind cells, because child windows are above their
		// parent. In inner_window, it won't reach out over scrollbars. Another weird solution would be to display part
		// of it in inner window, and the part that's over scrollbars in the outer window..)
		// Either solution currently won't allow us to use a larger border size: the border would clipped.
		outer_border : ImRect = table.OuterRect
		outer_col : ImU32 = table.BorderColorStrong
		if (table.Flags & ImGuiTableFlags_.ImGuiTableFlags_BordersOuter) == ImGuiTableFlags_.ImGuiTableFlags_BordersOuter {
			AddRect(inner_drawlist, outer_border.Min, outer_border.Max, outer_col, 0.0, {}, border_size)
		}
		else if (table.Flags & ImGuiTableFlags_.ImGuiTableFlags_BordersOuterV) != {} {
			AddLine(inner_drawlist, outer_border.Min, ImVec2{outer_border.Min.x, outer_border.Max.y}, outer_col, border_size)
			AddLine(inner_drawlist, ImVec2{outer_border.Max.x, outer_border.Min.y}, outer_border.Max, outer_col, border_size)
		}
		else if (table.Flags & ImGuiTableFlags_.ImGuiTableFlags_BordersOuterH) != {} {
			AddLine(inner_drawlist, outer_border.Min, ImVec2{outer_border.Max.x, outer_border.Min.y}, outer_col, border_size)
			AddLine(inner_drawlist, ImVec2{outer_border.Min.x, outer_border.Max.y}, outer_border.Max, outer_col, border_size)
		}
	}
	if (table.Flags & ImGuiTableFlags_.ImGuiTableFlags_BordersInnerH) != {} && table.RowPosY2 < table.OuterRect.Max.y {
		// Draw bottom-most row border between it is above outer border.
		border_y : f32 = table.RowPosY2
		if border_y >= table.BgClipRect.Min.y && border_y < table.BgClipRect.Max.y { AddLine(inner_drawlist, ImVec2{table.BorderX1, border_y}, ImVec2{table.BorderX2, border_y}, table.BorderColorLight, border_size) }
	}

	PopClipRect(inner_drawlist)
}

//-------------------------------------------------------------------------
// [SECTION] Tables: Sorting
//-------------------------------------------------------------------------
// - TableGetSortSpecs()
// - TableFixColumnSortDirection() [Internal]
// - TableGetColumnNextSortDirection() [Internal]
// - TableSetColumnSortDirection() [Internal]
// - TableSortSpecsSanitize() [Internal]
// - TableSortSpecsBuild() [Internal]
//-------------------------------------------------------------------------

// Return NULL if no sort specs (most often when ImGuiTableFlags_Sortable is not set)
// When 'sort_specs->SpecsDirty == true' you should sort your data. It will be true when sorting specs have
// changed since last call, or the first time. Make sure to set 'SpecsDirty = false' after sorting,
// else you may wastefully sort your data every frame!
// Lifetime: don't hold on this pointer over multiple frames or past any subsequent call to BeginTable()!
TableGetSortSpecs :: proc() -> ^ImGuiTableSortSpecs
{
	g : ^ImGuiContext = GImGui
	table : ^ImGuiTable = g.CurrentTable
	IM_ASSERT(table != nil)

	if (table.Flags & ImGuiTableFlags_.ImGuiTableFlags_Sortable) == {} { return nil }

	// Require layout (in case TableHeadersRow() hasn't been called) as it may alter IsSortSpecsDirty in some paths.
	if !table.IsLayoutLocked { TableUpdateLayout(table) }

	TableSortSpecsBuild(table)
	return &table.SortSpecs
}

TableGetColumnAvailSortDirection :: #force_inline proc(column : ^ImGuiTableColumn, n : i32) -> ImGuiSortDirection
{
	IM_ASSERT(n < i32(column.SortDirectionsAvailCount))
	return cast(ImGuiSortDirection) ((column.SortDirectionsAvailList >> (u32(n) << 1)) & 0x03)
}

// Fix sort direction if currently set on a value which is unavailable (e.g. activating NoSortAscending/NoSortDescending)
TableFixColumnSortDirection :: proc(table : ^ImGuiTable, column : ^ImGuiTableColumn)
{
	if column.SortOrder == -1 || (column.SortDirectionsAvailMask & (1 << column.SortDirection)) != 0 { return }
	column.SortDirection = TableGetColumnAvailSortDirection(column, 0)
	table.IsSortSpecsDirty = true
}

// Calculate next sort direction that would be set after clicking the column
// - If the PreferSortDescending flag is set, we will default to a Descending direction on the first click.
// - Note that the PreferSortAscending flag is never checked, it is essentially the default and therefore a no-op.
#assert(i32(ImGuiSortDirection.ImGuiSortDirection_None) == 0 && i32(ImGuiSortDirection.ImGuiSortDirection_Ascending) == 1 && i32(ImGuiSortDirection.ImGuiSortDirection_Descending) == 2)
TableGetColumnNextSortDirection :: proc(column : ^ImGuiTableColumn) -> ImGuiSortDirection
{
	IM_ASSERT(column.SortDirectionsAvailCount > 0)
	if column.SortOrder == -1 { return TableGetColumnAvailSortDirection(column, 0) }
	for n : i32 = 0; n < 3; n += 1 { if column.SortDirection == TableGetColumnAvailSortDirection(column, n) {
		return TableGetColumnAvailSortDirection(column, (n + 1) % i32(column.SortDirectionsAvailCount))
	} }

	IM_ASSERT(false)
	return ImGuiSortDirection.ImGuiSortDirection_None
}

// Note that the NoSortAscending/NoSortDescending flags are processed in TableSortSpecsSanitize(), and they may change/revert
// the value of SortDirection. We could technically also do it here but it would be unnecessary and duplicate code.
TableSetColumnSortDirection :: proc(column_n : i32, sort_direction : ImGuiSortDirection, append_to_sort_specs : bool)
{
	g : ^ImGuiContext = GImGui
	table : ^ImGuiTable = g.CurrentTable

	append_to_sort_specs := append_to_sort_specs
	if (table.Flags & ImGuiTableFlags_.ImGuiTableFlags_SortMulti) == {} { append_to_sort_specs = false }
	if (table.Flags & ImGuiTableFlags_.ImGuiTableFlags_SortTristate) == {} { IM_ASSERT(sort_direction != ImGuiSortDirection.ImGuiSortDirection_None) }

	sort_order_max : ImGuiTableColumnIdx = 0
	if append_to_sort_specs { for other_column_n : i32 = 0; other_column_n < table.ColumnsCount; other_column_n += 1 { sort_order_max = ImMax(sort_order_max, table.Columns.Data[other_column_n].SortOrder) } }

	column : ^ImGuiTableColumn = &table.Columns.Data[column_n]
	column.SortDirection = sort_direction
	if column.SortDirection == ImGuiSortDirection.ImGuiSortDirection_None { column.SortOrder = -1 }
	else if column.SortOrder == -1 || !append_to_sort_specs { column.SortOrder = append_to_sort_specs ? sort_order_max + 1 : 0 }

	for other_column_n : i32 = 0; other_column_n < table.ColumnsCount; other_column_n += 1 {
		other_column : ^ImGuiTableColumn = &table.Columns.Data[other_column_n]
		if other_column != column && !append_to_sort_specs { other_column.SortOrder = -1 }
		TableFixColumnSortDirection(table, other_column)
	}

	table.IsSettingsDirty = true
	table.IsSortSpecsDirty = true
}

TableSortSpecsSanitize :: proc(table : ^ImGuiTable)
{
	IM_ASSERT((table.Flags & ImGuiTableFlags_.ImGuiTableFlags_Sortable) != {})

	// Clear SortOrder from hidden column and verify that there's no gap or duplicate.
	sort_order_count : i32 = 0
	sort_order_mask : ImU64 = 0x00
	for column_n : i32 = 0; column_n < table.ColumnsCount; column_n += 1 {
		column : ^ImGuiTableColumn = &table.Columns.Data[column_n]
		if column.SortOrder != -1 && !column.IsEnabled { column.SortOrder = -1 }
		if column.SortOrder == -1 { continue }
		post_incr(&sort_order_count)
		sort_order_mask |= (cast(ImU64) 1 << u32(column.SortOrder))
		IM_ASSERT(sort_order_count < cast(i32) size_of(sort_order_mask) * 8)
	}

	need_fix_linearize : bool = (cast(ImU64) 1 << u32(sort_order_count)) != (sort_order_mask + 1)
	need_fix_single_sort_order : bool = (sort_order_count > 1) && (table.Flags & ImGuiTableFlags_.ImGuiTableFlags_SortMulti) == {}
	if need_fix_linearize || need_fix_single_sort_order {
		fixed_mask : ImU64 = 0x00
		for sort_n : i32 = 0; sort_n < sort_order_count; sort_n += 1 {
			// Fix: Rewrite sort order fields if needed so they have no gap or duplicate.
			// (e.g. SortOrder 0 disappeared, SortOrder 1..2 exists --> rewrite then as SortOrder 0..1)
			column_with_smallest_sort_order : i32 = -1
			for column_n : i32 = 0; column_n < table.ColumnsCount; column_n += 1 { if (fixed_mask & (cast(ImU64) 1 << cast(ImU64) column_n)) == 0 && table.Columns.Data[column_n].SortOrder != -1 { if column_with_smallest_sort_order == -1 || table.Columns.Data[column_n].SortOrder < table.Columns.Data[column_with_smallest_sort_order].SortOrder { column_with_smallest_sort_order = column_n } } }

			IM_ASSERT(column_with_smallest_sort_order != -1)
			fixed_mask |= (cast(ImU64) 1 << u32(column_with_smallest_sort_order))
			table.Columns.Data[column_with_smallest_sort_order].SortOrder = cast(ImGuiTableColumnIdx) sort_n

			// Fix: Make sure only one column has a SortOrder if ImGuiTableFlags_MultiSortable is not set.
			if need_fix_single_sort_order {
				sort_order_count = 1
				for column_n : i32 = 0; column_n < table.ColumnsCount; column_n += 1 { if column_n != column_with_smallest_sort_order { table.Columns.Data[column_n].SortOrder = -1 } }

				break
			}
		}
	}

	// Fallback default sort order (if no column with the ImGuiTableColumnFlags_DefaultSort flag)
	if sort_order_count == 0 && (table.Flags & ImGuiTableFlags_.ImGuiTableFlags_SortTristate) == {} { for column_n : i32 = 0; column_n < table.ColumnsCount; column_n += 1 {
	column : ^ImGuiTableColumn = &table.Columns.Data[column_n]
	if column.IsEnabled && (column.Flags & ImGuiTableColumnFlags_.ImGuiTableColumnFlags_NoSort) == {} {
		sort_order_count = 1
		column.SortOrder = 0
		column.SortDirection = TableGetColumnAvailSortDirection(column, 0)
		break
	}
} }

	table.SortSpecsCount = cast(ImGuiTableColumnIdx) sort_order_count
}

TableSortSpecsBuild :: proc(table : ^ImGuiTable)
{
	dirty : bool = table.IsSortSpecsDirty
	if dirty {
		TableSortSpecsSanitize(table)
		resize(&table.SortSpecsMulti, table.SortSpecsCount <= 1 ? 0 : i32(table.SortSpecsCount))
		table.SortSpecs.SpecsDirty = true; // Mark as dirty for user
		table.IsSortSpecsDirty = false; // Mark as not dirty for us
	}

	// Write output
	// May be able to move all SortSpecs data from table (48 bytes) to ImGuiTableTempData if we decide to write it back on every BeginTable()
	sort_specs : [^]ImGuiTableColumnSortSpecs = (table.SortSpecsCount == {}) ? nil : (table.SortSpecsCount == 1) ? &table.SortSpecsSingle : table.SortSpecsMulti.Data
	if dirty && sort_specs != nil { for column_n : i32 = 0; column_n < table.ColumnsCount; column_n += 1 {
	column : ^ImGuiTableColumn = &table.Columns.Data[column_n]
	if column.SortOrder == -1 { continue }
	IM_ASSERT(column.SortOrder < table.SortSpecsCount)
	sort_spec : ^ImGuiTableColumnSortSpecs = &sort_specs[column.SortOrder]
	sort_spec.ColumnUserID = column.UserID
	sort_spec.ColumnIndex = cast(ImGuiTableColumnIdx) column_n
	sort_spec.SortOrder = cast(ImGuiTableColumnIdx) column.SortOrder
	sort_spec.SortDirection = cast(ImGuiSortDirection) column.SortDirection
} }

	table.SortSpecs.Specs = sort_specs
	table.SortSpecs.SpecsCount = i32(table.SortSpecsCount)
}

//-------------------------------------------------------------------------
// [SECTION] Tables: Headers
//-------------------------------------------------------------------------
// - TableGetHeaderRowHeight() [Internal]
// - TableGetHeaderAngledMaxLabelWidth() [Internal]
// - TableHeadersRow()
// - TableHeader()
// - TableAngledHeadersRow()
// - TableAngledHeadersRowEx() [Internal]
//-------------------------------------------------------------------------

TableGetHeaderRowHeight :: proc() -> f32
{
	// Caring for a minor edge case:
	// Calculate row height, for the unlikely case that some labels may be taller than others.
	// If we didn't do that, uneven header height would highlight but smaller one before the tallest wouldn't catch input for all height.
	// In your custom header row you may omit this all together and just call TableNextRow() without a height...
	g : ^ImGuiContext = GImGui
	table : ^ImGuiTable = g.CurrentTable
	row_height : f32 = g.FontSize
	for column_n : i32 = 0; column_n < table.ColumnsCount; column_n += 1 { if IM_BITARRAY_TESTBIT(table.EnabledMaskByIndex, column_n) { if (table.Columns.Data[column_n].Flags & ImGuiTableColumnFlags_.ImGuiTableColumnFlags_NoHeaderLabel) == {} { row_height = ImMax(row_height, CalcTextSize(TableGetColumnName(table, column_n)).y) } } }

	return row_height + g.Style.CellPadding.y * 2.0
}

TableGetHeaderAngledMaxLabelWidth :: proc() -> f32
{
	g : ^ImGuiContext = GImGui
	table : ^ImGuiTable = g.CurrentTable
	width : f32 = 0.0
	for column_n : i32 = 0; column_n < table.ColumnsCount; column_n += 1 { if IM_BITARRAY_TESTBIT(table.EnabledMaskByIndex, column_n) { if (table.Columns.Data[column_n].Flags & ImGuiTableColumnFlags_.ImGuiTableColumnFlags_AngledHeader) != {} { width = ImMax(width, CalcTextSize(TableGetColumnName(table, column_n), true).x) } } }

	return width + g.Style.CellPadding.y * 2.0// Swap padding
}

// [Public] This is a helper to output TableHeader() calls based on the column names declared in TableSetupColumn().
// The intent is that advanced users willing to create customized headers would not need to use this helper
// and can create their own! For example: TableHeader() may be preceded by Checkbox() or other custom widgets.
// See 'Demo->Tables->Custom headers' for a demonstration of implementing a custom version of this.
// This code is intentionally written to not make much use of internal functions, to give you better direction
// if you need to write your own.
// FIXME-TABLE: TableOpenContextMenu() and TableGetHeaderRowHeight() are not public.
TableHeadersRow :: proc()
{
	g : ^ImGuiContext = GImGui
	table : ^ImGuiTable = g.CurrentTable
	IM_ASSERT(table != nil, "Need to call TableHeadersRow() after BeginTable()!")

	// Call layout if not already done. This is automatically done by TableNextRow: we do it here _only_ to make
	// it easier to debug-step in TableUpdateLayout(). Your own version of this function doesn't need this.
	if !table.IsLayoutLocked { TableUpdateLayout(table) }

	// Open row
	row_height : f32 = TableGetHeaderRowHeight()
	TableNextRow(ImGuiTableRowFlags_.ImGuiTableRowFlags_Headers, row_height)
	row_y1 : f32 = GetCursorScreenPos().y
	if table.HostSkipItems {
		// Merely an optimization, you may skip in your own code.
		return
	}

	columns_count : i32 = TableGetColumnCount()
	for column_n : i32 = 0; column_n < columns_count; column_n += 1 {
		if !TableSetColumnIndex(column_n) { continue }

		// Push an id to allow empty/unnamed headers. This is also idiomatic as it ensure there is a consistent ID path to access columns (for e.g. automation)
		name : string = (TableGetColumnFlags(column_n) & ImGuiTableColumnFlags_.ImGuiTableColumnFlags_NoHeaderLabel) != {} ? "" : TableGetColumnName(column_n)
		PushID(column_n)
		TableHeader(name)
		PopID()
	}

	// Allow opening popup from the right-most section after the last column.
	mouse_pos : ImVec2 = GetMousePos()
	if IsMouseReleased(cast(ImGuiMouseButton) 1) && TableGetHoveredColumn() == columns_count { if mouse_pos.y >= row_y1 && mouse_pos.y < row_y1 + row_height {
	// Will open a non-column-specific popup.
	TableOpenContextMenu(columns_count)
} }
}

// Emit a column header (text + optional sort order)
// We cpu-clip text here so that all columns headers can be merged into a same draw call.
// Note that because of how we cpu-clip and display sorting indicators, you _cannot_ use SameLine() after a TableHeader()
TableHeader :: proc(label : string)
{
	g : ^ImGuiContext = GImGui
	window : ^ImGuiWindow = g.CurrentWindow
	if window.SkipItems { return }

	table : ^ImGuiTable = g.CurrentTable
	IM_ASSERT(table != nil, "Need to call TableHeader() after BeginTable()!")
	IM_ASSERT(table.CurrentColumn != -1)
	column_n : i32 = table.CurrentColumn
	column : ^ImGuiTableColumn = &table.Columns.Data[column_n]

	// Label
	label_end := FindRenderedTextEnd(label)
	label_size : ImVec2 = CalcTextSize(label[:label_end], true)
	label_pos : ImVec2 = window.DC.CursorPos

	// If we already got a row height, there's use that.
	// FIXME-TABLE: Padding problem if the correct outer-padding CellBgRect strays off our ClipRect?
	cell_r : ImRect = TableGetCellBgRect(table, column_n)
	label_height : f32 = ImMax(label_size.y, table.RowMinHeight - table.RowCellPaddingY * 2.0)

	// Calculate ideal size for sort order arrow
	w_arrow : f32 = 0.0
	w_sort_text : f32 = 0.0
	sort_arrow : bool = false
	sort_order_suf : [4]u8; sort_order_suf_s : string
	ARROW_SCALE : f32 = 0.65
	if (table.Flags & ImGuiTableFlags_.ImGuiTableFlags_Sortable) != {} && (column.Flags & ImGuiTableColumnFlags_.ImGuiTableColumnFlags_NoSort) == {} {
		w_arrow = ImTrunc(g.FontSize * ARROW_SCALE + g.Style.FramePadding.x)
		if column.SortOrder != -1 { sort_arrow = true }
		if column.SortOrder > 0 {
			l := ImFormatString(sort_order_suf[:], "%d", column.SortOrder + 1)
			sort_order_suf_s = string_from_slice(sort_order_suf[:l], false)
			w_sort_text = g.Style.ItemInnerSpacing.x + CalcTextSize(sort_order_suf_s).x
		}
	}

	// We feed our unclipped width to the column without writing on CursorMaxPos, so that column is still considered for merging.
	max_pos_x : f32 = label_pos.x + label_size.x + w_sort_text + w_arrow
	column.ContentMaxXHeadersUsed = ImMax(column.ContentMaxXHeadersUsed, sort_arrow ? cell_r.Max.x : ImMin(max_pos_x, cell_r.Max.x))
	column.ContentMaxXHeadersIdeal = ImMax(column.ContentMaxXHeadersIdeal, max_pos_x)

	// Keep header highlighted when context menu is open.
	id : ImGuiID = GetID(window, label)
	bb : ImRect; init(&bb, cell_r.Min.x, cell_r.Min.y, cell_r.Max.x, ImMax(cell_r.Max.y, cell_r.Min.y + label_height + g.Style.CellPadding.y * 2.0))
	ItemSize(ImVec2{0.0, label_height}); // Don't declare unclipped width, it'll be fed ContentMaxPosHeadersIdeal
	if !ItemAdd(bb, id) { return }

	//GetForegroundDrawList()->AddRect(cell_r.Min, cell_r.Max, IM_COL32(255, 0, 0, 255)); // [DEBUG]
	//GetForegroundDrawList()->AddRect(bb.Min, bb.Max, IM_COL32(255, 0, 0, 255)); // [DEBUG]

	// Using AllowOverlap mode because we cover the whole cell, and we want user to be able to submit subsequent items.
	highlight : bool = (i32(table.HighlightColumnHeader) == column_n)
	hovered : bool; held : bool
	pressed : bool = ButtonBehavior(bb, id, &hovered, &held, cast(ImGuiButtonFlags)ImGuiButtonFlagsPrivate_.ImGuiButtonFlags_AllowOverlap)
	if held || hovered || highlight {
		col : ImU32 = GetColorU32(held ? ImGuiCol_.ImGuiCol_HeaderActive : hovered ? ImGuiCol_.ImGuiCol_HeaderHovered : ImGuiCol_.ImGuiCol_Header)
		//RenderFrame(bb.Min, bb.Max, col, false, 0.0f);
		TableSetBgColor(ImGuiTableBgTarget_.ImGuiTableBgTarget_CellBg, col, table.CurrentColumn)
	}
	else {
		// Submit single cell bg color in the case we didn't submit a full header row
		if (table.RowFlags & ImGuiTableRowFlags_.ImGuiTableRowFlags_Headers) == {} { TableSetBgColor(ImGuiTableBgTarget_.ImGuiTableBgTarget_CellBg, GetColorU32(ImGuiCol_.ImGuiCol_TableHeaderBg), table.CurrentColumn) }
	}
	RenderNavCursor(bb, id, ImGuiNavRenderCursorFlags_.ImGuiNavRenderCursorFlags_Compact | ImGuiNavRenderCursorFlags_.ImGuiNavRenderCursorFlags_NoRounding)
	if held { table.HeldHeaderColumn = cast(ImGuiTableColumnIdx) column_n }
	window.DC.CursorPos.y -= g.Style.ItemSpacing.y * 0.5

	// Drag and drop to re-order columns.
	// FIXME-TABLE: Scroll request while reordering a column and it lands out of the scrolling zone.
	if held && (table.Flags & ImGuiTableFlags_.ImGuiTableFlags_Reorderable) != {} && IsMouseDragging(ImGuiMouseButton(0)) && !g.DragDropActive {
		// While moving a column it will jump on the other side of the mouse, so we also test for MouseDelta.x
		table.ReorderColumn = cast(ImGuiTableColumnIdx) column_n
		table.InstanceInteracted = table.InstanceCurrent

		// We don't reorder: through the frozen<>unfrozen line, or through a column that is marked with ImGuiTableColumnFlags_NoReorder.
		if g.IO.MouseDelta.x < 0.0 && g.IO.MousePos.x < cell_r.Min.x { if prev_column : ^ImGuiTableColumn = (column.PrevEnabledColumn != -1) ? &table.Columns.Data[column.PrevEnabledColumn] : nil; prev_column != nil { if ((column.Flags | prev_column.Flags) & ImGuiTableColumnFlags_.ImGuiTableColumnFlags_NoReorder) == {} { if (column.IndexWithinEnabledSet < table.FreezeColumnsRequest) == (prev_column.IndexWithinEnabledSet < table.FreezeColumnsRequest) { table.ReorderColumnDir = -1 } } } }
		if g.IO.MouseDelta.x > 0.0 && g.IO.MousePos.x > cell_r.Max.x { if next_column : ^ImGuiTableColumn = (column.NextEnabledColumn != -1) ? &table.Columns.Data[column.NextEnabledColumn] : nil; next_column != nil { if ((column.Flags | next_column.Flags) & ImGuiTableColumnFlags_.ImGuiTableColumnFlags_NoReorder) == {} { if (column.IndexWithinEnabledSet < table.FreezeColumnsRequest) == (next_column.IndexWithinEnabledSet < table.FreezeColumnsRequest) { table.ReorderColumnDir = +1 } } } }
	}

	// Sort order arrow
	ellipsis_max : f32 = ImMax(cell_r.Max.x - w_arrow - w_sort_text, label_pos.x)
	if (table.Flags & ImGuiTableFlags_.ImGuiTableFlags_Sortable) != {} && (column.Flags & ImGuiTableColumnFlags_.ImGuiTableColumnFlags_NoSort) == {} {
		if column.SortOrder != -1 {
			x : f32 = ImMax(cell_r.Min.x, cell_r.Max.x - w_arrow - w_sort_text)
			y : f32 = label_pos.y
			if column.SortOrder > 0 {
				PushStyleColor(ImGuiCol_.ImGuiCol_Text, GetColorU32(ImGuiCol_.ImGuiCol_Text, 0.70))
				RenderText(ImVec2{x + g.Style.ItemInnerSpacing.x, y}, sort_order_suf_s)
				PopStyleColor()
				x += w_sort_text
			}
			RenderArrow(window.DrawList, ImVec2{x, y}, GetColorU32(ImGuiCol_.ImGuiCol_Text), column.SortDirection == ImGuiSortDirection.ImGuiSortDirection_Ascending ? ImGuiDir.ImGuiDir_Up : ImGuiDir.ImGuiDir_Down, ARROW_SCALE)
		}

		// Handle clicking on column header to adjust Sort Order
		if pressed && i32(table.ReorderColumn) != column_n {
			sort_direction : ImGuiSortDirection = TableGetColumnNextSortDirection(column)
			TableSetColumnSortDirection(column_n, sort_direction, g.IO.KeyShift)
		}
	}

	// Render clipped label. Clipping here ensure that in the majority of situations, all our header cells will
	// be merged into a single draw call.
	//window->DrawList->AddCircleFilled(ImVec2{ellipsis_max, label_pos.y}, 40, IM_COL32_WHITE);
	RenderTextEllipsis(window.DrawList, label_pos, ImVec2{ellipsis_max, label_pos.y + label_height + g.Style.FramePadding.y}, ellipsis_max, ellipsis_max, label, label_end, &label_size)

	text_clipped : bool = label_size.x > (ellipsis_max - label_pos.x)
	if text_clipped && hovered && g.ActiveId == 0 { SetItemTooltip("%s", label[:label_end]) }

	// We don't use BeginPopupContextItem() because we want the popup to stay up even after the column is hidden
	if IsMouseReleased(cast(ImGuiMouseButton) 1) && IsItemHovered() { TableOpenContextMenu(column_n) }
}

// Unlike TableHeadersRow() it is not expected that you can reimplement or customize this with custom widgets.
// FIXME: No hit-testing/button on the angled header.
TableAngledHeadersRow :: proc()
{
	g : ^ImGuiContext = GImGui
	table : ^ImGuiTable = g.CurrentTable
	temp_data : ^ImGuiTableTempData = table.TempData
	resize(&temp_data.AngledHeadersRequests, 0)
	reserve(&temp_data.AngledHeadersRequests, i32(table.ColumnsEnabledCount))

	// Which column needs highlight?
	row_id : ImGuiID = GetID("##AngledHeaders")
	table_instance : ^ImGuiTableInstanceData = TableGetInstanceData(table, i32(table.InstanceCurrent))
	highlight_column_n := table.HighlightColumnHeader
	if highlight_column_n == -1 && table.HoveredColumnBody != -1 { if table_instance.HoveredRowLast == 0 && table.HoveredColumnBorder == -1 && (g.ActiveId == 0 || g.ActiveId == row_id || (table.IsActiveIdInTable || g.DragDropActive)) { highlight_column_n = table.HoveredColumnBody } }

	// Build up request
	col_header_bg : ImU32 = GetColorU32(ImGuiCol_.ImGuiCol_TableHeaderBg)
	col_text : ImU32 = GetColorU32(ImGuiCol_.ImGuiCol_Text)
	for order_n : i32 = 0; order_n < table.ColumnsCount; order_n += 1 { if IM_BITARRAY_TESTBIT(table.EnabledMaskByDisplayOrder, order_n) {
	column_n := table.DisplayOrderToIndex.Data[order_n]
	column : ^ImGuiTableColumn = &table.Columns.Data[column_n]
	if (column.Flags & ImGuiTableColumnFlags_.ImGuiTableColumnFlags_AngledHeader) == {} {
		// Note: can't rely on ImGuiTableColumnFlags_IsVisible test here.
		continue
	}
	request : ImGuiTableHeaderData = {cast(ImGuiTableColumnIdx) column_n, col_text, col_header_bg, (column_n == highlight_column_n) ? GetColorU32(ImGuiCol_.ImGuiCol_Header) : 0}
	push_back(&temp_data.AngledHeadersRequests, request)
} }

	// Render row
	TableAngledHeadersRowEx(row_id, g.Style.TableAngledHeadersAngle, 0.0, temp_data.AngledHeadersRequests.Data, temp_data.AngledHeadersRequests.Size)
}

// Important: data must be fed left to right
TableAngledHeadersRowEx :: proc(row_id : ImGuiID, angle : f32, max_label_width : f32, data : [^]ImGuiTableHeaderData, data_count : i32)
{
	g : ^ImGuiContext = GImGui
	table : ^ImGuiTable = g.CurrentTable
	window : ^ImGuiWindow = g.CurrentWindow
	draw_list : ^ImDrawList = window.DrawList
	IM_ASSERT(table != nil, "Need to call TableHeadersRow() after BeginTable()!")
	IM_ASSERT(table.CurrentRow == -1, "Must be first row")

	max_label_width, angle := max_label_width, angle
	if max_label_width == 0.0 { max_label_width = TableGetHeaderAngledMaxLabelWidth() }

	// Angle argument expressed in (-IM_PI/2 .. +IM_PI/2) as it is easier to think about for user.
	flip_label : bool = (angle < 0.0)
	angle -= IM_PI * 0.5
	cos_a : f32 = ImCos(angle)
	sin_a : f32 = ImSin(angle)
	label_cos_a : f32 = flip_label ? ImCos(angle + IM_PI) : cos_a
	label_sin_a : f32 = flip_label ? ImSin(angle + IM_PI) : sin_a
	unit_right : ImVec2 = ImVec2{cos_a, sin_a}

	// Calculate our base metrics and set angled headers data _before_ the first call to TableNextRow()
	// FIXME-STYLE: Would it be better for user to submit 'max_label_width' or 'row_height' ? One can be derived from the other.
	header_height : f32 = g.FontSize + g.Style.CellPadding.x * 2.0
	row_height : f32 = ImTrunc(ImFabs(ImRotate(ImVec2{max_label_width, flip_label ? +header_height : -header_height}, cos_a, sin_a).y))
	table.AngledHeadersHeight = row_height
	table.AngledHeadersSlope = (sin_a != 0.0) ? (cos_a / sin_a) : 0.0
	header_angled_vector : ImVec2 = unit_right * (row_height / -sin_a); // vector from bottom-left to top-left, and from bottom-right to top-right

	// Declare row, override and draw our own background
	TableNextRow(ImGuiTableRowFlags_.ImGuiTableRowFlags_Headers, row_height)
	TableNextColumn()
	row_r : ImRect; init(&row_r, table.WorkRect.Min.x, table.BgClipRect.Min.y, table.WorkRect.Max.x, table.RowPosY2)
	SetCurrentChannel(table.DrawSplitter, draw_list, TABLE_DRAW_CHANNEL_BG0)
	clip_rect_min_x : f32 = table.BgClipRect.Min.x
	if table.FreezeColumnsCount > 0 { clip_rect_min_x = ImMax(clip_rect_min_x, table.Columns.Data[table.FreezeColumnsCount - 1].MaxX) }
	TableSetBgColor(ImGuiTableBgTarget_.ImGuiTableBgTarget_RowBg0, 0); // Cancel
	PushClipRect(table.BgClipRect.Min, table.BgClipRect.Max, false); // Span all columns
	AddRectFilled(draw_list, ImVec2{table.BgClipRect.Min.x, row_r.Min.y}, ImVec2{table.BgClipRect.Max.x, row_r.Max.y}, GetColorU32(ImGuiCol_.ImGuiCol_TableHeaderBg, 0.25)); // FIXME-STYLE: Change row background with an arbitrary color.
	PushClipRect(ImVec2{clip_rect_min_x, table.BgClipRect.Min.y}, table.BgClipRect.Max, true); // Span all columns

	ButtonBehavior(row_r, row_id, nil, nil)
	KeepAliveID(row_id)

	ascent_scaled : f32 = g.Font.Ascent * g.FontScale; // FIXME: Standardize those scaling factors better
	line_off_for_ascent_x : f32 = (ImMax((g.FontSize - ascent_scaled) * 0.5, 0.0) / -sin_a) * (flip_label ? -1.0 : 1.0)
	padding : ImVec2 = g.Style.CellPadding; // We will always use swapped component
	align : ImVec2 = g.Style.TableAngledHeadersTextAlign

	// Draw background and labels in first pass, then all borders.
	max_x : f32 = -FLT_MAX
	for pass : i32 = 0; pass < 2; pass += 1 { for order_n : i32 = 0; order_n < data_count; order_n += 1 {
	request : ^ImGuiTableHeaderData = &data[order_n]
	column_n : i32 = i32(request.Index)
	column : ^ImGuiTableColumn = &table.Columns.Data[column_n]

	bg_shape : [4]ImVec2
	bg_shape[0] = ImVec2{column.MaxX, row_r.Max.y}
	bg_shape[1] = ImVec2{column.MinX, row_r.Max.y}
	bg_shape[2] = bg_shape[1] + header_angled_vector
	bg_shape[3] = bg_shape[0] + header_angled_vector
	if pass == 0 {
		// Draw shape
		AddQuadFilled(draw_list, bg_shape[0], bg_shape[1], bg_shape[2], bg_shape[3], request.BgColor0)
		AddQuadFilled(draw_list, bg_shape[0], bg_shape[1], bg_shape[2], bg_shape[3], request.BgColor1); // Optional highlight
		max_x = ImMax(max_x, bg_shape[3].x)

		// Draw label
		// - First draw at an offset where RenderTextXXX() function won't meddle with applying current ClipRect, then transform to final offset.
		// - Handle multiple lines manually, as we want each lines to follow on the horizontal border, rather than see a whole block rotated.
		label_name := TableGetColumnName(table, column_n)
		label_name_end := FindRenderedTextEnd(label_name)
		line_off_step_x : f32 = (g.FontSize / -sin_a)
		label_lines : i32 = ImTextCountLines(raw_data(label_name), &raw_data(label_name)[label_name_end])

		// Left<>Right alignment
		line_off_curr_x : f32 = flip_label ? (f32(label_lines) - 1) * line_off_step_x : 0.0
		line_off_for_align_x : f32 = ImMax((((column.MaxX - column.MinX) - padding.x * 2.0) - (f32(label_lines) * line_off_step_x)), 0.0) * align.x
		line_off_curr_x += line_off_for_align_x - line_off_for_ascent_x

		// Register header width
		column.ContentMaxXHeadersIdeal = column.WorkMinX + ImCeil(f32(label_lines) * line_off_step_x - line_off_for_align_x); column.ContentMaxXHeadersUsed = column.ContentMaxXHeadersIdeal

		o : int = 0
		for o < label_name_end {
			label_line := next_line(label_name, &o)

			// FIXME: Individual line clipping for right-most column is broken for negative angles.
			label_size : ImVec2 = CalcTextSize(label_line, true)
			clip_width : f32 = max_label_width - padding.y; // Using padding.y*2.0f would be symmetrical but hide more text.
			clip_height : f32 = ImMin(label_size.y, column.ClipRect.Max.x - column.WorkMinX - line_off_curr_x)
			clip_r : ImRect; init(&clip_r, window.ClipRect.Min, window.ClipRect.Min + ImVec2{clip_width, clip_height})
			vtx_idx_begin : i32 = i32(draw_list._VtxCurrentIdx)
			PushStyleColor(ImGuiCol_.ImGuiCol_Text, request.TextColor)
			RenderTextEllipsis(draw_list, clip_r.Min, clip_r.Max, clip_r.Max.x, clip_r.Max.x, label_line, len(label_line), &label_size)
			PopStyleColor()
			vtx_idx_end : i32 = i32(draw_list._VtxCurrentIdx)

			// Up<>Down alignment
			available_space : f32 = ImMax(clip_width - label_size.x + ImAbs(padding.x * cos_a) * 2.0 - ImAbs(padding.y * sin_a) * 2.0, 0.0)
			vertical_offset : f32 = available_space * align.y * (flip_label ? -1.0 : 1.0)

			// Rotate and offset label
			pivot_in : ImVec2 = ImVec2{window.ClipRect.Min.x - vertical_offset, window.ClipRect.Min.y + label_size.y}
			pivot_out : ImVec2 = ImVec2{column.WorkMinX, row_r.Max.y}
			line_off_curr_x += flip_label ? -line_off_step_x : line_off_step_x
			pivot_out += unit_right * padding.y
			if flip_label { pivot_out += unit_right * (clip_width - ImMax(f32(0.0), clip_width - label_size.x)) }
			pivot_out.x += flip_label ? line_off_curr_x + line_off_step_x : line_off_curr_x
			ShadeVertsTransformPos(draw_list, vtx_idx_begin, vtx_idx_end, pivot_in, label_cos_a, label_sin_a, pivot_out); // Rotate and offset
			//if (g.IO.KeyShift) { ImDrawList* fg_dl = GetForegroundDrawList(); vtx_idx_begin = fg_dl->_VtxCurrentIdx; fg_dl->AddRect(clip_r.Min, clip_r.Max, IM_COL32(0, 255, 0, 255), 0.0f, 0, 1.0f); ShadeVertsTransformPos(fg_dl, vtx_idx_begin, fg_dl->_VtxCurrentIdx, pivot_in, label_cos_a, label_sin_a, pivot_out); }
		}
	}
	if pass == 1 {
		// Draw border
		AddLine(draw_list, bg_shape[0], bg_shape[3], TableGetColumnBorderCol(table, order_n, column_n))
	}
} }

	PopClipRect()
	PopClipRect()
	table.TempData.AngledHeadersExtraWidth = ImMax(f32(0.0), max_x - table.Columns.Data[table.RightMostEnabledColumn].MaxX)
}

//-------------------------------------------------------------------------
// [SECTION] Tables: Context Menu
//-------------------------------------------------------------------------
// - TableOpenContextMenu() [Internal]
// - TableBeginContextMenuPopup() [Internal]
// - TableDrawDefaultContextMenu() [Internal]
//-------------------------------------------------------------------------

// Use -1 to open menu not specific to a given column.
TableOpenContextMenu :: proc(column_n : i32)
{
	g : ^ImGuiContext = GImGui
	table : ^ImGuiTable = g.CurrentTable
	column_n := column_n
	if column_n == -1 && table.CurrentColumn != -1 {
		// When called within a column automatically use this one (for consistency)
		column_n = table.CurrentColumn
	}
	if column_n == table.ColumnsCount {
		// To facilitate using with TableGetHoveredColumn()
		column_n = -1
	}
	IM_ASSERT(column_n >= -1 && column_n < table.ColumnsCount)
	if (table.Flags & (ImGuiTableFlags_.ImGuiTableFlags_Resizable | ImGuiTableFlags_.ImGuiTableFlags_Reorderable | ImGuiTableFlags_.ImGuiTableFlags_Hideable)) != {} {
		table.IsContextPopupOpen = true
		table.ContextPopupColumn = cast(ImGuiTableColumnIdx) column_n
		table.InstanceInteracted = table.InstanceCurrent
		context_menu_id : ImGuiID = ImHashStr("##ContextMenu", table.ID)
		OpenPopupEx(context_menu_id, ImGuiPopupFlags_.ImGuiPopupFlags_None)
	}
}

TableBeginContextMenuPopup :: proc(table : ^ImGuiTable) -> bool
{
	if !table.IsContextPopupOpen || table.InstanceCurrent != table.InstanceInteracted { return false }
	context_menu_id : ImGuiID = ImHashStr("##ContextMenu", table.ID)
	if BeginPopupEx(context_menu_id, ImGuiWindowFlags_.ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_.ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_.ImGuiWindowFlags_NoSavedSettings) { return true }
	table.IsContextPopupOpen = false
	return false
}

// Output context menu into current window (generally a popup)
// FIXME-TABLE: Ideally this should be writable by the user. Full programmatic access to that data?
// Sections to display are pulled from 'flags_for_section_to_display', which is typically == table->Flags.
// - ImGuiTableFlags_Resizable   -> display Sizing menu items
// - ImGuiTableFlags_Reorderable -> display "Reset Order"
////- ImGuiTableFlags_Sortable   -> display sorting options (disabled)
// - ImGuiTableFlags_Hideable    -> display columns visibility menu items
// It means if you have a custom context menus you can call this section and omit some sections, and add your own.
TableDrawDefaultContextMenu :: proc(table : ^ImGuiTable, flags_for_section_to_display : ImGuiTableFlags)
{
	g : ^ImGuiContext = GImGui
	window : ^ImGuiWindow = g.CurrentWindow
	if window.SkipItems { return }

	want_separator : bool = false
	column_n : i32 = (table.ContextPopupColumn >= 0 && i32(table.ContextPopupColumn) < table.ColumnsCount) ? i32(table.ContextPopupColumn) : -1
	column : ^ImGuiTableColumn = (column_n != -1) ? &table.Columns.Data[column_n] : nil

	// Sizing
	if (flags_for_section_to_display & ImGuiTableFlags_.ImGuiTableFlags_Resizable) != {} {
		if column != nil {
			can_resize : bool = (column.Flags & ImGuiTableColumnFlags_.ImGuiTableColumnFlags_NoResize) == {} && column.IsEnabled
			if MenuItem(LocalizeGetMsg(ImGuiLocKey.ImGuiLocKey_TableSizeOne), "", false, can_resize) {
				// "###SizeOne"
				TableSetColumnWidthAutoSingle(table, column_n)
			}
		}

		size_all_desc : string
		if table.ColumnsEnabledFixedCount == table.ColumnsEnabledCount && (table.Flags & ImGuiTableFlags_.ImGuiTableFlags_SizingMask_) != ImGuiTableFlags_.ImGuiTableFlags_SizingFixedSame {
			// "###SizeAll" All fixed
			size_all_desc = LocalizeGetMsg(ImGuiLocKey.ImGuiLocKey_TableSizeAllFit)
		}
		else {
			// "###SizeAll" All stretch or mixed
			size_all_desc = LocalizeGetMsg(ImGuiLocKey.ImGuiLocKey_TableSizeAllDefault)
		}
		if MenuItem(size_all_desc, "") { TableSetColumnWidthAutoAll(table) }
		want_separator = true
	}

	// Ordering
	if (flags_for_section_to_display & ImGuiTableFlags_.ImGuiTableFlags_Reorderable) != {} {
		if MenuItem(LocalizeGetMsg(ImGuiLocKey.ImGuiLocKey_TableResetOrder), "", false, !table.IsDefaultDisplayOrder) { table.IsResetDisplayOrderRequest = true }
		want_separator = true
	}

	// Reset all (should work but seems unnecessary/noisy to expose?)
	//if (MenuItem("Reset all"))
	//    table->IsResetAllRequest = true;

	// Sorting
	// (modify TableOpenContextMenu() to add _Sortable flag if enabling this)


	// Hiding / Visibility
	if (flags_for_section_to_display & ImGuiTableFlags_.ImGuiTableFlags_Hideable) != {} {
		if want_separator { Separator() }
		want_separator = true

		PushItemFlag(ImGuiItemFlags_.ImGuiItemFlags_AutoClosePopups, false)
		for other_column_n : i32 = 0; other_column_n < table.ColumnsCount; other_column_n += 1 {
			other_column : ^ImGuiTableColumn = &table.Columns.Data[other_column_n]
			if (other_column.Flags & ImGuiTableColumnFlags_.ImGuiTableColumnFlags_Disabled) != {} { continue }

			name : string = TableGetColumnName(table, other_column_n)
			if name == "" || name[0] == 0 { name = "<Unknown>" }

			// Make sure we can't hide the last active column
			menu_item_active : bool = (other_column.Flags & ImGuiTableColumnFlags_.ImGuiTableColumnFlags_NoHide) != {} ? false : true
			if other_column.IsUserEnabled && table.ColumnsEnabledCount <= 1 { menu_item_active = false }
			if MenuItem(name, "", other_column.IsUserEnabled, menu_item_active) { other_column.IsUserEnabledNextFrame = !other_column.IsUserEnabled }
		}

		PopItemFlag()
	}
}

//-------------------------------------------------------------------------
// [SECTION] Tables: Settings (.ini data)
//-------------------------------------------------------------------------
// FIXME: The binding/finding/creating flow are too confusing.
//-------------------------------------------------------------------------
// - TableSettingsInit() [Internal]
// - TableSettingsCalcChunkSize() [Internal]
// - TableSettingsCreate() [Internal]
// - TableSettingsFindByID() [Internal]
// - TableGetBoundSettings() [Internal]
// - TableResetSettings()
// - TableSaveSettings() [Internal]
// - TableLoadSettings() [Internal]
// - TableSettingsHandler_ClearAll() [Internal]
// - TableSettingsHandler_ApplyAll() [Internal]
// - TableSettingsHandler_ReadOpen() [Internal]
// - TableSettingsHandler_ReadLine() [Internal]
// - TableSettingsHandler_WriteAll() [Internal]
// - TableSettingsInstallHandler() [Internal]
//-------------------------------------------------------------------------
// [Init] 1: TableSettingsHandler_ReadXXXX()   Load and parse .ini file into TableSettings.
// [Main] 2: TableLoadSettings()               When table is created, bind Table to TableSettings, serialize TableSettings data into Table.
// [Main] 3: TableSaveSettings()               When table properties are modified, serialize Table data into bound or new TableSettings, mark .ini as dirty.
// [Main] 4: TableSettingsHandler_WriteAll()   When .ini file is dirty (which can come from other source), save TableSettings into .ini file.
//-------------------------------------------------------------------------

// Clear and initialize empty settings instance
TableSettingsInit :: proc(settings : ^ImGuiTableSettings, id : ImGuiID, columns_count : i32, columns_count_max : i32)
{
	init(settings)
	settings_column := GetColumnSettings(settings)
	for n : i32 = 0; n < columns_count_max; n, settings_column = n + 1, settings_column[1:] { init(settings_column) }

	settings.ID = id
	settings.ColumnsCount = cast(ImGuiTableColumnIdx) columns_count
	settings.ColumnsCountMax = cast(ImGuiTableColumnIdx) columns_count_max
	settings.WantApply = true
}

TableSettingsCalcChunkSize :: proc(columns_count : i32) -> uint
{
	return size_of(ImGuiTableSettings) + cast(uint) columns_count * size_of(ImGuiTableColumnSettings)
}

TableSettingsCreate :: proc(id : ImGuiID, columns_count : i32) -> ^ImGuiTableSettings
{
	g : ^ImGuiContext = GImGui
	settings : ^ImGuiTableSettings = alloc_chunk(&g.SettingsTables, TableSettingsCalcChunkSize(columns_count))
	TableSettingsInit(settings, id, columns_count, columns_count)
	return settings
}

// Find existing settings
TableSettingsFindByID :: proc(id : ImGuiID) -> ^ImGuiTableSettings
{
	// FIXME-OPT: Might want to store a lookup map for this?
	g : ^ImGuiContext = GImGui
	for settings : ^ImGuiTableSettings = begin(&g.SettingsTables); settings != nil; settings = next_chunk(&g.SettingsTables, settings) { if settings.ID == id { return settings } }

	return nil
}

// Get settings for a given table, NULL if none
TableGetBoundSettings :: proc(table : ^ImGuiTable) -> ^ImGuiTableSettings
{
	if table.SettingsOffset != -1 {
		g : ^ImGuiContext = GImGui
		settings : ^ImGuiTableSettings = ptr_from_offset(&g.SettingsTables, table.SettingsOffset)
		IM_ASSERT(settings.ID == table.ID)
		if i32(settings.ColumnsCountMax) >= table.ColumnsCount {
			// OK
			return settings
		}
		settings.ID = 0; // Invalidate storage, we won't fit because of a count change
	}
	return nil
}

// Restore initial state of table (with or without saved settings)
TableResetSettings :: proc(table : ^ImGuiTable)
{
	table.IsSettingsDirty = true; table.IsInitializing = table.IsSettingsDirty
	table.IsResetAllRequest = false
	table.IsSettingsRequestLoad = false; // Don't reload from ini
	table.SettingsLoadedFlags = ImGuiTableFlags_.ImGuiTableFlags_None; // Mark as nothing loaded so our initialized data becomes authoritative
}

TableSaveSettings :: proc(table : ^ImGuiTable)
{
	table.IsSettingsDirty = false
	if (table.Flags & ImGuiTableFlags_.ImGuiTableFlags_NoSavedSettings) != {} { return }

	// Bind or create settings data
	g : ^ImGuiContext = GImGui
	settings : ^ImGuiTableSettings = TableGetBoundSettings(table)
	if settings == nil {
		settings = TableSettingsCreate(table.ID, table.ColumnsCount)
		table.SettingsOffset = offset_from_ptr(&g.SettingsTables, settings)
	}
	settings.ColumnsCount = cast(ImGuiTableColumnIdx) table.ColumnsCount

	// Serialize ImGuiTable/ImGuiTableColumn into ImGuiTableSettings/ImGuiTableColumnSettings
	IM_ASSERT(settings.ID == table.ID)
	IM_ASSERT(i32(settings.ColumnsCount) == table.ColumnsCount && settings.ColumnsCountMax >= settings.ColumnsCount)
	column : ^ImGuiTableColumn = table.Columns.Data
	column_settings : ^ImGuiTableColumnSettings = GetColumnSettings(settings)

	save_ref_scale : bool = false
	settings.SaveFlags = ImGuiTableFlags_.ImGuiTableFlags_None
	for n : i32 = 0; n < table.ColumnsCount; n, column, column_settings = n + 1, mem.ptr_offset(column, 1), mem.ptr_offset(column_settings, 1) {
		width_or_weight : f32 = (column.Flags & ImGuiTableColumnFlags_.ImGuiTableColumnFlags_WidthStretch) != {} ? column.StretchWeight : column.WidthRequest
		column_settings.WidthOrWeight = width_or_weight
		column_settings.Index = cast(ImGuiTableColumnIdx) n
		column_settings.DisplayOrder = column.DisplayOrder
		column_settings.SortOrder = column.SortOrder
		column_settings.SortDirection = column.SortDirection
		column_settings.IsEnabled = column.IsUserEnabled
		column_settings.IsStretch = (column.Flags & ImGuiTableColumnFlags_.ImGuiTableColumnFlags_WidthStretch) != {}
		if (column.Flags & ImGuiTableColumnFlags_.ImGuiTableColumnFlags_WidthStretch) == {} { save_ref_scale = true }

		// We skip saving some data in the .ini file when they are unnecessary to restore our state.
		// Note that fixed width where initial width was derived from auto-fit will always be saved as InitStretchWeightOrWidth will be 0.0f.
		// FIXME-TABLE: We don't have logic to easily compare SortOrder to DefaultSortOrder yet so it's always saved when present.
		if width_or_weight != column.InitStretchWeightOrWidth { settings.SaveFlags |= ImGuiTableFlags_.ImGuiTableFlags_Resizable }
		if i32(column.DisplayOrder) != n { settings.SaveFlags |= ImGuiTableFlags_.ImGuiTableFlags_Reorderable }
		if column.SortOrder != -1 { settings.SaveFlags |= ImGuiTableFlags_.ImGuiTableFlags_Sortable }
		if column.IsUserEnabled != ((column.Flags & ImGuiTableColumnFlags_.ImGuiTableColumnFlags_DefaultHide) == {}) { settings.SaveFlags |= ImGuiTableFlags_.ImGuiTableFlags_Hideable }
	}

	settings.SaveFlags &= table.Flags
	settings.RefScale = save_ref_scale ? table.RefScale : 0.0

	MarkIniSettingsDirty()
}

TableLoadSettings :: proc(table : ^ImGuiTable)
{
	g : ^ImGuiContext = GImGui
	table.IsSettingsRequestLoad = false
	if (table.Flags & ImGuiTableFlags_.ImGuiTableFlags_NoSavedSettings) != {} { return }

	// Bind settings
	settings : ^ImGuiTableSettings
	if table.SettingsOffset == -1 {
		settings = TableSettingsFindByID(table.ID)
		if settings == nil { return }
		if i32(settings.ColumnsCount) != table.ColumnsCount {
			// Allow settings if columns count changed. We could otherwise decide to return...
			table.IsSettingsDirty = true
		}
		table.SettingsOffset = offset_from_ptr(&g.SettingsTables, settings)
	}
	else {
		settings = TableGetBoundSettings(table)
	}

	table.SettingsLoadedFlags = settings.SaveFlags
	table.RefScale = settings.RefScale

	// Serialize ImGuiTableSettings/ImGuiTableColumnSettings into ImGuiTable/ImGuiTableColumn
	column_settings : ^ImGuiTableColumnSettings = GetColumnSettings(settings)
	display_order_mask : ImU64 = 0
	for data_n : i32 = 0; data_n < i32(settings.ColumnsCount); data_n, column_settings = data_n + 1, mem.ptr_offset(column_settings, 1) {
		column_n : i32 = i32(column_settings.Index)
		if column_n < 0 || column_n >= table.ColumnsCount { continue }

		column : ^ImGuiTableColumn = &table.Columns.Data[column_n]
		if (settings.SaveFlags & ImGuiTableFlags_.ImGuiTableFlags_Resizable) != {} {
			if column_settings.IsStretch != false { column.StretchWeight = column_settings.WidthOrWeight }
			else { column.WidthRequest = column_settings.WidthOrWeight }
			column.AutoFitQueue = 0x00
		}
		if (settings.SaveFlags & ImGuiTableFlags_.ImGuiTableFlags_Reorderable) != {} { column.DisplayOrder = column_settings.DisplayOrder }
		else { column.DisplayOrder = cast(ImGuiTableColumnIdx) column_n }
		display_order_mask |= cast(ImU64) 1 << u32(column.DisplayOrder)
		column.IsUserEnabledNextFrame = column_settings.IsEnabled; column.IsUserEnabled = column.IsUserEnabledNextFrame
		column.SortOrder = column_settings.SortOrder
		column.SortDirection = column_settings.SortDirection
	}

	// Validate and fix invalid display order data
	expected_display_order_mask : ImU64 = (settings.ColumnsCount == 64) ? ~ImU64(0) : (cast(ImU64) 1 << u32(settings.ColumnsCount)) - 1
	if display_order_mask != expected_display_order_mask { for column_n : i32 = 0; column_n < table.ColumnsCount; column_n += 1 { table.Columns.Data[column_n].DisplayOrder = cast(ImGuiTableColumnIdx) column_n } }

	// Rebuild index
	for column_n : i32 = 0; column_n < table.ColumnsCount; column_n += 1 { table.DisplayOrderToIndex.Data[table.Columns.Data[column_n].DisplayOrder] = cast(ImGuiTableColumnIdx) column_n }
}

TableSettingsHandler_ClearAll :: proc(ctx : ^ImGuiContext, _ : ^ImGuiSettingsHandler)
{
	g : ^ImGuiContext = ctx
	for i : i32 = 0; i != GetMapSize(&g.Tables); i += 1 { if table : ^ImGuiTable = TryGetMapData(&g.Tables, i); table != nil { table.SettingsOffset = -1 } }

	clear(&g.SettingsTables)
}

// Apply to existing windows (if any)
TableSettingsHandler_ApplyAll :: proc(ctx : ^ImGuiContext, _ : ^ImGuiSettingsHandler)
{
	g : ^ImGuiContext = ctx
	for i : i32 = 0; i != GetMapSize(&g.Tables); i += 1 { if table : ^ImGuiTable = TryGetMapData(&g.Tables, i); table != nil {
	table.IsSettingsRequestLoad = true
	table.SettingsOffset = -1
} }
}

TableSettingsHandler_ReadOpen :: proc(_ : ^ImGuiContext, _ : ^ImGuiSettingsHandler, name : string) -> rawptr
{
	o  : int; _id, _columns_count : i64
	if parse_int_pair(name, &o, &_id, 16, &_columns_count, 10) { return nil }
	id := ImGuiID(_id)
	columns_count := i32(_columns_count)

	if settings : ^ImGuiTableSettings = TableSettingsFindByID(id); settings != nil {
		if i32(settings.ColumnsCountMax) >= columns_count {
			TableSettingsInit(settings, id, columns_count, i32(settings.ColumnsCountMax)); // Recycle
			return settings
		}
		settings.ID = 0; // Invalidate storage, we won't fit because of a count change
	}
	return TableSettingsCreate(id, columns_count)
}

TableSettingsHandler_ReadLine :: proc(_ : ^ImGuiContext, _ : ^ImGuiSettingsHandler, entry : rawptr, line : string)
{
	// "Column 0  UserID=0x42AD2D21 Width=100 Visible=1 Order=0 Sort=0v"
	settings := cast(^ImGuiTableSettings) entry
	f : f32 = 0.0; o : int
	column_n : i64 = 0; r : i32 = 0; n : i64 = 0

	if parse_float_prefixed(line, &o, "RefScale=", &f, 10) { settings.RefScale = f; return }

	if parse_int_prefixed(line, &o, "Column ", &column_n, 10) {
		if column_n < 0 || column_n >= i64(settings.ColumnsCount) { return }
		parse_skip_blank(line, &o)
		c : u8 = 0
		column : ^ImGuiTableColumnSettings = GetColumnSettings(settings)[column_n:]
		column.Index = cast(ImGuiTableColumnIdx) column_n
		if parse_int_prefixed(line, &o, "UserID=", &n, 16) { parse_skip_blank(line, &o); column.UserID = cast(ImGuiID) n }
		if parse_int_prefixed(line, &o, "Width=", &n, 10) { parse_skip_blank(line, &o); column.WidthOrWeight = cast(f32) n; column.IsStretch = false; settings.SaveFlags |= ImGuiTableFlags_.ImGuiTableFlags_Resizable }
		if parse_float_prefixed(line, &o, "Weight=", &f, 10) { parse_skip_blank(line, &o); column.WidthOrWeight = f; column.IsStretch = true; settings.SaveFlags |= ImGuiTableFlags_.ImGuiTableFlags_Resizable }
		if parse_int_prefixed(line, &o, "Visible=", &n, 10) { parse_skip_blank(line, &o); column.IsEnabled = cast(bool) n; settings.SaveFlags |= ImGuiTableFlags_.ImGuiTableFlags_Hideable }
		if parse_int_prefixed(line, &o, "Order=", &n, 10) { parse_skip_blank(line, &o); column.DisplayOrder = cast(ImGuiTableColumnIdx) n; settings.SaveFlags |= ImGuiTableFlags_.ImGuiTableFlags_Reorderable }
		if parse_int_prefixed(line, &o, "Sort=", &n, 10) && parse_char(line, &o, &c) { parse_skip_blank(line, &o); column.SortOrder = cast(ImGuiTableColumnIdx) n; column.SortDirection = (c == '^') ? ImGuiSortDirection.ImGuiSortDirection_Descending : ImGuiSortDirection.ImGuiSortDirection_Ascending; settings.SaveFlags |= ImGuiTableFlags_.ImGuiTableFlags_Sortable }
	}
}

TableSettingsHandler_WriteAll :: proc(ctx : ^ImGuiContext, handler : ^ImGuiSettingsHandler, buf : ^ImGuiTextBuffer)
{
	g : ^ImGuiContext = ctx
	for settings : ^ImGuiTableSettings = begin(&g.SettingsTables); settings != nil; settings = next_chunk(&g.SettingsTables, settings) {
		if settings.ID == 0 {
			// Skip ditched settings
			continue
		}

		// TableSaveSettings() may clear some of those flags when we establish that the data can be stripped
		// (e.g. Order was unchanged)
		save_size : bool = (settings.SaveFlags & ImGuiTableFlags_.ImGuiTableFlags_Resizable) != {}
		save_visible : bool = (settings.SaveFlags & ImGuiTableFlags_.ImGuiTableFlags_Hideable) != {}
		save_order : bool = (settings.SaveFlags & ImGuiTableFlags_.ImGuiTableFlags_Reorderable) != {}
		save_sort : bool = (settings.SaveFlags & ImGuiTableFlags_.ImGuiTableFlags_Sortable) != {}
		if !save_size && !save_visible && !save_order && !save_sort { continue }

		reserve(buf, size(buf) + 30 + i32(settings.ColumnsCount) * 50); // ballpark reserve
		appendf(buf, "[%s][0x%08X,%d]\n", handler.TypeName, settings.ID, settings.ColumnsCount)
		if settings.RefScale != 0.0 { appendf(buf, "RefScale=%g\n", settings.RefScale) }
		column : ^ImGuiTableColumnSettings = GetColumnSettings(settings)
		for column_n : i32 = 0; column_n < i32(settings.ColumnsCount); column_n, column = column_n + 1, mem.ptr_offset(column, 1) {
			// "Column 0  UserID=0x42AD2D21 Width=100 Visible=1 Order=0 Sort=0v"
			save_column : bool = column.UserID != 0 || save_size || save_visible || save_order || (save_sort && column.SortOrder != -1)
			if !save_column { continue }
			appendf(buf, "Column %-2d", column_n)
			if column.UserID != 0 { appendf(buf, " UserID=%08X", column.UserID) }
			if save_size && column.IsStretch { appendf(buf, " Weight=%.4f", column.WidthOrWeight) }
			if save_size && column.IsStretch == false { appendf(buf, " Width=%d", cast(i32) column.WidthOrWeight) }
			if save_visible { appendf(buf, " Visible=%d", column.IsEnabled) }
			if save_order { appendf(buf, " Order=%d", column.DisplayOrder) }
			if save_sort && column.SortOrder != -1 { appendf(buf, " Sort=%d%c", column.SortOrder, (column.SortDirection == ImGuiSortDirection.ImGuiSortDirection_Ascending) ? 'v' : '^') }
			append(buf, "\n")
		}

		append(buf, "\n")
	}
}

TableSettingsAddSettingsHandler :: proc()
{
	ini_handler : ImGuiSettingsHandler
	ini_handler.TypeName = "Table"
	ini_handler.TypeHash = ImHashStr("Table")
	ini_handler.ClearAllFn = TableSettingsHandler_ClearAll
	ini_handler.ReadOpenFn = TableSettingsHandler_ReadOpen
	ini_handler.ReadLineFn = TableSettingsHandler_ReadLine
	ini_handler.ApplyAllFn = TableSettingsHandler_ApplyAll
	ini_handler.WriteAllFn = TableSettingsHandler_WriteAll
	AddSettingsHandler(&ini_handler)
}

//-------------------------------------------------------------------------
// [SECTION] Tables: Garbage Collection
//-------------------------------------------------------------------------
// - TableRemove() [Internal]
// - TableGcCompactTransientBuffers() [Internal]
// - TableGcCompactSettings() [Internal]
//-------------------------------------------------------------------------

// Remove Table (currently only used by TestEngine)
TableRemove :: proc(table : ^ImGuiTable)
{
	//IMGUI_DEBUG_PRINT("TableRemove() id=0x%08X\n", table->ID);
	g : ^ImGuiContext = GImGui
	table_idx : i32 = GetIndex(&g.Tables, table)
	//memset(table->RawData.Data, 0, table->RawData.size_in_bytes());
	//memset(table, 0, sizeof(ImGuiTable));
	Remove(&g.Tables, table.ID, table)
	g.TablesLastTimeActive.Data[table_idx] = -1.0
}

// Free up/compact internal Table buffers for when it gets unused
TableGcCompactTransientBuffers_tab :: proc(table : ^ImGuiTable)
{
	//IMGUI_DEBUG_PRINT("TableGcCompactTransientBuffers() id=0x%08X\n", table->ID);
	g : ^ImGuiContext = GImGui
	IM_ASSERT(table.MemoryCompacted == false)
	table.SortSpecs.Specs = nil
	clear(&table.SortSpecsMulti)
	table.IsSortSpecsDirty = true; // FIXME: In theory shouldn't have to leak into user performing a sort on resume.
	clear(&table.ColumnsNames)
	table.MemoryCompacted = true
	for n : i32 = 0; n < table.ColumnsCount; n += 1 { table.Columns.Data[n].NameOffset = -1 }

	g.TablesLastTimeActive.Data[GetIndex(&g.Tables, table)] = -1.0
}

TableGcCompactTransientBuffers_tmp :: proc(temp_data : ^ImGuiTableTempData)
{
	ClearFreeMemory(&temp_data.DrawSplitter)
	temp_data.LastTimeActive = -1.0
}

// Compact and remove unused settings data (currently only used by TestEngine)
TableGcCompactSettings :: proc()
{
	g : ^ImGuiContext = GImGui
	required_memory : i32 = 0
	for settings : ^ImGuiTableSettings = begin(&g.SettingsTables); settings != nil; settings = next_chunk(&g.SettingsTables, settings) { if settings.ID != 0 { required_memory += cast(i32) TableSettingsCalcChunkSize(i32(settings.ColumnsCount)) } }

	if required_memory == g.SettingsTables.Buf.Size { return }
	new_chunk_stream : ImChunkStream(ImGuiTableSettings)
	reserve(&new_chunk_stream.Buf, required_memory)
	for settings : ^ImGuiTableSettings = begin(&g.SettingsTables); settings != nil; settings = next_chunk(&g.SettingsTables, settings) { if settings.ID != 0 { memcpy(alloc_chunk(&new_chunk_stream, TableSettingsCalcChunkSize(i32(settings.ColumnsCount))), settings, cast(int)TableSettingsCalcChunkSize(i32(settings.ColumnsCount))) } }

	swap(&g.SettingsTables, &new_chunk_stream)
}


//-------------------------------------------------------------------------
// [SECTION] Tables: Debugging
//-------------------------------------------------------------------------
// - DebugNodeTable() [Internal]
//-------------------------------------------------------------------------

when ! IMGUI_DISABLE_DEBUG_TOOLS { /* @gen ifndef */

DebugNodeTableGetSizingPolicyDesc :: proc(sizing_policy : ImGuiTableFlags) -> string
{
	sizing_policy := sizing_policy & ImGuiTableFlags_.ImGuiTableFlags_SizingMask_
	if sizing_policy == ImGuiTableFlags_.ImGuiTableFlags_SizingFixedFit { return "FixedFit" }
	if sizing_policy == ImGuiTableFlags_.ImGuiTableFlags_SizingFixedSame { return "FixedSame" }
	if sizing_policy == ImGuiTableFlags_.ImGuiTableFlags_SizingStretchProp { return "StretchProp" }
	if sizing_policy == ImGuiTableFlags_.ImGuiTableFlags_SizingStretchSame { return "StretchSame" }
	return "N/A"
}

DebugNodeTable :: proc(table : ^ImGuiTable)
{
	g : ^ImGuiContext = GImGui
	is_active : bool = (table.LastFrameActive >= g.FrameCount - 2); // Note that fully clipped early out scrolling tables will appear as inactive here.
	if !is_active { PushStyleColor(ImGuiCol_.ImGuiCol_Text, GetStyleColorVec4(ImGuiCol_.ImGuiCol_TextDisabled)) }
	open : bool = TreeNode(table, "Table 0x%08X (%d columns, in '%s')%s", table.ID, table.ColumnsCount, table.OuterWindow.Name, is_active ? "" : " *Inactive*")
	if !is_active { PopStyleColor() }
	if IsItemHovered() { AddRect(GetForegroundDrawList(), table.OuterRect.Min, table.OuterRect.Max, IM_COL32(255, 255, 0, 255)) }
	if IsItemVisible() && table.HoveredColumnBody != -1 { AddRect(GetForegroundDrawList(), GetItemRectMin(), GetItemRectMax(), IM_COL32(255, 255, 0, 255)) }
	if !open { return }
	if table.InstanceCurrent > 0 { Text("** %d instances of same table! Some data below will refer to last instance.", table.InstanceCurrent + 1) }
	if g.IO.ConfigDebugIsDebuggerPresent {
		if DebugBreakButton("**DebugBreak**", "in BeginTable()") { g.DebugBreakInTable = table.ID }
		SameLine()
	}

	clear_settings : bool = SmallButton("Clear settings")
	BulletText("OuterRect: Pos: (%.1f,%.1f) Size: (%.1f,%.1f) Sizing: '%s'", table.OuterRect.Min.x, table.OuterRect.Min.y, GetWidth(table.OuterRect), GetHeight(table.OuterRect), DebugNodeTableGetSizingPolicyDesc(table.Flags))
	BulletText("ColumnsGivenWidth: %.1f, ColumnsAutoFitWidth: %.1f, InnerWidth: %.1f%s", table.ColumnsGivenWidth, table.ColumnsAutoFitWidth, table.InnerWidth, table.InnerWidth == 0.0 ? " (auto)" : "")
	BulletText("CellPaddingX: %.1f, CellSpacingX: %.1f/%.1f, OuterPaddingX: %.1f", table.CellPaddingX, table.CellSpacingX1, table.CellSpacingX2, table.OuterPaddingX)
	BulletText("HoveredColumnBody: %d, HoveredColumnBorder: %d", table.HoveredColumnBody, table.HoveredColumnBorder)
	BulletText("ResizedColumn: %d, ReorderColumn: %d, HeldHeaderColumn: %d", table.ResizedColumn, table.ReorderColumn, table.HeldHeaderColumn)
	for n : i32 = 0; n < i32(table.InstanceCurrent) + 1; n += 1 {
		table_instance : ^ImGuiTableInstanceData = TableGetInstanceData(table, n)
		BulletText("Instance %d: HoveredRow: %d, LastOuterHeight: %.2f", n, table_instance.HoveredRowLast, table_instance.LastOuterHeight)
	}

	//BulletText("BgDrawChannels: %d/%d", 0, table->BgDrawChannelUnfrozen);
	sum_weights : f32 = 0.0
	for n : i32 = 0; n < table.ColumnsCount; n += 1 { if (table.Columns.Data[n].Flags & ImGuiTableColumnFlags_.ImGuiTableColumnFlags_WidthStretch) != {} { sum_weights += table.Columns.Data[n].StretchWeight } }

	for n : i32 = 0; n < table.ColumnsCount; n += 1 {
		column : ^ImGuiTableColumn = &table.Columns.Data[n]
		name : string = TableGetColumnName(table, n)
		buf : [512]u8
		l := ImFormatString(buf[:], "Sort: %d%s, UserID: 0x%08X, Flags: 0x%04X: %s%s%s..", n, column.DisplayOrder, name, column.MinX - table.WorkRect.Min.x, column.MaxX - table.WorkRect.Min.x, (n < i32(table.FreezeColumnsRequest)) ? " (Frozen)" : "", column.IsEnabled, column.IsVisibleX, column.IsVisibleY, column.IsRequestOutput, column.IsSkipItems, column.DrawChannelFrozen, column.DrawChannelUnfrozen, column.WidthGiven, column.WidthRequest, column.WidthAuto, column.StretchWeight, column.StretchWeight > 0.0 ? (column.StretchWeight / sum_weights) * 100.0 : 0.0, column.MinX, column.MaxX, column.MaxX - column.MinX, column.ClipRect.Min.x, column.ClipRect.Max.x, column.ClipRect.Max.x - column.ClipRect.Min.x, column.ContentMaxXFrozen - column.WorkMinX, column.ContentMaxXUnfrozen - column.WorkMinX, column.ContentMaxXHeadersUsed - column.WorkMinX, column.ContentMaxXHeadersIdeal - column.WorkMinX, column.SortOrder, (column.SortDirection == ImGuiSortDirection.ImGuiSortDirection_Ascending) ? " (Asc)" : (column.SortDirection == ImGuiSortDirection.ImGuiSortDirection_Descending) ? " (Des)" : "", column.UserID, column.Flags, (column.Flags & ImGuiTableColumnFlags_.ImGuiTableColumnFlags_WidthStretch) != {} ? "WidthStretch " : "", (column.Flags & ImGuiTableColumnFlags_.ImGuiTableColumnFlags_WidthFixed) != {} ? "WidthFixed " : "", (column.Flags & ImGuiTableColumnFlags_.ImGuiTableColumnFlags_NoResize) != {} ? "NoResize " : "")
		Bullet()
		Selectable(string_from_slice(buf[:l], false))
		if IsItemHovered() {
			r : ImRect; init(&r, column.MinX, table.OuterRect.Min.y, column.MaxX, table.OuterRect.Max.y)
			AddRect(GetForegroundDrawList(), r.Min, r.Max, IM_COL32(255, 255, 0, 255))
		}
	}

	if settings : ^ImGuiTableSettings = TableGetBoundSettings(table); settings != nil { DebugNodeTableSettings(settings) }
	if clear_settings { table.IsResetAllRequest = true }
	TreePop()
}

DebugNodeTableSettings :: proc(settings : ^ImGuiTableSettings)
{
	if !TreeNode(cast(rawptr) cast(uintptr) settings.ID, "Settings 0x%08X (%d columns)", settings.ID, settings.ColumnsCount) { return }
	BulletText("SaveFlags: 0x%08X", settings.SaveFlags)
	BulletText("ColumnsCount: %d (max %d)", settings.ColumnsCount, settings.ColumnsCountMax)
	for n : i16 = 0; n < settings.ColumnsCount; n += 1 {
		column_settings : ^ImGuiTableColumnSettings = &GetColumnSettings(settings)[n]
		sort_dir : ImGuiSortDirection = (column_settings.SortOrder != -1) ? cast(ImGuiSortDirection) column_settings.SortDirection : ImGuiSortDirection.ImGuiSortDirection_None
		BulletText("Column %d Order %d SortOrder %d %s Vis %d %s %7.3f UserID 0x%08X", n, column_settings.DisplayOrder, column_settings.SortOrder, (sort_dir == ImGuiSortDirection.ImGuiSortDirection_Ascending) ? "Asc" : (sort_dir == ImGuiSortDirection.ImGuiSortDirection_Descending) ? "Des" : "---", column_settings.IsEnabled, column_settings.IsStretch != false ? "Weight" : "Width ", column_settings.WidthOrWeight, column_settings.UserID)
	}

	TreePop()
}

} else when !IMGUI_DISABLE_DEBUG_TOOLS { // #ifndef IMGUI_DISABLE_DEBUG_TOOLS

DebugNodeTable :: proc(_ : ^ImGuiTable) { }
DebugNodeTableSettings :: proc(_ : ^ImGuiTableSettings) { }

} // preproc endif


//-------------------------------------------------------------------------
// [SECTION] Columns, BeginColumns, EndColumns, etc.
// (This is a legacy API, prefer using BeginTable/EndTable!)
//-------------------------------------------------------------------------
// FIXME: sizing is lossy when columns width is very small (default width may turn negative etc.)
//-------------------------------------------------------------------------
// - SetWindowClipRectBeforeSetChannel() [Internal]
// - GetColumnIndex()
// - GetColumnsCount()
// - GetColumnOffset()
// - GetColumnWidth()
// - SetColumnOffset()
// - SetColumnWidth()
// - PushColumnClipRect() [Internal]
// - PushColumnsBackground() [Internal]
// - PopColumnsBackground() [Internal]
// - FindOrCreateColumns() [Internal]
// - GetColumnsID() [Internal]
// - BeginColumns()
// - NextColumn()
// - EndColumns()
// - Columns()
//-------------------------------------------------------------------------

// [Internal] Small optimization to avoid calls to PopClipRect/SetCurrentChannel/PushClipRect in sequences,
// they would meddle many times with the underlying ImDrawCmd.
// Instead, we do a preemptive overwrite of clipping rectangle _without_ altering the command-buffer and let
// the subsequent single call to SetCurrentChannel() does it things once.
SetWindowClipRectBeforeSetChannel :: proc(window : ^ImGuiWindow, clip_rect : ImRect)
{
	clip_rect_vec4 : ImVec4 = ToVec4(clip_rect)
	window.ClipRect = clip_rect
	window.DrawList._CmdHeader.ClipRect = clip_rect_vec4
	window.DrawList._ClipRectStack.Data[window.DrawList._ClipRectStack.Size - 1] = clip_rect_vec4
}

GetColumnIndex :: proc() -> i32
{
	window : ^ImGuiWindow = GetCurrentWindowRead()
	return window.DC.CurrentColumns != nil ? window.DC.CurrentColumns.Current : 0
}

GetColumnsCount :: proc() -> i32
{
	window : ^ImGuiWindow = GetCurrentWindowRead()
	return window.DC.CurrentColumns != nil ? window.DC.CurrentColumns.Count : 1
}

GetColumnOffsetFromNorm :: proc(columns : ^ImGuiOldColumns, offset_norm : f32) -> f32
{
	return offset_norm * (columns.OffMaxX - columns.OffMinX)
}

GetColumnNormFromOffset :: proc(columns : ^ImGuiOldColumns, offset : f32) -> f32
{
	return offset / (columns.OffMaxX - columns.OffMinX)
}

COLUMNS_HIT_RECT_HALF_THICKNESS : f32 = 4.0

GetDraggedColumnOffset :: proc(columns : ^ImGuiOldColumns, column_index : i32) -> f32
{
	// Active (dragged) column always follow mouse. The reason we need this is that dragging a column to the right edge of an auto-resizing
	// window creates a feedback loop because we store normalized positions. So while dragging we enforce absolute positioning.
	g : ^ImGuiContext = GImGui
	window : ^ImGuiWindow = g.CurrentWindow
	IM_ASSERT(column_index > 0); // We are not supposed to drag column 0.
	IM_ASSERT(g.ActiveId == columns.ID + ImGuiID(column_index))

	x : f32 = g.IO.MousePos.x - g.ActiveIdClickOffset.x + ImTrunc(COLUMNS_HIT_RECT_HALF_THICKNESS * g.CurrentDpiScale) - window.Pos.x
	x = ImMax(x, GetColumnOffset(column_index - 1) + g.Style.ColumnsMinSpacing)
	if (columns.Flags & ImGuiOldColumnFlags_.ImGuiOldColumnFlags_NoPreserveWidths) != {} { x = ImMin(x, GetColumnOffset(column_index + 1) - g.Style.ColumnsMinSpacing) }

	return x
}

GetColumnOffset :: proc(column_index : i32) -> f32
{
	window : ^ImGuiWindow = GetCurrentWindowRead()
	columns : ^ImGuiOldColumns = window.DC.CurrentColumns
	if columns == nil { return 0.0 }

	column_index := column_index
	if column_index < 0 { column_index = columns.Current }
	IM_ASSERT(column_index < columns.Columns.Size)

	t : f32 = columns.Columns.Data[column_index].OffsetNorm
	x_offset : f32 = ImLerp(columns.OffMinX, columns.OffMaxX, t)
	return x_offset
}

GetColumnWidthEx :: proc(columns : ^ImGuiOldColumns, column_index : i32, before_resize : bool = false) -> f32
{
	column_index := column_index
	if column_index < 0 { column_index = columns.Current }

	offset_norm : f32
	if before_resize { offset_norm = columns.Columns.Data[column_index + 1].OffsetNormBeforeResize - columns.Columns.Data[column_index].OffsetNormBeforeResize }
	else { offset_norm = columns.Columns.Data[column_index + 1].OffsetNorm - columns.Columns.Data[column_index].OffsetNorm }
	return GetColumnOffsetFromNorm(columns, offset_norm)
}

GetColumnWidth :: proc(column_index : i32) -> f32
{
	g : ^ImGuiContext = GImGui
	window : ^ImGuiWindow = g.CurrentWindow
	columns : ^ImGuiOldColumns = window.DC.CurrentColumns
	if columns == nil { return GetContentRegionAvail().x }

	column_index := column_index
	if column_index < 0 { column_index = columns.Current }
	return GetColumnOffsetFromNorm(columns, columns.Columns.Data[column_index + 1].OffsetNorm - columns.Columns.Data[column_index].OffsetNorm)
}

SetColumnOffset :: proc(column_index : i32, offset : f32)
{
	g : ^ImGuiContext = GImGui
	window : ^ImGuiWindow = g.CurrentWindow
	columns : ^ImGuiOldColumns = window.DC.CurrentColumns
	IM_ASSERT(columns != nil)

	column_index := column_index
	if column_index < 0 { column_index = columns.Current }
	IM_ASSERT(column_index < columns.Columns.Size)

	preserve_width : bool = (columns.Flags & ImGuiOldColumnFlags_.ImGuiOldColumnFlags_NoPreserveWidths) == {} && (column_index < columns.Count - 1)
	width : f32 = preserve_width ? GetColumnWidthEx(columns, column_index, columns.IsBeingResized) : 0.0

	offset := offset
	if (columns.Flags & ImGuiOldColumnFlags_.ImGuiOldColumnFlags_NoForceWithinWindow) == {} { offset = ImMin(offset, columns.OffMaxX - g.Style.ColumnsMinSpacing * f32(columns.Count - column_index)) }
	columns.Columns.Data[column_index].OffsetNorm = GetColumnNormFromOffset(columns, offset - columns.OffMinX)

	if preserve_width { SetColumnOffset(column_index + 1, offset + ImMax(g.Style.ColumnsMinSpacing, width)) }
}

SetColumnWidth :: proc(column_index : i32, width : f32)
{
	window : ^ImGuiWindow = GetCurrentWindowRead()
	columns : ^ImGuiOldColumns = window.DC.CurrentColumns
	IM_ASSERT(columns != nil)

	column_index := column_index
	if column_index < 0 { column_index = columns.Current }
	SetColumnOffset(column_index + 1, GetColumnOffset(column_index) + width)
}

PushColumnClipRect :: proc(column_index : i32)
{
	window : ^ImGuiWindow = GetCurrentWindowRead()
	columns : ^ImGuiOldColumns = window.DC.CurrentColumns
	column_index := column_index
	if column_index < 0 { column_index = columns.Current }

	column : ^ImGuiOldColumnData = &columns.Columns.Data[column_index]
	PushClipRect(column.ClipRect.Min, column.ClipRect.Max, false)
}

// Get into the columns background draw command (which is generally the same draw command as before we called BeginColumns)
PushColumnsBackground :: proc()
{
	window : ^ImGuiWindow = GetCurrentWindowRead()
	columns : ^ImGuiOldColumns = window.DC.CurrentColumns
	if columns.Count == 1 { return }

	// Optimization: avoid SetCurrentChannel() + PushClipRect()
	columns.HostBackupClipRect = window.ClipRect
	SetWindowClipRectBeforeSetChannel(window, columns.HostInitialClipRect)
	SetCurrentChannel(&columns.Splitter, window.DrawList, 0)
}

PopColumnsBackground :: proc()
{
	window : ^ImGuiWindow = GetCurrentWindowRead()
	columns : ^ImGuiOldColumns = window.DC.CurrentColumns
	if columns.Count == 1 { return }

	// Optimization: avoid PopClipRect() + SetCurrentChannel()
	SetWindowClipRectBeforeSetChannel(window, columns.HostBackupClipRect)
	SetCurrentChannel(&columns.Splitter, window.DrawList, columns.Current + 1)
}

FindOrCreateColumns :: proc(window : ^ImGuiWindow, id : ImGuiID) -> ^ImGuiOldColumns
{
	// We have few columns per window so for now we don't need bother much with turning this into a faster lookup.
	for n : i32 = 0; n < window.ColumnsStorage.Size; n += 1 { if window.ColumnsStorage.Data[n].ID == id { return &window.ColumnsStorage.Data[n] } }

	v : ImGuiOldColumns; init(&v)
	push_back(&window.ColumnsStorage, v)
	columns : ^ImGuiOldColumns = back(&window.ColumnsStorage)
	columns.ID = id
	return columns
}

GetColumnsID :: proc(str_id : string, columns_count : i32) -> ImGuiID
{
	window : ^ImGuiWindow = GetCurrentWindow()

	// Differentiate column ID with an arbitrary prefix for cases where users name their columns set the same as another widget.
	// In addition, when an identifier isn't explicitly provided we include the number of columns in the hash to make it uniquer.
	PushID(0x11223347 + (str_id != "" ? 0 : columns_count))
	id : ImGuiID = GetID(window, str_id != "" ? str_id : "columns")
	PopID()

	return id
}

BeginColumns :: proc(str_id : string, columns_count : i32, flags : ImGuiOldColumnFlags)
{
	g : ^ImGuiContext = GImGui
	window : ^ImGuiWindow = GetCurrentWindow()

	IM_ASSERT(columns_count >= 1)
	IM_ASSERT(window.DC.CurrentColumns == nil); // Nested columns are currently not supported

	// Acquire storage for the columns set
	id : ImGuiID = GetColumnsID(str_id, columns_count)
	columns : ^ImGuiOldColumns = FindOrCreateColumns(window, id)
	IM_ASSERT(columns.ID == id)
	columns.Current = 0
	columns.Count = columns_count
	columns.Flags = flags
	window.DC.CurrentColumns = columns
	window.DC.NavIsScrollPushableX = false; // Shortcut for NavUpdateCurrentWindowIsScrollPushableX();

	columns.HostCursorPosY = window.DC.CursorPos.y
	columns.HostCursorMaxPosX = window.DC.CursorMaxPos.x
	columns.HostInitialClipRect = window.ClipRect
	columns.HostBackupParentWorkRect = window.ParentWorkRect
	window.ParentWorkRect = window.WorkRect

	// Set state for first column
	// We aim so that the right-most column will have the same clipping width as other after being clipped by parent ClipRect
	column_padding : f32 = g.Style.ItemSpacing.x
	half_clip_extend_x : f32 = ImTrunc(ImMax(window.WindowPadding.x * 0.5, window.WindowBorderSize))
	max_1 : f32 = window.WorkRect.Max.x + column_padding - ImMax(column_padding - window.WindowPadding.x, 0.0)
	max_2 : f32 = window.WorkRect.Max.x + half_clip_extend_x
	columns.OffMinX = window.DC.Indent.x - column_padding + ImMax(column_padding - window.WindowPadding.x, 0.0)
	columns.OffMaxX = ImMax(ImMin(max_1, max_2) - window.Pos.x, columns.OffMinX + 1.0)
	columns.LineMaxY = window.DC.CursorPos.y; columns.LineMinY = columns.LineMaxY

	// Clear data if columns count changed
	if columns.Columns.Size != 0 && columns.Columns.Size != columns_count + 1 { resize(&columns.Columns, 0) }

	// Initialize default widths
	columns.IsFirstFrame = (columns.Columns.Size == 0)
	if columns.Columns.Size == 0 {
		reserve(&columns.Columns, columns_count + 1)
		for n : i32 = 0; n < columns_count + 1; n += 1 {
			column : ImGuiOldColumnData
			column.OffsetNorm = f32(n) / cast(f32) columns_count
			push_back(&columns.Columns, column)
		}
	}

	for n : i32 = 0; n < columns_count; n += 1 {
		// Compute clipping rectangle
		column : ^ImGuiOldColumnData = &columns.Columns.Data[n]
		clip_x1 : f32 = IM_ROUND(window.Pos.x + GetColumnOffset(n))
		clip_x2 : f32 = IM_ROUND(window.Pos.x + GetColumnOffset(n + 1) - 1.0)
		column.ClipRect = ImRect{{clip_x1, -FLT_MAX}, {clip_x2, +FLT_MAX}}
		ClipWithFull(&column.ClipRect, window.ClipRect)
	}

	if columns.Count > 1 {
		Split(&columns.Splitter, window.DrawList, 1 + columns.Count)
		SetCurrentChannel(&columns.Splitter, window.DrawList, 1)
		PushColumnClipRect(0)
	}

	// We don't generally store Indent.x inside ColumnsOffset because it may be manipulated by the user.
	offset_0 : f32 = GetColumnOffset(columns.Current)
	offset_1 : f32 = GetColumnOffset(columns.Current + 1)
	width : f32 = offset_1 - offset_0
	PushItemWidth(width * 0.65)
	window.DC.ColumnsOffset.x = ImMax(column_padding - window.WindowPadding.x, 0.0)
	window.DC.CursorPos.x = IM_TRUNC(window.Pos.x + window.DC.Indent.x + window.DC.ColumnsOffset.x)
	window.WorkRect.Max.x = window.Pos.x + offset_1 - column_padding
	window.WorkRect.Max.y = window.ContentRegionRect.Max.y
}

NextColumn :: proc()
{
	window : ^ImGuiWindow = GetCurrentWindow()
	if window.SkipItems || window.DC.CurrentColumns == nil { return }

	g : ^ImGuiContext = GImGui
	columns : ^ImGuiOldColumns = window.DC.CurrentColumns

	if columns.Count == 1 {
		window.DC.CursorPos.x = IM_TRUNC(window.Pos.x + window.DC.Indent.x + window.DC.ColumnsOffset.x)
		IM_ASSERT(columns.Current == 0)
		return
	}

	// Next column
	if pre_incr(&columns.Current) == columns.Count { columns.Current = 0 }

	PopItemWidth()

	// Optimization: avoid PopClipRect() + SetCurrentChannel() + PushClipRect()
	// (which would needlessly attempt to update commands in the wrong channel, then pop or overwrite them),
	column : ^ImGuiOldColumnData = &columns.Columns.Data[columns.Current]
	SetWindowClipRectBeforeSetChannel(window, column.ClipRect)
	SetCurrentChannel(&columns.Splitter, window.DrawList, columns.Current + 1)

	column_padding : f32 = g.Style.ItemSpacing.x
	columns.LineMaxY = ImMax(columns.LineMaxY, window.DC.CursorPos.y)
	if columns.Current > 0 {
		// Columns 1+ ignore IndentX (by canceling it out)
		// FIXME-COLUMNS: Unnecessary, could be locked?
		window.DC.ColumnsOffset.x = GetColumnOffset(columns.Current) - window.DC.Indent.x + column_padding
	}
	else {
		// New row/line: column 0 honor IndentX.
		window.DC.ColumnsOffset.x = ImMax(column_padding - window.WindowPadding.x, 0.0)
		window.DC.IsSameLine = false
		columns.LineMinY = columns.LineMaxY
	}
	window.DC.CursorPos.x = IM_TRUNC(window.Pos.x + window.DC.Indent.x + window.DC.ColumnsOffset.x)
	window.DC.CursorPos.y = columns.LineMinY
	window.DC.CurrLineSize = ImVec2{0.0, 0.0}
	window.DC.CurrLineTextBaseOffset = 0.0

	// FIXME-COLUMNS: Share code with BeginColumns() - move code on columns setup.
	offset_0 : f32 = GetColumnOffset(columns.Current)
	offset_1 : f32 = GetColumnOffset(columns.Current + 1)
	width : f32 = offset_1 - offset_0
	PushItemWidth(width * 0.65)
	window.WorkRect.Max.x = window.Pos.x + offset_1 - column_padding
}

EndColumns :: proc()
{
	g : ^ImGuiContext = GImGui
	window : ^ImGuiWindow = GetCurrentWindow()
	columns : ^ImGuiOldColumns = window.DC.CurrentColumns
	IM_ASSERT(columns != nil)

	PopItemWidth()
	if columns.Count > 1 {
		PopClipRect()
		Merge(&columns.Splitter, window.DrawList)
	}

	flags : ImGuiOldColumnFlags = columns.Flags
	columns.LineMaxY = ImMax(columns.LineMaxY, window.DC.CursorPos.y)
	window.DC.CursorPos.y = columns.LineMaxY
	if (flags & ImGuiOldColumnFlags_.ImGuiOldColumnFlags_GrowParentContentsSize) == {} {
		// Restore cursor max pos, as columns don't grow parent
		window.DC.CursorMaxPos.x = columns.HostCursorMaxPosX
	}

	// Draw columns borders and handle resize
	// The IsBeingResized flag ensure we preserve pre-resize columns width so back-and-forth are not lossy
	is_being_resized : bool = false
	if (flags & ImGuiOldColumnFlags_.ImGuiOldColumnFlags_NoBorder) == {} && !window.SkipItems {
		// We clip Y boundaries CPU side because very long triangles are mishandled by some GPU drivers.
		y1 : f32 = ImMax(columns.HostCursorPosY, window.ClipRect.Min.y)
		y2 : f32 = ImMin(window.DC.CursorPos.y, window.ClipRect.Max.y)
		dragging_column : i32 = -1
		for n : i32 = 1; n < columns.Count; n += 1 {
			column : ^ImGuiOldColumnData = &columns.Columns.Data[n]
			x : f32 = window.Pos.x + GetColumnOffset(n)
			column_id : ImGuiID = columns.ID + ImGuiID(n)
			column_hit_hw : f32 = ImTrunc(COLUMNS_HIT_RECT_HALF_THICKNESS * g.CurrentDpiScale)
			column_hit_rect : ImRect; init(&column_hit_rect, ImVec2{x - column_hit_hw, y1}, ImVec2{x + column_hit_hw, y2})
			if !ItemAdd(column_hit_rect, column_id, nil, ImGuiItemFlags_.ImGuiItemFlags_NoNav) { continue }

			hovered : bool = false; held : bool = false
			if (flags & ImGuiOldColumnFlags_.ImGuiOldColumnFlags_NoResize) == {} {
				ButtonBehavior(column_hit_rect, column_id, &hovered, &held)
				if hovered || held { SetMouseCursor(ImGuiMouseCursor_.ImGuiMouseCursor_ResizeEW) }
				if held && (column.Flags & ImGuiOldColumnFlags_.ImGuiOldColumnFlags_NoResize) == {} { dragging_column = n }
			}

			// Draw column
			col : ImU32 = GetColorU32(held ? ImGuiCol_.ImGuiCol_SeparatorActive : hovered ? ImGuiCol_.ImGuiCol_SeparatorHovered : ImGuiCol_.ImGuiCol_Separator)
			xi : f32 = IM_TRUNC(x)
			AddLine(window.DrawList, ImVec2{xi, y1 + 1.0}, ImVec2{xi, y2}, col)
		}

		// Apply dragging after drawing the column lines, so our rendered lines are in sync with how items were displayed during the frame.
		if dragging_column != -1 {
			if !columns.IsBeingResized { for n : i32 = 0; n < columns.Count + 1; n += 1 { columns.Columns.Data[n].OffsetNormBeforeResize = columns.Columns.Data[n].OffsetNorm } }
			is_being_resized = true; columns.IsBeingResized = is_being_resized
			x : f32 = GetDraggedColumnOffset(columns, dragging_column)
			SetColumnOffset(dragging_column, x)
		}
	}
	columns.IsBeingResized = is_being_resized

	window.WorkRect = window.ParentWorkRect
	window.ParentWorkRect = columns.HostBackupParentWorkRect
	window.DC.CurrentColumns = nil
	window.DC.ColumnsOffset.x = 0.0
	window.DC.CursorPos.x = IM_TRUNC(window.Pos.x + window.DC.Indent.x + window.DC.ColumnsOffset.x)
	NavUpdateCurrentWindowIsScrollPushableX()
}

Columns :: proc(columns_count : i32, id : string, borders : bool)
{
	window : ^ImGuiWindow = GetCurrentWindow()
	IM_ASSERT(columns_count >= 1)

	flags : ImGuiOldColumnFlags = (borders ? {} : ImGuiOldColumnFlags_.ImGuiOldColumnFlags_NoBorder)
	//flags |= ImGuiOldColumnFlags_NoPreserveWidths; // NB: Legacy behavior
	columns : ^ImGuiOldColumns = window.DC.CurrentColumns
	if columns != nil && columns.Count == columns_count && columns.Flags == flags { return }

	if columns != nil { EndColumns() }

	if columns_count != 1 { BeginColumns(id, columns_count, flags) }
}


